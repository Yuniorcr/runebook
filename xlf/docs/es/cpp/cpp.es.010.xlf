<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="5de0dced78d11272f963c83043ebca189594c138" translate="yes" xml:space="preserve">
          <source>A member of a class &lt;code&gt;T&lt;/code&gt; cannot use &lt;code&gt;T&lt;/code&gt; as its name if the member is a static data member, a member function, a member type, a member template , an enumerator of an unscoped enumeration, a member of a member anonymous union. However, a non-static data member may use the name &lt;code&gt;T&lt;/code&gt; as long as there are no user-declared constructors.</source>
          <target state="translated">Un miembro de una clase &lt;code&gt;T&lt;/code&gt; no puede usar &lt;code&gt;T&lt;/code&gt; como su nombre si el miembro es un miembro de datos est&amp;aacute;ticos, una funci&amp;oacute;n miembro, un tipo de miembro, una plantilla de miembro, un enumerador de una enumeraci&amp;oacute;n sin &amp;aacute;mbito, un miembro de una uni&amp;oacute;n an&amp;oacute;nima miembro. Sin embargo, un miembro de datos no est&amp;aacute;tico puede usar el nombre &lt;code&gt;T&lt;/code&gt; siempre que no haya constructores declarados por el usuario.</target>
        </trans-unit>
        <trans-unit id="b4ca9ae096395091286ce2f97b84c334ccf6644c" translate="yes" xml:space="preserve">
          <source>A member or a member template of a class template may be explicitly specialized for a given implicit instantiation of the class template, even if the member or member template is defined in the class template definition.</source>
          <target state="translated">Un miembro o una plantilla de miembro de una plantilla de clase puede estar explícitamente especializado para una instanciación implícita dada de la plantilla de clase,incluso si la plantilla de miembro o de miembro está definida en la definición de la plantilla de clase.</target>
        </trans-unit>
        <trans-unit id="3cc4194447e3feb7759961528ba2acc170fa12c7" translate="yes" xml:space="preserve">
          <source>A modifiable lvalue may be used as the left-hand operand of the built-in assignment and compound assignment operators.</source>
          <target state="translated">Se puede utilizar un valor l modificable como operando izquierdo de los operadores de asignación incorporada y de asignación compuesta.</target>
        </trans-unit>
        <trans-unit id="8c00f6a72efb6556fa9292b04ea6629a5f0cab13" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_day&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/1&lt;/code&gt;.</source>
          <target state="translated">Una forma m&amp;aacute;s conveniente de construir un &lt;code&gt;month_day&lt;/code&gt; es con el &lt;code&gt;operator/&lt;/code&gt; , por ejemplo, &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e596eb0f0194c2c2e4167ab358138e5b60c14287" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_day_last&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Una forma m&amp;aacute;s conveniente de construir un &lt;code&gt;month_day_last&lt;/code&gt; es con el &lt;code&gt;operator/&lt;/code&gt; , por ejemplo, &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a8c5116dd01717b8a1f75b9620c596b6f5367a7" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_weekday&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[2]&lt;/code&gt;.</source>
          <target state="translated">Una forma m&amp;aacute;s conveniente de construir un &lt;code&gt;month_weekday&lt;/code&gt; es con el &lt;code&gt;operator/&lt;/code&gt; , por ejemplo, &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[2]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4752a9f37cdb6658a9a8728cdd2291f0b5ec64d6" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;month_weekday_last&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="translated">Una manera m&amp;aacute;s conveniente de construir un &lt;code&gt;month_weekday_last&lt;/code&gt; es con el &lt;code&gt;operator/&lt;/code&gt; , por ejemplo, &lt;code&gt;&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;/&lt;a href=&quot;../weekday&quot;&gt;std::chrono::Sunday&lt;/a&gt;[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7327a074e15b5c31502879c12e39a884355916ba" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;weekday_indexed&lt;/code&gt; is with &lt;code&gt;weekday&lt;/code&gt;'s &lt;code&gt;operator[]&lt;/code&gt;, i.e., &lt;code&gt;wd[index]&lt;/code&gt;.</source>
          <target state="translated">Una forma m&amp;aacute;s conveniente de construir un &lt;code&gt;weekday_indexed&lt;/code&gt; es con el &lt;code&gt;operator[]&lt;/code&gt; &lt;code&gt;weekday&lt;/code&gt; la semana [] , es decir, &lt;code&gt;wd[index]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c209a7c3ca3ab0475649b12caaff743d2fbd1dd1" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;weekday_last&lt;/code&gt; is with &lt;code&gt;weekday&lt;/code&gt;'s &lt;code&gt;operator[]&lt;/code&gt;, i.e., &lt;code&gt;wd[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt;.</source>
          <target state="translated">Una forma m&amp;aacute;s conveniente de construir un &lt;code&gt;weekday_last&lt;/code&gt; &lt;code&gt;weekday&lt;/code&gt; la semana es con el &lt;code&gt;operator[]&lt;/code&gt; d&amp;iacute;a de la semana [] , es decir, &lt;code&gt;wd[&lt;a href=&quot;../last_spec&quot;&gt;std::chrono::last&lt;/a&gt;]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="653ca78a80e72fd3496d4da44b432d7ef45908d8" translate="yes" xml:space="preserve">
          <source>A more convenient way to construct a &lt;code&gt;year_month&lt;/code&gt; is with &lt;code&gt;operator/&lt;/code&gt;, e.g., &lt;code&gt;2007y/&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Una forma m&amp;aacute;s conveniente de construir un &lt;code&gt;year_month&lt;/code&gt; es con el &lt;code&gt;operator/&lt;/code&gt; , por ejemplo, &lt;code&gt;2007y/&lt;a href=&quot;../month&quot;&gt;std::chrono::April&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f1d73be6c54e98a146e6c453de6dea68f79b357" translate="yes" xml:space="preserve">
          <source>A move assignment operator of class &lt;code&gt;T&lt;/code&gt; is a non-template &lt;a href=&quot;member_functions&quot;&gt;non-static member function&lt;/a&gt; with the name &lt;code&gt;operator=&lt;/code&gt; that takes exactly one parameter of type &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt;, or &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Un operador de asignaci&amp;oacute;n de movimiento de clase &lt;code&gt;T&lt;/code&gt; es una &lt;a href=&quot;member_functions&quot;&gt;funci&amp;oacute;n miembro no est&amp;aacute;tica no est&amp;aacute;tica&lt;/a&gt; con el nombre &lt;code&gt;operator=&lt;/code&gt; que toma exactamente un par&amp;aacute;metro de tipo &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt; o &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7677c3fc7a7f1b5d05a4ba8d65de62c8c77ad6c9" translate="yes" xml:space="preserve">
          <source>A move constructor of class &lt;code&gt;T&lt;/code&gt; is a non-template &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; whose first parameter is &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt;, &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt;, or &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt;, and either there are no other parameters, or the rest of the parameters all have default values.</source>
          <target state="translated">Un constructor de movimiento de clase &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;constructor&quot;&gt;constructor que&lt;/a&gt; no es de plantilla cuyo primer par&amp;aacute;metro es &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;const T&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;volatile T&amp;amp;&amp;amp;&lt;/code&gt; o &lt;code&gt;const volatile T&amp;amp;&amp;amp;&lt;/code&gt; , y o bien no hay otros par&amp;aacute;metros, o el resto de los par&amp;aacute;metros tienen valores predeterminados.</target>
        </trans-unit>
        <trans-unit id="16af80cf4cdc5acb425ed5fb5f2a532dceaaf925" translate="yes" xml:space="preserve">
          <source>A multibyte character string is layout-compatible with null-terminated byte string (NTBS), that is, can be stored, copied, and examined using the same facilities, except for calculating the number of characters. If the correct locale is in effect, I/O functions also handle multibyte strings. Multibyte strings can be converted to and from wide strings using the &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; member functions, &lt;code&gt;&lt;a href=&quot;../locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;, or the following locale-dependent conversion functions:</source>
          <target state="translated">Una cadena de caracteres multibyte es compatible con el dise&amp;ntilde;o con una cadena de bytes terminada en nulo (NTBS), es decir, puede almacenarse, copiarse y examinarse utilizando las mismas facilidades, excepto para calcular el n&amp;uacute;mero de caracteres. Si la configuraci&amp;oacute;n regional correcta est&amp;aacute; vigente, las funciones de E / S tambi&amp;eacute;n manejan cadenas multibyte. Cadenas multibyte se pueden convertir en y a partir de cadenas de ancho utilizando los &lt;code&gt;&lt;a href=&quot;../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; funciones miembro, &lt;code&gt;&lt;a href=&quot;../locale/wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; , o las siguientes funciones de conversi&amp;oacute;n dependientes del entorno local:</target>
        </trans-unit>
        <trans-unit id="d98fb2bdc836fccaa6d115487be59107743d4bcc" translate="yes" xml:space="preserve">
          <source>A name declared non-deprecated may be redeclared deprecated. A name declared deprecated cannot be un-deprecated by redeclaring it without this attribute.</source>
          <target state="translated">Un nombre declarado no depreciado puede ser redeclarado depreciado.Un nombre declarado no depreciado no puede ser redeclarado sin este atributo.</target>
        </trans-unit>
        <trans-unit id="9645e04714e8aeab4e16fb75044a74252ed38005" translate="yes" xml:space="preserve">
          <source>A name first declared in a friend declaration within class or class template X becomes a member of the innermost enclosing namespace of X, but is not visible for lookup (except argument-dependent lookup that considers X) unless a matching declaration at the namespace scope is provided - see &lt;a href=&quot;namespace#Namespaces&quot;&gt;namespaces&lt;/a&gt; for details.</source>
          <target state="translated">Un nombre declarado por primera vez en una declaraci&amp;oacute;n de amigo dentro de la clase o la plantilla de clase X se convierte en un miembro del espacio de nombres m&amp;aacute;s cerrado de X, pero no es visible para la b&amp;uacute;squeda (excepto la b&amp;uacute;squeda dependiente de argumentos que considera X) a menos que haya una declaraci&amp;oacute;n coincidente en el &amp;aacute;mbito del espacio de nombres. proporcionado: vea los &lt;a href=&quot;namespace#Namespaces&quot;&gt;espacios&lt;/a&gt; de nombres para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="3933fe1919f27704fb38fb769004562260d8099c" translate="yes" xml:space="preserve">
          <source>A name is classified as a member of the current instantiation if it is.</source>
          <target state="translated">Un nombre se clasifica como miembro de la instanciación actual si lo es.</target>
        </trans-unit>
        <trans-unit id="9ddc18654271b83daffe509c6b14c3572df5edd8" translate="yes" xml:space="preserve">
          <source>A name that denotes object, reference, function, type, template, namespace, or value, may have</source>
          <target state="translated">Un nombre que denota objeto,referencia,función,tipo,plantilla,espacio de nombres o valor,puede tener</target>
        </trans-unit>
        <trans-unit id="853d1578fabbd2c82d82a0fe09f5702733aba960" translate="yes" xml:space="preserve">
          <source>A name that is accessible through multiple paths in the inheritance graph has the access of the path with the most access:</source>
          <target state="translated">Un nombre que es accesible a través de múltiples caminos en el gráfico de la herencia tiene el acceso del camino con más acceso:</target>
        </trans-unit>
        <trans-unit id="6e45514825dadadd15b3e67c603ee32f7155b58a" translate="yes" xml:space="preserve">
          <source>A name that is private according to unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, may be accessible through qualified name lookup:</source>
          <target state="translated">Un nombre que es privado de acuerdo con la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda de nombre&lt;/a&gt; no calificado , puede ser accesible a trav&amp;eacute;s de la b&amp;uacute;squeda de nombre calificado:</target>
        </trans-unit>
        <trans-unit id="39b86d73926de6a377e6b550b9b013a7e40df60f" translate="yes" xml:space="preserve">
          <source>A namespace member that was declared within a namespace body may be defined or redeclared outside of it using explicit qualification.</source>
          <target state="translated">Un miembro del espacio de nombres que haya sido declarado dentro de un organismo del espacio de nombres puede definirse o redeclararse fuera de él utilizando una calificación explícita.</target>
        </trans-unit>
        <trans-unit id="039345001a9866dd339fc34b017f987d45772976" translate="yes" xml:space="preserve">
          <source>A narrow character string is created as if by a call to &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(spec, v)&lt;/code&gt; in the &quot;C&quot; locale, where &lt;code&gt;spec&lt;/code&gt; is the chosen conversion specifier.</source>
          <target state="translated">Se crea una cadena de caracteres angosta como si fuera una llamada a &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::printf&lt;/a&gt;(spec, v)&lt;/code&gt; en la configuraci&amp;oacute;n regional &quot;C&quot;, donde &lt;code&gt;spec&lt;/code&gt; es el especificador de conversi&amp;oacute;n elegido.</target>
        </trans-unit>
        <trans-unit id="105e80128937d46ea748308c3640f225aa1f1163" translate="yes" xml:space="preserve">
          <source>A negative value of &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; causes &lt;code&gt;mktime&lt;/code&gt; to attempt to determine if Daylight Saving Time was in effect.</source>
          <target state="translated">Un valor negativo de &lt;code&gt;time-&amp;gt;tm_isdst&lt;/code&gt; hace que &lt;code&gt;mktime&lt;/code&gt; intente determinar si el horario de verano estaba vigente.</target>
        </trans-unit>
        <trans-unit id="93b6295b9130f095206e2ffbf6e1a198ffb81cdb" translate="yes" xml:space="preserve">
          <source>A nested requirement has the form.</source>
          <target state="translated">Un requisito anidado tiene la forma.</target>
        </trans-unit>
        <trans-unit id="aab04a416d50d68103518e61edffcc3d876b52d0" translate="yes" xml:space="preserve">
          <source>A new &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; object, constructed from correctly copied allocators.</source>
          <target state="translated">Un nuevo objeto &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; , construido a partir de asignadores copiados correctamente.</target>
        </trans-unit>
        <trans-unit id="b3fea0735582c1d92ba9ca4265c504066694d506" translate="yes" xml:space="preserve">
          <source>A newly constructed object of type &lt;code&gt;pos_type&lt;/code&gt; which stores the resulting file position, or &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; on failure.</source>
          <target state="translated">Un objeto reci&amp;eacute;n construido de tipo &lt;code&gt;pos_type&lt;/code&gt; que almacena la posici&amp;oacute;n del archivo resultante, o &lt;code&gt;pos_type(off_type(-1))&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="7812e17881f85045a11332d843939ff143d1510b" translate="yes" xml:space="preserve">
          <source>A newly opened stream has no orientation. The first call to &lt;code&gt;std::fwide&lt;/code&gt; or to any I/O function establishes the orientation: wide I/O function makes the stream wide-oriented, narrow I/O function makes the stream narrow-oriented. Once set, orientation can only be changed with &lt;code&gt;&lt;a href=&quot;c/freopen&quot;&gt;std::freopen&lt;/a&gt;&lt;/code&gt;. Narrow I/O functions cannot be called on a wide-oriented stream, wide I/O functions cannot be called on a narrow-oriented stream. Wide I/O functions convert between wide and multibyte characters as if by calling &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt;. Unlike the multibyte character strings that are valid in a program, multibyte characters in the file may contain embedded nulls and do not have to begin or end in the initial shift state.</source>
          <target state="translated">Una secuencia reci&amp;eacute;n abierta no tiene orientaci&amp;oacute;n. La primera llamada a &lt;code&gt;std::fwide&lt;/code&gt; o a cualquier funci&amp;oacute;n de E / S establece la orientaci&amp;oacute;n: la funci&amp;oacute;n de E / S amplia hace que la secuencia sea de orientaci&amp;oacute;n amplia, la funci&amp;oacute;n de E / S estrecha hace que la secuencia sea de orientaci&amp;oacute;n estrecha. Una vez establecida, la orientaci&amp;oacute;n solo se puede cambiar con &lt;code&gt;&lt;a href=&quot;c/freopen&quot;&gt;std::freopen&lt;/a&gt;&lt;/code&gt; . Las funciones de E / S estrechas no se pueden invocar en una secuencia orientada de forma amplia, las funciones de E / S amplias no se pueden invocar en una secuencia de orientaci&amp;oacute;n estrecha. Las funciones de E / S amplias convierten entre caracteres anchos y multibyte como si llamaran &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcrtomb&quot;&gt;std::wcrtomb&lt;/a&gt;&lt;/code&gt; . A diferencia de las cadenas de caracteres multibyte que son v&amp;aacute;lidas en un programa, los caracteres multibyte en el archivo pueden contener nulos incrustados y no tienen que comenzar o finalizar en el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="869a3424851c79242efec3e07d77e356612111d6" translate="yes" xml:space="preserve">
          <source>A noexcept-specification of a function is considered to be</source>
          <target state="translated">Se considera que la especificación de una función sin excepción es</target>
        </trans-unit>
        <trans-unit id="6aee1e7c886fbccbfdc8526a802aa2e4e5e0f970" translate="yes" xml:space="preserve">
          <source>A non-class non-array prvalue cannot be &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;. (Note: a function call or cast expression may result in a prvalue of non-class cv-qualified type, but the cv-qualifier is immediately stripped out.)</source>
          <target state="translated">Un prvalue no-class no-array no puede ser &lt;a href=&quot;cv&quot;&gt;calificado por cv&lt;/a&gt; . (Nota: una llamada a funci&amp;oacute;n o una expresi&amp;oacute;n de conversi&amp;oacute;n puede dar como resultado un prvalor de tipo no calificado con cv de clase, pero el calificador cv se elimina inmediatamente).</target>
        </trans-unit>
        <trans-unit id="9c16e8da66b88facf18bcff094f8898640478943" translate="yes" xml:space="preserve">
          <source>A non-const rvalue of type &lt;code&gt;X::node_type&lt;/code&gt;</source>
          <target state="translated">Un valor no constante de tipo &lt;code&gt;X::node_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cbfbc01b79d14846f146d50d1446c4035f6cd1b8" translate="yes" xml:space="preserve">
          <source>A non-explicit constructor that accepts an argument of type (possibly const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt;, which stores that offset and and value-initializes the state object. This constructor must also accept the special value &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;(-1)&lt;/code&gt;: the &lt;code&gt;std::fpos&lt;/code&gt; constructed in this manner is returned by some stream operations to indicate errors.</source>
          <target state="translated">Un constructor no expl&amp;iacute;cito que acepta un argumento de tipo (posiblemente const) &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;&lt;/code&gt; , que almacena ese desplazamiento e inicializa el objeto de estado. Este constructor tambi&amp;eacute;n debe aceptar el valor especial &lt;code&gt;&lt;a href=&quot;streamoff&quot;&gt;std::streamoff&lt;/a&gt;(-1)&lt;/code&gt; : el &lt;code&gt;std::fpos&lt;/code&gt; construido de esta manera es devuelto por algunas operaciones de flujo para indicar errores.</target>
        </trans-unit>
        <trans-unit id="7c5f2f406d4c6d5a6be68be9a352e598e29e63cd" translate="yes" xml:space="preserve">
          <source>A non-member function definition may appear at namespace scope only (there are no nested functions). A &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt; definition may also appear in the body of a &lt;a href=&quot;class&quot;&gt;class definition&lt;/a&gt;. They have the following syntax:</source>
          <target state="translated">Una definici&amp;oacute;n de funci&amp;oacute;n no miembro puede aparecer solo en el &amp;aacute;mbito del espacio de nombres (no hay funciones anidadas). Una definici&amp;oacute;n de &lt;a href=&quot;member_functions&quot;&gt;funci&amp;oacute;n miembro&lt;/a&gt; tambi&amp;eacute;n puede aparecer en el cuerpo de una &lt;a href=&quot;class&quot;&gt;definici&amp;oacute;n de clase&lt;/a&gt; . Tienen la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="a8537e5e8c50ad3a4da6590cf63b9c692c279951" translate="yes" xml:space="preserve">
          <source>A non-placement allocation or deallocation function for a class is odr-used by the definition of a constructor of that class.</source>
          <target state="translated">La definición de un constructor de una clase utiliza una función de no colocación o de colocación de una clase.</target>
        </trans-unit>
        <trans-unit id="54709ac99fdc50ecc6383b09c5e6260c6f17f5a9" translate="yes" xml:space="preserve">
          <source>A non-placement deallocation function for a class is odr-used by the definition of the destructor of that class, or by being selected by the lookup at the point of definition of a virtual destructor</source>
          <target state="translated">Una función de no colocación de una clase es odr-utilizada por la definición del destructor de esa clase,o por ser seleccionada por la búsqueda en el punto de definición de un destructor virtual</target>
        </trans-unit>
        <trans-unit id="57427d16d98090f308df82f3319c4bb23d4b400e" translate="yes" xml:space="preserve">
          <source>A non-static member function can be declared with a const, volatile, or const volatile qualifier (this qualifier appears after the parameter list in the &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;). Differently cv-qualified functions have different types and so may overload each other.</source>
          <target state="translated">Una funci&amp;oacute;n miembro no est&amp;aacute;tica se puede declarar con un calificador const, vol&amp;aacute;til o const vol&amp;aacute;til (este calificador aparece despu&amp;eacute;s de la lista de par&amp;aacute;metros en la &lt;a href=&quot;function&quot;&gt;declaraci&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; ). Las funciones con calificaci&amp;oacute;n cv diferente tienen diferentes tipos y, por lo tanto, pueden sobrecargarse entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="6269d14f99ea7d83ea3dec1f28326b8c6d5c5ecd" translate="yes" xml:space="preserve">
          <source>A non-static member function can be declared with no ref-qualifier, with an lvalue ref-qualifier (the token &lt;code&gt;&amp;amp;&lt;/code&gt; after the parameter list) or the rvalue ref-qualifier (the token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; after the parameter list). During &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, non-static cv-qualified member function of class X is treated as follows:</source>
          <target state="translated">Se puede declarar una funci&amp;oacute;n miembro no est&amp;aacute;tica sin calificador de referencia, con un calificador de referencia lvalue (el token &lt;code&gt;&amp;amp;&lt;/code&gt; despu&amp;eacute;s de la lista de par&amp;aacute;metros) o el calificador de ref rvalue (el token &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; despu&amp;eacute;s de la lista de par&amp;aacute;metros). Durante la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; , la funci&amp;oacute;n miembro no est&amp;aacute;tica calificada por cv de clase X se trata de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="c58ef98b1f97443f7f30d89e9dea4b508149bdcf" translate="yes" xml:space="preserve">
          <source>A non-static member function is a function that is declared in a &lt;a href=&quot;class&quot;&gt;member specification&lt;/a&gt; of a class without a &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; or &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; specifier.</source>
          <target state="translated">Una funci&amp;oacute;n miembro no est&amp;aacute;tica es una funci&amp;oacute;n que se declara en una &lt;a href=&quot;class&quot;&gt;especificaci&amp;oacute;n&lt;/a&gt; de miembro de una clase sin un especificador &lt;a href=&quot;static&quot;&gt;est&amp;aacute;tico&lt;/a&gt; o &lt;a href=&quot;friend&quot;&gt;amigo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="327b4ee07e641d05a96006e2735a0db3601ea014" translate="yes" xml:space="preserve">
          <source>A non-static member function may be declared</source>
          <target state="translated">La función de un miembro no estático puede ser declarada</target>
        </trans-unit>
        <trans-unit id="8309388308c23f79d7667a2481e8485faf7c4b76" translate="yes" xml:space="preserve">
          <source>A non-static member function of class X may be called.</source>
          <target state="translated">Una función de miembro no estático de la clase X puede ser llamada.</target>
        </trans-unit>
        <trans-unit id="3dd8b8cff9d7f40f60c773d5633d2a93e250abe4" translate="yes" xml:space="preserve">
          <source>A non-template function is always distinct from a template specialization with the same type. Specializations of different function templates are always distinct from each other even if they have the same type. Two function templates with the same return type and the same parameter list are distinct and can be distinguished with explicit template argument list.</source>
          <target state="translated">Una función no relacionada con la plantilla siempre es distinta de una especialización de la plantilla con el mismo tipo.Las especializaciones de las diferentes plantillas de funciones son siempre distintas entre sí,incluso si tienen el mismo tipo.Dos plantillas de funciones con el mismo tipo de retorno y la misma lista de parámetros son distintas y pueden distinguirse con la lista de argumentos explícitos de la plantilla.</target>
        </trans-unit>
        <trans-unit id="ec8d1e0238ca169189cb132939968a32e225940d" translate="yes" xml:space="preserve">
          <source>A non-template member function and a template member function with the same name may be declared. In case of conflict (when some template specialization matches the non-template function signature exactly), use of that name and type refers to the non-template member unless an explicit template argument list is supplied.</source>
          <target state="translated">Se puede declarar una función de miembro no modelo y una función de miembro modelo con el mismo nombre.En caso de conflicto (cuando alguna especialización de la plantilla coincide exactamente con la firma de la función no perteneciente a la plantilla),el uso de ese nombre y tipo se refiere al miembro no perteneciente a la plantilla a menos que se proporcione una lista de argumentos explícitos de la plantilla.</target>
        </trans-unit>
        <trans-unit id="1d14804af608dab04a2318dab2393b02651d54c9" translate="yes" xml:space="preserve">
          <source>A notable implementation where &lt;code&gt;std::random_device&lt;/code&gt; is deterministic is MinGW (&lt;a href=&quot;https://sourceforge.net/p/mingw-w64/bugs/338/&quot;&gt;bug 338&lt;/a&gt;), although replacement implementations exist, such as &lt;a href=&quot;https://github.com/euloanty/mingw-std-random_device&quot;&gt;mingw-std-random_device&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n notable donde &lt;code&gt;std::random_device&lt;/code&gt; es determinista es MinGW ( &lt;a href=&quot;https://sourceforge.net/p/mingw-w64/bugs/338/&quot;&gt;error 338&lt;/a&gt; ), aunque existen implementaciones de reemplazo, como &lt;a href=&quot;https://github.com/euloanty/mingw-std-random_device&quot;&gt;mingw-std-random_device&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d97541bdffeb4e63b35a3a02617d21fc06220467" translate="yes" xml:space="preserve">
          <source>A null pointer constant may be &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to any pointer type; such conversion results in the null pointer value of that type. If a null pointer constant has integer type, it may be converted to a prvalue of type &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Una constante de puntero nulo puede &lt;a href=&quot;../language/implicit_cast&quot;&gt;convertirse impl&amp;iacute;citamente&lt;/a&gt; a cualquier tipo de puntero; dicha conversi&amp;oacute;n da como resultado el valor de puntero nulo de ese tipo. Si una constante de puntero nulo tiene un tipo entero, se puede convertir a un prvalor de tipo &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1572c78e938eb0e97af4e78573d5ecf38073eb0" translate="yes" xml:space="preserve">
          <source>A null-terminated byte string (NTBS) is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character). Each byte in a byte string encodes one character of some character set. For example, the character array &lt;code&gt;{'\x63', '\x61', '\x74', '\0'}&lt;/code&gt; is an NTBS holding the string &lt;code&gt;&quot;cat&quot;&lt;/code&gt; in ASCII encoding.</source>
          <target state="translated">Una cadena de bytes con terminaci&amp;oacute;n nula (NTBS) es una secuencia de bytes distintos de cero seguida de un byte con valor cero (el car&amp;aacute;cter nulo final). Cada byte en una cadena de bytes codifica un car&amp;aacute;cter de alg&amp;uacute;n conjunto de caracteres. Por ejemplo, la matriz de caracteres &lt;code&gt;{'\x63', '\x61', '\x74', '\0'}&lt;/code&gt; es un NTBS que contiene la cadena &lt;code&gt;&quot;cat&quot;&lt;/code&gt; en codificaci&amp;oacute;n ASCII.</target>
        </trans-unit>
        <trans-unit id="3b3fe15454343ce4cbfa8b2d64edd72623154c83" translate="yes" xml:space="preserve">
          <source>A null-terminated multibyte string (NTMBS), or &quot;multibyte string&quot;, is a sequence of nonzero bytes followed by a byte with value zero (the terminating null character).</source>
          <target state="translated">Una cadena multibyte terminada en cero (NTMBS),o &quot;cadena multibyte&quot;,es una secuencia de bytes no nulos seguida de un byte con valor cero (el carácter nulo de terminación).</target>
        </trans-unit>
        <trans-unit id="d3f369b83e123d7a5137bbdf57df583877994fe3" translate="yes" xml:space="preserve">
          <source>A null-terminated wide string is a sequence of valid wide characters, ending with a null character.</source>
          <target state="translated">Una cadena ancha terminada en cero es una secuencia de caracteres anchos válidos,terminada con un carácter nulo.</target>
        </trans-unit>
        <trans-unit id="f262d7c58008e0145d059876c3647b11a00b98dc" translate="yes" xml:space="preserve">
          <source>A numeric array containing elements with values obtained by applying corresponding operator to the values in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Una matriz num&amp;eacute;rica que contiene elementos con valores obtenidos aplicando el operador correspondiente a los valores en &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="477cf9e2034b21d56b53532edeb5fa0ff54341d3" translate="yes" xml:space="preserve">
          <source>A numeric array containing the results of computation of inverse tangent.</source>
          <target state="translated">Un conjunto numérico que contiene los resultados del cálculo de la tangente inversa.</target>
        </trans-unit>
        <trans-unit id="d991ad4854aaf7bce85259a803aef1efb1b7db52" translate="yes" xml:space="preserve">
          <source>A numeric array containing the results of exponentiation.</source>
          <target state="translated">Una matriz numérica que contiene los resultados de la exponenciación.</target>
        </trans-unit>
        <trans-unit id="2b3cfb0c9df6711008dfe1dd42137fa47903d378" translate="yes" xml:space="preserve">
          <source>A numeric array of &lt;code&gt;bool&lt;/code&gt; containing comparison results of corresponding elements.</source>
          <target state="translated">Una matriz num&amp;eacute;rica de &lt;code&gt;bool&lt;/code&gt; que contiene resultados de comparaci&amp;oacute;n de elementos correspondientes.</target>
        </trans-unit>
        <trans-unit id="bd2bad531f6152b88c43bb2fbb72d8dcd8b7df39" translate="yes" xml:space="preserve">
          <source>A numeric value &lt;code&gt;n&lt;/code&gt; can be converted to a byte value using &lt;code&gt;std::byte{n}&lt;/code&gt;, due to C++17 relaxed enum class initialization rules.</source>
          <target state="translated">Un valor num&amp;eacute;rico &lt;code&gt;n&lt;/code&gt; se puede convertir en un valor de byte usando &lt;code&gt;std::byte{n}&lt;/code&gt; , debido a las reglas de inicializaci&amp;oacute;n de clase de enumeraci&amp;oacute;n relajada de C ++ 17.</target>
        </trans-unit>
        <trans-unit id="c9a28ea00b0028d881fe812f3c217cb4fc954bd0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a &lt;a href=&quot;direct_initialization&quot;&gt;direct initializer&lt;/a&gt;, a &lt;a href=&quot;explicit_cast&quot;&gt;function-style cast&lt;/a&gt;, and other contexts (&lt;a href=&quot;constructor&quot;&gt;member initializer&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, etc) in which case the rules are identical to the rules for a function call expression above.</source>
          <target state="translated">Una expansi&amp;oacute;n de paquete puede aparecer dentro de los par&amp;eacute;ntesis de un &lt;a href=&quot;direct_initialization&quot;&gt;inicializador directo&lt;/a&gt; , una &lt;a href=&quot;explicit_cast&quot;&gt;conversi&amp;oacute;n de estilo de funci&amp;oacute;n&lt;/a&gt; y otros contextos ( &lt;a href=&quot;constructor&quot;&gt;inicializador de miembro&lt;/a&gt; , &lt;a href=&quot;new&quot;&gt;nueva expresi&amp;oacute;n&lt;/a&gt; , etc.) en cuyo caso las reglas son id&amp;eacute;nticas a las reglas para una expresi&amp;oacute;n de llamada de funci&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="2677c415425384fd8d2e20b4d33138e46186a2e0" translate="yes" xml:space="preserve">
          <source>A pack expansion may appear inside the parentheses of a function call operator, in which case the largest expression or braced-init-list to the left of the ellipsis is the pattern that is expanded.</source>
          <target state="translated">Una expansión de paquete puede aparecer dentro de los paréntesis de un operador de llamada de función,en cuyo caso la expresión más grande o la lista de &quot;braced-init-list&quot; a la izquierda de la elipse es el patrón que se expande.</target>
        </trans-unit>
        <trans-unit id="e1ace690cd25f5f4ab9e5665bb9125a09841bb96" translate="yes" xml:space="preserve">
          <source>A pack expansion may designate the list of base classes in a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. Typically, this also means that the constructor needs to use a pack expansion in the &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; to call the constructors of these bases:</source>
          <target state="translated">Una expansi&amp;oacute;n de paquete puede designar la lista de clases base en una &lt;a href=&quot;class&quot;&gt;declaraci&amp;oacute;n de clase&lt;/a&gt; . T&amp;iacute;picamente, esto tambi&amp;eacute;n significa que el constructor necesita usar una expansi&amp;oacute;n de paquete en la &lt;a href=&quot;constructor&quot;&gt;lista de inicializadores de miembros&lt;/a&gt; para llamar a los constructores de estas bases:</target>
        </trans-unit>
        <trans-unit id="d479119249c5408ac797bae6fd07fa8962b62780" translate="yes" xml:space="preserve">
          <source>A pair of iterators to the first and one past last positions in [first, last) where a subsequence that compares equal to [pat_first, pat_last) as defined by &lt;code&gt;pred&lt;/code&gt; is located, or a pair of copies of &lt;code&gt;last&lt;/code&gt; otherwise.</source>
          <target state="translated">Un par de iteradores para las primeras y una &amp;uacute;ltimas &amp;uacute;ltimas posiciones en [first, last) donde se encuentra una subsecuencia que se compara igual a [pat_first, pat_last) como se define por &lt;code&gt;pred&lt;/code&gt; , o un par de copias de &lt;code&gt;last&lt;/code&gt; de lo contrario.</target>
        </trans-unit>
        <trans-unit id="92fbc534b58c32d1abb15ac3dd6e84d9ec347ad8" translate="yes" xml:space="preserve">
          <source>A pair whose first element is an iterator to the element past the last element moved in the source range, and whose second element is an iterator to the element past the last element moved in the destination range.</source>
          <target state="translated">Un par cuyo primer elemento es un iterador al elemento más allá del último elemento movido en el rango de origen,y cuyo segundo elemento es un iterador al elemento más allá del último elemento movido en el rango de destino.</target>
        </trans-unit>
        <trans-unit id="2e2beaabd453f4099778dc9501c74c786e364ee1" translate="yes" xml:space="preserve">
          <source>A parameter declaration in a function declaration that isn't a definition</source>
          <target state="translated">Una declaración de parámetros en una declaración de función que no es una definición</target>
        </trans-unit>
        <trans-unit id="0076d34b706ead6a1662fb14d4690ea4e30b8030" translate="yes" xml:space="preserve">
          <source>A parameter pack may appear in the capture clause of a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; expression.</source>
          <target state="translated">Un paquete de par&amp;aacute;metros puede aparecer en la cl&amp;aacute;usula de captura de una expresi&amp;oacute;n &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9b45675f6742158d4e1ce1e4e41d58001eb61fb1" translate="yes" xml:space="preserve">
          <source>A path can be</source>
          <target state="translated">Un camino puede ser</target>
        </trans-unit>
        <trans-unit id="8d3919f5b58d9be3b1d118858e1954d6017bb744" translate="yes" xml:space="preserve">
          <source>A path of execution is deemed to include a label if and only if it contains a jump to that label:</source>
          <target state="translated">Se considera que una vía de ejecución incluye una etiqueta si y sólo si contiene un salto a esa etiqueta:</target>
        </trans-unit>
        <trans-unit id="cc3d18d57e43e7c1a9f4ffb652c5171bd83b4d2f" translate="yes" xml:space="preserve">
          <source>A pattern consisting of a sign with no digits following it is treated as pattern that did not match anything.</source>
          <target state="translated">Un patrón que consiste en un signo sin dígitos que lo siguen se trata como un patrón que no coincide con nada.</target>
        </trans-unit>
        <trans-unit id="8746ca0afe0288d6db6ce87470f68b70a4fdf43e" translate="yes" xml:space="preserve">
          <source>A pattern followed by an ellipsis, in which the name of at least one parameter pack appears at least once, is</source>
          <target state="translated">Un patrón seguido de una elipse,en el que el nombre de al menos un paquete de parámetros aparece al menos una vez,es</target>
        </trans-unit>
        <trans-unit id="9ca2d1d59088c7c3b22db69dff86c0c2b3191b10" translate="yes" xml:space="preserve">
          <source>A placeholder type specifier may appear in the following contexts:</source>
          <target state="translated">Un especificador de tipo de marcador de posición puede aparecer en los siguientes contextos:</target>
        </trans-unit>
        <trans-unit id="cbee5c61daad736bbf4e77a8621940e9b34e3473" translate="yes" xml:space="preserve">
          <source>A plain integer is accepted if its meaning is unambiguous from the types of other operands: &lt;code&gt;2005y/4/5&lt;/code&gt; is allowed, but &lt;code&gt;5/April/2005&lt;/code&gt; is not.</source>
          <target state="translated">Se acepta un entero simple si su significado es inequ&amp;iacute;voco de los tipos de otros operandos: &lt;code&gt;2005y/4/5&lt;/code&gt; est&amp;aacute; permitido, pero &lt;code&gt;5/April/2005&lt;/code&gt; no.</target>
        </trans-unit>
        <trans-unit id="fec8de0bf924bd134d73493ee3f200fd0ba8a2d5" translate="yes" xml:space="preserve">
          <source>A pointer declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">Una declaraci&amp;oacute;n de puntero es cualquier declaraci&amp;oacute;n simple cuyo &lt;a href=&quot;declarations&quot;&gt;declarante&lt;/a&gt; tiene la forma.</target>
        </trans-unit>
        <trans-unit id="e616d2d8a65fe8ffec77841c511375e1b8f9b0c3" translate="yes" xml:space="preserve">
          <source>A pointer or a reference to the current element.</source>
          <target state="translated">Un puntero o una referencia al elemento actual.</target>
        </trans-unit>
        <trans-unit id="76ac2aea4079c4a955b7660eae02edd433a9fd7c" translate="yes" xml:space="preserve">
          <source>A pointer or reference to the current match.</source>
          <target state="translated">Un puntero o una referencia al partido actual.</target>
        </trans-unit>
        <trans-unit id="ab95db86866612e103ecab472411fe9d5d6b7a23" translate="yes" xml:space="preserve">
          <source>A pointer that points to an object</source>
          <target state="translated">Un puntero que apunta a un objeto</target>
        </trans-unit>
        <trans-unit id="4c96343afd2f0777da9cdc63088d337b0fc36123" translate="yes" xml:space="preserve">
          <source>A pointer to (possibly &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt;-qualified) &lt;code&gt;void&lt;/code&gt; cannot be dereferenced. Pointers to other incomplete types can be dereferenced, but the resulting lvalue can only be used in contexts that allow an lvalue of incomplete type, e.g. when initializing a reference.</source>
          <target state="translated">Un puntero al &lt;code&gt;void&lt;/code&gt; (posiblemente calificado por &lt;a href=&quot;cv&quot;&gt;cv&lt;/a&gt; ) no puede ser desreferenciado. Los punteros a otros tipos incompletos se pueden desreferenciar, pero el valor l resultante solo se puede usar en contextos que permitan un valor l de tipo incompleto, por ejemplo, al inicializar una referencia.</target>
        </trans-unit>
        <trans-unit id="d01181d4498df4cf0f8003b09ba8e09b3c553181" translate="yes" xml:space="preserve">
          <source>A pointer to &lt;code&gt;void&lt;/code&gt; cannot be deleted because it is not a pointer to a complete object type.</source>
          <target state="translated">Un puntero a &lt;code&gt;void&lt;/code&gt; no se puede eliminar porque no es un puntero a un tipo de objeto completo.</target>
        </trans-unit>
        <trans-unit id="9f73f5e3d4de4e157b8dccf9da808fedaf2b59de" translate="yes" xml:space="preserve">
          <source>A pointer to a standard-layout class may be converted (with reinterpret_cast) to a pointer to its first non-static data member and vice versa.</source>
          <target state="translated">Un puntero a una clase de diseño estándar puede convertirse (con reinterpret_cast)en un puntero a su primer miembro de datos no estático y viceversa.</target>
        </trans-unit>
        <trans-unit id="705e66bb80cbfe8e2e8b61352ddc175ed95890e9" translate="yes" xml:space="preserve">
          <source>A pointer to allocated storage of at least &lt;code&gt;bytes&lt;/code&gt; bytes in size, aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">Un puntero al almacenamiento asignado de al menos &lt;code&gt;bytes&lt;/code&gt; bytes de tama&amp;ntilde;o, alineado a la &lt;code&gt;alignment&lt;/code&gt; especificada si se admite dicha alineaci&amp;oacute;n, y &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="a9e5f21a34ce522aab5ca357e2281d794f6f56ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyContiguousIterator.</source>
          <target state="translated">Un puntero a un elemento de un arreglo satisface todos los requisitos del LegadoContiguoIterador.</target>
        </trans-unit>
        <trans-unit id="2dabfa7c1aee6ff19a8d014db29f4e03389ef1ab" translate="yes" xml:space="preserve">
          <source>A pointer to an element of an array satisfies all requirements of LegacyRandomAccessIterator.</source>
          <target state="translated">Un puntero a un elemento de una matriz satisface todos los requisitos del LegacyRandomAccessIterator.</target>
        </trans-unit>
        <trans-unit id="bf53771350311775a7859918261dd7a4cabe6a6f" translate="yes" xml:space="preserve">
          <source>A pointer to an object of standard-layout class type can be &lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpret_cast&lt;/a&gt; to pointer to its first non-static non-bitfield data member (if it has non-static data members) or otherwise any of its base class subobjects (if it has any), and vice versa. In other words, padding is not allowed before the first data member of a standard-layout type. Note that &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;strict aliasing&lt;/a&gt; rules still apply to the result of such cast.</source>
          <target state="translated">Un puntero a un objeto de tipo de clase de dise&amp;ntilde;o est&amp;aacute;ndar se puede &lt;a href=&quot;reinterpret_cast&quot;&gt;reinterpretar_cast&lt;/a&gt; para se&amp;ntilde;alar a su primer miembro de datos no est&amp;aacute;tico sin campo de bits (si tiene miembros de datos no est&amp;aacute;ticos) o de lo contrario cualquiera de sus subobjetos de clase base (si tiene alguno ), y viceversa. En otras palabras, el relleno no est&amp;aacute; permitido antes del primer miembro de datos de un tipo de dise&amp;ntilde;o est&amp;aacute;ndar. Tenga en cuenta que &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;las&lt;/a&gt; reglas estrictas de alias a&amp;uacute;n se aplican al resultado de dicho reparto.</target>
        </trans-unit>
        <trans-unit id="c433adb64c0845bb1339f1da97f3f437a44c4418" translate="yes" xml:space="preserve">
          <source>A pointer to function can be initialized with an address of a non-member function or a static member function. Because of the &lt;a href=&quot;implicit_cast&quot;&gt;function-to-pointer&lt;/a&gt; implicit conversion, the address-of operator is optional:</source>
          <target state="translated">Un puntero a funci&amp;oacute;n se puede inicializar con una direcci&amp;oacute;n de una funci&amp;oacute;n no miembro o una funci&amp;oacute;n miembro est&amp;aacute;tica. Debido a la conversi&amp;oacute;n impl&amp;iacute;cita de &lt;a href=&quot;implicit_cast&quot;&gt;funci&amp;oacute;n a puntero&lt;/a&gt; , la direcci&amp;oacute;n del operador es opcional:</target>
        </trans-unit>
        <trans-unit id="fee552ad23a470ee0488c57dc099836dec669c19" translate="yes" xml:space="preserve">
          <source>A pointer to function can be used as the left-hand operand of the &lt;a href=&quot;operator_other&quot;&gt;function call operator&lt;/a&gt;, this invokes the pointed-to function:</source>
          <target state="translated">Se puede usar un puntero para funcionar como el operando de la izquierda del &lt;a href=&quot;operator_other&quot;&gt;operador de llamada de funci&amp;oacute;n&lt;/a&gt; , esto invoca la funci&amp;oacute;n apuntada a:</target>
        </trans-unit>
        <trans-unit id="099c10c4969aca0ed60f063fd0510673f35f2754" translate="yes" xml:space="preserve">
          <source>A pointer to function may be initialized from an overload set which may include functions, function template specializations, and function templates, if only one overload matches the type of the pointer (see &lt;a href=&quot;overloaded_address&quot;&gt;address of an overloaded function&lt;/a&gt; for more detail):</source>
          <target state="translated">Se puede inicializar un puntero a la funci&amp;oacute;n a partir de un conjunto de sobrecarga que puede incluir funciones, especializaciones de plantilla de funci&amp;oacute;n y plantillas de funci&amp;oacute;n, si solo una sobrecarga coincide con el tipo de puntero (consulte la &lt;a href=&quot;overloaded_address&quot;&gt;direcci&amp;oacute;n de una funci&amp;oacute;n sobrecargada&lt;/a&gt; para obtener m&amp;aacute;s detalles):</target>
        </trans-unit>
        <trans-unit id="8f1bfae7aedabc69e7b7058df026de700a35db9f" translate="yes" xml:space="preserve">
          <source>A pointer to non-array object is treated as a pointer to the first element of an array with size 1.</source>
          <target state="translated">Un puntero a un objeto que no es una matriz se trata como un puntero al primer elemento de una matriz con tamaño 1.</target>
        </trans-unit>
        <trans-unit id="cb38a2b02a68bb7fc07ad522e4391fd787512883" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member function &lt;code&gt;f&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::f&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; or &lt;code&gt;&amp;amp;f&lt;/code&gt; inside C's member function do not form pointers to member functions.</source>
          <target state="translated">Un puntero a la funci&amp;oacute;n miembro no est&amp;aacute;tica &lt;code&gt;f&lt;/code&gt; que es miembro de la clase &lt;code&gt;C&lt;/code&gt; se puede inicializar con la expresi&amp;oacute;n &lt;code&gt;&amp;amp;C::f&lt;/code&gt; exactamente. Las expresiones como &lt;code&gt;&amp;amp;(C::f)&lt;/code&gt; o &lt;code&gt;&amp;amp;f&lt;/code&gt; dentro de la funci&amp;oacute;n miembro de C no forman punteros a las funciones miembro.</target>
        </trans-unit>
        <trans-unit id="53cf9e67e880a7f25905f2424504dd5b25bc02f1" translate="yes" xml:space="preserve">
          <source>A pointer to non-static member object &lt;code&gt;m&lt;/code&gt; which is a member of class &lt;code&gt;C&lt;/code&gt; can be initialized with the expression &lt;code&gt;&amp;amp;C::m&lt;/code&gt; exactly. Expressions such as &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; or &lt;code&gt;&amp;amp;m&lt;/code&gt; inside C's member function do not form pointers to members.</source>
          <target state="translated">Un puntero al objeto miembro no est&amp;aacute;tico &lt;code&gt;m&lt;/code&gt; que es miembro de la clase &lt;code&gt;C&lt;/code&gt; se puede inicializar con la expresi&amp;oacute;n &lt;code&gt;&amp;amp;C::m&lt;/code&gt; exactamente. Las expresiones como &lt;code&gt;&amp;amp;(C::m)&lt;/code&gt; o &lt;code&gt;&amp;amp;m&lt;/code&gt; dentro de la funci&amp;oacute;n miembro de C no forman punteros a los miembros.</target>
        </trans-unit>
        <trans-unit id="4605388fefbc6745ad5fb4ab3501853f9b2e59ca" translate="yes" xml:space="preserve">
          <source>A pointer to object can be initialized with the return value of the &lt;a href=&quot;operator_member_access&quot;&gt;address-of operator&lt;/a&gt; applied to any expression of object type, including another pointer type:</source>
          <target state="translated">Un puntero al objeto se puede inicializar con el valor de retorno &lt;a href=&quot;operator_member_access&quot;&gt;del operador de direcci&amp;oacute;n&lt;/a&gt; aplicado a cualquier expresi&amp;oacute;n de tipo de objeto, incluido otro tipo de puntero:</target>
        </trans-unit>
        <trans-unit id="cb0b45c2fb8692553e4131bcd61d0db96c449b86" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the local time zone of the computer.</source>
          <target state="translated">Un puntero a &lt;code&gt;std::chrono::time_zone&lt;/code&gt; en esta base de datos que representa la zona horaria local de la computadora.</target>
        </trans-unit>
        <trans-unit id="109ab033a06ddd191eedf4e6243ebdbfa781c50d" translate="yes" xml:space="preserve">
          <source>A pointer to the &lt;code&gt;std::chrono::time_zone&lt;/code&gt; in this database that represents the time zone designated by &lt;code&gt;tz_name&lt;/code&gt;.</source>
          <target state="translated">Un puntero a &lt;code&gt;std::chrono::time_zone&lt;/code&gt; en esta base de datos que representa la zona horaria designada por &lt;code&gt;tz_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7186294424331f7f2da77bb5b939c2393a738e08" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated and constructed object.</source>
          <target state="translated">Un puntero al objeto asignado y construido.</target>
        </trans-unit>
        <trans-unit id="90fab4aff09dede56fdb6d84059c3624b3b99e4c" translate="yes" xml:space="preserve">
          <source>A pointer to the allocated storage.</source>
          <target state="translated">Un indicador del almacenamiento asignado.</target>
        </trans-unit>
        <trans-unit id="84ca1216b138fa1171353f37562e84b5694e8e55" translate="yes" xml:space="preserve">
          <source>A pointer to the beginning of the sequence.</source>
          <target state="translated">Un puntero al principio de la secuencia.</target>
        </trans-unit>
        <trans-unit id="34743a200c5640f215061cfae8958c69a6b3ced4" translate="yes" xml:space="preserve">
          <source>A pointer to the block of memory containing the elements of the container.</source>
          <target state="translated">Un puntero al bloque de memoria que contiene los elementos del contenedor.</target>
        </trans-unit>
        <trans-unit id="a8d3f2979c65ac771376f7686ffa1017464bd622" translate="yes" xml:space="preserve">
          <source>A pointer to the first character in the range specified by &lt;code&gt;[p, p + count)&lt;/code&gt; that compares equal to &lt;code&gt;ch&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; if not found.</source>
          <target state="translated">Un puntero al primer car&amp;aacute;cter en el rango especificado por &lt;code&gt;[p, p + count)&lt;/code&gt; que se compara igual a &lt;code&gt;ch&lt;/code&gt; , o &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; si no se encuentra.</target>
        </trans-unit>
        <trans-unit id="85748d7d2f8b08c1130cce69c2693bdbf36686d5" translate="yes" xml:space="preserve">
          <source>A pointer to the first element in the classification table (which an array of size &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt;).</source>
          <target state="translated">Un puntero al primer elemento en la tabla de clasificaci&amp;oacute;n (que es una matriz de tama&amp;ntilde;o &lt;code&gt;std::ctype&amp;lt;char&amp;gt;::table_size&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d6f48b5d05090c0288e98d43d8a863e8b2c04b8" translate="yes" xml:space="preserve">
          <source>A pointer to the owned deleter or &lt;code&gt;nullptr&lt;/code&gt;. The returned pointer is valid at least as long as there remains at least one &lt;code&gt;shared_ptr&lt;/code&gt; instance that owns it.</source>
          <target state="translated">Un puntero al borrador o &lt;code&gt;nullptr&lt;/code&gt; propiedad . El puntero devuelto es v&amp;aacute;lido al menos mientras exista al menos una instancia &lt;code&gt;shared_ptr&lt;/code&gt; que lo posea.</target>
        </trans-unit>
        <trans-unit id="b50fe0059480635f66a814d6c4000336f99ae375" translate="yes" xml:space="preserve">
          <source>A pointer to the stored function if &lt;code&gt;target_type() == typeid(T)&lt;/code&gt;, otherwise a null pointer.</source>
          <target state="translated">Un puntero a la funci&amp;oacute;n almacenada si &lt;code&gt;target_type() == typeid(T)&lt;/code&gt; , de lo contrario, un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="fe7ecdbac553ec91128d6f72f68f35f00624e049" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character array.</source>
          <target state="translated">Un puntero a la matriz de caracteres subyacente.</target>
        </trans-unit>
        <trans-unit id="890ea029c831a738d852daab1692736f467e7a47" translate="yes" xml:space="preserve">
          <source>A pointer to the underlying character storage.</source>
          <target state="translated">Un indicador del almacenamiento de caracteres subyacente.</target>
        </trans-unit>
        <trans-unit id="7a202c804155efff22e9a4e471438c6dbf2d98d3" translate="yes" xml:space="preserve">
          <source>A possible implementation of this class is.</source>
          <target state="translated">Una posible implementación de esta clase es.</target>
        </trans-unit>
        <trans-unit id="bc77f50c4833701227ea3422c38b612aa4fdfe9d" translate="yes" xml:space="preserve">
          <source>A possible use for &lt;code&gt;std::condition_variable_any&lt;/code&gt; with custom &lt;a href=&quot;../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; types is to provide convenient interruptible waits: the custom lock operation would both lock the associated mutex as expected, and also perform the necessary setup to notify this condition variable when the interrupting signal is received.&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Un posible uso para &lt;code&gt;std::condition_variable_any&lt;/code&gt; con la costumbre &lt;a href=&quot;../named_req/lockable&quot;&gt;bloqueables&lt;/a&gt; tipos es proporcionar espera interrumpibles convenientes: la operaci&amp;oacute;n de bloqueo a medida ser&amp;iacute;a tanto bloquear el mutex asociado como se esperaba, y tambi&amp;eacute;n realizar la configuraci&amp;oacute;n necesaria para notificar esta condici&amp;oacute;n variable cuando se recibe la se&amp;ntilde;al de interrupci&amp;oacute;n. &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;condition_variable_any#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="0c4ca9f04ce9075912ba0b19bfb872f73c52baa7" translate="yes" xml:space="preserve">
          <source>A possibly const value of type &lt;code&gt;X::key_compare&lt;/code&gt;</source>
          <target state="translated">Posiblemente un valor constante de tipo &lt;code&gt;X::key_compare&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7916eb952414b9a1c31b5a2dafada3b876f5ad6e" translate="yes" xml:space="preserve">
          <source>A precondition of this function is that &lt;code&gt;[first, n_first)&lt;/code&gt; and &lt;code&gt;[n_first, last)&lt;/code&gt; are valid ranges.</source>
          <target state="translated">Una condici&amp;oacute;n previa de esta funci&amp;oacute;n es que &lt;code&gt;[first, n_first)&lt;/code&gt; y &lt;code&gt;[n_first, last)&lt;/code&gt; son rangos v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="b6b696e16fd55d74c0cbd8840d4be4cbde76e009" translate="yes" xml:space="preserve">
          <source>A primitive static vector class, demonstrating creation, access, and destruction of objects in aligned storage.</source>
          <target state="translated">Una clase de vector estático primitivo,que demuestra la creación,el acceso y la destrucción de objetos en un almacenamiento alineado.</target>
        </trans-unit>
        <trans-unit id="9f03356025d9d886dc6751b026e010eaa4c75c65" translate="yes" xml:space="preserve">
          <source>A priority queue is a container adaptor that provides constant time lookup of the largest (by default) element, at the expense of logarithmic insertion and extraction.</source>
          <target state="translated">Una cola de prioridad es un adaptador de contenedor que proporciona una búsqueda constante en el tiempo del elemento más grande (por defecto),a expensas de la inserción y extracción logarítmica.</target>
        </trans-unit>
        <trans-unit id="aa89f91f3d3f3e8b505f31100bf86fa2ca7b655c" translate="yes" xml:space="preserve">
          <source>A private member of a class can only be accessed by the members and friends of that class, regardless of whether the members are on the same or different instances:</source>
          <target state="translated">A un miembro privado de una clase sólo pueden acceder los miembros y amigos de esa clase,independientemente de que los miembros estén en la misma o en diferentes instancias:</target>
        </trans-unit>
        <trans-unit id="da9d03016a24905e53207d2ba428a1b8e9a9aaf7" translate="yes" xml:space="preserve">
          <source>A program is not required to call the destructor of an object to end its lifetime if the object is &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;trivially-destructible&lt;/a&gt; or if the program does not rely on the side effects of the destructor. However, if a program ends the lifetime of an non-trivial object explicitly, it must ensure that a new object of the same type is constructed in-place (e.g. via placement new) before the destructor may be called implicitly, i.e. due to scope exit or exception for automatic objects, due to thread exit for thread-local objects, or due to program exit for static objects; otherwise the behavior is undefined.</source>
          <target state="translated">No se requiere que un programa llame al destructor de un objeto para finalizar su vida &amp;uacute;til si el objeto es &lt;a href=&quot;destructor#Trivial_destructor&quot;&gt;trivialmente destructible&lt;/a&gt; o si el programa no se basa en los efectos secundarios del destructor. Sin embargo, si un programa finaliza expl&amp;iacute;citamente la vida &amp;uacute;til de un objeto no trivial, debe asegurarse de que un nuevo objeto del mismo tipo se construya en el lugar (por ejemplo, mediante la colocaci&amp;oacute;n de nuevo) antes de que el destructor pueda llamarse impl&amp;iacute;citamente, es decir, debido al alcance salida o excepci&amp;oacute;n para objetos autom&amp;aacute;ticos, debido a la salida de hilo para objetos locales de hilo, o debido a la salida de programa para objetos est&amp;aacute;ticos; de lo contrario, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="03089f15ead7ca5ed65d816afebaddda671b3974" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of three</source>
          <target state="translated">Un programa puede ser traducido con una de tres</target>
        </trans-unit>
        <trans-unit id="66c3ecf22ff81745bed14260f746ab81e7c0d0a2" translate="yes" xml:space="preserve">
          <source>A program may be translated with one of two</source>
          <target state="translated">Un programa puede ser traducido con una de dos</target>
        </trans-unit>
        <trans-unit id="5a764d00cd6118dc37146370c6388538e41d1085" translate="yes" xml:space="preserve">
          <source>A program may not specialize &lt;code&gt;basic_common_reference&lt;/code&gt; on the third or fourth parameters, nor may it specialize &lt;code&gt;common_reference&lt;/code&gt; itself. A program that adds specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">Un programa no puede especializarse &lt;code&gt;basic_common_reference&lt;/code&gt; en el tercer o cuarto par&amp;aacute;metro, ni puede especializarse &lt;code&gt;common_reference&lt;/code&gt; en s&amp;iacute;. Un programa que agrega especializaciones en violaci&amp;oacute;n de estas reglas tiene un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="17328f55bfa3f5f5c88fbe4c9f98cf4b5f272bc0" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; on the first two parameters &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; are both true and at least one of them depends on a program-defined type.</source>
          <target state="translated">Un programa puede especializarse &lt;code&gt;basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;&lt;/code&gt; en los primeros dos par&amp;aacute;metros &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;U&lt;/code&gt; si &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;T, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;is_same&quot;&gt;std::is_same&lt;/a&gt;&amp;lt;U, &lt;a href=&quot;decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;U&amp;gt;&amp;gt;&lt;/code&gt; son verdaderos y al menos uno de ellos depende de un tipo definido por el programa.</target>
        </trans-unit>
        <trans-unit id="8e61a356e3234eed06fa2f0f5dee899601ee82c6" translate="yes" xml:space="preserve">
          <source>A program may specialize &lt;code&gt;clock_time_conversion&lt;/code&gt; if at least one of the template parameters is a user-defined clock type.</source>
          <target state="translated">Un programa puede especializarse &lt;code&gt;clock_time_conversion&lt;/code&gt; si al menos uno de los par&amp;aacute;metros de la plantilla es un tipo de reloj definido por el usuario.</target>
        </trans-unit>
        <trans-unit id="97b63352c2d736a021395385f10f9bb467d6e3fd" translate="yes" xml:space="preserve">
          <source>A program shall contain a global function named &lt;code&gt;main&lt;/code&gt;, which is the designated start of the program. It shall have one of the following forms:</source>
          <target state="translated">Un programa contendr&amp;aacute; una funci&amp;oacute;n global llamada &lt;code&gt;main&lt;/code&gt; , que es el inicio designado del programa. Tendr&amp;aacute; una de las siguientes formas:</target>
        </trans-unit>
        <trans-unit id="5437280a6191901c16079ac8f80aff7f070d8c2f" translate="yes" xml:space="preserve">
          <source>A program that adds &lt;code&gt;common_type&lt;/code&gt; specializations in violation of these rules has undefined behavior.</source>
          <target state="translated">Un programa que agrega especializaciones &lt;code&gt;common_type&lt;/code&gt; en violaci&amp;oacute;n de estas reglas tiene un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="7fee44e17e3a13581354a330d85e96728e00f4bd" translate="yes" xml:space="preserve">
          <source>A protected member of a class &lt;code&gt;Base&lt;/code&gt; can only be accessed.</source>
          <target state="translated">Solo se puede acceder a un miembro protegido de una clase &lt;code&gt;Base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87b080a926e158a236034e081054063e31488155" translate="yes" xml:space="preserve">
          <source>A prvalue cannot be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;: the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of the object it identifies is always the type of the expression.</source>
          <target state="translated">Un prvalue no puede ser &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polim&amp;oacute;rfico&lt;/a&gt; : el &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;tipo din&amp;aacute;mico&lt;/a&gt; del objeto que identifica es siempre el tipo de expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="948c7440ba50ed3eb424033ba764365ffa6afd0f" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt; or an array thereof.</source>
          <target state="translated">Un prvalue no puede tener &lt;a href=&quot;abstract_class&quot;&gt;un tipo de clase abstracta&lt;/a&gt; o una matriz del mismo.</target>
        </trans-unit>
        <trans-unit id="9922e8eeb154c6c0744ee9e4ba026d8fb5b557df" translate="yes" xml:space="preserve">
          <source>A prvalue cannot have &lt;a href=&quot;type-id#Incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (except for type void, see below, or when used in &lt;a href=&quot;decltype&quot;&gt;decltype specifier&lt;/a&gt;)</source>
          <target state="translated">Un valor prvalue no puede tener &lt;a href=&quot;type-id#Incomplete_type&quot;&gt;un tipo incompleto&lt;/a&gt; (excepto el tipo vac&amp;iacute;o, ver m&amp;aacute;s abajo, o cuando se utiliza en el &lt;a href=&quot;decltype&quot;&gt;especificador decltype&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="89adcc7246c411786e22055f1d4bc6dc797ab523" translate="yes" xml:space="preserve">
          <source>A prvalue of integer or unscoped enumeration type can be converted to a prvalue of any floating-point type. If the value cannot be represented correctly, it is implementation defined whether the closest higher or the closest lower representable value will be selected, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;. If the value cannot fit into the destination type, the behavior is undefined. If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero, and the value &lt;code&gt;true&lt;/code&gt; is converted to one.</source>
          <target state="translated">Un valor de tipo de enumeraci&amp;oacute;n entero o sin &amp;aacute;mbito se puede convertir a un valor de cualquier tipo de punto flotante. Si el valor no se puede representar correctamente, su implementaci&amp;oacute;n se define si se seleccionar&amp;aacute; el valor representable m&amp;aacute;s alto o el m&amp;aacute;s bajo representable m&amp;aacute;s cercano, aunque si se admite la aritm&amp;eacute;tica IEEE, el redondeo predeterminado &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;es el m&amp;aacute;s cercano&lt;/a&gt; . Si el valor no puede caber en el tipo de destino, el comportamiento no est&amp;aacute; definido. Si el tipo de origen es &lt;code&gt;bool&lt;/code&gt; , el valor &lt;code&gt;false&lt;/code&gt; se convierte a cero y el valor &lt;code&gt;true&lt;/code&gt; se convierte a uno.</target>
        </trans-unit>
        <trans-unit id="1cc331b941fd7c1d4179b58d5442419123db000e" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to member of cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt; can be converted to a prvalue pointer to member of more cv-qualified type &lt;code&gt;T&lt;/code&gt; in class &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">A prvalue de tipo puntero a miembro de tipo cv-calificado &lt;code&gt;T&lt;/code&gt; en la clase &lt;code&gt;X&lt;/code&gt; se puede convertir a un puntero prvalue al miembro de m&amp;aacute;s cv-cualificado tipo &lt;code&gt;T&lt;/code&gt; en la clase &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3def19238902e53ffc0e7c4199b58d0948a3fce" translate="yes" xml:space="preserve">
          <source>A prvalue of type pointer to non-throwing member function can be converted to a prvalue pointer to potentially-throwing member function.</source>
          <target state="translated">El valor de un puntero de tipo a la función de miembro no lanzador puede convertirse en un puntero de valor a la función de miembro potencialmente lanzador.</target>
        </trans-unit>
        <trans-unit id="e4ca3c60807a21440fb680870f4faa7d3f0b6ab5" translate="yes" xml:space="preserve">
          <source>A prvalue pointer to a (optionally cv-qualified) derived class type can be converted to a prvalue pointer to its (identically cv-qualified) base class. If the base class is inaccessible or ambiguous, the conversion is ill-formed (won't compile). The result of the conversion is a pointer to the base class subobject within the pointed-to object. The null pointer value is converted to the null pointer value of the destination type.</source>
          <target state="translated">Un puntero de valor a un tipo de clase derivada (opcionalmente calificada para cv)puede convertirse en un puntero de valor a su clase base (idénticamente calificada para cv).Si la clase base es inaccesible o ambigua,la conversión está mal hecha (no se compilará).El resultado de la conversión es un puntero a la clase base subobjeto dentro del objeto señalado.El valor nulo del puntero se convierte en el valor nulo del puntero de la clase destino.</target>
        </trans-unit>
        <trans-unit id="b68c522f33b2f282c51184b2111938ab2a45c6a2" translate="yes" xml:space="preserve">
          <source>A pseudo-random number in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">Un n&amp;uacute;mero pseudoaleatorio en [ &lt;code&gt;min()&lt;/code&gt; , &lt;code&gt;max()&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="518c2995944086d5bc64a89e68ef8ff2eda028d4" translate="yes" xml:space="preserve">
          <source>A public member of a class is accessible everywhere.</source>
          <target state="translated">Un miembro público de una clase es accesible en todas partes.</target>
        </trans-unit>
        <trans-unit id="a237039e9334b0659fe3de5e7abb2fcf04116a22" translate="yes" xml:space="preserve">
          <source>A pure virtual function is a &lt;a href=&quot;virtual&quot;&gt;virtual function&lt;/a&gt; whose &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; has the following syntax:</source>
          <target state="translated">Una funci&amp;oacute;n virtual pura es una &lt;a href=&quot;virtual&quot;&gt;funci&amp;oacute;n virtual&lt;/a&gt; cuyo &lt;a href=&quot;function&quot;&gt;declarador&lt;/a&gt; tiene la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="d2a131b189a54243081396040bed210dca58fe18" translate="yes" xml:space="preserve">
          <source>A qualified name that appears in</source>
          <target state="translated">Un nombre calificado que aparece en</target>
        </trans-unit>
        <trans-unit id="f00c1c26af032f164f98a00ceb65858c99c608e2" translate="yes" xml:space="preserve">
          <source>A qualified name that is used as a &lt;a href=&quot;declarations#Specifiers&quot;&gt;declaration specifier&lt;/a&gt; in the (top-level) decl-specifier-seq of:</source>
          <target state="translated">Un nombre calificado que se utiliza como un &lt;a href=&quot;declarations#Specifiers&quot;&gt;especificador de declaraci&amp;oacute;n&lt;/a&gt; en el (nivel superior) decl-specifier-seq de:</target>
        </trans-unit>
        <trans-unit id="234e75018942daa7d9ddc6b7ab239081b75bbb61" translate="yes" xml:space="preserve">
          <source>A random number distribution post-processes the output of a URBG in such a way that resulting output is distributed according to a defined statistical probability density function.</source>
          <target state="translated">Una distribución de números aleatorios procesa la salida de un URBG de tal manera que la salida resultante se distribuye de acuerdo con una función de densidad de probabilidad estadística definida.</target>
        </trans-unit>
        <trans-unit id="63c005a6e5fbfc7dc8af621e2d17685667135352" translate="yes" xml:space="preserve">
          <source>A random number engine is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">Un motor de números aleatorios es un objeto de función que devuelve valores enteros sin signo,de manera que cada valor en el rango de resultados posibles tiene (idealmente)igual probabilidad.</target>
        </trans-unit>
        <trans-unit id="218114a7bf5a72fb79f4bcfba1ca863f66fc080d" translate="yes" xml:space="preserve">
          <source>A random number generator may satisfy &lt;code&gt;Invocable&lt;/code&gt; but cannot satisfy &lt;code&gt;RegularInvocable&lt;/code&gt; (&lt;a href=&quot;https://xkcd.com/221/&quot;&gt;comical&lt;/a&gt;&lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;ones&lt;/a&gt; excluded).</source>
          <target state="translated">Un generador de n&amp;uacute;meros aleatorios puede satisfacer &lt;code&gt;Invocable&lt;/code&gt; pero no puede satisfacer &lt;code&gt;RegularInvocable&lt;/code&gt; ( excluyendo &lt;a href=&quot;http://dilbert.com/strip/2001-10-25&quot;&gt;los &lt;/a&gt;&lt;a href=&quot;https://xkcd.com/221/&quot;&gt;c&amp;oacute;micos&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c8740cda35197e3b7986bfb9d3958a23da53121b" translate="yes" xml:space="preserve">
          <source>A random number uniformly distributed in [&lt;code&gt;min()&lt;/code&gt;, &lt;code&gt;max()&lt;/code&gt;].</source>
          <target state="translated">Un n&amp;uacute;mero aleatorio distribuido uniformemente en [ &lt;code&gt;min()&lt;/code&gt; , &lt;code&gt;max()&lt;/code&gt; ].</target>
        </trans-unit>
        <trans-unit id="c6c8fb5e09b78d7ba8993d92c01b80b6ecf577e7" translate="yes" xml:space="preserve">
          <source>A range adaptor that returns a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of its &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument.</source>
          <target state="translated">Un adaptador de rango que devuelve una &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que incluye todos los elementos de su argumento &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b161bf3c0670ce52a5c8049eec7a861c20295c5" translate="yes" xml:space="preserve">
          <source>A raw pointer of the type &lt;code&gt;element_type*&lt;/code&gt; that references the same memory location as the argument &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Un puntero sin &lt;code&gt;element_type*&lt;/code&gt; del tipo element_type * que hace referencia a la misma ubicaci&amp;oacute;n de memoria que el argumento &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a987fe5116d16dac6c986d15e44866f1f2950023" translate="yes" xml:space="preserve">
          <source>A read-modify-write operation with this memory order is both an</source>
          <target state="translated">Una operación de lecturamodificación-escritura con este orden de memoria es a la vez una</target>
        </trans-unit>
        <trans-unit id="e3862e525cd9728a75bb86198e817c0be834e74b" translate="yes" xml:space="preserve">
          <source>A reference is required to be initialized to refer to a valid object or function: see &lt;a href=&quot;reference_initialization&quot;&gt;reference initialization&lt;/a&gt;.</source>
          <target state="translated">Se requiere que se inicialice una referencia para referirse a un objeto o funci&amp;oacute;n v&amp;aacute;lida: ver &lt;a href=&quot;reference_initialization&quot;&gt;inicializaci&amp;oacute;n de referencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b8168313a358c53144732f59b7b55f79bc0d83aa" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;OuterAlloc&lt;/code&gt;.</source>
          <target state="translated">Una referencia a &lt;code&gt;OuterAlloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="804797fdb54fd58e448bcbbb5edeb1965dd46ac6" translate="yes" xml:space="preserve">
          <source>A reference to &lt;code&gt;T&lt;/code&gt; can be initialized with an object of type &lt;code&gt;T&lt;/code&gt;, a function of type &lt;code&gt;T&lt;/code&gt;, or an object implicitly convertible to &lt;code&gt;T&lt;/code&gt;. Once initialized, a reference cannot be changed to refer to another object.</source>
          <target state="translated">Una referencia a &lt;code&gt;T&lt;/code&gt; puede ser inicializado con un objeto de tipo &lt;code&gt;T&lt;/code&gt; , una funci&amp;oacute;n del tipo &lt;code&gt;T&lt;/code&gt; , o un objeto impl&amp;iacute;citamente convertible a &lt;code&gt;T&lt;/code&gt; . Una vez inicializada, una referencia no se puede cambiar para referirse a otro objeto.</target>
        </trans-unit>
        <trans-unit id="96effaa229108956b87eaa0ef7506c4b68779cfb" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">Una referencia al elemento &lt;code&gt;Ith&lt;/code&gt; de &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fed9a57692255e9193120495f8b304740d5643ee" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;Ith&lt;/code&gt; element of &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Una referencia al elemento &lt;code&gt;Ith&lt;/code&gt; del &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8587a8972573baad1abe654df486c02df1c78add" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the array, i.e., &lt;code&gt;get()[idx]&lt;/code&gt;</source>
          <target state="translated">Una referencia al elemento &lt;code&gt;idx&lt;/code&gt; -th de la matriz, es decir, &lt;code&gt;get()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36d8ef7aa332a08ad1749e9a36b2ab00fe12b221" translate="yes" xml:space="preserve">
          <source>A reference to the &lt;code&gt;idx&lt;/code&gt;-th element of the sequence, i.e., &lt;code&gt;data()[idx]&lt;/code&gt;</source>
          <target state="translated">Una referencia al elemento &lt;code&gt;idx&lt;/code&gt; -th de la secuencia, es decir, &lt;code&gt;data()[idx]&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af1efc2484e454ad9728eae87f942a799f403462" translate="yes" xml:space="preserve">
          <source>A reference to the back element.</source>
          <target state="translated">Una referencia al elemento de la espalda.</target>
        </trans-unit>
        <trans-unit id="932b2a1f1d48ceff1483626d393c48deb6ec133d" translate="yes" xml:space="preserve">
          <source>A reference to the contained value.</source>
          <target state="translated">Una referencia al valor contenido.</target>
        </trans-unit>
        <trans-unit id="8de78a95776c196427cb50ef2308786df9feaa77" translate="yes" xml:space="preserve">
          <source>A reference to the element at relative location, that is, &lt;code&gt;base()[-n-1]&lt;/code&gt;.</source>
          <target state="translated">Una referencia al elemento en una ubicaci&amp;oacute;n relativa, es decir, &lt;code&gt;base()[-n-1]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed2f64858c4b136043374a81f773f2bb47825288" translate="yes" xml:space="preserve">
          <source>A reference to the element.</source>
          <target state="translated">Una referencia al elemento.</target>
        </trans-unit>
        <trans-unit id="1b47ff083eea09f7ebfc57e29aa6a19dcffb7f4b" translate="yes" xml:space="preserve">
          <source>A reference to the first element.</source>
          <target state="translated">Una referencia al primer elemento.</target>
        </trans-unit>
        <trans-unit id="a0df3de2b33596434eabf885b30512aa4bd9a7f7" translate="yes" xml:space="preserve">
          <source>A reference to the inner allocator, which is itself a &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt;.</source>
          <target state="translated">Una referencia al asignador interno, que en s&amp;iacute; mismo es un &lt;code&gt;std::scoped_allocator_adaptor&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d12739b00cf675a6ba691cc42cc3b54b7c86c25" translate="yes" xml:space="preserve">
          <source>A reference to the inserted element.</source>
          <target state="translated">Una referencia al elemento insertado.</target>
        </trans-unit>
        <trans-unit id="9b728bf8ae3f8f1afb3d2c134ee7f6175d648f5b" translate="yes" xml:space="preserve">
          <source>A reference to the new contained object.</source>
          <target state="translated">Una referencia al nuevo objeto contenido.</target>
        </trans-unit>
        <trans-unit id="695dad725bff816bf70ec1a1e915658d83c47722" translate="yes" xml:space="preserve">
          <source>A reference to the new contained value.</source>
          <target state="translated">Una referencia al nuevo valor contenido.</target>
        </trans-unit>
        <trans-unit id="1f840389ee6e69a00e4361ae4f5b87b0602e4e15" translate="yes" xml:space="preserve">
          <source>A reference to the selected element of &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Una referencia al elemento seleccionado de &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="215a738f7f92427350a124e8545beaf159690b56" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Una referencia al objeto est&amp;aacute;tico de tipo de tiempo de ejecuci&amp;oacute;n no especificado, derivado de &lt;code&gt;&lt;a href=&quot;../../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dce474f5e611fdd344ca6f78607a960539b8d24" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Una referencia al objeto est&amp;aacute;tico de tipo de tiempo de ejecuci&amp;oacute;n no especificado, derivado de &lt;code&gt;&lt;a href=&quot;../error/error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52beb0ba5b037a0cd1d9ec162abace30f7074fd0" translate="yes" xml:space="preserve">
          <source>A reference to the static object of unspecified runtime type, derived from &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Una referencia al objeto est&amp;aacute;tico de tipo de tiempo de ejecuci&amp;oacute;n no especificado, derivado de &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9ad010ef7d281736e175c6e04e6e45d80ea96e8" translate="yes" xml:space="preserve">
          <source>A reference to the stream, i.e., &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Una referencia a la secuencia, es decir, &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b519975029bcddb7935a1938c71b85de5a9aa395" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;day&lt;/code&gt; after modification.</source>
          <target state="translated">Una referencia a este &lt;code&gt;day&lt;/code&gt; despu&amp;eacute;s de la modificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fd1b8fb4c67bb93024d4c080ffbd107e8a00646c" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;month&lt;/code&gt; after modification.</source>
          <target state="translated">Una referencia a este &lt;code&gt;month&lt;/code&gt; despu&amp;eacute;s de la modificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="77d42f71b8ba36af0d80129ce3320e59f448b88f" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;weekday&lt;/code&gt; after modification.</source>
          <target state="translated">Una referencia a este &lt;code&gt;weekday&lt;/code&gt; despu&amp;eacute;s de la modificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="30e2b7de4724355804f01b061a5218dcca673f33" translate="yes" xml:space="preserve">
          <source>A reference to this &lt;code&gt;year&lt;/code&gt; after modification.</source>
          <target state="translated">Una referencia a este &lt;code&gt;year&lt;/code&gt; despu&amp;eacute;s de la modificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c42d3cc108e10a5c0d961e89275a7b7e304370ef" translate="yes" xml:space="preserve">
          <source>A reference to this duration after modification.</source>
          <target state="translated">Una referencia a esta duración después de la modificación.</target>
        </trans-unit>
        <trans-unit id="477f7a0da5713d89a4c5a2b12679f4b4532b6576" translate="yes" xml:space="preserve">
          <source>A reference variable declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">Una declaraci&amp;oacute;n de variable de referencia es cualquier declaraci&amp;oacute;n simple cuyo &lt;a href=&quot;declarations&quot;&gt;declarador&lt;/a&gt; tiene la forma.</target>
        </trans-unit>
        <trans-unit id="071394746753f76fda55bbb1f2d7273768e4c96d" translate="yes" xml:space="preserve">
          <source>A release fence F in thread A synchronizes-with atomic &lt;a href=&quot;memory_order&quot;&gt;acquire operation&lt;/a&gt; Y in thread B, if.</source>
          <target state="translated">Una gu&amp;iacute;a de liberaci&amp;oacute;n F en el hilo A se sincroniza con la &lt;a href=&quot;memory_order&quot;&gt;operaci&amp;oacute;n de adquisici&amp;oacute;n&lt;/a&gt; at&amp;oacute;mica Y en el hilo B, si.</target>
        </trans-unit>
        <trans-unit id="6aafba41a946d2b0a19753067d04e0ec8318ec66" translate="yes" xml:space="preserve">
          <source>A release fence FA in thread A synchronizes-with an acquire fence FB in thread B, if.</source>
          <target state="translated">Una valla de liberación FA en el hilo A se sincroniza con una valla de adquisición FB en el hilo B,si.</target>
        </trans-unit>
        <trans-unit id="00a2a5eb93eeb9be0332c1c8673603beb7ab0223" translate="yes" xml:space="preserve">
          <source>A safely-derived copy of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Una copia segura derivada de &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34d713d3ce9641e15f0083875fa82da7295cd6d0" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;Boyer-Moore-Horspool string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">Un buscador adecuado para usar con la sobrecarga del &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;buscador&lt;/a&gt; de &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; que implementa el &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&quot;&gt;algoritmo de b&amp;uacute;squeda de cadenas Boyer-Moore-Horspool&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4aca9528474448c3c240ea5a50dac0f70fee741" translate="yes" xml:space="preserve">
          <source>A searcher suitable for use with the &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt; overload of &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; that implements the &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;Boyer-Moore string searching algorithm&lt;/a&gt;.</source>
          <target state="translated">Un buscador adecuado para usar con la sobrecarga del &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;buscador&lt;/a&gt; de &lt;code&gt;&lt;a href=&quot;../../algorithm/search&quot;&gt;std::search&lt;/a&gt;&lt;/code&gt; que implementa el &lt;a href=&quot;https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm&quot;&gt;algoritmo de b&amp;uacute;squeda de cadenas Boyer-Moore&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c73f721b6023bb7d94aabb383e7afe39aad3eff" translate="yes" xml:space="preserve">
          <source>A separate stored pointer is necessary to ensure that converting a &lt;code&gt;shared_ptr&lt;/code&gt; to &lt;code&gt;weak_ptr&lt;/code&gt; and then back works correctly, even for aliased &lt;code&gt;shared_ptr&lt;/code&gt;s. It is not possible to access the stored pointer in a &lt;code&gt;weak_ptr&lt;/code&gt; without locking it into a &lt;code&gt;shared_ptr&lt;/code&gt;.</source>
          <target state="translated">Es necesario un puntero almacenado por separado para garantizar que la conversi&amp;oacute;n de &lt;code&gt;shared_ptr&lt;/code&gt; a &lt;code&gt;weak_ptr&lt;/code&gt; y luego hacia atr&amp;aacute;s funcione correctamente, incluso para los &lt;code&gt;shared_ptr&lt;/code&gt; s con alias . No es posible acceder al puntero almacenado en un &lt;code&gt;weak_ptr&lt;/code&gt; sin bloquearlo en un &lt;code&gt;shared_ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e507c2060a3cafdcda35e0bc4aa2552b49e574" translate="yes" xml:space="preserve">
          <source>A sequence of characters that represents the collating element consisting of the character sequence designated by the iterator range &lt;code&gt;[F1, F2)&lt;/code&gt; otherwise</source>
          <target state="translated">Una secuencia de caracteres que representa el elemento de clasificaci&amp;oacute;n que consiste en la secuencia de caracteres designada por el rango del iterador &lt;code&gt;[F1, F2)&lt;/code&gt; contrario</target>
        </trans-unit>
        <trans-unit id="3a4ef167623ed9faf9a94eff09dae4f596aaaa70" translate="yes" xml:space="preserve">
          <source>A simple declaration is a statement that introduces, creates, and optionally initializes one or several identifiers, typically variables.</source>
          <target state="translated">Una declaración simple es una declaración que introduce,crea y,opcionalmente,inicializa uno o varios identificadores,normalmente variables.</target>
        </trans-unit>
        <trans-unit id="555b8933650b3bb84b4b7b35f14e9c321630ac4d" translate="yes" xml:space="preserve">
          <source>A simple requirement is an arbitrary expression statement. It asserts that the expression is valid. The expression is an unevaluated operand; only language correctness is checked.</source>
          <target state="translated">Un simple requisito es una declaración de expresión arbitraria.Afirma que la expresión es válida.La expresión es un operando no evaluado;sólo se comprueba la corrección del lenguaje.</target>
        </trans-unit>
        <trans-unit id="3a6977f0304e9c21ebecd390f1670f86c4119c3c" translate="yes" xml:space="preserve">
          <source>A simple-template-id that names a class template specialization names a class.</source>
          <target state="translated">Una simple-plantilla-id que nombra una especialización de plantilla de clase nombra una clase.</target>
        </trans-unit>
        <trans-unit id="8fa198408b5d0cb7b3044995aa1b61b2fdf97bfa" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of alternative names of time zones (links)</source>
          <target state="translated">Un &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;link&quot;&gt;std::chrono::link&lt;/a&gt;&amp;gt;&lt;/code&gt; ordenado que contiene la descripci&amp;oacute;n de nombres alternativos de zonas horarias (enlaces)</target>
        </trans-unit>
        <trans-unit id="457d45e0af075f01765307d373a69c2a8d94815f" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt; containing description of time zones</source>
          <target state="translated">Un &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;&lt;a href=&quot;time_zone&quot;&gt;std::chrono::time_zone&lt;/a&gt;&amp;gt;&lt;/code&gt; ordenado que contiene la descripci&amp;oacute;n de las zonas horarias</target>
        </trans-unit>
        <trans-unit id="967914ef26dbd68948b66b13d60e30b85ed85a3c" translate="yes" xml:space="preserve">
          <source>A sorted &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt; containing description of leap seconds</source>
          <target state="translated">Un &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;std::chrono::leaps&amp;gt;&lt;/code&gt; ordenado que contiene la descripci&amp;oacute;n de los segundos bisiestos</target>
        </trans-unit>
        <trans-unit id="eee524fe2ac982c4dd9f9a32a0c582f50eef3782" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the first &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">Un intervalo &lt;code&gt;r&lt;/code&gt; que es una vista sobre los primeros elementos &lt;code&gt;Count&lt;/code&gt; de &lt;code&gt;*this&lt;/code&gt; , de modo que &lt;code&gt;r.data() == this-&amp;gt;data() &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65c54f136c4760893800380e5b0c393d21d23647" translate="yes" xml:space="preserve">
          <source>A span &lt;code&gt;r&lt;/code&gt; that is a view over the last &lt;code&gt;Count&lt;/code&gt; elements of &lt;code&gt;*this&lt;/code&gt;, such that &lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt;.</source>
          <target state="translated">Un intervalo &lt;code&gt;r&lt;/code&gt; que es una vista sobre los &amp;uacute;ltimos elementos &lt;code&gt;Count&lt;/code&gt; de &lt;code&gt;*this&lt;/code&gt; , de modo que &lt;code&gt;r.data() == this-&amp;gt;data() + (this-&amp;gt;size() - Count) &amp;amp;&amp;amp; r.size() == Count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5074592fbba4772cb532096c90f531b3f380c17b" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Una especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ee495551d56b04a23dc52fb815bb43b2e18e8c4" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;conjunction&lt;/code&gt; does not necessarily inherit from either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to bool, is false, or from the very last &lt;code&gt;B&lt;/code&gt; when all of them convert to true. For example, &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Una especializaci&amp;oacute;n de &lt;code&gt;conjunction&lt;/code&gt; no necesariamente hereda de &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; : simplemente hereda de la primera &lt;code&gt;B&lt;/code&gt; cuyo &lt;code&gt;::value&lt;/code&gt; , convertido expl&amp;iacute;citamente a bool, es falso, o de la &amp;uacute;ltima &lt;code&gt;B&lt;/code&gt; cuando todas convertir a verdadero. Por ejemplo, &lt;code&gt;std::conjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9e9b49b2bead30b9efc6f23cbdc32fd0fd8ce60" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;disjunction&lt;/code&gt; does not necessarily inherit from of either &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt;: it simply inherits from the first &lt;code&gt;B&lt;/code&gt; whose &lt;code&gt;::value&lt;/code&gt;, explicitly converted to &lt;code&gt;bool&lt;/code&gt;, is true, or from the very last B when all of them convert to false. For example, &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;2&lt;/code&gt;.</source>
          <target state="translated">Una especializaci&amp;oacute;n de &lt;code&gt;disjunction&lt;/code&gt; no necesariamente hereda de &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::true_type&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::false_type&lt;/a&gt;&lt;/code&gt; : simplemente hereda de la primera &lt;code&gt;B&lt;/code&gt; cuyo &lt;code&gt;::value&lt;/code&gt; , convertido expl&amp;iacute;citamente a &lt;code&gt;bool&lt;/code&gt; , es verdadero, o de la &amp;uacute;ltima B cuando todos ellos se convierten en falso. Por ejemplo, &lt;code&gt;std::disjunction&amp;lt;&lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 2&amp;gt;, &lt;a href=&quot;integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, 4&amp;gt;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f9e5d495b1b862008c29e72aac873442799f4b0" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::greater&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">Una especializaci&amp;oacute;n de &lt;code&gt;std::greater&lt;/code&gt; para cualquier tipo de puntero produce un orden total estricto, incluso si el &lt;code&gt;operator&amp;gt;&lt;/code&gt; integrado &amp;gt; no lo hace. El estricto orden total es coherente entre las especializaciones de &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::greater&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , std :: less_equal y &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; para ese tipo de puntero, y tambi&amp;eacute;n es coherente con el orden parcial impuesto por los operadores integrados correspondientes. ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; y &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d8a4b2d55428dedbd5dbf627f7b5d8550161022" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::greater_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">Una especializaci&amp;oacute;n de &lt;code&gt;std::greater_equal&lt;/code&gt; para cualquier tipo de puntero produce un orden total estricto, incluso si el &lt;code&gt;operator&amp;gt;=&lt;/code&gt; integrado &amp;gt; = no lo hace. El estricto orden total es coherente entre las especializaciones de &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , std :: less_equal y &lt;code&gt;std::greater_equal&lt;/code&gt; para ese tipo de puntero, y tambi&amp;eacute;n es coherente con el orden parcial impuesto por los operadores integrados correspondientes. ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; y &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="475b3cfac8883fd0a588f09dae13ae24eea6b2df" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;std::less&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">Una especializaci&amp;oacute;n de &lt;code&gt;std::less&lt;/code&gt; para cualquier tipo de puntero produce un orden total estricto, incluso si el &lt;code&gt;operator&amp;lt;&lt;/code&gt; integrado &amp;lt; no lo hace. El estricto orden total es coherente entre las especializaciones de &lt;code&gt;std::less&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , std :: less_equal y &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; para ese tipo de puntero, y tambi&amp;eacute;n es coherente con el orden parcial impuesto por los operadores integrados correspondientes. ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; y &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5040d1c9db6502c777c18889e5250a72b8267c2f" translate="yes" xml:space="preserve">
          <source>A specialization of &lt;code&gt;std::less_equal&lt;/code&gt; for any pointer type yields a strict total order, even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. The strict total order is consistent among specializations of &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; for that pointer type, and is also consistent with the partial order imposed by the corresponding built-in operators (&lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; and &lt;code&gt;&amp;gt;=&lt;/code&gt;).</source>
          <target state="translated">Una especializaci&amp;oacute;n de &lt;code&gt;std::less_equal&lt;/code&gt; para cualquier tipo de puntero produce un orden total estricto, incluso si el &lt;code&gt;operator&amp;lt;=&lt;/code&gt; integrado &amp;lt;= no lo hace. El estricto orden total es coherente entre las especializaciones de &lt;code&gt;&lt;a href=&quot;less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; &lt;code&gt;std::less_equal&lt;/code&gt; , std :: less_equal y &lt;code&gt;&lt;a href=&quot;greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; para ese tipo de puntero, y tambi&amp;eacute;n es coherente con el orden parcial impuesto por los operadores integrados correspondientes. ( &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; y &lt;code&gt;&amp;gt;=&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="92e25a120740f5ad5adbba2aabed8d933eb3d5e4" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic exchange operation, similar to &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Se puede implementar un mutex spinlock en el espacio de usuario utilizando una operaci&amp;oacute;n de intercambio at&amp;oacute;mico, similar a &lt;code&gt;&lt;a href=&quot;atomic_flag_test_and_set&quot;&gt;std::atomic_flag_test_and_set&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9515057fe6328dc05919c4cf02d9006061787a0c" translate="yes" xml:space="preserve">
          <source>A spinlock mutex can be implemented in userspace using an atomic_flag.</source>
          <target state="translated">Se puede implementar un mutex de giro en el espacio de usuario usando una bandera atómica.</target>
        </trans-unit>
        <trans-unit id="901d05a2e6ec5ffbcf6b01e787bf262ebced94a5" translate="yes" xml:space="preserve">
          <source>A standard conversion sequence consists of the following, in this order:</source>
          <target state="translated">Una secuencia de conversión estándar consiste en lo siguiente,en este orden:</target>
        </trans-unit>
        <trans-unit id="d4c338c0450a24104d97679430b5532160d82771" translate="yes" xml:space="preserve">
          <source>A static assert declaration may appear at namespace and block scope (as a &lt;a href=&quot;declarations&quot;&gt;block declaration&lt;/a&gt;) and inside a class body (as a &lt;a href=&quot;class&quot;&gt;member declaration&lt;/a&gt;).</source>
          <target state="translated">Una declaraci&amp;oacute;n de afirmaci&amp;oacute;n est&amp;aacute;tica puede aparecer en el espacio de nombres y el alcance del bloque (como una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n de bloque&lt;/a&gt; ) y dentro de un cuerpo de clase (como una &lt;a href=&quot;class&quot;&gt;declaraci&amp;oacute;n de miembro&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f33f270773f2dc3de0fd0352e32cf33418d9b8c0" translate="yes" xml:space="preserve">
          <source>A static data member may be declared &lt;a href=&quot;inline&quot;&gt;&lt;code&gt;inline&lt;/code&gt;&lt;/a&gt;. An inline static data member can be defined in the class definition and may specify an initializer. It does not need an out-of-class definition:</source>
          <target state="translated">Un miembro de datos est&amp;aacute;ticos puede declararse en &lt;a href=&quot;inline&quot;&gt; &lt;code&gt;inline&lt;/code&gt; &lt;/a&gt; . Un miembro de datos est&amp;aacute;ticos en l&amp;iacute;nea se puede definir en la definici&amp;oacute;n de clase y puede especificar un inicializador. No necesita una definici&amp;oacute;n fuera de clase:</target>
        </trans-unit>
        <trans-unit id="5da97780b140e6a47935295d4e1ee4870bfe1e89" translate="yes" xml:space="preserve">
          <source>A static member variable (but not a namespace-scope variable) declared &lt;code&gt;constexpr&lt;/code&gt; is implicitly an inline variable.</source>
          <target state="translated">Una variable miembro est&amp;aacute;tica (pero no una variable de &amp;aacute;mbito de espacio de nombres) declarada &lt;code&gt;constexpr&lt;/code&gt; es impl&amp;iacute;citamente una variable en l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="4b6d0fdd7d7607c01a896d9094690fc14c51a0b3" translate="yes" xml:space="preserve">
          <source>A steady clock is used to measure the duration. This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">Un reloj fijo se usa para medir la duraci&amp;oacute;n. Esta funci&amp;oacute;n puede bloquear por m&amp;aacute;s tiempo que &lt;code&gt;timeout_duration&lt;/code&gt; debido a retrasos en la programaci&amp;oacute;n o contenci&amp;oacute;n de recursos.</target>
        </trans-unit>
        <trans-unit id="78127daba885f04d8c232a3a0e396aee55e69e02" translate="yes" xml:space="preserve">
          <source>A store operation with this memory order performs the</source>
          <target state="translated">Una operación de almacenamiento con esta orden de memoria realiza la</target>
        </trans-unit>
        <trans-unit id="c6bc48899775e9a6c5f0a1a15785f5ee33b9cf7b" translate="yes" xml:space="preserve">
          <source>A string describing the given error condition.</source>
          <target state="translated">Una cadena que describe la condición de error dada.</target>
        </trans-unit>
        <trans-unit id="46b19b69118bd315cdfc683d15a6fa75436b64bc" translate="yes" xml:space="preserve">
          <source>A string literal is not necessarily a C string: if a string literal has embedded null characters, it represents an array which contains more than one string.</source>
          <target state="translated">Un literal de cadena no es necesariamente una cadena de C:si un literal de cadena tiene caracteres nulos incrustados,representa una matriz que contiene más de una cadena.</target>
        </trans-unit>
        <trans-unit id="1550cc2a5436eb99f071dfa4dcf0dd47ccf4c825" translate="yes" xml:space="preserve">
          <source>A string view representing the entire contents of the string.</source>
          <target state="translated">Una vista de cadena que representa el contenido completo de la cadena.</target>
        </trans-unit>
        <trans-unit id="32570ac03b4c2c47cffb2bbc021cc0ca86dcc629" translate="yes" xml:space="preserve">
          <source>A structured binding declaration first introduces a uniquely-named variable (here denoted by &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt;) to hold the value of the initializer, as follows:</source>
          <target state="translated">Una declaraci&amp;oacute;n de enlace estructurado introduce primero una variable con un nombre &amp;uacute;nico (aqu&amp;iacute; denotado por &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; ) para mantener el valor del inicializador, de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="144f71d00798ee052aabd4ddb5c24678262a6ae1" translate="yes" xml:space="preserve">
          <source>A structured binding declaration introduces all identifiers in the identifier-list as names in the surrounding scope and binds them to subobjects or elements of the object denoted by expression. The bindings so introduced are called</source>
          <target state="translated">Una declaración vinculante estructurada introduce todos los identificadores en la lista de identificadores como nombres en el ámbito circundante y los vincula a subobjetos o elementos del objeto denotados por la expresión.Las vinculaciones así introducidas se denominan</target>
        </trans-unit>
        <trans-unit id="835974f7bef28e4dff1c1ff405518b0bb98087eb" translate="yes" xml:space="preserve">
          <source>A structured binding declaration then performs the binding in one of three possible ways, depending on &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;:</source>
          <target state="translated">Una declaraci&amp;oacute;n de enlace estructurado realiza el enlace de una de las tres formas posibles, dependiendo de &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5ebdd31b80b554a53c87eaf8af1247d0cf95b1cf" translate="yes" xml:space="preserve">
          <source>A subobject is</source>
          <target state="translated">Un subobjeto es</target>
        </trans-unit>
        <trans-unit id="7a0f0cf82fd7a9695235dbab61201c1151c693d9" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;operator()&lt;/code&gt; synchronizes with a call to any member function of a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; that share their shared state with &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Una llamada exitosa a &lt;code&gt;operator()&lt;/code&gt; sincroniza con una llamada a cualquier funci&amp;oacute;n miembro de un &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; que comparta su estado compartido con &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e5e13088bac64880bbd1d92f74dea1c546eae32" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; clears the end of file status flag &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Una llamada exitosa a &lt;code&gt;ungetc&lt;/code&gt; borra el final del indicador de estado del archivo &lt;code&gt;&lt;a href=&quot;feof&quot;&gt;std::feof&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f18b9828e8cbe5f820c7f00f14018c93e63c261" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a binary stream decrements the stream position indicator by one (the behavior is indeterminate if the stream position indicator was zero).</source>
          <target state="translated">Una llamada exitosa a &lt;code&gt;ungetc&lt;/code&gt; en un flujo binario disminuye el indicador de posici&amp;oacute;n del flujo en uno (el comportamiento es indeterminado si el indicador de posici&amp;oacute;n del flujo era cero).</target>
        </trans-unit>
        <trans-unit id="ca4337b8d12737a6a022afbf7eb03368caa77b5b" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetc&lt;/code&gt; on a text stream modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetc&lt;/code&gt;.</source>
          <target state="translated">Una llamada exitosa a &lt;code&gt;ungetc&lt;/code&gt; en una secuencia de texto modifica el indicador de posici&amp;oacute;n de la secuencia de manera no especificada, pero garantiza que despu&amp;eacute;s de que se recuperen todos los caracteres devueltos con una operaci&amp;oacute;n de lectura, el indicador de posici&amp;oacute;n de la secuencia es igual a su valor antes de &lt;code&gt;ungetc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a28d7859e6f4fcb6db1df05cff06566fff5a4e72" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; clears the end of file status flag &lt;code&gt;feof&lt;/code&gt;.</source>
          <target state="translated">Una llamada exitosa a &lt;code&gt;ungetwc&lt;/code&gt; borra el final de la bandera de estado de archivo &lt;code&gt;feof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96bde972d314cd8969488c09d04edcb68d3e8cec" translate="yes" xml:space="preserve">
          <source>A successful call to &lt;code&gt;ungetwc&lt;/code&gt; on a stream (whether text or binary) modifies the stream position indicator in unspecified manner but guarantees that after all pushed-back wide characters are retrieved with a read operation, the stream position indicator is equal to its value before &lt;code&gt;ungetwc&lt;/code&gt;.</source>
          <target state="translated">Una llamada exitosa a &lt;code&gt;ungetwc&lt;/code&gt; en una secuencia (ya sea texto o binario) modifica el indicador de posici&amp;oacute;n de la secuencia de manera no especificada, pero garantiza que despu&amp;eacute;s de recuperar todos los caracteres anchos retrocedidos con una operaci&amp;oacute;n de lectura, el indicador de posici&amp;oacute;n de la secuencia es igual a su valor antes de &lt;code&gt;ungetwc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4438ef6f7a0682bb256998449673a26881f7a072" translate="yes" xml:space="preserve">
          <source>A template argument for a template template parameter must be an &lt;a href=&quot;name#In_expressions&quot;&gt;id-expression&lt;/a&gt; which names a class template or a template alias.</source>
          <target state="translated">Un argumento de plantilla para un par&amp;aacute;metro de plantilla de plantilla debe ser una &lt;a href=&quot;name#In_expressions&quot;&gt;expresi&amp;oacute;n de identificaci&amp;oacute;n&lt;/a&gt; que nombre una plantilla de clase o un alias de plantilla.</target>
        </trans-unit>
        <trans-unit id="0cbe97ed8a5079b18bed67f0b987c6e75304c3a6" translate="yes" xml:space="preserve">
          <source>A template argument for a type template parameter must be a &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;, which may name an incomplete type:</source>
          <target state="translated">Un argumento de plantilla para un par&amp;aacute;metro de plantilla de tipo debe ser una &lt;a href=&quot;type-id#Type_naming&quot;&gt;identificaci&amp;oacute;n de tipo&lt;/a&gt; , que puede nombrar un tipo incompleto:</target>
        </trans-unit>
        <trans-unit id="b77575f13c55d5afb76807a44c03b42f3be5cca3" translate="yes" xml:space="preserve">
          <source>A template defined in the &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; header may be instantiated with an incomplete type unless otherwise specified, notwithstanding the general prohibition against instantiating standard library templates with incomplete types.</source>
          <target state="translated">Una plantilla definida en el &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; puede instanciarse con un tipo incompleto a menos que se especifique lo contrario, a pesar de la prohibici&amp;oacute;n general de crear instancias de plantillas de biblioteca est&amp;aacute;ndar con tipos incompletos.</target>
        </trans-unit>
        <trans-unit id="3db9cfde6b359f0a7eac7446ebfcb7cabe3498b5" translate="yes" xml:space="preserve">
          <source>A template friend declaration can name a member of a class template A, which can be either a member function or a member type (the type must use &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated-type-specifier&lt;/a&gt;). Such declaration is only well-formed if the last component in its nested-name-specifier (the name to the left of the last &lt;code&gt;::&lt;/code&gt;) is a simple-template-id (template name followed by argument list in angle brackets) that names the class template. The template parameters of such template friend declaration must be deducible from the simple-template-id.</source>
          <target state="translated">Una declaraci&amp;oacute;n de amigo de plantilla puede nombrar a un miembro de una plantilla de clase A, que puede ser una funci&amp;oacute;n de miembro o un tipo de miembro (el tipo debe usar &lt;a href=&quot;elaborated_type_specifier&quot;&gt;un especificador de tipo elaborado&lt;/a&gt; ). Dicha declaraci&amp;oacute;n solo est&amp;aacute; bien formada si el &amp;uacute;ltimo componente en su especificador de nombre anidado (el nombre a la izquierda del &amp;uacute;ltimo &lt;code&gt;::&lt;/code&gt; ) es una identificaci&amp;oacute;n de plantilla simple (nombre de plantilla seguido de una lista de argumentos entre par&amp;eacute;ntesis angulares) que nombra La plantilla de clase. Los par&amp;aacute;metros de plantilla de dicha declaraci&amp;oacute;n de amigo de plantilla deben ser deducibles de simple-template-id.</target>
        </trans-unit>
        <trans-unit id="b8cbfd05ed876a96f58d914b20aab64f29b86a74" translate="yes" xml:space="preserve">
          <source>A template is a C++ entity that defines one of the following:</source>
          <target state="translated">Una plantilla es una entidad C++que define uno de los siguientes aspectos:</target>
        </trans-unit>
        <trans-unit id="59d81713cfdc4799ddf46175f8d61401bcd90683" translate="yes" xml:space="preserve">
          <source>A template parameter of the form &lt;code&gt;class Foo&lt;/code&gt; is not an unnamed non-type template parameter of type &lt;code&gt;Foo&lt;/code&gt;, even if otherwise &lt;code&gt;class Foo&lt;/code&gt; is an &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt; and &lt;code&gt;class Foo x;&lt;/code&gt; declares &lt;code&gt;x&lt;/code&gt; to be of type &lt;code&gt;Foo&lt;/code&gt;.</source>
          <target state="translated">Un par&amp;aacute;metro de plantilla de la &lt;code&gt;class Foo&lt;/code&gt; formulario Foo no es un par&amp;aacute;metro de plantilla sin tipo sin nombre de tipo &lt;code&gt;Foo&lt;/code&gt; , incluso si de lo contrario la &lt;code&gt;class Foo&lt;/code&gt; es un &lt;a href=&quot;elaborated_type_specifier&quot;&gt;especificador de tipo elaborado&lt;/a&gt; y una &lt;code&gt;class Foo x;&lt;/code&gt; declara que &lt;code&gt;x&lt;/code&gt; es del tipo &lt;code&gt;Foo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d85241f2bc54602e57c2582a6ecab6b9f660f5f6" translate="yes" xml:space="preserve">
          <source>A template parameter pack is a template parameter that accepts zero or more template arguments (non-types, types, or templates). A function parameter pack is a function parameter that accepts zero or more function arguments.</source>
          <target state="translated">Un paquete de parámetros de plantilla es un parámetro de plantilla que acepta cero o más argumentos de plantilla (no tipos,tipos o plantillas).Un paquete de parámetros de función es un parámetro de función que acepta cero o más argumentos de función.</target>
        </trans-unit>
        <trans-unit id="eb2fa05aae2cb5737143f68053260c6a62f41e74" translate="yes" xml:space="preserve">
          <source>A template parameter pack that is explicitly specified may be extended by template argument deduction if there are additional arguments:</source>
          <target state="translated">Un paquete de parámetros de plantilla que se especifica explícitamente puede ampliarse mediante la deducción de argumentos de plantilla si hay argumentos adicionales:</target>
        </trans-unit>
        <trans-unit id="f41dfabc2328a29181220b5113304c48aad61703" translate="yes" xml:space="preserve">
          <source>A template specialization that was declared but not defined can be used just like any other &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; (e.g. pointers and references to it may be used).</source>
          <target state="translated">Una especializaci&amp;oacute;n de plantilla que fue declarada pero no definida puede usarse como cualquier otro &lt;a href=&quot;incomplete_type&quot;&gt;tipo incompleto&lt;/a&gt; (por ejemplo, pueden usarse punteros y referencias a ella).</target>
        </trans-unit>
        <trans-unit id="344b2caa5e5fe345b5eddc1d5d915de3d6be2db2" translate="yes" xml:space="preserve">
          <source>A template with at least one parameter pack is called a</source>
          <target state="translated">Una plantilla con al menos un paquete de parámetros se llama</target>
        </trans-unit>
        <trans-unit id="673816c6497404faf247ef589f1b122b3a14f807" translate="yes" xml:space="preserve">
          <source>A template-id is only valid if.</source>
          <target state="translated">Una identificación de plantilla sólo es válida si.</target>
        </trans-unit>
        <trans-unit id="10655830c19a77e3e63f7c59d226efb3c807b9e8" translate="yes" xml:space="preserve">
          <source>A template-id that names an alias template specialization names a type.</source>
          <target state="translated">Un identificador de plantilla que nombra un alias de especialización de plantilla nombra un tipo.</target>
        </trans-unit>
        <trans-unit id="df2b079308f3eca647407b9397b352dc670c7a81" translate="yes" xml:space="preserve">
          <source>A template-id that names an function template specialization names a function.</source>
          <target state="translated">Una identificación de plantilla que nombra una función especialización de plantilla nombra una función.</target>
        </trans-unit>
        <trans-unit id="3c85feec0c63ebeca50f678f352ffcc3928d1b88" translate="yes" xml:space="preserve">
          <source>A templated entity (or, in some sources, &quot;temploid&quot;) is any entity that is defined (or, for a lambda-expression, created) within a template definition. All of the following are templated entities:</source>
          <target state="translated">Una entidad templada (o,en algunas fuentes,&quot;temploide&quot;)es cualquier entidad que se define (o,para una expresión lambda,se crea)dentro de una definición de plantilla.Todas las siguientes son entidades templadas:</target>
        </trans-unit>
        <trans-unit id="97a674e12e96df448607046bf1ea74819514e29d" translate="yes" xml:space="preserve">
          <source>A temporary object of type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; or &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialized&lt;/a&gt;.</source>
          <target state="translated">Un objeto temporal de tipo &lt;code&gt;T&lt;/code&gt; tiene &lt;a href=&quot;../language/value_initialization&quot;&gt;valor inicializado&lt;/a&gt; o &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;agregado inicializado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="33f18c53306de042e4c98fc4f2ec71d92fc7452f" translate="yes" xml:space="preserve">
          <source>A test for self-reset, i.e. whether &lt;code&gt;ptr&lt;/code&gt; points to an object already managed by &lt;code&gt;*this&lt;/code&gt;, is not performed, except where provided as a compiler extension or as a debugging assert. Note that code such as &lt;code&gt;p.reset(p.release())&lt;/code&gt; does not involve self-reset, only code like &lt;code&gt;p.reset(p.get())&lt;/code&gt; does.</source>
          <target state="translated">No se realiza una prueba de restablecimiento autom&amp;aacute;tico, es decir, si &lt;code&gt;ptr&lt;/code&gt; apunta a un objeto ya administrado por &lt;code&gt;*this&lt;/code&gt; , no se realiza, excepto cuando se proporciona como una extensi&amp;oacute;n del compilador o como una afirmaci&amp;oacute;n de depuraci&amp;oacute;n. Tenga en cuenta que el c&amp;oacute;digo como &lt;code&gt;p.reset(p.release())&lt;/code&gt; no implica un reinicio autom&amp;aacute;tico, solo el c&amp;oacute;digo como &lt;code&gt;p.reset(p.get())&lt;/code&gt; s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="69a493f42c2d5d0a3d7b1e06a1285a10bdbe7061" translate="yes" xml:space="preserve">
          <source>A thread is said to</source>
          <target state="translated">Se dice que un hilo</target>
        </trans-unit>
        <trans-unit id="ba9c13c0f9167e54bcbaf88e115f4167e83660c0" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;lock&lt;/code&gt; on a recursive mutex repeatedly. Ownership will only be released after the thread makes a matching number of calls to &lt;code&gt;unlock&lt;/code&gt;.</source>
          <target state="translated">Un hilo puede llamar al &lt;code&gt;lock&lt;/code&gt; en un mutex recursivo repetidamente. La propiedad solo se liberar&amp;aacute; despu&amp;eacute;s de que el hilo haga un n&amp;uacute;mero coincidente de llamadas para &lt;code&gt;unlock&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f432eae50bd789012a099dcf2a13f431564693f" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock&lt;/code&gt; increment the ownsership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Un hilo puede llamar a &lt;code&gt;try_lock&lt;/code&gt; en un mutex recursivo repetidamente. Las llamadas exitosas a &lt;code&gt;try_lock&lt;/code&gt; incrementan el recuento de propiedad: el mutex solo se liberar&amp;aacute; despu&amp;eacute;s de que el hilo haga un n&amp;uacute;mero coincidente de llamadas para &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37671f46b069e4bce5a6c704520d4965568d9f60" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_for&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_for&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Un hilo puede llamar a &lt;code&gt;try_lock_for&lt;/code&gt; en un mutex recursivo repetidamente. Las llamadas exitosas a &lt;code&gt;try_lock_for&lt;/code&gt; incrementan el conteo de propiedad: el mutex solo se liberar&amp;aacute; despu&amp;eacute;s de que el hilo haga un n&amp;uacute;mero coincidente de llamadas para &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="892016f3791df53a75393a4054de36f6670ede74" translate="yes" xml:space="preserve">
          <source>A thread may call &lt;code&gt;try_lock_until&lt;/code&gt; on a recursive mutex repeatedly. Successful calls to &lt;code&gt;try_lock_until&lt;/code&gt; increment the ownership count: the mutex will only be released after the thread makes a matching number of calls to &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Un subproceso puede llamar a &lt;code&gt;try_lock_until&lt;/code&gt; en un mutex recursivo repetidamente. Las llamadas exitosas a &lt;code&gt;try_lock_until&lt;/code&gt; incrementan el conteo de propiedad: el mutex solo se liberar&amp;aacute; despu&amp;eacute;s de que el hilo haga un n&amp;uacute;mero coincidente de llamadas para &lt;code&gt;&lt;a href=&quot;unlock&quot;&gt;unlock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b4560e93294ed5a9703378d1e170be75de3f418" translate="yes" xml:space="preserve">
          <source>A thread object does not have an associated thread (and is safe to destroy) after.</source>
          <target state="translated">Un objeto de hilo no tiene un hilo asociado (y es seguro de destruir)después.</target>
        </trans-unit>
        <trans-unit id="bac126fd4b2160e8de884ee506093cb6e1453d7a" translate="yes" xml:space="preserve">
          <source>A thread of execution is a flow of control within a program that begins with the invocation of a top-level function by &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, or other means.</source>
          <target state="translated">Un hilo de ejecuci&amp;oacute;n es un flujo de control dentro de un programa que comienza con la invocaci&amp;oacute;n de una funci&amp;oacute;n de nivel superior por &lt;code&gt;&lt;a href=&quot;../thread/thread/thread&quot;&gt;std::thread::thread&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../thread/async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; u otros medios.</target>
        </trans-unit>
        <trans-unit id="13fb085a74dd9fd867bcbeeeed6c63aa5ff60cd7" translate="yes" xml:space="preserve">
          <source>A thread that has finished executing code, but has not yet been joined is still considered an active thread of execution and is therefore joinable.</source>
          <target state="translated">Un hilo que ha terminado de ejecutar el código,pero que aún no se ha unido,sigue siendo considerado un hilo de ejecución activo y por lo tanto se puede unir.</target>
        </trans-unit>
        <trans-unit id="d83b1a24d6c356fdf4f8f81bf30022c94f556e0c" translate="yes" xml:space="preserve">
          <source>A time point is a duration of time that has passed since the epoch of a specific clock.</source>
          <target state="translated">Un punto de tiempo es una duración de tiempo que ha pasado desde la época de un reloj específico.</target>
        </trans-unit>
        <trans-unit id="842ecf6d69cdbeaddd28ab48c6e44b247497210b" translate="yes" xml:space="preserve">
          <source>A time point representing the current time.</source>
          <target state="translated">Un punto de tiempo que representa la hora actual.</target>
        </trans-unit>
        <trans-unit id="482e88b6e7ea3206c3e62b40431b9801a98e659f" translate="yes" xml:space="preserve">
          <source>A trailing template-argument can be left unspecified in an explicit instantiation of a function template specialization or of a member function template specialization if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from the function parameter.</source>
          <target state="translated">Un argumento de plantilla final puede dejarse sin especificar en una instanciaci&amp;oacute;n expl&amp;iacute;cita de una especializaci&amp;oacute;n de plantilla de funci&amp;oacute;n o de una especializaci&amp;oacute;n de plantilla de funci&amp;oacute;n miembro si puede &lt;a href=&quot;template_argument_deduction&quot;&gt;deducirse&lt;/a&gt; del par&amp;aacute;metro de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1744e51348fac7204c6560fe5f680fd02436a4e6" translate="yes" xml:space="preserve">
          <source>A translation unit that includes a standard library header may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names declared in any standard library header.</source>
          <target state="translated">Una unidad de traducci&amp;oacute;n que incluye un encabezado de biblioteca est&amp;aacute;ndar no puede &lt;code&gt;#define&lt;/code&gt; o &lt;code&gt;#undef&lt;/code&gt; nombres declarados en ning&amp;uacute;n encabezado de biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="e8a16a40cb320ca82f7aab312a29ceda1b14f739" translate="yes" xml:space="preserve">
          <source>A translation unit that uses any part of the standard library may not &lt;code&gt;#define&lt;/code&gt; or &lt;code&gt;#undef&lt;/code&gt; names lexically identical to:</source>
          <target state="translated">Una unidad de traducci&amp;oacute;n que usa cualquier parte de la biblioteca est&amp;aacute;ndar puede no &lt;code&gt;#define&lt;/code&gt; o &lt;code&gt;#undef&lt;/code&gt; nombres l&amp;eacute;xicamente id&amp;eacute;nticos a:</target>
        </trans-unit>
        <trans-unit id="d317f7a0ab3e788267489e0fc1532ddec6c12c38" translate="yes" xml:space="preserve">
          <source>A trivial copy assignment operator makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially copy-assignable.</source>
          <target state="translated">Un operador de asignaci&amp;oacute;n de copia trivial realiza una copia de la representaci&amp;oacute;n del objeto como por &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; . Todos los tipos de datos compatibles con el lenguaje C (tipos POD) son trivialmente copiables.</target>
        </trans-unit>
        <trans-unit id="dd6abf8a66d91871c0f211e838354255f118cc43" translate="yes" xml:space="preserve">
          <source>A trivial copy constructor for a non-union class effectively copies every scalar subobject (including, recursively, subobject of subobjects and so forth) of the argument and performs no other action. However, padding bytes need not be copied, and even the object representations of the copied subobjects need not be the same as long as their values are identical.</source>
          <target state="translated">Un constructor de copias triviales para una clase no sindicalizada copia efectivamente cada subobjeto escalar (incluyendo,recursivamente,subobjeto de subobjetos y así sucesivamente)del argumento y no realiza ninguna otra acción.Sin embargo,no es necesario copiar los bytes de relleno,e incluso las representaciones de objetos de los subobjetos copiados no tienen por qué ser iguales siempre que sus valores sean idénticos.</target>
        </trans-unit>
        <trans-unit id="53f265b51a6ad6bc29b0d13aa314fdd06dcfce6a" translate="yes" xml:space="preserve">
          <source>A trivial default constructor is a constructor that performs no action. All data types compatible with the C language (POD types) are trivially default-constructible. Unlike &lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;in C&lt;/a&gt;, however, objects with trivial default constructors cannot be created by simply reinterpreting suitably aligned storage, such as memory allocated with &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;: placement-new is required to formally &lt;a href=&quot;objects&quot;&gt;introduce a new object&lt;/a&gt; and avoid potential undefined behavior.</source>
          <target state="translated">Un constructor predeterminado trivial es un constructor que no realiza ninguna acci&amp;oacute;n. Todos los tipos de datos compatibles con el lenguaje C (tipos POD) son trivialmente construibles por defecto. Sin embargo, a diferencia &lt;a href=&quot;http://en.cppreference.com/w/c/language/object.html#Effective_type&quot;&gt;de C&lt;/a&gt; , los objetos con constructores predeterminados triviales no se pueden crear simplemente reinterpretando el almacenamiento adecuadamente alineado, como la memoria asignada con &lt;code&gt;&lt;a href=&quot;../memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; : position-new es necesaria para &lt;a href=&quot;objects&quot;&gt;introducir&lt;/a&gt; formalmente un nuevo objeto y evitar un posible comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="033337ca5c4ad7c5b77be1ecaa5de6acda3c11c8" translate="yes" xml:space="preserve">
          <source>A trivial destructor is a destructor that performs no action. Objects with trivial destructors don't require a delete-expression and may be disposed of by simply deallocating their storage. All data types compatible with the C language (POD types) are trivially destructible.</source>
          <target state="translated">Un destructor trivial es un destructor que no realiza ninguna acción.Los objetos con destructores triviales no requieren una expresión de borrado y pueden ser eliminados simplemente colocando su almacenamiento.Todos los tipos de datos compatibles con el lenguaje C (tipos POD)son trivialmente destructibles.</target>
        </trans-unit>
        <trans-unit id="d79042321968ff405b9eb41b02f03841f248eb8b" translate="yes" xml:space="preserve">
          <source>A trivial move assignment operator performs the same action as the trivial copy assignment operator, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially move-assignable.</source>
          <target state="translated">Un operador de asignaci&amp;oacute;n de movimiento trivial realiza la misma acci&amp;oacute;n que el operador de asignaci&amp;oacute;n de copia trivial, es decir, hace una copia de la representaci&amp;oacute;n del objeto como si fuera &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; . Todos los tipos de datos compatibles con el lenguaje C (tipos POD) son trivialmente asignables por movimiento.</target>
        </trans-unit>
        <trans-unit id="0ceb73134e634232cb9fed5b06967cd8af551fd6" translate="yes" xml:space="preserve">
          <source>A trivial move constructor is a constructor that performs the same action as the trivial copy constructor, that is, makes a copy of the object representation as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;. All data types compatible with the C language (POD types) are trivially movable.</source>
          <target state="translated">Un constructor de movimiento trivial es un constructor que realiza la misma acci&amp;oacute;n que el constructor de copia trivial, es decir, hace una copia de la representaci&amp;oacute;n del objeto como si fuera &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; . Todos los tipos de datos compatibles con el lenguaje C (tipos POD) son trivialmente m&amp;oacute;viles.</target>
        </trans-unit>
        <trans-unit id="4362f0ff877083bd05b03790df742e70f948b72d" translate="yes" xml:space="preserve">
          <source>A try-block is a &lt;a href=&quot;statements&quot;&gt;statement&lt;/a&gt;, and as such, can appear anywhere a statement can appear (that is, as one of the statements in a compound statement, including the function body compound statement). See &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; for the try blocks around function bodies. The following description applies to both try-blocks and &lt;a href=&quot;function-try-block&quot;&gt;function-try-blocks&lt;/a&gt;.</source>
          <target state="translated">Un bloque de prueba es una &lt;a href=&quot;statements&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; y, como tal, puede aparecer en cualquier lugar donde pueda aparecer una declaraci&amp;oacute;n (es decir, como una de las declaraciones en una declaraci&amp;oacute;n compuesta, incluida la declaraci&amp;oacute;n compuesta del cuerpo de la funci&amp;oacute;n). Ver &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt; para los bloques try alrededor de los cuerpos de funciones. La siguiente descripci&amp;oacute;n se aplica tanto a try-blocks como a &lt;a href=&quot;function-try-block&quot;&gt;function-try-blocks&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="19834a31076ba08c517eaff630de5e748d366c53" translate="yes" xml:space="preserve">
          <source>A type &lt;code&gt;E&lt;/code&gt; satisfying &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; will additionally satisfy RandomNumberEngine if, given.</source>
          <target state="translated">Un tipo &lt;code&gt;E&lt;/code&gt; que satisfaga &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; tambi&amp;eacute;n satisfar&amp;aacute; RandomNumberEngine si se proporciona.</target>
        </trans-unit>
        <trans-unit id="ca6cf0688a958e8a7bf6dc59cfc4cfb1df147a82" translate="yes" xml:space="preserve">
          <source>A type T is ValueSwappable if.</source>
          <target state="translated">Un tipo T es ValueSwappable si.</target>
        </trans-unit>
        <trans-unit id="a7bc09bb961fc3d44a04b48c1111a1a318bd62fe" translate="yes" xml:space="preserve">
          <source>A type has</source>
          <target state="translated">Un tipo tiene</target>
        </trans-unit>
        <trans-unit id="1816dc600e8b7d025987ab256efe8b9a53ee4eb9" translate="yes" xml:space="preserve">
          <source>A type requirement is the keyword &lt;code&gt;typename&lt;/code&gt; followed by a type name, optionally qualified. The requirement is that the named type is valid: this can be used to verify that a certain named nested type exists, or that a class template specialization names a type, or that an alias template specialization names a type. A type requirement naming a class template specialization does not require the type to be complete.</source>
          <target state="translated">Un requisito de tipo es la palabra clave &lt;code&gt;typename&lt;/code&gt; seguida de un nombre de tipo, opcionalmente calificado. El requisito es que el tipo con nombre sea v&amp;aacute;lido: esto se puede utilizar para verificar que existe un cierto tipo anidado con nombre, o que una especializaci&amp;oacute;n de plantilla de clase nombra un tipo, o que una especializaci&amp;oacute;n de plantilla de alias nombra un tipo. Un requisito de tipo que nombra una especializaci&amp;oacute;n de plantilla de clase no requiere que el tipo est&amp;eacute; completo.</target>
        </trans-unit>
        <trans-unit id="15ef01c2ad4973128037ff3072f4151a78c62933" translate="yes" xml:space="preserve">
          <source>A type that can hold all valid values of &lt;code&gt;X::char_type&lt;/code&gt; plus &lt;code&gt;X::eof()&lt;/code&gt;</source>
          <target state="translated">Un tipo que puede contener todos los valores v&amp;aacute;lidos de &lt;code&gt;X::char_type&lt;/code&gt; plus &lt;code&gt;X::eof()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="03ac68cf57c6c426934400170b4271e37c362fbe" translate="yes" xml:space="preserve">
          <source>A typical cause of failure for &lt;code&gt;std::puts&lt;/code&gt; is running out of space on the file system, when &lt;code&gt;stdout&lt;/code&gt; is redirected to a file.</source>
          <target state="translated">Una causa t&amp;iacute;pica de falla para &lt;code&gt;std::puts&lt;/code&gt; es quedarse sin espacio en el sistema de archivos, cuando &lt;code&gt;stdout&lt;/code&gt; se redirige a un archivo.</target>
        </trans-unit>
        <trans-unit id="ae95c3cb82eea0b19d5fa37c3903de19a5db5a6a" translate="yes" xml:space="preserve">
          <source>A typical example of such situation is the naive implementation of &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; (derived from the empty base &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;), which holds the underlying iterator (also derived from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt;) as its first non-static data member.</source>
          <target state="translated">Un ejemplo t&amp;iacute;pico de tal situaci&amp;oacute;n es la implementaci&amp;oacute;n ingenua de &lt;code&gt;&lt;a href=&quot;../iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; (derivada de la base vac&amp;iacute;a &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; ), que mantiene el iterador subyacente (tambi&amp;eacute;n derivado de &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&lt;/code&gt; ) como su primer miembro de datos no est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="0734374c55a399a52d1410a4e6f7c1c0d057f16d" translate="yes" xml:space="preserve">
          <source>A typical generator's yield_value would store (copy/move or just store the address of, since the argument's lifetime crosses the suspension point inside the co_await) its argument into the generator object and return &lt;code&gt;std::suspend_always&lt;/code&gt;, transferring control to the caller/resumer.</source>
          <target state="translated">El t&amp;iacute;pico value_value de un generador almacena (copia / mueve o simplemente almacena la direcci&amp;oacute;n de, ya que la vida &amp;uacute;til del argumento cruza el punto de suspensi&amp;oacute;n dentro del co_await) su argumento en el objeto generador y devuelve &lt;code&gt;std::suspend_always&lt;/code&gt; , transfiriendo el control a la persona que llama / reanudar.</target>
        </trans-unit>
        <trans-unit id="51f160ce423fd83704df3a5cb0174dbe3220c314" translate="yes" xml:space="preserve">
          <source>A typical implementation holds one integer data member (the value) and a pointer to an &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica contiene un miembro de datos entero (el valor) y un puntero a &lt;code&gt;&lt;a href=&quot;error_category&quot;&gt;std::error_category&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1aa218a5c2f20a77c0b0ce98af0029f85ebd7ae1" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to &lt;code&gt;T&lt;/code&gt; and a size.</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica tiene solo dos miembros: un puntero a &lt;code&gt;T&lt;/code&gt; y un tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="b1049a0bd6d2b817dcdf4dbacf6924d39c59809b" translate="yes" xml:space="preserve">
          <source>A typical implementation holds only two members: a pointer to constant &lt;code&gt;CharT&lt;/code&gt; and a size.</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica tiene solo dos miembros: un puntero a &lt;code&gt;CharT&lt;/code&gt; constante y un tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="2c4f9d8e2fe4e7c12c1285e532e5570e4bb48e5d" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_fstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica de &lt;code&gt;std::basic_fstream&lt;/code&gt; contiene solo un miembro de datos no derivado: una instancia de &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8130838cccfdb668dc1da70d0ff806b7225abc0" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ifstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica de &lt;code&gt;std::basic_ifstream&lt;/code&gt; contiene solo un miembro de datos no derivado: una instancia de &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7183d62923a8e947e2f0e103df21cd2904d87891" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::basic_ofstream&lt;/code&gt; holds only one non-derived data member: an instance of &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica de &lt;code&gt;std::basic_ofstream&lt;/code&gt; contiene solo un miembro de datos no derivado: una instancia de &lt;code&gt;&lt;a href=&quot;basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="217f99906b2120be1fba7713f69e991a00815576" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::istream_iterator&lt;/code&gt; holds two data members: a pointer to the associated &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; object and the most recently read value of type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Una aplicaci&amp;oacute;n t&amp;iacute;pica de &lt;code&gt;std::istream_iterator&lt;/code&gt; tiene dos miembros de datos: un puntero a The Associated &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; objeto y el &amp;uacute;ltimo valor le&amp;iacute;do de tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad3a71fd17c76f0ee62dee1d66ae5633a375fd68" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_iterator&lt;/code&gt; holds the begin and the end iterators for the underlying sequence (two instances of BidirIt), a pointer to the regular expression (&lt;code&gt;const regex_type*&lt;/code&gt;), the match flags (&lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt;), and the current match (&lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica de &lt;code&gt;std::regex_iterator&lt;/code&gt; contiene los iteradores de inicio y fin de la secuencia subyacente (dos instancias de BidirIt), un puntero a la expresi&amp;oacute;n regular ( &lt;code&gt;const regex_type*&lt;/code&gt; ), los indicadores de coincidencia ( &lt;code&gt;&lt;a href=&quot;match_flag_type&quot;&gt;std::regex_constants::match_flag_type&lt;/a&gt;&lt;/code&gt; ) , y la coincidencia actual ( &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&amp;lt;BidirIt&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5594f6466e9c627a309f191d1d21416131d6dcaa" translate="yes" xml:space="preserve">
          <source>A typical implementation of &lt;code&gt;std::regex_token_iterator&lt;/code&gt; holds the underlying &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, a container (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt;) of the requested submatch indexes, the internal counter equal to the index of the submatch, a pointer to &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;, pointing at the current submatch of the current match, and a &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; object containing the last non-matched character sequence (used in tokenizer mode).</source>
          <target state="translated">Una implementaci&amp;oacute;n t&amp;iacute;pica de &lt;code&gt;std::regex_token_iterator&lt;/code&gt; contiene el &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; subyacente , un contenedor (por ejemplo, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;int&amp;gt;&lt;/code&gt; ) de los &amp;iacute;ndices de subcoincidencia solicitados, el contador interno igual al &amp;iacute;ndice de la subcoincidencia, un puntero a &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; , apuntando a la subcoincidencia actual de la coincidencia actual, y un objeto &lt;code&gt;&lt;a href=&quot;match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; que contiene la &amp;uacute;ltima secuencia de caracteres no coincidentes (utilizada en modo tokenizer).</target>
        </trans-unit>
        <trans-unit id="ec993624f290f31f38642161da480cca7738a5b4" translate="yes" xml:space="preserve">
          <source>A uniform random bit generator is a function object returning unsigned integer values such that each value in the range of possible results has (ideally) equal probability.</source>
          <target state="translated">Un generador de bits aleatorios uniformes es un objeto de función que devuelve valores enteros sin signo,de manera que cada valor de la gama de resultados posibles tiene (idealmente)igual probabilidad.</target>
        </trans-unit>
        <trans-unit id="5b1045e71b04fce292271774a5a72bec6686a37d" translate="yes" xml:space="preserve">
          <source>A union can have member functions (including constructors and destructors), but not virtual functions.</source>
          <target state="translated">Una unión puede tener funciones de miembro (incluyendo constructores y destructores),pero no funciones virtuales.</target>
        </trans-unit>
        <trans-unit id="a2abfe76729a7513736cb7faa5d5ce5576166784" translate="yes" xml:space="preserve">
          <source>A union cannot have base classes and cannot be used as a base class.</source>
          <target state="translated">Un sindicato no puede tener clases de base y no puede ser usado como una clase de base.</target>
        </trans-unit>
        <trans-unit id="d044e7ff18d6370026b7cb48f5515536c724fbdc" translate="yes" xml:space="preserve">
          <source>A union cannot have non-static data members of reference types.</source>
          <target state="translated">Una unión no puede tener miembros de datos no estáticos de los tipos de referencia.</target>
        </trans-unit>
        <trans-unit id="8c914c20794cb64933a85898ab023cc57498cff6" translate="yes" xml:space="preserve">
          <source>A union is a special class type that can hold only one of its non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; at a time.</source>
          <target state="translated">Una uni&amp;oacute;n es un tipo de clase especial que puede contener solo uno de sus &lt;a href=&quot;data_members&quot;&gt;miembros de datos&lt;/a&gt; no est&amp;aacute;ticos a la vez.</target>
        </trans-unit>
        <trans-unit id="b72fa34edde9b7a760e2ca9a63cea91e1b555145" translate="yes" xml:space="preserve">
          <source>A universal character name in a narrow string literal or a 16-bit string literal may map to more than one character, e.g. &lt;code&gt;\U0001f34c&lt;/code&gt; is 4 &lt;code&gt;char&lt;/code&gt; code units in UTF-8 (&lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt;) and 2 &lt;code&gt;char16_t&lt;/code&gt; code units in UTF-16 (&lt;code&gt;\uD83C\uDF4C&lt;/code&gt;).</source>
          <target state="translated">Un nombre de car&amp;aacute;cter universal en un literal de cadena estrecha o un literal de cadena de 16 bits puede asignar a m&amp;aacute;s de un car&amp;aacute;cter, por ejemplo &lt;code&gt;\U0001f34c&lt;/code&gt; es de 4 &lt;code&gt;char&lt;/code&gt; unidades de c&amp;oacute;digo en UTF-8 ( &lt;code&gt;\xF0\x9F\x8D\x8C&lt;/code&gt; ) y 2 &lt;code&gt;char16_t&lt;/code&gt; c&amp;oacute;digo unidades en UTF-16 ( &lt;code&gt;\uD83C\uDF4C&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="416c36a6fa82a246cd095bd156c7aaf5425291a8" translate="yes" xml:space="preserve">
          <source>A useful guideline is that the destructor of any base class must be &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;public and virtual or protected and non-virtual&lt;/a&gt;.</source>
          <target state="translated">Una gu&amp;iacute;a &amp;uacute;til es que el destructor de cualquier clase base debe ser &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#discussion-make-base-class-destructors-public-and-virtual-or-protected-and-nonvirtual&quot;&gt;p&amp;uacute;blico y virtual o protegido y no virtual&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83e4b1da3b5d3236546ebba09aeb934da81e6f4f" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; can be a template.</source>
          <target state="translated">Una &lt;a href=&quot;cast_operator&quot;&gt;funci&amp;oacute;n de conversi&amp;oacute;n&lt;/a&gt; definida por el usuario puede ser una plantilla.</target>
        </trans-unit>
        <trans-unit id="5d638bfd657359641307f2e7271f6931cb2015b9" translate="yes" xml:space="preserve">
          <source>A user-defined &lt;code&gt;std::unexpected_handler&lt;/code&gt; is expected to either terminate the program or throw an exception. If it throws an exception, one of the following three situations may be encountered:</source>
          <target state="translated">Se espera que un &lt;code&gt;std::unexpected_handler&lt;/code&gt; definido por el usuario finalice el programa o arroje una excepci&amp;oacute;n. Si arroja una excepci&amp;oacute;n, se puede encontrar una de las siguientes tres situaciones:</target>
        </trans-unit>
        <trans-unit id="73f25ff036d8280e869a001e21e48bbeb542c334" translate="yes" xml:space="preserve">
          <source>A user-defined conversion consists of zero or one non-explicit single-argument constructor or non-explicit &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt; call.</source>
          <target state="translated">Una conversi&amp;oacute;n definida por el usuario consiste en cero o un constructor de argumento &amp;uacute;nico no expl&amp;iacute;cito o una llamada de &lt;a href=&quot;cast_operator&quot;&gt;funci&amp;oacute;n de conversi&amp;oacute;n&lt;/a&gt; no expl&amp;iacute;cita .</target>
        </trans-unit>
        <trans-unit id="d0e1aabd13d35e1072413a4e56940753290b1935" translate="yes" xml:space="preserve">
          <source>A user-defined conversion function template cannot have a deduced return type.</source>
          <target state="translated">Una plantilla de función de conversión definida por el usuario no puede tener un tipo de retorno deducido.</target>
        </trans-unit>
        <trans-unit id="1e6c06935ba93da6b0506db32bcdb2cfcdba4051" translate="yes" xml:space="preserve">
          <source>A user-defined literal is an expression of any of the following forms.</source>
          <target state="translated">Un literal definido por el usuario es una expresión de cualquiera de las siguientes formas.</target>
        </trans-unit>
        <trans-unit id="3054b1de584f16f3593abd57817b8a39cfd5c191" translate="yes" xml:space="preserve">
          <source>A user-provided &lt;code&gt;Compare&lt;/code&gt; can be supplied to change the ordering, e.g. using &lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; would cause the smallest element to appear as the &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se puede proporcionar una &lt;code&gt;Compare&lt;/code&gt; proporcionada por el usuario para cambiar el orden, por ejemplo, usar &lt;code&gt;std::greater&amp;lt;T&amp;gt;&lt;/code&gt; har&amp;iacute;a que el elemento m&amp;aacute;s peque&amp;ntilde;o aparezca como &lt;code&gt;&lt;a href=&quot;priority_queue/top&quot;&gt;top()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="640dc08af4538f2be62eb03eb3dd195df49a90d2" translate="yes" xml:space="preserve">
          <source>A using-declaration also can't be used to introduce the name of a dependent member template as a</source>
          <target state="translated">Tampoco se puede utilizar una declaración de uso para introducir el nombre de una plantilla de miembro dependiente como un</target>
        </trans-unit>
        <trans-unit id="4bae902040c5ab2ebd693033e3fed94dda49e2af" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot name a member template specialization (&lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; is not permitted by the grammar):</source>
          <target state="translated">Una declaraci&amp;oacute;n de uso no puede nombrar una especializaci&amp;oacute;n de plantilla miembro ( la gram&amp;aacute;tica no permite &lt;a href=&quot;templates#template-id&quot;&gt;id-plantilla&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="ef90b2e3eff9b374774e4a806f69699ec8e2d794" translate="yes" xml:space="preserve">
          <source>A using-declaration cannot refer to a namespace, to a scoped enumerator, to a destructor of a base class or to a specialization of a member template for a user-defined conversion function.</source>
          <target state="translated">Una declaración de uso no puede referirse a un espacio de nombres,a un enumerador de alcance,a un destructor de una clase base o a una especialización de una plantilla de miembro para una función de conversión definida por el usuario.</target>
        </trans-unit>
        <trans-unit id="b03fbcaa0bf1071b311fbaae0c5ce6b26d0a8ede" translate="yes" xml:space="preserve">
          <source>A using-declaration with more than one using-declarator is equivalent to a corresponding sequence of using-declarations with one using-declarator.</source>
          <target state="translated">Una declaración de uso con más de un declarante de uso equivale a una secuencia correspondiente de declaraciones de uso con un declarante de uso.</target>
        </trans-unit>
        <trans-unit id="20d0f9a0bea74c92ad5ff18da1b24cd553bbba2b" translate="yes" xml:space="preserve">
          <source>A valarray with the same size as the parameter.</source>
          <target state="translated">Un valarray con el mismo tamaño del parámetro.</target>
        </trans-unit>
        <trans-unit id="9b0aa598587fc3cc855c9c9ccc2c85d04dd3b0d5" translate="yes" xml:space="preserve">
          <source>A valid const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Un iterador constante v&amp;aacute;lido para &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="14a30aab0776a047f20feb27371310d867438a4f" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable const iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Un iterador const desreferenciable v&amp;aacute;lido para &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7c5ba5e3ccd5588e225779b9a36ab64c069c240a" translate="yes" xml:space="preserve">
          <source>A valid dereferenceable iterator to &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Un iterador desreferenciable v&amp;aacute;lido para &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="28223fe6cd5ada49f5862218ac60de143b2567db" translate="yes" xml:space="preserve">
          <source>A value equal to 0 if the path is lexicographically equal to the given path.</source>
          <target state="translated">Un valor igual a 0 si el camino es lexicográficamente igual al camino dado.</target>
        </trans-unit>
        <trans-unit id="a50061555eec54932403da5e038843403742ee9c" translate="yes" xml:space="preserve">
          <source>A value equivalent to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Un valor equivalente a &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de1ab572a1a705bc1af0966dac1fe26f7ab37241" translate="yes" xml:space="preserve">
          <source>A value greater than 0 if the path is lexicographically greater than the given path.</source>
          <target state="translated">Un valor mayor que 0 si el camino es lexicográficamente mayor que el camino dado.</target>
        </trans-unit>
        <trans-unit id="59605f92ecf81d222cf73bc53f88e408d0be42bc" translate="yes" xml:space="preserve">
          <source>A value less than 0 if the path is lexicographically less than the given path.</source>
          <target state="translated">Un valor menor que 0 si el camino es lexicográficamente menor que el camino dado.</target>
        </trans-unit>
        <trans-unit id="772e15e1bdd5eccbbc37f434f301068fa5b598a7" translate="yes" xml:space="preserve">
          <source>A value less than zero if this sub_match is</source>
          <target state="translated">Un valor menor que cero si este sub_partido es</target>
        </trans-unit>
        <trans-unit id="32241575a78d789ffd0a6260e7ef09d51214c2a4" translate="yes" xml:space="preserve">
          <source>A value not equivalent to any valid value of type &lt;code&gt;char_type&lt;/code&gt;.</source>
          <target state="translated">Un valor no equivalente a ning&amp;uacute;n valor v&amp;aacute;lido de tipo &lt;code&gt;char_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b19e1b2f4ff9e9aafad05b04d18d7cec329645b" translate="yes" xml:space="preserve">
          <source>A value of a floating-point type can also be converted to any complete enumeration type.</source>
          <target state="translated">Un valor de un tipo de punto flotante también puede convertirse en cualquier tipo de enumeración completa.</target>
        </trans-unit>
        <trans-unit id="63a22bbd341be0d94948a8da39b757c96e4a822a" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; que contiene el n&amp;uacute;mero de c&amp;oacute;digo de error de &lt;code&gt;e&lt;/code&gt; asociado con la categor&amp;iacute;a de error &lt;code&gt;&quot;future&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d689f1f7f9107c84de7e9e6a91164c4d8d448b7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; que contiene el n&amp;uacute;mero de c&amp;oacute;digo de error de &lt;code&gt;e&lt;/code&gt; asociado con la categor&amp;iacute;a de error &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d85edc98c1d148807f1167309444da367dce2885" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;future&quot;&lt;/code&gt;.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; que contiene el n&amp;uacute;mero de c&amp;oacute;digo de error de &lt;code&gt;e&lt;/code&gt; asociado con la categor&amp;iacute;a de error &lt;code&gt;&quot;future&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db29599a3ec1300b12f7cddbf4961efd2a438f2c" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; that holds the error code number from &lt;code&gt;e&lt;/code&gt; associated with the error category &lt;code&gt;&quot;iostream&quot;&lt;/code&gt;.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; que contiene el n&amp;uacute;mero de c&amp;oacute;digo de error de &lt;code&gt;e&lt;/code&gt; asociado con la categor&amp;iacute;a de error &lt;code&gt;&quot;iostream&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d4716864d7aecb12710c82c5051f8f56cfc5d9f6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt;, indicating the success status as follows:</source>
          <target state="translated">Un valor de tipo &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::result&lt;/a&gt;&lt;/code&gt; , que indica el estado de &amp;eacute;xito de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="32fad6cd0042895426d631ee6330654d50fdd26f" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; identifying the thread associated with &lt;code&gt;*this&lt;/code&gt;. If there is no thread associated, default constructed &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; identifica el hilo asociado con &lt;code&gt;*this&lt;/code&gt; . Si no hay ning&amp;uacute;n subproceso asociado, se devuelve &lt;code&gt;&lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; construido por defecto .</target>
        </trans-unit>
        <trans-unit id="4007ab79efb7d58184f823559bcab8f2c0fe4508" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::key_type&lt;/code&gt;</source>
          <target state="translated">Un valor de tipo &lt;code&gt;X::key_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="072712158f85df6191a61fbd61f9b1af57edb2a6" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;X::value_type&lt;/code&gt;</source>
          <target state="translated">Un valor de tipo &lt;code&gt;X::value_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c9fa2a7989928288a59b9d1061cab281384dc7d7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;dateorder&lt;/code&gt;.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;dateorder&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e52779b1e6c9706944a08739b4d2e94ab73e1ebe" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; representing &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;std::chrono::system_clock::time_point&lt;/code&gt; representa &lt;code&gt;t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="372178480f2f29b6cd4a1502b1b12fa8b61b4a68" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::partial_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;std::partial_ordering&lt;/code&gt; , como se describi&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="f50da534940de9fa538b0344ec2f07e991732fc7" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;std::strong_equality&lt;/code&gt; , como se describi&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="1240d3098b2313d3e38b4e6524a3981c2caf173b" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::strong_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;std::strong_ordering&lt;/code&gt; , como se describi&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="d920da1ed499cf59fb8f2ff084478f87888ebedf" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_equality&lt;/code&gt;, as described above.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;std::weak_equality&lt;/code&gt; , como se describi&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="84362b6647406e2ba1f03eb0961d6929e28947bb" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;std::weak_ordering&lt;/code&gt;, as described above.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;std::weak_ordering&lt;/code&gt; , como se describi&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="d92cb041f91a75157fbd95d555f69774c1ab1976" translate="yes" xml:space="preserve">
          <source>A value of type &lt;code&gt;void (*)(int)&lt;/code&gt;. When returned by &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt;, indicates that an error has occurred.</source>
          <target state="translated">Un valor de tipo &lt;code&gt;void (*)(int)&lt;/code&gt; . Cuando lo devuelve &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; , indica que se ha producido un error.</target>
        </trans-unit>
        <trans-unit id="03d7158f8947427f81b002e1dd1993eed28a9ff7" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;!c(ku, r)&lt;/code&gt;</source>
          <target state="translated">Un valor tal que &lt;code&gt;a&lt;/code&gt; est&amp;aacute; dividido con respecto a &lt;code&gt;!c(ku, r)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="450945ae5d73489824ccfb0cd773638c26cd3654" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r, ke)&lt;/code&gt; and &lt;code&gt;!c(ke, r)&lt;/code&gt;, with &lt;code&gt;c(r, ke)&lt;/code&gt; implying &lt;code&gt;!c(ke, r)&lt;/code&gt;</source>
          <target state="translated">Un valor tal que &lt;code&gt;a&lt;/code&gt; se divide con respecto a &lt;code&gt;c(r, ke)&lt;/code&gt; y &lt;code&gt;!c(ke, r)&lt;/code&gt; , con &lt;code&gt;c(r, ke)&lt;/code&gt; implica &lt;code&gt;!c(ke, r)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66162c2a5d40aef1c22e1f7994ce56c76783a955" translate="yes" xml:space="preserve">
          <source>A value such that &lt;code&gt;a&lt;/code&gt; is partitioned with respect to &lt;code&gt;c(r,kl)&lt;/code&gt;, with &lt;code&gt;r&lt;/code&gt; the key value of &lt;code&gt;e&lt;/code&gt; and &lt;code&gt;e&lt;/code&gt; in &lt;code&gt;a&lt;/code&gt;</source>
          <target state="translated">Un valor tal que &lt;code&gt;a&lt;/code&gt; se divide con respecto a &lt;code&gt;c(r,kl)&lt;/code&gt; , con &lt;code&gt;r&lt;/code&gt; el valor clave de &lt;code&gt;e&lt;/code&gt; y &lt;code&gt;e&lt;/code&gt; en &lt;code&gt;a&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0a71e388e98e2de2ca1e6729afcd2caf02f4c95" translate="yes" xml:space="preserve">
          <source>A value that is identical for all &lt;code&gt;type_info&lt;/code&gt; objects referring to the same type.</source>
          <target state="translated">Un valor que es id&amp;eacute;ntico para todos los objetos &lt;code&gt;type_info&lt;/code&gt; que se refieren al mismo tipo.</target>
        </trans-unit>
        <trans-unit id="79bfc8c0189d75c8cec44ecc8d6396e58c45af93" translate="yes" xml:space="preserve">
          <source>A variable template declaration may appear at class scope, in which case it declares a static data member template. See &lt;a href=&quot;variable_template&quot;&gt;variable templates&lt;/a&gt; for details.</source>
          <target state="translated">Puede aparecer una declaraci&amp;oacute;n de plantilla variable en el &amp;aacute;mbito de clase, en cuyo caso declara una plantilla de miembro de datos est&amp;aacute;tica. Ver &lt;a href=&quot;variable_template&quot;&gt;plantillas variables&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="a00357cf9d6e102b6c1e5ad12063c42c54ad2ce7" translate="yes" xml:space="preserve">
          <source>A variable template defines a family of variables or static data members.</source>
          <target state="translated">Una plantilla de variables define una familia de variables o miembros de datos estáticos.</target>
        </trans-unit>
        <trans-unit id="aff896d1642161992d5991ac4ba8de8003708a52" translate="yes" xml:space="preserve">
          <source>A variable template may be introduced by a template declaration at namespace scope, where declaration declares a variable.</source>
          <target state="translated">Una plantilla variable puede introducirse mediante una declaración de plantilla en el ámbito del espacio de nombres,donde la declaración declara una variable.</target>
        </trans-unit>
        <trans-unit id="09fc623a5cbacf9a90a9e712a74ec555cda701fd" translate="yes" xml:space="preserve">
          <source>A variadic class template can be instantiated with any number of template arguments:</source>
          <target state="translated">Una plantilla de clases variadas puede ser instanciada con cualquier número de argumentos de la plantilla:</target>
        </trans-unit>
        <trans-unit id="1fb3820743def9d88fa6123aad6fc9bce3f38a75" translate="yes" xml:space="preserve">
          <source>A variadic function template can be called with any number of function arguments (the template arguments are deduced through &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;):</source>
          <target state="translated">Se puede invocar una plantilla de funci&amp;oacute;n variable con cualquier n&amp;uacute;mero de argumentos de funci&amp;oacute;n (los argumentos de plantilla se deducen mediante &lt;a href=&quot;template_argument_deduction&quot;&gt;la deducci&amp;oacute;n de argumentos de plantilla&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="bb6e304c2616213d182d17fab4792e56d3349945" translate="yes" xml:space="preserve">
          <source>A variant is not permitted to hold references, arrays, or the type &lt;code&gt;void&lt;/code&gt;. Empty variants are also ill-formed (&lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; can be used instead).</source>
          <target state="translated">No se permite que una variante contenga referencias, matrices o el tipo &lt;code&gt;void&lt;/code&gt; . Las variantes vac&amp;iacute;as tambi&amp;eacute;n est&amp;aacute;n mal formadas ( &lt;code&gt;std::variant&amp;lt;&lt;a href=&quot;variant/monostate&quot;&gt;std::monostate&lt;/a&gt;&amp;gt;&lt;/code&gt; puede usarse en su lugar).</target>
        </trans-unit>
        <trans-unit id="ce4af0ae9360b0d87edd912329cc74243aa60def" translate="yes" xml:space="preserve">
          <source>A variant is permitted to hold the same type more than once, and to hold differently cv-qualified versions of the same type.</source>
          <target state="translated">Una variante puede contener el mismo tipo más de una vez,y contener versiones diferentes con calificación cv del mismo tipo.</target>
        </trans-unit>
        <trans-unit id="ea9112a4205a8e149b6d870c2538c2387fcc45a2" translate="yes" xml:space="preserve">
          <source>A variant may become valueless in the following situations:</source>
          <target state="translated">Una variante puede perder su valor en las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="360ab0f56da776d903fad4cd3c7802b6cff86bff" translate="yes" xml:space="preserve">
          <source>A variant that is valueless by exception is treated as being in an invalid state: &lt;a href=&quot;index&quot;&gt;index&lt;/a&gt; returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;, &lt;a href=&quot;get&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;visit&quot;&gt;visit&lt;/a&gt; throw &lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_access&lt;/a&gt;.</source>
          <target state="translated">Una variante que no tiene valor por excepci&amp;oacute;n se trata como un estado no v&amp;aacute;lido: el &lt;a href=&quot;index&quot;&gt;&amp;iacute;ndice&lt;/a&gt; devuelve &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt; , &lt;a href=&quot;get&quot;&gt;get&lt;/a&gt; and &lt;a href=&quot;visit&quot;&gt;visit&lt;/a&gt; throw &lt;a href=&quot;bad_variant_access&quot;&gt;bad_variant_access&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d13acd0a8aed6cefb7c9972fe8dbd4991eb6d5ec" translate="yes" xml:space="preserve">
          <source>A vector of strings can be sorted according to a non-default locale by using the locale object as comparator:</source>
          <target state="translated">Un vector de cuerdas puede clasificarse según una localidad no predeterminada utilizando el objeto de la localidad como comparador:</target>
        </trans-unit>
        <trans-unit id="c3e281fb8afe5cc3b522bbdd748cec3c0126f3da" translate="yes" xml:space="preserve">
          <source>A very common implementation-defined form of main() has a third argument (in addition to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;), of type &lt;code&gt;char*[]&lt;/code&gt;, pointing at &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the execution environment variables&lt;/a&gt;.</source>
          <target state="translated">Una forma de main () definida por implementaci&amp;oacute;n muy com&amp;uacute;n tiene un tercer argumento (adem&amp;aacute;s de &lt;code&gt;argc&lt;/code&gt; y &lt;code&gt;argv&lt;/code&gt; ), de tipo &lt;code&gt;char*[]&lt;/code&gt; , que apunta a &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;una matriz de punteros a las variables de entorno de ejecuci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9ec66bbac0bdedd0761cb72a1751288a98eb028c" translate="yes" xml:space="preserve">
          <source>A very common implementation-defined form of main() has a third argument (in addition to &lt;code&gt;argc&lt;/code&gt; and &lt;code&gt;argv&lt;/code&gt;), of type &lt;code&gt;char*[]&lt;/code&gt;, pointing at &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html&quot;&gt;an array of pointers to the execution environment variables&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cef77f8c0ffb4916f8bc0498dc7440820ca8d36" translate="yes" xml:space="preserve">
          <source>A zero-initialized pointer is the null pointer value of its type, even if the value of the null pointer is not integral zero.</source>
          <target state="translated">Un puntero con inicialización cero es el valor del puntero nulo de su tipo,incluso si el valor del puntero nulo no es cero integral.</target>
        </trans-unit>
        <trans-unit id="7be129f416228534857a690cd4c38374c5515373" translate="yes" xml:space="preserve">
          <source>A, and B</source>
          <target state="translated">A,y B</target>
        </trans-unit>
        <trans-unit id="a5e35ae614f82259bcebce61eb00073751f2e388" translate="yes" xml:space="preserve">
          <source>A, and B is a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation, then X precedes B in S d) if a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence X</source>
          <target state="translated">A, y B es una operaci&amp;oacute;n &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , luego X precede a B en S d) si una cerca &lt;code&gt;memory_order_seq_cst&lt;/code&gt; X</target>
        </trans-unit>
        <trans-unit id="48a01a12d57f9009c8dea86e8610f3bdea642dd4" translate="yes" xml:space="preserve">
          <source>A. Williams (2012), &quot;C++ concurrency in action&quot; 9.2.4 Interrupting a wait on std::condition_variable_any</source>
          <target state="translated">A.Williams (2012),&quot;C++concurrencia en acción&quot; 9.2.4 Interrumpir una espera en std::condition_variable_any</target>
        </trans-unit>
        <trans-unit id="6b4fe715ea89fb871c5a975d173f10a5adf57e7c" translate="yes" xml:space="preserve">
          <source>A1, A2, A3,... is a possibly empty list of arbitrary expressions, except the comma operator is not allowed at the top level to avoid ambiguity.</source>
          <target state="translated">A1,A2,A3,...es una lista posiblemente vacía de expresiones arbitrarias,excepto que el operador de la coma no está permitido en el nivel superior para evitar la ambigüedad.</target>
        </trans-unit>
        <trans-unit id="de2c49eaafb50b14e68d760cacef2f0ba0ba8f45" translate="yes" xml:space="preserve">
          <source>ADL</source>
          <target state="translated">ADL</target>
        </trans-unit>
        <trans-unit id="cd5086cb4e7d0efbc40ccb220af4c1d024f33775" translate="yes" xml:space="preserve">
          <source>ADL can find a &lt;a href=&quot;friend&quot;&gt;friend function&lt;/a&gt; (typically, an overloaded operator) that is defined entirely within a class or class template, even if it was never declared at namespace level.</source>
          <target state="translated">ADL puede encontrar una &lt;a href=&quot;friend&quot;&gt;funci&amp;oacute;n amiga&lt;/a&gt; (generalmente, un operador sobrecargado) que se define completamente dentro de una clase o plantilla de clase, incluso si nunca se declar&amp;oacute; a nivel de espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="c2f934cb8cab6c1b3af0d4f2fdd824eabafb6bf4" translate="yes" xml:space="preserve">
          <source>AND</source>
          <target state="translated">AND</target>
        </trans-unit>
        <trans-unit id="daf2a98f5077d337e35a18a770cad80d218e9ca5" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE NOON WITH JEEM WITH YEH FINAL FORM</source>
          <target state="translated">LIGADURA ÁRABE MEDIODÍA CON JEEM CON YEH FORMA FINAL</target>
        </trans-unit>
        <trans-unit id="5f8c72f94f6217e6dad861d24c88516ef9cd816b" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE SALLA USED AS KORANIC STOP SIGN ISOLATED FORM -</source>
          <target state="translated">LA LIGADURA ÁRABE SALLA UTILIZADA COMO SIGNO CORÁNICO DE PARADA DE FORMA AISLADA -</target>
        </trans-unit>
        <trans-unit id="af1d8ae2aa108f95b9b57f28478231da2a606638" translate="yes" xml:space="preserve">
          <source>ARABIC LIGATURE TEH WITH JEEM WITH MEEM INITIAL FORM -</source>
          <target state="translated">LIGADURA ÁRABE TEH CON JEEM CON MEEM FORMA INICIAL -</target>
        </trans-unit>
        <trans-unit id="187459c12cbce645deb52d74f3d6152a7a9a17fc" translate="yes" xml:space="preserve">
          <source>ASCII Chart</source>
          <target state="translated">Carta ASCII</target>
        </trans-unit>
        <trans-unit id="6b85275355e86325dde0c35693852c2d7820c750" translate="yes" xml:space="preserve">
          <source>ASCII chart</source>
          <target state="translated">Gráfico ASCII</target>
        </trans-unit>
        <trans-unit id="6ff2c765d8c7f7f1624b70244d10913facb7ae0b" translate="yes" xml:space="preserve">
          <source>ASCII values</source>
          <target state="translated">Los valores ASCII</target>
        </trans-unit>
        <trans-unit id="63e21a0c9c10fbf518b0166eb437a67f1ed962cd" translate="yes" xml:space="preserve">
          <source>ATOMIC_FLAG_INIT</source>
          <target state="translated">ATOMIC_FLAG_INIT</target>
        </trans-unit>
        <trans-unit id="0b0620452fea1cd6ef04952a1260146f273e310f" translate="yes" xml:space="preserve">
          <source>ATOMIC_VAR_INIT</source>
          <target state="translated">ATOMIC_VAR_INIT</target>
        </trans-unit>
        <trans-unit id="435b6099910c97d9bc8e078e332560e92819291f" translate="yes" xml:space="preserve">
          <source>Abandons the shared state and destroys the stored task object.</source>
          <target state="translated">Abandona el estado compartido y destruye el objeto de tarea almacenado.</target>
        </trans-unit>
        <trans-unit id="36e1c539cc780bc605cb01b3fddc5d8db9c3b6ab" translate="yes" xml:space="preserve">
          <source>Abandons the shared state:</source>
          <target state="translated">Abandona el estado compartido:</target>
        </trans-unit>
        <trans-unit id="e7becc73c7eaff031859fb120395433f96283795" translate="yes" xml:space="preserve">
          <source>Abbreviated function template</source>
          <target state="translated">Plantilla de funciones abreviadas</target>
        </trans-unit>
        <trans-unit id="019202b59ca73881cfaab35533cb5a7033c39a80" translate="yes" xml:space="preserve">
          <source>Abbreviated function templates can be specialized like all function templates.</source>
          <target state="translated">Las plantillas de funciones abreviadas pueden ser especializadas como todas las plantillas de funciones.</target>
        </trans-unit>
        <trans-unit id="fd2f1ad3f3e244485410235abcc0dcd9d528402f" translate="yes" xml:space="preserve">
          <source>Absolute value of &lt;code&gt;d&lt;/code&gt;.</source>
          <target state="translated">Valor absoluto de &lt;code&gt;d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b11f0b716439740a7eef7b0954e8e03f2442de7" translate="yes" xml:space="preserve">
          <source>Abstract classes are used to represent general concepts (for example, Shape, Animal), which can be used as base classes for concrete classes (for example, Circle, Dog).</source>
          <target state="translated">Las clases abstractas se utilizan para representar conceptos generales (por ejemplo,Forma,Animal),que pueden utilizarse como clases base para clases concretas (por ejemplo,Círculo,Perro).</target>
        </trans-unit>
        <trans-unit id="496f013275ea0cccdde9e4ce5e27272837e636f5" translate="yes" xml:space="preserve">
          <source>Abstract types cannot be used as parameter types, as function return types, or as the type of an explicit conversion (note this is checked at the point of definition and function call, since at the point of function declaration parameter and return type may be incomplete).</source>
          <target state="translated">Los tipos abstractos no pueden utilizarse como tipos de parámetros,como tipos de retorno de la función,o como el tipo de una conversión explícita (nótese que esto se comprueba en el punto de definición y llamada de la función,ya que en el punto de declaración de la función el parámetro y el tipo de retorno pueden estar incompletos).</target>
        </trans-unit>
        <trans-unit id="8fda6cf2aae5ca82e8dc635a5cfbd7ff01d1ac31" translate="yes" xml:space="preserve">
          <source>Abstraction</source>
          <target state="translated">Abstraction</target>
        </trans-unit>
        <trans-unit id="fe89f3fca6949588976c79493bd13c9b36f00658" translate="yes" xml:space="preserve">
          <source>Access checking for the names used in &lt;a href=&quot;default_arguments&quot;&gt;default function arguments&lt;/a&gt; as well as in the default &lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;template parameters&lt;/a&gt; is performed at the point of declaration, not at the point of use.</source>
          <target state="translated">La verificaci&amp;oacute;n de acceso para los nombres utilizados en &lt;a href=&quot;default_arguments&quot;&gt;los argumentos de la funci&amp;oacute;n predeterminada&lt;/a&gt; , as&amp;iacute; como en los &lt;a href=&quot;template_parameters#Default_template_arguments&quot;&gt;par&amp;aacute;metros de la plantilla&lt;/a&gt; predeterminada , se realiza en el punto de declaraci&amp;oacute;n, no en el punto de uso.</target>
        </trans-unit>
        <trans-unit id="9de67dfb6d06413cdc219824a0f3f88445b9f32c" translate="yes" xml:space="preserve">
          <source>Access out of bounds</source>
          <target state="translated">Acceso fuera de los límites</target>
        </trans-unit>
        <trans-unit id="64d102e911590ffe48aba24684384d363cf0b36b" translate="yes" xml:space="preserve">
          <source>Access outside of lifetime</source>
          <target state="translated">Acceso fuera de la vida</target>
        </trans-unit>
        <trans-unit id="ff2202db9230ee307101c952851e1360ff1ce903" translate="yes" xml:space="preserve">
          <source>Access overhead: In pImpl, each call to a private member function indirects through a pointer. Each access to a public member made by a private member indirects through another pointer. Both indirections cross translation unit boundaries and so can only be optimized out by link-time optimization. Note that OO factory requires indirection across translation units to access both public data and implementation detail, and offers even fewer opportunities for the link time optimizer due to virtual dispatch.</source>
          <target state="translated">Acceso por encima de la cabeza:En pImpl,cada llamada a un miembro privado funciona indirectamente a través de un puntero.Cada acceso a un miembro público hecho por un miembro privado se indirecta a través de otro puntero.Ambas indirectas cruzan los límites de la unidad de traducción y,por lo tanto,sólo pueden ser optimizadas fuera por la optimización del tiempo de enlace.Tenga en cuenta que la fábrica OO requiere la función indirecta a través de las unidades de traducción para acceder tanto a los datos públicos como a los detalles de implementación,y ofrece incluso menos oportunidades para el optimizador de tiempo de enlace debido al envío virtual.</target>
        </trans-unit>
        <trans-unit id="41dcddad26f26d0b23476e3af19f8e0cff1f9f7e" translate="yes" xml:space="preserve">
          <source>Access permissions model &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX permission bits&lt;/a&gt;, and any individual file permissions (as reported by &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;) are a combination of some of the following bits:</source>
          <target state="translated">Los &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;bits de&lt;/a&gt; permiso del modelo de permisos de acceso POSIX y cualquier permiso de archivo individual (seg&amp;uacute;n lo informado por el &lt;a href=&quot;status&quot;&gt;estado&lt;/a&gt; ) son una combinaci&amp;oacute;n de algunos de los siguientes bits:</target>
        </trans-unit>
        <trans-unit id="ff48fcdd36448626dfca91c0959a95a136068169" translate="yes" xml:space="preserve">
          <source>Access permissions model &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;POSIX permission bits&lt;/a&gt;, and any individual file permissions (as reported by &lt;a href=&quot;status&quot;&gt;status&lt;/a&gt;) are a combination of some of the following bits:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29695d27ada4464e68e5f7e3d3cd693fa6cadcf" translate="yes" xml:space="preserve">
          <source>Access rules for the names of &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt; are checked at the call point using the type of the expression used to denote the object for which the member function is called. The access of the final overrider is ignored.</source>
          <target state="translated">Las reglas de acceso para los nombres de &lt;a href=&quot;virtual&quot;&gt;las funciones virtuales&lt;/a&gt; se verifican en el punto de llamada utilizando el tipo de expresi&amp;oacute;n utilizada para denotar el objeto para el que se llama la funci&amp;oacute;n miembro. Se ignora el acceso del anulador final.</target>
        </trans-unit>
        <trans-unit id="172f15fcb1759434b4e5cac298998c9f90e5367d" translate="yes" xml:space="preserve">
          <source>Access specifiers</source>
          <target state="translated">Especificadores de acceso</target>
        </trans-unit>
        <trans-unit id="fd9b61139d61fe4a3ad562d5c3fb1467d5f0fb25" translate="yes" xml:space="preserve">
          <source>Access specifiers give the author of the class the ability to decide which class members are accessible to the users of the class (that is, the</source>
          <target state="translated">Los especificadores de acceso dan al autor de la clase la posibilidad de decidir qué miembros de la clase son accesibles para los usuarios de la clase (es decir,la</target>
        </trans-unit>
        <trans-unit id="b5f1627a2f9ef35b0cad78d685d46c26ac79a8ba" translate="yes" xml:space="preserve">
          <source>Access to a non-static data member or a call to a non-static member function.</source>
          <target state="translated">Acceso a un miembro de datos no estático o una llamada a una función de miembro no estático.</target>
        </trans-unit>
        <trans-unit id="1632238dd01e0d2949d4e0ad89257742628b773a" translate="yes" xml:space="preserve">
          <source>Access to pointer passed to realloc</source>
          <target state="translated">El acceso al puntero pasó a reasignarse</target>
        </trans-unit>
        <trans-unit id="27559787dd122b923d06b7298557d1cd2c568a23" translate="yes" xml:space="preserve">
          <source>Access to the &lt;code&gt;p&lt;/code&gt;'s deleter. If the shared pointer &lt;code&gt;p&lt;/code&gt; owns a deleter of type cv-unqualified &lt;code&gt;Deleter&lt;/code&gt; (e.g. if it was created with one of the constructors that take a deleter as a parameter), then returns a pointer to the deleter. Otherwise, returns a null pointer.</source>
          <target state="translated">Acceso al eliminador de &lt;code&gt;p&lt;/code&gt; . Si el puntero compartido &lt;code&gt;p&lt;/code&gt; posee un supresor de tipo cv-descalificador no &lt;code&gt;Deleter&lt;/code&gt; (por ejemplo, si fue creado con uno de los constructores que toman un supresor como par&amp;aacute;metro), entonces devuelve un puntero al supresor. De lo contrario, devuelve un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="5c1d13d1c544b3feecb6e442b5b9a73c51c6b267" translate="yes" xml:space="preserve">
          <source>Access to the same shared state from multiple threads is safe if each thread does it through its own copy of a &lt;code&gt;shared_future&lt;/code&gt; object.</source>
          <target state="translated">El acceso al mismo estado compartido desde m&amp;uacute;ltiples hilos es seguro si cada hilo lo hace a trav&amp;eacute;s de su propia copia de un objeto &lt;code&gt;shared_future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f563d2f693e12ab63ee51309db6c0dd439835d3c" translate="yes" xml:space="preserve">
          <source>Accesses a member of its operand.</source>
          <target state="translated">Accede a un miembro de su operando.</target>
        </trans-unit>
        <trans-unit id="a42b2fe3c4d5fcc9a9d311beb7c3efb130c09b8a" translate="yes" xml:space="preserve">
          <source>Accesses the bit at position &lt;code&gt;pos&lt;/code&gt;. The first version returns the value of the bit, the second version returns an object of type &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; that allows modification of the value.</source>
          <target state="translated">Accede al bit en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; . La primera versi&amp;oacute;n devuelve el valor del bit, la segunda versi&amp;oacute;n devuelve un objeto de tipo &lt;code&gt;&lt;a href=&quot;reference&quot;&gt;std::bitset::reference&lt;/a&gt;&lt;/code&gt; que permite la modificaci&amp;oacute;n del valor.</target>
        </trans-unit>
        <trans-unit id="d60917183a0203e125a2a367082f7e505a1b54cc" translate="yes" xml:space="preserve">
          <source>Accesses the contained value.</source>
          <target state="translated">Accede al valor contenido.</target>
        </trans-unit>
        <trans-unit id="5ffc054a82694395488926c5d88d20377f2fee4f" translate="yes" xml:space="preserve">
          <source>Accesses the file permissions information.</source>
          <target state="translated">Accede a la información de los permisos del archivo.</target>
        </trans-unit>
        <trans-unit id="0faa3d14d648895a9103231a47e67306cf3658f8" translate="yes" xml:space="preserve">
          <source>Accesses the file type information.</source>
          <target state="translated">Accede a la información del tipo de archivo.</target>
        </trans-unit>
        <trans-unit id="9ab9ff8b7be4b7d40eb92e8afba99b14b56097f9" translate="yes" xml:space="preserve">
          <source>Accesses the imaginary part of the complex number.</source>
          <target state="translated">Accede a la parte imaginaria del número complejo.</target>
        </trans-unit>
        <trans-unit id="6c9900004652bab063edd448abb4e13e10ff694e" translate="yes" xml:space="preserve">
          <source>Accesses the index stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Accede al &amp;iacute;ndice almacenado en &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3c82d4ce7723e142d0946770db58f80f216a936" translate="yes" xml:space="preserve">
          <source>Accesses the name and target of this &lt;code&gt;link&lt;/code&gt; object.</source>
          <target state="translated">Accede al nombre y al objetivo de este objeto de &lt;code&gt;link&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad5cf92f478d0439f59cdb4880f47ebacaf46e23" translate="yes" xml:space="preserve">
          <source>Accesses the native handle of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Accede al identificador nativo de &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7d833d3713305bce90c91948acf875f0c20ba4" translate="yes" xml:space="preserve">
          <source>Accesses the native path name as a character string.</source>
          <target state="translated">Accede al nombre del camino nativo como una cadena de caracteres.</target>
        </trans-unit>
        <trans-unit id="3ae496a866ebcdc4db51cd8794d1e50d8d500069" translate="yes" xml:space="preserve">
          <source>Accesses the pointed-to &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Accede a la entrada de &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; apuntada a .</target>
        </trans-unit>
        <trans-unit id="9823697b16ef01bf1ebfdd504cd02cc048fbff41" translate="yes" xml:space="preserve">
          <source>Accesses the real part of the complex number.</source>
          <target state="translated">Accede a la parte real del número complejo.</target>
        </trans-unit>
        <trans-unit id="bbd2d3ce5c26cd90201155a08a10040ce8faa66b" translate="yes" xml:space="preserve">
          <source>Accessibility applies to all names with no regard to their origin, so a name introduced by a &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; or &lt;a href=&quot;using_declaration&quot;&gt;using declarations&lt;/a&gt; is checked, not the name it refers to.</source>
          <target state="translated">La accesibilidad se aplica a todos los nombres sin tener en cuenta su origen, por lo que se &lt;a href=&quot;typedef&quot;&gt;marca&lt;/a&gt; un nombre introducido por typedef o &lt;a href=&quot;using_declaration&quot;&gt;mediante declaraciones&lt;/a&gt; , no el nombre al que se refiere.</target>
        </trans-unit>
        <trans-unit id="db5f1eeeca9d3c68907d330e642c8ec9d5a0116f" translate="yes" xml:space="preserve">
          <source>Accessing an object using an expression of a type other than the type with which it was created is undefined behavior in many cases, see &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;reinterpret_cast&lt;/a&gt; for the list of exceptions and examples.</source>
          <target state="translated">Acceder a un objeto usando una expresi&amp;oacute;n de un tipo diferente al tipo con el que fue creado es un comportamiento indefinido en muchos casos, vea &lt;a href=&quot;reinterpret_cast#Type_aliasing&quot;&gt;reinterpret_cast&lt;/a&gt; para la lista de excepciones y ejemplos.</target>
        </trans-unit>
        <trans-unit id="43edbdec6f4616d56db2ed67623f9b6b877668ea" translate="yes" xml:space="preserve">
          <source>Accessing the variable during initialization from another thread, even through an atomic operation, is a data race (it may happen if the address is immediately passed to another thread with a &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; operation).</source>
          <target state="translated">Acceder a la variable durante la inicializaci&amp;oacute;n desde otro subproceso, incluso a trav&amp;eacute;s de una operaci&amp;oacute;n at&amp;oacute;mica, es una carrera de datos (puede ocurrir si la direcci&amp;oacute;n se pasa inmediatamente a otro subproceso con una operaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="bd21f9aade4e041d6127535e2103b7265328e814" translate="yes" xml:space="preserve">
          <source>Acquire operation</source>
          <target state="translated">Adquirir la operación</target>
        </trans-unit>
        <trans-unit id="336eaf1465ee3c86483dca958f5b3f81e8c35309" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutex &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Adquiere la propiedad del mutex dado &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0bfcec1da334e9014a69ecff78b70a46245c533" translate="yes" xml:space="preserve">
          <source>Acquires ownership of the given mutexes &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">Adquiere la propiedad de los mutexes dados &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c865fe856f24b54f5a468d814de44d24b3ad8da2" translate="yes" xml:space="preserve">
          <source>Acquires shared ownership of the mutex. If another thread is holding the mutex in exclusive ownership, a call to &lt;code&gt;lock_shared&lt;/code&gt; will block execution until shared ownership can be acquired.</source>
          <target state="translated">Adquiere la propiedad compartida del mutex. Si otro hilo mantiene el mutex en propiedad exclusiva, una llamada a &lt;code&gt;lock_shared&lt;/code&gt; bloquear&amp;aacute; la ejecuci&amp;oacute;n hasta que se pueda adquirir la propiedad compartida.</target>
        </trans-unit>
        <trans-unit id="116672ae6ceb211b89b5cc24d53045f44bb76b12" translate="yes" xml:space="preserve">
          <source>Acronyms</source>
          <target state="translated">Acronyms</target>
        </trans-unit>
        <trans-unit id="894e0d0ca601136dd7488a48cc4e246850d2e574" translate="yes" xml:space="preserve">
          <source>Action if file</source>
          <target state="translated">Acción si archivo</target>
        </trans-unit>
        <trans-unit id="5405a9d57e6b63ab5821d9588dde26920a308e00" translate="yes" xml:space="preserve">
          <source>Action if file already exists</source>
          <target state="translated">Acción si el archivo ya existe</target>
        </trans-unit>
        <trans-unit id="c3c1db410576ecf3d85988b0535501a3dc1d020f" translate="yes" xml:space="preserve">
          <source>Action if file does not exist</source>
          <target state="translated">Acción si el archivo no existe</target>
        </trans-unit>
        <trans-unit id="a7817b78f6b68e579f4e4537bfed1875e7ae184f" translate="yes" xml:space="preserve">
          <source>Actual implementations vary:</source>
          <target state="translated">Las implementaciones reales varían:</target>
        </trans-unit>
        <trans-unit id="3ca7e3d2e4ac34bc514652447560887a72b3f649" translate="yes" xml:space="preserve">
          <source>Adaptors</source>
          <target state="translated">Adaptors</target>
        </trans-unit>
        <trans-unit id="fb414d455da6b9468629ebcfdfce20d9ea740f72" translate="yes" xml:space="preserve">
          <source>Adding constexpr modifiers to &lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;a href=&quot;iterator#Container_access&quot;&gt;range access&lt;/a&gt;</source>
          <target state="translated">Agregar modificadores constexpr a &lt;code&gt;&lt;a href=&quot;iterator/reverse_iterator&quot;&gt;std::reverse_iterator&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;iterator/move_iterator&quot;&gt;std::move_iterator&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; y &lt;a href=&quot;iterator#Container_access&quot;&gt;rango de acceso&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9c64c7ebe5a611a1f12ffc12fb7a8366d9e1fdc" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to associative containers</source>
          <target state="translated">Añadir la búsqueda de comparaciones heterogéneas a los contenedores asociativos</target>
        </trans-unit>
        <trans-unit id="ad005a38d417aa5d21ad05bcc3397517559e1e10" translate="yes" xml:space="preserve">
          <source>Adding heterogeneous comparison lookup to unordered associative containers</source>
          <target state="translated">Añadir la búsqueda de comparaciones heterogéneas a los contenedores asociativos no ordenados</target>
        </trans-unit>
        <trans-unit id="a6dea03cb51c5650f791a12987ca0df26adb5602" translate="yes" xml:space="preserve">
          <source>Adding pre-calculated hash value lookup to unordered associative containers</source>
          <target state="translated">Añadir la búsqueda de valor de hachís precalculado a los contenedores asociativos no ordenados</target>
        </trans-unit>
        <trans-unit id="87ed11c26edf58b14803d392bf82cd48a91e96b8" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references. An iterator is invalidated only when the corresponding element is deleted.</source>
          <target state="translated">La adición,eliminación y desplazamiento de los elementos dentro de la lista o a través de varias listas no invalida los iteradores o referencias.Un iterador sólo se invalida cuando se elimina el elemento correspondiente.</target>
        </trans-unit>
        <trans-unit id="98f2660c67411bcd6814bc7ce1f2e850dfc897be" translate="yes" xml:space="preserve">
          <source>Adding, removing and moving the elements within the list, or across several lists, does not invalidate the iterators currently referring to other elements in the list. However, an iterator or reference referring to an element is invalidated when the corresponding element is removed (via &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt;) from the list.</source>
          <target state="translated">Agregar, eliminar y mover los elementos dentro de la lista, o entre varias listas, no invalida los iteradores que actualmente se refieren a otros elementos en la lista. Sin embargo, un iterador o referencia que hace referencia a un elemento se invalida cuando el elemento correspondiente se elimina (a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;forward_list/erase_after&quot;&gt;erase_after&lt;/a&gt;&lt;/code&gt; ) de la lista.</target>
        </trans-unit>
        <trans-unit id="48911a7386b2baa20a76ef9e342562ca04e9c341" translate="yes" xml:space="preserve">
          <source>Addition and subtraction</source>
          <target state="translated">Suma y resta</target>
        </trans-unit>
        <trans-unit id="5c20b1f1d3dccc5fc33df625c9821015eb0d18af" translate="yes" xml:space="preserve">
          <source>Additional basic types and macros</source>
          <target state="translated">Tipos básicos y macros adicionales</target>
        </trans-unit>
        <trans-unit id="dc459b3781fd1c39294a64216e4b94c9615d87b0" translate="yes" xml:space="preserve">
          <source>Additional behavior may be defined by the implementations for file systems which append additional elements (such as alternate data streams or partitioned dataset names) to extensions.</source>
          <target state="translated">El comportamiento adicional puede ser definido por las implementaciones de los sistemas de archivos que añaden elementos adicionales (como flujos de datos alternativos o nombres de conjuntos de datos particionados)a las extensiones.</target>
        </trans-unit>
        <trans-unit id="a9a945aa19333f0b54ff5676b6d9de2643f1b76b" translate="yes" xml:space="preserve">
          <source>Additional classifications such as &lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; or &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; may be provided by system-supplied locales (in which case they are also accessible through &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Las &lt;code&gt;&quot;jdigit&quot;&lt;/code&gt; &lt;code&gt;&quot;jkanji&quot;&lt;/code&gt; proporcionadas por el sistema pueden proporcionar clasificaciones adicionales como &quot;jdigit&quot; o &quot;jkanji&quot; (en cuyo caso tambi&amp;eacute;n son accesibles a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../../string/wide/wctype&quot;&gt;std::wctype&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ed64694f365b81d351dbd520c43964630a71e79f" translate="yes" xml:space="preserve">
          <source>Additional concepts can be found in &lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;the algorithms library&lt;/a&gt; and &lt;a href=&quot;ranges#Range_concepts&quot;&gt;the ranges library&lt;/a&gt;.</source>
          <target state="translated">Se pueden encontrar conceptos adicionales en &lt;a href=&quot;algorithm/ranges#Algorithm_concepts_and_utilities&quot;&gt;la biblioteca de algoritmos&lt;/a&gt; y &lt;a href=&quot;ranges#Range_concepts&quot;&gt;la biblioteca de rangos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="655988b4d376c12072cf6c9cdb9826fe22ae3e28" translate="yes" xml:space="preserve">
          <source>Additional execution policies may be provided by a standard library implementation (possible future additions may include &lt;code&gt;std::parallel::cuda&lt;/code&gt; and &lt;code&gt;std::parallel::opencl&lt;/code&gt;).</source>
          <target state="translated">Una implementaci&amp;oacute;n est&amp;aacute;ndar de la biblioteca puede proporcionar pol&amp;iacute;ticas de ejecuci&amp;oacute;n adicionales (las posibles adiciones futuras pueden incluir &lt;code&gt;std::parallel::cuda&lt;/code&gt; y &lt;code&gt;std::parallel::opencl&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0b037de42fdfdd2746ba0eff4076bb78f7f07fda" translate="yes" xml:space="preserve">
          <source>Additional implementation-defined preparation may take place, which may call &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Puede tener lugar una preparaci&amp;oacute;n adicional definida por la implementaci&amp;oacute;n, que puede llamar a &lt;code&gt;setstate(failbit)&lt;/code&gt; (que puede arrojar &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="96549f1325a6bd11423df1587b53f51b1bda1aee" translate="yes" xml:space="preserve">
          <source>Additional macro constants, with names that begin with &lt;code&gt;LC_&lt;/code&gt; followed by at least one uppercase letter, may be defined in &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt;. For example, the POSIX specification requires LC_MESSAGES (which controls &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt;), ISO/IEC 30112:2014 (&lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;2014 draft&lt;/a&gt;) additionally defines LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT, and LC_KEYBOARD, which are supported by the GNU C library (except for LC_XLITERATE).</source>
          <target state="translated">Las constantes macro adicionales, con nombres que comienzan con &lt;code&gt;LC_&lt;/code&gt; seguidos de al menos una letra may&amp;uacute;scula, se pueden definir en &lt;code&gt;&amp;lt;clocale&amp;gt;&lt;/code&gt; . Por ejemplo, la especificaci&amp;oacute;n POSIX requiere LC_MESSAGES (que controla &lt;code&gt;&lt;a href=&quot;../io/c/perror&quot;&gt;std::perror&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt; ), ISO / IEC 30112: 2014 ( &lt;a href=&quot;http://www.open-std.org/JTC1/SC35/WG5/docs/30112d10.pdf&quot;&gt;borrador 2014&lt;/a&gt; ) define adicionalmente LC_IDENTIFICATION, LC_XLITERATE, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_PAPER, LC_MEASUREMENT y LC_KKEYKARD , que son compatibles con la biblioteca GNU C (excepto LC_XLITERATE).</target>
        </trans-unit>
        <trans-unit id="99f91b99c0d1f5963361dc127f6dbe9e38bb8903" translate="yes" xml:space="preserve">
          <source>Additional macros that begin with &lt;code&gt;FE_&lt;/code&gt; followed by uppercase letters, and have the type &lt;code&gt;const std::fenv_t*&lt;/code&gt;, may be supported by an implementation.</source>
          <target state="translated">Las macros adicionales que comienzan con &lt;code&gt;FE_&lt;/code&gt; seguidas de letras may&amp;uacute;sculas y tienen el tipo &lt;code&gt;const std::fenv_t*&lt;/code&gt; , pueden ser compatibles con una implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ef3d826dd03b81e684d86b842e89e92269929ee7" translate="yes" xml:space="preserve">
          <source>Additional numeric formats may be accepted by the currently installed C &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se pueden aceptar formatos num&amp;eacute;ricos adicionales en la &lt;code&gt;&lt;a href=&quot;../../locale/setlocale&quot;&gt;locale&lt;/a&gt;&lt;/code&gt; C actualmente instalada .</target>
        </trans-unit>
        <trans-unit id="0a5c5be417cfb6cd7d9118d383daf9f4ffd160e0" translate="yes" xml:space="preserve">
          <source>Additional overloads are provided for &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, and all integer types, which are treated as complex numbers with zero imaginary component.</source>
          <target state="translated">Sobrecargas adicionales se proporcionan para &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; , y todos los tipos de enteros, que son tratados como n&amp;uacute;meros complejos con el componente imaginario cero.</target>
        </trans-unit>
        <trans-unit id="e8146529cfa6fa203e23e61b37cbdf2d37d4634b" translate="yes" xml:space="preserve">
          <source>Additional rounding modes may be supported by an implementation.</source>
          <target state="translated">Otras modalidades de redondeo pueden ser apoyadas por una aplicación.</target>
        </trans-unit>
        <trans-unit id="c51476def7086889d71b363945c5ad2e8649c02e" translate="yes" xml:space="preserve">
          <source>Additional signal names &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;are specified by POSIX&lt;/a&gt;.</source>
          <target state="translated">&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;POSIX especifica&lt;/a&gt; nombres de se&amp;ntilde;al adicionales .</target>
        </trans-unit>
        <trans-unit id="b8e3f88a4fb1a893c72eb1c76430bba45d521493" translate="yes" xml:space="preserve">
          <source>Additional signal names &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html&quot;&gt;are specified by POSIX&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e1faa5440a863d95ba8c415f20385dfa4af6d4b" translate="yes" xml:space="preserve">
          <source>Additional support</source>
          <target state="translated">Apoyo adicional</target>
        </trans-unit>
        <trans-unit id="04f95216581ee9c47e04240f25828352cba16ddc" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; may be used to indicate conformance to the iterator concepts.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;&lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;It&amp;gt;::iterator_&amp;shy;concept&lt;/code&gt; pueden usarse para indicar la conformidad con los conceptos de iterador.</target>
        </trans-unit>
        <trans-unit id="f2e0dd9b924004af0072e53510ae5406eb8b489b" translate="yes" xml:space="preserve">
          <source>Additionally, &lt;code&gt;operator==&lt;/code&gt; and &lt;code&gt;operator!=&lt;/code&gt; are provided, either as members or as non-members, as required by &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;operator==&lt;/code&gt; y &lt;code&gt;operator!=&lt;/code&gt; Se proporcionan, como miembros o no miembros, seg&amp;uacute;n lo requiera &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ce53b9c5df0fcfe1d1195f17fc25165a98c09650" translate="yes" xml:space="preserve">
          <source>Additionally, O(N) calls to the constructor of &lt;code&gt;value_type&lt;/code&gt;, where N is &lt;code&gt;cont.size()&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, O (N) llama al constructor de &lt;code&gt;value_type&lt;/code&gt; , donde N es &lt;code&gt;cont.size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bee97038914dbaf49097462be0b6fa3a27587e0" translate="yes" xml:space="preserve">
          <source>Additionally, a specialization exists for every cv-qualified version of each arithmetic type, identical to the unqualified specialization, e.g. &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt;, &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; are provided and are equivalent to &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, existe una especializaci&amp;oacute;n para cada versi&amp;oacute;n calificada por cv de cada tipo aritm&amp;eacute;tico, id&amp;eacute;ntica a la especializaci&amp;oacute;n no calificada, por ejemplo, &lt;code&gt;std::numeric_limits&amp;lt;const int&amp;gt;&lt;/code&gt; , &lt;code&gt;std::numeric_limits&amp;lt;volatile int&amp;gt;&lt;/code&gt; y &lt;code&gt;std::numeric_limits&amp;lt;const volatile int&amp;gt;&lt;/code&gt; se proporcionan y son equivalentes a &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="234e939fc46f7fc9566afc50a39f23e96624b23f" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedMutex type supports another mode of ownership: shared. Multiple threads (or, more generally, execution agents) can simultaneously own this mutex in shared mode, but no thread may obtain shared ownership if there is a thread that owns it in exclusive mode and no thread may obtain exclusive ownership if there is a thread that owns it in shared mode. If more than implementation-defined number of threads (no less than 10000) hold a shared lock, another attempt to acquire the mutex in shared mode blocks until the number of shared owners drops down below that threshold.</source>
          <target state="translated">Adem&amp;aacute;s, un objeto &lt;code&gt;m&lt;/code&gt; de tipo SharedMutex admite otro modo de propiedad: compartido. Varios subprocesos (o, m&amp;aacute;s generalmente, agentes de ejecuci&amp;oacute;n) pueden poseer simult&amp;aacute;neamente este mutex en modo compartido, pero ning&amp;uacute;n subproceso puede obtener la propiedad compartida si hay un subproceso que lo posee en modo exclusivo y ning&amp;uacute;n subproceso puede obtener la propiedad exclusiva si hay un subproceso que lo posee en modo compartido. Si m&amp;aacute;s del n&amp;uacute;mero de subprocesos definidos por la implementaci&amp;oacute;n (no menos de 10000) mantienen un bloqueo compartido, otro intento de adquirir el mutex en bloques de modo compartido hasta que el n&amp;uacute;mero de propietarios compartidos caiga por debajo de ese umbral.</target>
        </trans-unit>
        <trans-unit id="4c21e2edf0f81a97ef8a624494e0c5a7e8d14423" translate="yes" xml:space="preserve">
          <source>Additionally, an object &lt;code&gt;m&lt;/code&gt; of SharedTimedMutex type supports timed shared operations:</source>
          <target state="translated">Adem&amp;aacute;s, un objeto &lt;code&gt;m&lt;/code&gt; del tipo SharedTimedMutex admite operaciones compartidas temporizadas:</target>
        </trans-unit>
        <trans-unit id="6981bc51ea468df1e5cb432a395ddfc2e5d78804" translate="yes" xml:space="preserve">
          <source>Additionally, for an object &lt;code&gt;m&lt;/code&gt; of TimedMutex type:</source>
          <target state="translated">Adem&amp;aacute;s, para un objeto &lt;code&gt;m&lt;/code&gt; del tipo TimedMutex:</target>
        </trans-unit>
        <trans-unit id="ceefa22c95a1f23f16745529c429d1edf71f2d45" translate="yes" xml:space="preserve">
          <source>Additionally, for every sequence container, the constructor template that takes two input iterators and the member function template overloads of &lt;code&gt;insert()&lt;/code&gt;, &lt;code&gt;append()&lt;/code&gt;, &lt;code&gt;assign()&lt;/code&gt;, &lt;code&gt;replace()&lt;/code&gt; that take two input iterators do not participate in overload resolution if the corresponding template argument does not satisfy &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, para cada contenedor de secuencia, la plantilla del constructor que toma dos iteradores de entrada y las sobrecargas de la plantilla de funci&amp;oacute;n miembro de &lt;code&gt;insert()&lt;/code&gt; , &lt;code&gt;append()&lt;/code&gt; , &lt;code&gt;assign()&lt;/code&gt; , &lt;code&gt;replace()&lt;/code&gt; que toman dos iteradores de entrada no participan en la resoluci&amp;oacute;n de sobrecarga si El argumento de plantilla correspondiente no satisface &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="80407204b5613c93f4ff9eeeca0d87435272db5c" translate="yes" xml:space="preserve">
          <source>Additionally, if &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt;, then(since C++11) precision modifier is added, set to &lt;code&gt;str.precision()&lt;/code&gt;</source>
          <target state="translated">Adem&amp;aacute;s, si &lt;code&gt;floatfield != (ios_base::fixed | ios_base::scientific)&lt;/code&gt; , entonces (desde C ++ 11) se agrega un modificador de precisi&amp;oacute;n, establezca &lt;code&gt;str.precision()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="92ec030910d3cd27bfd60a9308eb60d240987aa3" translate="yes" xml:space="preserve">
          <source>Additionally, in order for the type &lt;code&gt;A&lt;/code&gt; to satisfy Allocator.</source>
          <target state="translated">Adem&amp;aacute;s, para que el tipo &lt;code&gt;A&lt;/code&gt; satisfaga al asignador.</target>
        </trans-unit>
        <trans-unit id="e4c633a25d8deae1fd83be48e6f21fc0579f3bfe" translate="yes" xml:space="preserve">
          <source>Additionally, the following constants of this type are defined, which do not represent permissions:</source>
          <target state="translated">Además,se definen las siguientes constantes de este tipo,que no representan permisos:</target>
        </trans-unit>
        <trans-unit id="e3b85cc6377c854375953c6897c361f957b07ce5" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor.</source>
          <target state="translated">Adem&amp;aacute;s, la especializaci&amp;oacute;n &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Floating&lt;/i&gt;&amp;gt;&lt;/code&gt; resultante tiene un dise&amp;ntilde;o est&amp;aacute;ndar, un constructor trivial predeterminado y un destructor trivial.</target>
        </trans-unit>
        <trans-unit id="e8aaea245aabbd553929a2dc8693fcb475a09d9c" translate="yes" xml:space="preserve">
          <source>Additionally, the resulting &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; specialization has standard layout, a trivial default constructor, and a trivial destructor. Signed integer arithmetic is defined to use two's complement; there are no undefined results.</source>
          <target state="translated">Adem&amp;aacute;s, la especializaci&amp;oacute;n &lt;code&gt;std::atomic&amp;lt;&lt;i&gt;Integral&lt;/i&gt;&amp;gt;&lt;/code&gt; resultante tiene un dise&amp;ntilde;o est&amp;aacute;ndar, un constructor trivial predeterminado y un destructor trivial. La aritm&amp;eacute;tica de enteros con signo se define para usar el complemento de dos; No hay resultados indefinidos.</target>
        </trans-unit>
        <trans-unit id="ac1d2a76e849b1b5833ee66f2036219c73ed4239" translate="yes" xml:space="preserve">
          <source>Additionally:</source>
          <target state="translated">Additionally:</target>
        </trans-unit>
        <trans-unit id="76be74594d0a3f6f1c23004ef8fbefa453574daa" translate="yes" xml:space="preserve">
          <source>Additive operators</source>
          <target state="translated">Operadores de aditivos</target>
        </trans-unit>
        <trans-unit id="ce6e9db4782a94f83450a756f42238c060b97d77" translate="yes" xml:space="preserve">
          <source>Address constant expression</source>
          <target state="translated">La expresión constante de la dirección</target>
        </trans-unit>
        <trans-unit id="38ee922cd750ff4631c23d9b88d00633994c2466" translate="yes" xml:space="preserve">
          <source>Address family not supported</source>
          <target state="translated">Dirección familia no apoyada</target>
        </trans-unit>
        <trans-unit id="9e53f7cf7661710ec98f0a6e7a65398f5e81f0be" translate="yes" xml:space="preserve">
          <source>Address in use</source>
          <target state="translated">Dirección en uso</target>
        </trans-unit>
        <trans-unit id="a645d07371a2ce45ebb0b375f8787a4fc425584d" translate="yes" xml:space="preserve">
          <source>Address not available</source>
          <target state="translated">La dirección no está disponible</target>
        </trans-unit>
        <trans-unit id="f282d429f8e10c6e8f6cc685119b79f7b98f8d4a" translate="yes" xml:space="preserve">
          <source>Address of an lvalue may be taken: &lt;code&gt;&amp;amp;++i&lt;/code&gt;&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; and &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; are valid expressions.</source>
          <target state="translated">Se puede tomar la direcci&amp;oacute;n de un lvalue: &lt;code&gt;&amp;amp;++i&lt;/code&gt; &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;value_category#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; y &lt;code&gt;&amp;amp;&lt;a href=&quot;../io/manip/endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; son expresiones v&amp;aacute;lidas.</target>
        </trans-unit>
        <trans-unit id="1a289481f4bde8e8211ad9ffe17faa98c7f5cb4e" translate="yes" xml:space="preserve">
          <source>Address of an overload set</source>
          <target state="translated">Dirección de un conjunto de sobrecarga</target>
        </trans-unit>
        <trans-unit id="b68e9b443504394c722ff5e4129a8d602ab42051" translate="yes" xml:space="preserve">
          <source>Address of an overloaded function</source>
          <target state="translated">Dirección de una función sobrecargada</target>
        </trans-unit>
        <trans-unit id="50d8d3dd04846c597735fdea066d1202471e00ac" translate="yes" xml:space="preserve">
          <source>Address of an rvalue may not be taken: &lt;code&gt;&amp;amp;int()&lt;/code&gt;, &lt;code&gt;&amp;amp;i++&lt;/code&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;, &lt;code&gt;&amp;amp;42&lt;/code&gt;, and &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; are invalid.</source>
          <target state="translated">No se puede tomar la direcci&amp;oacute;n de un valor r: &lt;code&gt;&amp;amp;int()&lt;/code&gt; , &lt;code&gt;&amp;amp;i++&lt;/code&gt; &lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;value_category#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt; , &lt;code&gt;&amp;amp;42&lt;/code&gt; , y &lt;code&gt;&amp;amp;std::move(x)&lt;/code&gt; no son v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="9377e4719dc070a5dfa0119a44583c6b5ae07578" translate="yes" xml:space="preserve">
          <source>Address-of</source>
          <target state="translated">Address-of</target>
        </trans-unit>
        <trans-unit id="d8e9fb4e567ee2aa8c62d2ac99954b60bc22db70" translate="yes" xml:space="preserve">
          <source>Addressing tuples by type</source>
          <target state="translated">Dirigir las tuplas por tipo</target>
        </trans-unit>
        <trans-unit id="b0ef7d67a5935e3fe8af11cd7847c8809d95a854" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the day value.</source>
          <target state="translated">Suma o resta 1 al valor del día.</target>
        </trans-unit>
        <trans-unit id="e43efbbed96f261cc9549f2681044676631d009f" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">Suma o resta 1 al valor del mes,reduciendo el módulo de resultado 12 a un entero en el rango [1,12].</target>
        </trans-unit>
        <trans-unit id="fa3ef2c3e28e35bbf2cbd5aafea835fc3ea7a3ef" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">Suma o resta 1 al valor del día de la semana,reduciendo el módulo de resultado 7 a un entero en el rango [0,6].</target>
        </trans-unit>
        <trans-unit id="640e675cb46fdd695967fccbbef63e0607e284a0" translate="yes" xml:space="preserve">
          <source>Adds or subtracts 1 from the year value.</source>
          <target state="translated">Suma o resta 1 del valor del año.</target>
        </trans-unit>
        <trans-unit id="4153c4972fd500059ef400485fdf85b87aceaa00" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; days from the day value.</source>
          <target state="translated">Suma o resta &lt;code&gt;d.count()&lt;/code&gt; d&amp;iacute;as del valor del d&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="678a7c04a10343a84658ffb12634bd9ee9456301" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;d.count()&lt;/code&gt; from the weekday value, reducing the result modulo 7 to an integer in the range [0, 6].</source>
          <target state="translated">Suma o resta &lt;code&gt;d.count()&lt;/code&gt; del valor del d&amp;iacute;a de la semana, reduciendo el m&amp;oacute;dulo de resultados 7 a un n&amp;uacute;mero entero en el rango [0, 6].</target>
        </trans-unit>
        <trans-unit id="3230fc75b04ac3e6ea29e55230fe30dd1c203bfe" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;m.count()&lt;/code&gt; from the month value, reducing the result modulo 12 to an integer in the range [1, 12].</source>
          <target state="translated">Suma o resta &lt;code&gt;m.count()&lt;/code&gt; del valor del mes, reduciendo el m&amp;oacute;dulo de resultados 12 a un n&amp;uacute;mero entero en el rango [1, 12].</target>
        </trans-unit>
        <trans-unit id="25e4a09fe7696cac408ac8a894a8ff1b27aa44b2" translate="yes" xml:space="preserve">
          <source>Adds or subtracts &lt;code&gt;y.count()&lt;/code&gt; years from the year value.</source>
          <target state="translated">Suma o resta &lt;code&gt;y.count()&lt;/code&gt; a&amp;ntilde;os del valor del a&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="458e4498a6e12a40a95f335b3f81898cfd748b12" translate="yes" xml:space="preserve">
          <source>Adjacent &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are concatenated.</source>
          <target state="translated">Los &lt;a href=&quot;string_literal&quot;&gt;literales de cadena&lt;/a&gt; adyacentes se concatenan.</target>
        </trans-unit>
        <trans-unit id="9932bec15aa8c818ed7b8796dbd6ed7ef02aab26" translate="yes" xml:space="preserve">
          <source>Adopt the Parallelism TS for C++17</source>
          <target state="translated">Adoptar el Paralelismo TS para C++17</target>
        </trans-unit>
        <trans-unit id="03e5621c572270086c95471651dc888f07bc2da9" translate="yes" xml:space="preserve">
          <source>Advances &lt;code&gt;e&lt;/code&gt;'s state as if by &lt;code&gt;z&lt;/code&gt; consecutive calls to &lt;code&gt;e()&lt;/code&gt;.</source>
          <target state="translated">Los avances &lt;code&gt;e&lt;/code&gt; estado 's como por &lt;code&gt;z&lt;/code&gt; llamadas consecutivas a &lt;code&gt;e()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="135dd9fae6bf561e041334e7723bb57b90c62cf2" translate="yes" xml:space="preserve">
          <source>Advances the input sequence by one character and reads one character.</source>
          <target state="translated">Avanza la secuencia de entrada por un carácter y lee un carácter.</target>
        </trans-unit>
        <trans-unit id="50499158101997cf6bc049268a358d31d71424e8" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result.</source>
          <target state="translated">Avanza el estado interno por &lt;code&gt;z&lt;/code&gt; veces. Equivalente a llamar &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;z&lt;/code&gt; veces y descartar el resultado.</target>
        </trans-unit>
        <trans-unit id="efa9b27cb8a086b18bbe299b9e1c46a036172d58" translate="yes" xml:space="preserve">
          <source>Advances the internal state by &lt;code&gt;z&lt;/code&gt; times. Equivalent to calling &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;z&lt;/code&gt; times and discarding the result. The state of the underlying engine may be advanced by more than &lt;code&gt;z&lt;/code&gt; times.</source>
          <target state="translated">Avanza el estado interno por &lt;code&gt;z&lt;/code&gt; veces. Equivalente a &lt;code&gt;&lt;a href=&quot;operator()&quot;&gt;operator()&lt;/a&gt;&lt;/code&gt; llamada () &lt;code&gt;z&lt;/code&gt; veces y descartar el resultado. El estado del motor subyacente puede avanzar m&amp;aacute;s de &lt;code&gt;z&lt;/code&gt; veces.</target>
        </trans-unit>
        <trans-unit id="b9ef5cc9bbd2286407c3e7b628e2c0232b990d29" translate="yes" xml:space="preserve">
          <source>Advances the iterator by calling &lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; where &lt;code&gt;sbuf_&lt;/code&gt; is the stored pointer to the stream buffer.</source>
          <target state="translated">Avanza el iterador llamando a &lt;code&gt;sbuf_-&amp;gt;sbumpc()&lt;/code&gt; donde &lt;code&gt;sbuf_&lt;/code&gt; es el puntero almacenado en el b&amp;uacute;fer de flujo.</target>
        </trans-unit>
        <trans-unit id="141cb43c20eeabe7572fd03d0044e60b4fa23f86" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next match.</source>
          <target state="translated">Avanza el iterador en el próximo partido.</target>
        </trans-unit>
        <trans-unit id="041d757eb7a9bbdbe12db3d41c780db95f87a90c" translate="yes" xml:space="preserve">
          <source>Advances the iterator on the next sub match.</source>
          <target state="translated">Avanza el iterador en el próximo partido de submarinos.</target>
        </trans-unit>
        <trans-unit id="6539ad1eea9dd55e8e95ccfb1b1a314e60e23185" translate="yes" xml:space="preserve">
          <source>Advances the iterator to the next entry. Invalidates all copies of the previous value of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Avanza el iterador a la siguiente entrada. Invalida todas las copias del valor anterior de &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78b5c8f29ae07de10df28f52834a61b1bdbbd82b" translate="yes" xml:space="preserve">
          <source>Advances the iterator.</source>
          <target state="translated">Avanza el iterador.</target>
        </trans-unit>
        <trans-unit id="207287a093e89e5bc03f0303474f506b39d8c2b3" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;erasure&lt;/b&gt;, are...</source>
          <target state="translated">Despu&amp;eacute;s &lt;b&gt; borrado&lt;/b&gt; , son ...</target>
        </trans-unit>
        <trans-unit id="4f0adbf879d7bad6224d512c2918e8643c30107f" translate="yes" xml:space="preserve">
          <source>After &lt;b&gt;insertion&lt;/b&gt;, are...</source>
          <target state="translated">Despu&amp;eacute;s &lt;b&gt; inserci&amp;oacute;n&lt;/b&gt; , son ...</target>
        </trans-unit>
        <trans-unit id="88341f67098f03a0da3cea31a839663a0bc13b2c" translate="yes" xml:space="preserve">
          <source>After a</source>
          <target state="translated">Después de un</target>
        </trans-unit>
        <trans-unit id="a061077fb09465352c22016448276d1996de8a86" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">Despu&amp;eacute;s de una llamada a &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; , las secuencias din&amp;aacute;micas se congelan autom&amp;aacute;ticamente. Un llamado a &lt;code&gt;freeze(false)&lt;/code&gt; antes de salir del &amp;aacute;mbito en el que se cre&amp;oacute; este objeto &lt;code&gt;ostrstream&lt;/code&gt; . de lo contrario, el destructor perder&amp;aacute; memoria. Adem&amp;aacute;s, la salida adicional a una secuencia congelada puede truncarse una vez que alcanza el final del b&amp;uacute;fer asignado.</target>
        </trans-unit>
        <trans-unit id="a539ff8b097686cd8f474897e86e0367fc84dba2" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt;, dynamic streams become frozen automatically. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer.</source>
          <target state="translated">Despu&amp;eacute;s de una llamada a &lt;code&gt;&lt;a href=&quot;str&quot;&gt;str()&lt;/a&gt;&lt;/code&gt; , las secuencias din&amp;aacute;micas se congelan autom&amp;aacute;ticamente. Se requiere una llamada para &lt;code&gt;freeze(false)&lt;/code&gt; antes de salir del alcance en el que este &lt;code&gt;strstream&lt;/code&gt; se cre&amp;oacute; objeto strstream . de lo contrario, el destructor perder&amp;aacute; memoria. Adem&amp;aacute;s, la salida adicional a una secuencia congelada puede truncarse una vez que alcanza el final del b&amp;uacute;fer asignado.</target>
        </trans-unit>
        <trans-unit id="5eb647e196d16c21c41ab1c8527d9b7e8b2a6ba0" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;ostrstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">Despu&amp;eacute;s de una llamada a &lt;code&gt;str()&lt;/code&gt; , las secuencias din&amp;aacute;micas se congelan. Se requiere una llamada para &lt;code&gt;freeze(false)&lt;/code&gt; antes de salir del &amp;aacute;mbito en el que se cre&amp;oacute; este objeto &lt;code&gt;ostrstream&lt;/code&gt; . de lo contrario, el destructor perder&amp;aacute; memoria. Adem&amp;aacute;s, la salida adicional a una secuencia congelada puede truncarse una vez que alcanza el final del b&amp;uacute;fer asignado, lo que puede dejar el b&amp;uacute;fer sin terminaci&amp;oacute;n nula.</target>
        </trans-unit>
        <trans-unit id="44cdb0260695b6e760f2d33d6208f4bfff7fe216" translate="yes" xml:space="preserve">
          <source>After a call to &lt;code&gt;str()&lt;/code&gt;, dynamic streams become frozen. A call to &lt;code&gt;freeze(false)&lt;/code&gt; is required before exiting the scope in which this &lt;code&gt;strstream&lt;/code&gt; object was created. otherwise the destructor will leak memory. Also, additional output to a frozen stream may be truncated once it reaches the end of the allocated buffer, which may leave the buffer not null-terminated.</source>
          <target state="translated">Despu&amp;eacute;s de una llamada a &lt;code&gt;str()&lt;/code&gt; , las secuencias din&amp;aacute;micas se congelan. Se requiere una llamada para &lt;code&gt;freeze(false)&lt;/code&gt; antes de salir del alcance en el que este &lt;code&gt;strstream&lt;/code&gt; se cre&amp;oacute; objeto strstream . de lo contrario, el destructor perder&amp;aacute; memoria. Adem&amp;aacute;s, la salida adicional a una secuencia congelada puede truncarse una vez que alcanza el final del b&amp;uacute;fer asignado, lo que puede dejar el b&amp;uacute;fer sin terminaci&amp;oacute;n nula.</target>
        </trans-unit>
        <trans-unit id="b9daa7be1c203f1734014387e6ddd71754a92603" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true if no overflow occurred during the operation.</source>
          <target state="translated">Despu&amp;eacute;s de una llamada a una de estas funciones, &lt;code&gt;ok()&lt;/code&gt; siempre es verdadero si no se produjo un desbordamiento durante la operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="85753ca571347a3ec5bab8ac7f1155da1ea5f3fa" translate="yes" xml:space="preserve">
          <source>After a call to one of these functions, &lt;code&gt;ok()&lt;/code&gt; is always true.</source>
          <target state="translated">Despu&amp;eacute;s de una llamada a una de estas funciones, &lt;code&gt;ok()&lt;/code&gt; siempre es verdadero.</target>
        </trans-unit>
        <trans-unit id="b0d14c1273920c43e0727fafe465d22e6d51d0cb" translate="yes" xml:space="preserve">
          <source>After all macro expansion and evaluation of &lt;code&gt;defined&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) expressions, any identifier which is not a &lt;a href=&quot;../language/bool_literal&quot;&gt;boolean literal&lt;/a&gt; is replaced with the number &lt;code&gt;​0​&lt;/code&gt; (this includes identifiers that are lexically keywords, but not alternative tokens like &lt;code&gt;and&lt;/code&gt;).</source>
          <target state="translated">Despu&amp;eacute;s de todo expansi&amp;oacute;n y evaluaci&amp;oacute;n de macro &lt;code&gt;defined&lt;/code&gt; y &lt;code&gt;__has_include&lt;/code&gt; (desde 17 C ++) expresiones, cualquier identificador que no es un &lt;a href=&quot;../language/bool_literal&quot;&gt;literal booleano&lt;/a&gt; se sustituye con el n&amp;uacute;mero &lt;code&gt;​0​&lt;/code&gt; (esto incluye identificadores que son l&amp;eacute;xicamente palabras clave, pero tokens no alternativos como &lt;code&gt;and&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b09013ce3cd67396c7277e3bcafa2ffe1562348b" translate="yes" xml:space="preserve">
          <source>After all static initialization is completed, dynamic initialization of non-local variables occurs in the following situations:</source>
          <target state="translated">Una vez completada la inicialización estática,la inicialización dinámica de las variables no locales se produce en las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="35dd559617a4f18a5460a7d2ed6280a6a78170b4" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt; on a stream with a dynamic buffer, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the &lt;code&gt;strstreambuf&lt;/code&gt; destructor to deallocate the buffer when necessary.</source>
          <target state="translated">Despu&amp;eacute;s de cualquier llamada a &lt;code&gt;str()&lt;/code&gt; en una secuencia con un b&amp;uacute;fer din&amp;aacute;mico, se requiere una llamada a &lt;code&gt;freeze(false)&lt;/code&gt; para permitir que el destructor &lt;code&gt;strstreambuf&lt;/code&gt; desasigne el b&amp;uacute;fer cuando sea necesario.</target>
        </trans-unit>
        <trans-unit id="1bff9fbc15a1512d56427c0bac69b8131756695d" translate="yes" xml:space="preserve">
          <source>After any call to &lt;code&gt;str()&lt;/code&gt;, a call to &lt;code&gt;freeze(false)&lt;/code&gt; is required to allow the destructor to deallocate the buffer as necessary.</source>
          <target state="translated">Despu&amp;eacute;s de cualquier llamada a &lt;code&gt;str()&lt;/code&gt; , se requiere una llamada a &lt;code&gt;freeze(false)&lt;/code&gt; para permitir que el destructor desasigne el b&amp;uacute;fer seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="a783411c667be5aeca25a2e7d260e7d91749c14d" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;detach&lt;/code&gt;&lt;code&gt;*this&lt;/code&gt; no longer owns any thread.</source>
          <target state="translated">Despu&amp;eacute;s de llamar a &lt;code&gt;detach&lt;/code&gt; &lt;code&gt;*this&lt;/code&gt; ya no posee ning&amp;uacute;n hilo.</target>
        </trans-unit>
        <trans-unit id="d81c3a85f42719a311033e306e37b8e8b9fb3c51" translate="yes" xml:space="preserve">
          <source>After calling &lt;code&gt;share&lt;/code&gt; on a &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de llamar a &lt;code&gt;share&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; , &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8a56377919a429bed8801b85b079d1d09d9b97f" translate="yes" xml:space="preserve">
          <source>After calling the rvalue overloads (2,4,6,8), &lt;code&gt;r&lt;/code&gt; is empty and &lt;code&gt;r.get() == nullptr&lt;/code&gt;, except that &lt;code&gt;r&lt;/code&gt; is not modified for &lt;code&gt;dynamic_pointer_cast&lt;/code&gt;(4) if the &lt;code&gt;dynamic_cast&lt;/code&gt; fails.</source>
          <target state="translated">Despu&amp;eacute;s de llamar a las sobrecargas de rvalue (2,4,6,8), &lt;code&gt;r&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o y &lt;code&gt;r.get() == nullptr&lt;/code&gt; , excepto que &lt;code&gt;r&lt;/code&gt; no se modifica para &lt;code&gt;dynamic_pointer_cast&lt;/code&gt; (4) si el &lt;code&gt;dynamic_cast&lt;/code&gt; falla.</target>
        </trans-unit>
        <trans-unit id="a43ab890db9a9d7fd099d5804cec46453734ffa7" translate="yes" xml:space="preserve">
          <source>After considering every P and A in both directions, if, for each type that was considered,</source>
          <target state="translated">Después de considerar cada P y A en ambas direcciones,si,para cada tipo que fue considerado,</target>
        </trans-unit>
        <trans-unit id="cde16484b3a6dce1a5a73f1d71d4d5f94eda1f7f" translate="yes" xml:space="preserve">
          <source>After container move assignment (overload (2)), unless elementwise move assignment is forced by incompatible allocators, references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de la asignaci&amp;oacute;n de movimiento del contenedor (sobrecarga (2)), a menos que la asignaci&amp;oacute;n de movimiento por elementos sea forzada por asignadores incompatibles, referencias, punteros e iteradores (que no sean el iterador final) a &lt;code&gt;other&lt;/code&gt; siguen siendo v&amp;aacute;lidos, pero se refieren a elementos que ahora est&amp;aacute;n en &lt;code&gt;*this&lt;/code&gt; . El est&amp;aacute;ndar actual otorga esta garant&amp;iacute;a a trav&amp;eacute;s de la declaraci&amp;oacute;n general en &amp;sect;23.2.1 [container.requirements.general] / 12, y se est&amp;aacute; considerando una garant&amp;iacute;a m&amp;aacute;s directa a trav&amp;eacute;s de &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1efd3ba5fab7d922cddedab135cbf68623f0fbb3" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (4)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de la construcci&amp;oacute;n del movimiento del contenedor (sobrecarga (4)), las referencias, punteros e iteradores (que no sean el iterador final) a &lt;code&gt;other&lt;/code&gt; siguen siendo v&amp;aacute;lidos, pero se refieren a elementos que ahora est&amp;aacute;n en &lt;code&gt;*this&lt;/code&gt; . El est&amp;aacute;ndar actual otorga esta garant&amp;iacute;a a trav&amp;eacute;s de la declaraci&amp;oacute;n general en &amp;sect;23.2.1 [container.requirements.general] / 12, y se est&amp;aacute; considerando una garant&amp;iacute;a m&amp;aacute;s directa a trav&amp;eacute;s de &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eaca101a515420f6158015d9049a7c61e1020372" translate="yes" xml:space="preserve">
          <source>After container move construction (overload (6)), references, pointers, and iterators (other than the end iterator) to &lt;code&gt;other&lt;/code&gt; remain valid, but refer to elements that are now in &lt;code&gt;*this&lt;/code&gt;. The current standard makes this guarantee via the blanket statement in &amp;sect;23.2.1[container.requirements.general]/12, and a more direct guarantee is under consideration via &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de la construcci&amp;oacute;n del movimiento del contenedor (sobrecarga (6)), las referencias, punteros e iteradores (que no sean el iterador final) a &lt;code&gt;other&lt;/code&gt; siguen siendo v&amp;aacute;lidos, pero se refieren a elementos que ahora est&amp;aacute;n en &lt;code&gt;*this&lt;/code&gt; . El est&amp;aacute;ndar actual otorga esta garant&amp;iacute;a a trav&amp;eacute;s de la declaraci&amp;oacute;n general en &amp;sect;23.2.1 [container.requirements.general] / 12, y se est&amp;aacute; considerando una garant&amp;iacute;a m&amp;aacute;s directa a trav&amp;eacute;s de &lt;a href=&quot;http://www.open-std.org/JTC1/SC22/WG21/docs/lwg-active.html#2321&quot;&gt;LWG 2321&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fb3e0e585b7b35a447a3da6d3ae0da5248da92b" translate="yes" xml:space="preserve">
          <source>After encountering the &lt;code&gt;#error&lt;/code&gt; directive, an implementation displays the diagnostic message error_message and renders the program ill-formed (the compilation stops).</source>
          <target state="translated">Despu&amp;eacute;s de encontrar la directiva &lt;code&gt;#error&lt;/code&gt; , una implementaci&amp;oacute;n muestra el mensaje de error error_message y hace que el programa est&amp;eacute; mal formado (la compilaci&amp;oacute;n se detiene).</target>
        </trans-unit>
        <trans-unit id="1d2d75b0b4cf172aa9246ff178f69aced36a5e9c" translate="yes" xml:space="preserve">
          <source>After evaluating &lt;code&gt;lhs = rhs&lt;/code&gt;:</source>
          <target state="translated">Despu&amp;eacute;s de evaluar &lt;code&gt;lhs = rhs&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="45a5bba2318081758d338e6bc0ad55114ce64350" translate="yes" xml:space="preserve">
          <source>After one of the two templates was transformed as described above, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is executed using the transformed template as the argument template and the original template type of the other template as the parameter template. The process is then repeated using the second template (after transformations) as the argument and the first template in its original form as the parameter.</source>
          <target state="translated">Despu&amp;eacute;s de que una de las dos plantillas se transform&amp;oacute; como se describi&amp;oacute; anteriormente, &lt;a href=&quot;template_argument_deduction&quot;&gt;la deducci&amp;oacute;n de argumento de plantilla&lt;/a&gt; se ejecuta utilizando la plantilla transformada como plantilla de argumento y el tipo de plantilla original de la otra plantilla como plantilla de par&amp;aacute;metro. Luego, el proceso se repite utilizando la segunda plantilla (despu&amp;eacute;s de las transformaciones) como argumento y la primera plantilla en su forma original como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="37697aac1a5eff809b30503e048e426d91ee09c0" translate="yes" xml:space="preserve">
          <source>After seeking to a non-end position in a wide stream, the next call to any output function may render the remainder of the file undefined, e.g. by outputting a multibyte sequence of a different length.</source>
          <target state="translated">Después de buscar una posición no final en un flujo amplio,la siguiente llamada a cualquier función de salida puede hacer que el resto del archivo quede indefinido,por ejemplo,mediante la salida de una secuencia multibyte de diferente longitud.</target>
        </trans-unit>
        <trans-unit id="6723da668a7284d1e0d9c856af9a4e60e17d6599" translate="yes" xml:space="preserve">
          <source>After substitution, all function parameters of array and function type are adjusted to pointers and all top-level cv-qualifiers are dropped from function parameters (as in a regular &lt;a href=&quot;function#Function_declaration&quot;&gt;function declaration&lt;/a&gt;).</source>
          <target state="translated">Despu&amp;eacute;s de la sustituci&amp;oacute;n, todos los par&amp;aacute;metros de funci&amp;oacute;n de matriz y tipo de funci&amp;oacute;n se ajustan a punteros y todos los calificadores cv de nivel superior se eliminan de los par&amp;aacute;metros de funci&amp;oacute;n (como en una &lt;a href=&quot;function#Function_declaration&quot;&gt;declaraci&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; regular ).</target>
        </trans-unit>
        <trans-unit id="799039415462a10354f545fe871b500eacc988ea" translate="yes" xml:space="preserve">
          <source>After that, whether or not an exception was thrown by any destructor, the delete expression invokes the &lt;a href=&quot;../memory/new/operator_delete&quot;&gt; deallocation function&lt;/a&gt;: either &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; (for the first version of the expression) or &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; (for the second version of the expression), unless the matching new-expression was combined with another new-expression(since C++14).</source>
          <target state="translated">Despu&amp;eacute;s de eso, ya sea que un destructor haya lanzado o no una excepci&amp;oacute;n, la expresi&amp;oacute;n de eliminaci&amp;oacute;n invoca la &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;funci&amp;oacute;n de desasignaci&amp;oacute;n&lt;/a&gt; : &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;&lt;/code&gt; (para la primera versi&amp;oacute;n de la expresi&amp;oacute;n) u &lt;code&gt;&lt;a href=&quot;../memory/new/operator_delete&quot;&gt;operator delete&lt;/a&gt;[]&lt;/code&gt; (para la segunda versi&amp;oacute;n de la expresi&amp;oacute;n), a menos que la nueva expresi&amp;oacute;n coincidente se combin&amp;oacute; con otra nueva expresi&amp;oacute;n (desde C ++ 14).</target>
        </trans-unit>
        <trans-unit id="e0b82e4b58314156b84c6c073fedd13df3c06173" translate="yes" xml:space="preserve">
          <source>After the associated set of classes and namespaces is determined, all declarations found in classes of this set are discarded for the purpose of further ADL processing, except namespace-scoped friend functions and function templates, as stated in point 2 below .</source>
          <target state="translated">Una vez determinado el conjunto asociado de clases y espacios de nombres,todas las declaraciones que se encuentran en las clases de este conjunto se descartan a los efectos de su posterior procesamiento en la ADL,excepto las funciones amigas del espacio de nombres y las plantillas de funciones,como se indica en el punto 2 infra .</target>
        </trans-unit>
        <trans-unit id="a30be8c196cfecdbad0fc0881a76a52f9af12d23" translate="yes" xml:space="preserve">
          <source>After the call &lt;code&gt;getloc() == loc&lt;/code&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de la llamada &lt;code&gt;getloc() == loc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b157835cfa6ec4fc0f1fce8dc684fe4a88600d3" translate="yes" xml:space="preserve">
          <source>After the call, the value of &lt;code&gt;t&lt;/code&gt; is the value held by &lt;code&gt;u&lt;/code&gt; before the call, and the value of &lt;code&gt;u&lt;/code&gt; is the value held by &lt;code&gt;t&lt;/code&gt; before the call.</source>
          <target state="translated">Despu&amp;eacute;s de la llamada, el valor de &lt;code&gt;t&lt;/code&gt; es el valor retenido por &lt;code&gt;u&lt;/code&gt; antes de la llamada, y el valor de &lt;code&gt;u&lt;/code&gt; es el valor retenido por &lt;code&gt;t&lt;/code&gt; antes de la llamada.</target>
        </trans-unit>
        <trans-unit id="4cd3511e0d8d14569c23c73c7b91dc33ab8e711e" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = rv;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;u2&lt;/code&gt;;</source>
          <target state="translated">Despu&amp;eacute;s de la definici&amp;oacute;n &lt;code&gt;T u = rv;&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; es igual a &lt;code&gt;u2&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="3d30d64981287500c819b1f90ccbf12490e9f92c" translate="yes" xml:space="preserve">
          <source>After the definition &lt;code&gt;T u = v;&lt;/code&gt;, &lt;code&gt;u&lt;/code&gt; is equal to &lt;code&gt;v&lt;/code&gt;;</source>
          <target state="translated">Despu&amp;eacute;s de la definici&amp;oacute;n &lt;code&gt;T u = v;&lt;/code&gt; , &lt;code&gt;u&lt;/code&gt; es igual a &lt;code&gt;v&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0c6c90fd32023a18a6a7da6b1f777294338454a9" translate="yes" xml:space="preserve">
          <source>After the destruction, the smart pointers that shared ownership with &lt;code&gt;*this&lt;/code&gt;, if any, will report a &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; that is one less than its previous value.</source>
          <target state="translated">Despu&amp;eacute;s de la destrucci&amp;oacute;n, los punteros inteligentes que compartieron la propiedad con &lt;code&gt;*this&lt;/code&gt; , si lo hubiera, informar&amp;aacute;n un &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count()&lt;/a&gt;&lt;/code&gt; que es uno menos que su valor anterior.</target>
        </trans-unit>
        <trans-unit id="d2d0310f3096791666afb21ddf68713192d5f5d5" translate="yes" xml:space="preserve">
          <source>After the error condition is reported by a function, additional guarantees may be provided with regards to the state of the program. The following four levels of exception guarantee are generally recognized&lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt;, which are strict supersets of each other:</source>
          <target state="translated">Despu&amp;eacute;s de que una funci&amp;oacute;n informa la condici&amp;oacute;n de error, se pueden proporcionar garant&amp;iacute;as adicionales con respecto al estado del programa. Los siguientes cuatro niveles de garant&amp;iacute;a de excepci&amp;oacute;n son generalmente reconocidos &lt;sup id=&quot;cite_ref-4&quot;&gt;&lt;a href=&quot;exceptions#cite_note-4&quot;&gt;[4] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;exceptions#cite_note-5&quot;&gt;[5] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-6&quot;&gt;&lt;a href=&quot;exceptions#cite_note-6&quot;&gt;[6]&lt;/a&gt;&lt;/sup&gt; , que son estrictamente superconjuntos entre s&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="5b29961c177bd98d620f93782ce1efd7215c74a8" translate="yes" xml:space="preserve">
          <source>After the standard library deallocation function returns, all pointers referring to any part of the deallocated storage become invalid.</source>
          <target state="translated">Después de que la función de distribución de la biblioteca estándar regrese,todos los indicadores que se refieren a cualquier parte del almacenamiento distribuido se vuelven inválidos.</target>
        </trans-unit>
        <trans-unit id="d0f96cdce258dfc61390cebc0e99878ba570d5a1" translate="yes" xml:space="preserve">
          <source>After these adjustments, deduction of &lt;code&gt;P&lt;/code&gt; from &lt;code&gt;A&lt;/code&gt; is done following &lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;template argument deduction from a type&lt;/a&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de estos ajustes, la deducci&amp;oacute;n de &lt;code&gt;P&lt;/code&gt; de &lt;code&gt;A&lt;/code&gt; se realiza siguiendo &lt;a href=&quot;template_argument_deduction#Deduction_from_a_type&quot;&gt;la deducci&amp;oacute;n de argumento de plantilla de un tipo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2d3d82b04f2207d9d6bcf7a9bbc105dd774ee13b" translate="yes" xml:space="preserve">
          <source>After these transformations, the deduction processes as described below (cf. section &quot;Deduction from type&quot;) and attempts to find such template arguments that would make the deduced &lt;code&gt;A&lt;/code&gt; (that is, &lt;code&gt;P&lt;/code&gt; after adjustments listed above and the substitution of the deduced template parameters) identical to the</source>
          <target state="translated">Despu&amp;eacute;s de estas transformaciones, la deducci&amp;oacute;n se procesa como se describe a continuaci&amp;oacute;n (ver secci&amp;oacute;n &quot;Deducci&amp;oacute;n del tipo&quot;) e intenta encontrar tales argumentos de plantilla que har&amp;iacute;an la &lt;code&gt;A&lt;/code&gt; deducida (es decir, &lt;code&gt;P&lt;/code&gt; despu&amp;eacute;s de los ajustes enumerados anteriormente y la sustituci&amp;oacute;n de los par&amp;aacute;metros de plantilla deducidos ) id&amp;eacute;ntico al</target>
        </trans-unit>
        <trans-unit id="cbfa05ba4a64164c2c06108c94e66a0d15618966" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;other&lt;/code&gt; has no associated mutex.</source>
          <target state="translated">Despu&amp;eacute;s de esta llamada, &lt;code&gt;other&lt;/code&gt; no tiene ning&amp;uacute;n mutex asociado.</target>
        </trans-unit>
        <trans-unit id="09e6d08a70617f303ffde1bea6a795b13dc7771a" translate="yes" xml:space="preserve">
          <source>After this call, &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; is equal to the value of &lt;code&gt;other.get_id()&lt;/code&gt; prior to the call, and &lt;code&gt;other&lt;/code&gt; no longer represents a thread of execution.</source>
          <target state="translated">Despu&amp;eacute;s de esta llamada, &lt;code&gt;this-&amp;gt;get_id()&lt;/code&gt; es igual al valor de &lt;code&gt;other.get_id()&lt;/code&gt; antes de la llamada, y &lt;code&gt;other&lt;/code&gt; ya no representa un hilo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8c87604fd723b0f75058b0139b052da68fd8a53e" translate="yes" xml:space="preserve">
          <source>After this function completes, &lt;a href=&quot;has_path&quot;&gt;&lt;code&gt;has_filename&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Una vez completada esta funci&amp;oacute;n, &lt;a href=&quot;has_path&quot;&gt; &lt;code&gt;has_filename&lt;/code&gt; &lt;/a&gt; devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af11ceb4dfc69bc2e19a600385c6a2e921b44982" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be dereferenceable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">Despu&amp;eacute;s de esta operaci&amp;oacute;n, no se requiere que &lt;code&gt;r&lt;/code&gt; sea ​​desreferenciable y ya no se requiere que ninguna copia del valor anterior de &lt;code&gt;r&lt;/code&gt; sea ​​desreferenciable o incrementable.</target>
        </trans-unit>
        <trans-unit id="d6b3e4110c978c6c966e175d0fb21c24d0cb55b2" translate="yes" xml:space="preserve">
          <source>After this operation &lt;code&gt;r&lt;/code&gt; is not required to be incrementable and any copies of the previous value of &lt;code&gt;r&lt;/code&gt; are no longer required to be dereferenceable or incrementable.</source>
          <target state="translated">Despu&amp;eacute;s de esta operaci&amp;oacute;n, no se requiere que &lt;code&gt;r&lt;/code&gt; sea ​​incrementable y ya no se requiere que ninguna copia del valor anterior de &lt;code&gt;r&lt;/code&gt; sea ​​desreferenciable o incrementable.</target>
        </trans-unit>
        <trans-unit id="5cb3c3ab15a7948ac9776fc01389be53890f7bf1" translate="yes" xml:space="preserve">
          <source>After this statement the control is transferred to the statement immediately following the enclosing loop or switch. As with any block exit, all automatic storage objects declared in enclosing compound statement or in the condition of a loop/switch are destroyed, in reverse order of construction, before the execution of the first line following the enclosing loop.</source>
          <target state="translated">Después de esta declaración,el control se transfiere a la declaración inmediatamente después del bucle o interruptor adjunto.Como en cualquier salida de bloque,todos los objetos de almacenamiento automático declarados en la declaración adjunta o en la condición de un bucle/interruptor se destruyen,en orden inverso de construcción,antes de la ejecución de la primera línea que sigue al bucle adjunto.</target>
        </trans-unit>
        <trans-unit id="fd175daec3ba5a5ff832d7613dfb6df9054a3994" translate="yes" xml:space="preserve">
          <source>After this, digit grouping is checked. if the position of any of the thousands separators discarded in Stage 2 does not match the grouping provided by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">Despu&amp;eacute;s de esto, se verifica la agrupaci&amp;oacute;n de d&amp;iacute;gitos. si la posici&amp;oacute;n de cualquiera de los miles de separadores descartados en la Etapa 2 no coincide con la agrupaci&amp;oacute;n proporcionada por &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping()&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; se asigna a &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d93b73971332d0c3efd8634484908552ab34c9a" translate="yes" xml:space="preserve">
          <source>Afterwards, &lt;code&gt;p&lt;/code&gt; is equivalent to &lt;code&gt;nullptr&lt;/code&gt;</source>
          <target state="translated">Despu&amp;eacute;s, &lt;code&gt;p&lt;/code&gt; es equivalente a &lt;code&gt;nullptr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="795da143b5dbe81dcf8c6232ccf436d09b14c393" translate="yes" xml:space="preserve">
          <source>Aggregate initialization</source>
          <target state="translated">Inicialización agregada</target>
        </trans-unit>
        <trans-unit id="32f6926454c3165c26d9dc05c16b8b6e9f95c8bb" translate="yes" xml:space="preserve">
          <source>Aggregate initialization initializes</source>
          <target state="translated">La inicialización agregada inicializa</target>
        </trans-unit>
        <trans-unit id="ce0cf7c09d177b646d6d216478f49a68396c308c" translate="yes" xml:space="preserve">
          <source>Aggregates copy/move initialize directly from single-element braced-init-lists of the same type, but non-aggregates consider initializer_list constructors first:</source>
          <target state="translated">Los agregados copian/mueven inicializan directamente desde listas de elementos individuales con corchetes del mismo tipo,pero los no agregados consideran primero a los constructores de listas_inicializadoras:</target>
        </trans-unit>
        <trans-unit id="02f02485ab679a9031f461bdbd3edab48ea42a79" translate="yes" xml:space="preserve">
          <source>Algorithm</source>
          <target state="translated">Algorithm</target>
        </trans-unit>
        <trans-unit id="e8a0f2b8083d5e86992465667615250c3f737a35" translate="yes" xml:space="preserve">
          <source>Algorithm concepts and utilities</source>
          <target state="translated">Conceptos de algoritmos y utilidades</target>
        </trans-unit>
        <trans-unit id="b03f71c0b2a6d1e175830b00066b005660a7079a" translate="yes" xml:space="preserve">
          <source>Algorithm utilities</source>
          <target state="translated">Utilidades de los algoritmos</target>
        </trans-unit>
        <trans-unit id="67e15eb99dc0e473c962d6a494d00e048e9f6fc6" translate="yes" xml:space="preserve">
          <source>Algorithms</source>
          <target state="translated">Algorithms</target>
        </trans-unit>
        <trans-unit id="6886e87f506cf00f362a34227ad744fd6fcd6652" translate="yes" xml:space="preserve">
          <source>Algorithms library</source>
          <target state="translated">Biblioteca de algoritmos</target>
        </trans-unit>
        <trans-unit id="b1d4c8b0854335cb6dc181f5d361a3a9a6c77f1d" translate="yes" xml:space="preserve">
          <source>Algorithms that operate on ranges</source>
          <target state="translated">Los algoritmos que operan en los rangos</target>
        </trans-unit>
        <trans-unit id="8d55ef673ad6d9815c8fe83971681410e8111110" translate="yes" xml:space="preserve">
          <source>Alias declarations are &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt; with the following syntax:</source>
          <target state="translated">Las declaraciones de alias son &lt;a href=&quot;declarations&quot;&gt;declaraciones&lt;/a&gt; con la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="ac7adb6d456a732926b16ac92fea1efb425fa68c" translate="yes" xml:space="preserve">
          <source>Alias template is a name that refers to a family of types.</source>
          <target state="translated">La plantilla de alias es un nombre que se refiere a una familia de tipos.</target>
        </trans-unit>
        <trans-unit id="536ee4b3a1593a51e4e7a02e531109ebfa1e7aa5" translate="yes" xml:space="preserve">
          <source>Alias templates</source>
          <target state="translated">Alias de plantilla</target>
        </trans-unit>
        <trans-unit id="81fdfe39ee9314fa8adbdd24c8cefa9e67062042" translate="yes" xml:space="preserve">
          <source>Alias templates are never deduced by &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; when deducing a template template parameter.  It is not possible to &lt;a href=&quot;partial_specialization&quot;&gt;partially&lt;/a&gt; or &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialize&lt;/a&gt; an alias template.</source>
          <target state="translated">Las plantillas de alias nunca se deducen mediante &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;la deducci&amp;oacute;n de argumentos de plantilla&lt;/a&gt; al deducir un par&amp;aacute;metro de plantilla de plantilla. No es posible &lt;a href=&quot;template_specialization&quot;&gt;especializar &lt;/a&gt;&lt;a href=&quot;partial_specialization&quot;&gt;parcial&lt;/a&gt; o expl&amp;iacute;citamente una plantilla de alias.</target>
        </trans-unit>
        <trans-unit id="7f8c5176c3f03b97659161923f2b6492f7de7e73" translate="yes" xml:space="preserve">
          <source>Alignment</source>
          <target state="translated">Alignment</target>
        </trans-unit>
        <trans-unit id="a2aba61989bb9dc7a1e9fe034611bf7295de52c9" translate="yes" xml:space="preserve">
          <source>Alignment (as obtained by &lt;code&gt;alignof&lt;/code&gt;) has the type &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, but placement forms of allocation and deallocation functions that take &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; as an additional parameter are already in use, so this type is used instead.</source>
          <target state="translated">La alineaci&amp;oacute;n (obtenida por &lt;code&gt;alignof&lt;/code&gt; ) tiene el tipo &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , pero las formas de ubicaci&amp;oacute;n de las funciones de asignaci&amp;oacute;n y desasignaci&amp;oacute;n que toman &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; como par&amp;aacute;metro adicional ya est&amp;aacute;n en uso, por lo que este tipo se usa en su lugar.</target>
        </trans-unit>
        <trans-unit id="1284e78e088763e07d38bdc498c7ac19fcd9faaa" translate="yes" xml:space="preserve">
          <source>Alignment specifier</source>
          <target state="translated">Especificador de alineación</target>
        </trans-unit>
        <trans-unit id="6a72085653e4c5be8c7640c868ef787cbcf063d1" translate="yes" xml:space="preserve">
          <source>All</source>
          <target state="translated">All</target>
        </trans-unit>
        <trans-unit id="c533be78046b2b7438a7f5af4856db7635ad0dde" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../container&quot;&gt;standard library containers&lt;/a&gt; require that their element type satisfies Erasable.</source>
          <target state="translated">Todos &lt;a href=&quot;../container&quot;&gt;los contenedores de biblioteca est&amp;aacute;ndar&lt;/a&gt; requieren que su tipo de elemento cumpla con Erasable.</target>
        </trans-unit>
        <trans-unit id="ad583fce81393d0c4c343ed80041c1cf855fb389" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;pointers to functions&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">Todos los &lt;a href=&quot;../language/pointer#Pointers_to_functions&quot;&gt;punteros a funciones&lt;/a&gt; satisfacen este requisito.</target>
        </trans-unit>
        <trans-unit id="85e52ab157feeaab3392116ff6342f562d88a7b4" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;objects&quot;&gt;objects&lt;/a&gt; in a program have one of the following storage durations:</source>
          <target state="translated">Todos los &lt;a href=&quot;objects&quot;&gt;objetos&lt;/a&gt; en un programa tienen una de las siguientes duraciones de almacenamiento:</target>
        </trans-unit>
        <trans-unit id="2be019deb6ca8794e180ab1025f12fa6403846db" translate="yes" xml:space="preserve">
          <source>All &lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt; satisfy this requirement.</source>
          <target state="translated">Todos los &lt;a href=&quot;randomnumberengine&quot;&gt;RandomNumberEngines&lt;/a&gt; cumplen este requisito.</target>
        </trans-unit>
        <trans-unit id="5586b0fcd654b42e2d7df9c2c898d38125873577" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions can be called concurrently by different threads on the same container. In addition, the member functions &lt;code&gt;begin()&lt;/code&gt;, &lt;code&gt;end()&lt;/code&gt;, &lt;code&gt;rbegin()&lt;/code&gt;, &lt;code&gt;rend()&lt;/code&gt;, &lt;code&gt;front()&lt;/code&gt;, &lt;code&gt;back()&lt;/code&gt;, &lt;code&gt;data()&lt;/code&gt;, &lt;code&gt;find()&lt;/code&gt;, &lt;code&gt;lower_bound()&lt;/code&gt;, &lt;code&gt;upper_bound()&lt;/code&gt;, &lt;code&gt;equal_range()&lt;/code&gt;, &lt;code&gt;at()&lt;/code&gt;, and, except in associative containers, &lt;code&gt;operator[]&lt;/code&gt;, behave as &lt;code&gt;const&lt;/code&gt; for the purposes of thread safety (that is, they can also be called concurrently by different threads on the same container). More generally, the C++ standard library functions do not modify objects unless those objects are accessible, directly or indirectly, via the function's non-const arguments, including the this pointer.</source>
          <target state="translated">Todas las funciones miembro &lt;code&gt;const&lt;/code&gt; pueden ser llamadas simult&amp;aacute;neamente por diferentes hilos en el mismo contenedor. Adem&amp;aacute;s, las funciones miembro &lt;code&gt;begin()&lt;/code&gt; , &lt;code&gt;end()&lt;/code&gt; , &lt;code&gt;rbegin()&lt;/code&gt; , &lt;code&gt;rend()&lt;/code&gt; , &lt;code&gt;front()&lt;/code&gt; , &lt;code&gt;back()&lt;/code&gt; , &lt;code&gt;data()&lt;/code&gt; , &lt;code&gt;find()&lt;/code&gt; , &lt;code&gt;lower_bound()&lt;/code&gt; , &lt;code&gt;upper_bound()&lt;/code&gt; , &lt;code&gt;equal_range()&lt;/code&gt; , &lt;code&gt;at()&lt;/code&gt; , y, excepto en contenedores asociativos, el &lt;code&gt;operator[]&lt;/code&gt; , se comporta como &lt;code&gt;const&lt;/code&gt; antepara fines de seguridad de subprocesos (es decir, tambi&amp;eacute;n pueden llamarse simult&amp;aacute;neamente por diferentes subprocesos en el mismo contenedor). En t&amp;eacute;rminos m&amp;aacute;s generales, las funciones de la biblioteca est&amp;aacute;ndar de C ++ no modifican objetos a menos que esos objetos sean accesibles, directa o indirectamente, a trav&amp;eacute;s de los argumentos no constantes de la funci&amp;oacute;n, incluido el puntero this.</target>
        </trans-unit>
        <trans-unit id="4ce574fe03a26ad67fb18ae15f6d204f756c8e28" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;const&lt;/code&gt; member functions of &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; are provided.</source>
          <target state="translated">Se proporcionan todas las funciones miembro &lt;code&gt;const&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4c5afaf4fff1d58306c2cfe530397e8446742a3" translate="yes" xml:space="preserve">
          <source>All &lt;code&gt;emit()&lt;/code&gt; calls transferring characters to the same wrapped stream buffer object appear to execute in a total order, where each &lt;code&gt;emit()&lt;/code&gt; call &lt;a href=&quot;../../atomic/memory_order&quot;&gt;synchronizes-with&lt;/a&gt; subsequent &lt;code&gt;emit()&lt;/code&gt; calls in that total order, even if these calls are made through difference instances of &lt;code&gt;std::basic_syncbuf&lt;/code&gt;/&lt;code&gt;std::basic_osyncstream&lt;/code&gt;. In practice, this means that emit() takes a lock uniquely associated with the wrapped stream object: for example, it could be held in a static hash map where the address of the wrapped stream is used as the key.</source>
          <target state="translated">Todas las llamadas &lt;code&gt;emit()&lt;/code&gt; transfieren caracteres al mismo objeto buffer de flujo envuelto parecen ejecutarse en un orden total, donde cada llamada &lt;code&gt;emit()&lt;/code&gt; &lt;a href=&quot;../../atomic/memory_order&quot;&gt;sincroniza con&lt;/a&gt; las llamadas &lt;code&gt;emit()&lt;/code&gt; posteriores en ese orden total, incluso si estas llamadas se realizan a trav&amp;eacute;s de instancias diferentes de &lt;code&gt;std::basic_syncbuf&lt;/code&gt; / &lt;code&gt;std::basic_osyncstream&lt;/code&gt; . En la pr&amp;aacute;ctica, esto significa que emit () toma un bloqueo &amp;uacute;nicamente asociado con el objeto de flujo envuelto: por ejemplo, podr&amp;iacute;a mantenerse en un mapa hash est&amp;aacute;tico donde la direcci&amp;oacute;n del flujo envuelto se usa como clave.</target>
        </trans-unit>
        <trans-unit id="08e7989631f4fa0b7b123c5eceab25241a651d43" translate="yes" xml:space="preserve">
          <source>All Function objects defined in &lt;a href=&quot;../header/functional&quot;&gt;&lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Todos los objetos de funci&amp;oacute;n definidos en &lt;a href=&quot;../header/functional&quot;&gt; &lt;code&gt;&amp;lt;functional&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="267678e718109eec99ac63d1e0c78b1e78e6bc72" translate="yes" xml:space="preserve">
          <source>All arithmetic operators compute the result of specific arithmetic operation and returns its result. The arguments are not modified.</source>
          <target state="translated">Todos los operadores aritméticos calculan el resultado de una operación aritmética específica y devuelven su resultado.Los argumentos no se modifican.</target>
        </trans-unit>
        <trans-unit id="2196ca16119493aee11e0e86a9a7193062fd552b" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">Todos los tipos at&amp;oacute;micos, excepto &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pueden implementarse utilizando mutexes u otras operaciones de bloqueo, en lugar de utilizar las instrucciones de la CPU at&amp;oacute;mica sin bloqueo. Los tipos at&amp;oacute;micos tambi&amp;eacute;n pueden ser</target>
        </trans-unit>
        <trans-unit id="acf874c1ced8a0f3cff5567518c467d553d7b81d" translate="yes" xml:space="preserve">
          <source>All atomic types except for &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; may be implemented using mutexes or other locking operations, rather than using the lock-free atomic CPU instructions. Atomic types are also allowed to be</source>
          <target state="translated">Todos los tipos at&amp;oacute;micos, excepto &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pueden implementarse utilizando mutexes u otras operaciones de bloqueo, en lugar de utilizar las instrucciones de la CPU at&amp;oacute;mica sin bloqueo. Los tipos at&amp;oacute;micos tambi&amp;eacute;n pueden ser</target>
        </trans-unit>
        <trans-unit id="1c6a82095fc35876e8565ece289c3317d10e940b" translate="yes" xml:space="preserve">
          <source>All built-in assignment operators return &lt;code&gt;*this&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;*this&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">Todos los operadores de asignaci&amp;oacute;n incorporados devuelven &lt;code&gt;*this&lt;/code&gt; , y la mayor&amp;iacute;a de &lt;a href=&quot;operators&quot;&gt;las sobrecargas definidas por el usuario&lt;/a&gt; tambi&amp;eacute;n devuelven &lt;code&gt;*this&lt;/code&gt; para que los operadores definidos por el usuario puedan usarse de la misma manera que los incorporados. Sin embargo, en una sobrecarga de operador definida por el usuario, cualquier tipo puede usarse como tipo de retorno (incluido &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1e3f7702614f1e201b0d2d7ca9cab6129fd842e0" translate="yes" xml:space="preserve">
          <source>All built-in operators return &lt;code&gt;bool&lt;/code&gt;, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">Todos los operadores integrados devuelven &lt;code&gt;bool&lt;/code&gt; , y la mayor&amp;iacute;a de &lt;a href=&quot;operators&quot;&gt;las sobrecargas definidas&lt;/a&gt; por el usuario tambi&amp;eacute;n devuelven &lt;code&gt;bool&lt;/code&gt; para que los operadores definidos por el usuario puedan usarse de la misma manera que los incorporados. Sin embargo, en una sobrecarga de operador definida por el usuario, cualquier tipo puede usarse como tipo de retorno (incluido &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad44cda1026b661b30b82e23a1cc8e4adc8dad82" translate="yes" xml:space="preserve">
          <source>All built-in operators return values, and most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return values so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;). In particular, stream insertion and stream extraction overloads of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; and &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; return &lt;code&gt;T&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Todos los operadores integrados devuelven valores, y la mayor&amp;iacute;a&lt;a href=&quot;operators&quot;&gt; las sobrecargas definidas&lt;/a&gt; por el usuario tambi&amp;eacute;n devuelven valores para que los operadores definidos por el usuario puedan usarse de la misma manera que los incorporados. Sin embargo, en una sobrecarga de operador definida por el usuario, cualquier tipo puede usarse como tipo de retorno (incluido &lt;code&gt;void&lt;/code&gt; ). En particular, las sobrecargas de inserci&amp;oacute;n y extracci&amp;oacute;n de flujo del &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; y &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; devuelven &lt;code&gt;T&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c15cf3f5d785f05b074208b892da42654f696fb" translate="yes" xml:space="preserve">
          <source>All comments are removed from the program at &lt;a href=&quot;language/translation_phases&quot;&gt;translation phase 3&lt;/a&gt; by replacing each comment with a single whitespace character.</source>
          <target state="translated">Todos los comentarios se eliminan del programa en la &lt;a href=&quot;language/translation_phases&quot;&gt;fase de traducci&amp;oacute;n 3&lt;/a&gt; reemplazando cada comentario con un solo car&amp;aacute;cter de espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="bf78ad8fede01661fec9052125328b1508f2f4d8" translate="yes" xml:space="preserve">
          <source>All comparison operators are short-circuited; they do not access tuple elements beyond what is necessary to determine the result of the comparison.</source>
          <target state="translated">Todos los operadores de comparación están en cortocircuito;no acceden a los elementos tuplicados más allá de lo necesario para determinar el resultado de la comparación.</target>
        </trans-unit>
        <trans-unit id="d086b64161b8d9aca02f8348f6309d2102ee1278" translate="yes" xml:space="preserve">
          <source>All comparisons are done via the &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; member function (which itself is defined in terms of &lt;code&gt;Traits::compare()&lt;/code&gt;):</source>
          <target state="translated">Todas las comparaciones se realizan a trav&amp;eacute;s de la funci&amp;oacute;n miembro &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; (que se define en t&amp;eacute;rminos de &lt;code&gt;Traits::compare()&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="b8289f337cbc9bd64fef53be2978b84bf37ef44f" translate="yes" xml:space="preserve">
          <source>All constants, except for &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt;, are bitmask elements. The &lt;code&gt;match_default&lt;/code&gt; and &lt;code&gt;format_default&lt;/code&gt; constants are empty bitmasks.</source>
          <target state="translated">Todas las constantes, excepto &lt;code&gt;match_default&lt;/code&gt; y &lt;code&gt;format_default&lt;/code&gt; , son elementos de m&amp;aacute;scara de bits. Las constantes &lt;code&gt;match_default&lt;/code&gt; y &lt;code&gt;format_default&lt;/code&gt; son m&amp;aacute;scaras de bits vac&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="dc168f2bceb154961bb7ed9909031e74d78d43a5" translate="yes" xml:space="preserve">
          <source>All constructors that take &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; as the only argument, or as the first argument if the remaining arguments have default values, are examined, and matched by &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; against a single argument of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Todos los constructores que toman &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; como &amp;uacute;nico argumento, o como el primer argumento si los argumentos restantes tienen valores predeterminados, se examinan y se comparan por &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; contra un &amp;uacute;nico argumento de tipo &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2bcfde28187d671e9cbf776fb85caf9d73bb4df9" translate="yes" xml:space="preserve">
          <source>All container functions can be called concurrently by different threads on different containers. More generally, the C++ standard library functions do not read objects accessible by other threads unless those objects are directly or indirectly accessible via the function arguments, including the this pointer.</source>
          <target state="translated">Todas las funciones de los contenedores pueden ser llamadas simultáneamente por diferentes hilos en diferentes contenedores.En términos más generales,las funciones de la biblioteca estándar de C++no leen objetos accesibles por otros hilos a menos que esos objetos sean directa o indirectamente accesibles por medio de los argumentos de la función,incluido el puntero de este.</target>
        </trans-unit>
        <trans-unit id="36bd3ae32477cc666c63b1b73c2d5eb0bca71c31" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/byte/isspace&quot;&gt;&lt;code&gt;isspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">Todos los especificadores de conversi&amp;oacute;n que no sean &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;n&lt;/code&gt; consumen y descartan todos los caracteres de espacio en blanco &lt;a href=&quot;../../string/byte/isspace&quot;&gt; &lt;code&gt;isspace&lt;/code&gt; &lt;/a&gt; (determinado como si se llama a isspace ) antes de intentar analizar la entrada. Estos caracteres consumidos no cuentan para el ancho de campo m&amp;aacute;ximo especificado.</target>
        </trans-unit>
        <trans-unit id="a2b014357acb5001a9291cf56269f10b96493516" translate="yes" xml:space="preserve">
          <source>All conversion specifiers other than &lt;code&gt;[&lt;/code&gt;, &lt;code&gt;c&lt;/code&gt;, and &lt;code&gt;n&lt;/code&gt; consume and discard all leading whitespace characters (determined as if by calling &lt;a href=&quot;../../string/wide/iswspace&quot;&gt;&lt;code&gt;iswspace&lt;/code&gt;&lt;/a&gt;) before attempting to parse the input. These consumed characters do not count towards the specified maximum field width.</source>
          <target state="translated">Todos los especificadores de conversi&amp;oacute;n que no sean &lt;code&gt;[&lt;/code&gt; , &lt;code&gt;c&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; consumen y descartan todos los caracteres de espacio en blanco &lt;a href=&quot;../../string/wide/iswspace&quot;&gt; &lt;code&gt;iswspace&lt;/code&gt; &lt;/a&gt; (determinado como si se llamara iswspace ) antes de intentar analizar la entrada. Estos caracteres consumidos no cuentan para el ancho de campo m&amp;aacute;ximo especificado.</target>
        </trans-unit>
        <trans-unit id="cbea028682ce84815358b5aa6eda3b614cfe993e" translate="yes" xml:space="preserve">
          <source>All custom allocators also must be stateless.</source>
          <target state="translated">Todos los asignadores de aduanas también deben ser apátridas.</target>
        </trans-unit>
        <trans-unit id="e99bcc0ededa138f077034c407c38f0bfa9cb54b" translate="yes" xml:space="preserve">
          <source>All deallocation functions are &lt;code&gt;noexcept(true)&lt;/code&gt; unless specified otherwise in the declaration.</source>
          <target state="translated">Todas las funciones de desasignaci&amp;oacute;n son &lt;code&gt;noexcept(true)&lt;/code&gt; menos que se especifique lo contrario en la declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7590e38178794abe168d1f61e5e605ebedab40ca" translate="yes" xml:space="preserve">
          <source>All direct base classes have trivial destructors</source>
          <target state="translated">Todas las clases de bases directas tienen destructores triviales</target>
        </trans-unit>
        <trans-unit id="d1644548c66e07081be823b1a24493d9cfc6d493" translate="yes" xml:space="preserve">
          <source>All error codes are distinct and non-zero.</source>
          <target state="translated">Todos los códigos de error son distintos y distintos de cero.</target>
        </trans-unit>
        <trans-unit id="4eb9393603f7bb0528b986591eb39bc9de40a1c4" translate="yes" xml:space="preserve">
          <source>All evaluations of &lt;code&gt;h(k)&lt;/code&gt;executed within a given execution of a program(since C++14) yield the same result for the same value of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">Todas las evaluaciones de &lt;code&gt;h(k)&lt;/code&gt; ejecutadas dentro de una ejecuci&amp;oacute;n dada de un programa (desde C ++ 14) producen el mismo resultado para el mismo valor de &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="615556c95cd2277e3f2551bbe6ac5d7b7503c6b8" translate="yes" xml:space="preserve">
          <source>All exceptions generated by the standard library inherit from &lt;code&gt;std::exception&lt;/code&gt;.</source>
          <target state="translated">Todas las excepciones generadas por la biblioteca est&amp;aacute;ndar heredan de &lt;code&gt;std::exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47496370c3026a6d2335b4c07d2899c2bfd0a9f8" translate="yes" xml:space="preserve">
          <source>All existing elements of &lt;code&gt;a&lt;/code&gt; are either move assigned to or destroyed; &lt;code&gt;a&lt;/code&gt; is equal to the value that &lt;code&gt;rv&lt;/code&gt; had before the assignment</source>
          <target state="translated">Todos los elementos existentes de &lt;code&gt;a&lt;/code&gt; son movimientos asignados o destruidos; &lt;code&gt;a&lt;/code&gt; es igual al valor que ten&amp;iacute;a &lt;code&gt;rv&lt;/code&gt; antes de la asignaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="9b1c1c57702fcbfb1474e82ce403b1688060d643" translate="yes" xml:space="preserve">
          <source>All explicit and partial specializations of &lt;code&gt;hash&lt;/code&gt; provided by the standard library are &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; and &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;. User-provided specializations of &lt;code&gt;hash&lt;/code&gt; also must meet those requirements.</source>
          <target state="translated">Todas las especializaciones expl&amp;iacute;citas y parciales de &lt;code&gt;hash&lt;/code&gt; proporcionadas por la biblioteca est&amp;aacute;ndar son &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; y &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; . Las especializaciones de &lt;code&gt;hash&lt;/code&gt; proporcionadas por el usuario tambi&amp;eacute;n deben cumplir esos requisitos.</target>
        </trans-unit>
        <trans-unit id="d3caef46757d5c781ce31db0ab1b1d011a7c9448" translate="yes" xml:space="preserve">
          <source>All functions accepting an argument of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; except &lt;a href=&quot;begin2&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;end2&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt;(since C++11) should also accept the replacement type.</source>
          <target state="translated">Todas las funciones que aceptan un argumento de tipo &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; except &lt;a href=&quot;begin2&quot;&gt; &lt;code&gt;begin()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;end2&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; (ya que C ++ 11) tambi&amp;eacute;n deber&amp;iacute;an aceptar el tipo de reemplazo.</target>
        </trans-unit>
        <trans-unit id="0179673daad25aa9537982f33e1688378d0b8b34" translate="yes" xml:space="preserve">
          <source>All functions accepting two arguments of type &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; should accept every combination of &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; and the replacement type.</source>
          <target state="translated">Todas las funciones aceptan dos argumentos de tipo &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; deber&amp;iacute;an aceptar todas las combinaciones de &lt;code&gt;const &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;amp;&lt;/code&gt; y el tipo de reemplazo.</target>
        </trans-unit>
        <trans-unit id="c84866185eebd1e3d3c0bd203de655735b81b728" translate="yes" xml:space="preserve">
          <source>All functions from &lt;a href=&quot;../../types#Type_traits&quot;&gt;&amp;lt;type_traits&amp;gt;&lt;/a&gt;</source>
          <target state="translated">Todas las funciones de &lt;a href=&quot;../../types#Type_traits&quot;&gt; &amp;lt;type_traits&amp;gt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="eacdccc0ff89286560bd5447dd6d3e5754738868" translate="yes" xml:space="preserve">
          <source>All implicitly-captured variables must be declared within the</source>
          <target state="translated">Todas las variables capturadas implícitamente deben ser declaradas dentro de la</target>
        </trans-unit>
        <trans-unit id="ee4038fb61cddc0d5aee00559af689e67143f4cb" translate="yes" xml:space="preserve">
          <source>All implicitly-declared member functions (and inheriting constructors) have exception specifications, selected as follows:</source>
          <target state="translated">Todas las funciones de los miembros implícitamente declarados (y los constructores herederos)tienen especificaciones de excepción,seleccionadas de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="73a8920376f49ed06b9320f4b183b14d1b56c59a" translate="yes" xml:space="preserve">
          <source>All instances of &lt;code&gt;std::monostate&lt;/code&gt; compare equal.</source>
          <target state="translated">Todas las instancias de &lt;code&gt;std::monostate&lt;/code&gt; comparan igual.</target>
        </trans-unit>
        <trans-unit id="6f36973910215a95c48be1c361c474c6abda5dfd" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated, unless the erased elements are at the end or the beginning of the container, in which case only the iterators and references to the erased elements are invalidated.</source>
          <target state="translated">Todos los iteradores y referencias se invalidan,a menos que los elementos borrados se encuentren al final o al principio del contenedor,en cuyo caso sólo se invalidan los iteradores y referencias a los elementos borrados.</target>
        </trans-unit>
        <trans-unit id="3ff58822fed4cebf575b53176b537d16617bfe40" translate="yes" xml:space="preserve">
          <source>All iterators and references are invalidated. Past-the-end iterator is also invalidated.</source>
          <target state="translated">Todos los iteradores y referencias son invalidados.El iterador del pasado también está invalidado.</target>
        </trans-unit>
        <trans-unit id="b6bfeb63a7689b81c8714600b9a0261d56188882" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. It is unspecified whether an iterator holding the past-the-end value in this container will refer to this or the other container after the operation.</source>
          <target state="translated">Todos los iteradores y referencias siguen siendo válidos.No se especifica si un iterador que contenga el valor pasado en este contenedor se referirá a éste o al otro contenedor después de la operación.</target>
        </trans-unit>
        <trans-unit id="c94adb4871f7b21a7fe1f80a6cb316845a106fd2" translate="yes" xml:space="preserve">
          <source>All iterators and references remain valid. The past-the-end iterator is invalidated.</source>
          <target state="translated">Todos los iteradores y referencias siguen siendo válidos.El iterador de pasado y final queda invalidado.</target>
        </trans-unit>
        <trans-unit id="ca555a6b3c340c88a2973a4408368f43f4dc4831" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. No references are invalidated.</source>
          <target state="translated">Todos los iteradores,incluyendo el iterador pasado,son invalidados.No se invalida ninguna referencia.</target>
        </trans-unit>
        <trans-unit id="cf1ebdb0694902a0ff8fae76c426f9dc6a20dead" translate="yes" xml:space="preserve">
          <source>All iterators, including the past-the-end iterator, are invalidated. References are invalidated too, unless &lt;code&gt;pos == begin()&lt;/code&gt; or &lt;code&gt;pos == end()&lt;/code&gt;, in which case they are not invalidated.</source>
          <target state="translated">Todos los iteradores, incluido el iterador pasado al final, est&amp;aacute;n invalidados. Las referencias tambi&amp;eacute;n se invalidan, a menos que &lt;code&gt;pos == begin()&lt;/code&gt; o &lt;code&gt;pos == end()&lt;/code&gt; , en cuyo caso no se invalidan.</target>
        </trans-unit>
        <trans-unit id="40ad628bf4f34bdc58de5f589d209eea4731620e" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated.</source>
          <target state="translated">Todos los iteradores,punteros y referencias a los elementos del contenedor son invalidados.</target>
        </trans-unit>
        <trans-unit id="94cae0bd78bc02d0cb18bf7254756a408b83ca8f" translate="yes" xml:space="preserve">
          <source>All iterators, pointers and references to the elements of the container are invalidated. The past-the-end iterator is also invalidated.</source>
          <target state="translated">Todos los iteradores,punteros y referencias a los elementos del contenedor son invalidados.El iterador del pasado también se invalida.</target>
        </trans-unit>
        <trans-unit id="1aa2eedbbbd254c0a4f9a58cb63ee4b66a5cdbf4" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order</source>
          <target state="translated">Todas las operaciones de bloqueo y desbloqueo en un solo mutex se producen en un solo orden total</target>
        </trans-unit>
        <trans-unit id="178cdfec76dc5f4d6166a9e91517e1f3fec12bff" translate="yes" xml:space="preserve">
          <source>All lock and unlock operations on a single mutex occur in a single total order that can be viewed as &lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of an atomic variable: the order is specific to this individual mutex.</source>
          <target state="translated">Todas las operaciones de bloqueo y desbloqueo en un &amp;uacute;nico mutex se producen en un solo orden total que se puede ver como &lt;a href=&quot;../atomic/memory_order#Modification_order&quot;&gt;orden de modificaci&amp;oacute;n&lt;/a&gt; de de una variable at&amp;oacute;mica: el orden es espec&amp;iacute;fico para este mutex individual.</target>
        </trans-unit>
        <trans-unit id="34930fdb8cc73ddd310f600e059433705d8a684e" translate="yes" xml:space="preserve">
          <source>All member functions (including copy constructor and copy assignment) can be called by multiple threads on different instances of &lt;code&gt;shared_ptr&lt;/code&gt; without additional synchronization even if these instances are copies and share ownership of the same object. If multiple threads of execution access the same &lt;code&gt;shared_ptr&lt;/code&gt; without synchronization and any of those accesses uses a non-const member function of &lt;code&gt;shared_ptr&lt;/code&gt; then a data race will occur; the &lt;a href=&quot;shared_ptr/atomic&quot;&gt;shared_ptr overloads of atomic functions&lt;/a&gt; can be used to prevent the data race.</source>
          <target state="translated">Todas las funciones miembro (incluido el constructor de copias y la asignaci&amp;oacute;n de copias) pueden ser llamadas por m&amp;uacute;ltiples hilos en diferentes instancias de &lt;code&gt;shared_ptr&lt;/code&gt; sin sincronizaci&amp;oacute;n adicional, incluso si estas instancias son copias y comparten la propiedad del mismo objeto. Si varios subprocesos de ejecuci&amp;oacute;n acceden al mismo &lt;code&gt;shared_ptr&lt;/code&gt; sin sincronizaci&amp;oacute;n y cualquiera de esos accesos utiliza una funci&amp;oacute;n de miembro no constante de &lt;code&gt;shared_ptr&lt;/code&gt; , se producir&amp;aacute; una carrera de datos; las &lt;a href=&quot;shared_ptr/atomic&quot;&gt;sobrecargas shared_ptr de funciones at&amp;oacute;micas&lt;/a&gt; pueden ser usados para prevenir la carrera de datos.</target>
        </trans-unit>
        <trans-unit id="35b76e83898bb18b9a2f37898e8607d37cde7935" translate="yes" xml:space="preserve">
          <source>All member functions of all standard library specializations of this template are &lt;code&gt;noexcept&lt;/code&gt; except for the member functions of &lt;a href=&quot;optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;variant/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Todas las funciones miembro de todas las especialidades de la biblioteca est&amp;aacute;ndar de esta plantilla son &lt;code&gt;noexcept&lt;/code&gt; a excepci&amp;oacute;n de las funciones miembro de &lt;a href=&quot;optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;variant/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::variant&amp;gt;&lt;/code&gt; &lt;/a&gt; , y &lt;a href=&quot;../memory/unique_ptr/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::unique_ptr&amp;gt;&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8504e2abc83d5c2fab9fb5538bf231a69f226b05" translate="yes" xml:space="preserve">
          <source>All members are defined at once in the class definition, they cannot be added to an already-defined class (unlike the members of namespaces).</source>
          <target state="translated">Todos los miembros se definen a la vez en la definición de la clase,no pueden añadirse a una clase ya definida (a diferencia de los miembros de los espacios de nombres).</target>
        </trans-unit>
        <trans-unit id="5302fa5db09bb78acbca4f2b6c8fda7d03161a35" translate="yes" xml:space="preserve">
          <source>All members of a class (bodies of &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, initializers of member objects, and the entire &lt;a href=&quot;nested_classes&quot;&gt;nested class definitions&lt;/a&gt;) have access to all names the class can access. A local class within a member function has access to all names the member function can access.</source>
          <target state="translated">Todos los miembros de una clase (cuerpos de &lt;a href=&quot;member_functions&quot;&gt;funciones miembro&lt;/a&gt; , inicializadores de objetos miembro y todas &lt;a href=&quot;nested_classes&quot;&gt;las definiciones de clase anidadas&lt;/a&gt; ) tienen acceso a todos los nombres a los que puede acceder la clase. Una clase local dentro de una funci&amp;oacute;n miembro tiene acceso a todos los nombres a los que puede acceder la funci&amp;oacute;n miembro.</target>
        </trans-unit>
        <trans-unit id="59ab18ea391c2d9b328f2f7d982b4ad982485409" translate="yes" xml:space="preserve">
          <source>All modifications to any particular atomic variable occur in a total order that is specific to this one atomic variable.</source>
          <target state="translated">Todas las modificaciones de cualquier variable atómica en particular ocurren en un orden total que es específico de esta única variable atómica.</target>
        </trans-unit>
        <trans-unit id="d28efff2a0fb864afdef01249aa565cd9c9d0c3a" translate="yes" xml:space="preserve">
          <source>All names introduced by the declarations that appear within namespace-body (including nested namespace definitions) become members of the namespace identifier, whether this namespace definition is the original namespace definition (which introduced identifier), or an extension namespace definition (which &quot;reopened&quot; the already defined namespace).</source>
          <target state="translated">Todos los nombres introducidos por las declaraciones que figuran en el cuerpo del espacio de nombres (incluidas las definiciones anidadas de espacio de nombres)pasan a ser miembros del identificador del espacio de nombres,ya sea que esta definición de espacio de nombres sea la definición original del espacio de nombres (que introdujo el identificador)o una definición de extensión del espacio de nombres (que &quot;reabrió&quot; el espacio de nombres ya definido).</target>
        </trans-unit>
        <trans-unit id="b08c863ba714f38d0d860de01117473b44bbbe86" translate="yes" xml:space="preserve">
          <source>All non-local variables with static &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; are initialized as part of program startup, before the execution of the &lt;a href=&quot;main_function&quot;&gt;main function&lt;/a&gt; begins (unless deferred, see below). All variables with thread-local storage duration are initialized as part of thread launch, sequenced-before the execution of the thread function begins. For both of these classes of variables, initialization occurs in two distinct stages:</source>
          <target state="translated">Todas las variables no locales con &lt;a href=&quot;storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; est&amp;aacute;tico se inicializan como parte del inicio del programa, antes de la ejecuci&amp;oacute;n de la &lt;a href=&quot;main_function&quot;&gt;funci&amp;oacute;n principal.&lt;/a&gt; (a menos que se difiera, ver m&amp;aacute;s abajo). Todas las variables con duraci&amp;oacute;n de almacenamiento local de subprocesos se inicializan como parte del inicio del subproceso, secuenciadas antes de que comience la ejecuci&amp;oacute;n de la funci&amp;oacute;n del subproceso. Para ambas clases de variables, la inicializaci&amp;oacute;n ocurre en dos etapas distintas:</target>
        </trans-unit>
        <trans-unit id="55481c71bd011e1fe7bc3e43733da57362a61783" translate="yes" xml:space="preserve">
          <source>All non-specialized &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; functions are also provided by this specialization, and no additional member functions.</source>
          <target state="translated">Todas &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; funciones std :: atomic no especializadas tambi&amp;eacute;n son proporcionadas por esta especializaci&amp;oacute;n, y no hay funciones miembro adicionales.</target>
        </trans-unit>
        <trans-unit id="0557b920b1069437438d197127c5136f3ee6adf1" translate="yes" xml:space="preserve">
          <source>All non-static data members and base classes are themselves standard layout types</source>
          <target state="translated">Todos los miembros de datos no estáticos y las clases de base son en sí mismos tipos de disposición estándar</target>
        </trans-unit>
        <trans-unit id="e4dcf520b0bb3c172727a71b79681a5d16c241c8" translate="yes" xml:space="preserve">
          <source>All non-static data members have the same &lt;a href=&quot;../language/access&quot;&gt;access control&lt;/a&gt;</source>
          <target state="translated">Todos los miembros de datos no est&amp;aacute;ticos tienen el mismo &lt;a href=&quot;../language/access&quot;&gt;control de acceso.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="624a5b6de90948456f868c89c51c9329989f3cb3" translate="yes" xml:space="preserve">
          <source>All non-static data members of class type (or array of class type) have trivial destructors</source>
          <target state="translated">Todos los miembros de datos no estáticos del tipo de clase (o conjunto de tipos de clase)tienen destructores triviales</target>
        </trans-unit>
        <trans-unit id="f485616a097e8c940e99a2d2edb5c6f19158253d" translate="yes" xml:space="preserve">
          <source>All of the elements before this new &lt;code&gt;nth&lt;/code&gt; element are less than or equal to the elements after the new &lt;code&gt;nth&lt;/code&gt; element.</source>
          <target state="translated">Todos los elementos antes de este nuevo &lt;code&gt;nth&lt;/code&gt; elemento son menores o iguales que los elementos despu&amp;eacute;s del nuevo &lt;code&gt;nth&lt;/code&gt; elemento.</target>
        </trans-unit>
        <trans-unit id="d5ea57823ac6ced06c326c70fd59fde6fcce0fad" translate="yes" xml:space="preserve">
          <source>All of the iterator categories (except &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;) can be organized into a hierarchy, where more powerful iterator categories (e.g. &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;) support the operations of less powerful categories (e.g. &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;). If an iterator falls into one of these categories and also satisfies the requirements of &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, then it is called a</source>
          <target state="translated">Todas las categor&amp;iacute;as de iterador (excepto &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; y &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; ) se pueden organizar en una jerarqu&amp;iacute;a, donde las categor&amp;iacute;as de iterador m&amp;aacute;s potentes (por ejemplo, &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; ) admiten las operaciones de categor&amp;iacute;as menos potentes (por ejemplo, &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; ). Si un iterador cae en una de estas categor&amp;iacute;as y tambi&amp;eacute;n satisface los requisitos de &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , se llama</target>
        </trans-unit>
        <trans-unit id="f4c48696f28287567f830764d3d2f6d6181a4365" translate="yes" xml:space="preserve">
          <source>All other constructors take an allocator parameter.</source>
          <target state="translated">Todos los demás constructores toman un parámetro asignador.</target>
        </trans-unit>
        <trans-unit id="9051dde370d80e8aba9af3637e2fe2a4c637ddb2" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated</source>
          <target state="translated">Todas las indicaciones se consideran válidas y pueden ser desviadas o distribuidas.</target>
        </trans-unit>
        <trans-unit id="06db46d40762e7a049233b69f344ddc40172814b" translate="yes" xml:space="preserve">
          <source>All pointers are considered valid and may be dereferenced or deallocated. A reachability-based leak detector may be active</source>
          <target state="translated">Todas las indicaciones se consideran válidas y pueden ser desviadas o distribuidas.Un detector de fugas basado en la accesibilidad puede estar activo</target>
        </trans-unit>
        <trans-unit id="bdcfa55217ac64f8db8a5cf75b2b3e2a7b2b589f" translate="yes" xml:space="preserve">
          <source>All pointers, references, and iterators are invalidated.</source>
          <target state="translated">Todos los indicadores,referencias e iteradores son invalidados.</target>
        </trans-unit>
        <trans-unit id="cae4dbc2c6705f38175037741cbe2272cd9f0a9e" translate="yes" xml:space="preserve">
          <source>All private data members and all private non-virtual member functions are placed in the implementation class. All public, protected, and virtual members remain in the interface class (see &lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW #100&lt;/a&gt; for the discussion of the alternatives).</source>
          <target state="translated">Todos los miembros de datos privados y todas las funciones de miembros privados no virtuales se colocan en la clase de implementaci&amp;oacute;n. Todos los miembros p&amp;uacute;blicos, protegidos y virtuales permanecen en la clase de interfaz (vea &lt;a href=&quot;http://herbsutter.com/gotw/_100/&quot;&gt;GOTW # 100&lt;/a&gt; para la discusi&amp;oacute;n de las alternativas).</target>
        </trans-unit>
        <trans-unit id="6ad08b1a1866207c625f156796d23145d807041c" translate="yes" xml:space="preserve">
          <source>All read only operations</source>
          <target state="translated">Todas las operaciones de sólo lectura</target>
        </trans-unit>
        <trans-unit id="51f454bbf261c865ca3eafaca5186949d522a16c" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Todas las operaciones de solo lectura, &lt;code&gt;&lt;a href=&quot;unordered_map/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d0ff23cc747ee3f2c2cacda30dad2daf43fc67d" translate="yes" xml:space="preserve">
          <source>All read only operations, &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Todas las operaciones de solo lectura, &lt;code&gt;&lt;a href=&quot;vector/swap&quot;&gt;swap&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41a67df5b26d67f230c41a225f6f4807b01737d6" translate="yes" xml:space="preserve">
          <source>All references, pointers, and iterators are invalidated, including the end iterator. &lt;code&gt;a.empty() == true&lt;/code&gt;.</source>
          <target state="translated">Todas las referencias, punteros e iteradores est&amp;aacute;n invalidados, incluido el iterador final. &lt;code&gt;a.empty() == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe67501a1ba3ff0b54181ac0c20ec517abdc3e4" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;basic_string_view&lt;/code&gt; as well.</source>
          <target state="translated">Todos los requisitos sobre los tipos de iterador de un &lt;a href=&quot;../named_req/container&quot;&gt;Contenedor se&lt;/a&gt; aplican tambi&amp;eacute;n a los tipos de &lt;code&gt;iterator&lt;/code&gt; y &lt;code&gt;const_iterator&lt;/code&gt; de &lt;code&gt;basic_string_view&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f7b5a1e5c99b2a9bb4697e1dc9787334111a47c" translate="yes" xml:space="preserve">
          <source>All requirements on the iterator types of a &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; applies to the &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; types of &lt;code&gt;span&lt;/code&gt; as well.</source>
          <target state="translated">Todos los requisitos sobre los tipos de iterador de un &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt; se aplica a los &lt;code&gt;iterator&lt;/code&gt; y &lt;code&gt;const_iterator&lt;/code&gt; tipos de &lt;code&gt;span&lt;/code&gt; tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="38eb211404e95dd1fe2352aec53428f8cadc5999" translate="yes" xml:space="preserve">
          <source>All resources owned by &lt;code&gt;u&lt;/code&gt; are reclaimed, no exceptions are thrown.</source>
          <target state="translated">Todos los recursos propiedad de &lt;code&gt;u&lt;/code&gt; son recuperados, no se lanzan excepciones.</target>
        </trans-unit>
        <trans-unit id="67f929817d9ab7c1515c103b3dec94699f49b916" translate="yes" xml:space="preserve">
          <source>All restrictions on regular declarations of the same names, hiding, and overloading rules apply to using-declarations:</source>
          <target state="translated">Todas las restricciones sobre las declaraciones regulares de los mismos nombres,las reglas de ocultación y sobrecarga se aplican a las declaraciones de uso:</target>
        </trans-unit>
        <trans-unit id="be8b6e7136fa8d596cfda90d7fa7d28938ef27cd" translate="yes" xml:space="preserve">
          <source>All six relational operators are automatically generated by the compiler if the three-way comparison operator &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; is defined, and that operator, in turn, is generated by the compiler if it is defined as defaulted:</source>
          <target state="translated">El compilador genera autom&amp;aacute;ticamente los seis operadores relacionales si se define el &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; operador de comparaci&amp;oacute;n de tres v&amp;iacute;as &amp;lt;=&amp;gt; , y ese operador, a su vez, es generado por el compilador si se define como predeterminado:</target>
        </trans-unit>
        <trans-unit id="0d9fb7dc61944bda88f1835dd4562a6f28a100a2" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;fpos&lt;/code&gt; meet the &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; requirements.</source>
          <target state="translated">Todas las especializaciones de &lt;code&gt;fpos&lt;/code&gt; cumplen los requisitos &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; e &lt;a href=&quot;../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="672a39cb4d9a7dc48c3d594e3812033e46d14edc" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;polymorphic_allocator&lt;/code&gt; meet the &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;Allocator completeness requirements&lt;/a&gt;.</source>
          <target state="translated">Todas las especializaciones de &lt;code&gt;polymorphic_allocator&lt;/code&gt; cumplen los &lt;a href=&quot;../named_req/allocator#Allocator_completeness_requirements&quot;&gt;requisitos de integridad de Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="211f03dbec01e5b6570f235c7176b37d2a2a79b5" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;shared_ptr&lt;/code&gt; meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; and are &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually convertible&lt;/a&gt; to &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Todas las especializaciones de &lt;code&gt;shared_ptr&lt;/code&gt; cumplen los requisitos de &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; y &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; y son &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextualmente convertibles&lt;/a&gt; en &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1031f9406b312c985a6ae796719a2a8d26efc31e" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::tuple_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">Todas las especializaciones de &lt;code&gt;std::tuple_size&lt;/code&gt; satisfacen &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; con</target>
        </trans-unit>
        <trans-unit id="743934d87daadcc6d9d31370a3db4d5504aa0fb9" translate="yes" xml:space="preserve">
          <source>All specializations of &lt;code&gt;std::variant_size&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">Todas las especializaciones de &lt;code&gt;std::variant_size&lt;/code&gt; satisfacen &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; con</target>
        </trans-unit>
        <trans-unit id="63c53895a6870cc913e144b2578bac2d714b260c" translate="yes" xml:space="preserve">
          <source>All standard containers (&lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;, etc.) value-initialize their elements when constructed with a single &lt;code&gt;size_type&lt;/code&gt; argument or when grown by a call to &lt;code&gt;resize()&lt;/code&gt;.</source>
          <target state="translated">Todos los contenedores est&amp;aacute;ndar ( &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt; , etc.) inicializan sus elementos con valor cuando se construyen con un solo argumento &lt;code&gt;size_type&lt;/code&gt; o cuando crecen mediante una llamada a &lt;code&gt;resize()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="358e40d1bfabb9461fdcb4d0a347855e7c412649" translate="yes" xml:space="preserve">
          <source>All standard library containers except &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; are AllocatorAwareContainers:</source>
          <target state="translated">Todos los contenedores de la biblioteca est&amp;aacute;ndar excepto &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; son AllocatorAwareContainers:</target>
        </trans-unit>
        <trans-unit id="ffcd9ca742b4542ddb772e7d60b22b2039e3de22" translate="yes" xml:space="preserve">
          <source>All temporary objects are destroyed as the last step in evaluating the full-expression that (lexically) contains the point where they were created, and if multiple temporary objects were created, they are destroyed in the order opposite to the order of creation. This is true even if that evaluation ends in throwing an exception.</source>
          <target state="translated">Todos los objetos temporales se destruyen como último paso para evaluar la expresión completa que (léxicamente)contiene el punto donde fueron creados,y si se crearon múltiples objetos temporales,se destruyen en el orden opuesto al orden de creación.Esto es cierto incluso si esa evaluación termina en lanzar una excepción.</target>
        </trans-unit>
        <trans-unit id="32f475507fbff7c599c3fd139abea98403ae6343" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions do not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">Todas estas funciones invocan &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; al menos una vez, el valor de &lt;code&gt;arg&lt;/code&gt; es indeterminado despu&amp;eacute;s del retorno. Estas funciones no invocan &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; , y la persona que llama debe hacerlo.</target>
        </trans-unit>
        <trans-unit id="176f5f0946a06ebe297b8c8ddf38982989abc5aa" translate="yes" xml:space="preserve">
          <source>All these functions invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; at least once, the value of &lt;code&gt;arg&lt;/code&gt; is indeterminate after the return. These functions to not invoke &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt;, and it must be done by the caller.</source>
          <target state="translated">Todas estas funciones invocan &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_arg&quot;&gt;va_arg&lt;/a&gt;&lt;/code&gt; al menos una vez, el valor de &lt;code&gt;arg&lt;/code&gt; es indeterminado despu&amp;eacute;s del retorno. Estas funciones no invocan &lt;code&gt;&lt;a href=&quot;../../utility/variadic/va_end&quot;&gt;va_end&lt;/a&gt;&lt;/code&gt; , y la persona que llama debe hacerlo.</target>
        </trans-unit>
        <trans-unit id="fe267d2b83e7299286bdf1b9c5aac0a7f499c7ed" translate="yes" xml:space="preserve">
          <source>All these functions invoke undefined behavior if &lt;code&gt;p&lt;/code&gt; is a null pointer.</source>
          <target state="translated">Todas estas funciones invocan un comportamiento indefinido si &lt;code&gt;p&lt;/code&gt; es un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="b0490d0cb63a327b1645f25c31bcc6482c7608ed" translate="yes" xml:space="preserve">
          <source>All these macro constants (except &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt;) expand to integer constant expressions that are distinct powers of 2, which uniquely identify all supported floating-point exceptions. Each macro is only defined if it is supported.</source>
          <target state="translated">Todas estas constantes macro (excepto &lt;code&gt;FE_ALL_EXCEPT&lt;/code&gt; ) se expanden a expresiones constantes enteras que son potencias distintas de 2, que identifican de manera &amp;uacute;nica todas las excepciones de punto flotante admitidas. Cada macro solo se define si es compatible.</target>
        </trans-unit>
        <trans-unit id="18f14072e9d32bbf324c49cf31c0caf2c548ae29" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt;</source>
          <target state="translated">Las tres sobrecargas devuelven efectivamente &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).ends_with(x);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ae0f95f4fd5fb1e59f705f02f6b13547bc8d638" translate="yes" xml:space="preserve">
          <source>All three overloads effectively return &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt;</source>
          <target state="translated">Las tres sobrecargas devuelven efectivamente &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;(data(), size()).starts_with(x);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41dbcf1025fbada0bb806a90ae80be55d2ccdbc3" translate="yes" xml:space="preserve">
          <source>All uniform random bit generators meet the &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; requirements. C++20 also defines a &lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt;&lt;code&gt;UniformRandomBitGenerator&lt;/code&gt;&lt;/a&gt; concept.</source>
          <target state="translated">Todos los generadores de bits aleatorios uniformes cumplen los requisitos &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; . C ++ 20 tambi&amp;eacute;n define un concepto &lt;a href=&quot;random/uniformrandombitgenerator&quot;&gt; &lt;code&gt;UniformRandomBitGenerator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8d23b28c0c5980cc7718a01e280ed03d0685c95f" translate="yes" xml:space="preserve">
          <source>All users have read, write, and execute/search permissions</source>
          <target state="translated">Todos los usuarios tienen permisos de lectura,escritura y ejecución/búsqueda</target>
        </trans-unit>
        <trans-unit id="a57778f1822ccdd378e7db95391c602549921f33" translate="yes" xml:space="preserve">
          <source>All valid permission bits.</source>
          <target state="translated">Todos los bits de permiso válidos.</target>
        </trans-unit>
        <trans-unit id="49247714c9e6a1264921f2f7061610f5ebfc233f" translate="yes" xml:space="preserve">
          <source>All values are required to be unique except that the values of &lt;code&gt;EOPNOTSUPP&lt;/code&gt; and &lt;code&gt;ENOTSUP&lt;/code&gt; may be identical and the values of &lt;code&gt;EAGAIN&lt;/code&gt; and &lt;code&gt;EWOULDBLOCK&lt;/code&gt; may be identical.</source>
          <target state="translated">Se requiere que todos los valores sean &amp;uacute;nicos, excepto que los valores de &lt;code&gt;EOPNOTSUPP&lt;/code&gt; y &lt;code&gt;ENOTSUP&lt;/code&gt; pueden ser id&amp;eacute;nticos y los valores de &lt;code&gt;EAGAIN&lt;/code&gt; y &lt;code&gt;EWOULDBLOCK&lt;/code&gt; pueden ser id&amp;eacute;nticos.</target>
        </trans-unit>
        <trans-unit id="9c56cddca11b01528f10a9f07f26dc5bec9d8e2f" translate="yes" xml:space="preserve">
          <source>All versions behave as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions&lt;/a&gt;. After constructing and checking the sentry object, these functions perform the following:</source>
          <target state="translated">Todas las versiones se comportan como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunctions&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, estas funciones realizan lo siguiente:</target>
        </trans-unit>
        <trans-unit id="fe817f9833c1ccda48652b1e96a5f243b7b8c465" translate="yes" xml:space="preserve">
          <source>All versions set the value of &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; to the number of characters extracted.</source>
          <target state="translated">Todas las versiones establecen el valor de &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; en el n&amp;uacute;mero de caracteres extra&amp;iacute;dos.</target>
        </trans-unit>
        <trans-unit id="7c49bcb1867689918b55a1779cbc5e6907f7117d" translate="yes" xml:space="preserve">
          <source>All virtual base subobjects are initialized before any non-virtual base subobject, so only the most derived class calls the constructors of the virtual bases in its &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt;:</source>
          <target state="translated">Todos los subobjetos de base virtual se inicializan antes que cualquier subobjeto de base no virtual, por lo que solo la clase m&amp;aacute;s derivada llama a los constructores de las bases virtuales en su &lt;a href=&quot;constructor&quot;&gt;lista de inicializadores miembros&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7b8e5641e2d8cbf1a2bdfdaf4f5a52ae7c538b20" translate="yes" xml:space="preserve">
          <source>Allocate &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage whose alignment is specified by &lt;code&gt;alignment&lt;/code&gt;. The &lt;code&gt;size&lt;/code&gt; parameter must be an integral multiple of &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">Asigne bytes de &lt;code&gt;size&lt;/code&gt; de almacenamiento no inicializado cuya alineaci&amp;oacute;n se especifica por &lt;code&gt;alignment&lt;/code&gt; . El par&amp;aacute;metro de &lt;code&gt;size&lt;/code&gt; debe ser un m&amp;uacute;ltiplo integral de &lt;code&gt;alignment&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3713458c26ce42a8beb1ed61bfb66555a6fd00bb" translate="yes" xml:space="preserve">
          <source>Allocate memory</source>
          <target state="translated">Asignar la memoria</target>
        </trans-unit>
        <trans-unit id="c69536036834933fadf93bcfad2311dd91d4b772" translate="yes" xml:space="preserve">
          <source>Allocate raw aligned memory from the underlying resource</source>
          <target state="translated">Asignar la memoria alineada bruta del recurso subyacente</target>
        </trans-unit>
        <trans-unit id="8c90ccd007d394557e735c7fe5d3753ec43eedf6" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;n * sizeof(T)&lt;/code&gt; bytes of uninitialized storage by calling &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt;or &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt;(since C++17), but it is unspecified when and how this function is called. The pointer &lt;code&gt;hint&lt;/code&gt; may be used to provide locality of reference: the allocator, if supported by the implementation, will attempt to allocate the new memory block as close as possible to &lt;code&gt;hint&lt;/code&gt;.</source>
          <target state="translated">Asigna &lt;code&gt;n * sizeof(T)&lt;/code&gt; bytes de almacenamiento no inicializado llamando a &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;)&lt;/code&gt; u &lt;code&gt;::&lt;a href=&quot;../new/operator_new&quot;&gt;operator new&lt;/a&gt;(&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt; (desde C ++ 17), pero es sin especificar cu&amp;aacute;ndo y c&amp;oacute;mo se llama esta funci&amp;oacute;n. La &lt;code&gt;hint&lt;/code&gt; puntero se puede utilizar para proporcionar la localidad de referencia: el asignador, si es compatible con la implementaci&amp;oacute;n, intentar&amp;aacute; asignar el nuevo bloque de memoria lo m&amp;aacute;s cerca posible de la &lt;code&gt;hint&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e4fd50aabe78c29ec16f5fd9d57b662c1d7d801a" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;nbytes&lt;/code&gt; bytes of storage at specified alignment &lt;code&gt;alignment&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</source>
          <target state="translated">Asigna &lt;code&gt;nbytes&lt;/code&gt; bytes de almacenamiento a alineaci&amp;oacute;n especificada &lt;code&gt;alignment&lt;/code&gt; utilizando el recurso de memoria subyacente. Equivalente a &lt;code&gt;return resource()-&amp;gt;allocate(nbytes, alignment);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="575bf26e9df794dbd1383b334ef663788e920b7e" translate="yes" xml:space="preserve">
          <source>Allocates &lt;code&gt;size&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">Asigna bytes de &lt;code&gt;size&lt;/code&gt; de almacenamiento no inicializado.</target>
        </trans-unit>
        <trans-unit id="deda37c663ffd540f8cba4cf2e2cde12e85c7e4b" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object</source>
          <target state="translated">Asigna y construye un objeto</target>
        </trans-unit>
        <trans-unit id="37d6f4ac7e329233b5c6cfd53ae16c6539bab6fd" translate="yes" xml:space="preserve">
          <source>Allocates and constructs an object of type &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Asigna y construye un objeto de tipo &lt;code&gt;U&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eec2cf410629d96a9a943a9c58f28ac54a41b535" translate="yes" xml:space="preserve">
          <source>Allocates memory for an array of &lt;code&gt;num&lt;/code&gt; objects of size &lt;code&gt;size&lt;/code&gt; and initializes it to all bits zero.</source>
          <target state="translated">Asigna memoria para una matriz de objetos &lt;code&gt;num&lt;/code&gt; &amp;eacute;ricos de tama&amp;ntilde;o &lt;code&gt;size&lt;/code&gt; e inicializa a todos los bits cero.</target>
        </trans-unit>
        <trans-unit id="9d033c92aaed0cd6d702cbb7cedf1b4eeff6647d" translate="yes" xml:space="preserve">
          <source>Allocates raw memory suitable for an object or an array</source>
          <target state="translated">Asigna la memoria en bruto adecuada para un objeto o una matriz</target>
        </trans-unit>
        <trans-unit id="cf91bb95384027fe5328e00c00aaeaa013321358" translate="yes" xml:space="preserve">
          <source>Allocates requested number of bytes. These allocation functions are called by &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate memory in which new object would then be initialized. They may also be called using regular function call syntax.</source>
          <target state="translated">Asigna el n&amp;uacute;mero de bytes solicitado. Estas funciones de asignaci&amp;oacute;n son llamadas por &lt;a href=&quot;../../language/new&quot;&gt;nuevas expresiones&lt;/a&gt; para asignar memoria en la cual se inicializar&amp;iacute;a un nuevo objeto. Tambi&amp;eacute;n pueden llamarse utilizando la sintaxis de llamada de funci&amp;oacute;n regular.</target>
        </trans-unit>
        <trans-unit id="d2fc2b0dfd842a7e3a00d1f42dd3c72c9a40aeb4" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;T&lt;/code&gt; using the underlying memory resource. Equivalent to &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt;.</source>
          <target state="translated">Asigna almacenamiento para &lt;code&gt;n&lt;/code&gt; objetos de tipo &lt;code&gt;T&lt;/code&gt; utilizando el recurso de memoria subyacente. Equivalente a &lt;code&gt;return static_cast&amp;lt;T*&amp;gt;(resource()-&amp;gt;allocate(n * sizeof(T), alignof(T)));&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef1e5d4c9fecdb8c77f2367b414e8a2ebe079e5f" translate="yes" xml:space="preserve">
          <source>Allocates storage for &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;U&lt;/code&gt; using the underlying memory resource.</source>
          <target state="translated">Asigna almacenamiento para &lt;code&gt;n&lt;/code&gt; objetos de tipo &lt;code&gt;U&lt;/code&gt; utilizando el recurso de memoria subyacente.</target>
        </trans-unit>
        <trans-unit id="c8d51dfb7cc15d733b905081816cec434af6b924" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes, aligned to the specified &lt;code&gt;alignment&lt;/code&gt;.</source>
          <target state="translated">Asigna almacenamiento con un tama&amp;ntilde;o de al menos &lt;code&gt;bytes&lt;/code&gt; bytes, alineado con la &lt;code&gt;alignment&lt;/code&gt; especificada .</target>
        </trans-unit>
        <trans-unit id="1719b83d89f242ab75b869949fb55eef6c5d0e25" translate="yes" xml:space="preserve">
          <source>Allocates storage with a size of at least &lt;code&gt;bytes&lt;/code&gt; bytes. The returned storage is aligned to the specified &lt;code&gt;alignment&lt;/code&gt; if such alignment is supported, and to &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; otherwise.</source>
          <target state="translated">Asigna almacenamiento con un tama&amp;ntilde;o de al menos &lt;code&gt;bytes&lt;/code&gt; bytes. El almacenamiento devuelto se alinea con la &lt;code&gt;alignment&lt;/code&gt; especificada si dicha alineaci&amp;oacute;n es compatible, y para &lt;code&gt;alignof(&lt;a href=&quot;../../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="5fa0c7f2ed7e5ab17575514af95c1b4726f6491b" translate="yes" xml:space="preserve">
          <source>Allocates storage.</source>
          <target state="translated">Asigna el almacenamiento.</target>
        </trans-unit>
        <trans-unit id="a4cd37a2b2f79389364650460bd02f87e623f6b0" translate="yes" xml:space="preserve">
          <source>Allocates uninitialized contiguous storage, which should be sufficient to store up to &lt;code&gt;count&lt;/code&gt; adjacent objects of type &lt;code&gt;T&lt;/code&gt;. The request is non-binding and the implementation may allocate less or more than necessary to store &lt;code&gt;count&lt;/code&gt; adjacent objects.</source>
          <target state="translated">Asigna sin inicializar almacenamiento contiguo, que deber&amp;iacute;a ser suficiente para almacenar hasta &lt;code&gt;count&lt;/code&gt; objetos adyacentes de tipo &lt;code&gt;T&lt;/code&gt; . La solicitud no es vinculante y la implementaci&amp;oacute;n puede asignar menos o m&amp;aacute;s de lo necesario para almacenar el &lt;code&gt;count&lt;/code&gt; objetos adyacentes.</target>
        </trans-unit>
        <trans-unit id="1b5c021aee14bea734803bc4262d3ac794a7f664" translate="yes" xml:space="preserve">
          <source>Allocation</source>
          <target state="translated">Allocation</target>
        </trans-unit>
        <trans-unit id="7e5a93aa2050aa67c4b2a8fa0227ec2d570a5f78" translate="yes" xml:space="preserve">
          <source>Allocation functions</source>
          <target state="translated">Funciones de asignación</target>
        </trans-unit>
        <trans-unit id="bcdc03b4788456846d38f2b2c7a10637d4ba865e" translate="yes" xml:space="preserve">
          <source>Allocations requests that exceed the largest block size are served from the</source>
          <target state="translated">Las solicitudes de asignación que exceden el tamaño del bloque más grande son atendidas desde el</target>
        </trans-unit>
        <trans-unit id="cbf9e75065cafb419b19fb5a13dddefb2735eaa6" translate="yes" xml:space="preserve">
          <source>Allocator</source>
          <target state="translated">Allocator</target>
        </trans-unit>
        <trans-unit id="c26087d42681b7f6e496369e9c820f3e757778ab" translate="yes" xml:space="preserve">
          <source>Allocator completeness requirements</source>
          <target state="translated">Requisitos de integridad del asignador</target>
        </trans-unit>
        <trans-unit id="006db541d4a947093a399166c59d14c227c66a14" translate="yes" xml:space="preserve">
          <source>Allocator for &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">Asignador para &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a14116cd7defc5cfe1008ae088831e83125981b1" translate="yes" xml:space="preserve">
          <source>Allocator of a type convertible to &lt;code&gt;A&lt;/code&gt;</source>
          <target state="translated">Asignador de un tipo convertible a &lt;code&gt;A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71d3d89dd86b8060b5c2c3dff2ad831f3f7d33f4" translate="yes" xml:space="preserve">
          <source>Allocator type</source>
          <target state="translated">Tipo de asignador</target>
        </trans-unit>
        <trans-unit id="c5e06a85490c85e6350aa5bd28390e1ead65f231" translate="yes" xml:space="preserve">
          <source>Allocator-aware containers always call &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; to construct an object of type &lt;code&gt;A&lt;/code&gt; at &lt;code&gt;p&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt;, with &lt;code&gt;m == get_allocator()&lt;/code&gt;. The default &lt;code&gt;construct&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt;, but specialized allocators may choose a different definition.</source>
          <target state="translated">Los contenedores con &lt;code&gt;m == get_allocator()&lt;/code&gt; siempre llaman a &lt;code&gt;&lt;a href=&quot;../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A&amp;gt;::construct(m, p, args)&lt;/code&gt; para construir un objeto de tipo &lt;code&gt;A&lt;/code&gt; en &lt;code&gt;p&lt;/code&gt; usando &lt;code&gt;args&lt;/code&gt; , con m == get_allocator () . La &lt;code&gt;construct&lt;/code&gt; predeterminada en &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; llama &lt;code&gt;::new((void*)p) T(args)&lt;/code&gt; , pero los asignadores especializados pueden elegir una definici&amp;oacute;n diferente.</target>
        </trans-unit>
        <trans-unit id="34acd9339509e4e1e31704ab4c073ecbdafd1f25" translate="yes" xml:space="preserve">
          <source>AllocatorAwareContainer</source>
          <target state="translated">AllocatorAwareContainer</target>
        </trans-unit>
        <trans-unit id="5ceb7c7c9f3657e9513254564292abfe012cfefb" translate="yes" xml:space="preserve">
          <source>Allocators</source>
          <target state="translated">Allocators</target>
        </trans-unit>
        <trans-unit id="629f37bb798c36a67317aa9ec0378bd852ec9f11" translate="yes" xml:space="preserve">
          <source>Allocators are class templates encapsulating memory allocation strategy. This allows generic containers to decouple memory management from the data itself.</source>
          <target state="translated">Los asignadores son plantillas de clase que encapsulan la estrategia de asignación de memoria.Esto permite que los contenedores genéricos desacoplen la gestión de la memoria de los propios datos.</target>
        </trans-unit>
        <trans-unit id="095c1a8ff16049f04c3471ba9a37d8292cb9648d" translate="yes" xml:space="preserve">
          <source>Allow constant evaluation for all &lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;non-type template arguments&lt;/a&gt;</source>
          <target state="translated">Permitir evaluaci&amp;oacute;n constante para todos &lt;a href=&quot;language/template_parameters#Template_non-type_arguments&quot;&gt;los argumentos de plantilla sin tipo&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8672315bab526e017a0da6b4db8394d5643bd21c" translate="yes" xml:space="preserve">
          <source>Allow the compiler to optimize for the case where paths of execution including that statement are more or less likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">Permitir que el compilador optimice para el caso en que las vías de ejecución que incluyan esa declaración sean más o menos probables que cualquier otra vía de ejecución que no incluya dicha declaración.</target>
        </trans-unit>
        <trans-unit id="03388373add47a2fa22bbeb6dede9123b781ba3f" translate="yes" xml:space="preserve">
          <source>Allows a function to accept any number of arguments.</source>
          <target state="translated">Permite que una función acepte cualquier número de argumentos.</target>
        </trans-unit>
        <trans-unit id="411787b050d38051721728f3a87d5174918b5c69" translate="yes" xml:space="preserve">
          <source>Allows a function to be called without providing one or more trailing arguments.</source>
          <target state="translated">Permite llamar una función sin proporcionar uno o más argumentos de seguimiento.</target>
        </trans-unit>
        <trans-unit id="459d9517d5603efba94121b4d2acec3f8491a657" translate="yes" xml:space="preserve">
          <source>Allows any and all code transformations that do not change the observable behavior of the program.</source>
          <target state="translated">Permite todas y cada una de las transformaciones de código que no cambian el comportamiento observable del programa.</target>
        </trans-unit>
        <trans-unit id="f7fd47c92a72794dea3d8bd7149aab52470581d7" translate="yes" xml:space="preserve">
          <source>Allows customizing class and variable(since C++14) templates for a given category of template arguments.</source>
          <target state="translated">Permite personalizar las plantillas de clases y variables (desde C++14)para una categoría dada de argumentos de plantillas.</target>
        </trans-unit>
        <trans-unit id="36e28bc484be80710ded433fdd6ceb2b32b730fd" translate="yes" xml:space="preserve">
          <source>Allows customizing the template code for a given set of template arguments.</source>
          <target state="translated">Permite personalizar el código de la plantilla para un determinado conjunto de argumentos de la plantilla.</target>
        </trans-unit>
        <trans-unit id="a8bf676764b0183a61de1aa7f44f4c55b945bd3c" translate="yes" xml:space="preserve">
          <source>Allows insertion and extraction of quoted strings, such as the ones found in CSV or XML.</source>
          <target state="translated">Permite la inserción y extracción de cadenas citadas,como las que se encuentran en CSV o XML.</target>
        </trans-unit>
        <trans-unit id="1433f306e640197740511f48680f25d7413dc2e9" translate="yes" xml:space="preserve">
          <source>Allows integer, floating-point, character, and string literals to produce objects of user-defined type by defining a user-defined suffix.</source>
          <target state="translated">Permite que los enteros,los puntos flotantes,los caracteres y los literales de las cadenas produzcan objetos de tipo definido por el usuario mediante la definición de un sufijo definido por el usuario.</target>
        </trans-unit>
        <trans-unit id="714a3428d46162788e491e8dc3208e88274f1f2f" translate="yes" xml:space="preserve">
          <source>Allows the size of an empty base subobject to be zero.</source>
          <target state="translated">Permite que el tamaño de un subobjeto de base vacío sea cero.</target>
        </trans-unit>
        <trans-unit id="ccb54e9be1a4c6bc9837fefd7cc02f1997a12f3c" translate="yes" xml:space="preserve">
          <source>Allows values of integer type to be used in expressions directly.</source>
          <target state="translated">Permite que los valores de tipo entero se utilicen directamente en las expresiones.</target>
        </trans-unit>
        <trans-unit id="9a0c4d0005f924626f07462db95d58f6067b54a8" translate="yes" xml:space="preserve">
          <source>Also because braced-init-list has no type, &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;special rules for overload resolution&lt;/a&gt; apply when it is used as an argument to an overloaded function call.</source>
          <target state="translated">Adem&amp;aacute;s, debido a que braced-init-list no tiene tipo, se &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;aplican reglas especiales para la resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; cuando se usa como argumento para una llamada de funci&amp;oacute;n sobrecargada.</target>
        </trans-unit>
        <trans-unit id="3b587e48dc1be81684dc5d496c6af85f6a461578" translate="yes" xml:space="preserve">
          <source>Also provided are the C-style date and time functions, such as &lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Tambi&amp;eacute;n se proporcionan las funciones de fecha y hora de estilo C, como &lt;code&gt;&lt;a href=&quot;chrono/c/time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;chrono/c/difftime&quot;&gt;std::difftime&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;chrono/c/clocks_per_sec&quot;&gt;CLOCKS_PER_SEC&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="729da59cb6e707c89f461faec986a483c428299a" translate="yes" xml:space="preserve">
          <source>Also, all &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; that contain a double underscore __ in any position and each identifier that begins with an underscore followed by an uppercase letter is always reserved and all identifiers that begin with an underscore are reserved for use as names in the global namespace. See &lt;a href=&quot;language/name&quot;&gt;identifiers&lt;/a&gt; for more details.</source>
          <target state="translated">Adem&amp;aacute;s, todos los &lt;a href=&quot;language/name&quot;&gt;identificadores&lt;/a&gt; que contienen un gui&amp;oacute;n bajo doble __ en cualquier posici&amp;oacute;n y cada identificador que comienza con un gui&amp;oacute;n bajo seguido de una letra may&amp;uacute;scula siempre est&amp;aacute;n reservados y todos los identificadores que comienzan con un gui&amp;oacute;n bajo est&amp;aacute;n reservados para su uso como nombres en el espacio de nombres global. Ver &lt;a href=&quot;language/name&quot;&gt;identificadores&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="8790a9cbd433decb4fdf7491221b8bbc56822f99" translate="yes" xml:space="preserve">
          <source>Also, on some platforms, bit fields are packed left-to-right, on others right-to-left</source>
          <target state="translated">Además,en algunas plataformas,los campos de bits están empaquetados de izquierda a derecha,en otras de derecha a izquierda</target>
        </trans-unit>
        <trans-unit id="5b07b0bdeb35442e306edb6a6d7347901e47e660" translate="yes" xml:space="preserve">
          <source>Also, the standard library functions called with xvalue arguments may assume the argument is the only reference to the object; if it was constructed from an lvalue with &lt;code&gt;std::move&lt;/code&gt;, no aliasing checks are made. In particular, this means that standard library move assignment operators do not have to perform self-assignment checks:</source>
          <target state="translated">Adem&amp;aacute;s, las funciones de biblioteca est&amp;aacute;ndar llamadas con argumentos xvalue pueden asumir que el argumento es la &amp;uacute;nica referencia al objeto; si se construy&amp;oacute; a partir de un valor l con &lt;code&gt;std::move&lt;/code&gt; , no se realizan comprobaciones de alias. En particular, esto significa que los operadores de asignaci&amp;oacute;n de movimiento de biblioteca est&amp;aacute;ndar no tienen que realizar comprobaciones de autoasignaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="9465911da185e318d4f902c965db53e7bdd827fb" translate="yes" xml:space="preserve">
          <source>Also, unlike the formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; on failure.</source>
          <target state="translated">Adem&amp;aacute;s, a diferencia de las funciones de salida formateadas, esta funci&amp;oacute;n no establece el &lt;code&gt;failbit&lt;/code&gt; de falla en caso de falla.</target>
        </trans-unit>
        <trans-unit id="3b74e96e489cf616e54374e5e92ff3290101f441" translate="yes" xml:space="preserve">
          <source>Alternative</source>
          <target state="translated">Alternative</target>
        </trans-unit>
        <trans-unit id="2e4d959d6a71905b14d43661b5387037b9b586bd" translate="yes" xml:space="preserve">
          <source>Alternative operator representations</source>
          <target state="translated">Representaciones de operadores alternativos</target>
        </trans-unit>
        <trans-unit id="c8b93e0cfffeb74171554b62200f1f073639dd68" translate="yes" xml:space="preserve">
          <source>Alternative operator syntax</source>
          <target state="translated">Sintaxis de operador alternativo</target>
        </trans-unit>
        <trans-unit id="e32467443dfa96c0777ac9526ba4d4884bea25fb" translate="yes" xml:space="preserve">
          <source>Alternative tokens</source>
          <target state="translated">Fichas alternativas</target>
        </trans-unit>
        <trans-unit id="3a4be7155bcffba0850c80a370bc5c6b34c37e74" translate="yes" xml:space="preserve">
          <source>Alternatives</source>
          <target state="translated">Alternatives</target>
        </trans-unit>
        <trans-unit id="f33a42489881f94fe215353e72be54816924c644" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; may sometimes be used to detect stack unwinding in progress, it is generally considered bad practice to allow any destructor to terminate by throwing an exception. This functionality is nevertheless used by some libraries, such as &lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt; and &lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt;, which rely on the ability of the destructors of nameless temporaries to throw exceptions at the end of the full expression that constructs the temporary.</source>
          <target state="translated">Aunque &lt;code&gt;&lt;a href=&quot;../error/exception/uncaught_exception&quot;&gt;std::uncaught_exception&lt;/a&gt;&lt;/code&gt; veces se puede usar para detectar el desbobinado de la pila en progreso, generalmente se considera una mala pr&amp;aacute;ctica permitir que cualquier destructor termine lanzando una excepci&amp;oacute;n. Sin embargo, esta funcionalidad es utilizada por algunas bibliotecas, como &lt;a href=&quot;https://github.com/SOCI/soci&quot;&gt;SOCI&lt;/a&gt; y &lt;a href=&quot;http://galeracluster.com/downloads/&quot;&gt;Galera 3&lt;/a&gt; , que se basan en la capacidad de los destructores de temporarios sin nombre para lanzar excepciones al final de la expresi&amp;oacute;n completa que construye lo temporal.</target>
        </trans-unit>
        <trans-unit id="ea2b684e4b095592200988c7ab99debb5b70a888" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::pow&lt;/code&gt; cannot be used to obtain a root of a negative number, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; is provided for the common case where &lt;code&gt;exp&lt;/code&gt; is 1/3.</source>
          <target state="translated">Aunque &lt;code&gt;std::pow&lt;/code&gt; no puede usarse para obtener una ra&amp;iacute;z de un n&amp;uacute;mero negativo, &lt;code&gt;&lt;a href=&quot;cbrt&quot;&gt;std::cbrt&lt;/a&gt;&lt;/code&gt; se proporciona para el caso com&amp;uacute;n donde &lt;code&gt;exp&lt;/code&gt; es 1/3.</target>
        </trans-unit>
        <trans-unit id="b0bbe9c54239a7325e443792536d8b4342054835" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::scalbn&lt;/code&gt; and &lt;code&gt;std::scalbln&lt;/code&gt; are specified to perform the operation efficiently, on many implementations they are less efficient than multiplication or division by a power of two using arithmetic operators.</source>
          <target state="translated">Aunque &lt;code&gt;std::scalbn&lt;/code&gt; y &lt;code&gt;std::scalbln&lt;/code&gt; est&amp;aacute;n especificados para realizar la operaci&amp;oacute;n de manera eficiente, en muchas implementaciones son menos eficientes que la multiplicaci&amp;oacute;n o divisi&amp;oacute;n por una potencia de dos usando operadores aritm&amp;eacute;ticos.</target>
        </trans-unit>
        <trans-unit id="3d1825778acdae18596af041fff74b7b10c86289" translate="yes" xml:space="preserve">
          <source>Although &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; with the default deleter may be constructed with &lt;a href=&quot;../../language/incomplete_type&quot;&gt;incomplete type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;, the type &lt;code&gt;T&lt;/code&gt; must be complete at the point of code where the destructor is called.</source>
          <target state="translated">Aunque &lt;code&gt;std::unique_ptr&amp;lt;T&amp;gt;&lt;/code&gt; con el borrador predeterminado puede construirse con &lt;a href=&quot;../../language/incomplete_type&quot;&gt;un tipo &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; incompleto , el tipo &lt;code&gt;T&lt;/code&gt; debe estar completo en el punto de c&amp;oacute;digo donde se llama al destructor.</target>
        </trans-unit>
        <trans-unit id="439c84aa6d4f184555f03b26b3fb02df31f3c81c" translate="yes" xml:space="preserve">
          <source>Although a function call can be resolved through ADL even if ordinary lookup finds nothing, a function call to a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; with explicitly-specified template arguments requires that there is a declaration of the template found by ordinary lookup (otherwise, it is a syntax error to encounter an unknown name followed by a less-than character).</source>
          <target state="translated">Aunque una llamada de funci&amp;oacute;n puede resolverse a trav&amp;eacute;s de ADL incluso si la b&amp;uacute;squeda ordinaria no encuentra nada, una llamada de funci&amp;oacute;n a una &lt;a href=&quot;function_template&quot;&gt;plantilla de funci&amp;oacute;n&lt;/a&gt; con argumentos de plantilla especificados expl&amp;iacute;citamente requiere que haya una declaraci&amp;oacute;n de la plantilla encontrada por la b&amp;uacute;squeda ordinaria (de lo contrario, es un error de sintaxis encontrar un nombre desconocido seguido de un car&amp;aacute;cter menor que).</target>
        </trans-unit>
        <trans-unit id="f1ebb0e824901f4ec3f02ea57f64d9e4828306f2" translate="yes" xml:space="preserve">
          <source>Although a zero-initialized &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; always represents the initial conversion state, there may be other values of &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; that also represent the initial conversion state.</source>
          <target state="translated">Aunque un &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; inicializaci&amp;oacute;n cero siempre representa el estado de conversi&amp;oacute;n inicial, puede haber otros valores de &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; que tambi&amp;eacute;n representen el estado de conversi&amp;oacute;n inicial.</target>
        </trans-unit>
        <trans-unit id="f708528328b72807fc0654354970ef41ee70cd4b" translate="yes" xml:space="preserve">
          <source>Although arrays cannot be returned from functions by value and cannot be targets of most cast expressions, array &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt; may be formed by using a type alias to construct an array temporary using &lt;a href=&quot;explicit_cast&quot;&gt;brace-initialized functional cast&lt;/a&gt;.</source>
          <target state="translated">Aunque las matrices no pueden devolverse de las funciones por valor y no pueden ser objetivos de la mayor&amp;iacute;a de las expresiones de &lt;a href=&quot;value_category&quot;&gt;conversi&amp;oacute;n&lt;/a&gt; , los valores de matriz pueden formarse utilizando un alias de tipo para construir una matriz temporal utilizando la &lt;a href=&quot;explicit_cast&quot;&gt;conversi&amp;oacute;n funcional inicializada con llaves&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1fd9b3c6d07c5655b399e6be4424fee0edae9357" translate="yes" xml:space="preserve">
          <source>Although canonical form of pre-increment/pre-decrement returns a reference, as with any operator overload, the return type is user-defined; for example the overloads of these operators for &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; return by value.</source>
          <target state="translated">Aunque la forma can&amp;oacute;nica de pre-incremento / pre-decremento devuelve una referencia, como con cualquier sobrecarga del operador, el tipo de retorno es definido por el usuario; por ejemplo, las sobrecargas de estos operadores para &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; return by value.</target>
        </trans-unit>
        <trans-unit id="2de2491baa0eb4945c698a40f7cf02c5b5ff7ca9" translate="yes" xml:space="preserve">
          <source>Although decl-specifier-seq implies there can exist &lt;a href=&quot;declarations#Specifiers&quot;&gt;specifiers&lt;/a&gt; other than type specifiers, the only other specifier allowed is &lt;code&gt;register&lt;/code&gt;as well as &lt;code&gt;auto&lt;/code&gt;(until C++11), and it has no effect.</source>
          <target state="translated">Aunque decl-specifier-seq implica que pueden existir &lt;a href=&quot;declarations#Specifiers&quot;&gt;especificadores que&lt;/a&gt; no sean de tipo, el &amp;uacute;nico otro especificador permitido es tanto el &lt;code&gt;register&lt;/code&gt; como el &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tico (hasta C ++ 11), y no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="14b7b14235553f3b91083c0b71081ba75f07e98f" translate="yes" xml:space="preserve">
          <source>Although no class is its own base, &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; is true because the intent of the trait is to model the &quot;is-a&quot; relationship, and T is a T. Despite that, &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; is false because only classes participate in the relationship that this trait models.</source>
          <target state="translated">Aunque ninguna clase es su propia base, &lt;code&gt;std::is_base_of&amp;lt;T, T&amp;gt;::value&lt;/code&gt; es verdadero porque la intenci&amp;oacute;n del rasgo es modelar la relaci&amp;oacute;n &quot;es-a&quot;, y T es una T. A pesar de eso, &lt;code&gt;std::is_base_of&amp;lt;int, int&amp;gt;::value&lt;/code&gt; es falso porque solo las clases participan en la relaci&amp;oacute;n que modela este rasgo.</target>
        </trans-unit>
        <trans-unit id="119fa9e7db8c27df8ae932b0248b04e4bfefb226" translate="yes" xml:space="preserve">
          <source>Although not defined, this is almost always an integral value holding the number of seconds (not counting leap seconds) since 00:00, Jan 1 1970 UTC, corresponding to &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt; POSIX time&lt;/a&gt;.</source>
          <target state="translated">Aunque no est&amp;aacute; definido, este es casi siempre un valor integral que contiene el n&amp;uacute;mero de segundos (sin contar los segundos bisiestos) desde las 00:00, 1 de enero de 1970 UTC, correspondiente al &lt;a href=&quot;https://en.wikipedia.org/wiki/Unix_time&quot;&gt;tiempo POSIX&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ac8975eb41b5df62d74c9b6ae1a1689383a4d797" translate="yes" xml:space="preserve">
          <source>Although references, once initialized, always refer to valid objects or functions, it is possible to create a program where the &lt;a href=&quot;lifetime&quot;&gt;lifetime&lt;/a&gt; of the referred-to object ends, but the reference remains accessible (</source>
          <target state="translated">Aunque las referencias, una vez inicializadas, siempre se refieren a objetos o funciones v&amp;aacute;lidos, es posible crear un programa donde finaliza la &lt;a href=&quot;lifetime&quot;&gt;vida &amp;uacute;til&lt;/a&gt; del objeto mencionado, pero la referencia permanece accesible (</target>
        </trans-unit>
        <trans-unit id="6c367e67cfae5a3c20e167ab56108c7704f6c4ad" translate="yes" xml:space="preserve">
          <source>Although synchronized blocks execute as-if under a global lock, the implementations are expected to examine the code within each block and use optimistic concurrency (backed up by hardware transactional memory where available) for transaction-safe code and minimal locking for non-transaction safe code. When a synchronized block makes a call to a non-inlined function, the compiler may have to drop out of speculative execution and hold a lock around the entire call unless the function is declared &lt;code&gt;transaction_safe&lt;/code&gt; (see below) or the attribute &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; (see below) is used.</source>
          <target state="translated">Aunque los bloques sincronizados se ejecutan como si estuvieran bajo un bloqueo global, se espera que las implementaciones examinen el c&amp;oacute;digo dentro de cada bloque y usen la concurrencia optimista (respaldada por la memoria transaccional de hardware donde est&amp;eacute; disponible) para el c&amp;oacute;digo seguro de la transacci&amp;oacute;n y el bloqueo m&amp;iacute;nimo para la no-transacci&amp;oacute;n segura c&amp;oacute;digo. Cuando un bloque sincronizado realiza una llamada a una funci&amp;oacute;n no en l&amp;iacute;nea, el compilador puede tener que abandonar la ejecuci&amp;oacute;n especulativa y mantener un bloqueo alrededor de toda la llamada a menos que la funci&amp;oacute;n sea declarada como &lt;code&gt;transaction_safe&lt;/code&gt; (ver a continuaci&amp;oacute;n) o el atributo &lt;code&gt;[[optimize_for_synchronized]]&lt;/code&gt; (ver abajo) se utiliza.</target>
        </trans-unit>
        <trans-unit id="dad5173c2001f38e75509fd69dc64ba3e87866b3" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic cosine&quot; (used by POSIX) or &quot;area hyperbolic cosine&quot;.</source>
          <target state="translated">Aunque la norma C (a la que C++se refiere para esta función)denomina a esta función &quot;arco del coseno hiperbólico&quot;,las funciones inversas de las funciones hiperbólicas son las funciones de área.Su argumento es el área de un sector hiperbólico,no un arco.El nombre correcto es &quot;coseno hiperbólico inverso&quot; (usado por POSIX)o &quot;área coseno hiperbólico&quot;.</target>
        </trans-unit>
        <trans-unit id="a1733c8cc2a0d050132b6b9364d6944323c32b74" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic sine&quot; (used by POSIX) or &quot;area hyperbolic sine&quot;.</source>
          <target state="translated">Aunque la norma C (a la que C++se refiere para esta función)denomina a esta función &quot;arco hiperbólico sinusoidal&quot;,las funciones inversas de las funciones hiperbólicas son las funciones de área.Su argumento es el área de un sector hiperbólico,no un arco.El nombre correcto es &quot;seno hiperbólico inverso&quot; (usado por POSIX)o &quot;área hiperbólica sinusoidal&quot;.</target>
        </trans-unit>
        <trans-unit id="4277fd8c5f429dde16accb19c538a3e9d0e882ce" translate="yes" xml:space="preserve">
          <source>Although the C standard (to which C++ refers for this function) names this function &quot;arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;inverse hyperbolic tangent&quot; (used by POSIX) or &quot;area hyperbolic tangent&quot;.</source>
          <target state="translated">Aunque la norma C (a la que C++se refiere para esta función)denomina a esta función &quot;arco hiperbólico tangente&quot;,las funciones inversas de las funciones hiperbólicas son las funciones de área.Su argumento es el área de un sector hiperbólico,no un arco.El nombre correcto es &quot;tangente hiperbólica inversa&quot; (utilizado por POSIX)o &quot;área hiperbólica tangente&quot;.</target>
        </trans-unit>
        <trans-unit id="91479e7f0ee3ff1337daf6434e5f71cdfdc3c6a6" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic cosine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic cosine&quot;, and, less common, &quot;complex area hyperbolic cosine&quot;.</source>
          <target state="translated">Aunque la norma C++denomina a esta función &quot;coseno hiperbólico de arco complejo&quot;,las funciones inversas de las funciones hiperbólicas son las funciones de área.Su argumento es el área de un sector hiperbólico,no un arco.El nombre correcto es &quot;coseno hiperbólico complejo inverso&quot; y,menos común,&quot;coseno hiperbólico de área compleja&quot;.</target>
        </trans-unit>
        <trans-unit id="6a7e68fe75439346aeaad1f6906c84e17daadb3b" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic sine&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic sine&quot;, and, less common, &quot;complex area hyperbolic sine&quot;.</source>
          <target state="translated">Aunque la norma C++denomina a esta función &quot;arco complejo hiperbólico sinusoidal&quot;,las funciones inversas de las funciones hiperbólicas son las funciones de área.Su argumento es el área de un sector hiperbólico,no un arco.El nombre correcto es &quot;seno hiperbólico complejo inverso&quot;,y,menos común,&quot;seno hiperbólico de área compleja&quot;.</target>
        </trans-unit>
        <trans-unit id="8d2c788effcf0da46c782a95d9a9fd3b66474139" translate="yes" xml:space="preserve">
          <source>Although the C++ standard names this function &quot;complex arc hyperbolic tangent&quot;, the inverse functions of the hyperbolic functions are the area functions. Their argument is the area of a hyperbolic sector, not an arc. The correct name is &quot;complex inverse hyperbolic tangent&quot;, and, less common, &quot;complex area hyperbolic tangent&quot;.</source>
          <target state="translated">Aunque la norma C++denomina a esta función &quot;tangente hiperbólica de arco complejo&quot;,las funciones inversas de las funciones hiperbólicas son las funciones de área.Su argumento es el área de un sector hiperbólico,no un arco.El nombre correcto es &quot;tangente hiperbólica inversa compleja&quot; y,menos común,&quot;tangente hiperbólica de área compleja&quot;.</target>
        </trans-unit>
        <trans-unit id="fd70e10e04c4727c7eb398861b7b422e51e53f42" translate="yes" xml:space="preserve">
          <source>Although the C++11 standard still says &quot;On most machines, this is true for signed integers.&quot;, it is a defect and has been corrected. The exact wording changed from C++03 to C++11 in such a way that the &lt;code&gt;true&lt;/code&gt; value is no longer compatible with &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;undefined behavior on signed integer overflow&lt;/a&gt;. Because of that, the implementations that rely on signed overflow being undefined (for optimization opportunities) now set &lt;code&gt;is_modulo&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for signed integers. See for example &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;.</source>
          <target state="translated">Aunque el est&amp;aacute;ndar C ++ 11 todav&amp;iacute;a dice &quot;En la mayor&amp;iacute;a de las m&amp;aacute;quinas, esto es cierto para los enteros con signo&quot;, es un defecto y se ha corregido. La redacci&amp;oacute;n exacta cambi&amp;oacute; de C ++ 03 a C ++ 11 de tal manera que el valor &lt;code&gt;true&lt;/code&gt; ya no es compatible con el &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;comportamiento indefinido en el desbordamiento de enteros con signo&lt;/a&gt; . Debido a eso, las implementaciones que dependen del desbordamiento firmado no est&amp;aacute;n definidas (para oportunidades de optimizaci&amp;oacute;n) ahora establecen &lt;code&gt;is_modulo&lt;/code&gt; en &lt;code&gt;false&lt;/code&gt; para enteros firmados. Ver por ejemplo &lt;a href=&quot;http://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73c3fb8cae35d1afdb844e48a3d68c51dd534493" translate="yes" xml:space="preserve">
          <source>Although the C++11 standard still says &quot;On most machines, this is true for signed integers.&quot;, it is a defect and has been corrected. The exact wording changed from C++03 to C++11 in such a way that the &lt;code&gt;true&lt;/code&gt; value is no longer compatible with &lt;a href=&quot;../../language/operator_arithmetic#Overflows&quot;&gt;undefined behavior on signed integer overflow&lt;/a&gt;. Because of that, the implementations that rely on signed overflow being undefined (for optimization opportunities) now set &lt;code&gt;is_modulo&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for signed integers. See for example &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=22200&quot;&gt;GCC PR 22200&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661de5137e7e9dcc1cb0c7e5d23a45a40d059e70" translate="yes" xml:space="preserve">
          <source>Although the definition uses &lt;code&gt;-1&lt;/code&gt;, &lt;a href=&quot;../basic_string&quot;&gt;&lt;code&gt;size_type&lt;/code&gt;&lt;/a&gt; is an unsigned integer type, and the value of &lt;code&gt;npos&lt;/code&gt; is the largest positive value it can hold, due to &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;signed-to-unsigned implicit conversion&lt;/a&gt;. This is a portable way to specify the largest value of any unsigned type.</source>
          <target state="translated">Aunque la definici&amp;oacute;n usa &lt;code&gt;-1&lt;/code&gt; , &lt;a href=&quot;../basic_string&quot;&gt; &lt;code&gt;size_type&lt;/code&gt; &lt;/a&gt; es un tipo entero sin signo, y el valor de &lt;code&gt;npos&lt;/code&gt; es el mayor valor positivo que puede contener, debido a la &lt;a href=&quot;../../language/implicit_cast#Integral_conversions&quot;&gt;conversi&amp;oacute;n impl&amp;iacute;cita de signo a signo&lt;/a&gt; . Esta es una forma port&amp;aacute;til de especificar el valor m&amp;aacute;s grande de cualquier tipo sin signo.</target>
        </trans-unit>
        <trans-unit id="1abd2f0bb23531226358684e90cc6818e8f8598e" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;++c.begin()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.begin()&lt;/code&gt; is an rvalue expression, and there is no &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; requirement that specifies that increment of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;++c.begin()&lt;/code&gt; does not compile, while &lt;code&gt;std::next(c.begin())&lt;/code&gt; does.</source>
          <target state="translated">Aunque la expresi&amp;oacute;n &lt;code&gt;++c.begin()&lt;/code&gt; menudo se compila, no se garantiza que lo haga: &lt;code&gt;c.begin()&lt;/code&gt; es una expresi&amp;oacute;n de valor de r, y no existe un requisito de &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; que especifique que el incremento de un valor de r est&amp;eacute; garantizado para funcionar. En particular, cuando los iteradores se implementan como punteros, &lt;code&gt;++c.begin()&lt;/code&gt; no se compila, mientras que &lt;code&gt;std::next(c.begin())&lt;/code&gt; s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="55ffdbc2010bd6fba5315668a01fc1d2cb4bf01d" translate="yes" xml:space="preserve">
          <source>Although the expression &lt;code&gt;--c.end()&lt;/code&gt; often compiles, it is not guaranteed to do so: &lt;code&gt;c.end()&lt;/code&gt; is an rvalue expression, and there is no iterator requirement that specifies that decrement of an rvalue is guaranteed to work. In particular, when iterators are implemented as pointers, &lt;code&gt;--c.end()&lt;/code&gt; does not compile, while &lt;code&gt;std::prev(c.end())&lt;/code&gt; does.</source>
          <target state="translated">Aunque la expresi&amp;oacute;n &lt;code&gt;--c.end()&lt;/code&gt; menudo se compila, no se garantiza que lo haga: &lt;code&gt;c.end()&lt;/code&gt; es una expresi&amp;oacute;n de valor de r, y no existe un requisito de iterador que especifique que la disminuci&amp;oacute;n de un valor de r est&amp;eacute; garantizada. En particular, cuando los iteradores se implementan como punteros, &lt;code&gt;--c.end()&lt;/code&gt; no se compila, mientras que &lt;code&gt;std::prev(c.end())&lt;/code&gt; s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="562d3af0d04be2de0b30b637809f27a622e04faf" translate="yes" xml:space="preserve">
          <source>Although the header &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; is based on the C standard library header &lt;code&gt;errno.h&lt;/code&gt;, the majority of the macros defined by &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; were adopted by C++ from the POSIX standard, rather than the C standard library.</source>
          <target state="translated">Aunque el encabezado &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; se basa en el encabezado de la biblioteca est&amp;aacute;ndar C &lt;code&gt;errno.h&lt;/code&gt; , la mayor&amp;iacute;a de las macros definidas por &lt;code&gt;&amp;lt;cerrno&amp;gt;&lt;/code&gt; fueron adoptadas por C ++ del est&amp;aacute;ndar POSIX, en lugar de la biblioteca est&amp;aacute;ndar C.</target>
        </trans-unit>
        <trans-unit id="3db5014665fd46dd8e252214316aa47507ad7ef2" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;std::tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;std::tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="translated">Aunque los nombres generados por &lt;code&gt;std::tmpnam&lt;/code&gt; son dif&amp;iacute;ciles de adivinar, es posible que un archivo con ese nombre sea creado por otro proceso entre el momento en que &lt;code&gt;std::tmpnam&lt;/code&gt; regresa y el momento en que este programa intenta usar el nombre devuelto para crear un expediente. La funci&amp;oacute;n est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; y la funci&amp;oacute;n POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; no tienen este problema (la creaci&amp;oacute;n de un directorio &amp;uacute;nico utilizando solo la biblioteca C est&amp;aacute;ndar todav&amp;iacute;a requiere el uso de &lt;code&gt;tmpnam&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9d5994bfdfeb1041b6398f05b2f8f3e33b52a975" translate="yes" xml:space="preserve">
          <source>Although the names generated by &lt;code&gt;std::tmpnam&lt;/code&gt; are difficult to guess, it is possible that a file with that name is created by another process between the moment &lt;code&gt;std::tmpnam&lt;/code&gt; returns and the moment this program attempts to use the returned name to create a file. The standard function &lt;code&gt;&lt;a href=&quot;tmpfile&quot;&gt;std::tmpfile&lt;/a&gt;&lt;/code&gt; and the POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdtemp.html&quot;&gt;mkstemp&lt;/a&gt; do not have this problem (creating a unique directory using only the standard C library still requires the use of &lt;code&gt;tmpnam&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9f3db27755b0d585a653f2d5f3657aa1f21c81b" translate="yes" xml:space="preserve">
          <source>Although the results of comparing pointers of random origin (e.g. not all pointing to members of the same array) is unspecified, many implementations provide &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total ordering&lt;/a&gt; of pointers, e.g. if they are implemented as addresses within continuous virtual address space. Those implementations that do not (e.g. where not all bits of the pointer are part of a memory address and have to be ignored for comparison, or an additional calculation is required or otherwise pointer and integer is not a 1 to 1 relationship), provide a specialization of &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; for pointers that has that guarantee. This makes it possible to use all pointers of random origin as keys in standard associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Aunque los resultados de comparar punteros de origen aleatorio (p. Ej., No todos apuntan a miembros de la misma matriz) no est&amp;aacute;n especificados, muchas implementaciones proporcionan un &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;estricto orden total&lt;/a&gt; de punteros, p. Ej., Si se implementan como direcciones dentro del espacio virtual continuo de direcciones. Las implementaciones que no lo hacen (p. Ej., Donde no todos los bits del puntero son parte de una direcci&amp;oacute;n de memoria y deben ignorarse para la comparaci&amp;oacute;n, o se requiere un c&amp;aacute;lculo adicional o de lo contrario el puntero y el entero no son una relaci&amp;oacute;n 1 a 1), proporcionan un especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../utility/functional/less&quot;&gt;std::less&lt;/a&gt;&lt;/code&gt; para punteros que tienen esa garant&amp;iacute;a. Esto permite utilizar todos los punteros de origen aleatorio como claves en contenedores asociativos est&amp;aacute;ndar como &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8a747e33a10c6fa21c941b73f1438fc704b6283" translate="yes" xml:space="preserve">
          <source>Although the return type is &lt;code&gt;char*&lt;/code&gt;, modifying the pointed-to characters is undefined behavior.</source>
          <target state="translated">Aunque el tipo de retorno es &lt;code&gt;char*&lt;/code&gt; , modificar los caracteres se&amp;ntilde;alados es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="1a131648c16bdab1f4ad67b397e73af609dc5ab0" translate="yes" xml:space="preserve">
          <source>Although the return type is not allowed in the declaration of a user-defined conversion function, the decl-specifier-seq of &lt;a href=&quot;declarations#Specifiers&quot;&gt;the declaration grammar&lt;/a&gt; may be present and may include any specifier other than type-specifier or the keyword static, In particular, besides &lt;code&gt;explicit&lt;/code&gt;, the specifiers &lt;a href=&quot;inline&quot;&gt;inline&lt;/a&gt;, &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt;, &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;, and &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; are also allowed (note that &lt;code&gt;friend&lt;/code&gt; requires a qualified name: &lt;code&gt;friend A::operator B();&lt;/code&gt;).</source>
          <target state="translated">Aunque el tipo de retorno no est&amp;aacute; permitido en la declaraci&amp;oacute;n de una funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario, el decl-specifier-seq de &lt;a href=&quot;declarations#Specifiers&quot;&gt;la gram&amp;aacute;tica&lt;/a&gt; de la declaraci&amp;oacute;n puede estar presente y puede incluir cualquier especificador que no sea type-specifier o la palabra clave static, en particular, adem&amp;aacute;s &lt;code&gt;explicit&lt;/code&gt; , los especificadores en &lt;a href=&quot;inline&quot;&gt;l&amp;iacute;nea&lt;/a&gt; , &lt;a href=&quot;virtual&quot;&gt;virtual&lt;/a&gt; , &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt; y &lt;a href=&quot;friend&quot;&gt;friend&lt;/a&gt; tambi&amp;eacute;n est&amp;aacute;n permitidos (tenga en cuenta que &lt;code&gt;friend&lt;/code&gt; requiere un nombre calificado: &lt;code&gt;friend A::operator B();&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d77898594331af7d94d8805113c2ae7cc96df8a5" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead, making this a non-converting locale. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">Aunque el est&amp;aacute;ndar requiere que esta faceta funcione con UCS2 cuando el tama&amp;ntilde;o de &lt;code&gt;Elem&lt;/code&gt; es de 16 bits, algunas implementaciones usan UTF-16 en su lugar, lo que lo convierte en un entorno no convertible. El t&amp;eacute;rmino &quot;UCS2&quot; qued&amp;oacute; en desuso y se elimin&amp;oacute; del est&amp;aacute;ndar Unicode.</target>
        </trans-unit>
        <trans-unit id="3eafdced96881df5338499ac356a8e8f50b8bc53" translate="yes" xml:space="preserve">
          <source>Although the standard requires that this facet works with UCS2 when the size of &lt;code&gt;Elem&lt;/code&gt; is 16 bits, some implementations use UTF-16 instead. The term &quot;UCS2&quot; was deprecated and removed from the Unicode standard.</source>
          <target state="translated">Aunque el est&amp;aacute;ndar requiere que esta faceta funcione con UCS2 cuando el tama&amp;ntilde;o de &lt;code&gt;Elem&lt;/code&gt; es de 16 bits, algunas implementaciones usan UTF-16 en su lugar. El t&amp;eacute;rmino &quot;UCS2&quot; qued&amp;oacute; en desuso y se elimin&amp;oacute; del est&amp;aacute;ndar Unicode.</target>
        </trans-unit>
        <trans-unit id="a91bcce893b5de905ecbd22a99a03889cdcc2544" translate="yes" xml:space="preserve">
          <source>Always</source>
          <target state="translated">Always</target>
        </trans-unit>
        <trans-unit id="fe09758345685e241df672635cfac946bfc561d8" translate="yes" xml:space="preserve">
          <source>Always-throwing functions</source>
          <target state="translated">Funciones de lanzamiento permanente</target>
        </trans-unit>
        <trans-unit id="4df6b8083eb91bc6a923cb0c4bf5c1ae0e994985" translate="yes" xml:space="preserve">
          <source>Ambiguous and nonexistent local times can occur as a result of time zone transitions (such as daylight saving time). For example, &quot;2016-03-13 02:30:00&quot; does not exist in the &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; time zone, while &quot;2016-11-06 01:30:00&quot; in that time zone can correspond to two UTC time points: 2016-11-06 05:30:00 UTC and 2016-11-06 06:30:00 UTC.</source>
          <target state="translated">Pueden ocurrir horas locales ambiguas e inexistentes como resultado de las transiciones de zona horaria (como el horario de verano). Por ejemplo, &quot;2016-03-13 02:30:00&quot; no existe en la zona horaria &lt;code&gt;&quot;America/New_York&quot;&lt;/code&gt; , mientras que &quot;2016-11-06 01:30:00&quot; en esa zona horaria puede corresponder a dos UTC puntos de tiempo: 2016-11-06 05:30:00 UTC y 2016-11-06 06:30:00 UTC.</target>
        </trans-unit>
        <trans-unit id="c067979f83933e6c4d89a2c1e0fb562a0f280310" translate="yes" xml:space="preserve">
          <source>Ambiguous conversion sequences are ranked as user-defined conversion sequences because multiple conversion sequences for an argument can exist only if they involve different user-defined conversions:</source>
          <target state="translated">Las secuencias de conversión ambiguas se clasifican como secuencias de conversión definidas por el usuario porque sólo pueden existir múltiples secuencias de conversión para un argumento si implican diferentes conversiones definidas por el usuario:</target>
        </trans-unit>
        <trans-unit id="5aa47b263945205f7df82cf554dee097502b0d78" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g.operator()&lt;/code&gt;.</source>
          <target state="translated">N&amp;uacute;mero constante amortizado de invocaciones de &lt;code&gt;g.operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="128bb665ca4a35fff2ef43cce127f6f8f60033b5" translate="yes" xml:space="preserve">
          <source>Amortized constant number of invocations of &lt;code&gt;g&lt;/code&gt;</source>
          <target state="translated">N&amp;uacute;mero constante amortizado de invocaciones de &lt;code&gt;g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1cbb525f8d6525a8ab447903dfd14ddbdc0818e6" translate="yes" xml:space="preserve">
          <source>Amortized constant on average, worst case linear in the size of the container.</source>
          <target state="translated">Amortizado constante en promedio,en el peor de los casos lineal en el tamaño del contenedor.</target>
        </trans-unit>
        <trans-unit id="50471dc8ecc10f0a607efbdd965811e70e031a13" translate="yes" xml:space="preserve">
          <source>Amortized constant.</source>
          <target state="translated">Constante amortizada.</target>
        </trans-unit>
        <trans-unit id="99690d58d4abd10cd0938a7adcb56ded08ef66ad" translate="yes" xml:space="preserve">
          <source>An</source>
          <target state="translated">An</target>
        </trans-unit>
        <trans-unit id="45ea68905c72735578b243d8c992010c73dd2b71" translate="yes" xml:space="preserve">
          <source>An 8-bit binary type can represent any two-digit decimal number exactly, but 3-digit decimal numbers 256..999 cannot be represented. The value of &lt;code&gt;digits10&lt;/code&gt; for an 8-bit type is 2 (&lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; is 2.41).</source>
          <target state="translated">Un tipo binario de 8 bits puede representar cualquier n&amp;uacute;mero decimal de dos d&amp;iacute;gitos exactamente, pero los n&amp;uacute;meros decimales de 3 d&amp;iacute;gitos 256..999 no se pueden representar. El valor de &lt;code&gt;digits10&lt;/code&gt; para un tipo de 8 bits es 2 ( &lt;code&gt;8 * &lt;a href=&quot;../../numeric/math/log10&quot;&gt;std::log10&lt;/a&gt;(2)&lt;/code&gt; es 2.41).</target>
        </trans-unit>
        <trans-unit id="b70a29f58335fff2ae0f72bb6d64b3b5da9003ef" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../language/type-id&quot;&gt;arithmetic type&lt;/a&gt;</source>
          <target state="translated">Un &lt;a href=&quot;../language/type-id&quot;&gt;tipo aritm&amp;eacute;tico&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="807382b205cd61b4e07e059d92477e9e7b450d4d" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation&lt;/a&gt; or deallocation function for a class is odr-used by a &lt;a href=&quot;new&quot;&gt;new expression&lt;/a&gt; appearing in a potentially-evaluated expression</source>
          <target state="translated">Una &lt;a href=&quot;new&quot;&gt;nueva &lt;/a&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;asignaci&amp;oacute;n que&lt;/a&gt; aparece en una expresi&amp;oacute;n potencialmente evaluada eval&amp;uacute;a una funci&amp;oacute;n de asignaci&amp;oacute;n o desasignaci&amp;oacute;n para una clase.</target>
        </trans-unit>
        <trans-unit id="8d5b39fd5f28e44fd4cbe7c1a6e4527324fdb198" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;asm&quot;&gt;asm declaration&lt;/a&gt; does not define any entities, but it is classified as a definition.</source>
          <target state="translated">Una &lt;a href=&quot;asm&quot;&gt;declaraci&amp;oacute;n asm&lt;/a&gt; no define ninguna entidad, pero se clasifica como una definici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d3db36c93422d5b474b182b8149fdd0c74f76e94" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;attributes&quot;&gt;attribute&lt;/a&gt; sequence attr may appear just before the label (in which case it applies to the label), or just before any statement itself, in which case it applies to the entire statement. A statement may carry multiple labels. Labels (and only labels) have &lt;a href=&quot;scope#Function_scope&quot;&gt;function scope&lt;/a&gt;. Labels are ignored by &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt;: a label can have the same name as any other entity in the program.</source>
          <target state="translated">Un &lt;a href=&quot;attributes&quot;&gt;atributo de&lt;/a&gt; secuencia de atributos puede aparecer justo antes de la etiqueta (en cuyo caso se aplica a la etiqueta), o justo antes de cualquier declaraci&amp;oacute;n en s&amp;iacute;, en cuyo caso se aplica a toda la declaraci&amp;oacute;n. Una declaraci&amp;oacute;n puede llevar m&amp;uacute;ltiples etiquetas. Las etiquetas (y solo las etiquetas) tienen &lt;a href=&quot;scope#Function_scope&quot;&gt;alcance de funci&amp;oacute;n&lt;/a&gt; . Las etiquetas son ignoradas por la &lt;a href=&quot;unqualified_lookup&quot;&gt;b&amp;uacute;squeda no calificada&lt;/a&gt; : una etiqueta puede tener el mismo nombre que cualquier otra entidad en el programa.</target>
        </trans-unit>
        <trans-unit id="67d8f4f0c409d53bf6fc239c4572103225de8737" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt;explicit instantiation declaration&lt;/a&gt; (an &quot;extern template&quot;)</source>
          <target state="translated">Un &lt;a href=&quot;class_template#Class_template_instantiation&quot;&gt; declaraci&amp;oacute;n de instanciaci&amp;oacute;n expl&amp;iacute;cita&lt;/a&gt; (una &quot;plantilla externa&quot;)</target>
        </trans-unit>
        <trans-unit id="e8d07ab60f03237d43aaac774ff0a48905536383" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;attribute declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">Un &lt;a href=&quot;declarations&quot;&gt; declaraci&amp;oacute;n de atributo&lt;/a&gt; (no define ninguna entidad)</target>
        </trans-unit>
        <trans-unit id="8250bcb5d0e5dcdf0fb994dd06a03c09d7251e75" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;declarations&quot;&gt;empty declaration&lt;/a&gt; (does not define any entities)</source>
          <target state="translated">Un &lt;a href=&quot;declarations&quot;&gt; declaraci&amp;oacute;n vac&amp;iacute;a&lt;/a&gt; (no define ninguna entidad)</target>
        </trans-unit>
        <trans-unit id="1cae5b3ce33128b19eacc0658479be44746e7c43" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;enum&quot;&gt;opaque declaration&lt;/a&gt; of an enumeration</source>
          <target state="translated">Un &lt;a href=&quot;enum&quot;&gt; declaraci&amp;oacute;n opaca&lt;/a&gt; de una enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="97e3c29d16d88a0e096a7e69f7173bded9fa122e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::const_iterator&lt;/code&gt;</source>
          <target state="translated">Un &lt;a href=&quot;iterator&quot;&gt;legado iterador&lt;/a&gt; cuya categor&amp;iacute;a y tipos son los mismos que &lt;code&gt;X::const_iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf13631c6d364b349a268bbd81c204b7997b1947" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; whose category and types are the same as &lt;code&gt;X::iterator&lt;/code&gt;</source>
          <target state="translated">Un &lt;a href=&quot;iterator&quot;&gt;legado iterador&lt;/a&gt; cuya categor&amp;iacute;a y tipos son los mismos que &lt;code&gt;X::iterator&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c036f0c614197c69e50ff0747f60db77d1ca80a7" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name&quot;&gt;identifier&lt;/a&gt; that names a non-type template parameter of class type &lt;code&gt;T&lt;/code&gt; denotes a static storage duration object of type &lt;code&gt;const T&lt;/code&gt;, called a</source>
          <target state="translated">Un &lt;a href=&quot;name&quot;&gt;identificador&lt;/a&gt; que nombra un par&amp;aacute;metro de plantilla sin tipo de clase tipo &lt;code&gt;T&lt;/code&gt; denota un objeto de tipo de duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico &lt;code&gt;const T&lt;/code&gt; , denominado</target>
        </trans-unit>
        <trans-unit id="c6fbfbd5514da52daf4588bb104a4a85d038970e" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;name#In_expressions&quot;&gt;identifier expression&lt;/a&gt; that denotes an immediate function may only appear within a subexpression of an immediate invocation or within an immediate function context. A pointer or reference to an immediate function can be taken but cannot escape constant expression evaluation:</source>
          <target state="translated">Un &lt;a href=&quot;name#In_expressions&quot;&gt; expresi&amp;oacute;n de identificador&lt;/a&gt; que denota una funci&amp;oacute;n inmediata solo puede aparecer dentro de una subexpresi&amp;oacute;n de una invocaci&amp;oacute;n inmediata o dentro de un contexto de funci&amp;oacute;n inmediata. Se puede tomar un puntero o referencia a una funci&amp;oacute;n inmediata pero no se puede escapar de la evaluaci&amp;oacute;n de expresi&amp;oacute;n constante:</target>
        </trans-unit>
        <trans-unit id="4835e23540157d178506c76dbed3585b131cd6c2" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt; whose declaration is not a definition.</source>
          <target state="translated">Una &lt;a href=&quot;template_specialization&quot;&gt;especializaci&amp;oacute;n expl&amp;iacute;cita&lt;/a&gt; cuya declaraci&amp;oacute;n no es una definici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0476037f5a01ed84f4c68efe6578d34ee836c695" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;type_alias&quot;&gt;alias-declaration&lt;/a&gt;</source>
          <target state="translated">Un &lt;a href=&quot;type_alias&quot;&gt; declaraci&amp;oacute;n de alias&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec273bcf1f66db0db9b6197343f94ba32b5eec31" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; of function type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt;&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;pointer to that function&lt;/a&gt;. This does not apply to non-static member functions because lvalues that refer to non-static member functions do not exist.</source>
          <target state="translated">Un &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; de tipo de funci&amp;oacute;n &lt;code&gt;T&lt;/code&gt; se puede convertir impl&amp;iacute;citamente a un &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue &lt;/a&gt;&lt;a href=&quot;pointer#Pointers_to_functions&quot;&gt;puntero a esa funci&amp;oacute;n&lt;/a&gt; . Esto no se aplica a las funciones miembro no est&amp;aacute;ticas porque los valores que se refieren a funciones miembro no est&amp;aacute;ticas no existen.</target>
        </trans-unit>
        <trans-unit id="7ba6cc034ab70817b81a34ed74af74dd8855a970" translate="yes" xml:space="preserve">
          <source>An &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; or &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; of type &quot;array of &lt;code&gt;N&lt;/code&gt;&lt;code&gt;T&lt;/code&gt;&quot; or &quot;array of unknown bound of &lt;code&gt;T&lt;/code&gt;&quot; can be implicitly converted to a &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt; of type &quot;pointer to &lt;code&gt;T&lt;/code&gt;&quot;. If the array is a prvalue, &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.(since C++17) The resulting pointer refers to the first element of the array (see &lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;array to pointer decay&lt;/a&gt; for details).</source>
          <target state="translated">Un &lt;a href=&quot;value_category#lvalue&quot;&gt;lvalue&lt;/a&gt; o &lt;a href=&quot;value_category#rvalue&quot;&gt;rvalue&lt;/a&gt; de tipo &quot;array de &lt;code&gt;N&lt;/code&gt; &lt;code&gt;T&lt;/code&gt; &quot; o &quot;variedad de desconocido unido de &lt;code&gt;T&lt;/code&gt; &quot; se pueden convertir impl&amp;iacute;citamente a un &lt;a href=&quot;value_category#prvalue&quot;&gt;prvalue&lt;/a&gt; de tipo &quot;puntero a &lt;code&gt;T&lt;/code&gt; &quot;. Si la matriz es un prvalue, &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;se&lt;/a&gt; produce una materializaci&amp;oacute;n temporal . (Desde C ++ 17) El puntero resultante se refiere al primer elemento de la matriz (consulte la &lt;a href=&quot;array#Array-to-pointer_decay&quot;&gt;descomposici&amp;oacute;n de la matriz en el puntero&lt;/a&gt; para obtener m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="3b75a307aa52c5825d1730c4cdd4f9a558685208" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; object containing the given values.</source>
          <target state="translated">Un objeto &lt;code&gt;&lt;a href=&quot;../pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; que contiene los valores dados.</target>
        </trans-unit>
        <trans-unit id="d6c35561be6c0db7de52088fd8b63305b7a7d8f9" translate="yes" xml:space="preserve">
          <source>An &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; holding a pointer to the beginning of the allocated storage and the number of objects that fit in the storage that was actually allocated.</source>
          <target state="translated">Un &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; contiene un puntero al comienzo del almacenamiento asignado y el n&amp;uacute;mero de objetos que caben en el almacenamiento que se asign&amp;oacute; realmente.</target>
        </trans-unit>
        <trans-unit id="64c0acf093e82ca7c2d56259ef132c09f1d727d8" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AllocatorAwareContainer&lt;/strong&gt; is a &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that holds an instance of an &lt;a href=&quot;allocator&quot;&gt;Allocator&lt;/a&gt; and uses that instance in all its member functions to allocate and deallocate memory and to construct and destroy objects in that memory (such objects may be container elements, nodes, or, for unordered containers, bucket arrays).</source>
          <target state="translated">Un &lt;strong&gt;AllocatorAwareContainer&lt;/strong&gt; es un &lt;a href=&quot;container&quot;&gt;contenedor&lt;/a&gt; que contiene una instancia de un &lt;a href=&quot;allocator&quot;&gt;asignador&lt;/a&gt; y usa esa instancia en todas sus funciones miembro para asignar y desasignar memoria y para construir y destruir objetos en esa memoria (tales objetos pueden ser elementos contenedor, nodos o, para contenedores no ordenados , conjuntos de cubos).</target>
        </trans-unit>
        <trans-unit id="eaa15e16e5ec0c95afc353328fbb4fb678121869" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;AssociativeContainer&lt;/strong&gt; is an ordered &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt; that provides fast lookup of objects based on keys.</source>
          <target state="translated">Un &lt;a href=&quot;container&quot;&gt;Contenedor &lt;/a&gt;&lt;strong&gt;Asociativo&lt;/strong&gt; es un Contenedor ordenado que proporciona una b&amp;uacute;squeda r&amp;aacute;pida de objetos basados ​​en claves.</target>
        </trans-unit>
        <trans-unit id="b5c5d4aca5ec3c0868d0e700b371604b1ec448c3" translate="yes" xml:space="preserve">
          <source>An &lt;strong&gt;LegacyInputIterator&lt;/strong&gt; is an &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; that can read from the pointed-to element. LegacyInputIterators only guarantee validity for single pass algorithms: once an LegacyInputIterator &lt;code&gt;i&lt;/code&gt; has been incremented, all copies of its previous value may be invalidated.</source>
          <target state="translated">Un &lt;strong&gt;LegacyInputIterator&lt;/strong&gt; es un &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt; que puede leer desde el elemento se&amp;ntilde;alado. LegacyInputIterators solo garantiza la validez de los algoritmos de un solo paso: una vez que un LegacyInputIterator &lt;code&gt;i&lt;/code&gt; ha sido incrementado, todas las copias de su valor anterior pueden ser invalidadas.</target>
        </trans-unit>
        <trans-unit id="a021125aae1a0c5f6666fbd70ad3091d5eaf4be5" translate="yes" xml:space="preserve">
          <source>An UnformattedInputFunction is a stream input function that performs the following:</source>
          <target state="translated">Una UnformattedInputFunction es una función de entrada de corriente que realiza lo siguiente:</target>
        </trans-unit>
        <trans-unit id="ce56470376a6a1e9f7a374ada94b689a0ac77bd6" translate="yes" xml:space="preserve">
          <source>An abstract class is a class that either defines or inherits at least one function for which &lt;a href=&quot;virtual&quot;&gt;the final overrider&lt;/a&gt; is pure virtual.</source>
          <target state="translated">Una clase abstracta es una clase que define o hereda al menos una funci&amp;oacute;n para la que &lt;a href=&quot;virtual&quot;&gt;la anulaci&amp;oacute;n final&lt;/a&gt; es puramente virtual.</target>
        </trans-unit>
        <trans-unit id="908b2d8b11e075496d08f7d7d4b01d8354d7a3e1" translate="yes" xml:space="preserve">
          <source>An additional class template &lt;code&gt;auto_ptr_ref&lt;/code&gt; is referred to throughout the documentation. It is an implementation-defined type that holds a reference to &lt;code&gt;auto_ptr&lt;/code&gt;. The implementation is allowed to provide the template with a different name or implement the functions returning it or accepting it as parameter in other ways.</source>
          <target state="translated">Se hace referencia a una plantilla de clase adicional &lt;code&gt;auto_ptr_ref&lt;/code&gt; en toda la documentaci&amp;oacute;n. Es un tipo definido por la implementaci&amp;oacute;n que contiene una referencia a &lt;code&gt;auto_ptr&lt;/code&gt; . La implementaci&amp;oacute;n puede proporcionar a la plantilla un nombre diferente o implementar las funciones que la devuelven o la aceptan como par&amp;aacute;metro de otras maneras.</target>
        </trans-unit>
        <trans-unit id="492bf377c49f20efce1a6cebadb795c9f43e068d" translate="yes" xml:space="preserve">
          <source>An additional rule is applied to the deduction in this case: when comparing function parameters &lt;code&gt;P&lt;/code&gt;i and &lt;code&gt;A&lt;/code&gt;i, if any &lt;code&gt;P&lt;/code&gt;i is an rvalue reference to cv-unqualified template parameter (a &quot;forwarding reference&quot;) and the corresponding &lt;code&gt;A&lt;/code&gt;i is an lvalue reference, then &lt;code&gt;P&lt;/code&gt;i is adjusted to the template parameter type (T&amp;amp;&amp;amp; becomes T).</source>
          <target state="translated">En este caso, se aplica una regla adicional a la deducci&amp;oacute;n: cuando se comparan los par&amp;aacute;metros de funci&amp;oacute;n &lt;code&gt;P&lt;/code&gt; i y &lt;code&gt;A&lt;/code&gt; i, si cualquier &lt;code&gt;P&lt;/code&gt; i es una referencia de valor al par&amp;aacute;metro de plantilla no calificado cv (una &quot;referencia de reenv&amp;iacute;o&quot;) y la &lt;code&gt;A&lt;/code&gt; i correspondiente es un lvalue reference, luego &lt;code&gt;P&lt;/code&gt; i se ajusta al tipo de par&amp;aacute;metro de plantilla (T &amp;amp;&amp;amp; se convierte en T).</target>
        </trans-unit>
        <trans-unit id="39f1e2f1f4a1f2712c275be633629814179e5046" translate="yes" xml:space="preserve">
          <source>An aggregate class or array may include non-aggregate public bases(since C++17), members, or elements, which are initialized as described above (e.g. copy-initialization from the corresponding initializer clause).</source>
          <target state="translated">Una clase o conjunto agregado puede incluir bases públicas no agregadas (desde C++17),miembros o elementos,que se inicializan como se ha descrito anteriormente (por ejemplo,inicialización de copias de la cláusula de inicialización correspondiente).</target>
        </trans-unit>
        <trans-unit id="b197d6cc29c7895c847275964c7060dca3357d57" translate="yes" xml:space="preserve">
          <source>An aggregate is one of the following types:</source>
          <target state="translated">Un agregado es uno de los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="12db35057383aa0593fc91fb24bea2072f9fc5b7" translate="yes" xml:space="preserve">
          <source>An algorithm to &quot;clamp&quot; a value between a pair of boundary values (&lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Un algoritmo para &quot;sujetar&quot; un valor entre un par de valores l&amp;iacute;mite ( &lt;code&gt;&lt;a href=&quot;algorithm/clamp&quot;&gt;std::clamp&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="6a4c8075a51ee48f2fc8e9678f381d4c2cc5cd9e" translate="yes" xml:space="preserve">
          <source>An allocator that is used to acquire/release memory and to construct/destroy the elements in that memory. The type must meet the requirements of &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;. The behavior is undefined if &lt;code&gt;Allocator::value_type&lt;/code&gt; is not the same as &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Un asignador que se utiliza para adquirir / liberar memoria y para construir / destruir los elementos en esa memoria. El tipo debe cumplir los requisitos de &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; . El comportamiento no est&amp;aacute; definido si &lt;code&gt;Allocator::value_type&lt;/code&gt; no es lo mismo que &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7e6c1744a360683380fca88796315c08727ff6" translate="yes" xml:space="preserve">
          <source>An allocator type &lt;code&gt;X&lt;/code&gt; for type &lt;code&gt;T&lt;/code&gt; additionally satisfies the</source>
          <target state="translated">Un asignador tipo &lt;code&gt;X&lt;/code&gt; para el tipo &lt;code&gt;T&lt;/code&gt; satisface adicionalmente el</target>
        </trans-unit>
        <trans-unit id="8d97370574b17753b94ede73aa5e362da9eb3aac" translate="yes" xml:space="preserve">
          <source>An arithmetic type or a class emulating an arithmetic type</source>
          <target state="translated">Un tipo aritmético o una clase que emula un tipo aritmético</target>
        </trans-unit>
        <trans-unit id="c52cf5a897774b32a3cc4643437d36a5b1792813" translate="yes" xml:space="preserve">
          <source>An array can also be used as a tuple of &lt;code&gt;N&lt;/code&gt; elements of the same type.</source>
          <target state="translated">Una matriz tambi&amp;eacute;n se puede usar como una tupla de &lt;code&gt;N&lt;/code&gt; elementos del mismo tipo.</target>
        </trans-unit>
        <trans-unit id="5ac3648865a50f77bee68245b1bc8d2b8af79b49" translate="yes" xml:space="preserve">
          <source>An array declaration is any simple declaration whose &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt; has the form.</source>
          <target state="translated">Una declaraci&amp;oacute;n de matriz es cualquier declaraci&amp;oacute;n simple cuyo &lt;a href=&quot;declarations&quot;&gt;declarador&lt;/a&gt; tiene la forma.</target>
        </trans-unit>
        <trans-unit id="f97a7d14a3134d2ce52774abf33446e4a447d088" translate="yes" xml:space="preserve">
          <source>An assignment operator in a class &lt;code&gt;T&lt;/code&gt; that is a member or base of another class &lt;code&gt;U&lt;/code&gt; is odr-used by an implicitly-defined copy-assignment or move-assignment functions of &lt;code&gt;U&lt;/code&gt;.</source>
          <target state="translated">Un operador de asignaci&amp;oacute;n en una clase &lt;code&gt;T&lt;/code&gt; que es miembro o base de otra clase &lt;code&gt;U&lt;/code&gt; es utilizado por una funci&amp;oacute;n de asignaci&amp;oacute;n de copia o asignaci&amp;oacute;n de movimiento de &lt;code&gt;U&lt;/code&gt; impl&amp;iacute;citamente definida .</target>
        </trans-unit>
        <trans-unit id="2bc87d164b8e7f6ecde4c668667f3c0239908e17" translate="yes" xml:space="preserve">
          <source>An associative container &lt;code&gt;X&lt;/code&gt; that is either &lt;code&gt;std::map&lt;/code&gt; and &lt;code&gt;std::multimap&lt;/code&gt; additionally supports the expression X::mapped_type, which has a return type of T, with the requirement that &lt;code&gt;T&lt;/code&gt; be &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and compile time complexity.</source>
          <target state="translated">Un contenedor asociativo &lt;code&gt;X&lt;/code&gt; que es &lt;code&gt;std::map&lt;/code&gt; y &lt;code&gt;std::multimap&lt;/code&gt; tambi&amp;eacute;n admite la expresi&amp;oacute;n X :: mapped_type, que tiene un tipo de retorno de T, con el requisito de que &lt;code&gt;T&lt;/code&gt; sea &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt; y compile la complejidad del tiempo.</target>
        </trans-unit>
        <trans-unit id="864fa04b4ed98eae74afcfaa9ef56bb780bc69ce" translate="yes" xml:space="preserve">
          <source>An asynchronous operation (created via &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt;) can provide a &lt;code&gt;std::future&lt;/code&gt; object to the creator of that asynchronous operation.</source>
          <target state="translated">Una operaci&amp;oacute;n asincr&amp;oacute;nica (creada mediante &lt;code&gt;&lt;a href=&quot;async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; ) puede proporcionar un objeto &lt;code&gt;std::future&lt;/code&gt; al creador de esa operaci&amp;oacute;n asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="9e8f8230bc284edbfa18713cf06662ed31c603fb" translate="yes" xml:space="preserve">
          <source>An atomic &lt;a href=&quot;memory_order&quot;&gt;release operation&lt;/a&gt; X in thread A synchronizes-with an acquire fence F in thread B, if.</source>
          <target state="translated">Una &lt;a href=&quot;memory_order&quot;&gt;operaci&amp;oacute;n de liberaci&amp;oacute;n&lt;/a&gt; at&amp;oacute;mica X en el hilo A se sincroniza con una cerca de adquisici&amp;oacute;n F en el hilo B, si.</target>
        </trans-unit>
        <trans-unit id="928fdce82eda51be195710313098b2223ec96c39" translate="yes" xml:space="preserve">
          <source>An atomic constraint consists of an expression &lt;code&gt;E&lt;/code&gt; and a mapping from the template parameters that appear within &lt;code&gt;E&lt;/code&gt; to template arguments involving the template parameters of the constrained entity, called its</source>
          <target state="translated">Una restricci&amp;oacute;n at&amp;oacute;mica consiste en una expresi&amp;oacute;n &lt;code&gt;E&lt;/code&gt; y un mapeo de los par&amp;aacute;metros de plantilla que aparecen dentro de &lt;code&gt;E&lt;/code&gt; a argumentos de plantilla que involucran los par&amp;aacute;metros de plantilla de la entidad restringida, llamada su</target>
        </trans-unit>
        <trans-unit id="5a79829f8c7b85fe4e4638dfbea954acbd0eda02" translate="yes" xml:space="preserve">
          <source>An atomic operation A on some atomic object M is</source>
          <target state="translated">Una operación atómica A en algún objeto atómico M es</target>
        </trans-unit>
        <trans-unit id="5a5310902368573c36e555b627b994b235e68248" translate="yes" xml:space="preserve">
          <source>An attribute can be used almost everywhere in the C++ program, and can be applied to almost everything: to types, to variables, to functions, to names, to code blocks, to entire translation units, although each particular attribute is only valid where it is permitted by the implementation: &lt;code&gt;[[expect_true]]&lt;/code&gt; could be an attribute that can only be used with an &lt;code&gt;if&lt;/code&gt;, and not with a class declaration. &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; could be an attribute that applies to a code block or to a &lt;code&gt;for&lt;/code&gt; loop, but not to the type &lt;code&gt;int&lt;/code&gt;, etc. (note these two attributes are fictional examples, see below for the standard and some non-standard attributes).</source>
          <target state="translated">Un atributo se puede usar en casi todas partes en el programa C ++, y se puede aplicar a casi todo: a tipos, a variables, a funciones, a nombres, a bloques de c&amp;oacute;digo, a unidades de traducci&amp;oacute;n completas, aunque cada atributo particular solo es v&amp;aacute;lido donde est&amp;aacute; permitido por la implementaci&amp;oacute;n: &lt;code&gt;[[expect_true]]&lt;/code&gt; podr&amp;iacute;a ser un atributo que solo se puede usar con un &lt;code&gt;if&lt;/code&gt; y no con una declaraci&amp;oacute;n de clase. &lt;code&gt;[[omp::parallel()]]&lt;/code&gt; podr&amp;iacute;a ser un atributo que se aplica a un bloque de c&amp;oacute;digo o a un bucle &lt;code&gt;for&lt;/code&gt; , pero no al tipo &lt;code&gt;int&lt;/code&gt; , etc. (tenga en cuenta que estos dos atributos son ejemplos ficticios, consulte a continuaci&amp;oacute;n el est&amp;aacute;ndar y algunos atributos no est&amp;aacute;ndar).</target>
        </trans-unit>
        <trans-unit id="3b30276e5eb22d8f2d82beaa0982183267864ede" translate="yes" xml:space="preserve">
          <source>An ellipsis &lt;code&gt;...&lt;/code&gt; may appear at the end of the parameter list; this declares a &lt;a href=&quot;variadic_arguments&quot;&gt;variadic function&lt;/a&gt;:</source>
          <target state="translated">Pueden aparecer puntos suspensivos &lt;code&gt;...&lt;/code&gt; al final de la lista de par&amp;aacute;metros; Esto declara una &lt;a href=&quot;variadic_arguments&quot;&gt;funci&amp;oacute;n variadic&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7b28c53044424dbd671a0a292fff9b11ed2f240c" translate="yes" xml:space="preserve">
          <source>An empty path can be obtained by calling &lt;a href=&quot;clear&quot;&gt;&lt;code&gt;clear&lt;/code&gt;&lt;/a&gt; and by default-constructing a &lt;code&gt;path&lt;/code&gt;. It can also be returned by a path decomposition function (such as &lt;a href=&quot;extension&quot;&gt;&lt;code&gt;extension&lt;/code&gt;&lt;/a&gt;) if the corresponding component is not present in the path.</source>
          <target state="translated">Se puede obtener una ruta vac&amp;iacute;a llamando a &lt;a href=&quot;clear&quot;&gt; &lt;code&gt;clear&lt;/code&gt; &lt;/a&gt; y construyendo una &lt;code&gt;path&lt;/code&gt; por defecto . Tambi&amp;eacute;n puede ser devuelto por una funci&amp;oacute;n de descomposici&amp;oacute;n de ruta (como la &lt;a href=&quot;extension&quot;&gt; &lt;code&gt;extension&lt;/code&gt; &lt;/a&gt; ) si el componente correspondiente no est&amp;aacute; presente en la ruta.</target>
        </trans-unit>
        <trans-unit id="2ecc5a9f5ce0682a542e5d3a7d4ffa7f954c9836" translate="yes" xml:space="preserve">
          <source>An empty path is classified as a relative path.</source>
          <target state="translated">Un camino vacío se clasifica como un camino relativo.</target>
        </trans-unit>
        <trans-unit id="96c80c138bff7aa336c0c80903e065616c06546c" translate="yes" xml:space="preserve">
          <source>An empty range is lexicographically</source>
          <target state="translated">Un rango vacío es lexicográficamente</target>
        </trans-unit>
        <trans-unit id="c5d73f72c6721b75502428576903171289a2fc14" translate="yes" xml:space="preserve">
          <source>An empty shared_ptr (where &lt;code&gt;use_count() == 0&lt;/code&gt;) may store a non-null pointer accessible by &lt;code&gt;get()&lt;/code&gt;, e.g. if it were created using the aliasing constructor.</source>
          <target state="translated">Un shared_ptr vac&amp;iacute;o (donde &lt;code&gt;use_count() == 0&lt;/code&gt; ) puede almacenar un puntero no nulo accesible por &lt;code&gt;get()&lt;/code&gt; , por ejemplo, si se cre&amp;oacute; utilizando el constructor de alias.</target>
        </trans-unit>
        <trans-unit id="bf3e0e6688aa2181023a253a9e87db009478a78e" translate="yes" xml:space="preserve">
          <source>An empty string if the character sequence is not a valid collating element</source>
          <target state="translated">Una cadena vacía si la secuencia de caracteres no es un elemento de cotejo válido</target>
        </trans-unit>
        <trans-unit id="3d82664471aad182109ca58741b1d45d1271d6cf" translate="yes" xml:space="preserve">
          <source>An enumeration is defined by</source>
          <target state="translated">Una enumeración se define por</target>
        </trans-unit>
        <trans-unit id="afe5baa45aa238529a9d9f5521326fb55bc4227f" translate="yes" xml:space="preserve">
          <source>An equivalent effect may be achieved with the facilities provided by &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se puede lograr un efecto equivalente con las facilidades proporcionadas por &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;packaged_task&quot;&gt;std::packaged_task&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26b27f109fdc73d104fb47c91bb0233ff5e7c5ad" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;std::strong_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares every member of a class, except in order that is different from the default (here: last name first).</source>
          <target state="translated">Un ejemplo de un operador personalizado &amp;lt;=&amp;gt; que devuelve &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt; &lt;code&gt;std::strong_ordering&lt;/code&gt; &lt;/a&gt; es un operador que compara cada miembro de una clase, excepto en un orden diferente al predeterminado (aqu&amp;iacute;: apellido primero).</target>
        </trans-unit>
        <trans-unit id="e794383d64707bd6aee1a7ffa3033ac34c3317b6" translate="yes" xml:space="preserve">
          <source>An example of a custom operator&amp;lt;=&amp;gt; that returns &lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt;&lt;code&gt;std::weak_ordering&lt;/code&gt;&lt;/a&gt; is an operator that compares string members of a class in case-insensitive manner: this is different from the default comparison (so a custom operator is required) and it's possible to distinguish two strings that compare equal under this comparison.</source>
          <target state="translated">Un ejemplo de un operador personalizado &amp;lt;=&amp;gt; que devuelve &lt;a href=&quot;../utility/compare/weak_ordering&quot;&gt; &lt;code&gt;std::weak_ordering&lt;/code&gt; &lt;/a&gt; es un operador que compara miembros de cadena de una clase sin distinci&amp;oacute;n entre may&amp;uacute;sculas y min&amp;uacute;sculas: esto es diferente de la comparaci&amp;oacute;n predeterminada (por lo que se requiere un operador personalizado) y es posible distinguir dos cadenas que se comparan igual bajo esta comparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bc3fdebc617a723576859b7b78597b5a6e61e62e" translate="yes" xml:space="preserve">
          <source>An example of a type that implements LegacyOutputIterator is &lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std::ostream_iterator&lt;/a&gt;.</source>
          <target state="translated">Un ejemplo de un tipo que implementa LegacyOutputIterator es &lt;a href=&quot;../iterator/ostream_iterator&quot;&gt;std :: ostream_iterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="831c258222c425472a6e48db4facf3170a3cef28" translate="yes" xml:space="preserve">
          <source>An example of an inheritance hierarchy with virtual base classes is the iostreams hierarchy of the standard library: &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; using virtual inheritance. &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; is derived from both &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt;, so every instance of &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; contains a &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; subobject, a &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; subobject, and just one &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; subobject (and, consequently, one &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Un ejemplo de una jerarqu&amp;iacute;a de herencia con clases base virtuales es la jerarqu&amp;iacute;a de iostreams de la biblioteca est&amp;aacute;ndar: &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; se derivan de &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; usando herencia virtual. &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; se deriva de ambos &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; , por lo que cada instancia de &lt;code&gt;&lt;a href=&quot;../io/basic_iostream&quot;&gt;std::iostream&lt;/a&gt;&lt;/code&gt; contiene un &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; subobjeto, un &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; subobjeto, y s&amp;oacute;lo uno &lt;code&gt;&lt;a href=&quot;../io/basic_ios&quot;&gt;std::ios&lt;/a&gt;&lt;/code&gt; subobjeto ( y, en consecuencia, un &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="41464d61485a2aac603dadcdf39c0ce3781751e5" translate="yes" xml:space="preserve">
          <source>An example of when such declaration is used is the implementation of &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Un ejemplo de cu&amp;aacute;ndo se usa dicha declaraci&amp;oacute;n es la implementaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../types/is_function&quot;&gt;std::is_function&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdba113faa387d1ab71c87afef4ec469f4cc925c" translate="yes" xml:space="preserve">
          <source>An example where int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; is used is the &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; library: the expression &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; first creates a guard object and records the number of uncaught exceptions in its constructor. The output is performed by the guard object's destructor unless foo() throws (in which case the number of uncaught exceptions in the destructor is greater than what the constructor observed).</source>
          <target state="translated">Un ejemplo en el que se usa int-return &lt;code&gt;uncaught_exceptions&lt;/code&gt; es la biblioteca &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; : la expresi&amp;oacute;n &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; primero crea un objeto protector y registra el n&amp;uacute;mero de excepciones no detectadas en su constructor. El destructor del objeto de protecci&amp;oacute;n realiza la salida a menos que arroje foo () (en cuyo caso, el n&amp;uacute;mero de excepciones no detectadas en el destructor es mayor de lo que observ&amp;oacute; el constructor).</target>
        </trans-unit>
        <trans-unit id="3c376fdb08a2c546d5e0e5f8f44feb92df5bc392" translate="yes" xml:space="preserve">
          <source>An example where int-returning &lt;code&gt;uncaught_exceptions&lt;/code&gt; is used is the &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/log/doc/html/index.html&quot;&gt;boost.log&lt;/a&gt; library: the expression &lt;code&gt;BOOST_LOG(logger) &amp;lt;&amp;lt; foo();&lt;/code&gt; first creates a guard object and records the number of uncaught exceptions in its constructor. The output is performed by the guard object's destructor unless foo() throws (in which case the number of uncaught exceptions in the destructor is greater than what the constructor observed).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b085b3ecbb54c70910e25f3896da20b2a187a73" translate="yes" xml:space="preserve">
          <source>An exception can be thrown by a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;, &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;, &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, &lt;a href=&quot;../memory/new/operator_new&quot;&gt;allocation function&lt;/a&gt;, and any of the standard library functions that are specified to throw exceptions to signal certain error conditions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt;, etc).</source>
          <target state="translated">Una excepci&amp;oacute;n puede ser lanzada por una funci&amp;oacute;n &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt; , &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; , &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; , &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; , de &lt;a href=&quot;../memory/new/operator_new&quot;&gt;asignaci&amp;oacute;n&lt;/a&gt; , y cualquiera de las funciones de biblioteca est&amp;aacute;ndar que se especifican para lanzar excepciones para se&amp;ntilde;alar ciertas condiciones de error (por ejemplo, &lt;code&gt;&lt;a href=&quot;../container/vector/at&quot;&gt;std::vector::at&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/basic_string/substr&quot;&gt;std::string::substr&lt;/a&gt;&lt;/code&gt; , etc.).</target>
        </trans-unit>
        <trans-unit id="734db5e27654b7a1a090879aa79155ed3b4b2a8b" translate="yes" xml:space="preserve">
          <source>An exception is thrown if &lt;code&gt;*this&lt;/code&gt; has no shared state or &lt;code&gt;get_future&lt;/code&gt; has already been called. To get multiple &quot;pop&quot; ends of the promise-future communication channel, use &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se produce una excepci&amp;oacute;n si &lt;code&gt;*this&lt;/code&gt; no tiene un estado compartido o &lt;code&gt;get_future&lt;/code&gt; ya se ha llamado a get_future . Para obtener m&amp;uacute;ltiples &quot;pop&quot; finales del canal de comunicaci&amp;oacute;n promesa-futuro, use &lt;code&gt;&lt;a href=&quot;../future/share&quot;&gt;std::future::share&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="44db7b4c1aff9b2986166f1068a5b7109c799860" translate="yes" xml:space="preserve">
          <source>An exception is thrown if there is no shared state or the shared state already stores a value or exception.</source>
          <target state="translated">Se lanza una excepción si no hay un estado compartido o el estado compartido ya almacena un valor o una excepción.</target>
        </trans-unit>
        <trans-unit id="400934141b26ebdcfa01b232809e28da4e1614d3" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; to a reference type fails the run-time check (e.g. because the types are not related by inheritance), and also from &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; if the requested facet does not exist in the locale.</source>
          <target state="translated">Se produce una excepci&amp;oacute;n de este tipo cuando un &lt;a href=&quot;../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt; a un tipo de referencia falla la comprobaci&amp;oacute;n de tiempo de ejecuci&amp;oacute;n (por ejemplo, porque los tipos no est&amp;aacute;n relacionados por herencia), y tambi&amp;eacute;n desde &lt;code&gt;&lt;a href=&quot;../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&lt;/code&gt; si la faceta solicitada no existe en la configuraci&amp;oacute;n regional.</target>
        </trans-unit>
        <trans-unit id="3e10eeb3d50b8941ecde1bf2d5b08ad5eba672d1" translate="yes" xml:space="preserve">
          <source>An exception of this type is thrown when a &lt;a href=&quot;../language/typeid&quot;&gt;&lt;code&gt;typeid&lt;/code&gt;&lt;/a&gt; operator is applied to a dereferenced null pointer value of a polymorphic type.</source>
          <target state="translated">Se produce una excepci&amp;oacute;n de este tipo cuando se aplica un operador &lt;a href=&quot;../language/typeid&quot;&gt; &lt;code&gt;typeid&lt;/code&gt; &lt;/a&gt; a un valor de puntero nulo desreferenciado de un tipo polim&amp;oacute;rfico.</target>
        </trans-unit>
        <trans-unit id="392a7913172c4bf28f4342b2ce3e240403f2f75f" translate="yes" xml:space="preserve">
          <source>An explanatory message for the stored error code and error category.</source>
          <target state="translated">Un mensaje explicativo para el código de error almacenado y la categoría de error.</target>
        </trans-unit>
        <trans-unit id="d5eabc2515cac7175770538d9fd2aca675f84744" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) prevents implicit instantiations: the code that would otherwise cause an implicit instantiation has to use the explicit instantiation definition provided somewhere else in the program.</source>
          <target state="translated">Una declaración de instanciación explícita (una plantilla externa)evita las instanciacones implícitas:el código que de otro modo causaría una instanciación implícita tiene que usar la definición de instanciación explícita proporcionada en otra parte del programa.</target>
        </trans-unit>
        <trans-unit id="33cd7a0177e9f7ec5c231dde735e35e1a0d3fb00" translate="yes" xml:space="preserve">
          <source>An explicit instantiation declaration (an extern template) skips implicit instantiation step: the code that would otherwise cause an implicit instantiation instead uses the explicit instantiation definition provided elsewhere (resulting in link errors if no such instantiation exists). This can be used to reduce compilation times by explicitly declaring a template instantiation in all but one of the source files using it, and explicitly defining it in the remaining file.</source>
          <target state="translated">Una declaración de instanciación explícita (una plantilla externa)salta el paso de la instanciación implícita:el código que de otro modo causaría una instanciación implícita utiliza en su lugar la definición de instanciación explícita proporcionada en otro lugar (lo que da lugar a errores de enlace si no existe tal instanciación).Esto puede utilizarse para reducir los tiempos de compilación declarando explícitamente una instanciación de plantilla en todos los archivos fuente que la utilizan,excepto en uno,y definiéndola explícitamente en el archivo restante.</target>
        </trans-unit>
        <trans-unit id="133c2fb50577da662edeff998e62d6b70b901935" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the class, struct, or union they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the entire program.</source>
          <target state="translated">Una definición explícita de instanciación obliga a la instanciación de la clase,estructura o unión a la que se refieren.Puede aparecer en el programa en cualquier lugar después de la definición de la plantilla,y para una determinada lista de argumentos,sólo se permite que aparezca una vez en todo el programa.</target>
        </trans-unit>
        <trans-unit id="c3fb00f7b63425b442d1cc0c31f1edb4322117c1" translate="yes" xml:space="preserve">
          <source>An explicit instantiation definition forces instantiation of the function or member function they refer to. It may appear in the program anywhere after the template definition, and for a given argument-list, is only allowed to appear once in the program.</source>
          <target state="translated">Una definición explícita de instanciación obliga a instanciar la función o la función miembro a la que se refieren.Puede aparecer en el programa en cualquier lugar después de la definición de la plantilla,y para una determinada lista de argumentos,sólo se permite que aparezca una vez en el programa.</target>
        </trans-unit>
        <trans-unit id="c9c128e72c9b832e8384315ba572027dc359efd3" translate="yes" xml:space="preserve">
          <source>An explicit specialization cannot be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">Una especializaci&amp;oacute;n expl&amp;iacute;cita no puede ser una &lt;a href=&quot;friend&quot;&gt;declaraci&amp;oacute;n de amigo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a4ebeb793310cf18619b24eeafbc2e6fd5d0c1f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a function template is inline only if it is declared with the &lt;a href=&quot;inline&quot;&gt;inline specifier&lt;/a&gt; (or defined as deleted), it doesn't matter if the primary template is inline.</source>
          <target state="translated">Una especializaci&amp;oacute;n expl&amp;iacute;cita de una plantilla de funci&amp;oacute;n est&amp;aacute; en l&amp;iacute;nea solo si se declara con el &lt;a href=&quot;inline&quot;&gt;especificador en l&amp;iacute;nea&lt;/a&gt; (o se define como eliminada), no importa si la plantilla primaria est&amp;aacute; en l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="ad7859780f7fda205f962953901c88030d43e65f" translate="yes" xml:space="preserve">
          <source>An explicit specialization of a static data member of a template is a definition if the declaration includes an initializer; otherwise, it is a declaration. These definitions must use braces for default initialization:</source>
          <target state="translated">Una especialización explícita de un miembro de datos estáticos de una plantilla es una definición si la declaración incluye un inicializador;de lo contrario,es una declaración.Estas definiciones deben utilizar corchetes para la inicialización por defecto:</target>
        </trans-unit>
        <trans-unit id="f5646484a04d1f69f62bdf5309c5a9d249438cc5" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is</source>
          <target state="translated">Una expresi&amp;oacute;n &lt;code&gt;e&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="11f8c98f192821781cccabf62455469b73d17864" translate="yes" xml:space="preserve">
          <source>An expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">Se dice que una expresi&amp;oacute;n &lt;code&gt;e&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="34f74cee143d788f51fcc25acc797aea92c197b8" translate="yes" xml:space="preserve">
          <source>An expression followed by a semicolon is a statement.</source>
          <target state="translated">Una expresión seguida de un punto y coma es una declaración.</target>
        </trans-unit>
        <trans-unit id="f703e5af31c537ec73c27f6089a222ac20a91c8b" translate="yes" xml:space="preserve">
          <source>An expression is</source>
          <target state="translated">Una expresión es</target>
        </trans-unit>
        <trans-unit id="c5756e59953f27f7802c2879dfb5bf8b2ef537aa" translate="yes" xml:space="preserve">
          <source>An expression is a sequence of</source>
          <target state="translated">Una expresión es una secuencia de</target>
        </trans-unit>
        <trans-unit id="8582e3c88de4617441467faab5ff600afdf1bfb6" translate="yes" xml:space="preserve">
          <source>An expression statement without an expression is called a</source>
          <target state="translated">Una declaración de expresión sin una expresión se llama</target>
        </trans-unit>
        <trans-unit id="ba931ef941c10e68e24584826bf3e7b5e908486f" translate="yes" xml:space="preserve">
          <source>An expression that designates a &lt;a href=&quot;bit_field&quot;&gt;bit field&lt;/a&gt; (e.g. &lt;code&gt;a.m&lt;/code&gt;, where &lt;code&gt;a&lt;/code&gt; is an lvalue of type &lt;code&gt;struct A { int m: 3; }&lt;/code&gt;) is an lvalue expression: it may be used as the left-hand operand of the assignment operator, but its address cannot be taken and a non-const lvalue reference cannot be bound to it. A const lvalue reference can be initialized from a bit-field lvalue, but a temporary copy of the bit-field will be made: it won't bind to the bit field directly.</source>
          <target state="translated">Una expresi&amp;oacute;n que designa un &lt;a href=&quot;bit_field&quot;&gt;campo de bits&lt;/a&gt; (p &lt;code&gt;a.m&lt;/code&gt; Ej . , Am , donde &lt;code&gt;a&lt;/code&gt; es un valor de tipo &lt;code&gt;struct A { int m: 3; }&lt;/code&gt; ) es una expresi&amp;oacute;n de valor de valor: puede usarse como el operando de la izquierda del operador de asignaci&amp;oacute;n, pero su no se puede tomar la direcci&amp;oacute;n y no se puede vincular una referencia de valor no constante. Se puede inicializar una referencia de valor constante a partir de un valor de campo de bit, pero se realizar&amp;aacute; una copia temporal del campo de bit: no se unir&amp;aacute; directamente al campo de bit.</target>
        </trans-unit>
        <trans-unit id="95fcc97496d0a23551b56ed465f2ec32a136ce51" translate="yes" xml:space="preserve">
          <source>An identifier can be used &lt;a href=&quot;declarations&quot;&gt;to name&lt;/a&gt; objects, references, functions, enumerators, types, class members, namespaces, templates, template specializations, parameter packs, goto labels, and other entities, with the following exceptions:</source>
          <target state="translated">Se puede usar un identificador &lt;a href=&quot;declarations&quot;&gt;para nombrar&lt;/a&gt; objetos, referencias, funciones, enumeradores, tipos, miembros de la clase, espacios de nombres, plantillas, especializaciones de plantillas, paquetes de par&amp;aacute;metros, etiquetas Goto y otras entidades, con las siguientes excepciones:</target>
        </trans-unit>
        <trans-unit id="f6eb1c54d1e440abd120bdddffed4feee0d07b20" translate="yes" xml:space="preserve">
          <source>An identifier that names a variable, a function, specialization of a &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) or an enumerator can be used as an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;. The result of an expression consisting of just the identifier is the entity named by the identifier. The &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of the expression is</source>
          <target state="translated">Un identificador que nombra una variable, una funci&amp;oacute;n, la especializaci&amp;oacute;n de un &lt;a href=&quot;constraints&quot;&gt;concepto&lt;/a&gt; (desde C ++ 20) o un enumerador puede usarse como una &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; . El resultado de una expresi&amp;oacute;n que consiste solo en el identificador es la entidad nombrada por el identificador. La &lt;a href=&quot;value_category&quot;&gt;categor&amp;iacute;a&lt;/a&gt; de valor de la expresi&amp;oacute;n es</target>
        </trans-unit>
        <trans-unit id="2bea22f245aad6a1bbd96dbe721e6bfbb9cba55e" translate="yes" xml:space="preserve">
          <source>An immediate function is a constexpr function, and must satisfy the requirements applicable to &lt;a href=&quot;constexpr&quot;&gt;constexpr functions or constexpr constructors&lt;/a&gt;, as the case may be.</source>
          <target state="translated">Una funci&amp;oacute;n inmediata es una funci&amp;oacute;n constexpr y debe cumplir los requisitos aplicables a &lt;a href=&quot;constexpr&quot;&gt;las funciones constexpr o constructores constexpr&lt;/a&gt; , seg&amp;uacute;n sea el caso.</target>
        </trans-unit>
        <trans-unit id="252a155693a85c4513362e41870c607628599139" translate="yes" xml:space="preserve">
          <source>An implementation cannot declare additional non-static data members that would occupy storage disjoint from the real and imaginary components, and must ensure that the class template specialization does not contain any padding. The implementation must also ensure that optimizations to array access account for the possibility that a pointer to &lt;code&gt;value_type&lt;/code&gt; may be aliasing a &lt;code&gt;std::complex&lt;/code&gt; specialization or array thereof.</source>
          <target state="translated">Una implementaci&amp;oacute;n no puede declarar miembros de datos no est&amp;aacute;ticos adicionales que ocupar&amp;iacute;an un almacenamiento disjunto de los componentes reales e imaginarios, y debe asegurarse de que la especializaci&amp;oacute;n de plantilla de clase no contenga ning&amp;uacute;n relleno. La implementaci&amp;oacute;n tambi&amp;eacute;n debe garantizar que las optimizaciones para el acceso a la matriz tengan en cuenta la posibilidad de que un puntero a &lt;code&gt;value_type&lt;/code&gt; pueda estar aliasando una especializaci&amp;oacute;n &lt;code&gt;std::complex&lt;/code&gt; o matriz de la misma.</target>
        </trans-unit>
        <trans-unit id="b36215737bc9acc94a1181b9b9fc0edbe7c6e8eb" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">Una implementaci&amp;oacute;n de &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; para un tipo definido por el usuario.</target>
        </trans-unit>
        <trans-unit id="5f56c2af44fa6aea68d66ab4f981e253c1870786" translate="yes" xml:space="preserve">
          <source>An implementation of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; for a user-defined type.</source>
          <target state="translated">Una implementaci&amp;oacute;n del &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; para un tipo definido por el usuario.</target>
        </trans-unit>
        <trans-unit id="8e1b5b99aec49dc279b82a189df1e4e71765f759" translate="yes" xml:space="preserve">
          <source>An implementation of the spherical harmonic function is &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;available in boost.math&lt;/a&gt;, and it reduces to this function when called with the parameter phi set to zero.</source>
          <target state="translated">Una implementaci&amp;oacute;n de la funci&amp;oacute;n arm&amp;oacute;nica esf&amp;eacute;rica est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;disponible en boost.math&lt;/a&gt; , y se reduce a esta funci&amp;oacute;n cuando se llama con el par&amp;aacute;metro phi establecido en cero.</target>
        </trans-unit>
        <trans-unit id="6ef6f4ff8cf4b3091eca3ca55f5f34c2dba25629" translate="yes" xml:space="preserve">
          <source>An implementation of the spherical harmonic function is &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/sf_poly/sph_harm.html&quot;&gt;available in boost.math&lt;/a&gt;, and it reduces to this function when called with the parameter phi set to zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05f3d51d05cc3d2c938b7773b2a75528f0f533a8" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e8a80dd8b49b57fd0af28cb5b6f9eab92b003670" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="463a45be898237901d9e95795630e24b7725815f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a328d339a02fcd8f09757618757e341adcf6caf4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05afb78eee87d60d6affed2bb5d378e94152fda4" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="14e04477fae2c219d4ca4910e671ec277e96650f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23aab2406e44d22254e76892b9bb67f949035f8f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6d6d6fb65c08ea8df15db6341e3a63d4c3b1cb08" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a8f1f0a1677f6760e20f47ca31a1260d73446bbf" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="172a3359b3bc94067fe1ce4e3994c6fccab63962" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c3f9ea786832c07ac6ee8f2a1cf1bab37d07067f" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="023d43dc101a8f0e0055a1bbe7ca05f32647f8f2" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1416c6c581d2a16bec76ecd9c479fdd72d0c8646" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7a97e935596f5c5ad772a94c524a08ecf79d480" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt; as &lt;code&gt;boost::math::legendre_p&lt;/code&gt;, except that the boost.math definition includes the Condon-Shortley phase term.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;disponible en boost.math&lt;/a&gt; como &lt;code&gt;boost::math::legendre_p&lt;/code&gt; , excepto que la definici&amp;oacute;n boost.math incluye el t&amp;eacute;rmino de fase Condon-Shortley.</target>
        </trans-unit>
        <trans-unit id="1b94dc33e3c2677817a24c87c5ae3eefdf3888b7" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="translated">Una implementaci&amp;oacute;n de esta funci&amp;oacute;n tambi&amp;eacute;n est&amp;aacute; &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;disponible en boost.math&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4376b52a3b698d01342890c645e63be771774af" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_1.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b60467ab6c0631a5664cf0494d5a0ca49e6e52f1" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52edf4f2bf1751043ad31c41a6c11b35f270bfcb" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a7b5eda0bb25aa403ce524620df1896aebc5bcd" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_60_0/libs/math/doc/html/math_toolkit/zetas/zeta.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aeeb2ecef2e098cd110869669dbedfb641d1e82" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/bessel_first.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4bbb817d2363546432c72ec47562034e62b930c" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/mbessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5bcaa2e77d6da4f3fa4ce84e311bb065df9b7be" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/1_62_0/libs/math/doc/html/math_toolkit/bessel/sph_bessel.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="583558c1ff06b0561d4406d21632ee55c2b6f356" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_2.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c47a9490a77b892440d4dd4af49e877b2a9df1a" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/ellint/ellint_3.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="659dcb29046fa05710b38a8fb1931ec898ae5519" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/expint/expint_i.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf8d66df175707d6c72a60a41c20ae8c99e0d86e" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_beta/beta_function.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39da4171238400ac3f8feb8e52e5f753d1bd1fb7" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/hermite.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbdbc8151f3002ecfb8833c5c5c3125beb8e1447" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/laguerre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e14b6f00e0b4e1eb1ae3b23159f9339d5a211c3" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt; as &lt;code&gt;boost::math::legendre_p&lt;/code&gt;, except that the boost.math definition includes the Condon-Shortley phase term.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dde4c238b03e2f7efad8438d5c040e7628566cfd" translate="yes" xml:space="preserve">
          <source>An implementation of this function is also &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/math/doc/html/math_toolkit/sf_poly/legendre.html&quot;&gt;available in boost.math&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6484905546dbda0376c3234e4af32b4774ac948c" translate="yes" xml:space="preserve">
          <source>An incompletely-defined object type can be completed:</source>
          <target state="translated">Se puede completar un tipo de objeto definido de forma incompleta:</target>
        </trans-unit>
        <trans-unit id="034496cba173d751719f86a31427ebfaf5a3c429" translate="yes" xml:space="preserve">
          <source>An inline namespace is a namespace that uses the optional keyword &lt;code&gt;inline&lt;/code&gt; in its</source>
          <target state="translated">Un espacio de nombres en l&amp;iacute;nea es un espacio de nombres que utiliza la palabra clave opcional en &lt;code&gt;inline&lt;/code&gt; en su</target>
        </trans-unit>
        <trans-unit id="14113ff7972f0e79ae2bcb3f11df635a03888186" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the copy of &lt;code&gt;e&lt;/code&gt;, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Una instancia de &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; contiene una referencia a la copia de &lt;code&gt;e&lt;/code&gt; , a una instancia de &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; o a una instancia de &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; (consulte &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ba236b1f1a8d82abf0083dac8c36782f2303388c" translate="yes" xml:space="preserve">
          <source>An instance of &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; holding a reference to the exception object, or a copy of the exception object, or to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; or to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Una instancia de &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; contiene una referencia al objeto de excepci&amp;oacute;n, o una copia del objeto de excepci&amp;oacute;n, o una instancia de &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; o una instancia de &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fbb0b241c865dd210a0103cf5d2af8c3a3e8a71" translate="yes" xml:space="preserve">
          <source>An integer greater than zero if the stream is wide-oriented after this call, less than zero if the stream is byte-oriented after this call, and zero if the stream has no orientation.</source>
          <target state="translated">Un número entero mayor que cero si el flujo está orientado al ancho después de esta llamada,menos de cero si el flujo está orientado a los bytes después de esta llamada,y cero si el flujo no tiene orientación.</target>
        </trans-unit>
        <trans-unit id="27a4b795995133a65c00f00e3a5c86747c696bf8" translate="yes" xml:space="preserve">
          <source>An integer literal is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt; of the form.</source>
          <target state="translated">Un literal entero es una &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;expresi&amp;oacute;n primaria&lt;/a&gt; de la forma.</target>
        </trans-unit>
        <trans-unit id="22296b3029f90df1ec990b3a781242c55d5beaa6" translate="yes" xml:space="preserve">
          <source>An integer type which can be accessed as an atomic entity even in the presence of asynchronous interrupts made by signals.</source>
          <target state="translated">Un tipo entero al que se puede acceder como entidad atómica incluso en presencia de interrupciones asincrónicas hechas por señales.</target>
        </trans-unit>
        <trans-unit id="5018516b14deb056aa79dc2efd7d50ff7637de58" translate="yes" xml:space="preserve">
          <source>An invalid (in the current C locale) multibyte character was encountered.</source>
          <target state="translated">Se encontró un personaje multibyte inválido (en la actual localidad C).</target>
        </trans-unit>
        <trans-unit id="6a1cb2e740b1d006f9942d3f948b281b6ec84075" translate="yes" xml:space="preserve">
          <source>An invalid multibyte character (according to the current C locale) was encountered. &lt;code&gt;src&lt;/code&gt; is set to point at the beginning of the first unconverted multibyte character.</source>
          <target state="translated">Se encontr&amp;oacute; un car&amp;aacute;cter multibyte no v&amp;aacute;lido (de acuerdo con la configuraci&amp;oacute;n regional C actual). &lt;code&gt;src&lt;/code&gt; est&amp;aacute; configurado para apuntar al comienzo del primer car&amp;aacute;cter multibyte no convertido.</target>
        </trans-unit>
        <trans-unit id="e0fbbc7a96cda105d7e43e6ea9e384c88eb8bd01" translate="yes" xml:space="preserve">
          <source>An invalid simple-template-id is a compile-time error, unless it names a function template specialization (in which case &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; may apply).</source>
          <target state="translated">Una identificaci&amp;oacute;n de plantilla simple no v&amp;aacute;lida es un error en tiempo de compilaci&amp;oacute;n, a menos que nombre una especializaci&amp;oacute;n de plantilla de funci&amp;oacute;n (en cuyo caso puede aplicarse &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="738a0c3fdce4b2a8db1475951201c5a23036b195" translate="yes" xml:space="preserve">
          <source>An invariant of &lt;code&gt;zoned_time&lt;/code&gt; is that it always refers to a valid time zone and represents an existing and unambiguous time point in that time zone. Consistent with this invariant, &lt;code&gt;zoned_time&lt;/code&gt; has no move constructor or move assignment operator; attempts to move a &lt;code&gt;zoned_time&lt;/code&gt; will perform a copy.</source>
          <target state="translated">Una invariante de &lt;code&gt;zoned_time&lt;/code&gt; es que siempre se refiere a una zona horaria v&amp;aacute;lida y representa un punto de tiempo existente e inequ&amp;iacute;voco en esa zona horaria. De acuerdo con esta invariante, &lt;code&gt;zoned_time&lt;/code&gt; no tiene constructor de movimiento ni operador de asignaci&amp;oacute;n de movimiento; Los intentos de mover un &lt;code&gt;zoned_time&lt;/code&gt; realizar&amp;aacute;n una copia.</target>
        </trans-unit>
        <trans-unit id="ff8ec771a3e408dd089882b2303398b60f16d16a" translate="yes" xml:space="preserve">
          <source>An invocation of an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; is always evaluated, even in an unevaluated operand.</source>
          <target state="translated">La invocaci&amp;oacute;n de una &lt;a href=&quot;consteval&quot;&gt;funci&amp;oacute;n inmediata&lt;/a&gt; siempre se eval&amp;uacute;a, incluso en un operando no evaluado.</target>
        </trans-unit>
        <trans-unit id="30e4b56dc9d38cfe9d66956b6e4aed328bf1c204" translate="yes" xml:space="preserve">
          <source>An invocation of an immediate function whose innermost non-block scope is not a &lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;function parameter scope&lt;/a&gt; of an immediate function must produce a constant expression; such an invocation (known as an</source>
          <target state="translated">Una invocaci&amp;oacute;n de una funci&amp;oacute;n inmediata cuyo alcance no bloqueado m&amp;aacute;s interno no es un &lt;a href=&quot;scope#Function_parameter_scope&quot;&gt;par&amp;aacute;metro de funci&amp;oacute;n alcance&lt;/a&gt; de una funci&amp;oacute;n inmediata debe producir una expresi&amp;oacute;n constante; tal invocaci&amp;oacute;n (conocida como</target>
        </trans-unit>
        <trans-unit id="4706ad1f00d621a48d2e07b2a350e165dc71b6e6" translate="yes" xml:space="preserve">
          <source>An iterator pointing at the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Un iterador apuntando al mismo objeto que &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ef94e98b9aecdcf5a48dda0b6d175cdca4869ff" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character produced.</source>
          <target state="translated">Un iterador que apunta inmediatamente después del último personaje producido.</target>
        </trans-unit>
        <trans-unit id="a6f7df894c8448a1c11979a004ebd6ace3d75b98" translate="yes" xml:space="preserve">
          <source>An iterator pointing immediately after the last character recognized as a valid part of the monetary string input.</source>
          <target state="translated">Un iterador que apunta inmediatamente después del último carácter reconocido como parte válida de la entrada de la cadena monetaria.</target>
        </trans-unit>
        <trans-unit id="2ae3748a0356e1b6e535e66f5c4ffa0cfaff3539" translate="yes" xml:space="preserve">
          <source>An iterator pointing to the element following the erased element, or &lt;code&gt;end()&lt;/code&gt; if no such element exists.</source>
          <target state="translated">Un iterador que apunta al elemento que sigue al elemento borrado, o &lt;code&gt;end()&lt;/code&gt; si no existe dicho elemento.</target>
        </trans-unit>
        <trans-unit id="e831682f27c4215fd3d51adc3ab282760afa70fa" translate="yes" xml:space="preserve">
          <source>An iterator referring to the first &lt;code&gt;std::chrono::tzdb&lt;/code&gt; in the container.</source>
          <target state="translated">Un iterador que se refiere al primer &lt;code&gt;std::chrono::tzdb&lt;/code&gt; en el contenedor.</target>
        </trans-unit>
        <trans-unit id="7a63b694e4a7d314c8d05c5417ebc4bb1f31eb30" translate="yes" xml:space="preserve">
          <source>An iterator to the beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">Un iterador al principio de &lt;code&gt;c&lt;/code&gt; o &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02479c246c44225a9035a0d45997e83cce8420db" translate="yes" xml:space="preserve">
          <source>An iterator to the end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;. Note that the end of a container or array is defined as the element following the last valid element.</source>
          <target state="translated">Un iterador hasta el final de &lt;code&gt;c&lt;/code&gt; o &lt;code&gt;array&lt;/code&gt; . Tenga en cuenta que el final de un contenedor o matriz se define como el elemento que sigue al &amp;uacute;ltimo elemento v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="a11a64a7066be12c5192b1c7d9f47275f39b47d8" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-beginning of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">Un iterador a la inversa comienzo de &lt;code&gt;c&lt;/code&gt; o &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7197d58fc54a43b495f2accaea0f6922ad829bd" translate="yes" xml:space="preserve">
          <source>An iterator to the reverse-end of &lt;code&gt;c&lt;/code&gt; or &lt;code&gt;array&lt;/code&gt;.</source>
          <target state="translated">Un iterador al reverso de &lt;code&gt;c&lt;/code&gt; o &lt;code&gt;array&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="625c5f2464c30593f74840f1bd907c2068776afc" translate="yes" xml:space="preserve">
          <source>An iterator type whose category, value, difference, pointer and</source>
          <target state="translated">Un tipo de iterador cuya categoría,valor,diferencia,puntero y</target>
        </trans-unit>
        <trans-unit id="19a75628cf6442d77f6648e9556c5bb263d28280" translate="yes" xml:space="preserve">
          <source>An lvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an lvalue reference&lt;/a&gt;; this associates a new name with the object identified by the expression.</source>
          <target state="translated">Se puede usar un valor para &lt;a href=&quot;reference_initialization&quot;&gt;inicializar una referencia de valor&lt;/a&gt; ; esto asocia un nuevo nombre con el objeto identificado por la expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ca62ca28732e81cc9d1b6aa1ed666a055a48eb41" translate="yes" xml:space="preserve">
          <source>An object can contain other objects, which are called</source>
          <target state="translated">Un objeto puede contener otros objetos,que se llaman</target>
        </trans-unit>
        <trans-unit id="83df7119bca64cfa6a0dedb8658d0ab00a4eaf95" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_istream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; that performs input (both formatted and unformatted). Its constructor prepares the input stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, skips leading whitespace unless &lt;code&gt;noskipws&lt;/code&gt; flag is set, and performs other implementation-defined tasks if necessary. All cleanup, if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during input.</source>
          <target state="translated">Un objeto de la clase &lt;code&gt;basic_istream::sentry&lt;/code&gt; se construye en el &amp;aacute;mbito local al comienzo de cada funci&amp;oacute;n miembro de &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; que realiza la entrada (formateada y no formateada). Su constructor prepara la secuencia de entrada: comprueba si la secuencia ya est&amp;aacute; en un estado fallido, vac&amp;iacute;a las secuencias de salida tie () 'd, omite los espacios en blanco a menos que se &lt;code&gt;noskipws&lt;/code&gt; indicador noskipws y realiza otras tareas definidas por la implementaci&amp;oacute;n si es necesario. Toda la limpieza, si es necesario, se realiza en el destructor, de modo que se garantiza que suceda si se lanzan excepciones durante la entrada.</target>
        </trans-unit>
        <trans-unit id="823634b581a9cede4fd0ccc574bd7fa0bc24d634" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;basic_ostream::sentry&lt;/code&gt; is constructed in local scope at the beginning of each member function of &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; that performs output (both formatted and unformatted). Its constructor prepares the output stream: checks if the stream is already in a failed state, flushes the tie()'d output streams, and performs other implementation-defined tasks if necessary. Implementation-defined cleanup, as well as flushing of the output stream if necessary, is performed in the destructor, so that it is guaranteed to happen if exceptions are thrown during output.</source>
          <target state="translated">Un objeto de la clase &lt;code&gt;basic_ostream::sentry&lt;/code&gt; se construye en el &amp;aacute;mbito local al comienzo de cada funci&amp;oacute;n miembro de &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; que realiza la salida (formateada y no formateada). Su constructor prepara la secuencia de salida: comprueba si la secuencia ya est&amp;aacute; en un estado fallido, vac&amp;iacute;a las secuencias de salida tie () 'd y realiza otras tareas definidas por la implementaci&amp;oacute;n si es necesario. La limpieza definida por la implementaci&amp;oacute;n, as&amp;iacute; como el vaciado de la secuencia de salida si es necesario, se realiza en el destructor, de modo que se garantiza que suceda si se lanzan excepciones durante la salida.</target>
        </trans-unit>
        <trans-unit id="0455f9161322806dadb1a5a0172793f044ae30ea" translate="yes" xml:space="preserve">
          <source>An object of class &lt;code&gt;std::locale&lt;/code&gt; is an immutable indexed set of immutable facets. Each stream object of the C++ input/output library is associated with an &lt;code&gt;std::locale&lt;/code&gt; object and uses its facets for parsing and formatting of all data. In addition, a locale object is associated with each &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; object. Locale objects can also be used as predicates that perform string collation with the standard containers and algorithms and can be accessed directly to obtain or modify the facets they hold.</source>
          <target state="translated">Un objeto de la clase &lt;code&gt;std::locale&lt;/code&gt; es un conjunto indexado inmutable de facetas inmutables. Cada objeto de flujo de la biblioteca de entrada / salida de C ++ est&amp;aacute; asociado con un objeto &lt;code&gt;std::locale&lt;/code&gt; y usa sus facetas para analizar y formatear todos los datos. Adem&amp;aacute;s, un objeto local est&amp;aacute; asociado con cada objeto &lt;code&gt;&lt;a href=&quot;../regex/basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; . Los objetos locales tambi&amp;eacute;n se pueden usar como predicados que realizan la recopilaci&amp;oacute;n de cadenas con los contenedores y algoritmos est&amp;aacute;ndar y se puede acceder directamente para obtener o modificar las facetas que contienen.</target>
        </trans-unit>
        <trans-unit id="d66af98d41f06cecefd4af58c7d9c0ca924bcff6" translate="yes" xml:space="preserve">
          <source>An object of the type must be contextually convertible to bool. The effect of this conversion returns false if the value is equivalent to its null value and true otherwise.</source>
          <target state="translated">Un objeto de este tipo debe ser contextualmente convertible en bool.El efecto de esta conversión se devuelve falso si el valor es equivalente a su valor nulo y verdadero en caso contrario.</target>
        </trans-unit>
        <trans-unit id="7bacce28d1059e82c9739033111e220b4d8671d7" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Un objeto de tipo &lt;code&gt;&lt;a href=&quot;../../../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f0e2760523dc7073d44af20a277e7f5a90698df4" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;&amp;lt;value_type&amp;gt;</source>
          <target state="translated">Un objeto de tipo &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; &amp;lt;value_type&amp;gt;</target>
        </trans-unit>
        <trans-unit id="7bd18a30dbdab573b7c39639752708407fb37b52" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;To&lt;/code&gt; whose value representation is as described above.</source>
          <target state="translated">Un objeto de tipo &lt;code&gt;To&lt;/code&gt; cuya representaci&amp;oacute;n de valor es como se describe anteriormente.</target>
        </trans-unit>
        <trans-unit id="e81f259c6d82e8e50d80fae74008b6a20cb6f607" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;X::value_compare&lt;/code&gt; constructed out of the comparison object is returned.</source>
          <target state="translated">Se &lt;code&gt;X::value_compare&lt;/code&gt; un objeto de tipo X :: value_compare construido a partir del objeto de comparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7cce6a193570a048de83246c7b511f63641f001b" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; is a lightweight proxy object that provides access to an array of objects of type &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="translated">Un objeto de tipo &lt;code&gt;std::initializer_list&amp;lt;T&amp;gt;&lt;/code&gt; es un peso ligero objeto proxy que proporciona acceso a una gran variedad de objetos de tipo &lt;code&gt;const T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9033aa603f097747fd262291447f23ece9703946" translate="yes" xml:space="preserve">
          <source>An object of type &lt;code&gt;std::once_flag&lt;/code&gt; that is passed to multiple calls to &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; allows those calls to coordinate with each other such that only one of the calls will actually run to completion.</source>
          <target state="translated">Un objeto de tipo &lt;code&gt;std::once_flag&lt;/code&gt; que se pasa a varias llamadas a &lt;code&gt;&lt;a href=&quot;call_once&quot;&gt;std::call_once&lt;/a&gt;&lt;/code&gt; permite que esas llamadas se coordinen entre s&amp;iacute; de modo que solo una de las llamadas se ejecute realmente hasta su finalizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3bdae20fade93232b05ba74a9d73283a7dcdf8dd" translate="yes" xml:space="preserve">
          <source>An object of unspecified type such that any value can be assigned to it with no effect. Intended for use with &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; when unpacking a &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, as a placeholder for the arguments that are not used.</source>
          <target state="translated">Un objeto de tipo no especificado de modo que se le puede asignar cualquier valor sin efecto. Dise&amp;ntilde;ado para usar con &lt;code&gt;&lt;a href=&quot;tie&quot;&gt;std::tie&lt;/a&gt;&lt;/code&gt; al desempaquetar una &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , como marcador de posici&amp;oacute;n para los argumentos que no se usan.</target>
        </trans-unit>
        <trans-unit id="26b9967510dc89a341fa42ca83cfa44ef6ebf576" translate="yes" xml:space="preserve">
          <source>An object that is not a subobject of another object is called</source>
          <target state="translated">Un objeto que no es un subobjeto de otro objeto se llama</target>
        </trans-unit>
        <trans-unit id="858015fdff20dfb1bcca98de775349cd0072b086" translate="yes" xml:space="preserve">
          <source>An object, in C++, is a</source>
          <target state="translated">Un objeto,en C++,es un</target>
        </trans-unit>
        <trans-unit id="2f63388a843dce76eb6b22f8810249f3b38a691e" translate="yes" xml:space="preserve">
          <source>An optional object &lt;code&gt;op&lt;/code&gt; may be turned into an empty optional with both &lt;code&gt;op = {};&lt;/code&gt; and &lt;code&gt;op = nullopt;&lt;/code&gt;. The first expression constructs an empty &lt;code&gt;optional&lt;/code&gt; object with &lt;code&gt;{}&lt;/code&gt; and assigns it to &lt;code&gt;op&lt;/code&gt;.</source>
          <target state="translated">Un objeto opcional &lt;code&gt;op&lt;/code&gt; puede convertirse en un opcional vac&amp;iacute;o con ambos &lt;code&gt;op = {};&lt;/code&gt; y &lt;code&gt;op = nullopt;&lt;/code&gt; . La primera expresi&amp;oacute;n construye un objeto &lt;code&gt;optional&lt;/code&gt; vac&amp;iacute;o con &lt;code&gt;{}&lt;/code&gt; y lo asigna a &lt;code&gt;op&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb6a5327aa18d2bb8b350958dde2d290354f8030" translate="yes" xml:space="preserve">
          <source>An out-of-class definition of a member function template must be</source>
          <target state="translated">Una definición fuera de clase de una plantilla de funciones de los miembros debe ser</target>
        </trans-unit>
        <trans-unit id="7a79aaf703db97b5a7b0d58031c37912c2d8149a" translate="yes" xml:space="preserve">
          <source>An output iterator that writes successive elements into an output stream, separating adjacent elements with a delimiter</source>
          <target state="translated">Un iterador de salida que escribe elementos sucesivos en una corriente de salida,separando los elementos adyacentes con un delimitador</target>
        </trans-unit>
        <trans-unit id="7c1bcb6f6b9e1950eeb340e7b5a97c8ee444cb42" translate="yes" xml:space="preserve">
          <source>An output iterator to element past the last element copied.</source>
          <target state="translated">Un iterador de salida a elemento más allá del último elemento copiado.</target>
        </trans-unit>
        <trans-unit id="dc7304d0df5442d14acbaafb1a4c43fd8d0d9ec3" translate="yes" xml:space="preserve">
          <source>An overload &lt;code&gt;F(T_i)&lt;/code&gt; is only considered if the declaration &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; is valid for some invented variable &lt;code&gt;x&lt;/code&gt;;</source>
          <target state="translated">Una sobrecarga &lt;code&gt;F(T_i)&lt;/code&gt; solo se considera si la declaraci&amp;oacute;n &lt;code&gt;T_i x[] = { &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(t) };&lt;/code&gt; es v&amp;aacute;lido para alguna variable inventada &lt;code&gt;x&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="31a89ff54bf0a65e07ec5e6290a30f27bf9c83bf" translate="yes" xml:space="preserve">
          <source>An rvalue can't be used as the left-hand operand of the built-in assignment or compound assignment operators.</source>
          <target state="translated">Un valor no puede ser usado como el operando izquierdo de la asignación incorporada o de los operadores de la asignación compuesta.</target>
        </trans-unit>
        <trans-unit id="df8a77695e43a01d35ff3833e595deae1c70885b" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize a const lvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">Se puede usar un valor r para &lt;a href=&quot;reference_initialization&quot;&gt;inicializar una referencia de valor constante&lt;/a&gt; , en cuyo caso la vida &amp;uacute;til del objeto identificado por el valor r se &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extiende&lt;/a&gt; hasta que finalice el alcance de la referencia.</target>
        </trans-unit>
        <trans-unit id="0e072674017d2ac839c66e65b949d44d2466050e" translate="yes" xml:space="preserve">
          <source>An rvalue may be used to &lt;a href=&quot;reference_initialization&quot;&gt;initialize an rvalue reference&lt;/a&gt;, in which case the lifetime of the object identified by the rvalue is &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extended&lt;/a&gt; until the scope of the reference ends.</source>
          <target state="translated">Se puede usar &lt;a href=&quot;reference_initialization&quot;&gt;un valor r&lt;/a&gt; para inicializar una referencia de valor r , en cuyo caso la vida &amp;uacute;til del objeto identificado por el valor r se &lt;a href=&quot;reference_initialization#Lifetime_of_a_temporary&quot;&gt;extiende&lt;/a&gt; hasta que finalice el alcance de la referencia.</target>
        </trans-unit>
        <trans-unit id="9223b2493a48ecf49ed1c32238f5defa3e17a1e2" translate="yes" xml:space="preserve">
          <source>An rvalue reference to a cv-unqualified template parameter is not a &lt;a href=&quot;template_argument_deduction&quot;&gt;forwarding reference&lt;/a&gt; if that parameter is a class template parameter:</source>
          <target state="translated">Una referencia rvalue a un par&amp;aacute;metro de plantilla no calificado cv no es una &lt;a href=&quot;template_argument_deduction&quot;&gt;referencia de reenv&amp;iacute;o&lt;/a&gt; si ese par&amp;aacute;metro es un par&amp;aacute;metro de plantilla de clase:</target>
        </trans-unit>
        <trans-unit id="06c47888799c4beade0a1c880e7969d048a047e7" translate="yes" xml:space="preserve">
          <source>An rvalue reference to the element at relative location, that is, &lt;code&gt;std::move(base()[n])&lt;/code&gt;.</source>
          <target state="translated">Una referencia de valor de r al elemento en una ubicaci&amp;oacute;n relativa, es decir, &lt;code&gt;std::move(base()[n])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4431ce6b5c54a2464689bcd2649d6be6a6d6edb5" translate="yes" xml:space="preserve">
          <source>Analyzes the character sequence &lt;code&gt;[first,last)&lt;/code&gt; for a pattern described below. If no characters match the pattern or if the value obtained by parsing the matched characters is not representable in the type of &lt;code&gt;value&lt;/code&gt;, &lt;code&gt;value&lt;/code&gt; is unmodified, otherwise the characters matching the pattern are interpreted as a text representation of an arithmetic value, which is stored in &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Analiza la secuencia de caracteres &lt;code&gt;[first,last)&lt;/code&gt; para un patr&amp;oacute;n que se describe a continuaci&amp;oacute;n. Si ning&amp;uacute;n car&amp;aacute;cter coincide con el patr&amp;oacute;n o si el valor obtenido al analizar los caracteres coincidentes no es representable en el tipo de &lt;code&gt;value&lt;/code&gt; , el &lt;code&gt;value&lt;/code&gt; no se modifica; de lo contrario, los caracteres que coinciden con el patr&amp;oacute;n se interpretan como una representaci&amp;oacute;n de texto de un valor aritm&amp;eacute;tico, que se almacena en &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ffd735c77a58f5bee4802f3701c7f6fda3f232e" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value formerly held by &lt;code&gt;rv&lt;/code&gt; (&lt;code&gt;rv&lt;/code&gt; remains valid, but is in an unspecified state.).</source>
          <target state="translated">Y despu&amp;eacute;s de la evaluaci&amp;oacute;n, el valor de &lt;code&gt;*p&lt;/code&gt; es equivalente al valor que anteriormente ten&amp;iacute;a &lt;code&gt;rv&lt;/code&gt; ( &lt;code&gt;rv&lt;/code&gt; sigue siendo v&amp;aacute;lido, pero est&amp;aacute; en un estado no especificado).</target>
        </trans-unit>
        <trans-unit id="a5b3b63e68ab039e5e9a76fb79b51bc5995bb988" translate="yes" xml:space="preserve">
          <source>And after evaluation, the value of &lt;code&gt;*p&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;. The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">Y despu&amp;eacute;s de la evaluaci&amp;oacute;n, el valor de &lt;code&gt;*p&lt;/code&gt; es equivalente al valor de &lt;code&gt;v&lt;/code&gt; . El valor de &lt;code&gt;v&lt;/code&gt; no cambia.</target>
        </trans-unit>
        <trans-unit id="56b1a77f4fe21b0570e2813c8d454db94a7cb374" translate="yes" xml:space="preserve">
          <source>And if any &lt;a href=&quot;reference_initialization&quot;&gt;reference binding&lt;/a&gt; takes place, it is direct binding (not one that constructs a temporary object)</source>
          <target state="translated">Y si se produce un &lt;a href=&quot;reference_initialization&quot;&gt;enlace de referencia&lt;/a&gt; , es un enlace directo (no uno que construya un objeto temporal)</target>
        </trans-unit>
        <trans-unit id="c4c1b28f8418245c8009d38e2fd06aa2b822e70b" translate="yes" xml:space="preserve">
          <source>And, for every.</source>
          <target state="translated">Y,por cada uno.</target>
        </trans-unit>
        <trans-unit id="c8cb4cc17edf8c49a6c05da36754f248647a5429" translate="yes" xml:space="preserve">
          <source>And, given.</source>
          <target state="translated">Y,dado.</target>
        </trans-unit>
        <trans-unit id="78f82f2df8d5e45692f017f6cf128f97529f9a02" translate="yes" xml:space="preserve">
          <source>Anonymous unions</source>
          <target state="translated">Uniones anónimas</target>
        </trans-unit>
        <trans-unit id="f39f69aff078c2dee33a0b3c3af4837d3936bb7c" translate="yes" xml:space="preserve">
          <source>Anonymous unions have further restrictions: they cannot have member functions, cannot have static data members, and all their data members must be public. The only declarations allowed are non-static data members  and &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; declarations(since C++14).</source>
          <target state="translated">Los sindicatos an&amp;oacute;nimos tienen m&amp;aacute;s restricciones: no pueden tener funciones miembro, no pueden tener miembros de datos est&amp;aacute;ticos y todos sus miembros de datos deben ser p&amp;uacute;blicos. Las &amp;uacute;nicas declaraciones permitidas son miembros de datos no est&amp;aacute;ticos y declaraciones &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; (desde C ++ 14).</target>
        </trans-unit>
        <trans-unit id="79c7bbc8f686393ed4d5a563735506c51a1b8513" translate="yes" xml:space="preserve">
          <source>Another use for &lt;code&gt;std::weak_ptr&lt;/code&gt; is to break reference cycles formed by objects managed by &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. If such cycle is orphaned (i,e. there are no outside shared pointers into the cycle), the shared_ptr reference counts cannot reach zero and the memory is leaked. To prevent this, one of the pointers in the cycle can be made weak.</source>
          <target state="translated">Otro uso para &lt;code&gt;std::weak_ptr&lt;/code&gt; es romper los ciclos de referencia formados por objetos administrados por &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; . Si dicho ciclo es hu&amp;eacute;rfano (es decir, no hay punteros compartidos externos en el ciclo), los recuentos de referencia shared_ptr no pueden llegar a cero y la memoria se pierde. Para evitar esto, uno de los punteros en el ciclo puede debilitarse.</target>
        </trans-unit>
        <trans-unit id="899d67ebfae429b08b8eebcf8e8c9e086747304a" translate="yes" xml:space="preserve">
          <source>Another way to test if a floating-point value is NaN is to compare it with itself: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</source>
          <target state="translated">Otra forma de probar si un valor de punto flotante es NaN es compararlo consigo mismo: &lt;code&gt;bool is_nan(double x) { return x != x; }&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1f898bf7d5a8e88530be0282c53c70a4902e14d0" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;declarations&quot;&gt;simple declarations&lt;/a&gt; are allowed, except.</source>
          <target state="translated">Cualquier &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n simple&lt;/a&gt; est&amp;aacute; permitida, excepto.</target>
        </trans-unit>
        <trans-unit id="b7e1bdbe6a7f8ce733280e2254188bf3b1de8cb1" translate="yes" xml:space="preserve">
          <source>Any &lt;a href=&quot;function&quot;&gt;function declarations&lt;/a&gt; are allowed, with additional syntax elements that are only available for non-static member functions: &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; and &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; specifiers, &lt;a href=&quot;abstract_class&quot;&gt;pure-specifiers&lt;/a&gt;, cv-qualifiers, ref-qualifiers, and &lt;a href=&quot;constructor&quot;&gt;member initialization lists&lt;/a&gt;.</source>
          <target state="translated">Se permiten todas las &lt;a href=&quot;function&quot;&gt;declaraciones de funciones&lt;/a&gt; , con elementos de sintaxis adicionales que solo est&amp;aacute;n disponibles para funciones miembro no est&amp;aacute;ticas: especificadores &lt;a href=&quot;final&quot;&gt;finales&lt;/a&gt; y de &lt;a href=&quot;override&quot;&gt;anulaci&amp;oacute;n&lt;/a&gt; , especificadores &lt;a href=&quot;abstract_class&quot;&gt;puros&lt;/a&gt; , calificadores cv, calificadores ref y &lt;a href=&quot;constructor&quot;&gt;listas de inicializaci&amp;oacute;n de miembros&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8b49f8c4e0a542030094cffe671da5baa163695a" translate="yes" xml:space="preserve">
          <source>Any additional integral types needed by the typedefs in the header &lt;a href=&quot;../header/cstdint&quot;&gt;&lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cualquier tipo integral adicional que necesitan los typedefs en el encabezado &lt;a href=&quot;../header/cstdint&quot;&gt; &lt;code&gt;&amp;lt;cstdint&amp;gt;&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f08aea9a890f019823885a1075301ba39bc58d28" translate="yes" xml:space="preserve">
          <source>Any capture may appear only once:</source>
          <target state="translated">Cualquier captura puede aparecer sólo una vez:</target>
        </trans-unit>
        <trans-unit id="a6942cddecd7def2bc3a413a01b71ac46c41eb7d" translate="yes" xml:space="preserve">
          <source>Any character in the buffer which has been initialized, regardless of whether it originated from the string passed in the constructor or was appended by &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, is considered to be part of the input sequence.</source>
          <target state="translated">Cualquier car&amp;aacute;cter en el b&amp;uacute;fer que se haya inicializado, independientemente de si se origin&amp;oacute; a partir de la cadena pasada en el constructor o fue agregado por &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; , se considera parte de la secuencia de entrada.</target>
        </trans-unit>
        <trans-unit id="6e77be05deb9b5ecac58519844a0e640e7f8ea02" translate="yes" xml:space="preserve">
          <source>Any character sequence, except that it must not contain the closing sequence &lt;code&gt;)&lt;/code&gt;delimiter&lt;code&gt;&quot;&lt;/code&gt;</source>
          <target state="translated">Cualquier secuencia de caracteres, excepto que no debe contener la secuencia de cierre &lt;code&gt;)&lt;/code&gt; delimitador &lt;code&gt;&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e8037bc5cabc21aa1e4b299af2223a57b399d0e7" translate="yes" xml:space="preserve">
          <source>Any class type (whether declared with class-key&lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt;) may be declared as</source>
          <target state="translated">Cualquier tipo de clase (ya sea declarada con class-key &lt;code&gt;class&lt;/code&gt; o &lt;code&gt;struct&lt;/code&gt; ) puede declararse como</target>
        </trans-unit>
        <trans-unit id="3f8220613774bb0009e4140293deea0ebc75659a" translate="yes" xml:space="preserve">
          <source>Any declaration with an &lt;code&gt;extern&lt;/code&gt;&lt;a href=&quot;storage_duration&quot;&gt;storage class specifier&lt;/a&gt; or with a &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; specifier (such as &lt;code&gt;extern &quot;C&quot;&lt;/code&gt;) without an initializer</source>
          <target state="translated">Cualquier declaraci&amp;oacute;n con un &lt;a href=&quot;storage_duration&quot;&gt;especificador de clase de almacenamiento &lt;/a&gt; &lt;code&gt;extern&lt;/code&gt; o o con un especificador de &lt;a href=&quot;language_linkage&quot;&gt;enlace de idioma&lt;/a&gt; (como &lt;code&gt;extern &quot;C&quot;&lt;/code&gt; ) sin un inicializador</target>
        </trans-unit>
        <trans-unit id="7246de96efdd56306a5b292694e0b51ddecb8395" translate="yes" xml:space="preserve">
          <source>Any entity captured by a lambda (implicitly or explicitly) is odr-used by the lambda-expression (therefore, implicit capture by a nested lambda triggers implicit capture in the enclosing lambda).</source>
          <target state="translated">Cualquier entidad capturada por un lambda (implícita o explícitamente)es odr-utilizada por la expresión lambda (por lo tanto,la captura implícita por un lambda anidado desencadena la captura implícita en el lambda que lo encierra).</target>
        </trans-unit>
        <trans-unit id="2989809a7b8d0c13f3bc5dcda54fae5845e8e939" translate="yes" xml:space="preserve">
          <source>Any exception thrown by &lt;code&gt;Clock&lt;/code&gt; or &lt;code&gt;Duration&lt;/code&gt; (clocks and durations provided by the standard library never throw).</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;Clock&lt;/code&gt; o &lt;code&gt;Duration&lt;/code&gt; (los relojes y duraciones provistos por la biblioteca est&amp;aacute;ndar nunca se lanzan).</target>
        </trans-unit>
        <trans-unit id="0155546b454eb352e396af9a9583e45239059529" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">Cualquier excepción lanzada por reloj,punto de tiempo o duración durante la ejecución (los relojes,puntos de tiempo y duraciones proporcionados por la biblioteca estándar nunca lanzan).</target>
        </trans-unit>
        <trans-unit id="c2829040c4ec83947a1f6cbfdec13c1bbc1b434c" translate="yes" xml:space="preserve">
          <source>Any exception thrown by clock, time_point, or duration during the execution (clocks, time points, and durations provided by the standard library never throw).</source>
          <target state="translated">Cualquier excepción lanzada por reloj,punto_de_tiempo,o duración durante la ejecución (los relojes,puntos de tiempo y duraciones proporcionados por la biblioteca estándar nunca lanzan).</target>
        </trans-unit>
        <trans-unit id="c01d2aae1c56f6c1e27461994e6f980f695234ee" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, &lt;code&gt;*this&lt;/code&gt; does not contain a value after this call (the previously contained value, if any, had been destroyed).</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por el constructor seleccionado de &lt;code&gt;T&lt;/code&gt; . Si se produce una excepci&amp;oacute;n, &lt;code&gt;*this&lt;/code&gt; no contiene un valor despu&amp;eacute;s de esta llamada (el valor contenido anteriormente, si lo hubiera, se hab&amp;iacute;a destruido).</target>
        </trans-unit>
        <trans-unit id="9f5d991a2059cb95872e45c2fc73f5d2c5d644d5" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the selected constructor of the return value &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por el constructor seleccionado del valor de retorno &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8272c2eb0b4b3a47c1fd6266b118d8e0b7dc16c2" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Compare&lt;/code&gt; objects.</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por el intercambio de los objetos &lt;code&gt;Compare&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="067dbafb29590e30db3698223b8289c3ba3a81cd" translate="yes" xml:space="preserve">
          <source>Any exception thrown by the swap of the &lt;code&gt;Hash&lt;/code&gt; or &lt;code&gt;KeyEqual&lt;/code&gt; objects.</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por el intercambio de los objetos &lt;code&gt;Hash&lt;/code&gt; o &lt;code&gt;KeyEqual&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee3642fda89a9c4f4d022a23e66f5f0e3c59796" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;mutex()-&amp;gt;lock()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b6634d37c80775a0920996e88d7df6e338b295bf" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;mutex()-&amp;gt;lock_shared()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a87dda0d2400f372bf7fe2820ca303981427bec3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; (&lt;a href=&quot;../../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; types do not throw in &lt;code&gt;try_lock&lt;/code&gt;, but a custom &lt;a href=&quot;../../named_req/lockable&quot;&gt;Lockable&lt;/a&gt; might)</source>
          <target state="translated">Excepciones emitidas por el &lt;code&gt;mutex()-&amp;gt;try_lock()&lt;/code&gt; ( &lt;a href=&quot;../../named_req/mutex&quot;&gt;mutex&lt;/a&gt; tipos no lanzan en &lt;code&gt;try_lock&lt;/code&gt; , pero una costumbre &lt;a href=&quot;../../named_req/lockable&quot;&gt;bloqueable&lt;/a&gt; fuerza)</target>
        </trans-unit>
        <trans-unit id="655f412d1dcbf9a4b5e59996ea72d45e509cebc3" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;mutex()-&amp;gt;try_lock_for(timeout_duration)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7e00b1d47fa13181989c95392d4568f3ce99f9b2" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;mutex()-&amp;gt;try_lock_shared()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fbacb0aafa934213b8105430ca644b8c44fceb18" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_duration)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29577e958473f7848749dbde1c0fe41d4d28de86" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt;</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;mutex()-&amp;gt;try_lock_shared_for(timeout_time)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c13a79f4c3e26012d9358714b624c43671f4909" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt;</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;mutex()-&amp;gt;try_lock_until(timeout_time)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50c476323ba0569c33a9d73cfd698b2849a0d7de" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt;</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;mutex()-&amp;gt;unlock()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dde4d98fe163593f45905da9796164d4135b2aa5" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46aca186f0d5118e57ea1ec2d858f1e279a474ac" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by the copy constructors of &lt;code&gt;BinaryPredicate&lt;/code&gt; or &lt;code&gt;ForwardIt&lt;/code&gt;.</source>
          <target state="translated">Cualquier excepci&amp;oacute;n lanzada por los constructores de copia de &lt;code&gt;BinaryPredicate&lt;/code&gt; o &lt;code&gt;ForwardIt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d35da87105417bd2f8dd9b5f22cbdf22b00eefe" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown by.</source>
          <target state="translated">Cualquier excepción que se haga.</target>
        </trans-unit>
        <trans-unit id="ae8214fbedcd7b7b2c7806d56b17165dfe143da7" translate="yes" xml:space="preserve">
          <source>Any exceptions thrown from iterator operations or the element swap.</source>
          <target state="translated">Cualquier excepción arrojada de las operaciones de iterador o el intercambio de elementos.</target>
        </trans-unit>
        <trans-unit id="39254fcd3fdb015be0ee13d463da04333fcb57d3" translate="yes" xml:space="preserve">
          <source>Any expression in parentheses is also classified as a primary expression: this guarantees that the parentheses have higher precedence than any operator. Parentheses preserve value, type, and value category.</source>
          <target state="translated">Cualquier expresión entre paréntesis se clasifica también como expresión primaria:esto garantiza que los paréntesis tienen mayor precedencia que cualquier operador.Los paréntesis conservan el valor,el tipo y la categoría de valor.</target>
        </trans-unit>
        <trans-unit id="60455d87fc053fc9392b56ddecf2d39bad868244" translate="yes" xml:space="preserve">
          <source>Any instance of &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; at any given point in time either</source>
          <target state="translated">Cualquier instancia de &lt;code&gt;optional&amp;lt;T&amp;gt;&lt;/code&gt; en cualquier momento dado</target>
        </trans-unit>
        <trans-unit id="d6460fec33d2d5219b69f7a6eebb68fbfc2a92cb" translate="yes" xml:space="preserve">
          <source>Any lvalue or rvalue of this type can be swapped with any lvalue or rvalue of some other type, using unqualified function call &lt;code&gt;swap()&lt;/code&gt; in the context where both &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; and the user-defined &lt;code&gt;swap()&lt;/code&gt;s are visible.</source>
          <target state="translated">Cualquier lvalue o rvalue de este tipo puede intercambiarse con cualquier lvalue o rvalue de alg&amp;uacute;n otro tipo, utilizando la funci&amp;oacute;n no calificada call &lt;code&gt;swap()&lt;/code&gt; en el contexto donde est&amp;aacute;n visibles &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; y los &lt;code&gt;swap()&lt;/code&gt; definidos por el usuario .</target>
        </trans-unit>
        <trans-unit id="6091484d7bf355dd0cb949cd776657171718f832" translate="yes" xml:space="preserve">
          <source>Any member that could not be determined is set to &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt;</source>
          <target state="translated">Cualquier miembro que no se pudo determinar se establece en &lt;code&gt;static_cast&amp;lt;uintmax_t&amp;gt;(-1)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="74a03ddfcb26a95ca3f318466c08e7e95a815c27" translate="yes" xml:space="preserve">
          <source>Any number of access specifiers may appear within a class, in any order. Member access specifiers may affect class layout: the addresses of non-static &lt;a href=&quot;data_members#Layout&quot;&gt;data members&lt;/a&gt; are only guaranteed to increase in order of declaration for the members with the same access. For &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt;, all non-static data members must have the same access.</source>
          <target state="translated">Cualquier n&amp;uacute;mero de especificadores de acceso puede aparecer dentro de una clase, en cualquier orden. Los especificadores de acceso de miembros pueden afectar el dise&amp;ntilde;o de la clase: las direcciones de los &lt;a href=&quot;data_members#Layout&quot;&gt;miembros de datos&lt;/a&gt; no est&amp;aacute;ticos solo se garantiza que aumenten en orden de declaraci&amp;oacute;n para los miembros con el mismo acceso. Para &lt;a href=&quot;../named_req/standardlayouttype&quot;&gt;StandardLayoutType&lt;/a&gt; , todos los miembros de datos no est&amp;aacute;ticos deben tener el mismo acceso.</target>
        </trans-unit>
        <trans-unit id="a64cd75ae326e1b045aa2b1398be8083184efecf" translate="yes" xml:space="preserve">
          <source>Any of the following can be fully specialized:</source>
          <target state="translated">Cualquiera de los siguientes puede ser totalmente especializado:</target>
        </trans-unit>
        <trans-unit id="437e7790370da61d174fe4d318acf7c074ede85b" translate="yes" xml:space="preserve">
          <source>Any of the following contexts requires class &lt;code&gt;T&lt;/code&gt; to be complete:</source>
          <target state="translated">Cualquiera de los siguientes contextos requiere que la clase &lt;code&gt;T&lt;/code&gt; est&amp;eacute; completa:</target>
        </trans-unit>
        <trans-unit id="104d110bb41e8701d9fe7c539eb86ce87b612d21" translate="yes" xml:space="preserve">
          <source>Any of the following names declared at namespace scope have external linkage unless the namespace is unnamed or is contained within an unnamed namespace(since C++11):</source>
          <target state="translated">Cualquiera de los siguientes nombres declarados en el ámbito del espacio de nombres tiene una vinculación externa,a menos que el espacio de nombres no tenga nombre o esté contenido dentro de un espacio de nombres sin nombre (desde C++11):</target>
        </trans-unit>
        <trans-unit id="5407990c5239cdd7bd6ef99bf9f9a20fd8e6527f" translate="yes" xml:space="preserve">
          <source>Any of the following names first declared at block scope have external linkage:</source>
          <target state="translated">Cualquiera de los siguientes nombres declarados por primera vez en el ámbito del bloque tiene una vinculación externa:</target>
        </trans-unit>
        <trans-unit id="3238703010dee73fdace47f181589c27f2e4d0de" translate="yes" xml:space="preserve">
          <source>Any of the six two-way relational operators can be explicitly defaulted. A defaulted relational operator must have the return type &lt;code&gt;bool&lt;/code&gt;.</source>
          <target state="translated">Cualquiera de los seis operadores relacionales bidireccionales puede ser expl&amp;iacute;citamente predeterminado. Un operador relacional predeterminado debe tener el tipo de retorno &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="904ac65505544c6e1c0c9dffcf96e6454f73cb6f" translate="yes" xml:space="preserve">
          <source>Any other combination of encoding prefixes may or may not be supported by the implementation. The result of such a concatenation is implementation-defined.</source>
          <target state="translated">Cualquier otra combinación de prefijos de codificación puede o no ser apoyada por la aplicación.El resultado de esa concatenación se define en la aplicación.</target>
        </trans-unit>
        <trans-unit id="0401aa15a157b543ba80abd41cb54281ed03d456" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#include&lt;/code&gt;and &lt;code&gt;__has_include&lt;/code&gt;(since C++17) as long as they expand to a sequence of characters surrounded by &lt;code&gt;&amp;lt;&lt;/code&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&quot;&lt;/code&gt;&lt;code&gt;&quot;&lt;/code&gt;.</source>
          <target state="translated">Todos los tokens de preprocesamiento (constantes o expresiones macro) est&amp;aacute;n permitidos como argumentos para &lt;code&gt;#include&lt;/code&gt; y &lt;code&gt;__has_include&lt;/code&gt; (desde C ++ 17) siempre que se expandan a una secuencia de caracteres rodeados por &lt;code&gt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&lt;/code&gt; o &lt;code&gt;&quot;&lt;/code&gt; &lt;code&gt;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52919eaf1eb62c0854fdd694ccfd8a6c2a0705b3" translate="yes" xml:space="preserve">
          <source>Any preprocessing tokens (macro constants or expressions) are permitted as arguments to &lt;code&gt;#line&lt;/code&gt; as long as they expand to a valid decimal integer optionally following a valid character string.</source>
          <target state="translated">Todos los tokens de preprocesamiento (constantes o expresiones macro) est&amp;aacute;n permitidos como argumentos para &lt;code&gt;#line&lt;/code&gt; ar siempre que se expandan a un entero decimal v&amp;aacute;lido, opcionalmente siguiendo una cadena de caracteres v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="8a80f56d370810d05ed5b7f500aef83276b2b56b" translate="yes" xml:space="preserve">
          <source>Any random number engine is also a &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;, and therefore may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">Cualquier motor de n&amp;uacute;meros aleatorios tambi&amp;eacute;n es un &lt;a href=&quot;uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; y, por lo tanto, puede conectarse a cualquier &lt;a href=&quot;../numeric/random&quot;&gt;distribuci&amp;oacute;n de n&amp;uacute;meros aleatorios&lt;/a&gt; para obtener un n&amp;uacute;mero aleatorio (formalmente, una variante aleatoria).</target>
        </trans-unit>
        <trans-unit id="25328abef95d7bd06cd8ccb115014d680f4af1fb" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a bitset that happen via a &lt;code&gt;std::bitset::reference&lt;/code&gt; potentially read or write to the entire underlying bitset.</source>
          <target state="translated">Cualquier lectura o escritura en un conjunto de bits que ocurra a trav&amp;eacute;s de una &lt;code&gt;std::bitset::reference&lt;/code&gt; puede leer o escribir en todo el conjunto de bits subyacente.</target>
        </trans-unit>
        <trans-unit id="ce62d6fd6228c7ed0a629a27ad487d906ba0cf6e" translate="yes" xml:space="preserve">
          <source>Any reads or writes to a vector that happen via a &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; potentially read or write to the entire underlying vector.</source>
          <target state="translated">Cualquier lectura o escritura en un vector que ocurra a trav&amp;eacute;s de una &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;::reference&lt;/code&gt; &lt;a href=&quot;../vector&quot;&gt;std :: vector&lt;/a&gt; &amp;lt;bool&amp;gt; :: potencialmente lee o escribe en todo el vector subyacente.</target>
        </trans-unit>
        <trans-unit id="79d69f3522c40f28b11ac3de0d09461ee1623eb9" translate="yes" xml:space="preserve">
          <source>Any return value from the function is ignored. If the function throws an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. In order to pass return values or exceptions back to the calling thread, &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">Cualquier valor de retorno de la funci&amp;oacute;n se ignora. Si la funci&amp;oacute;n arroja una excepci&amp;oacute;n, se llama a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Para pasar valores de retorno o excepciones al hilo de llamada, se pueden usar &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="65591f30b00907d381312a521d81c7b5924c3ee3" translate="yes" xml:space="preserve">
          <source>Any shared state is released. &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; after a call to this method.</source>
          <target state="translated">Cualquier estado compartido se libera. &lt;code&gt;&lt;a href=&quot;valid&quot;&gt;valid()&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; despu&amp;eacute;s de una llamada a este m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="594a9e7004e035507b2faafb30d5238be37f382a" translate="yes" xml:space="preserve">
          <source>Any statement can be</source>
          <target state="translated">Cualquier declaración puede ser</target>
        </trans-unit>
        <trans-unit id="569389483a39353b7174754570a587d2d30d7a93" translate="yes" xml:space="preserve">
          <source>Any thread can potentially access any object in the program (objects with automatic and thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; may still be accessed by another thread through a pointer or by reference).</source>
          <target state="translated">Cualquier subproceso puede acceder a cualquier objeto en el programa ( otro subproceso o referencia puede acceder a los objetos con una &lt;a href=&quot;storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; autom&amp;aacute;tica y local de subprocesos).</target>
        </trans-unit>
        <trans-unit id="c56361a71bf85ab91f9c4ec67339965aa7d1d832" translate="yes" xml:space="preserve">
          <source>Any thread that intends to wait on &lt;code&gt;std::condition_variable&lt;/code&gt; has to.</source>
          <target state="translated">Cualquier hilo que intente esperar en &lt;code&gt;std::condition_variable&lt;/code&gt; tiene que hacerlo.</target>
        </trans-unit>
        <trans-unit id="a27b17e4a874eb86d62efa02b876f52b84cb2492" translate="yes" xml:space="preserve">
          <source>Any two objects with overlapping &lt;a href=&quot;lifetime&quot;&gt;lifetimes&lt;/a&gt; (that are not &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;) are guaranteed to have different addresses unless one of them is a subobject of another or provides storage for another, or if they are subobjects of different type within the same complete object, and one of them is a subobject of zero size.</source>
          <target state="translated">Se garantiza que dos objetos con &lt;a href=&quot;lifetime&quot;&gt;vidas&lt;/a&gt; superpuestas (que no son &lt;a href=&quot;bit_field&quot;&gt;campos de bits&lt;/a&gt; ) tienen direcciones diferentes a menos que uno de ellos sea un subobjeto de otro o proporcione almacenamiento para otro, o si son subobjetos de diferente tipo dentro del mismo objeto completo, y uno de ellos es un subobjeto de tama&amp;ntilde;o cero.</target>
        </trans-unit>
        <trans-unit id="747805bfa6e2b47c753f371046684998f5739c7b" translate="yes" xml:space="preserve">
          <source>Any use of a pointer that became invalid in this manner, even copying the pointer value into another variable, is undefined behavior.</source>
          <target state="translated">Cualquier uso de un puntero que se haya vuelto inválido de esta manera,incluso copiando el valor del puntero en otra variable,es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="edb0075febb6c810a733225d843cfc260a841379" translate="yes" xml:space="preserve">
          <source>Any valid character except the double-quote &lt;code&gt;&quot;&lt;/code&gt;, backslash &lt;code&gt;\&lt;/code&gt;, or new-line character</source>
          <target state="translated">Cualquier car&amp;aacute;cter v&amp;aacute;lido excepto la comilla doble &lt;code&gt;&quot;&lt;/code&gt; , barra invertida &lt;code&gt;\&lt;/code&gt; o car&amp;aacute;cter de nueva l&amp;iacute;nea</target>
        </trans-unit>
        <trans-unit id="1b24babb1df893acf8a8a6efb01913ddf0bd9397" translate="yes" xml:space="preserve">
          <source>Appear in any type specifier, including decl-specifier-seq of &lt;a href=&quot;declarations&quot;&gt;declaration grammar&lt;/a&gt;, to specify constness or volatility of the object being declared or of the type being named.</source>
          <target state="translated">Aparecer en cualquier especificador de tipo, incluido decl-specifier-seq de la &lt;a href=&quot;declarations&quot;&gt;gram&amp;aacute;tica&lt;/a&gt; de declaraci&amp;oacute;n , para especificar la constancia o volatilidad del objeto que se declara o del tipo que se nombra.</target>
        </trans-unit>
        <trans-unit id="b3cea74b8699d0d5592fcdb76824dfd00b7a1900" translate="yes" xml:space="preserve">
          <source>Appears in a function declaration, enumeration declaration, or class declaration.</source>
          <target state="translated">Aparece en una declaración de función,declaración de enumeración o declaración de clase.</target>
        </trans-unit>
        <trans-unit id="1f41b36bd2867522723d540cbaf10ea09210fdf2" translate="yes" xml:space="preserve">
          <source>Append to a file</source>
          <target state="translated">Añadir a un archivo...</target>
        </trans-unit>
        <trans-unit id="185b3e5c1287dbe88e91911ebf09f0289a09ed1c" translate="yes" xml:space="preserve">
          <source>Append to file</source>
          <target state="translated">Añadir al archivo</target>
        </trans-unit>
        <trans-unit id="7727ad0dfc1361a3b9a9f16594166faee13a49d3" translate="yes" xml:space="preserve">
          <source>Appends a &lt;code&gt;T&lt;/code&gt; constructed with &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;</source>
          <target state="translated">Agrega una &lt;code&gt;T&lt;/code&gt; construida con &lt;code&gt;&lt;a href=&quot;../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ffa8f7a6232502ff61b9f355b8192a149bda0bdd" translate="yes" xml:space="preserve">
          <source>Appends a byte string pointed to by &lt;code&gt;src&lt;/code&gt; to a byte string pointed to by &lt;code&gt;dest&lt;/code&gt;. At most &lt;code&gt;count&lt;/code&gt; characters are copied. The resulting byte string is null-terminated.</source>
          <target state="translated">Agrega una cadena de bytes apuntada por &lt;code&gt;src&lt;/code&gt; a una cadena de bytes apuntada por &lt;code&gt;dest&lt;/code&gt; . En la mayor&amp;iacute;a &lt;code&gt;count&lt;/code&gt; caracteres se copian. La cadena de bytes resultante tiene una terminaci&amp;oacute;n nula.</target>
        </trans-unit>
        <trans-unit id="c89f8ba239ec205d14a709567d6066df8a0d1451" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;rv&lt;/code&gt;, possibly using move semantics</source>
          <target state="translated">Agrega una copia de &lt;code&gt;rv&lt;/code&gt; , posiblemente usando sem&amp;aacute;ntica de movimiento</target>
        </trans-unit>
        <trans-unit id="93a15a35c8298c01ed0b17fc08d04c4607bfeb7b" translate="yes" xml:space="preserve">
          <source>Appends a copy of &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">Anexa una copia de &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0749406f25dc8bfe01326e6508ea40f8ccdfe8f5" translate="yes" xml:space="preserve">
          <source>Appends a copy of the character string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;. The character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting byte string is null-terminated.</source>
          <target state="translated">Agrega una copia de la cadena de caracteres se&amp;ntilde;alada por &lt;code&gt;src&lt;/code&gt; al final de la cadena de caracteres se&amp;ntilde;alada por &lt;code&gt;dest&lt;/code&gt; . El car&amp;aacute;cter &lt;code&gt;src[0]&lt;/code&gt; reemplaza el terminador nulo al final de &lt;code&gt;dest&lt;/code&gt; . La cadena de bytes resultante tiene una terminaci&amp;oacute;n nula.</target>
        </trans-unit>
        <trans-unit id="0f3b244f19389096a59b50d552c3a3947e4ec319" translate="yes" xml:space="preserve">
          <source>Appends a copy of the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the wide string pointed to by &lt;code&gt;dest&lt;/code&gt;. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The resulting wide string is null-terminated.</source>
          <target state="translated">Agrega una copia de la cadena ancha apuntada por &lt;code&gt;src&lt;/code&gt; al final de la cadena ancha apuntada por &lt;code&gt;dest&lt;/code&gt; . El car&amp;aacute;cter ancho &lt;code&gt;src[0]&lt;/code&gt; reemplaza el terminador nulo al final de &lt;code&gt;dest&lt;/code&gt; . La cadena ancha resultante tiene una terminaci&amp;oacute;n nula.</target>
        </trans-unit>
        <trans-unit id="ee76f2e6383e182374a1ac158b3fb988871f2017" translate="yes" xml:space="preserve">
          <source>Appends a new element to the end of the container. The element is constructed through &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt;, which typically uses placement-new to construct the element in-place at the location provided by the container. The arguments &lt;code&gt;args...&lt;/code&gt; are forwarded to the constructor as &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">Agrega un nuevo elemento al final del contenedor. El elemento se construye a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits/construct&quot;&gt;std::allocator_traits::construct&lt;/a&gt;&lt;/code&gt; , que generalmente utiliza ubicaci&amp;oacute;n nueva para construir el elemento en el lugar en la ubicaci&amp;oacute;n proporcionada por el contenedor. Los argumentos &lt;code&gt;args...&lt;/code&gt; se reenv&amp;iacute;an al constructor como &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3769354c56bdf441401d30ffbfd485d11afed226" translate="yes" xml:space="preserve">
          <source>Appends additional characters to the string.</source>
          <target state="translated">Añade caracteres adicionales a la cadena.</target>
        </trans-unit>
        <trans-unit id="9435c7778f8168db6ddee793e51647858e33337b" translate="yes" xml:space="preserve">
          <source>Appends at most &lt;code&gt;count&lt;/code&gt; wide characters from the wide string pointed to by &lt;code&gt;src&lt;/code&gt; to the end of the character string pointed to by &lt;code&gt;dest&lt;/code&gt;, stopping if the null terminator is copied. The wide character &lt;code&gt;src[0]&lt;/code&gt; replaces the null terminator at the end of &lt;code&gt;dest&lt;/code&gt;. The null terminator is always appended in the end (so the maximum number of wide characters the function may write is &lt;code&gt;count+1&lt;/code&gt;).</source>
          <target state="translated">Anexa a la mayor&amp;iacute;a &lt;code&gt;count&lt;/code&gt; caracteres anchos de la cadena amplia apuntada por &lt;code&gt;src&lt;/code&gt; al final de la cadena de caracteres apuntada por &lt;code&gt;dest&lt;/code&gt; , parando si se copia el terminador nulo. El car&amp;aacute;cter ancho &lt;code&gt;src[0]&lt;/code&gt; reemplaza el terminador nulo al final de &lt;code&gt;dest&lt;/code&gt; . El terminador nulo siempre se agrega al final (por lo que el n&amp;uacute;mero m&amp;aacute;ximo de caracteres anchos que puede escribir la funci&amp;oacute;n es &lt;code&gt;count+1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="616d6d1b2db8c5cbc5b78e6729f280f6ef9cde21" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the output character sequence.</source>
          <target state="translated">Agrega el car&amp;aacute;cter &lt;code&gt;c&lt;/code&gt; a la secuencia de caracteres de salida.</target>
        </trans-unit>
        <trans-unit id="97e86c02631fb97ad63c305dc2c6744a765ce0c5" translate="yes" xml:space="preserve">
          <source>Appends the character &lt;code&gt;c&lt;/code&gt; to the put area of the buffer, reallocating if possible.</source>
          <target state="translated">Agrega el car&amp;aacute;cter &lt;code&gt;c&lt;/code&gt; al &amp;aacute;rea de colocaci&amp;oacute;n del b&amp;uacute;fer, reasignando si es posible.</target>
        </trans-unit>
        <trans-unit id="532328072ae734b050324e7bd55974ecc3a7470f" translate="yes" xml:space="preserve">
          <source>Appends the given character &lt;code&gt;ch&lt;/code&gt; to the end of the string.</source>
          <target state="translated">Agrega el car&amp;aacute;cter dado &lt;code&gt;ch&lt;/code&gt; al final de la cadena.</target>
        </trans-unit>
        <trans-unit id="cfc483d3db69eff6dcd82b004d3786722b9a1849" translate="yes" xml:space="preserve">
          <source>Appends the given element &lt;code&gt;value&lt;/code&gt; to the end of the container.</source>
          <target state="translated">Agrega el &lt;code&gt;value&lt;/code&gt; elemento dado al final del contenedor.</target>
        </trans-unit>
        <trans-unit id="d2c0fb94e5cddaf445eca7c3640f9ada9fb6e2a7" translate="yes" xml:space="preserve">
          <source>Applied to</source>
          <target state="translated">Aplicado a</target>
        </trans-unit>
        <trans-unit id="cbd47fe22d148dd069a031976318ab7fb6d631c4" translate="yes" xml:space="preserve">
          <source>Applies compound assignment operators to each element in the numeric array.</source>
          <target state="translated">Aplica operadores de asignación de compuestos a cada elemento de la matriz numérica.</target>
        </trans-unit>
        <trans-unit id="bc6e0092dfd47ac0f36260b8d91a3704f6cc8726" translate="yes" xml:space="preserve">
          <source>Applies lvalue-to-rvalue, array-to-pointer, and function-to-pointer implicit conversions to the type &lt;code&gt;T&lt;/code&gt;, removes cv-qualifiers, and defines the resulting type as the member typedef &lt;code&gt;type&lt;/code&gt;. Formally:</source>
          <target state="translated">Aplica las conversiones impl&amp;iacute;citas lvalue-to-rvalue, array-to-pointer y function-to-pointer al tipo &lt;code&gt;T&lt;/code&gt; , elimina los calificadores cv y define el tipo resultante como el &lt;code&gt;type&lt;/code&gt; miembro typedef . Formalmente:</target>
        </trans-unit>
        <trans-unit id="71f4ff319120444a2809431ede654e171b067641" translate="yes" xml:space="preserve">
          <source>Applies the corresponding operation to the referred elements and the elements of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Aplica la operaci&amp;oacute;n correspondiente a los elementos referidos y los elementos de &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d8e4e4d1d2e00786c12ccc2c42604642524bdd" translate="yes" xml:space="preserve">
          <source>Applies the unary operators to the year value.</source>
          <target state="translated">Aplica los operadores unarios al valor del año.</target>
        </trans-unit>
        <trans-unit id="a0cc3e98fe133b6a125be7a1095a1e4722d59951" translate="yes" xml:space="preserve">
          <source>Applies the visitor &lt;code&gt;vis&lt;/code&gt; to the variants &lt;code&gt;vars&lt;/code&gt;.</source>
          <target state="translated">Aplica el visitante &lt;code&gt;vis&lt;/code&gt; a las variantes &lt;code&gt;vars&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="767013b70c83389088a9d12acdf6717a821be569" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in a function declaration, which must be the first declaration of the function.</source>
          <target state="translated">Se aplica al nombre que se declara en una declaración de función,que debe ser la primera declaración de la función.</target>
        </trans-unit>
        <trans-unit id="0463466b4fbb2abaeda54896e7f772d38769d910" translate="yes" xml:space="preserve">
          <source>Applies to the name being declared in the declaration of a non-static data member that's not a bit field.</source>
          <target state="translated">Se aplica al nombre que se declara en la declaración de un miembro de datos no estático que no es un campo de bits.</target>
        </trans-unit>
        <trans-unit id="c80f073f7430ca362ef718e10efb9033f924c369" translate="yes" xml:space="preserve">
          <source>Applies unary operators to each element in the numeric array.</source>
          <target state="translated">Aplica operadores unarios a cada elemento de la matriz numérica.</target>
        </trans-unit>
        <trans-unit id="4b03880d31fcc803c8ff4f90e7d09f01a683bd9e" translate="yes" xml:space="preserve">
          <source>Apply binary operators to each element of two valarrays, or a valarray and a value.</source>
          <target state="translated">Aplicar operadores binarios a cada elemento de dos valarrays,o un valarray y un valor.</target>
        </trans-unit>
        <trans-unit id="68fcd04d7e11c3d0bcd63b86035531ef6f69e2ba" translate="yes" xml:space="preserve">
          <source>Applying &lt;a href=&quot;cv&quot;&gt;cv-qualifiers&lt;/a&gt; to an array type (through typedef or template type manipulation) applies the qualifiers to the element type, but any array type whose elements are of cv-qualified type is considered to have the same cv-qualification.</source>
          <target state="translated">La aplicaci&amp;oacute;n &lt;a href=&quot;cv&quot;&gt;de calificadores cv&lt;/a&gt; a un tipo de matriz (mediante typedef o manipulaci&amp;oacute;n de tipo de plantilla) aplica los calificadores al tipo de elemento, pero se considera que cualquier tipo de matriz cuyos elementos son calificados para cv tiene la misma calificaci&amp;oacute;n cv.</target>
        </trans-unit>
        <trans-unit id="4da3e84107ea6402ad05595526acce55c364845f" translate="yes" xml:space="preserve">
          <source>Approximate</source>
          <target state="translated">Approximate</target>
        </trans-unit>
        <trans-unit id="09d845a999b4fbc8adffb5aaf317f7912e88b018" translate="yes" xml:space="preserve">
          <source>Approximately (last-first)log(middle-first) applications of &lt;code&gt;cmp&lt;/code&gt;.</source>
          <target state="translated">Aproximadamente (&amp;uacute;ltimo-primero) aplicaciones de registro (medio-primero) de &lt;code&gt;cmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="784f9dcf68eaea0702498dee303485e97ffb2719" translate="yes" xml:space="preserve">
          <source>Approximately &lt;code&gt;N log N&lt;/code&gt; comparisons, where N is the number of elements in the list.</source>
          <target state="translated">Aproximadamente &lt;code&gt;N log N&lt;/code&gt; comparaciones, donde N es el n&amp;uacute;mero de elementos en la lista.</target>
        </trans-unit>
        <trans-unit id="263ef14d73529c347640508e4c1ee9f8d38a5463" translate="yes" xml:space="preserve">
          <source>Arbitrary variable name</source>
          <target state="translated">Nombre arbitrario de la variable</target>
        </trans-unit>
        <trans-unit id="e35b07545cf742633f94fa34acab673ea47df2c2" translate="yes" xml:space="preserve">
          <source>Args&lt;code&gt;...&lt;/code&gt;args(optional)</source>
          <target state="translated">Args&lt;code&gt;...&lt;/code&gt;args(optional)</target>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="b8bc95515466bfd1d5820bfea495f62a49211b2b" translate="yes" xml:space="preserve">
          <source>Argument list too long</source>
          <target state="translated">La lista de argumentos es demasiado larga</target>
        </trans-unit>
        <trans-unit id="def2bf62b424e602e225d5df7086bbc94649ceb1" translate="yes" xml:space="preserve">
          <source>Argument type</source>
          <target state="translated">Tipo de argumento</target>
        </trans-unit>
        <trans-unit id="2b55cecef5202fd86c073a0e44fac351439665bc" translate="yes" xml:space="preserve">
          <source>Argument-Dependent Lookup</source>
          <target state="translated">Búsqueda dependiente de argumentos</target>
        </trans-unit>
        <trans-unit id="81b2c9c824baa8fa05c1678ad66e87db4cff58c7" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup</source>
          <target state="translated">Búsqueda dependiente de argumentos</target>
        </trans-unit>
        <trans-unit id="ae0999c00edb7da81dc23e3610fb98d912a734a5" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup makes it possible to use operators defined in a different namespace. Example:</source>
          <target state="translated">La búsqueda dependiente de los argumentos permite utilizar operadores definidos en un espacio de nombres diferente.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="48fb1df93f3daa01db173d8e4c1d5be0610f1c51" translate="yes" xml:space="preserve">
          <source>Argument-dependent lookup, also known as ADL, or Koenig lookup, is the set of rules for looking up the unqualified function names in &lt;a href=&quot;operator_other&quot;&gt;function-call expressions&lt;/a&gt;, including implicit function calls to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;. These function names are looked up in the namespaces of their arguments in addition to the scopes and namespaces considered by the usual &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt;.</source>
          <target state="translated">La b&amp;uacute;squeda dependiente de argumentos, tambi&amp;eacute;n conocida como ADL o b&amp;uacute;squeda de Koenig, es el conjunto de reglas para buscar los nombres de &lt;a href=&quot;operator_other&quot;&gt;funciones no calificados en las expresiones de llamada a funciones&lt;/a&gt; , incluidas las llamadas a funciones impl&amp;iacute;citas a &lt;a href=&quot;operators&quot;&gt;operadores sobrecargados&lt;/a&gt; . Estos nombres de funciones se buscan en los espacios de nombres de sus argumentos, adem&amp;aacute;s de los &amp;aacute;mbitos y espacios de nombres considerados por la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda de nombre no calificado&lt;/a&gt; habitual .</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="6e926e8a15212af2e7d9e38d85b6ff5994219acc" translate="yes" xml:space="preserve">
          <source>Arithmetic comparison operators</source>
          <target state="translated">Operadores de comparación aritmética</target>
        </trans-unit>
        <trans-unit id="1fc0feb17ac2848b9f01591a445a367739c560da" translate="yes" xml:space="preserve">
          <source>Arithmetic operations</source>
          <target state="translated">Operaciones aritméticas</target>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="translated">Operadores aritméticos</target>
        </trans-unit>
        <trans-unit id="ebc8c7691d9a7980369acc634bd9267bcb2e5a9e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators are overloaded for many standard library types.</source>
          <target state="translated">Los operadores aritméticos están sobrecargados para muchos tipos de biblioteca estándar.</target>
        </trans-unit>
        <trans-unit id="aa83af8c4fc56c37be9ed278bb37886d698b573b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing the process running time of implementation-defined range and precision.</source>
          <target state="translated">Tipo de aritmética capaz de representar el tiempo de ejecución del proceso de rango y precisión definidos por la implementación.</target>
        </trans-unit>
        <trans-unit id="8067dbf084d6b81e05c895b3fb91dd4530c4b57b" translate="yes" xml:space="preserve">
          <source>Arithmetic type capable of representing times.</source>
          <target state="translated">Un tipo de aritmética capaz de representar los tiempos.</target>
        </trans-unit>
        <trans-unit id="3a96c27ea8acc41f84ccf2e2e957611cc9d4cd07" translate="yes" xml:space="preserve">
          <source>Arithmetic types</source>
          <target state="translated">Tipos aritméticos</target>
        </trans-unit>
        <trans-unit id="d06d9a0dfd0ee03ff5118df0f82845bdc8d2b4bc" translate="yes" xml:space="preserve">
          <source>Arithmetic types are the built-in types for which the &lt;a href=&quot;../language/operator_arithmetic&quot;&gt;arithmetic operators&lt;/a&gt; (+, -, *, /) are defined (possibly in combination with the usual arithmetic conversions).</source>
          <target state="translated">Los tipos aritm&amp;eacute;ticos son los tipos incorporados para los que se definen los &lt;a href=&quot;../language/operator_arithmetic&quot;&gt;operadores aritm&amp;eacute;ticos&lt;/a&gt; (+, -, *, /) (posiblemente en combinaci&amp;oacute;n con las conversiones aritm&amp;eacute;ticas habituales).</target>
        </trans-unit>
        <trans-unit id="7a080955122add0c1c12baf72d49c4257bf60020" translate="yes" xml:space="preserve">
          <source>Array &lt;a href=&quot;value_category&quot;&gt;xvalues&lt;/a&gt; may be formed directly by accessing an array member of a class rvalue or by using &lt;code&gt;std::move&lt;/code&gt; or another cast or function call that returns an rvalue reference.</source>
          <target state="translated">Los &lt;a href=&quot;value_category&quot;&gt;valores x de la&lt;/a&gt; matriz se pueden formar directamente accediendo a un miembro de la matriz de un valor de clase o usando &lt;code&gt;std::move&lt;/code&gt; u otra llamada de funci&amp;oacute;n o conversi&amp;oacute;n que devuelve una referencia de valor r.</target>
        </trans-unit>
        <trans-unit id="ee291b10c5dda44d0a9e99115603b2cd5af533b7" translate="yes" xml:space="preserve">
          <source>Array I/O implementations</source>
          <target state="translated">Implementaciones de E/S de la matriz</target>
        </trans-unit>
        <trans-unit id="1fac704c74c4d1cd597a85741e932ee6a1399565" translate="yes" xml:space="preserve">
          <source>Array allocation may supply unspecified overhead, which may vary from one call to new to the next. The pointer returned by the new-expression will be offset by that value from the pointer returned by the allocation function. Many implementations use the array overhead to store the number of objects in the array which is used by the &lt;a href=&quot;delete&quot;&gt;&lt;code&gt;delete[]&lt;/code&gt;&lt;/a&gt; expression to call the correct number of destructors. In addition, if the new-expression is used to allocate an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt;, it may request additional memory from the allocation function if necessary to guarantee correct alignment of objects of all types no larger than the requested array size, if one is later placed into the allocated array.</source>
          <target state="translated">La asignaci&amp;oacute;n de matriz puede proporcionar una sobrecarga no especificada, que puede variar de una llamada a una nueva a la siguiente. El puntero devuelto por la nueva expresi&amp;oacute;n ser&amp;aacute; compensado por ese valor del puntero devuelto por la funci&amp;oacute;n de asignaci&amp;oacute;n. Muchas implementaciones usan la sobrecarga de la matriz para almacenar el n&amp;uacute;mero de objetos en la matriz que utiliza la expresi&amp;oacute;n &lt;a href=&quot;delete&quot;&gt; &lt;code&gt;delete[]&lt;/code&gt; &lt;/a&gt; para llamar al n&amp;uacute;mero correcto de destructores. Adem&amp;aacute;s, si la nueva expresi&amp;oacute;n se usa para asignar una matriz de caracteres &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; o &lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt; , puede solicitar memoria adicional de la funci&amp;oacute;n de asignaci&amp;oacute;n si es necesario para garantizar la correcta alineaci&amp;oacute;n de objetos de todos los tipos no mayores que el tama&amp;ntilde;o de matriz solicitado, si luego se coloca uno en la matriz asignada.</target>
        </trans-unit>
        <trans-unit id="19dbfbf61f5e11cabe0b3e7c939480487b44e48e" translate="yes" xml:space="preserve">
          <source>Array and function types may be written in a template declaration, but they are automatically replaced by pointer to object and pointer to function as appropriate.</source>
          <target state="translated">Los tipos de matriz y de función pueden escribirse en una declaración de plantilla,pero se sustituyen automáticamente por puntero a objeto y puntero a función,según proceda.</target>
        </trans-unit>
        <trans-unit id="3fb125cc9e54d7ed417b90f1b586cad673b24cc3" translate="yes" xml:space="preserve">
          <source>Array declaration</source>
          <target state="translated">Declaración de la matriz</target>
        </trans-unit>
        <trans-unit id="fa11a0bed9bf8be4aa754cdcc96dcd83617299af" translate="yes" xml:space="preserve">
          <source>Array rvalues</source>
          <target state="translated">Los valores de la matriz</target>
        </trans-unit>
        <trans-unit id="2e4177a778e8e0d4d36e9396b01d0e6f4341b30c" translate="yes" xml:space="preserve">
          <source>Array subscript operator</source>
          <target state="translated">Operador de subíndices de matrices</target>
        </trans-unit>
        <trans-unit id="66b8cc3bf902fd9199bad14788d8e22184391a03" translate="yes" xml:space="preserve">
          <source>Array to pointer conversion</source>
          <target state="translated">Conversión de matriz a puntero</target>
        </trans-unit>
        <trans-unit id="c0025fd7b0d4a983ce2fa2e1c1b60d86f77fcd32" translate="yes" xml:space="preserve">
          <source>Array version, &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</source>
          <target state="translated">Versi&amp;oacute;n de matriz, &lt;code&gt;unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d338acd11db4278249951233a983d4b787dc89b" translate="yes" xml:space="preserve">
          <source>Array-oriented access</source>
          <target state="translated">Acceso orientado a la matriz</target>
        </trans-unit>
        <trans-unit id="78c423e7d10bf3348df8d43bf148cb5827744e5a" translate="yes" xml:space="preserve">
          <source>Array-to-pointer and function-to-pointer conversions are never applied to the value calculated by a discarded-value expression. The lvalue-to-rvalue conversion is applied if and only if the expression is a &lt;a href=&quot;cv&quot;&gt;volatile-qualified&lt;/a&gt; glvalue and has one of the following forms (built-in meaning required, possibly parenthesized).</source>
          <target state="translated">Las conversiones de matriz a puntero y funci&amp;oacute;n a puntero nunca se aplican al valor calculado por una expresi&amp;oacute;n de valor descartado. La conversi&amp;oacute;n lvalue-to-rvalue se aplica si y solo si la expresi&amp;oacute;n es un glvalue &lt;a href=&quot;cv&quot;&gt;calificado como&lt;/a&gt; vol&amp;aacute;til y tiene una de las siguientes formas (se requiere un significado incorporado, posiblemente entre par&amp;eacute;ntesis).</target>
        </trans-unit>
        <trans-unit id="e8874168e3c1df960a01e93b0e01fe86fb6ae2dc" translate="yes" xml:space="preserve">
          <source>Array-to-pointer decay</source>
          <target state="translated">Decadencia de la matriz a la punta</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="1376db7bd12df19420984d74ce62a991f95e82b5" translate="yes" xml:space="preserve">
          <source>Arrays can be constructed from any &lt;a href=&quot;types&quot;&gt;fundamental type&lt;/a&gt; (except &lt;code&gt;void&lt;/code&gt;), &lt;a href=&quot;pointer&quot;&gt;pointers&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointers to members&lt;/a&gt;, &lt;a href=&quot;classes&quot;&gt;classes&lt;/a&gt;, &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, or from other arrays (in which case the array is said to be multi-dimensional).</source>
          <target state="translated">Las matrices se pueden construir a partir de cualquier &lt;a href=&quot;types&quot;&gt;tipo fundamental&lt;/a&gt; (excepto &lt;code&gt;void&lt;/code&gt; ), &lt;a href=&quot;pointer&quot;&gt;punteros&lt;/a&gt; , &lt;a href=&quot;pointer&quot;&gt;punteros a miembros&lt;/a&gt; , &lt;a href=&quot;classes&quot;&gt;clases&lt;/a&gt; , &lt;a href=&quot;enum&quot;&gt;enumeraciones&lt;/a&gt; u otras matrices (en cuyo caso se dice que la matriz es multidimensional).</target>
        </trans-unit>
        <trans-unit id="fb1e79ec0101099cc8a59bf9fd30eb4aa15f99db" translate="yes" xml:space="preserve">
          <source>Arrays of character types (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;) can be initialized from an appropriate &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;, optionally enclosed in braces. Successive characters of the string literal (which includes the implicit terminating null character) initialize the elements of the array. If the size of the array is specified and it is larger than the number of characters in the string literal, the remaining characters are zero-initialized.</source>
          <target state="translated">Las matrices de tipos de caracteres ( &lt;code&gt;char&lt;/code&gt; , char &lt;code&gt;signed char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; ) se pueden inicializar desde un &lt;a href=&quot;string_literal&quot;&gt;literal de cadena&lt;/a&gt; apropiado , opcionalmente encerrado entre llaves. Los caracteres sucesivos del literal de cadena (que incluye el car&amp;aacute;cter nulo de terminaci&amp;oacute;n impl&amp;iacute;cito) inicializan los elementos de la matriz. Si se especifica el tama&amp;ntilde;o de la matriz y es mayor que el n&amp;uacute;mero de caracteres en el literal de cadena, los caracteres restantes se inicializan en cero.</target>
        </trans-unit>
        <trans-unit id="1dad2511cb3cf432d9a23097f1bff2b6f8637192" translate="yes" xml:space="preserve">
          <source>Arrays of unknown bound</source>
          <target state="translated">Matrices de límites desconocidos</target>
        </trans-unit>
        <trans-unit id="5cf5ca03aab0034cdf7ff385d06729a538f15f36" translate="yes" xml:space="preserve">
          <source>As a rule, iterators to an array are never invalidated throughout the lifetime of the array. One should take note, however, that during &lt;a href=&quot;array/swap&quot;&gt;swap&lt;/a&gt;, the iterator will continue to point to the same array element, and will thus change its value.</source>
          <target state="translated">Como regla general, los iteradores de una matriz nunca se invalidan durante la vida &amp;uacute;til de la matriz. Sin embargo, se debe tener en cuenta que durante el &lt;a href=&quot;array/swap&quot;&gt;intercambio&lt;/a&gt; , el iterador continuar&amp;aacute; apuntando al mismo elemento de matriz y, por lo tanto, cambiar&amp;aacute; su valor.</target>
        </trans-unit>
        <trans-unit id="614cc5be51bd0fccb31d1106fa599930fafe0ca5" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; is treated as a uses-allocator type even though &lt;code&gt;std::uses_allocator&lt;/code&gt; is false for pairs (unlike e.g. &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;): see pair-specific overloads of &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt;(until C++20)&lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt;(since C++20)</source>
          <target state="translated">Como caso especial, &lt;code&gt;&lt;a href=&quot;../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; se trata como un tipo de asignador de usos, aunque &lt;code&gt;std::uses_allocator&lt;/code&gt; es falso para pares (a diferencia de, por ejemplo, &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; ): ver sobrecargas espec&amp;iacute;ficas de pares de &lt;code&gt;std::polymoprhic_allocator::construct&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor/construct&quot;&gt;std::scoped_allocator_adaptor::construct&lt;/a&gt;&lt;/code&gt; (hasta C ++ 20) &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; (desde C ++ 20)</target>
        </trans-unit>
        <trans-unit id="363835804f732ae2a7518afa5d70079b8f827fb9" translate="yes" xml:space="preserve">
          <source>As a special case, objects can be created in arrays of &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;../types/byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; (in which case it is said that the array</source>
          <target state="translated">Como caso especial, los objetos se pueden crear en matrices de caracteres &lt;code&gt;unsigned char&lt;/code&gt; o &lt;a href=&quot;../types/byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt; (en cuyo caso se dice que la matriz</target>
        </trans-unit>
        <trans-unit id="f52724b9ca0301f1d8b93282821a00b036f2d526" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;eq=key_equal()&lt;/code&gt;</source>
          <target state="translated">Como arriba, con &lt;code&gt;eq=key_equal()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8531b085109b3b3d1377cabf79180d8d388c7ee8" translate="yes" xml:space="preserve">
          <source>As above, with &lt;code&gt;hf=hasher()&lt;/code&gt;</source>
          <target state="translated">Como arriba, con &lt;code&gt;hf=hasher()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bda77b28e4ca321fc30d59f16b97fba79dbe7581" translate="yes" xml:space="preserve">
          <source>As above, with an unspecified number of buckets</source>
          <target state="translated">Como arriba,con un número no especificado de cubos</target>
        </trans-unit>
        <trans-unit id="cb4232ed7041310ecc9217dc4e9b0dad693d0afb" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void*)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="translated">Como un ejemplo del requisito &quot;soportado por la implementaci&amp;oacute;n&quot;, la funci&amp;oacute;n POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; acepta cualquier &lt;code&gt;alignment&lt;/code&gt; que sea una potencia de dos y un m&amp;uacute;ltiplo de &lt;code&gt;sizeof(void*)&lt;/code&gt; , y las implementaciones de &lt;code&gt;aligned_alloc&lt;/code&gt; basadas en POSIX heredan estos requisitos.</target>
        </trans-unit>
        <trans-unit id="0a94bbdb2793055475b5f04a01eddcc7f88ab6b4" translate="yes" xml:space="preserve">
          <source>As an example of the &quot;supported by the implementation&quot; requirement, POSIX function &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html&quot;&gt;posix_memalign&lt;/a&gt; accepts any &lt;code&gt;alignment&lt;/code&gt; that is a power of two and a multiple of &lt;code&gt;sizeof(void*)&lt;/code&gt;, and POSIX-based implementations of &lt;code&gt;aligned_alloc&lt;/code&gt; inherit this requirements.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dabb20bee356347a72de2e02dded113dd51368a" translate="yes" xml:space="preserve">
          <source>As any other function, a destructor may terminate by throwing an &lt;a href=&quot;exceptions&quot;&gt;exception&lt;/a&gt;(this usually requires it to be explicitly declared &lt;code&gt;noexcept(false)&lt;/code&gt;)(since C++11), however if this destructor happens to be called during &lt;a href=&quot;throw&quot;&gt;stack unwinding&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Como cualquier otra funci&amp;oacute;n, un destructor puede terminar lanzando una &lt;a href=&quot;exceptions&quot;&gt;excepci&amp;oacute;n&lt;/a&gt; (esto generalmente requiere que se declare expl&amp;iacute;citamente &lt;code&gt;noexcept(false)&lt;/code&gt; ) (desde C ++ 11), sin embargo, si este destructor se llama durante el &lt;a href=&quot;throw&quot;&gt;desenrollado de la pila&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; se llama en su lugar.</target>
        </trans-unit>
        <trans-unit id="7a66bb24008dddd2f1f26becdeebf04e56826247" translate="yes" xml:space="preserve">
          <source>As defined above.</source>
          <target state="translated">Como se definió anteriormente.</target>
        </trans-unit>
        <trans-unit id="a534c811c2d3571f2ae27f157ef19b52a844ad05" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">Como se describe en &lt;a href=&quot;../../named_req/callable&quot;&gt;invocable&lt;/a&gt; , cuando se invoca un puntero a una funci&amp;oacute;n miembro no est&amp;aacute;tica o un puntero a un miembro de datos no est&amp;aacute;tico, el primer argumento debe ser una referencia o un puntero (incluido, posiblemente, un puntero inteligente como &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; ) a un objeto a cuyo miembro se acceder&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="9ee2578ea146050c5227b8b046d49c6f68518e95" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;../memory/new/operator_new&quot;&gt; allocation function&lt;/a&gt;, the C++ program may provide global and class-specific replacements for these functions. If the new-expression begins with the optional &lt;code&gt;::&lt;/code&gt; operator, as in &lt;code&gt;::new T&lt;/code&gt; or &lt;code&gt;::new T[n]&lt;/code&gt;, class-specific replacements will be ignored (the function is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; in global &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt;). Otherwise, if &lt;code&gt;T&lt;/code&gt; is a class type, lookup begins in the class scope of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Como se describe en la &lt;a href=&quot;../memory/new/operator_new&quot;&gt;funci&amp;oacute;n de asignaci&amp;oacute;n&lt;/a&gt; , el programa C ++ puede proporcionar reemplazos globales y espec&amp;iacute;ficos de clase para estas funciones. Si la nueva expresi&amp;oacute;n comienza con el operador opcional &lt;code&gt;::&lt;/code&gt; , como en &lt;code&gt;::new T&lt;/code&gt; o &lt;code&gt;::new T[n]&lt;/code&gt; , se ignorar&amp;aacute;n los reemplazos espec&amp;iacute;ficos de clase (la funci&amp;oacute;n se &lt;a href=&quot;lookup&quot;&gt;busca&lt;/a&gt; en el &lt;a href=&quot;scope&quot;&gt;&amp;aacute;mbito&lt;/a&gt; global ). De lo contrario, si &lt;code&gt;T&lt;/code&gt; es un tipo de clase, la b&amp;uacute;squeda se inicia en el &amp;aacute;mbito de la clase de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03fe97a528d16f7fe7e71f5717247af8db4822bd" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;explicit_cast&quot;&gt;functional cast&lt;/a&gt;, the syntax &lt;code&gt;T()&lt;/code&gt;(1) is prohibited for arrays, while &lt;code&gt;T{}&lt;/code&gt;(5) is allowed.</source>
          <target state="translated">Como se describe en la &lt;a href=&quot;explicit_cast&quot;&gt;conversi&amp;oacute;n funcional&lt;/a&gt; , la sintaxis &lt;code&gt;T()&lt;/code&gt; (1) est&amp;aacute; prohibida para las matrices, mientras que &lt;code&gt;T{}&lt;/code&gt; (5) est&amp;aacute; permitida.</target>
        </trans-unit>
        <trans-unit id="f2a24edd45dbf727b01f52b1b2fe43e48097af38" translate="yes" xml:space="preserve">
          <source>As described in &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;non-local initialization&lt;/a&gt;, static and thread-local variables that aren't constant-initialized(since C++14) are zero-initialized before any other initialization takes place. If the definition of a non-class non-local variable has no initializer, then default initialization does nothing, leaving the result of the earlier zero-initialization unmodified.</source>
          <target state="translated">Como se describe en &lt;a href=&quot;initialization#Non-local_variables&quot;&gt;la inicializaci&amp;oacute;n no local&lt;/a&gt; , las variables est&amp;aacute;ticas y locales de subprocesos que no se inicializan constantemente (ya que C ++ 14) se inicializan en cero antes de que tenga lugar cualquier otra inicializaci&amp;oacute;n. Si la definici&amp;oacute;n de una variable no local no de clase no tiene inicializador, la inicializaci&amp;oacute;n predeterminada no hace nada, dejando el resultado de la inicializaci&amp;oacute;n cero anterior sin modificar.</target>
        </trans-unit>
        <trans-unit id="08d19aea73540a5ba0404cba80c23af9e3c2ceba" translate="yes" xml:space="preserve">
          <source>As described in &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt;, when invoking a pointer to non-static member function or pointer to non-static data member, the first argument has to be a reference or pointer (including, possibly, smart pointer such as &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;) to an object whose member will be accessed.</source>
          <target state="translated">Como se describe en &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;&lt;/code&gt; , al invocar un puntero a una funci&amp;oacute;n de miembro no est&amp;aacute;tico o un puntero a un miembro de datos no est&amp;aacute;tico, el primer argumento debe ser una referencia o un puntero (incluido, posiblemente, un puntero inteligente como &lt;code&gt;&lt;a href=&quot;../../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; ) a un objeto a cuyo miembro se acceder&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="2b2d6cdbd1b2496e6a2f40aed0a78a511c900aab" translate="yes" xml:space="preserve">
          <source>As discussed in &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt;, the lookup of a dependent name used in a template is postponed until the template arguments are known, at which time.</source>
          <target state="translated">Como se discuti&amp;oacute; en la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; , la b&amp;uacute;squeda de un nombre dependiente utilizado en una plantilla se pospone hasta que se conocen los argumentos de la plantilla, momento en el cual.</target>
        </trans-unit>
        <trans-unit id="58e3f3f862eff79aa619bdf804e54d8152b28137" translate="yes" xml:space="preserve">
          <source>As formulated in C++11, the behavior of &lt;code&gt;std::result_of&lt;/code&gt; is undefined when &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is ill-formed (e.g. when F is not a callable type at all). C++14 changes that to a &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; (when F is not callable, &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; simply doesn't have the &lt;code&gt;type&lt;/code&gt; member).</source>
          <target state="translated">Como se formula en C ++ 11, el comportamiento de &lt;code&gt;std::result_of&lt;/code&gt; no est&amp;aacute; definido cuando &lt;code&gt;INVOKE(std::declval&amp;lt;F&amp;gt;(), std::declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; est&amp;aacute; mal formado (por ejemplo, cuando F no es un tipo invocable en absoluto). C ++ 14 cambia eso a &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; (cuando F no es invocable, &lt;code&gt;std::result_of&amp;lt;F(ArgTypes...)&amp;gt;&lt;/code&gt; simplemente no tiene el miembro de &lt;code&gt;type&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="937a4526e972e8900a66eaf74bf3283dd336852b" translate="yes" xml:space="preserve">
          <source>As free (namespace) function</source>
          <target state="translated">Como función libre (espacio de nombres)</target>
        </trans-unit>
        <trans-unit id="ebe6ab533cbf3972cb8d127e93ba520450789106" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop, if statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the loop body as if it was a compound statement.</source>
          <target state="translated">Como es el caso con &lt;a href=&quot;while&quot;&gt;mientras&lt;/a&gt; bucle, si la declaraci&amp;oacute;n es un solo estado (no una instrucci&amp;oacute;n compuesta), el alcance de las variables declaradas en ella se limita al cuerpo del bucle como si fuera una instrucci&amp;oacute;n compuesta.</target>
        </trans-unit>
        <trans-unit id="c00d6a8291143d3954d0476db09f338bbdf6a6a6" translate="yes" xml:space="preserve">
          <source>As is the case with &lt;code&gt;typename&lt;/code&gt;, the &lt;code&gt;template&lt;/code&gt; prefix is allowed even if the name is not dependent or the use does not appear in the scope of a template(since C++11).</source>
          <target state="translated">Como es el caso con &lt;code&gt;typename&lt;/code&gt; , el prefijo de &lt;code&gt;template&lt;/code&gt; est&amp;aacute; permitido incluso si el nombre no es dependiente o el uso no aparece en el alcance de una plantilla (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="f30e97ae154b85ba90b59b0fc7f3cc9421ecbfce" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid &lt;code&gt;weekday&lt;/code&gt; even if &lt;code&gt;wd.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Mientras el c&amp;aacute;lculo no se desborde, (1-3) siempre devuelve un &lt;code&gt;weekday&lt;/code&gt; v&amp;aacute;lido incluso si &lt;code&gt;wd.ok()&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2ffc3f13ddf954cdee7f939204ad75111f3eb7d" translate="yes" xml:space="preserve">
          <source>As long as the computation doesn't overflow, (1-3) always return a valid month even if &lt;code&gt;m.ok()&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Mientras el c&amp;aacute;lculo no se desborde, (1-3) siempre devuelve un mes v&amp;aacute;lido incluso si &lt;code&gt;m.ok()&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="974f4de3b83d59e1f68e4272f20e899a5d37454c" translate="yes" xml:space="preserve">
          <source>As member function</source>
          <target state="translated">Como función del miembro</target>
        </trans-unit>
        <trans-unit id="713b3ed5226e8894aaa4433505d652a47c900087" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;declarations#Declarators&quot;&gt;Declarations&lt;/a&gt;, the declarator can be followed by a</source>
          <target state="translated">Como se menciona en las &lt;a href=&quot;declarations#Declarators&quot;&gt;declaraciones&lt;/a&gt; , el declarador puede ser seguido por un</target>
        </trans-unit>
        <trans-unit id="49e91975e9ca17802a309ea7799083868c1165b1" translate="yes" xml:space="preserve">
          <source>As non-member function</source>
          <target state="translated">Como función de no miembro</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
