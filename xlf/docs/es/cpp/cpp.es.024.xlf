<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="42d66c9df47506c2bbd054315689658beb84bc9e" translate="yes" xml:space="preserve">
          <source>U+B0000 - U+BFFFD</source>
          <target state="translated">U+B0000-U+BFFFD</target>
        </trans-unit>
        <trans-unit id="cdba1c6047783563972c12317b4d72868b21fd76" translate="yes" xml:space="preserve">
          <source>U+C0000 - U+CFFFD</source>
          <target state="translated">U+C0000-U+CFFFD</target>
        </trans-unit>
        <trans-unit id="010072229c529f3ca79fb579b3df7190d32934a1" translate="yes" xml:space="preserve">
          <source>U+D0000 - U+DFFFD</source>
          <target state="translated">U+D0000-U+DFFFD</target>
        </trans-unit>
        <trans-unit id="ce5b442ae1391ac6f3397af8e6e2ed8bbfa37b7f" translate="yes" xml:space="preserve">
          <source>U+E0000 - U+EFFFD</source>
          <target state="translated">U+E0000-U+EFFFD</target>
        </trans-unit>
        <trans-unit id="520d6df0bba5aba46938723a37a68ea22f05a23c" translate="yes" xml:space="preserve">
          <source>U+F900 - U+FD3D</source>
          <target state="translated">U+F900-U+FD3D</target>
        </trans-unit>
        <trans-unit id="163422b76168f04b02797dee7a00db38f358ee53" translate="yes" xml:space="preserve">
          <source>U+FD40 - U+FDCF</source>
          <target state="translated">U+FD40-U+FDCF</target>
        </trans-unit>
        <trans-unit id="fb7bec8d977e924e7257c5655dae76a42823e7a8" translate="yes" xml:space="preserve">
          <source>U+FDF0 - U+FE44</source>
          <target state="translated">U+FDF0-U+FE44</target>
        </trans-unit>
        <trans-unit id="04089c7fc7f2ca3bf063171c8d318a9d6ea6bbde" translate="yes" xml:space="preserve">
          <source>U+FE20 - U+FE2F</source>
          <target state="translated">U+FE20-U+FE2F</target>
        </trans-unit>
        <trans-unit id="f56e67971694a5871856f55e8563ac4dbbcaec84" translate="yes" xml:space="preserve">
          <source>U+FE47 - U+FFFD</source>
          <target state="translated">U+FE47-U+FFFD</target>
        </trans-unit>
        <trans-unit id="270912477818594d05da0936d300cdd48568315a" translate="yes" xml:space="preserve">
          <source>U&lt;code&gt;( { &lt;/code&gt;arg1, arg2, ...&lt;code&gt;} )&lt;/code&gt;</source>
          <target state="translated">U &lt;code&gt;( { &lt;/code&gt; arg1, arg2, ... &lt;code&gt;} )&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="931d496adbd3f197940b61b27f25bcf6e5ce6062" translate="yes" xml:space="preserve">
          <source>UB</source>
          <target state="translated">UB</target>
        </trans-unit>
        <trans-unit id="02625f3ba5ef5ecc340624e8cdbc7bbea1792597" translate="yes" xml:space="preserve">
          <source>UB and optimization</source>
          <target state="translated">UB y optimización</target>
        </trans-unit>
        <trans-unit id="fc4cea3d19213a9f2ad0bf9e1d25fcd42a13416e" translate="yes" xml:space="preserve">
          <source>UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</source>
          <target state="translated">UCHAR_MAXUSHRT_MAXUINT_MAXULONG_MAXULLONG_MAX</target>
        </trans-unit>
        <trans-unit id="2cfb9dd16496ce85eff96d27557f7b42dd5f480d" translate="yes" xml:space="preserve">
          <source>UCS2</source>
          <target state="translated">UCS2</target>
        </trans-unit>
        <trans-unit id="cc245ae082a0221ea07ed3630dd9a406b15ac831" translate="yes" xml:space="preserve">
          <source>UCS2(Windows)</source>
          <target state="translated">UCS2(Windows)</target>
        </trans-unit>
        <trans-unit id="fb192521136df48247e2057851a45e670921483e" translate="yes" xml:space="preserve">
          <source>UDL</source>
          <target state="translated">UDL</target>
        </trans-unit>
        <trans-unit id="b326c17ee1a8eb3c225550246d3d3c78e82f8b2f" translate="yes" xml:space="preserve">
          <source>UINT8_CUINT16_CUINT32_CUINT64_C</source>
          <target state="translated">UINT8_CUINT16_CUINT32_CUINT64_C</target>
        </trans-unit>
        <trans-unit id="6fc76eff0c2b7cb02126a9c106ac3442a9727995" translate="yes" xml:space="preserve">
          <source>UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</source>
          <target state="translated">UINT8_MAXUINT16_MAXUINT32_MAXUINT64_MAX</target>
        </trans-unit>
        <trans-unit id="9ba6e74bce3dda604b2bb3467dd7e8066580c7b5" translate="yes" xml:space="preserve">
          <source>UINTMAX_C</source>
          <target state="translated">UINTMAX_C</target>
        </trans-unit>
        <trans-unit id="5b83709ee00794f8873850a1d8ed0fb42b4fb169" translate="yes" xml:space="preserve">
          <source>UINTMAX_MAX</source>
          <target state="translated">UINTMAX_MAX</target>
        </trans-unit>
        <trans-unit id="ce620a4e99af76df2964e767b6f8444400deb8ca" translate="yes" xml:space="preserve">
          <source>UINTPTR_MAX</source>
          <target state="translated">UINTPTR_MAX</target>
        </trans-unit>
        <trans-unit id="bfda17e335d33e8db92bdb55c45171d922a6859c" translate="yes" xml:space="preserve">
          <source>UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</source>
          <target state="translated">UINT_FAST8_MAXUINT_FAST16_MAXUINT_FAST32_MAXUINT_FAST64_MAX</target>
        </trans-unit>
        <trans-unit id="ad74c7ce12e14f74c8c414a0ec98ea6351f500a5" translate="yes" xml:space="preserve">
          <source>UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</source>
          <target state="translated">UINT_LEAST8_MAXUINT_LEAST16_MAXUINT_LEAST32_MAXUINT_LEAST64_MAX</target>
        </trans-unit>
        <trans-unit id="4196b39d1eebc6a19e223c4aac2d97a9aacf8120" translate="yes" xml:space="preserve">
          <source>UIntType</source>
          <target state="translated">UIntType</target>
        </trans-unit>
        <trans-unit id="469dc1d6169a7065a141b529a6260202a1c8ab1a" translate="yes" xml:space="preserve">
          <source>UNDERTIE - CHARACTER TIE</source>
          <target state="translated">CORBATA-CORBATA DE CARÁCTER</target>
        </trans-unit>
        <trans-unit id="505551a88f566bb8fb83e0abedb58180312ddfab" translate="yes" xml:space="preserve">
          <source>URBGs and distributions are designed to be used together to produce random values. All of the random number engines may be specifically seeded, serialized, and deserialized for use with repeatable simulators.</source>
          <target state="translated">Las URBGs y las distribuciones están diseñadas para ser usadas juntas para producir valores aleatorios.Todos los motores de números aleatorios pueden ser específicamente sembrados,seriados y deserializados para ser usados con simuladores repetibles.</target>
        </trans-unit>
        <trans-unit id="5a9da893be5fd5fae314bea8dcdeeee12beeec4b" translate="yes" xml:space="preserve">
          <source>UTF-16</source>
          <target state="translated">UTF-16</target>
        </trans-unit>
        <trans-unit id="2b2540046f34663d3e4a6d43e9cf9715c955300b" translate="yes" xml:space="preserve">
          <source>UTF-16 big-endian</source>
          <target state="translated">UTF-16 big-endian</target>
        </trans-unit>
        <trans-unit id="3e0f2acffc4ed45f148e707196e35bf9de816b83" translate="yes" xml:space="preserve">
          <source>UTF-16 little-endian</source>
          <target state="translated">UTF-16 little-endian</target>
        </trans-unit>
        <trans-unit id="9d90671c2d02729e29282121f3418c32309d8132" translate="yes" xml:space="preserve">
          <source>UTF-32</source>
          <target state="translated">UTF-32</target>
        </trans-unit>
        <trans-unit id="627eba919968fb21d35e780ba4de3a0334bac3b5" translate="yes" xml:space="preserve">
          <source>UTF-32(non-Windows)</source>
          <target state="translated">UTF-32(non-Windows)</target>
        </trans-unit>
        <trans-unit id="663b90c899fa25a111067be0c22ffc64dcf581c2" translate="yes" xml:space="preserve">
          <source>UTF-8</source>
          <target state="translated">UTF-8</target>
        </trans-unit>
        <trans-unit id="a2cdcc963eb83efa7c23e1cb852551ce54343476" translate="yes" xml:space="preserve">
          <source>UTF-8 (no effect on endianness)</source>
          <target state="translated">UTF-8 (sin efecto sobre la tutela)</target>
        </trans-unit>
        <trans-unit id="e6f9cf72db2d174ebd905a64df572642f988ef15" translate="yes" xml:space="preserve">
          <source>Unary &lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;plus and minus&lt;/a&gt;</source>
          <target state="translated">Unario &lt;a href=&quot;operator_arithmetic#Unary_arithmetic_operators&quot;&gt;m&amp;aacute;s y menos&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f5a792933066b9a9e2ac32f6f06b8c7c9b9c310a" translate="yes" xml:space="preserve">
          <source>Unary arithmetic operators</source>
          <target state="translated">Operadores aritméticos unitarios</target>
        </trans-unit>
        <trans-unit id="3b2a4a75a6716bd612609078150c84a2711d8a91" translate="yes" xml:space="preserve">
          <source>UnaryTypeTrait</source>
          <target state="translated">UnaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="487d4ab7256ac0a9d6c0537cc67b1af3240a7a6a" translate="yes" xml:space="preserve">
          <source>Unblocks all threads currently waiting for &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Desbloquea todos los hilos que actualmente esperan &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a36f6dfc5a6d8e565414aa5eb95d57c3673c1b95" translate="yes" xml:space="preserve">
          <source>Undefined Behavior</source>
          <target state="translated">Comportamiento indefinido</target>
        </trans-unit>
        <trans-unit id="ae22d7da41718d2107d501afa593d0dc097c049a" translate="yes" xml:space="preserve">
          <source>Undefined Behavior and Fermat&amp;rsquo;s Last Theorem</source>
          <target state="translated">Comportamiento indefinido y &amp;uacute;ltimo teorema de Fermat</target>
        </trans-unit>
        <trans-unit id="ebb35fed37a359f87ca6b9131bfd7b210eb81cd6" translate="yes" xml:space="preserve">
          <source>Undefined behavior</source>
          <target state="translated">Comportamiento indefinido</target>
        </trans-unit>
        <trans-unit id="675cd8702b8351b311d54416e35e1e88d24ddc83" translate="yes" xml:space="preserve">
          <source>Undefined behavior can result in time travel (among other things, but time travel is the funkiest)</source>
          <target state="translated">El comportamiento indefinido puede resultar en un viaje en el tiempo (entre otras cosas,pero el viaje en el tiempo es el más funky)</target>
        </trans-unit>
        <trans-unit id="148339d92ffb0ef43ac5c644f243daf7596715dc" translate="yes" xml:space="preserve">
          <source>Under a</source>
          <target state="translated">Bajo un</target>
        </trans-unit>
        <trans-unit id="9b9209c5de57506f2fda8e822d2a3ad3f311f55e" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are permitted, but not required to omit the copy and move(since C++11) construction of class objects even if the copy/move(since C++11) constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. This is an optimization: even when it takes place and the copy/move(since C++11) constructor is not called, it still must be present and accessible (as if no optimization happened at all), otherwise the program is ill-formed:</source>
          <target state="translated">En las siguientes circunstancias,los compiladores están permitidos,pero no están obligados a omitir la construcción de la copia y el movimiento (desde C++11)de los objetos de clase,incluso si el constructor de la copia y el movimiento (desde C++11)y el destructor tienen efectos secundarios observables.Los objetos se construyen directamente en el almacén donde de otra manera se copiarían/moverían.Esto es una optimización:incluso cuando tiene lugar y no se llama al constructor copy/move(desde C++11),éste debe estar presente y accesible (como si no hubiera habido ninguna optimización),de lo contrario el programa está mal formado:</target>
        </trans-unit>
        <trans-unit id="3bea3f4316b2cc744d56328e836cf72a7190a46d" translate="yes" xml:space="preserve">
          <source>Under the following circumstances, the compilers are required to omit the copy and move construction of class objects, even if the copy/move constructor and the destructor have observable side-effects. The objects are constructed directly into the storage where they would otherwise be copied/moved to. The copy/move constructors need not be present or accessible, as the language rules ensure that no copy/move operation takes place, even conceptually:</source>
          <target state="translated">En las siguientes circunstancias,los compiladores están obligados a omitir la copia y mover la construcción de los objetos de clase,incluso si el constructor de la copia/movimiento y el destructor tienen efectos secundarios observables.Los objetos se construyen directamente en el almacén donde de otro modo se copiarían/moverían.No es necesario que los constructores de copia/movimiento estén presentes o accesibles,ya que las reglas del lenguaje aseguran que no se produzca ninguna operación de copia/movimiento,ni siquiera conceptualmente:</target>
        </trans-unit>
        <trans-unit id="9c33868b413394e75c10c66bbcac09ee4be1866f" translate="yes" xml:space="preserve">
          <source>Under these conditions, it can be shown that &lt;code&gt;e&lt;/code&gt; is an equivalence relation, and &lt;code&gt;r&lt;/code&gt; induces a strict total ordering on the equivalence classes determined by &lt;code&gt;e&lt;/code&gt;.</source>
          <target state="translated">En estas condiciones, se puede demostrar que &lt;code&gt;e&lt;/code&gt; es una relaci&amp;oacute;n de equivalencia, y &lt;code&gt;r&lt;/code&gt; induce un ordenamiento total estricto en las clases de equivalencia determinadas por &lt;code&gt;e&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b828bc3cb0b877121715201877f23784c033074d" translate="yes" xml:space="preserve">
          <source>Underflow is guaranteed if &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt;  erf(</source>
          <target state="translated">El desbordamiento est&amp;aacute; garantizado si &lt;code&gt;|arg| &amp;lt; &lt;a href=&quot;../../types/climits&quot;&gt;DBL_MIN&lt;/a&gt;*(sqrt(&amp;pi;)/2)&lt;/code&gt; erf (</target>
        </trans-unit>
        <trans-unit id="5b4fe0953f656d5c3e07304963135e1851f6e5c7" translate="yes" xml:space="preserve">
          <source>Understanding Integer Overflow in C/C++</source>
          <target state="translated">Comprensión del desbordamiento de enteros en C/C++</target>
        </trans-unit>
        <trans-unit id="5e6066d0264c25a17abb92da4543d5a1bb3137db" translate="yes" xml:space="preserve">
          <source>Unevaluated expressions</source>
          <target state="translated">Expresiones no evaluadas</target>
        </trans-unit>
        <trans-unit id="28df9f930dfb483b42b3b26d6ba0e60a90d200c5" translate="yes" xml:space="preserve">
          <source>Unformatted input</source>
          <target state="translated">Entrada sin formato</target>
        </trans-unit>
        <trans-unit id="123f1fcb3edd17ce760e7f03ab6319443c344106" translate="yes" xml:space="preserve">
          <source>Unformatted input/output</source>
          <target state="translated">Entrada/salida sin formato</target>
        </trans-unit>
        <trans-unit id="b123c392cb4c8cf5311ee23670ea9ec4b71c524c" translate="yes" xml:space="preserve">
          <source>Unformatted output</source>
          <target state="translated">Salida sin formato</target>
        </trans-unit>
        <trans-unit id="1103a0808298976db7d8e2eb535bd8a9ef0b0697" translate="yes" xml:space="preserve">
          <source>UnformattedInputFunction</source>
          <target state="translated">UnformattedInputFunction</target>
        </trans-unit>
        <trans-unit id="57c86519dc947e7a7668db91684400955bbea92e" translate="yes" xml:space="preserve">
          <source>UnformattedOutputFunction</source>
          <target state="translated">UnformattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="746515815dbd70aa366c5c8ded38ceac411af5b5" translate="yes" xml:space="preserve">
          <source>Unicode characters in identifiers</source>
          <target state="translated">Caracteres de Unicode en los identificadores</target>
        </trans-unit>
        <trans-unit id="54c4cd3614eda1ec572a80ea2561789d6ec07f9a" translate="yes" xml:space="preserve">
          <source>Unicode conversion facilities</source>
          <target state="translated">Facilidades de conversión a Unicode</target>
        </trans-unit>
        <trans-unit id="518945c57eea6f988b28705fe9a73ae61f28aad7" translate="yes" xml:space="preserve">
          <source>Unicode string literals</source>
          <target state="translated">Literales de cadena de Unicode</target>
        </trans-unit>
        <trans-unit id="1d88fe66c0582c456f5ec5c8716a0f875d9594aa" translate="yes" xml:space="preserve">
          <source>Uniform container erasure</source>
          <target state="translated">Borrado uniforme del contenedor</target>
        </trans-unit>
        <trans-unit id="2d5f1d913211ede3bdf584eacf2d1f866d30dd39" translate="yes" xml:space="preserve">
          <source>Uniform distributions</source>
          <target state="translated">Distribuciones uniformes</target>
        </trans-unit>
        <trans-unit id="ebaf278dff4a479e5c381e2d14da13ed28569d5b" translate="yes" xml:space="preserve">
          <source>Uniform random bit generator requirements</source>
          <target state="translated">Requisitos del generador de bits aleatorios uniformes</target>
        </trans-unit>
        <trans-unit id="43fc79a87964e43367c8f806ef4c1bc6c3c17e50" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators</source>
          <target state="translated">Generadores de bits aleatorios uniformes</target>
        </trans-unit>
        <trans-unit id="304d61b117a4be33152a4987bccb311ec8786d3d" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators (URBGs), which include both random number engines, which are pseudo-random number generators that generate integer sequences with a uniform distribution, and true random number generators if available;</source>
          <target state="translated">Generadores de bits aleatorios uniformes (URBG),que incluyen tanto motores de números aleatorios,que son generadores de números pseudoaleatorios que generan secuencias de números enteros con una distribución uniforme,como generadores de números aleatorios verdaderos,si están disponibles;</target>
        </trans-unit>
        <trans-unit id="9961b884b0d41e9f96e9b47f18701458382481af" translate="yes" xml:space="preserve">
          <source>Uniform random bit generators are not intended to be used as random number generators: they are used as the source of random bits (generated in bulk, for efficiency). Any uniform random bit generator may be plugged into any &lt;a href=&quot;../numeric/random&quot;&gt;random number distribution&lt;/a&gt; in order to obtain a random number (formally, a random variate).</source>
          <target state="translated">Los generadores uniformes de bits aleatorios no est&amp;aacute;n destinados a ser utilizados como generadores de n&amp;uacute;meros aleatorios: se utilizan como fuente de bits aleatorios (generados en masa, para mayor eficiencia). Cualquier generador de bits aleatorio uniforme puede conectarse a cualquier &lt;a href=&quot;../numeric/random&quot;&gt;distribuci&amp;oacute;n de n&amp;uacute;meros aleatorios&lt;/a&gt; para obtener un n&amp;uacute;mero aleatorio (formalmente, una variante aleatoria).</target>
        </trans-unit>
        <trans-unit id="274ada2867567ab3047cbbf8de81549c088960b3" translate="yes" xml:space="preserve">
          <source>UniformRandomBitGenerator</source>
          <target state="translated">UniformRandomBitGenerator</target>
        </trans-unit>
        <trans-unit id="a1a52383b2bc722ac899de02954f212432e3b35b" translate="yes" xml:space="preserve">
          <source>Uninitialized scalar</source>
          <target state="translated">Escalar no inicializado</target>
        </trans-unit>
        <trans-unit id="78a4eb44ac157ac9e3cfb278647cea168bf4035b" translate="yes" xml:space="preserve">
          <source>Uninitialized storage</source>
          <target state="translated">Almacenamiento no inicializado</target>
        </trans-unit>
        <trans-unit id="669a8f132f6da5ef9c5ce154e361c127d5e3b34d" translate="yes" xml:space="preserve">
          <source>Union declaration</source>
          <target state="translated">Declaración de la Unión</target>
        </trans-unit>
        <trans-unit id="8b963a92c98e754dacda8255ebe746d63728ca26" translate="yes" xml:space="preserve">
          <source>Union-like classes</source>
          <target state="translated">Clases de unión</target>
        </trans-unit>
        <trans-unit id="3c64374ae8a1f69718dd9c2a053e7f58d07b77ab" translate="yes" xml:space="preserve">
          <source>Union-like classes can be used to implement &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;tagged unions&lt;/a&gt;.</source>
          <target state="translated">Las clases tipo uni&amp;oacute;n pueden usarse para implementar &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;uniones etiquetadas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b88a7a2c81e25c95a2b907495a6fc73639f9b55f" translate="yes" xml:space="preserve">
          <source>Unions cannot contain a non-static data member with a non-trivial special member function (&lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy-assignment&lt;/a&gt; operator, or &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;).</source>
          <target state="translated">Uniones no pueden contener un miembro de datos no est&amp;aacute;tica con una funci&amp;oacute;n miembro especial no trivial ( &lt;a href=&quot;copy_constructor&quot;&gt;constructor de copia&lt;/a&gt; , &lt;a href=&quot;as_operator&quot;&gt;copiar-asignaci&amp;oacute;n&lt;/a&gt; operador, o &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="bfa43e96dbedcb883a94acbaaea9cf15eba0504f" translate="yes" xml:space="preserve">
          <source>Unique integer for use as pword/iword index.</source>
          <target state="translated">Entero único para su uso como índice de palabras/palabras clave.</target>
        </trans-unit>
        <trans-unit id="d66a64b1da303d5c4d195ea302bf616e42aaa173" translate="yes" xml:space="preserve">
          <source>Unit type intended for use as a well-behaved empty alternative in &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt;. In particular, a variant of non-default-constructible types may list &lt;code&gt;std::monostate&lt;/code&gt; as its first alternative: this makes the variant itself default-constructible.</source>
          <target state="translated">Tipo de unidad destinada a ser utilizada como una alternativa vac&amp;iacute;a con buen comportamiento en &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; . En particular, una variante de tipos no construibles por defecto puede incluir &lt;code&gt;std::monostate&lt;/code&gt; como su primera alternativa: esto hace que la variante en s&amp;iacute; misma sea construible por defecto.</target>
        </trans-unit>
        <trans-unit id="43b3c1af3450df3cd0e1ac52c9b04b756ccd01b6" translate="yes" xml:space="preserve">
          <source>Unix and Unix-like systems (Linux, Mac OS X)</source>
          <target state="translated">Unix y sistemas similares a Unix (Linux,Mac OS X)</target>
        </trans-unit>
        <trans-unit id="efec0246344a5eba097c63d394ab6c8738a45789" translate="yes" xml:space="preserve">
          <source>Unknown permissions (e.g. when &lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt; is created without permissions)</source>
          <target state="translated">Permisos desconocidos (por ejemplo, cuando &lt;a href=&quot;file_status&quot;&gt;file_status&lt;/a&gt; se crea sin permisos)</target>
        </trans-unit>
        <trans-unit id="689c51725b427087666b6048cec59bcb29fcbece" translate="yes" xml:space="preserve">
          <source>Unknown specializations</source>
          <target state="translated">Especializaciones desconocidas</target>
        </trans-unit>
        <trans-unit id="fc9481ccc42310377001eaf4b65f0ba7f43291d9" translate="yes" xml:space="preserve">
          <source>Unless</source>
          <target state="translated">Unless</target>
        </trans-unit>
        <trans-unit id="2103e6143f9ffb325540052fdb6e95f6374d7553" translate="yes" xml:space="preserve">
          <source>Unless &lt;a href=&quot;../preprocessor/impl&quot;&gt;&lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt;&lt;/a&gt; is supported and set to &lt;code&gt;OFF&lt;/code&gt;, all floating-point arithmetic may be performed as if the intermediate results have infinite range and precision, that is, optimizations that omit rounding errors and floating-point exceptions are allowed. For example, C++ allows the implementation of &lt;code&gt;(x*y) + z&lt;/code&gt; with a single fused multiply-add CPU instruction or optimization of &lt;code&gt;a = x*x*x*x;&lt;/code&gt; as &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt;.</source>
          <target state="translated">A menos que &lt;a href=&quot;../preprocessor/impl&quot;&gt; &lt;code&gt; #pragma STDC FP_CONTRACT&lt;/code&gt; &lt;/a&gt; sea ​​compatible y se establezca en &lt;code&gt;OFF&lt;/code&gt; , toda la aritm&amp;eacute;tica de coma flotante se puede realizar como si los resultados intermedios tuvieran un rango y precisi&amp;oacute;n infinitos, es decir, se permiten optimizaciones que omiten errores de redondeo y excepciones de coma flotante. Por ejemplo, C ++ permite la implementaci&amp;oacute;n de &lt;code&gt;(x*y) + z&lt;/code&gt; con una sola instrucci&amp;oacute;n de CPU con m&amp;uacute;ltiples agregados fusionados u optimizaci&amp;oacute;n de &lt;code&gt;a = x*x*x*x;&lt;/code&gt; como &lt;code&gt;tmp = x *x; a = tmp*tmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07db20d2d23583077e6ea6e7dac4ed0dbdee1a6b" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted input.</source>
          <target state="translated">A menos que se haya emitido &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; , es seguro acceder simult&amp;aacute;neamente a estos objetos desde m&amp;uacute;ltiples hilos para entradas formateadas y no formateadas.</target>
        </trans-unit>
        <trans-unit id="24cf8fcc45f1c3c9991d569649560b6a524615c5" translate="yes" xml:space="preserve">
          <source>Unless &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; has been issued, it is safe to concurrently access these objects from multiple threads for both formatted and unformatted output.</source>
          <target state="translated">A menos que se haya emitido &lt;code&gt;sync_with_stdio(false)&lt;/code&gt; , es seguro acceder simult&amp;aacute;neamente a estos objetos desde m&amp;uacute;ltiples subprocesos para resultados formateados y no formateados.</target>
        </trans-unit>
        <trans-unit id="ffb634a2a2ce0ccfeec2cc3fe27d921270b24978" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">A menos que ocurra un error de rango, se ignora el &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo actual&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b15a066b3b603647166b0b65f64183254893ada5" translate="yes" xml:space="preserve">
          <source>Unless a range error occurs, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised (the result is exact)</source>
          <target state="translated">A menos que ocurra un error de rango, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; nunca se eleva (el resultado es exacto)</target>
        </trans-unit>
        <trans-unit id="7a8fedd6b20728353d81d9da733470bcfcd14b54" translate="yes" xml:space="preserve">
          <source>Unless a variable template was &lt;a href=&quot;template_specialization&quot;&gt;explicitly specialized&lt;/a&gt; or explicitly instantiated, it is implicitly instantiated when a specialization of the variable template is used.</source>
          <target state="translated">A menos que una plantilla variable haya sido &lt;a href=&quot;template_specialization&quot;&gt;expl&amp;iacute;citamente especializada&lt;/a&gt; o expl&amp;iacute;citamente instanciada, se crea una instancia impl&amp;iacute;cita cuando se utiliza una especializaci&amp;oacute;n de la plantilla variable.</target>
        </trans-unit>
        <trans-unit id="73ad983fb74c97b086aa0802f13da903aa886831" translate="yes" xml:space="preserve">
          <source>Unless noted otherwise, every expression used in a</source>
          <target state="translated">A menos que se indique lo contrario,toda expresión utilizada en una</target>
        </trans-unit>
        <trans-unit id="0e8d48b8c7d263f43322d50666aca5a3f152bb21" translate="yes" xml:space="preserve">
          <source>Unless otherwise specified, all standard library objects that have been moved from are placed in a valid but unspecified state. That is, only the functions without preconditions, such as the assignment operator, can be safely used on the object after it was moved from:</source>
          <target state="translated">A menos que se especifique lo contrario,todos los objetos estándar de la biblioteca de los que se han movido se colocan en un estado válido pero no especificado.Es decir,sólo las funciones sin condiciones previas,como el operador de asignación,pueden utilizarse con seguridad en el objeto después de que se haya desplazado:</target>
        </trans-unit>
        <trans-unit id="50f2a51822d2bc1f7472ad730cc910af100ceb07" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;../optional/hash&quot;&gt;&lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt;&lt;/a&gt;, hash of a variant does not typically equal the hash of the contained value; this makes it possible to distinguish &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; holding the same value as different alternatives.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;../optional/hash&quot;&gt; &lt;code&gt;std::hash&amp;lt;std::optional&amp;gt;&lt;/code&gt; &lt;/a&gt; , el hash de una variante no suele ser igual al hash del valor contenido; Esto hace posible distinguir &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&amp;lt;int, int&amp;gt;&lt;/code&gt; manteniendo el mismo valor que diferentes alternativas.</target>
        </trans-unit>
        <trans-unit id="338f8ce75fb81cb04c2ab9cbb733a6def87c3d13" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, it can be used in multipass algorithms.</source>
          <target state="translated">A diferencia de &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; y &lt;a href=&quot;outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , se puede usar en algoritmos multipass.</target>
        </trans-unit>
        <trans-unit id="612a7e68b15f6d911dae610df0e6c53ee095c272" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">A diferencia de &lt;a href=&quot;insert&quot;&gt;insertar&lt;/a&gt; o &lt;a href=&quot;emplace&quot;&gt;colocar&lt;/a&gt; , estas funciones no se mueven de los argumentos de valor si la inserci&amp;oacute;n no ocurre, lo que facilita la manipulaci&amp;oacute;n de mapas cuyos valores son tipos de solo movimiento, como &lt;code&gt;std::map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; . Adem&amp;aacute;s, &lt;code&gt;try_emplace&lt;/code&gt; trata la clave y los argumentos de &lt;code&gt;mapped_type&lt;/code&gt; por separado, a diferencia de &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; , que requiere los argumentos para construir un &lt;code&gt;value_type&lt;/code&gt; (es decir, un &lt;code&gt;std::pair&lt;/code&gt; :) .</target>
        </trans-unit>
        <trans-unit id="6875db19fce8401ca9aebbb20205b26bb728d1fd" translate="yes" xml:space="preserve">
          <source>Unlike &lt;a href=&quot;insert&quot;&gt;insert&lt;/a&gt; or &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, these functions do not move from rvalue arguments if the insertion does not happen, which makes it easy to manipulate maps whose values are move-only types, such as &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt;. In addition, &lt;code&gt;try_emplace&lt;/code&gt; treats the key and the arguments to the &lt;code&gt;mapped_type&lt;/code&gt; separately, unlike &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt;, which requires the arguments to construct a &lt;code&gt;value_type&lt;/code&gt; (that is, a &lt;code&gt;std::pair&lt;/code&gt;).</source>
          <target state="translated">A diferencia de &lt;a href=&quot;insert&quot;&gt;insertar&lt;/a&gt; o &lt;a href=&quot;emplace&quot;&gt;colocar&lt;/a&gt; , estas funciones no se mueven desde los argumentos de valor si la inserci&amp;oacute;n no ocurre, lo que facilita la manipulaci&amp;oacute;n de mapas cuyos valores son tipos de solo movimiento, como &lt;code&gt;std::unordered_map&amp;lt;std::string, std::unique_ptr&amp;lt;foo&amp;gt;&amp;gt;&lt;/code&gt; . Adem&amp;aacute;s, &lt;code&gt;try_emplace&lt;/code&gt; trata la clave y los argumentos de &lt;code&gt;mapped_type&lt;/code&gt; por separado, a diferencia de &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; , que requiere los argumentos para construir un &lt;code&gt;value_type&lt;/code&gt; (es decir, un &lt;code&gt;std::pair&lt;/code&gt; :) .</target>
        </trans-unit>
        <trans-unit id="2de29ed23c34ba831619b83b8554947943971200" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; and string literals, &lt;code&gt;data()&lt;/code&gt; may return a pointer to a buffer that is not null-terminated. Therefore it is typically a mistake to pass &lt;code&gt;data()&lt;/code&gt; to a routine that takes just a &lt;code&gt;const CharT*&lt;/code&gt; and expects a null-terminated string.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../basic_string/data&quot;&gt;std::basic_string::data()&lt;/a&gt;&lt;/code&gt; y los literales de cadena, &lt;code&gt;data()&lt;/code&gt; puede devolver un puntero a un b&amp;uacute;fer que no tiene terminaci&amp;oacute;n nula. Por lo tanto, generalmente es un error pasar &lt;code&gt;data()&lt;/code&gt; a una rutina que solo toma un &lt;code&gt;const CharT*&lt;/code&gt; y espera una cadena terminada en nulo.</target>
        </trans-unit>
        <trans-unit id="b42b73288e226f5ad79616019df229c7343f10e7" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; has undefined behavior instead of returning &lt;code&gt;CharT()&lt;/code&gt;.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../basic_string/operator_at&quot;&gt;std::basic_string::operator[]&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::basic_string_view::operator[](size())&lt;/code&gt; tiene un comportamiento indefinido en lugar de devolver &lt;code&gt;CharT()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82cf3dbf0c22a41175cd7995812ae5e616d63672" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt;, this function does not update static storage: it stores the parser state in the user-provided location.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../byte/strtok&quot;&gt;std::strtok&lt;/a&gt;&lt;/code&gt; , esta funci&amp;oacute;n no actualiza el almacenamiento est&amp;aacute;tico: almacena el estado del analizador en la ubicaci&amp;oacute;n proporcionada por el usuario.</target>
        </trans-unit>
        <trans-unit id="4887cd4b1d808c0fb500939d898308b30c68c620" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../greater&quot;&gt;std::greater&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ranges::greater&lt;/code&gt; requiere que los seis operadores de comparaci&amp;oacute;n &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt; &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt; v&amp;aacute;lidos (a trav&amp;eacute;s de la restricci&amp;oacute;n StrictTotallyOrderedWith ) y est&amp;aacute; completamente definido en t&amp;eacute;rminos de &lt;code&gt;std::ranges::less&lt;/code&gt; . Sin embargo, la implementaci&amp;oacute;n es libre de usar &lt;code&gt;operator&amp;gt;&lt;/code&gt; directamente, porque esos conceptos requieren que los resultados de los operadores de comparaci&amp;oacute;n sean consistentes.</target>
        </trans-unit>
        <trans-unit id="76b2faafc9a3dbd22464e63c0ec0383467b9c99f" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;gt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../greater_equal&quot;&gt;std::greater_equal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ranges::greater_equal&lt;/code&gt; requiere que los seis operadores de comparaci&amp;oacute;n &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt; &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt; v&amp;aacute;lidos (a trav&amp;eacute;s de la restricci&amp;oacute;n StrictTotallyOrderedWith ) y est&amp;aacute; completamente definido en t&amp;eacute;rminos de &lt;code&gt;std::ranges::less&lt;/code&gt; . Sin embargo, la implementaci&amp;oacute;n es gratuita para usar el &lt;code&gt;operator&amp;gt;=&lt;/code&gt; directamente, porque esos conceptos requieren que los resultados de los operadores de comparaci&amp;oacute;n sean consistentes.</target>
        </trans-unit>
        <trans-unit id="78dbcad5e4fbe558a33518be37657107f091659c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::less_equal&lt;/code&gt; requires all six comparison operators &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;gt;=&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt; constraint) and is entirely defined in terms of &lt;code&gt;std::ranges::less&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator&amp;lt;=&lt;/code&gt; directly, because those concepts require the results of the comparison operators to be consistent.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../less_equal&quot;&gt;std::less_equal&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ranges::less_equal&lt;/code&gt; requiere que los seis operadores de comparaci&amp;oacute;n &lt;code&gt;&amp;lt;&lt;/code&gt; , &lt;code&gt;&amp;lt;=&lt;/code&gt; , &lt;code&gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;gt;=&lt;/code&gt; , &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt; &lt;a href=&quot;../../../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt; v&amp;aacute;lidos (a trav&amp;eacute;s de la restricci&amp;oacute;n StrictTotallyOrderedWith ) y est&amp;aacute; completamente definido en t&amp;eacute;rminos de &lt;code&gt;std::ranges::less&lt;/code&gt; . Sin embargo, la implementaci&amp;oacute;n es gratuita para usar el &lt;code&gt;operator&amp;lt;=&lt;/code&gt; directamente, porque esos conceptos requieren que los resultados de los operadores de comparaci&amp;oacute;n sean consistentes.</target>
        </trans-unit>
        <trans-unit id="98c9c16f2e98cd689703db22c46385c7c82dbbfc" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt;, this operator never inserts a new element into the container.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../map/operator_at&quot;&gt;std::map::operator[]&lt;/a&gt;&lt;/code&gt; , este operador nunca inserta un nuevo elemento en el contenedor.</target>
        </trans-unit>
        <trans-unit id="83c22ec940642abd3fc1b2b3f91bda4fefd9187c" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; requires both &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be valid (via the &lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt;&lt;code&gt;EqualityComparableWith&lt;/code&gt;&lt;/a&gt; constraint), and is entirely defined in terms of &lt;code&gt;std::ranges::equal_to&lt;/code&gt;. However, the implementation is free to use &lt;code&gt;operator!=&lt;/code&gt; directly, because those concepts require the results of &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt; to be consistent.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../not_equal_to&quot;&gt;std::not_equal_to&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ranges::not_equal_to&lt;/code&gt; requiere que ambos &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt; Sean v&amp;aacute;lidos (a trav&amp;eacute;s de la restricci&amp;oacute;n &lt;a href=&quot;../../../concepts/equalitycomparable&quot;&gt; &lt;code&gt;EqualityComparableWith&lt;/code&gt; &lt;/a&gt; ), y est&amp;aacute; completamente definido en t&amp;eacute;rminos de &lt;code&gt;std::ranges::equal_to&lt;/code&gt; . Sin embargo, la implementaci&amp;oacute;n es gratuita para usar &lt;code&gt;operator!=&lt;/code&gt; Directamente, porque esos conceptos requieren que los resultados de &lt;code&gt;==&lt;/code&gt; y &lt;code&gt;!=&lt;/code&gt; Sean consistentes.</target>
        </trans-unit>
        <trans-unit id="a93ac31e396db5acf4776ae92718a031c6e2a35d" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; (which has &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;), &lt;code&gt;std::make_unique&lt;/code&gt; does not have an allocator-aware counterpart. A hypothetical &lt;code&gt;allocate_unique&lt;/code&gt; would be required to invent the deleter type &lt;code&gt;D&lt;/code&gt; for the &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; it returns which would contain an allocator object and invoke both &lt;code&gt;destroy&lt;/code&gt; and &lt;code&gt;deallocate&lt;/code&gt; in its &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; (que tiene &lt;code&gt;&lt;a href=&quot;../shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; ), &lt;code&gt;std::make_unique&lt;/code&gt; no tiene una contraparte compatible con el asignador. Se requerir&amp;iacute;a un &lt;code&gt;allocate_unique&lt;/code&gt; hipot&amp;eacute;tico para inventar el borrador tipo &lt;code&gt;D&lt;/code&gt; para el &lt;code&gt;unique_ptr&amp;lt;T,D&amp;gt;&lt;/code&gt; que devuelve, que contendr&amp;iacute;a un objeto asignador e invocar&amp;iacute;a &lt;code&gt;destroy&lt;/code&gt; y &lt;code&gt;deallocate&lt;/code&gt; en su &lt;code&gt;operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfa95d30700702ce194a65101a9f73a0be8c3e37" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt;, the deleter of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; is invoked even if the managed pointer is null.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; , el eliminador de &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; se invoca incluso si el puntero administrado es nulo.</target>
        </trans-unit>
        <trans-unit id="bcc84ea13a79573b43e6585e6b696a907d0811f1" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt;, this manipulator does not flush the stream.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; , este manipulador no vac&amp;iacute;a la secuencia.</target>
        </trans-unit>
        <trans-unit id="efa45df35e365dacc26b0c10d8f1d5381eb5b951" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt;, performs a bounds check and throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos&lt;/code&gt; does not correspond to a valid position in the bitset.</source>
          <target state="translated">A diferencia del &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt; , realiza una comprobaci&amp;oacute;n de l&amp;iacute;mites y arroja &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; si &lt;code&gt;pos&lt;/code&gt; no corresponde a una posici&amp;oacute;n v&amp;aacute;lida en el conjunto de bits.</target>
        </trans-unit>
        <trans-unit id="f987fe2de50e7bdc36ad5bea121ee3e9648279c4" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::forward_list::remove&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;erase&lt;/code&gt; acepta tipos heterog&amp;eacute;neos y no fuerza una conversi&amp;oacute;n al tipo de valor del contenedor antes de invocar el operador &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="173b793fffeab067a076675a0bbf0ba3c09de869" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;erase&lt;/code&gt; accepts heterogenous types and does not force a conversion to the container's value type before invoking the &lt;code&gt;==&lt;/code&gt; operator.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;remove&quot;&gt;std::list::remove&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;erase&lt;/code&gt; acepta tipos heterog&amp;eacute;neos y no fuerza una conversi&amp;oacute;n al tipo de valor del contenedor antes de invocar el operador &lt;code&gt;==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c977d4a7c4e43375bfbd8db6568cbdff01d3089" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::unique_ptr&lt;/code&gt; may manage an object through any custom handle type that satisfies &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt;. This allows, for example, managing objects located in shared memory, by supplying a &lt;code&gt;Deleter&lt;/code&gt; that defines &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; or another &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;fancy pointer&lt;/a&gt;.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::unique_ptr&lt;/code&gt; puede administrar un objeto a trav&amp;eacute;s de cualquier tipo de identificador personalizado que satisfaga &lt;a href=&quot;../named_req/nullablepointer&quot;&gt;NullablePointer&lt;/a&gt; . Esto permite, por ejemplo, administrar objetos ubicados en la memoria compartida, al proporcionar un &lt;code&gt;Deleter&lt;/code&gt; que define &lt;code&gt;typedef &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/boost/interprocess/offset_ptr.html&quot;&gt;boost::offset_ptr&lt;/a&gt; pointer;&lt;/code&gt; u otro &lt;a href=&quot;../named_req/allocator#Fancy_pointers&quot;&gt;puntero elegante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1573c755f58e9c4746c81740477c0b3b24dac236" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt;, does not throw exceptions: the behavior is undefined if &lt;code&gt;pos&lt;/code&gt; is out of bounds.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;test&quot;&gt;test()&lt;/a&gt;&lt;/code&gt; , no arroja excepciones: el comportamiento no est&amp;aacute; definido si la &lt;code&gt;pos&lt;/code&gt; ici&amp;oacute;n est&amp;aacute; fuera de los l&amp;iacute;mites.</target>
        </trans-unit>
        <trans-unit id="6eba30f9f21127f9176b2a660cfad2f04c8b9efb" translate="yes" xml:space="preserve">
          <source>Unlike &lt;code&gt;static_cast&lt;/code&gt;, but like &lt;code&gt;const_cast&lt;/code&gt;, the &lt;code&gt;reinterpret_cast&lt;/code&gt; expression does not compile to any CPU instructions (except when converting between integers and pointers or on obscure architectures where pointer representation depends on its type). It is purely a compile-time directive which instructs the compiler to treat expression as if it had the type new_type.</source>
          <target state="translated">A diferencia de &lt;code&gt;static_cast&lt;/code&gt; , pero como &lt;code&gt;const_cast&lt;/code&gt; , la expresi&amp;oacute;n &lt;code&gt;reinterpret_cast&lt;/code&gt; no se compila con ninguna instrucci&amp;oacute;n de CPU (excepto cuando se convierte entre enteros y punteros o en arquitecturas oscuras donde la representaci&amp;oacute;n del puntero depende de su tipo). Es puramente una directiva de tiempo de compilaci&amp;oacute;n que le indica al compilador que trate la expresi&amp;oacute;n como si tuviera el tipo new_type.</target>
        </trans-unit>
        <trans-unit id="f39585865906a9f2075869fd7919be30089c3370" translate="yes" xml:space="preserve">
          <source>Unlike Rule of Three, failing to provide move constructor and move assignment is usually not an error, but a missed optimization opportunity.</source>
          <target state="translated">A diferencia de la Regla de Tres,no proporcionar el constructor de la mudanza y la asignación de la misma no suele ser un error,sino una oportunidad de optimización perdida.</target>
        </trans-unit>
        <trans-unit id="57237dac9eb413318550844e3881a717ec402781" translate="yes" xml:space="preserve">
          <source>Unlike explicit constructors, which are only considered during &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; (which includes &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt; such as &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt;), converting constructors are also considered during &lt;a href=&quot;copy_initialization&quot;&gt;copy initialization&lt;/a&gt;, as part of &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt;.</source>
          <target state="translated">A diferencia de los constructores expl&amp;iacute;citos, que solo se consideran durante &lt;a href=&quot;direct_initialization&quot;&gt;la inicializaci&amp;oacute;n directa&lt;/a&gt; (que incluye &lt;a href=&quot;explicit_cast&quot;&gt;conversiones expl&amp;iacute;citas&lt;/a&gt; como &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; ), los constructores de conversi&amp;oacute;n tambi&amp;eacute;n se consideran durante la &lt;a href=&quot;copy_initialization&quot;&gt;inicializaci&amp;oacute;n de la copia&lt;/a&gt; , como parte de &lt;a href=&quot;implicit_cast&quot;&gt;la secuencia de conversi&amp;oacute;n definida por el usuario&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0519031d106f159f57ffffbcb3c189318dbf95d8" translate="yes" xml:space="preserve">
          <source>Unlike for &lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt;, the C++ standard does not explicitly require that &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; is unchanged by this function, but existing implementations do not change capacity. This means that they do not release the allocated memory (see also &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;../../container/vector/clear&quot;&gt;std::vector::clear&lt;/a&gt;&lt;/code&gt; , el C ++ est&amp;aacute;ndar no requiere expl&amp;iacute;citamente que &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity&lt;/a&gt;&lt;/code&gt; no ha cambiado por esta funci&amp;oacute;n, pero las implementaciones existentes no hacer el cambio de capacidad. Esto significa que no liberan la memoria asignada (ver tambi&amp;eacute;n &lt;code&gt;&lt;a href=&quot;shrink_to_fit&quot;&gt;shrink_to_fit&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="005bffdc5ce748f5fa7ecab037e6b4ba23fd3f4c" translate="yes" xml:space="preserve">
          <source>Unlike formatted output functions, this function does not set the &lt;code&gt;failbit&lt;/code&gt; if the output fails.</source>
          <target state="translated">A diferencia de las funciones de salida formateadas, esta funci&amp;oacute;n no establece el &lt;code&gt;failbit&lt;/code&gt; falla si la salida falla.</target>
        </trans-unit>
        <trans-unit id="c11ef1e4f5cbd932283bfef60dfc1f2ad7da6484" translate="yes" xml:space="preserve">
          <source>Unlike functions or references to functions, pointers to functions are objects and thus can be stored in arrays, copied, assigned, etc.</source>
          <target state="translated">A diferencia de las funciones o las referencias a las funciones,los punteros a las funciones son objetos y,por lo tanto,pueden almacenarse en matrices,copiarse,asignarse,etc.</target>
        </trans-unit>
        <trans-unit id="4fc1a9b3bf127389b70df7d40bbc2018c53338a0" translate="yes" xml:space="preserve">
          <source>Unlike header guards, this pragma makes it impossible to erroneously use the same macro name in more than one file. On the other hand, since with &lt;code&gt;#pragma once&lt;/code&gt; files are excluded based on their filesystem-level identity, this can't protect against including a header twice if it exists in more than one location in a project.</source>
          <target state="translated">A diferencia de los protectores de encabezado, este pragma hace que sea imposible usar err&amp;oacute;neamente el mismo nombre de macro en m&amp;aacute;s de un archivo. Por otro lado, ya que con &lt;code&gt;#pragma once&lt;/code&gt; archivos se excluyen en funci&amp;oacute;n de su identidad a nivel de sistema de archivos, esto no puede proteger contra la inclusi&amp;oacute;n de un encabezado dos veces si existe en m&amp;aacute;s de una ubicaci&amp;oacute;n en un proyecto.</target>
        </trans-unit>
        <trans-unit id="ee79da911cfc98f59e02246e9625087f966f6ee4" translate="yes" xml:space="preserve">
          <source>Unlike many related functions, this function is</source>
          <target state="translated">A diferencia de muchas funciones relacionadas,esta función es</target>
        </trans-unit>
        <trans-unit id="c7ea1f99bf46737fd3a9eb5569bcdb5f3547a949" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operator for &lt;code&gt;atomic_ref&lt;/code&gt; does not return a reference to its left-hand argument. It returns a copy of the stored value instead.</source>
          <target state="translated">A diferencia de la mayor&amp;iacute;a de los operadores de asignaci&amp;oacute;n, el operador de asignaci&amp;oacute;n para &lt;code&gt;atomic_ref&lt;/code&gt; no devuelve una referencia a su argumento de la izquierda. En su lugar, devuelve una copia del valor almacenado.</target>
        </trans-unit>
        <trans-unit id="1a4db73f4f2b5f3d23685150e26ab0e326ffc436" translate="yes" xml:space="preserve">
          <source>Unlike most assignment operators, the assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">A diferencia de la mayoría de los operadores de asignación,los operadores de asignación para los tipos atómicos no devuelven una referencia a sus argumentos de la izquierda.En su lugar,devuelven una copia del valor almacenado.</target>
        </trans-unit>
        <trans-unit id="3697fcced78a8dc2e1dd58511d1675942ea9902d" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">A diferencia de la mayor&amp;iacute;a de los operadores de asignaci&amp;oacute;n compuesta, los operadores de asignaci&amp;oacute;n compuesta para &lt;code&gt;atomic_ref&lt;/code&gt; no devuelven una referencia a sus argumentos de la izquierda. En su lugar, devuelven una copia del valor almacenado.</target>
        </trans-unit>
        <trans-unit id="139203564aef61dc9e502ac41ea33308504a0622" translate="yes" xml:space="preserve">
          <source>Unlike most compound assignment operators, the compound assignment operators for atomic types do not return a reference to their left-hand arguments. They return a copy of the stored value instead.</source>
          <target state="translated">A diferencia de la mayoría de los operadores de asignación compuesta,los operadores de asignación compuesta para los tipos atómicos no devuelven una referencia a sus argumentos de la izquierda.En su lugar,devuelven una copia del valor almacenado.</target>
        </trans-unit>
        <trans-unit id="dda22864e1900bb6a87e878513e661e3ee5d8ee4" translate="yes" xml:space="preserve">
          <source>Unlike most mathematical operations, the conversion of a floating-point value to text and back is</source>
          <target state="translated">A diferencia de la mayoría de las operaciones matemáticas,la conversión de un valor en punto flotante a texto y viceversa es</target>
        </trans-unit>
        <trans-unit id="76a29065db67fecaafea29ca64388623baf0bcbc" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;std::wcstok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">A diferencia de la mayor&amp;iacute;a de los otros tokenizadores, los delimitadores en &lt;code&gt;std::wcstok&lt;/code&gt; pueden ser diferentes para cada token posterior e incluso pueden depender del contenido de los tokens anteriores.</target>
        </trans-unit>
        <trans-unit id="c348ec3650d4d97ed9bc09e83c2572c81d376d68" translate="yes" xml:space="preserve">
          <source>Unlike most other tokenizers, the delimiters in &lt;code&gt;strtok&lt;/code&gt; can be different for each subsequent token, and can even depend on the contents of the previous tokens.</source>
          <target state="translated">A diferencia de la mayor&amp;iacute;a de los otros tokenizadores, los delimitadores en &lt;code&gt;strtok&lt;/code&gt; pueden ser diferentes para cada token posterior e incluso pueden depender del contenido de los tokens anteriores.</target>
        </trans-unit>
        <trans-unit id="e499b26c05a23f391924b25bade94974b21959a1" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for &lt;code&gt;atomic_ref&lt;/code&gt; do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">A diferencia de la mayor&amp;iacute;a de los operadores de pre-incremento y pre-decremento, los operadores de pre-incremento y pre-decremento para &lt;code&gt;atomic_ref&lt;/code&gt; no devuelven una referencia al objeto modificado. En su lugar, devuelven una copia del valor almacenado.</target>
        </trans-unit>
        <trans-unit id="247d65607595333e4901228f7023c088dbe9e552" translate="yes" xml:space="preserve">
          <source>Unlike most pre-increment and pre-decrement operators, the pre-increment and pre-decrement operators for atomic types do not return a reference to the modified object. They return a copy of the stored value instead.</source>
          <target state="translated">A diferencia de la mayoría de los operadores de preincremento y predecrecimiento,los operadores de preincremento y predecrecimiento para los tipos atómicos no devuelven una referencia al objeto modificado.En su lugar,devuelven una copia del valor almacenado.</target>
        </trans-unit>
        <trans-unit id="536f52cdb9582b6792ddf498c21f83ff3bc9d9a5" translate="yes" xml:space="preserve">
          <source>Unlike other formatting functions in C++ and C libraries, &lt;code&gt;std::to_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of formatting policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">A diferencia de otras funciones de formato en las bibliotecas C ++ y C, &lt;code&gt;std::to_chars&lt;/code&gt; es independiente de la configuraci&amp;oacute;n regional, no se asigna y no se lanza. Solo se proporciona un peque&amp;ntilde;o subconjunto de pol&amp;iacute;ticas de formato utilizadas por otras bibliotecas (como &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::sprintf&lt;/a&gt;&lt;/code&gt; ). Esto tiene como objetivo permitir la implementaci&amp;oacute;n m&amp;aacute;s r&amp;aacute;pida posible que sea &amp;uacute;til en contextos comunes de alto rendimiento, como el intercambio basado en texto (JSON o XML).</target>
        </trans-unit>
        <trans-unit id="960cf91e24a03ae762e9fec6a351793c82e6e03d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;begin()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">A diferencia de otras funciones que toman argumentos &lt;code&gt;std::valarray&lt;/code&gt; , &lt;code&gt;begin()&lt;/code&gt; no puede aceptar los tipos de reemplazo (como los tipos producidos por las plantillas de expresi&amp;oacute;n) que pueden devolverse de expresiones que involucran valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(v1 + v2)&lt;/code&gt; no es port&amp;aacute;til , &lt;code&gt;&lt;a href=&quot;../../iterator/begin&quot;&gt;std::begin&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; debe usarse en su lugar.</target>
        </trans-unit>
        <trans-unit id="07020cc0a6112afa1a94ca2a985fb8992ea81c5d" translate="yes" xml:space="preserve">
          <source>Unlike other functions that take &lt;code&gt;std::valarray&lt;/code&gt; arguments, &lt;code&gt;end()&lt;/code&gt; cannot accept the replacement types (such as the types produced by expression templates) that may be returned from expressions involving valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; is not portable, &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; has to be used instead.</source>
          <target state="translated">A diferencia de otras funciones que toman argumentos &lt;code&gt;std::valarray&lt;/code&gt; , &lt;code&gt;end()&lt;/code&gt; no puede aceptar los tipos de reemplazo (como los tipos producidos por las plantillas de expresi&amp;oacute;n) que pueden devolverse de expresiones que involucran valarrays: &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(v1 + v2)&lt;/code&gt; no es port&amp;aacute;til , &lt;code&gt;&lt;a href=&quot;../../iterator/end&quot;&gt;std::end&lt;/a&gt;(&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;T&amp;gt;(v1 + v2))&lt;/code&gt; debe usarse en su lugar.</target>
        </trans-unit>
        <trans-unit id="82b08c1bafac008cc3356484b3bea8b8da199f4c" translate="yes" xml:space="preserve">
          <source>Unlike other parsing functions in C++ and C libraries, &lt;code&gt;std::from_chars&lt;/code&gt; is locale-independent, non-allocating, and non-throwing. Only a small subset of parsing policies used by other libraries (such as &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt;) is provided. This is intended to allow the fastest possible implementation that is useful in common high-throughput contexts such as text-based interchange (JSON or XML).</source>
          <target state="translated">A diferencia de otras funciones de an&amp;aacute;lisis en las bibliotecas C ++ y C, &lt;code&gt;std::from_chars&lt;/code&gt; es independiente de la configuraci&amp;oacute;n regional, no se asigna y no se lanza. Solo se proporciona un peque&amp;ntilde;o subconjunto de pol&amp;iacute;ticas de an&amp;aacute;lisis utilizadas por otras bibliotecas (como &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::sscanf&lt;/a&gt;&lt;/code&gt; ). Esto tiene como objetivo permitir la implementaci&amp;oacute;n m&amp;aacute;s r&amp;aacute;pida posible que sea &amp;uacute;til en contextos comunes de alto rendimiento, como el intercambio basado en texto (JSON o XML).</target>
        </trans-unit>
        <trans-unit id="bc22867a4de3145dca568d4e66ffa742bf46b614" translate="yes" xml:space="preserve">
          <source>Unlike other temporary objects, the exception object is considered to be an lvalue argument when initializing the catch clause parameters, so it can be caught by lvalue reference, modified, and rethrown.</source>
          <target state="translated">A diferencia de otros objetos temporales,el objeto de excepción se considera un argumento de l-valor al inicializar los parámetros de la cláusula de captura,por lo que puede ser capturado por la referencia de l-valor,modificado y vuelto a lanzar.</target>
        </trans-unit>
        <trans-unit id="40e4049da792f251c064108725448595e7fb81c8" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; named requirement, &lt;code&gt;std::Destructible&lt;/code&gt; requires the destructor to be &lt;code&gt;noexcept(true)&lt;/code&gt;, not merely non-throwing when invoked, and allows reference types and array types.</source>
          <target state="translated">A diferencia del requisito con nombre &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; , &lt;code&gt;std::Destructible&lt;/code&gt; requiere que el destructor sea &lt;code&gt;noexcept(true)&lt;/code&gt; , no simplemente no arrojado cuando se invoca, y permite tipos de referencia y tipos de matriz.</target>
        </trans-unit>
        <trans-unit id="f2ff26def44fad2ae044095e7f187e2f9c03b39d" translate="yes" xml:space="preserve">
          <source>Unlike the &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; constructors, &lt;code&gt;std::make_shared&lt;/code&gt; does not allow a custom deleter.</source>
          <target state="translated">A diferencia de los constructores &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::make_shared&lt;/code&gt; no permite un borrador personalizado.</target>
        </trans-unit>
        <trans-unit id="1c6f8d4294a5e322f2430ee23bff35686e775144" translate="yes" xml:space="preserve">
          <source>Unlike the primary template &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, this specialization does not perform a virtual function call when classifying characters. To customize the behavior, a derived class may provide a non-default classification table to the base class constructor.</source>
          <target state="translated">A diferencia de la plantilla principal &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; , esta especializaci&amp;oacute;n no realiza una llamada de funci&amp;oacute;n virtual cuando clasifica caracteres. Para personalizar el comportamiento, una clase derivada puede proporcionar una tabla de clasificaci&amp;oacute;n no predeterminada al constructor de la clase base.</target>
        </trans-unit>
        <trans-unit id="3a3c250893800a21b88186ef185aadaf831d7992" translate="yes" xml:space="preserve">
          <source>Unlike the promotions, numeric conversions may change the values, with potential loss of precision.</source>
          <target state="translated">A diferencia de las promociones,las conversiones numéricas pueden cambiar los valores,con una potencial pérdida de precisión.</target>
        </trans-unit>
        <trans-unit id="5cf90c59183d16b061b44fcdd59d790f2d00de63" translate="yes" xml:space="preserve">
          <source>Unlike the rest of the algorithms, for_each is not allowed to make copies of the elements in the sequence even if they are trivially copyable.</source>
          <target state="translated">A diferencia del resto de los algoritmos,for_each no está autorizado a hacer copias de los elementos de la secuencia aunque sean trivialmente copiables.</target>
        </trans-unit>
        <trans-unit id="db1ac6c9a5b777adb044dcf5cc2c8e1d9362ebb5" translate="yes" xml:space="preserve">
          <source>Unlike the std::shared_ptr constructors, std::allocate_shared does not accept a separate custom deleter: the supplied allocator is used for destruction of the control block and the &lt;code&gt;T&lt;/code&gt; object, and for deallocation of their shared memory block.</source>
          <target state="translated">A diferencia de los constructores std :: shared_ptr, std :: allocate_shared no acepta un eliminador personalizado separado: el asignador suministrado se utiliza para destruir el bloque de control y el objeto &lt;code&gt;T&lt;/code&gt; , y para desasignar su bloque de memoria compartida.</target>
        </trans-unit>
        <trans-unit id="66abfa107dcdc9f5699b86a1259047a6420b2c52" translate="yes" xml:space="preserve">
          <source>Unlike type template parameter declaration, template template parameter declaration can only use the keyword &lt;code&gt;class&lt;/code&gt; and not &lt;code&gt;typename&lt;/code&gt;.</source>
          <target state="translated">A diferencia de la declaraci&amp;oacute;n de par&amp;aacute;metro de plantilla de tipo, la declaraci&amp;oacute;n de par&amp;aacute;metro de plantilla de plantilla solo puede usar la &lt;code&gt;class&lt;/code&gt; palabra clave y no &lt;code&gt;typename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d675911d340ea7fe2bddf254d2a266f734dde906" translate="yes" xml:space="preserve">
          <source>Unlike with &lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt;, additional directory separators are never introduced.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;append&quot;&gt;append()&lt;/a&gt;&lt;/code&gt; u &lt;code&gt;&lt;a href=&quot;append&quot;&gt;operator/=&lt;/a&gt;&lt;/code&gt; , nunca se introducen separadores de directorio adicionales.</target>
        </trans-unit>
        <trans-unit id="9795510ddaf8f7b584f9cfa5390b07d1db4d7240" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex and releases ownership.</source>
          <target state="translated">Desbloquea el mutex asociado y libera la propiedad.</target>
        </trans-unit>
        <trans-unit id="f433ee5a4f5ef551015f8cbf8189774e6d42e0da" translate="yes" xml:space="preserve">
          <source>Unlocks the associated mutex from shared mode. Effectively calls &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt;.</source>
          <target state="translated">Desbloquea el mutex asociado del modo compartido. Efectivamente llama a &lt;code&gt;mutex()-&amp;gt;unlock_shared()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961e1771431741648b7410afa7f25aec8f8bb6ba" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex if its level of ownership is &lt;code&gt;1&lt;/code&gt; (there was exactly one more call to &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; than there were calls to &lt;code&gt;unlock()&lt;/code&gt; made by this thread), reduces the level of ownership by 1 otherwise.</source>
          <target state="translated">Desbloquea el mutex si su nivel de propiedad es &lt;code&gt;1&lt;/code&gt; (hubo exactamente una llamada m&amp;aacute;s para &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; que hubo llamadas para &lt;code&gt;unlock()&lt;/code&gt; hechas por este hilo), de lo contrario reduce el nivel de propiedad en 1.</target>
        </trans-unit>
        <trans-unit id="3292cba2e9fa684816c3433f5e680ff1211985aa" translate="yes" xml:space="preserve">
          <source>Unlocks the mutex.</source>
          <target state="translated">Desbloquea el mutex.</target>
        </trans-unit>
        <trans-unit id="e5ecb1ac5a3284b964b98f95170550776c6f7221" translate="yes" xml:space="preserve">
          <source>Unnamed functions can be generated by &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;.</source>
          <target state="translated">Las funciones sin nombre pueden ser generadas por &lt;a href=&quot;lambda&quot;&gt;expresiones lambda&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4abed0ca00f10480f822ed4f5c54c15d912133a" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces</source>
          <target state="translated">Espacios de nombres sin nombre</target>
        </trans-unit>
        <trans-unit id="ce07e4c5885039551bddbc7d0f27189dfc040aaa" translate="yes" xml:space="preserve">
          <source>Unnamed namespaces as well as all namespaces declared directly or indirectly within an unnamed namespace have &lt;a href=&quot;storage_duration#Linkage&quot;&gt;internal linkage&lt;/a&gt;, which means that any name that is declared within an unnamed namespace has internal linkage.</source>
          <target state="translated">Los espacios de nombres sin nombre, as&amp;iacute; como todos los espacios de nombres declarados directa o indirectamente dentro de un espacio de nombres sin nombre tienen &lt;a href=&quot;storage_duration#Linkage&quot;&gt;un enlace interno&lt;/a&gt; , lo que significa que cualquier nombre que se declare dentro de un espacio de nombres sin nombre tiene un enlace interno.</target>
        </trans-unit>
        <trans-unit id="55c746743e689c2f62e5b9408423fdd2d1439715" translate="yes" xml:space="preserve">
          <source>Unordered associative containers</source>
          <target state="translated">Contenedores asociativos no ordenados</target>
        </trans-unit>
        <trans-unit id="67512286f8974c10c046fc1f0f6675019780544f" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are &lt;a href=&quot;container&quot;&gt;Containers&lt;/a&gt; that provide fast lookup of objects based on keys. Worst case complexity is linear but on average much faster for most of the operations.</source>
          <target state="translated">Los contenedores asociativos no ordenados son &lt;a href=&quot;container&quot;&gt;Contenedores&lt;/a&gt; que proporcionan una b&amp;uacute;squeda r&amp;aacute;pida de objetos basados ​​en claves. La complejidad del peor de los casos es lineal pero, en promedio, mucho m&amp;aacute;s r&amp;aacute;pida para la mayor&amp;iacute;a de las operaciones.</target>
        </trans-unit>
        <trans-unit id="5721c8ff7733bb174444b2a6b021b024c56a1897" translate="yes" xml:space="preserve">
          <source>Unordered associative containers are parametrized by &lt;code&gt;Key&lt;/code&gt;; &lt;code&gt;Hash&lt;/code&gt;, a &lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt; function object which acts as hash function on &lt;code&gt;Key&lt;/code&gt;; and &lt;code&gt;Pred&lt;/code&gt;, a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; evaluating equivalence between &lt;code&gt;Key&lt;/code&gt;s. &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; also have a mapped type &lt;code&gt;T&lt;/code&gt; associated with the &lt;code&gt;Key&lt;/code&gt;.</source>
          <target state="translated">Los contenedores asociativos no ordenados se parametrizan por &lt;code&gt;Key&lt;/code&gt; ; &lt;code&gt;Hash&lt;/code&gt; , un objeto de funci&amp;oacute;n &lt;a href=&quot;hash&quot;&gt;Hash&lt;/a&gt; que act&amp;uacute;a como funci&amp;oacute;n hash en &lt;code&gt;Key&lt;/code&gt; ; y &lt;code&gt;Pred&lt;/code&gt; , una equivalencia de evaluaci&amp;oacute;n &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; entre &lt;code&gt;Key&lt;/code&gt; s. &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; tambi&amp;eacute;n tienen un tipo &lt;code&gt;T&lt;/code&gt; mapeado asociado con la &lt;code&gt;Key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d0b13503ae28a6d2a746765f82094c67a9edd8" translate="yes" xml:space="preserve">
          <source>Unordered associative containers implement unsorted (hashed) data structures that can be quickly searched (O(1) amortized, O(n) worst-case complexity).</source>
          <target state="translated">Los contenedores asociativos no ordenados implementan estructuras de datos sin clasificar (hashed)que pueden ser buscados rápidamente (O(1)amortizado,O(n)complejidad del peor de los casos).</target>
        </trans-unit>
        <trans-unit id="b3e4ddc4a7977312b5ea810e7307eb4d25f9ced4" translate="yes" xml:space="preserve">
          <source>Unordered associative containers in the standard library</source>
          <target state="translated">Contenedores asociativos no ordenados en la biblioteca estándar</target>
        </trans-unit>
        <trans-unit id="9cbf323cb4f143925595576784d5b591b9699888" translate="yes" xml:space="preserve">
          <source>Unordered associative containers meet the requirements of &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt;. For &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; the requirements of &lt;code&gt;value_type&lt;/code&gt; in &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; apply to &lt;code&gt;key_type&lt;/code&gt; and &lt;code&gt;mapped_type&lt;/code&gt; (not to &lt;code&gt;value_type&lt;/code&gt;).</source>
          <target state="translated">Los contenedores asociativos no ordenados cumplen los requisitos de &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer&lt;/a&gt; . Para &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; &lt;code&gt;value_type&lt;/code&gt; los requisitos de value_type en &lt;a href=&quot;allocatorawarecontainer&quot;&gt;AllocatorAwareContainer se&lt;/a&gt; aplican a &lt;code&gt;key_type&lt;/code&gt; y &lt;code&gt;mapped_type&lt;/code&gt; (no a &lt;code&gt;value_type&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c05e882164dc6c352b2a91db5033a7f29679961d" translate="yes" xml:space="preserve">
          <source>Unordered dynamic initialization</source>
          <target state="translated">Inicialización dinámica desordenada</target>
        </trans-unit>
        <trans-unit id="6f584009e4c537a97fa6a23c2a4e0d998b8f9266" translate="yes" xml:space="preserve">
          <source>Unordered map is an associative container that contains key-value pairs with unique keys. Search, insertion, and removal of elements have average constant-time complexity.</source>
          <target state="translated">El mapa desordenado es un contenedor asociativo que contiene pares llave-valor con claves únicas.La búsqueda,inserción y eliminación de elementos tiene una complejidad promedio constante.</target>
        </trans-unit>
        <trans-unit id="a040e6bfa2ff6a84c4d4e54ec666b82a142217ba" translate="yes" xml:space="preserve">
          <source>Unordered multimap is an unordered associative container that supports equivalent keys (an unordered_multimap may contain multiple copies of each key value) and that associates values of another type with the keys. The unordered_multimap class supports forward iterators. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">El multimap no ordenado es un contenedor asociativo no ordenado que admite claves equivalentes (un multimap no ordenado puede contener múltiples copias de cada valor de la clave)y que asocia valores de otro tipo con las claves.La clase unordered_multimap soporta iteradores de reenvío.La búsqueda,la inserción y la eliminación tienen una complejidad media constante.</target>
        </trans-unit>
        <trans-unit id="781e73a9d10b79ea8423bbe4c282e042b203ed02" translate="yes" xml:space="preserve">
          <source>Unordered multiset is an associative container that contains set of possibly non-unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">El multiset no ordenado es un contenedor asociativo que contiene un conjunto de objetos posiblemente no únicos del tipo Key.La búsqueda,la inserción y la extracción tienen una complejidad promedio constante.</target>
        </trans-unit>
        <trans-unit id="6c35c1e1852ab51c8cfda8139fbce10f60da69d7" translate="yes" xml:space="preserve">
          <source>Unordered set is an associative container that contains a set of unique objects of type Key. Search, insertion, and removal have average constant-time complexity.</source>
          <target state="translated">El conjunto desordenado es un contenedor asociativo que contiene un conjunto de objetos únicos de tipo Clave.La búsqueda,la inserción y la extracción tienen una complejidad promedio constante.</target>
        </trans-unit>
        <trans-unit id="20ec84b0a684780da8ecd14376ab54e3d64c049a" translate="yes" xml:space="preserve">
          <source>UnorderedAssociativeContainer</source>
          <target state="translated">UnorderedAssociativeContainer</target>
        </trans-unit>
        <trans-unit id="5ed38d76cf76e990be50933f309543cd72253e57" translate="yes" xml:space="preserve">
          <source>Unqualified and qualified name lookup rules for class members are detailed in &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;.</source>
          <target state="translated">Las reglas de b&amp;uacute;squeda de nombre no calificadas y calificadas para los miembros de la clase se detallan en la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda de nombre&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a712c79b38b9542c96589abf3e1dda8d1042e2a4" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;abs&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;std::abs&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;abs&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;std::abs&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="fc119a198d533d4b0bbb7710d68460cff957292e" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;acos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;acos&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/acos&quot;&gt;std::acos&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="f215557e10fbc19791a7df65c388833c1a7dd11c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;asin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;asin&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/asin&quot;&gt;std::asin&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="9f3c5a7de17deb7da848c19ab6e3fce9f64dca13" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan2&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;atan2&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/atan2&quot;&gt;std::atan2&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="fa3a701b0983c693521c1ddd5947f77acceaace8" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;atan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;atan&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/atan&quot;&gt;std::atan&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="39d51e27856339476f1d01bf7073fed7dc2b3dbb" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cos&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;cos&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/cos&quot;&gt;std::cos&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="dbf3b6db25b09f0814d7e5a7fef391df5875da2a" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;cosh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;cosh&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/cosh&quot;&gt;std::cosh&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="e8abb5dd0c771afacf6766178d00da2ba065a2ec" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;exp&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;exp&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/exp&quot;&gt;std::exp&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente de argumentos.</target>
        </trans-unit>
        <trans-unit id="dd8575417503ea5be7c9d78fb49d54a74a502a5c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log10&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;log10&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/log10&quot;&gt;std::log10&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="42fd42135c1c4e85d3b6e8229754e9d9e009486f" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;log&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;log&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/log&quot;&gt;std::log&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente de argumentos.</target>
        </trans-unit>
        <trans-unit id="a8f42595543cd910c448cec8e9b024326f375da5" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;pow&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;pow&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/pow&quot;&gt;std::pow&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="0b45579c9b454c00347186dba4b670a1612acd28" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sin&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;sin&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="609a5411e92bb2e442b9695a0c7f1a35b0bcda38" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sinh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;sinh&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/sinh&quot;&gt;std::sinh&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="c0b2457b178abb1fbcd11ec0b12722a8184da253" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;sqrt&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;sqrt&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/sqrt&quot;&gt;std::sqrt&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente de argumentos.</target>
        </trans-unit>
        <trans-unit id="fa91ca5ff514fc595bf3f51f24fdd9e313d69b9c" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tan&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;tan&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/tan&quot;&gt;std::tan&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="d2d13c70f9b62f9ac241cafdef0b167740b73e83" translate="yes" xml:space="preserve">
          <source>Unqualified function (&lt;code&gt;tanh&lt;/code&gt;) is used to perform the computation. If such function is not available, &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; is used due to argument dependent lookup.</source>
          <target state="translated">La funci&amp;oacute;n no calificada ( &lt;code&gt;tanh&lt;/code&gt; ) se utiliza para realizar el c&amp;aacute;lculo. Si dicha funci&amp;oacute;n no est&amp;aacute; disponible, se usa &lt;code&gt;&lt;a href=&quot;../math/tanh&quot;&gt;std::tanh&lt;/a&gt;&lt;/code&gt; debido a la b&amp;uacute;squeda dependiente del argumento.</target>
        </trans-unit>
        <trans-unit id="5e538cf96d743b1733d4cf064e3d13d77d3aa646" translate="yes" xml:space="preserve">
          <source>Unqualified identifiers</source>
          <target state="translated">Identificadores no cualificados</target>
        </trans-unit>
        <trans-unit id="30683cf405f082292810a7676e96130ea1ebbac6" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup</source>
          <target state="translated">Búsqueda de nombres no cualificados</target>
        </trans-unit>
        <trans-unit id="42e9848a70274fa4e3ee76d98636ebc5974dc7bd" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup of the name used to the left of the function-call operator (and, equivalently, operator in an expression) is described in &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">La b&amp;uacute;squeda de nombre no calificado del nombre utilizado a la izquierda del operador de llamada a funci&amp;oacute;n (y, de manera equivalente, operador en una expresi&amp;oacute;n) se describe en la &lt;a href=&quot;adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="79648146553ba52f72840dfe58fd2d9c089e5fda" translate="yes" xml:space="preserve">
          <source>Unqualified name lookup that finds static members of &lt;code&gt;B&lt;/code&gt;, nested types of &lt;code&gt;B&lt;/code&gt;, and enumerators declared in &lt;code&gt;B&lt;/code&gt; is unambiguous even if there are multiple non-virtual base subobjects of type &lt;code&gt;B&lt;/code&gt; in the inheritance tree of the class being examined:</source>
          <target state="translated">La b&amp;uacute;squeda de nombre no calificado que encuentra miembros est&amp;aacute;ticos de &lt;code&gt;B&lt;/code&gt; , tipos anidados de &lt;code&gt;B&lt;/code&gt; y enumeradores declarados en &lt;code&gt;B&lt;/code&gt; es inequ&amp;iacute;voco, incluso si hay m&amp;uacute;ltiples subobjetos base no virtuales de tipo &lt;code&gt;B&lt;/code&gt; en el &amp;aacute;rbol de herencia de la clase que se est&amp;aacute; examinando:</target>
        </trans-unit>
        <trans-unit id="f0214ce4cc35b4369eeab0b471b29274746a99bb" translate="yes" xml:space="preserve">
          <source>Unregisters a range earlier registered with &lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;&lt;a href=&quot;declare_no_pointers&quot;&gt;std::declare_no_pointers&lt;/a&gt;()&lt;/code&gt; registro de un rango registrado anteriormente con std :: declare_no_pointers () .</target>
        </trans-unit>
        <trans-unit id="866d0de5757a1581405e841976c7443463cb9f92" translate="yes" xml:space="preserve">
          <source>Unrelated to contracting, intermediate results of floating-point arithmetic may have range and precision that is different from the one indicated by its type, see &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Sin relaci&amp;oacute;n con la contrataci&amp;oacute;n, los resultados intermedios de la aritm&amp;eacute;tica de coma flotante pueden tener un rango y una precisi&amp;oacute;n diferentes de los indicados por su tipo, ver &lt;code&gt;&lt;a href=&quot;../types/climits/flt_eval_method&quot;&gt;FLT_EVAL_METHOD&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c38c9bea005b30ba6a290df566acf1664518f308" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration</source>
          <target state="translated">Enumeración no revisada</target>
        </trans-unit>
        <trans-unit id="6222e920759d4ffc44da225d807dad755988a0aa" translate="yes" xml:space="preserve">
          <source>Unscoped enumeration type</source>
          <target state="translated">Tipo de enumeración no abarcado</target>
        </trans-unit>
        <trans-unit id="326065904fc6d55f14165c03f41503850d0a81df" translate="yes" xml:space="preserve">
          <source>Unsequenced execution policies are the only case where function calls are</source>
          <target state="translated">Las políticas de ejecución no secuenciada son el único caso en el que las llamadas a funciones son</target>
        </trans-unit>
        <trans-unit id="001f5aa9e95578bdbf624cdd233afcd23b9e1b0b" translate="yes" xml:space="preserve">
          <source>Unsets the formatting flags identified by &lt;code&gt;flags&lt;/code&gt;.</source>
          <target state="translated">Desactiva los indicadores de formato identificados por los &lt;code&gt;flags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e58bf16bb4075ebd2ecdad4cd86deb15d7942bb7" translate="yes" xml:space="preserve">
          <source>Unsigned integer arithmetic is always performed modulo 2n</source>
          <target state="translated">La aritmética de números enteros sin signo siempre se realiza en el módulo 2n</target>
        </trans-unit>
        <trans-unit id="73db4e2949bacc582e416479a510daae92386ab7" translate="yes" xml:space="preserve">
          <source>Unsigned integer of at least 32 bits</source>
          <target state="translated">Un entero sin signo de al menos 32 bits</target>
        </trans-unit>
        <trans-unit id="4e7bbf9fbab3d07bb38581701f9d99705350278e" translate="yes" xml:space="preserve">
          <source>Unsigned integer type (usually &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Tipo entero sin signo (generalmente &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1569ce9087643318f5b374c7177d610cac24614f" translate="yes" xml:space="preserve">
          <source>Unsigned integers : maximum value</source>
          <target state="translated">Enteros sin signo:valor máximo</target>
        </trans-unit>
        <trans-unit id="6fe5f2a61d9b8437ce58885d4aebe34e13639a40" translate="yes" xml:space="preserve">
          <source>UnsignedIntegral</source>
          <target state="translated">UnsignedIntegral</target>
        </trans-unit>
        <trans-unit id="5097984a5f9238c911d1b186817d23c6f3bcfe68" translate="yes" xml:space="preserve">
          <source>Unspecified order</source>
          <target state="translated">Orden no especificado</target>
        </trans-unit>
        <trans-unit id="d37821663cc5797b1388ccb9821c1c66f6dc7be6" translate="yes" xml:space="preserve">
          <source>Unspecified.</source>
          <target state="translated">Unspecified.</target>
        </trans-unit>
        <trans-unit id="42bff37b51ec7b1fccab4a5d361519fa088bb006" translate="yes" xml:space="preserve">
          <source>Unsupported C headers</source>
          <target state="translated">Cabezales C no apoyados</target>
        </trans-unit>
        <trans-unit id="3910cc8152231b6ede905978fe57cac1a0d03d97" translate="yes" xml:space="preserve">
          <source>Until &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt; (a C++14 defect), unused parameters in &lt;a href=&quot;../language/type_alias&quot;&gt;alias templates&lt;/a&gt; were not guaranteed to ensure SFINAE and could be ignored, so earlier compilers require a more complex definition of &lt;code&gt;void_t&lt;/code&gt;, such as.</source>
          <target state="translated">Hasta &lt;a href=&quot;http://open-std.org/JTC1/SC22/WG21/docs/cwg_defects.html#1558&quot;&gt;CWG 1558&lt;/a&gt; (un defecto de C ++ 14), los par&amp;aacute;metros no utilizados en las &lt;a href=&quot;../language/type_alias&quot;&gt;plantillas de alias&lt;/a&gt; no garantizaban SFINAE y pod&amp;iacute;an ignorarse, por lo que los compiladores anteriores requieren una definici&amp;oacute;n m&amp;aacute;s compleja de &lt;code&gt;void_t&lt;/code&gt; , como.</target>
        </trans-unit>
        <trans-unit id="f7718ae633302ee609828ca76d3c8d3d51cfea89" translate="yes" xml:space="preserve">
          <source>Until C++11, &lt;code&gt;auto&lt;/code&gt; had the semantic of a &lt;a href=&quot;storage_duration&quot;&gt;storage duration specifier&lt;/a&gt;.</source>
          <target state="translated">Hasta C ++ 11, &lt;code&gt;auto&lt;/code&gt; ten&amp;iacute;a la sem&amp;aacute;ntica de un &lt;a href=&quot;storage_duration&quot;&gt;especificador de duraci&amp;oacute;n de almacenamiento&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="965548c423c2af9ebf773d28ec036a9f63c4b83f" translate="yes" xml:space="preserve">
          <source>Until C++11, aggregate initialization could not be used in a constructor initializer list due to syntax restrictions.</source>
          <target state="translated">Hasta C++11,la inicialización agregada no podía utilizarse en una lista de inicialización de constructores debido a las restricciones sintácticas.</target>
        </trans-unit>
        <trans-unit id="9f555151d6b7d5f7a9ff7843af6a57a54b0a5819" translate="yes" xml:space="preserve">
          <source>Until C++11, classes that overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; were not CopyConstructible and thus weren't usable in the standard library containers. As of C++11, the standard library uses &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; whenever the address of an object is needed.</source>
          <target state="translated">Hasta C ++ 11, las clases que sobrecargaban al &lt;code&gt;operator&amp;amp;&lt;/code&gt; no eran CopyConstructible y, por lo tanto, no se pod&amp;iacute;an usar en los contenedores de la biblioteca est&amp;aacute;ndar. A partir de C ++ 11, la biblioteca est&amp;aacute;ndar usa &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; cuando se necesita la direcci&amp;oacute;n de un objeto.</target>
        </trans-unit>
        <trans-unit id="9f5f5ea9e92fa642a1d809852878c2987d57848b" translate="yes" xml:space="preserve">
          <source>Until C++11, it was unspecified whether &lt;code&gt;basic_streambuf&lt;/code&gt; or any of its derived classes is &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; (&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;LWG issue 421&lt;/a&gt;), and different C++ library implementations provided different options.</source>
          <target state="translated">Hasta C ++ 11, no se especificaba si &lt;code&gt;basic_streambuf&lt;/code&gt; o cualquiera de sus clases derivadas es &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; ( &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-closed.html#421&quot;&gt;LWG n&amp;uacute;mero 421&lt;/a&gt; ), y las diferentes implementaciones de la biblioteca C ++ proporcionaron diferentes opciones.</target>
        </trans-unit>
        <trans-unit id="328855c59d216dad3422e6e98a3125cd6d816dcf" translate="yes" xml:space="preserve">
          <source>Until C++11, narrowing conversions were permitted in aggregate initialization, but they are no longer allowed, except that, as of C++20, they are allowed when aggregate initialization uses round parentheses.</source>
          <target state="translated">Hasta C++11,se permitían conversiones estrechas en la inicialización agregada,pero ya no se permiten,salvo que,a partir de C++20,se permiten cuando la inicialización agregada utiliza paréntesis redondos.</target>
        </trans-unit>
        <trans-unit id="6e17e7cb9fc8a5970b94833c26c3d5625cb274e1" translate="yes" xml:space="preserve">
          <source>Until C++11, the rounding direction of the quotient and the sign of the remainder in the &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;built-in division and remainder operators&lt;/a&gt; was implementation-defined if either of the operands was negative, but it was well-defined in &lt;code&gt;std::div&lt;/code&gt;.</source>
          <target state="translated">Hasta C ++ 11, la direcci&amp;oacute;n de redondeo del cociente y el signo del resto en la &lt;a href=&quot;../../language/operator_arithmetic&quot;&gt;divisi&amp;oacute;n incorporada y los operadores restantes&lt;/a&gt; se definieron en la implementaci&amp;oacute;n si alguno de los operandos era negativo, pero estaba bien definido en &lt;code&gt;std::div&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2dd75578b3cf163fd9cdf707fa3febbd8933afe1" translate="yes" xml:space="preserve">
          <source>Until C++11, which introduced &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt;, about the only thing a strictly conforming program could do in a signal handler was to assign a value to a &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; variable and promptly return.</source>
          <target state="translated">Hasta C ++ 11, que introdujo &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../atomic/atomic_signal_fence&quot;&gt;std::atomic_signal_fence&lt;/a&gt;&lt;/code&gt; , lo &amp;uacute;nico que pod&amp;iacute;a hacer un programa estrictamente conforme en un controlador de se&amp;ntilde;al era asignar un valor a una variable &lt;code&gt;volatile static std::sig_atomic_t&lt;/code&gt; y regresar r&amp;aacute;pidamente.</target>
        </trans-unit>
        <trans-unit id="4d3ae3907e74b1b45f48b10e1e68c5b46d8f4619" translate="yes" xml:space="preserve">
          <source>Until C++14, the direct-initialization form &lt;code&gt;T a {args..}&lt;/code&gt; did not permit brace elision.</source>
          <target state="translated">Hasta C ++ 14, la forma de inicializaci&amp;oacute;n directa &lt;code&gt;T a {args..}&lt;/code&gt; no permit&amp;iacute;a la elisi&amp;oacute;n del aparato ortop&amp;eacute;dico.</target>
        </trans-unit>
        <trans-unit id="7f752f60fcef0ea971b808f8f6eaf483ad584079" translate="yes" xml:space="preserve">
          <source>Until C++17, a function could not return a tuple using list-initialization:</source>
          <target state="translated">Hasta C++17,una función no podía devolver una tupla usando la inicialización de la lista:</target>
        </trans-unit>
        <trans-unit id="58fb383e77b7fb0335ad97e0f3c210c1e1d6f098" translate="yes" xml:space="preserve">
          <source>Until the introduction of explicit conversion functions in C++11, designing a class that should be usable in boolean contexts (e.g. &lt;code&gt;if(obj) { ... }&lt;/code&gt;) presented a problem: given a user-defined conversion function, such as &lt;code&gt;T::operator bool() const;&lt;/code&gt;, the implicit conversion sequence allowed one additional standard conversion sequence after that function call, which means the resultant &lt;code&gt;bool&lt;/code&gt; could be converted to &lt;code&gt;int&lt;/code&gt;, allowing such code as &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; or &lt;code&gt;int i = obj;&lt;/code&gt;.</source>
          <target state="translated">Hasta la introducci&amp;oacute;n de funciones de conversi&amp;oacute;n expl&amp;iacute;citas en C ++ 11, el dise&amp;ntilde;o de una clase que deber&amp;iacute;a ser utilizable en contextos booleanos (por ejemplo, &lt;code&gt;if(obj) { ... }&lt;/code&gt; ) presentaba un problema: dada una funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario, como &lt;code&gt;T::operator bool() const;&lt;/code&gt; , la secuencia de conversi&amp;oacute;n impl&amp;iacute;cita permiti&amp;oacute; una secuencia de conversi&amp;oacute;n est&amp;aacute;ndar adicional despu&amp;eacute;s de esa llamada a la funci&amp;oacute;n, lo que significa que el &lt;code&gt;bool&lt;/code&gt; resultante podr&amp;iacute;a convertirse a &lt;code&gt;int&lt;/code&gt; , permitiendo un c&amp;oacute;digo como &lt;code&gt;obj &amp;lt;&amp;lt; 1;&lt;/code&gt; o &lt;code&gt;int i = obj;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b46999a4d771dcf596a583d2c8bf0dbc1bb017bc" translate="yes" xml:space="preserve">
          <source>Until variable templates were introduced in C++14, parametrized variables were typically implemented as either static data members of class templates or as constexpr function templates returning the desired values.</source>
          <target state="translated">Hasta que se introdujeron plantillas de variables en C++14,las variables parametrizadas se implementaron típicamente como miembros de datos estáticos de plantillas de clase o como plantillas de funciones constexpr que devolvían los valores deseados.</target>
        </trans-unit>
        <trans-unit id="c65bb8e4818155db56e2464c0be89b93b4aa7fb0" translate="yes" xml:space="preserve">
          <source>Upon return to the scope of &lt;code&gt;setjmp&lt;/code&gt;, all accessible objects, floating-point status flags, and other components of the abstract machine have the same values as they had when &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; was executed, except for the non-&lt;a href=&quot;../../language/cv&quot;&gt;volatile&lt;/a&gt; local variables in &lt;code&gt;setjmp&lt;/code&gt;'s scope, whose values are indeterminate if they have been changed since the setjmp invocation.</source>
          <target state="translated">Al regresar al alcance de &lt;code&gt;setjmp&lt;/code&gt; , todos los objetos accesibles, los indicadores de estado de coma flotante y otros componentes de la m&amp;aacute;quina abstracta tienen los mismos valores que ten&amp;iacute;an cuando se ejecut&amp;oacute; &lt;code&gt;&lt;a href=&quot;longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; , excepto las variables locales no &lt;a href=&quot;../../language/cv&quot;&gt;vol&amp;aacute;tiles&lt;/a&gt; en &lt;code&gt;setjmp&lt;/code&gt; El &amp;aacute;mbito de aplicaci&amp;oacute;n, cuyos valores son indeterminados si se han modificado desde la invocaci&amp;oacute;n de setjmp.</target>
        </trans-unit>
        <trans-unit id="30e91e701960bb8a2f2ddc9e70cec3e0f356f152" translate="yes" xml:space="preserve">
          <source>Uppercase version of &lt;code&gt;ch&lt;/code&gt; or unmodified &lt;code&gt;ch&lt;/code&gt; if no uppercase version is listed in the current C locale.</source>
          <target state="translated">Versi&amp;oacute;n en may&amp;uacute;scula de &lt;code&gt;ch&lt;/code&gt; o &lt;code&gt;ch&lt;/code&gt; no modificada si no aparece una versi&amp;oacute;n en may&amp;uacute;scula en la configuraci&amp;oacute;n regional actual de C.</target>
        </trans-unit>
        <trans-unit id="0bb18642b70b9f8a9c12ccf39487328f306b8e19" translate="yes" xml:space="preserve">
          <source>Usage</source>
          <target state="translated">Usage</target>
        </trans-unit>
        <trans-unit id="e2fa3e294a40d353ff7bd0279d846fe85eb6a460" translate="yes" xml:space="preserve">
          <source>Use &lt;code&gt;mem_fn&lt;/code&gt; to store and execute a member function and a member object:</source>
          <target state="translated">Use &lt;code&gt;mem_fn&lt;/code&gt; para almacenar y ejecutar una funci&amp;oacute;n miembro y un objeto miembro:</target>
        </trans-unit>
        <trans-unit id="ccd4cdfea5815983783eb398f954b34dd3308ca2" translate="yes" xml:space="preserve">
          <source>Use ECMAScript rules to construct strings in &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; (&lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;syntax documentation&lt;/a&gt;)</source>
          <target state="translated">Utilice las reglas de ECMAScript para construir cadenas en &lt;code&gt;&lt;a href=&quot;regex_replace&quot;&gt;std::regex_replace&lt;/a&gt;&lt;/code&gt; ( &lt;a href=&quot;http://ecma-international.org/ecma-262/5.1/#sec-15.5.4.11&quot;&gt;documentaci&amp;oacute;n de sintaxis&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="7d2ca269005572f7dcc4f93975b5006fe75b32fe" translate="yes" xml:space="preserve">
          <source>Use POSIX</source>
          <target state="translated">Use el POSIX...</target>
        </trans-unit>
        <trans-unit id="59088c12cff257aabcfd96c2bff5eb6d63196ace" translate="yes" xml:space="preserve">
          <source>Use of an indeterminate value obtained by default-initializing a non-class variable of any type is &lt;a href=&quot;ub&quot;&gt;undefined behavior&lt;/a&gt; (in particular, it may be a &lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;trap representation&lt;/a&gt;), except in the following cases:</source>
          <target state="translated">El uso de un valor indeterminado obtenido al inicializar por defecto una variable que no sea de clase de cualquier tipo es &lt;a href=&quot;ub&quot;&gt;un comportamiento indefinido&lt;/a&gt; (en particular, puede ser una &lt;a href=&quot;objects#Object_representation_and_value_representation&quot;&gt;representaci&amp;oacute;n trampa&lt;/a&gt; ), excepto en los siguientes casos:</target>
        </trans-unit>
        <trans-unit id="1343357d8857f07ed216045e4630d2360702830a" translate="yes" xml:space="preserve">
          <source>Use of pImpl requires a dedicated translation unit (a header-only library cannot use pImpl), introduces an additional class, a set of forwarding functions, and, if allocators are used, exposes the implementation detail of allocator use in the public interface.</source>
          <target state="translated">El uso de pImpl requiere una unidad de traducción dedicada (una biblioteca de cabecera no puede usar pImpl),introduce una clase adicional,un conjunto de funciones de reenvío y,si se usan asignadores,expone los detalles de implementación del uso de los asignadores en la interfaz pública.</target>
        </trans-unit>
        <trans-unit id="5c95344b6a2f2f118527f061626aec54628cfeac" translate="yes" xml:space="preserve">
          <source>Use of this invalid value as an argument to any &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; member taking a value of this type is undefined behaviour</source>
          <target state="translated">El uso de este valor no v&amp;aacute;lido como argumento para cualquier miembro &lt;code&gt;&lt;a href=&quot;../io/basic_istream&quot;&gt;std::istream&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/basic_ostream&quot;&gt;std::ostream&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; toma un valor de este tipo es un comportamiento indefinido</target>
        </trans-unit>
        <trans-unit id="6eb61fe88f9155e92fd5505231d51581c0a1f378" translate="yes" xml:space="preserve">
          <source>Use the &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;Modified ECMAScript regular expression grammar&lt;/a&gt;</source>
          <target state="translated">Utilice la &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript&quot;&gt;gram&amp;aacute;tica de expresi&amp;oacute;n regular ECMAScript modificada&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b59f8d4a6e7623991a4148e772aefe99cb9c959" translate="yes" xml:space="preserve">
          <source>Use the basic POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">Use la gram&amp;aacute;tica de expresi&amp;oacute;n regular POSIX b&amp;aacute;sica ( &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03&quot;&gt;documentaci&amp;oacute;n gramatical&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="4032118ad7e10c8a56fe81c51513bcd0f4198612" translate="yes" xml:space="preserve">
          <source>Use the extended POSIX regular expression grammar (&lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;grammar documentation&lt;/a&gt;).</source>
          <target state="translated">Utilice la gram&amp;aacute;tica de expresi&amp;oacute;n regular POSIX extendida ( &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_04&quot;&gt;documentaci&amp;oacute;n gramatical&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="efdfc5f80485169681a19ba23803d6f84ff4e293" translate="yes" xml:space="preserve">
          <source>Use the regular expression grammar used by the</source>
          <target state="translated">Utiliza la gramática de la expresión regular usada por el</target>
        </trans-unit>
        <trans-unit id="b6f72b04e0e8a80cecbd0a1176096ac1763ecf62" translate="yes" xml:space="preserve">
          <source>Used as a more readable equivalent to the traditional &lt;a href=&quot;for&quot;&gt; for loop&lt;/a&gt; operating over a range of values, such as all elements in a container.</source>
          <target state="translated">Se utiliza como un equivalente m&amp;aacute;s legible que el &lt;a href=&quot;for&quot;&gt;bucle&lt;/a&gt; tradicional para operar en un rango de valores, como todos los elementos en un contenedor.</target>
        </trans-unit>
        <trans-unit id="5a1c568d8c824c8779a7fbd4ddf0353bf241da96" translate="yes" xml:space="preserve">
          <source>Used fields</source>
          <target state="translated">Campos usados</target>
        </trans-unit>
        <trans-unit id="df4ac21ba90d03bbec4f8d92680ff358bb022c1a" translate="yes" xml:space="preserve">
          <source>Used to mark a &lt;a href=&quot;../language/class_template&quot;&gt;template definition&lt;/a&gt;</source>
          <target state="translated">Se usa para marcar una &lt;a href=&quot;../language/class_template&quot;&gt;definici&amp;oacute;n de plantilla&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af59dbcc1c5fb76dabc78981244f1492f92bd30a" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type</source>
          <target state="translated">Se utiliza para referirse al tipo de personaje</target>
        </trans-unit>
        <trans-unit id="452240ee9951387e7059a7bfdc9cc878fb58e6e5" translate="yes" xml:space="preserve">
          <source>Used to refer to the character type.</source>
          <target state="translated">Se utiliza para referirse al tipo de personaje.</target>
        </trans-unit>
        <trans-unit id="0411cff330fe1f926e098add76bac8d23f3a24cd" translate="yes" xml:space="preserve">
          <source>Used when actual size of the object must be known.</source>
          <target state="translated">Se utiliza cuando debe conocerse el tamaño real del objeto.</target>
        </trans-unit>
        <trans-unit id="cd3a7677f14605e188f81a1607ce0b998a59e8fc" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to ignore the remaining portion of the loop using conditional statements.</source>
          <target state="translated">Se utiliza cuando resulta incómodo ignorar la parte restante del bucle mediante declaraciones condicionales.</target>
        </trans-unit>
        <trans-unit id="73641814b8ae560f3493eb824a0db1bde1f528d6" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise awkward to terminate the loop using the condition expression and conditional statements.</source>
          <target state="translated">Se utiliza cuando de otro modo resulta incómodo terminar el bucle utilizando la expresión de la condición y las declaraciones condicionales.</target>
        </trans-unit>
        <trans-unit id="e80aa66e106a415e8288da7170c66b3a43f1b6c5" translate="yes" xml:space="preserve">
          <source>Used when it is otherwise impossible to transfer control to the desired location using other statements.</source>
          <target state="translated">Se utiliza cuando de otro modo es imposible transferir el control al lugar deseado utilizando otras declaraciones.</target>
        </trans-unit>
        <trans-unit id="7062a1fb9e1b49180bc64e78c1788d8e78b97581" translate="yes" xml:space="preserve">
          <source>Used where code needs to be executed based on a run-time or compile-time condition.</source>
          <target state="translated">Se utiliza cuando el código necesita ser ejecutado basado en una condición de tiempo de ejecución o tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="bf16483f532d4a8853cf1010caa2cb57d0f33c2f" translate="yes" xml:space="preserve">
          <source>Used where the &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;dynamic type&lt;/a&gt; of a &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic object&lt;/a&gt; must be known and for static type identification.</source>
          <target state="translated">Se usa donde se debe conocer el &lt;a href=&quot;type-id#Dynamic_type&quot;&gt;tipo din&amp;aacute;mico&lt;/a&gt; de un &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;objeto polim&amp;oacute;rfico&lt;/a&gt; y para la identificaci&amp;oacute;n de tipo est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="42d90e90aadfee8047aec9690cf0574d0347d7d2" translate="yes" xml:space="preserve">
          <source>User code should usually use &lt;code&gt;std::chrono::clock_cast&lt;/code&gt;, which provides a generic interface to convert time points between clocks, rather than call these functions directly.</source>
          <target state="translated">El c&amp;oacute;digo de usuario generalmente debe usar &lt;code&gt;std::chrono::clock_cast&lt;/code&gt; , que proporciona una interfaz gen&amp;eacute;rica para convertir puntos de tiempo entre relojes, en lugar de llamar a estas funciones directamente.</target>
        </trans-unit>
        <trans-unit id="22f079a53befe874a015e16af5dac8a9dbe1d7c3" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;../new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../new/operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Versiones de reemplazo de usuario del &lt;a href=&quot;../new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; global nuevo y &lt;a href=&quot;../new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="beecf2d4915648f8f0efab35c62b4b57d5f5b1df" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;a href=&quot;operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/a&gt; and &lt;strong&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/strong&gt;</source>
          <target state="translated">Versiones de reemplazo de usuario del &lt;a href=&quot;operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; global nuevo y &lt;strong&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="36a2cff95d451b8ddda6e6fad777fc4eedb46043" translate="yes" xml:space="preserve">
          <source>User replacement versions of global &lt;strong&gt;&lt;code&gt;operator new&lt;/code&gt;&lt;/strong&gt; and &lt;a href=&quot;operator_delete&quot;&gt;&lt;code&gt;operator delete&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Versiones de reemplazo de usuario del &lt;strong&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/strong&gt; global &lt;strong&gt;nuevo&lt;/strong&gt; y &lt;a href=&quot;operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="f9aac68f1811d0c886372a7b6aa12dfd47145f36" translate="yes" xml:space="preserve">
          <source>User specializations may define the member type &lt;code&gt;iterator_concept&lt;/code&gt; to one of &lt;a href=&quot;iterator_tags&quot;&gt;iterator category tags&lt;/a&gt;, to indicate conformance to the iterator concepts.</source>
          <target state="translated">Las especializaciones de usuario pueden definir el tipo de miembro &lt;code&gt;iterator_concept&lt;/code&gt; a una de las &lt;a href=&quot;iterator_tags&quot;&gt;etiquetas de categor&amp;iacute;a&lt;/a&gt; de iterador , para indicar conformidad con los conceptos de iterador.</target>
        </trans-unit>
        <trans-unit id="691620a9d9530e81a0d5cd25eb278071f62c4739" translate="yes" xml:space="preserve">
          <source>User-Defined Literals</source>
          <target state="translated">Literales definidos por el usuario</target>
        </trans-unit>
        <trans-unit id="d55e108d604fa5cfa1e00711a9ffe9ad9af9acb8" translate="yes" xml:space="preserve">
          <source>User-defined Literals for std::complex</source>
          <target state="translated">Literales definidos por el usuario para std::complex</target>
        </trans-unit>
        <trans-unit id="66b100ca6f92096c7cc2adfb8fd94dcf564c734d" translate="yes" xml:space="preserve">
          <source>User-defined character traits may be used to provide &lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;case-insensitive comparison&lt;/a&gt;.</source>
          <target state="translated">Los rasgos de caracteres definidos por el usuario pueden usarse para proporcionar &lt;a href=&quot;http://www.gotw.ca/gotw/029.htm&quot;&gt;una comparaci&amp;oacute;n entre may&amp;uacute;sculas y min&amp;uacute;sculas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="521384c0aef8e04b593ebebfeb20da581eaab716" translate="yes" xml:space="preserve">
          <source>User-defined classes and enumerations that implement the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; are required to overload the bitwise arithmetic operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt;, and may optionally overload the shift operators &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt;, and &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt;. The canonical implementations usually follow the pattern for binary arithmetic operators described above.</source>
          <target state="translated">Las clases y enumeraciones definidas por el usuario que implementan los requisitos de &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; son necesarias para sobrecargar los operadores aritm&amp;eacute;ticos bit a operador &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; , y &lt;code&gt;operator^=&lt;/code&gt; , y opcionalmente puede sobrecargar los operadores de turno &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; , &lt;code&gt;operator&amp;gt;&amp;gt;=&lt;/code&gt; y &lt;code&gt;operator&amp;lt;&amp;lt;=&lt;/code&gt; . Las implementaciones can&amp;oacute;nicas usualmente siguen el patr&amp;oacute;n para operadores aritm&amp;eacute;ticos binarios descritos anteriormente.</target>
        </trans-unit>
        <trans-unit id="41ab182df7e7de75a62a46e254284df8495915ff" translate="yes" xml:space="preserve">
          <source>User-defined classes that provide array-like access that allows both reading and writing typically define two overloads for &lt;code&gt;operator[]&lt;/code&gt;: const and non-const variants:</source>
          <target state="translated">Las clases definidas por el usuario que proporcionan acceso tipo matriz que permite tanto la lectura como la escritura suelen definir dos sobrecargas para el &lt;code&gt;operator[]&lt;/code&gt; : variantes const y no const:</target>
        </trans-unit>
        <trans-unit id="9759d0c809ae6bc40bb8a39c15779393d91b25b2" translate="yes" xml:space="preserve">
          <source>User-defined conversion function is invoked on the second stage of the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt;, which consists of zero or one &lt;a href=&quot;converting_constructor&quot;&gt;converting constructor&lt;/a&gt; or zero or one user-defined conversion function.</source>
          <target state="translated">La funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario se invoca en la segunda etapa de la &lt;a href=&quot;implicit_cast&quot;&gt;conversi&amp;oacute;n impl&amp;iacute;cita&lt;/a&gt; , que consiste en cero o un &lt;a href=&quot;converting_constructor&quot;&gt;constructor de conversi&amp;oacute;n&lt;/a&gt; o cero o una funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario.</target>
        </trans-unit>
        <trans-unit id="43fb76a0004d3479d12ac1d1092e34daa13fde1a" translate="yes" xml:space="preserve">
          <source>User-defined conversions (both converting constructors and user-defined conversion functions) are prohibited from taking part in implicit conversion sequence where it would make it possible to apply more than one user-defined conversion. Specifically, they are not considered if the target of the conversion is the first parameter of a constructor or the implicit object parameter of a user-defined conversion function, and that constructor/user-defined conversion is a candidate for.</source>
          <target state="translated">Se prohíbe que las conversiones definidas por el usuario (tanto los constructores de conversiones como las funciones de conversión definidas por el usuario)participen en una secuencia de conversión implícita en la que sea posible aplicar más de una conversión definida por el usuario.Concretamente,no se consideran si el objetivo de la conversión es el primer parámetro de un constructor o el parámetro de objeto implícito de una función de conversión definida por el usuario,y esa conversión definida por el constructor/usuario es candidata a ello.</target>
        </trans-unit>
        <trans-unit id="c8869104cf44d820cb55c49ce74b8353880870a6" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides</source>
          <target state="translated">Guías de deducción definidas por el usuario</target>
        </trans-unit>
        <trans-unit id="ef26f7121e5a45ae6e617a4103dcbb63ab5dc3ab" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides do not have to be templates:</source>
          <target state="translated">Las guías de deducción definidas por el usuario no tienen que ser plantillas:</target>
        </trans-unit>
        <trans-unit id="ada924d219c774c38ebbaa26b6b0ac7bd8284f27" translate="yes" xml:space="preserve">
          <source>User-defined deduction guides must name a class template and must be introduced within the same semantic scope of the class template (which could be namespace or enclosing class) and, for a member class template, must have the same access, but deduction guides do not become members of that scope.</source>
          <target state="translated">Las guías de deducción definidas por el usuario deben nombrar una plantilla de clase y deben introducirse dentro del mismo ámbito semántico de la plantilla de clase (que puede ser un espacio de nombres o una clase adjunta)y,en el caso de una plantilla de clase de miembro,deben tener el mismo acceso,pero las guías de deducción no se convierten en miembros de ese ámbito.</target>
        </trans-unit>
        <trans-unit id="9f7140ad8b86562edf1af76c7b4d2ecd3daf0a05" translate="yes" xml:space="preserve">
          <source>User-defined literals</source>
          <target state="translated">Literales definidos por el usuario</target>
        </trans-unit>
        <trans-unit id="27875895c12b2d250978e1e13877f06ad81a62ef" translate="yes" xml:space="preserve">
          <source>User-defined literals (since C++11)</source>
          <target state="translated">Literales definidos por el usuario (desde C++11)</target>
        </trans-unit>
        <trans-unit id="f9e1a4e3fe3d8c4879519e8d07a0503e9a4c9e72" translate="yes" xml:space="preserve">
          <source>User-defined literals for string types</source>
          <target state="translated">Los literales definidos por el usuario para los tipos de cadena</target>
        </trans-unit>
        <trans-unit id="d0490dae080d561474031e5c0e2c4ef6347ced31" translate="yes" xml:space="preserve">
          <source>User-defined literals for time types</source>
          <target state="translated">Literales definidos por el usuario para los tipos de tiempo</target>
        </trans-unit>
        <trans-unit id="fc5e25714db01eb56b2bf86b5e7921777fc9f4c1" translate="yes" xml:space="preserve">
          <source>User-defined overloads</source>
          <target state="translated">Sobrecargas definidas por el usuario</target>
        </trans-unit>
        <trans-unit id="33745b553a69e48bb26d5d43ad7a22124cb88491" translate="yes" xml:space="preserve">
          <source>User-defined overloads of &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; or &lt;code&gt;||&lt;/code&gt; have no effect on constraint normalization.</source>
          <target state="translated">Sobrecargas definidas por el usuario de &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; o &lt;code&gt;||&lt;/code&gt; no tienen efecto en la normalizaci&amp;oacute;n de restricciones.</target>
        </trans-unit>
        <trans-unit id="9d6ddc3c3044ee87f524355e003d05e7748d65d0" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;leap&lt;/code&gt; objects except by copying from existing &lt;code&gt;leap&lt;/code&gt; objects. The library implementation creates &lt;code&gt;leap&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">Los usuarios no pueden construir objetos de &lt;code&gt;leap&lt;/code&gt; excepto copiando desde objetos de &lt;code&gt;leap&lt;/code&gt; existentes . La implementaci&amp;oacute;n de la biblioteca crea objetos de &lt;code&gt;leap&lt;/code&gt; cuando inicializa la base de datos de zona horaria y proporciona acceso &lt;code&gt;const&lt;/code&gt; ante a estos objetos.</target>
        </trans-unit>
        <trans-unit id="f9e764d8a62224f28652f9477d145424640947d7" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;link&lt;/code&gt; objects. The library implementation creates &lt;code&gt;link&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">Los usuarios no pueden construir objetos de &lt;code&gt;link&lt;/code&gt; . La implementaci&amp;oacute;n de la biblioteca crea objetos de &lt;code&gt;link&lt;/code&gt; cuando inicializa la base de datos de zona horaria y proporciona acceso &lt;code&gt;const&lt;/code&gt; ante a estos objetos.</target>
        </trans-unit>
        <trans-unit id="af2f54042c747b54c3093610083361c67a39fbfd" translate="yes" xml:space="preserve">
          <source>Users cannot construct &lt;code&gt;time_zone&lt;/code&gt; objects. The library implementation creates &lt;code&gt;time_zone&lt;/code&gt; objects when it initializes the time zone database and provides &lt;code&gt;const&lt;/code&gt; access to these objects.</source>
          <target state="translated">Los usuarios no pueden construir objetos &lt;code&gt;time_zone&lt;/code&gt; . La implementaci&amp;oacute;n de la biblioteca crea objetos &lt;code&gt;time_zone&lt;/code&gt; cuando inicializa la base de datos de zona horaria y proporciona acceso &lt;code&gt;const&lt;/code&gt; ante a estos objetos.</target>
        </trans-unit>
        <trans-unit id="946304840b5dd2cc7ea35261e0218a4ed1cc1b01" translate="yes" xml:space="preserve">
          <source>Users may derive from &lt;code&gt;view_base&lt;/code&gt; or specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt; for types which model &lt;code&gt;View&lt;/code&gt;, and specialize &lt;code&gt;enable_view&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt; for types which do not.</source>
          <target state="translated">Los usuarios pueden derivar de &lt;code&gt;view_base&lt;/code&gt; o especializar &lt;code&gt;enable_view&lt;/code&gt; a &lt;code&gt;true&lt;/code&gt; para los tipos que modelan &lt;code&gt;View&lt;/code&gt; , y especializar &lt;code&gt;enable_view&lt;/code&gt; a &lt;code&gt;false&lt;/code&gt; para los tipos que no lo hacen.</target>
        </trans-unit>
        <trans-unit id="d77619d2d2aeedbc5912e54a11fc69314fc4b9b4" translate="yes" xml:space="preserve">
          <source>Users may specialize &lt;code&gt;common_type&lt;/code&gt; for types &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; if.</source>
          <target state="translated">Los usuarios pueden especializarse &lt;code&gt;common_type&lt;/code&gt; para los tipos &lt;code&gt;T1&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; si.</target>
        </trans-unit>
        <trans-unit id="44312d9b5ba550e3bf714285fd931d65780211eb" translate="yes" xml:space="preserve">
          <source>Uses base class pword storage for runtime type identification of derived stream objects.</source>
          <target state="translated">Utiliza el almacenamiento de palabras de la clase base p para la identificación del tipo de tiempo de ejecución de los objetos de corriente derivados.</target>
        </trans-unit>
        <trans-unit id="435dd26a3c29e79ab39283f08d206249de9658d9" translate="yes" xml:space="preserve">
          <source>Uses native_handle to enable realtime scheduling of C++ threads on a POSIX system.</source>
          <target state="translated">Utiliza el native_handle para permitir la programación en tiempo real de los hilos C++en un sistema POSIX.</target>
        </trans-unit>
        <trans-unit id="47d9c5030129b909d30f38ba61ff22e289ed4dc7" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to allocate &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; bytes of uninitialized storage.</source>
          <target state="translated">Utiliza el asignador &lt;code&gt;a&lt;/code&gt; para asignar &lt;code&gt;n*sizeof(Alloc::value_type)&lt;/code&gt; bytes de almacenamiento no inicializado.</target>
        </trans-unit>
        <trans-unit id="5774066b9e43fa4c8cddba29af3f1729deeb9d50" translate="yes" xml:space="preserve">
          <source>Uses the allocator &lt;code&gt;a&lt;/code&gt; to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;a.deallocate(p, n)&lt;/code&gt;.</source>
          <target state="translated">Utiliza el asignador &lt;code&gt;a&lt;/code&gt; para desasignar el almacenamiento al que hace referencia &lt;code&gt;p&lt;/code&gt; , llamando a &lt;code&gt;a.deallocate(p, n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ba97051617e132658e923e2cd0500400c48654b" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to allocate uninitialized storage.</source>
          <target state="translated">Utiliza el asignador externo para asignar el almacenamiento no inicializado.</target>
        </trans-unit>
        <trans-unit id="b3f5f74569dd5173607ac926d852b70e7c657155" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to call the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="translated">Utiliza el asignador externo para llamar al destructor del objeto al que apunta &lt;code&gt;p&lt;/code&gt; , llamando.</target>
        </trans-unit>
        <trans-unit id="1233805d22778d94a1a1092f4fdeffec6effe4da" translate="yes" xml:space="preserve">
          <source>Uses the outer allocator to deallocate the storage referenced by &lt;code&gt;p&lt;/code&gt;, by calling &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt;.</source>
          <target state="translated">Utiliza el asignador externo para desasignar el almacenamiento al que hace referencia &lt;code&gt;p&lt;/code&gt; , llamando a &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::deallocate(outer_allocator(), p, n)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d6bd96d2b4bc007cec5dbc13bffdb43818c467e" translate="yes" xml:space="preserve">
          <source>Uses-allocator construction</source>
          <target state="translated">Construcción del asignador de usos</target>
        </trans-unit>
        <trans-unit id="e8ccfd79bce11a76a3f0a27cd61f22c4be4a0529" translate="yes" xml:space="preserve">
          <source>Using a member typedef or alias template in a constructor or constructor template's parameter list does not, by itself, render the corresponding parameter of the implicitly generated guide a non-deduced context.</source>
          <target state="translated">El uso de un miembro tipedef o de una plantilla con alias en la lista de parámetros de un constructor o de una plantilla de constructor no hace,por sí mismo,que el parámetro correspondiente de la guía generada implícitamente sea un contexto no deducido.</target>
        </trans-unit>
        <trans-unit id="3973ba3748f277f1b1247e46879f1a5b0ff12c85" translate="yes" xml:space="preserve">
          <source>Using this library may require additional compiler/linker options. GNU implementation requires linking with &lt;code&gt;-lstdc++fs&lt;/code&gt; and LLVM implementation requires linking with &lt;code&gt;-lc++fs&lt;/code&gt;.</source>
          <target state="translated">El uso de esta biblioteca puede requerir opciones adicionales de compilador / enlazador. La implementaci&amp;oacute;n de GNU requiere un enlace con &lt;code&gt;-lstdc++fs&lt;/code&gt; y la implementaci&amp;oacute;n de LLVM requiere un enlace con &lt;code&gt;-lc++fs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="478f8e8f8e40a23e1335aa300d9b135f2ed07fd9" translate="yes" xml:space="preserve">
          <source>Using-declaration</source>
          <target state="translated">Using-declaration</target>
        </trans-unit>
        <trans-unit id="e192f9ebd97a059b8b3818089ff571a2768e5ba3" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of a base class into the derived class definition, such as to expose a protected member of base as public member of derived. In this case, nested-name-specifier must name a base class of the one being defined. If the name is the name of an overloaded member function of the base class, all base class member functions with that name are introduced. If the derived class already has a member with the same name, parameter list, and qualifications, the derived class member hides or overrides (doesn't conflict with) the member that is introduced from the base class.</source>
          <target state="translated">La declaración de uso introduce a un miembro de una clase base en la definición de clase derivada,de manera tal que se expone a un miembro protegido de la base como miembro público de la derivada.En este caso,el especificador del nombre anidado debe nombrar una clase base de la que se está definiendo.Si el nombre es el nombre de una función de miembro sobrecargado de la clase base,se introducen todas las funciones de miembro de la clase base con ese nombre.Si la clase derivada ya tiene un miembro con el mismo nombre,lista de parámetros y calificaciones,el miembro de la clase derivada oculta o anula (no entra en conflicto con)el miembro que se introduce de la clase base.</target>
        </trans-unit>
        <trans-unit id="647139d11b1988510ebdf137fbaac198034c6a6b" translate="yes" xml:space="preserve">
          <source>Using-declaration introduces a member of another namespace into current namespace or block scope.</source>
          <target state="translated">La declaración de uso introduce a un miembro de otro espacio de nombres en el espacio de nombres actual o en el ámbito del bloque.</target>
        </trans-unit>
        <trans-unit id="96ab3f618e4bb79ceae244afaf56510df88fbaa8" translate="yes" xml:space="preserve">
          <source>Using-declarations</source>
          <target state="translated">Using-declarations</target>
        </trans-unit>
        <trans-unit id="89ce2da2bf0809daefed3588888e71ab6c4b17a5" translate="yes" xml:space="preserve">
          <source>Using-declarations can be used to introduce namespace members into other namespaces and block scopes, or to introduce base class members into derived class definitions.</source>
          <target state="translated">Las declaraciones de uso pueden utilizarse para introducir miembros del espacio de nombres en otros espacios de nombres y alcances de bloques,o para introducir miembros de la clase base en definiciones de clase derivadas.</target>
        </trans-unit>
        <trans-unit id="1afd86105bb6b7eae3d1c2ff8ebac8080cc93c0b" translate="yes" xml:space="preserve">
          <source>Using-declarations cannot name &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, namespace, or a scoped enumerator. Each declarator in a using-declaration introduces one and only one name, for example using-declaration for an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; does not introduce any of its enumerators.</source>
          <target state="translated">Using-declaraciones no puede nombrar &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; , espacio de nombres o un enumerador de &amp;aacute;mbito. Cada declarador en una declaraci&amp;oacute;n de uso introduce uno y solo un nombre, por ejemplo, la declaraci&amp;oacute;n de uso para una &lt;a href=&quot;enum&quot;&gt;enumeraci&amp;oacute;n&lt;/a&gt; no introduce ninguno de sus enumeradores.</target>
        </trans-unit>
        <trans-unit id="243bb7e4adba8af291f9b9518cc9a875ccf74e65" translate="yes" xml:space="preserve">
          <source>Using-declarations in derived classes cannot refer to specializations of template conversion functions from base classes.</source>
          <target state="translated">Las declaraciones de uso en clases derivadas no pueden referirse a las especializaciones de las funciones de conversión de plantillas de las clases base.</target>
        </trans-unit>
        <trans-unit id="890b0e8bf12e6e2f8622f4d2164034f01e35b67b" translate="yes" xml:space="preserve">
          <source>Using-directive does not add any names to the declarative region in which it appears (unlike the using-declaration), and thus does not prevent identical names from being declared.</source>
          <target state="translated">La directiva de uso no añade ningún nombre a la región declarativa en la que aparece (a diferencia de la usado-declaración),por lo que no impide que se declaren nombres idénticos.</target>
        </trans-unit>
        <trans-unit id="9267f4ac5eb849d97bac3ea55d519f3646d7511f" translate="yes" xml:space="preserve">
          <source>Using-directives</source>
          <target state="translated">Using-directives</target>
        </trans-unit>
        <trans-unit id="e478a805aae96b5ada7799a77a72b64e59439220" translate="yes" xml:space="preserve">
          <source>Using-directives are allowed only in namespace &lt;a href=&quot;scope&quot;&gt;scope&lt;/a&gt; and in block scope. From the point of view of unqualified &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt; of any name after a using-directive and until the end of the scope in which it appears, every name from namespace-name is visible as if it were declared in the nearest enclosing namespace which contains both the using-directive and namespace-name.</source>
          <target state="translated">Las directivas de uso solo se permiten en el &lt;a href=&quot;scope&quot;&gt;&amp;aacute;mbito del&lt;/a&gt; espacio de nombres y en el &amp;aacute;mbito del bloque. Desde el punto de vista de la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; de nombres no calificados de cualquier nombre despu&amp;eacute;s de una directiva de uso y hasta el final del alcance en el que aparece, cada nombre del nombre del espacio de nombres es visible como si fuera declarado en el espacio de nombres adjunto m&amp;aacute;s cercano que contiene ambos la directiva using y el nombre del espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="fe20c085207b808c419801ec01c3f2d69d1e53a9" translate="yes" xml:space="preserve">
          <source>Using-directives are transitive for the purposes of &lt;a href=&quot;lookup&quot;&gt;unqualified lookup&lt;/a&gt;: if a scope contains a using-directive that nominates a namespace-name, which itself contains using-directive for some namespace-name-2, the effect is as if the using directives from the second namespace appear within the first. The order in which these transitive namespaces occur does not influence name lookup.</source>
          <target state="translated">Las directivas de uso son transitivas para fines de &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda no calificada&lt;/a&gt; : si un &amp;aacute;mbito contiene una directiva de uso que designa un nombre de espacio de nombres, que a su vez contiene la directiva de uso para algunos nombres de espacio de nombres 2, el efecto es como si las directivas de uso de el segundo espacio de nombres aparece dentro del primero. El orden en que ocurren estos espacios de nombres transitivos no influye en la b&amp;uacute;squeda de nombres.</target>
        </trans-unit>
        <trans-unit id="90e771e57dbe271295562deb5815544ce47acec2" translate="yes" xml:space="preserve">
          <source>Usual &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name lookup&lt;/a&gt; is used for the identifier prefixed by &lt;code&gt;typename&lt;/code&gt;. Unlike the case with &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, the lookup rules do not change despite the qualifier:</source>
          <target state="translated">La &lt;a href=&quot;qualified_lookup&quot;&gt;b&amp;uacute;squeda de nombre calificado&lt;/a&gt; habitual se utiliza para el identificador con el prefijo &lt;code&gt;typename&lt;/code&gt; . A diferencia del caso con el &lt;a href=&quot;elaborated_type_specifier&quot;&gt;especificador de tipo elaborado&lt;/a&gt; , las reglas de b&amp;uacute;squeda no cambian a pesar del calificador:</target>
        </trans-unit>
        <trans-unit id="18fdc5ee8b1f8fba8dabaa933373c0483ab7fad7" translate="yes" xml:space="preserve">
          <source>Utilities</source>
          <target state="translated">Utilities</target>
        </trans-unit>
        <trans-unit id="72c1f2942e6c2f59eb16eb2f336358c3428f04e8" translate="yes" xml:space="preserve">
          <source>Utilities library</source>
          <target state="translated">Biblioteca de utilidades</target>
        </trans-unit>
        <trans-unit id="c238357565249d5db64377b7321a861ff74e6a3d" translate="yes" xml:space="preserve">
          <source>Utility components</source>
          <target state="translated">Componentes de utilidad</target>
        </trans-unit>
        <trans-unit id="69be11f41a3c37842e99473568839d6e6c14c854" translate="yes" xml:space="preserve">
          <source>Utility library</source>
          <target state="translated">Biblioteca de servicios públicos</target>
        </trans-unit>
        <trans-unit id="6c204fbda83dad99b4764ac479029ca8981e718e" translate="yes" xml:space="preserve">
          <source>Utility metafunction that maps a sequence of any types to the type &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Metafunci&amp;oacute;n de utilidad que asigna una secuencia de cualquier tipo al tipo &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d7fadc1640d7f4704fe07fafd860ef56a6519b" translate="yes" xml:space="preserve">
          <source>VERTICAL KANA REPEAT MARK - HANGUL JONGSEONG PHIEUPH-THIEUTH</source>
          <target state="translated">MARCA DE REPETICIÓN DE KANA VERTICAL-HANGUL JONGSEONG PHIEUPH-THIEUTH</target>
        </trans-unit>
        <trans-unit id="5a815286d91c46561b98d7d910a0542f7fa603a7" translate="yes" xml:space="preserve">
          <source>VULGAR FRACTION ONE QUARTER - VULGAR FRACTION THREE QUARTERS</source>
          <target state="translated">FRACCIÓN VULGAR UN CUARTO-FRACCIÓN VULGAR TRES CUARTOS</target>
        </trans-unit>
        <trans-unit id="2a85014316c857fc68366f2d4cfeef4ccca44072" translate="yes" xml:space="preserve">
          <source>Valid non-zero alignments that are weaker than another &lt;code&gt;alignas&lt;/code&gt; on the same declaration are ignored.</source>
          <target state="translated">Se ignoran las alineaciones v&amp;aacute;lidas distintas de cero que son m&amp;aacute;s d&amp;eacute;biles que otras &lt;code&gt;alignas&lt;/code&gt; en la misma declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8dce170de238b1feda2ecd9674ea3ca0d068fbcb" translate="yes" xml:space="preserve">
          <source>Value</source>
          <target state="translated">Value</target>
        </trans-unit>
        <trans-unit id="f00df19eab61f9bc6b193ebf7f79f580e312b435" translate="yes" xml:space="preserve">
          <source>Value (hex)</source>
          <target state="translated">Valor (hexágono)</target>
        </trans-unit>
        <trans-unit id="6ccf81011273d24c106e237774966bec5a3f3d04" translate="yes" xml:space="preserve">
          <source>Value (octal)</source>
          <target state="translated">Valor (octal)</target>
        </trans-unit>
        <trans-unit id="842d5c71fd285df07d76b3a931200aef4027bbe5" translate="yes" xml:space="preserve">
          <source>Value array containing</source>
          <target state="translated">La matriz de valores que contiene</target>
        </trans-unit>
        <trans-unit id="8f9d98449ec4c8f79f22636316b3a0e923c947ef" translate="yes" xml:space="preserve">
          <source>Value array containing absolute values of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene valores absolutos de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bba712cfd9f7651aa772da136f89a61149be2ac1" translate="yes" xml:space="preserve">
          <source>Value array containing arc cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene cosenos de arco de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="918e7d00363d34ea17b81a2896797c2d5407de29" translate="yes" xml:space="preserve">
          <source>Value array containing arc sines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene arcos de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dd43aa4756d43fc4b8be056b5da614e7ae17fe0" translate="yes" xml:space="preserve">
          <source>Value array containing arc tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene tangentes de arco de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a16b1209abeda990f5a71b8d2e227e0b6c93b82" translate="yes" xml:space="preserve">
          <source>Value array containing common logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene logaritmos comunes de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a311ab5baa8093138875ac8a94b0cea46530bc77" translate="yes" xml:space="preserve">
          <source>Value array containing cosines of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene cosenos de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67e25f3a01cf3ed1b997a81a0d9b1d557b7e592b" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic cosine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene coseno hiperb&amp;oacute;lico de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d4fd3ea31174e2ad27a712e67ef9575efad3f21" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene seno hiperb&amp;oacute;lico de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2a5794dbb6788174721a7201fba5775845755af6" translate="yes" xml:space="preserve">
          <source>Value array containing hyperbolic tangent of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene la tangente hiperb&amp;oacute;lica de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="788503847d55a0b843da66ecc9eb7e909c8e81ea" translate="yes" xml:space="preserve">
          <source>Value array containing natural logarithms of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene logaritmos naturales de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d94e0b0bb891cd281312eef3d7cafb82f9093c2" translate="yes" xml:space="preserve">
          <source>Value array containing sine of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene el seno de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bcd496b550ea36f6a6a5da52708746dfc984226" translate="yes" xml:space="preserve">
          <source>Value array containing square roots of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene ra&amp;iacute;ces cuadradas de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acec93cb24e8ed07513e328851e06115700eaed0" translate="yes" xml:space="preserve">
          <source>Value array containing tangents of the values in &lt;code&gt;va&lt;/code&gt;.</source>
          <target state="translated">Matriz de valores que contiene tangentes de los valores en &lt;code&gt;va&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de0430a56abae1a9c8cca4fd7a8b8906769e0636" translate="yes" xml:space="preserve">
          <source>Value categories</source>
          <target state="translated">Categorías de valor</target>
        </trans-unit>
        <trans-unit id="82a222afd8aa1f50591d47af3a1da440d1b6c1c9" translate="yes" xml:space="preserve">
          <source>Value initialization is performed in these situations:</source>
          <target state="translated">La inicialización del valor se realiza en estas situaciones:</target>
        </trans-unit>
        <trans-unit id="44ee88d7a37283ed3f2e5c6bb77a69fd4b4ff443" translate="yes" xml:space="preserve">
          <source>Value of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">Valor de &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f316bf9562d1f2536d1f98b558dad75f56bae376" translate="yes" xml:space="preserve">
          <source>Value of a floating-point or &lt;a href=&quot;../../types/is_integral&quot;&gt;Integral type&lt;/a&gt;</source>
          <target state="translated">Valor de un tipo de punto flotante o &lt;a href=&quot;../../types/is_integral&quot;&gt;integral&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8868e91c4a5c3eea6c88793879068066054670cd" translate="yes" xml:space="preserve">
          <source>Value of a type &lt;code&gt;Y&lt;/code&gt; whose &lt;a href=&quot;../container/node_handle&quot;&gt;node handles&lt;/a&gt; are compatible with X</source>
          <target state="translated">Valor de un tipo &lt;code&gt;Y&lt;/code&gt; cuyos &lt;a href=&quot;../container/node_handle&quot;&gt;manejadores de nodo&lt;/a&gt; son compatibles con X</target>
        </trans-unit>
        <trans-unit id="a6d7a9a5f8f421d8d8d1289caa1073e525a68c0c" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X::size_type&lt;/code&gt;</source>
          <target state="translated">Valor de tipo &lt;code&gt;X::size_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a3076d857f6bafe8bc4b757157d8b7e92030d350" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt;</source>
          <target state="translated">Valor de tipo &lt;code&gt;X&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bdc99e4fc02f27b3e7f0e86f72aae50003652dc4" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports multiple keys</source>
          <target state="translated">Valor de tipo &lt;code&gt;X&lt;/code&gt; cuando &lt;code&gt;X&lt;/code&gt; admite varias claves</target>
        </trans-unit>
        <trans-unit id="d88b2ce84fd44f3d069f80a1cad885599a530444" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;X&lt;/code&gt; when &lt;code&gt;X&lt;/code&gt; supports unique keys</source>
          <target state="translated">Valor de tipo &lt;code&gt;X&lt;/code&gt; cuando &lt;code&gt;X&lt;/code&gt; admite claves &amp;uacute;nicas</target>
        </trans-unit>
        <trans-unit id="b2e637fb234b0c6b9d295e0383f8ac972d2e9be2" translate="yes" xml:space="preserve">
          <source>Value of type &lt;code&gt;float&lt;/code&gt;</source>
          <target state="translated">Valor de tipo &lt;code&gt;float&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c7cea36bd22384e74ce5693b3a96747824e4406" translate="yes" xml:space="preserve">
          <source>Value range</source>
          <target state="translated">Rango de valores</target>
        </trans-unit>
        <trans-unit id="51127d011c590cc06c1287343706272a08f0dc2d" translate="yes" xml:space="preserve">
          <source>Value too large to be stored in data type</source>
          <target state="translated">Valor demasiado grande para ser almacenado en el tipo de datos</target>
        </trans-unit>
        <trans-unit id="af99e0d3d72b238f81c500119ae328f4acda13dc" translate="yes" xml:space="preserve">
          <source>Value transformations</source>
          <target state="translated">Transformaciones de valor</target>
        </trans-unit>
        <trans-unit id="60a41a8af03cf015b251f42ec4877faede44cfa3" translate="yes" xml:space="preserve">
          <source>Value transformations are conversions that change the &lt;a href=&quot;value_category&quot;&gt;value category&lt;/a&gt; of an expression. They take place whenever an expression appears as an operand of an operator that expects an expression of a different value category.</source>
          <target state="translated">Las transformaciones de valor son conversiones que cambian la &lt;a href=&quot;value_category&quot;&gt;categor&amp;iacute;a&lt;/a&gt; de valor de una expresi&amp;oacute;n. Se producen cuando una expresi&amp;oacute;n aparece como un operando de un operador que espera una expresi&amp;oacute;n de una categor&amp;iacute;a de valor diferente.</target>
        </trans-unit>
        <trans-unit id="912f89db75340dd536695f5900751cb79605c44e" translate="yes" xml:space="preserve">
          <source>Value-dependent expressions</source>
          <target state="translated">Expresiones dependientes del valor</target>
        </trans-unit>
        <trans-unit id="1c83d35b39b8a1674f047686e39badc8092fea73" translate="yes" xml:space="preserve">
          <source>ValueSwappable</source>
          <target state="translated">ValueSwappable</target>
        </trans-unit>
        <trans-unit id="5cfdbdef621053e4c2adb3e5800cfd3510d6d549" translate="yes" xml:space="preserve">
          <source>ValueType</source>
          <target state="translated">ValueType</target>
        </trans-unit>
        <trans-unit id="e3d8fb1ed748d78b39416572c15d6566892835be" translate="yes" xml:space="preserve">
          <source>Values of &lt;code&gt;base&lt;/code&gt; other than 8, 10, or 16 reset &lt;code&gt;basefield&lt;/code&gt; to zero, which corresponds to decimal output and prefix-dependent input.</source>
          <target state="translated">Los valores de &lt;code&gt;base&lt;/code&gt; distintos de 8, 10 o 16 restablecen el &lt;code&gt;basefield&lt;/code&gt; a cero, que corresponde a la salida decimal y a la entrada dependiente del prefijo.</target>
        </trans-unit>
        <trans-unit id="699b7fde74d4bad2ed32bf4fdac5cb581d05b675" translate="yes" xml:space="preserve">
          <source>Values of integer, floating-point, and enumeration types can be converted by &lt;a href=&quot;static_cast&quot;&gt;&lt;code&gt;static_cast&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;explicit_cast&quot;&gt;explicit cast&lt;/a&gt;, to any enumeration type. If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the source value (first converted to the enumeration's underlying type if floating-point) is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration). Otherwise, the result is the same as the result of &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; to the underlying type.</source>
          <target state="translated">Los valores de tipos enteros, de coma flotante y de enumeraci&amp;oacute;n se pueden convertir mediante &lt;a href=&quot;static_cast&quot;&gt; &lt;code&gt;static_cast&lt;/code&gt; &lt;/a&gt; o conversi&amp;oacute;n&lt;a href=&quot;explicit_cast&quot;&gt; expl&amp;iacute;cita&lt;/a&gt; , a cualquier tipo de enumeraci&amp;oacute;n. Si el tipo subyacente no es fijo, el resultado es comportamiento indefinido no especificado (hasta C ++ 17) (desde C ++ 17) si el valor fuente (convertido primero al tipo subyacente de la enumeraci&amp;oacute;n si est&amp;aacute; en coma flotante) est&amp;aacute; fuera de rango ( el rango es todos los valores posibles para el campo de bits m&amp;aacute;s peque&amp;ntilde;o lo suficientemente grande como para contener todos los enumeradores de la enumeraci&amp;oacute;n de destino). De lo contrario, el resultado es el mismo que el resultado de la &lt;a href=&quot;implicit_cast&quot;&gt;conversi&amp;oacute;n impl&amp;iacute;cita&lt;/a&gt; al tipo subyacente.</target>
        </trans-unit>
        <trans-unit id="622c99b5f957359968fbce43706c282c2086981e" translate="yes" xml:space="preserve">
          <source>Values of unscoped enumeration type are &lt;a href=&quot;implicit_cast&quot;&gt;implicitly-convertible&lt;/a&gt; to integral types. If the underlying type is not fixed, the value is convertible to the first type from the following list able to hold their entire value range: &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, or &lt;code&gt;unsigned long long&lt;/code&gt;. If the underlying type is fixed, the values can be converted to their promoted underlying type.</source>
          <target state="translated">Los valores de tipo de enumeraci&amp;oacute;n sin &amp;aacute;mbito son &lt;a href=&quot;implicit_cast&quot;&gt;impl&amp;iacute;citamente convertibles&lt;/a&gt; a tipos integrales. Si el tipo subyacente no es fijo, el valor es convertible al primer tipo de la siguiente lista capaz de mantener todo su rango de valores: &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; o &lt;code&gt;unsigned long long&lt;/code&gt; . Si el tipo subyacente es fijo, los valores se pueden convertir a su tipo subyacente promocionado.</target>
        </trans-unit>
        <trans-unit id="f8df93af76ffcc18fdab0d35c919d46adda08d0a" translate="yes" xml:space="preserve">
          <source>Values of zero will be replaced with implementation-specified defaults;</source>
          <target state="translated">Los valores de cero serán reemplazados por valores predeterminados especificados para la implementación;</target>
        </trans-unit>
        <trans-unit id="052336d34e395136fdc7b0ea68de9e6ce0735430" translate="yes" xml:space="preserve">
          <source>Values returned from &lt;code&gt;lookup_classname&lt;/code&gt; can be bitwise or'ed together; the resulting value represents membership in either of the corresponding character classes</source>
          <target state="translated">Los valores devueltos por &lt;code&gt;lookup_classname&lt;/code&gt; pueden ser bit a bit o juntos; el valor resultante representa la pertenencia a cualquiera de las clases de caracteres correspondientes</target>
        </trans-unit>
        <trans-unit id="df08eb1d25241fdec3135b3385380633b3feb713" translate="yes" xml:space="preserve">
          <source>Variable template(since C++14)</source>
          <target state="translated">Plantilla variable (desde C++14)</target>
        </trans-unit>
        <trans-unit id="07e0c173abb12ff926e54a677500672fc6b6b986" translate="yes" xml:space="preserve">
          <source>Variable templates</source>
          <target state="translated">Plantillas variables</target>
        </trans-unit>
        <trans-unit id="bb8bc60fbcd37b30cc10bb1c4aefe4bd77138258" translate="yes" xml:space="preserve">
          <source>Variable templates cannot be used as &lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;template template arguments&lt;/a&gt;.</source>
          <target state="translated">Las plantillas variables no se pueden usar como &lt;a href=&quot;template_parameters#Template_template_arguments&quot;&gt;argumentos de plantilla&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bf60c912c256eebe5d2b8b031ec6bed1e0afbc9c" translate="yes" xml:space="preserve">
          <source>Variable templates for type traits</source>
          <target state="translated">Plantillas variables para los rasgos de tipo</target>
        </trans-unit>
        <trans-unit id="d41def7a6d8846ea38dabfb67345e2e0a09f52e7" translate="yes" xml:space="preserve">
          <source>Variables declared at block scope with the specifier &lt;code&gt;static&lt;/code&gt; have static storage duration but are initialized the first time control passes through their declaration (unless their initialization is &lt;a href=&quot;zero_initialization&quot;&gt;zero-&lt;/a&gt; or &lt;a href=&quot;constant_initialization&quot;&gt;constant-initialization&lt;/a&gt;, which can be performed before the block is first entered). On all further calls, the declaration is skipped.</source>
          <target state="translated">Las variables declaradas en el alcance del bloque con el especificador &lt;code&gt;static&lt;/code&gt; tienen una duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico, pero se inicializan la primera vez que el control pasa por su declaraci&amp;oacute;n (a menos que su inicializaci&amp;oacute;n sea inicializaci&amp;oacute;n &lt;a href=&quot;zero_initialization&quot;&gt;cero&lt;/a&gt; o &lt;a href=&quot;constant_initialization&quot;&gt;constante&lt;/a&gt; , que se puede realizar antes de que el bloque se ingrese por primera vez). En todas las llamadas posteriores, se omite la declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="56198fe808c824ddba06784c100164faedd427c3" translate="yes" xml:space="preserve">
          <source>Variadic &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; (&lt;code&gt;std::scoped_lock&lt;/code&gt;)</source>
          <target state="translated">Variad &lt;code&gt;&lt;a href=&quot;thread/lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; ( &lt;code&gt;std::scoped_lock&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="a8548e5a783f6964c2b71215ac2f1cf031c3e8a0" translate="yes" xml:space="preserve">
          <source>Variadic arguments</source>
          <target state="translated">Argumentos variados</target>
        </trans-unit>
        <trans-unit id="8e36a4956d4555b32607f272180c87deea209898" translate="yes" xml:space="preserve">
          <source>Variadic functions</source>
          <target state="translated">Funciones variadas</target>
        </trans-unit>
        <trans-unit id="04c44e45105b6cf53a83ce33f663f4af86c9d0a7" translate="yes" xml:space="preserve">
          <source>Variadic functions are functions (e.g. &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt;) which take a &lt;a href=&quot;../language/variadic_arguments&quot;&gt;variable number of arguments&lt;/a&gt;.</source>
          <target state="translated">Las funciones variables son funciones (por ejemplo, &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::printf&lt;/a&gt;&lt;/code&gt; ) que toman un &lt;a href=&quot;../language/variadic_arguments&quot;&gt;n&amp;uacute;mero variable de argumentos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8a308087e2905028e7ad5d2c240717d97448c333" translate="yes" xml:space="preserve">
          <source>Variadic templates</source>
          <target state="translated">Plantillas variadas</target>
        </trans-unit>
        <trans-unit id="40aa5342cc8cddbbe71fe77cdf48f02a16642a52" translate="yes" xml:space="preserve">
          <source>Various &lt;a href=&quot;utility&quot;&gt; utility components&lt;/a&gt;</source>
          <target state="translated">Varios &lt;a href=&quot;utility&quot;&gt;componentes de utilidad&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="43dfbbdcd916a0c6741ae6b7703f2bf5dd8096c3" translate="yes" xml:space="preserve">
          <source>Vector capacity is never reduced when resizing to smaller size because that would invalidate all iterators, rather than only the ones that would be invalidated by the equivalent sequence of pop_back() calls.</source>
          <target state="translated">La capacidad del vector nunca se reduce al redimensionar a un tamaño más pequeño porque eso invalidaría todos los iteradores,en lugar de sólo los que serían invalidados por la secuencia equivalente de llamadas pop_back().</target>
        </trans-unit>
        <trans-unit id="5519001c19e39db626b1e56d5b3636ed5b38cb6f" translate="yes" xml:space="preserve">
          <source>Version (2) of the &lt;code&gt;#define&lt;/code&gt; directive defines a simple function-like macro.</source>
          <target state="translated">La versi&amp;oacute;n (2) de la directiva &lt;code&gt;#define&lt;/code&gt; define una macro simple similar a una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ae3376f429640ab77c59ef69b6eeee356493fa80" translate="yes" xml:space="preserve">
          <source>Version (3) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments. The additional arguments (called</source>
          <target state="translated">La versi&amp;oacute;n (3) de la directiva &lt;code&gt;#define&lt;/code&gt; define una macro similar a una funci&amp;oacute;n con un n&amp;uacute;mero variable de argumentos. Los argumentos adicionales (llamados</target>
        </trans-unit>
        <trans-unit id="3243986759cbfdbcf8f3fe70af12570a24f20c76" translate="yes" xml:space="preserve">
          <source>Version (4) of the &lt;code&gt;#define&lt;/code&gt; directive defines a function-like macro with variable number of arguments, but no regular arguments. The arguments (called</source>
          <target state="translated">La versi&amp;oacute;n (4) de la directiva &lt;code&gt;#define&lt;/code&gt; define una macro similar a una funci&amp;oacute;n con un n&amp;uacute;mero variable de argumentos, pero sin argumentos regulares. Los argumentos (llamados</target>
        </trans-unit>
        <trans-unit id="1c26c7d8a48f6ecef280cf0b203307778072892d" translate="yes" xml:space="preserve">
          <source>Viable functions</source>
          <target state="translated">Funciones viables</target>
        </trans-unit>
        <trans-unit id="69bd4ef9fbd0894a22759c3766b859defbdedbc8" translate="yes" xml:space="preserve">
          <source>View</source>
          <target state="translated">View</target>
        </trans-unit>
        <trans-unit id="57dde08ae7e4931bf4b1d9d8203c8fb2aa6c4ddb" translate="yes" xml:space="preserve">
          <source>View of the substring &lt;code&gt;[pos, pos + rcount)&lt;/code&gt;.</source>
          <target state="translated">Vista de la subcadena &lt;code&gt;[pos, pos + rcount)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08776128bd18b59c55542f61081a01440f41b01c" translate="yes" xml:space="preserve">
          <source>ViewableRange</source>
          <target state="translated">ViewableRange</target>
        </trans-unit>
        <trans-unit id="24be61285e096fa817d4cdb0a0ed8294ea5bd2fb" translate="yes" xml:space="preserve">
          <source>Views</source>
          <target state="translated">Views</target>
        </trans-unit>
        <trans-unit id="c911ee9da5495317a3fd2048e2a77408d0f7651d" translate="yes" xml:space="preserve">
          <source>Violations of constraints are detected at compile time, early in the template instantiation process, which leads to easy to follow error messages.</source>
          <target state="translated">Las violaciones de las restricciones se detectan en el momento de la compilación,al principio del proceso de instanciación de la plantilla,lo que da lugar a mensajes de error fáciles de seguir.</target>
        </trans-unit>
        <trans-unit id="9b18a97a2fd2836708868d06e1ce4ef84d86615c" translate="yes" xml:space="preserve">
          <source>Virtual and pure virtual functions</source>
          <target state="translated">Funciones virtuales y puramente virtuales</target>
        </trans-unit>
        <trans-unit id="f68e04bd9e3e62f1affa5f5cd95daed9e7141704" translate="yes" xml:space="preserve">
          <source>Virtual base classes</source>
          <target state="translated">Clases de la base virtual</target>
        </trans-unit>
        <trans-unit id="bb2875a5baa367827268a607eb3795f455c6012e" translate="yes" xml:space="preserve">
          <source>Virtual destructor</source>
          <target state="translated">Virtual Destroyer</target>
        </trans-unit>
        <trans-unit id="5066038f5f1b55b5a2bc0bc13c582fae42181817" translate="yes" xml:space="preserve">
          <source>Virtual destructors</source>
          <target state="translated">Virtual Destructors</target>
        </trans-unit>
        <trans-unit id="f6fe3c659ed8077db8d0b5920aa4b5764bff62d6" translate="yes" xml:space="preserve">
          <source>Virtual functions (whether declared virtual or overriding one) cannot have any associated constraints.</source>
          <target state="translated">Las funciones virtuales (ya sean declaradas virtuales o anulables)no pueden tener ninguna restricción asociada.</target>
        </trans-unit>
        <trans-unit id="7f5fcb0f75cbb4813db427832ef8357c8c51c72a" translate="yes" xml:space="preserve">
          <source>Virtual functions are member functions whose behavior can be overridden in derived classes. As opposed to non-virtual functions, the overridden behavior is preserved even if there is no compile-time information about the actual type of the class. If a derived class is handled using pointer or reference to the base class, a call to an overridden virtual function would invoke the behavior defined in the derived class. This behavior is suppressed if the function is selected using &lt;a href=&quot;lookup&quot;&gt;qualified name lookup&lt;/a&gt; (that is, if the function's name appears to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt;).</source>
          <target state="translated">Las funciones virtuales son funciones miembro cuyo comportamiento se puede anular en clases derivadas. A diferencia de las funciones no virtuales, el comportamiento anulado se conserva incluso si no hay informaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n sobre el tipo real de la clase. Si una clase derivada se maneja utilizando un puntero o una referencia a la clase base, una llamada a una funci&amp;oacute;n virtual anulada invocar&amp;iacute;a el comportamiento definido en la clase derivada. Este comportamiento se suprime si la funci&amp;oacute;n se selecciona mediante la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda de nombre calificado&lt;/a&gt; (es decir, si el nombre de la funci&amp;oacute;n aparece a la derecha del operador de resoluci&amp;oacute;n de alcance &lt;code&gt;::&lt;/code&gt; ) .</target>
        </trans-unit>
        <trans-unit id="d022c012c3444ee6f002dccdfcd5905c70efa42e" translate="yes" xml:space="preserve">
          <source>Visible side-effects</source>
          <target state="translated">Efectos secundarios visibles</target>
        </trans-unit>
        <trans-unit id="30c3d8194815052f5f9f54a1fac519295b84ad3f" translate="yes" xml:space="preserve">
          <source>Visual Studio 2010</source>
          <target state="translated">Visual Studio 2010</target>
        </trans-unit>
        <trans-unit id="a50605af7e7015b16739f3db40248d1a64076a37" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 Inline Assembler</source>
          <target state="translated">Ensamblador en línea de Visual Studio 2013</target>
        </trans-unit>
        <trans-unit id="359a03f62e49986ef991446210499529db3fc418" translate="yes" xml:space="preserve">
          <source>Void expressions</source>
          <target state="translated">Expresiones de vacío</target>
        </trans-unit>
        <trans-unit id="f135b48d956f6ca097c1656d0a1863579947c9fb" translate="yes" xml:space="preserve">
          <source>Void expressions have no</source>
          <target state="translated">Las expresiones de vacío no tienen</target>
        </trans-unit>
        <trans-unit id="e8f5359cab08d3573121923f7436c0f33fc92629" translate="yes" xml:space="preserve">
          <source>Void type</source>
          <target state="translated">Tipo de vacío</target>
        </trans-unit>
        <trans-unit id="e2415cb7f63df0c9de23362326ad3c37a9adfc96" translate="yes" xml:space="preserve">
          <source>W</source>
          <target state="translated">W</target>
        </trans-unit>
        <trans-unit id="c0bc38123ad63ab545d3b75627acdac77e9b79a6" translate="yes" xml:space="preserve">
          <source>WCHAR_MAX</source>
          <target state="translated">WCHAR_MAX</target>
        </trans-unit>
        <trans-unit id="04ea5fdfa0eae316269a47c7f10e8316337146a4" translate="yes" xml:space="preserve">
          <source>WCHAR_MIN</source>
          <target state="translated">WCHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c37a74a6f2d73286ec534a439a5c059b13230ec6" translate="yes" xml:space="preserve">
          <source>WEOF</source>
          <target state="translated">WEOF</target>
        </trans-unit>
        <trans-unit id="8d070188c9052ddde44bc280e3aced3c983ed8c7" translate="yes" xml:space="preserve">
          <source>WINT_MAX</source>
          <target state="translated">WINT_MAX</target>
        </trans-unit>
        <trans-unit id="cb08e31a881a0bd7697665afb678cdce175c2f59" translate="yes" xml:space="preserve">
          <source>WINT_MIN</source>
          <target state="translated">WINT_MIN</target>
        </trans-unit>
        <trans-unit id="d7d72e040861a1f86b9b248b64986ff2db87de0a" translate="yes" xml:space="preserve">
          <source>WORD JOINER - TURNED DIGIT THREE</source>
          <target state="translated">UNIFICADOR DE PALABRAS-CONVERTIDO EN EL DÍGITO TRES</target>
        </trans-unit>
        <trans-unit id="33d30632848d3fd0ed2340adbd7be3e3e8e61010" translate="yes" xml:space="preserve">
          <source>Waiting</source>
          <target state="translated">Waiting</target>
        </trans-unit>
        <trans-unit id="8c8066383629449e748934ef44df8baa244ceb3f" translate="yes" xml:space="preserve">
          <source>Waits for the result to become available. Blocks until specified &lt;code&gt;timeout_duration&lt;/code&gt; has elapsed or the result becomes available, whichever comes first. Returns value identifies the state of the result.</source>
          <target state="translated">Espera a que el resultado est&amp;eacute; disponible. Bloquea hasta que transcurra el tiempo de &lt;code&gt;timeout_duration&lt;/code&gt; especificado o el resultado est&amp;eacute; disponible, lo que ocurra primero. El valor devuelto identifica el estado del resultado.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="128348550537d17215c4e4e19183a94c6cae96fb" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; to denote the type of the expression &lt;code&gt;e&lt;/code&gt;. (In other words, &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is the equivalent of &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt;.).</source>
          <target state="translated">Usamos &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; para denotar el tipo de la expresi&amp;oacute;n &lt;code&gt;e&lt;/code&gt; . (En otras palabras, &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; es el equivalente de &lt;code&gt;&lt;a href=&quot;../types/remove_reference&quot;&gt;std::remove_reference_t&lt;/a&gt;&amp;lt;decltype((e))&amp;gt;&lt;/code&gt; .).</target>
        </trans-unit>
        <trans-unit id="ff2d0e12c8d86e48e138480e627a03522625fd5b" translate="yes" xml:space="preserve">
          <source>Weak equality</source>
          <target state="translated">Débil igualdad</target>
        </trans-unit>
        <trans-unit id="cc0eeac220c48abd1f4d8a9066580d68089b7e2a" translate="yes" xml:space="preserve">
          <source>Weak ordering</source>
          <target state="translated">Un pedido débil</target>
        </trans-unit>
        <trans-unit id="5f9aead2f88dbe4721a67660c3e46cd95c9d01ce" translate="yes" xml:space="preserve">
          <source>Weakly parallel forward progress</source>
          <target state="translated">Un progreso débilmente paralelo hacia adelante</target>
        </trans-unit>
        <trans-unit id="32d5d9f2881f15e8163749d6edac5a8dd285e442" translate="yes" xml:space="preserve">
          <source>WeaklyIncrementable</source>
          <target state="translated">WeaklyIncrementable</target>
        </trans-unit>
        <trans-unit id="f82be68a7fb4e7dec88f27463de94ad355242ee5" translate="yes" xml:space="preserve">
          <source>Week</source>
          <target state="translated">Week</target>
        </trans-unit>
        <trans-unit id="1d901e38ea200c08db624662589c69e315e01ff1" translate="yes" xml:space="preserve">
          <source>Week/day of the year</source>
          <target state="translated">Semana/día del año</target>
        </trans-unit>
        <trans-unit id="17a74d187c8a04abdcb5c0a680b6e9d660e85fba" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #1/3</source>
          <target state="translated">Lo que todo programador de C debería saber sobre el comportamiento indefinido #1/3</target>
        </trans-unit>
        <trans-unit id="8b7904dfab491b34141248cdfa81f76b99500ce8" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #2/3</source>
          <target state="translated">Lo que todo programador de C debería saber sobre el comportamiento indefinido #2/3</target>
        </trans-unit>
        <trans-unit id="faec1f8b604ae7cb007c3f28c6244f78ba75f633" translate="yes" xml:space="preserve">
          <source>What Every C Programmer Should Know About Undefined Behavior #3/3</source>
          <target state="translated">Lo que todo programador de C debería saber sobre el comportamiento indefinido #3/3</target>
        </trans-unit>
        <trans-unit id="5345ef8ed5a57eddad0fc38e73e7287b6270366c" translate="yes" xml:space="preserve">
          <source>When &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, or &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; satisfies the LegacyOutputIterator requirements in addition to its own requirements, it is described as &lt;b&gt;mutable&lt;/b&gt;.</source>
          <target state="translated">Cuando &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; o &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; satisface los requisitos de LegacyOutputIterator adem&amp;aacute;s de sus propios requisitos, se describe como &lt;b&gt;mutable&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="cc0170dca8716eb24882edf591a81dee83e562ee" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;#&lt;/code&gt; appears before &lt;code&gt;__VA_ARGS__&lt;/code&gt;, the entire expanded __VA_ARGS__ is enclosed in quotes:</source>
          <target state="translated">Cuando aparece &lt;code&gt;#&lt;/code&gt; antes de &lt;code&gt;__VA_ARGS__&lt;/code&gt; , todo el __VA_ARGS__ expandido se encierra entre comillas:</target>
        </trans-unit>
        <trans-unit id="046623a30719eaa626e9121030272ea2805083f6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is a (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, it is unspecified whether function (1) is declared.</source>
          <target state="translated">Cuando &lt;code&gt;T&lt;/code&gt; es un &lt;code&gt;void&lt;/code&gt; (posiblemente calificado por cv) , no se especifica si se declara la funci&amp;oacute;n (1).</target>
        </trans-unit>
        <trans-unit id="bf6dcc3dc3f6b7e5ebe9923c510cc70615782d54" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is an array type, it is unspecified whether these member functions are declared, and if they are, what their return type is, except that the declaration (not necessarily the definition) of these functions is well-formed.</source>
          <target state="translated">Cuando &lt;code&gt;T&lt;/code&gt; es un tipo de matriz, no se especifica si estas funciones miembro se declaran, y si lo son, cu&amp;aacute;l es su tipo de retorno, excepto que la declaraci&amp;oacute;n (no necesariamente la definici&amp;oacute;n) de estas funciones est&amp;aacute; bien formada.</target>
        </trans-unit>
        <trans-unit id="97a2afc24ba5f22063e77c7d297d40d35897008d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, it is unspecified whether this function is declared. If the function is declared, it is unspecified what its return type is, except that the declaration (although not necessarily the definition) of the function is guaranteed to be legal.</source>
          <target state="translated">Cuando &lt;code&gt;T&lt;/code&gt; no es un tipo de matriz, no se especifica si esta funci&amp;oacute;n se declara. Si se declara la funci&amp;oacute;n, no se especifica cu&amp;aacute;l es su tipo de retorno, excepto que se garantiza que la declaraci&amp;oacute;n (aunque no necesariamente la definici&amp;oacute;n) de la funci&amp;oacute;n es legal.</target>
        </trans-unit>
        <trans-unit id="841913a7a092250d0d74debefdc20a6387cf98d1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;T&lt;/code&gt; is not an array type, the overloads (3), (4), and (6) enable &lt;code&gt;shared_from_this&lt;/code&gt; with &lt;code&gt;ptr&lt;/code&gt;, and the overload (13) enables &lt;code&gt;shared_from_this&lt;/code&gt; with the pointer returned by &lt;code&gt;r.release()&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;T&lt;/code&gt; no es un tipo de matriz, las sobrecargas (3), (4) y (6) habilitan &lt;code&gt;shared_from_this&lt;/code&gt; con &lt;code&gt;ptr&lt;/code&gt; , y la sobrecarga (13) habilita &lt;code&gt;shared_from_this&lt;/code&gt; con el puntero devuelto por &lt;code&gt;r.release()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="933697ca9b43c7b723b629859ce79b9ed2a3265c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt;, the following properties are guaranteed:</source>
          <target state="translated">Cuando &lt;code&gt;isfinite(a) &amp;amp;&amp;amp; isfinite(b)&lt;/code&gt; , se garantizan las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="57eacd6a7d9600dd8cd2e42c3f2ae19d11ad628e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;shared_ptr&lt;/code&gt; is created by calling &lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt;, the memory for both the control block and the managed object is created with a single allocation. The managed object is constructed in-place in a data member of the control block. When &lt;code&gt;shared_ptr&lt;/code&gt; is created via one of the &lt;code&gt;shared_ptr&lt;/code&gt; constructors, the managed object and the control block must be allocated separately. In this case, the control block stores a pointer to the managed object.</source>
          <target state="translated">Cuando &lt;code&gt;shared_ptr&lt;/code&gt; se crea llamando a &lt;code&gt;&lt;a href=&quot;shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;shared_ptr/allocate_shared&quot;&gt;std::allocate_shared&lt;/a&gt;&lt;/code&gt; , la memoria tanto para el bloque de control como para el objeto gestionado se crea con una &amp;uacute;nica asignaci&amp;oacute;n. El objeto gestionado se construye in situ en un miembro de datos del bloque de control. Cuando &lt;code&gt;shared_ptr&lt;/code&gt; se crea a trav&amp;eacute;s de uno de los constructores &lt;code&gt;shared_ptr&lt;/code&gt; , el objeto administrado y el bloque de control deben asignarse por separado. En este caso, el bloque de control almacena un puntero al objeto gestionado.</target>
        </trans-unit>
        <trans-unit id="4833d1b8e7740b741eed936468b06c1d2f60499d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;t&lt;/code&gt; is a &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;forwarding reference&lt;/a&gt; (a function argument that is declared as an rvalue reference to a cv-unqualified function template parameter), this overload forwards the argument to another function with the &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; it had when passed to the calling function.</source>
          <target state="translated">Cuando &lt;code&gt;t&lt;/code&gt; es una &lt;a href=&quot;../language/reference#Forwarding_references&quot;&gt;referencia de reenv&amp;iacute;o&lt;/a&gt; (un argumento de funci&amp;oacute;n que se declara como una referencia de valor a un par&amp;aacute;metro de plantilla de funci&amp;oacute;n no calificada por cv), esta sobrecarga reenv&amp;iacute;a el argumento a otra funci&amp;oacute;n con la &lt;a href=&quot;../language/value_category&quot;&gt;categor&amp;iacute;a de valor&lt;/a&gt; que ten&amp;iacute;a cuando se pas&amp;oacute; a la funci&amp;oacute;n de llamada.</target>
        </trans-unit>
        <trans-unit id="f05559f6187d0eff998ef174b497dd5f9e035c58" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;lock_guard&lt;/code&gt; object is created, it attempts to take ownership of the mutex it is given. When control leaves the scope in which the &lt;code&gt;lock_guard&lt;/code&gt; object was created, the &lt;code&gt;lock_guard&lt;/code&gt; is destructed and the mutex is released.</source>
          <target state="translated">Cuando se crea un objeto &lt;code&gt;lock_guard&lt;/code&gt; , intenta tomar posesi&amp;oacute;n del mutex que se le da. Cuando el control abandona el &amp;aacute;mbito en el que se cre&amp;oacute; el objeto &lt;code&gt;lock_guard&lt;/code&gt; , el &lt;code&gt;lock_guard&lt;/code&gt; se destruye y se libera el mutex.</target>
        </trans-unit>
        <trans-unit id="e69de8ba0616baddc63eba743d4447e24a787005" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;scoped_lock&lt;/code&gt; object is created, it attempts to take ownership of the mutexes it is given. When control leaves the scope in which the &lt;code&gt;scoped_lock&lt;/code&gt; object was created, the &lt;code&gt;scoped_lock&lt;/code&gt; is destructed and the mutexes are released, in reverse order. If several mutexes are given, deadlock avoidance algorithm is used as if by &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando se &lt;code&gt;scoped_lock&lt;/code&gt; un objeto scoped_lock , intenta tomar posesi&amp;oacute;n de los mutexes que se le dan. Cuando el control abandona el &amp;aacute;mbito en el que se cre&amp;oacute; el objeto &lt;code&gt;scoped_lock&lt;/code&gt; , el &lt;code&gt;scoped_lock&lt;/code&gt; se destruye y se liberan los mutexes, en orden inverso. Si se proporcionan varios mutexes, el algoritmo de evitaci&amp;oacute;n de punto muerto se usa como si fuera &lt;code&gt;&lt;a href=&quot;lock&quot;&gt;std::lock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="303d35d938cb833eac9338017dabe149a1c1712f" translate="yes" xml:space="preserve">
          <source>When a base class is intended for polymorphic use, its destructor may have to be declared public and virtual. This blocks implicit moves (and deprecates implicit copies), and so the special member functions have to be declared as defaulted&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Cuando una clase base est&amp;aacute; destinada para uso polim&amp;oacute;rfico, su destructor puede tener que ser declarado p&amp;uacute;blico y virtual. Esto bloquea los movimientos impl&amp;iacute;citos (y desprecia las copias impl&amp;iacute;citas), por lo que las funciones miembro especiales deben declararse como predeterminadas &lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;rule_of_three#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="a38cdff86c855a9f5b8dafef92329da17987f83a" translate="yes" xml:space="preserve">
          <source>When a block declaration appears &lt;a href=&quot;statements#Compound_statements&quot;&gt;inside a block&lt;/a&gt;, and an identifier introduced by a declaration was previously declared in an outer block, the &lt;a href=&quot;scope&quot;&gt;outer declaration is hidden&lt;/a&gt; for the remainder of the block.</source>
          <target state="translated">Cuando una declaraci&amp;oacute;n de bloque aparece &lt;a href=&quot;statements#Compound_statements&quot;&gt;dentro de un bloque&lt;/a&gt; , y un identificador introducido por una declaraci&amp;oacute;n se declar&amp;oacute; previamente en un bloque externo, la &lt;a href=&quot;scope&quot;&gt;declaraci&amp;oacute;n externa se oculta&lt;/a&gt; por el resto del bloque.</target>
        </trans-unit>
        <trans-unit id="da9117b375eefc957e65150185d8008bdc45763a" translate="yes" xml:space="preserve">
          <source>When a class or variable(since C++14) template is instantiated, and there are partial specializations available, the compiler has to decide if the primary template is going to be used or one of its partial specializations.</source>
          <target state="translated">Cuando una plantilla de clase o variable (desde C++14)es instanciada,y hay especializaciones parciales disponibles,el compilador tiene que decidir si se va a utilizar la plantilla primaria o una de sus especializaciones parciales.</target>
        </trans-unit>
        <trans-unit id="fea65df3178fced8b0ade7c9ce2a6ba4bc611c76" translate="yes" xml:space="preserve">
          <source>When a class template specialization is referenced in context that requires a complete object type, or when a function template specialization is referenced in context that requires a function definition to exist, the template is</source>
          <target state="translated">Cuando se hace referencia a una especialización de plantilla de clase en un contexto que requiere un tipo de objeto completo,o cuando se hace referencia a una especialización de plantilla de función en un contexto que requiere una definición de función para existir,la plantilla es</target>
        </trans-unit>
        <trans-unit id="5769c7acaf1d2335b2ca90b0ec55efa0d236a336" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;private&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as private members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">Cuando una clase usa &lt;code&gt;private&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;especificador de acceso de miembro &lt;/a&gt;privado para derivar de una base, todos los miembros p&amp;uacute;blicos y protegidos de la clase base son accesibles como miembros privados de la clase derivada (los miembros privados de la base nunca son accesibles a menos que sean amigos).</target>
        </trans-unit>
        <trans-unit id="2fcd782f662cbfb240e5bd78fca278b024889cc7" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;protected&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public and protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">Cuando una clase usa un &lt;a href=&quot;access&quot;&gt;especificador de acceso de miembro &lt;/a&gt; &lt;code&gt;protected&lt;/code&gt; para derivar de una base, todos los miembros p&amp;uacute;blicos y protegidos de la clase base son accesibles como miembros protegidos de la clase derivada (los miembros privados de la base nunca son accesibles a menos que sean amigos).</target>
        </trans-unit>
        <trans-unit id="774bfe4108db2bde44499cb4a6ab68ddca8b923c" translate="yes" xml:space="preserve">
          <source>When a class uses &lt;code&gt;public&lt;/code&gt;&lt;a href=&quot;access&quot;&gt;member access specifier&lt;/a&gt; to derive from a base, all public members of the base class are accessible as public members of the derived class and all protected members of the base class are accessible as protected members of the derived class (private members of the base are never accessible unless friended).</source>
          <target state="translated">Cuando una clase utiliza &lt;code&gt;public&lt;/code&gt; &lt;a href=&quot;access&quot;&gt;especificador de acceso de miembro &lt;/a&gt;p&amp;uacute;blico para derivar de una base, todos los miembros p&amp;uacute;blicos de la clase base son accesibles como miembros p&amp;uacute;blicos de la clase derivada y todos los miembros protegidos de la clase base son accesibles como miembros protegidos de la clase derivada (miembros privados de la base nunca son accesibles a menos que sean amigos).</target>
        </trans-unit>
        <trans-unit id="731c55e17d6e6e68ab60a46f9b70a72e60e6dd67" translate="yes" xml:space="preserve">
          <source>When a complete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">Cuando se necesita vaciar una l&amp;iacute;nea completa de salida, se puede &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; manipulador std :: endl .</target>
        </trans-unit>
        <trans-unit id="c302c1bc7c6fed86bcea489bc973092937f86e79" translate="yes" xml:space="preserve">
          <source>When a coroutine begins execution, it performs the following:</source>
          <target state="translated">Cuando una corutina comienza la ejecución,realiza lo siguiente:</target>
        </trans-unit>
        <trans-unit id="f150d08af5c8d72aecd740bc32ce2f1f91de3c2d" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches a suspension point.</source>
          <target state="translated">Cuando una corutina alcanza un punto de suspensión.</target>
        </trans-unit>
        <trans-unit id="0c56a2828a8dc079acafa0f6578250d1ca9ad491" translate="yes" xml:space="preserve">
          <source>When a coroutine reaches the &lt;code&gt;co_return&lt;/code&gt; statement, it performs the following:</source>
          <target state="translated">Cuando una rutina llega a la instrucci&amp;oacute;n &lt;code&gt;co_return&lt;/code&gt; , realiza lo siguiente:</target>
        </trans-unit>
        <trans-unit id="cf467bf3385d5e1232a7b50fd987d1bda1eb5b07" translate="yes" xml:space="preserve">
          <source>When a feature changes significantly, the macro will be updated accordingly.</source>
          <target state="translated">Cuando una característica cambia significativamente,la macro se actualizará en consecuencia.</target>
        </trans-unit>
        <trans-unit id="a1204ab37d3f0482e454433db039fd14f2d10599" translate="yes" xml:space="preserve">
          <source>When a file is included, it is processed by &lt;a href=&quot;../language/translation_phases&quot;&gt;translation phases&lt;/a&gt; 1-4, which may include, recursively, expansion of the nested &lt;code&gt;#include&lt;/code&gt; directives. To avoid repeated inclusion of the same file and endless recursion when a file includes itself, perhaps transitively,</source>
          <target state="translated">Cuando se incluye un archivo, se procesa mediante las &lt;a href=&quot;../language/translation_phases&quot;&gt;fases de traducci&amp;oacute;n&lt;/a&gt; 1-4, que pueden incluir, de forma recursiva, la expansi&amp;oacute;n de las directivas &lt;code&gt;#include&lt;/code&gt; anidadas . Para evitar la inclusi&amp;oacute;n repetida del mismo archivo y la recursi&amp;oacute;n sin fin cuando un archivo se incluye a s&amp;iacute; mismo, tal vez de forma transitiva,</target>
        </trans-unit>
        <trans-unit id="0f6ee751ce2ae6f2e1fe4fc82e2efbe71ee15f4f" translate="yes" xml:space="preserve">
          <source>When a friend declaration refers to a full specialization of a function template, the keyword &lt;code&gt;inline&lt;/code&gt; and default arguments cannot be used.</source>
          <target state="translated">Cuando una declaraci&amp;oacute;n de amigo se refiere a una especializaci&amp;oacute;n completa de una plantilla de funci&amp;oacute;n, la palabra clave en &lt;code&gt;inline&lt;/code&gt; y los argumentos predeterminados no se pueden usar.</target>
        </trans-unit>
        <trans-unit id="dd03b884a832ad273a2adbacad6fb75f476bfdf0" translate="yes" xml:space="preserve">
          <source>When a function is invoked, e.g. in a &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;function-call expression&lt;/a&gt;, the parameters are initialized from the arguments (either provided at the place of call or &lt;a href=&quot;default_arguments&quot;&gt;defaulted&lt;/a&gt;) and the statements in the function body are executed.</source>
          <target state="translated">Cuando se invoca una funci&amp;oacute;n, por ejemplo, en una &lt;a href=&quot;operator_other#Built-in_function_call_operator&quot;&gt;expresi&amp;oacute;n de llamada a funci&amp;oacute;n&lt;/a&gt; , los par&amp;aacute;metros se inicializan a partir de los argumentos (proporcionados en el lugar de la llamada o &lt;a href=&quot;default_arguments&quot;&gt;predeterminados&lt;/a&gt; ) y se ejecutan las declaraciones en el cuerpo de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="056da6db0024a8fc9e2178af3caa77a54e3aa303" translate="yes" xml:space="preserve">
          <source>When a function's return type is lvalue reference, the function call expression becomes an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt;:</source>
          <target state="translated">Cuando el tipo de retorno de una funci&amp;oacute;n es referencia de valor, la expresi&amp;oacute;n de llamada de funci&amp;oacute;n se convierte en una &lt;a href=&quot;value_category&quot;&gt;expresi&amp;oacute;n de valor&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="4616bf2b5d98e8563f41341866c844e7ac6e8d1f" translate="yes" xml:space="preserve">
          <source>When a function-style cast or declaration of a variable uses the name of a primary class template &lt;code&gt;C&lt;/code&gt; without an argument list as the type specifier, deduction will proceed as follows:</source>
          <target state="translated">Cuando una conversi&amp;oacute;n o declaraci&amp;oacute;n de estilo de funci&amp;oacute;n de una variable usa el nombre de una plantilla de clase primaria &lt;code&gt;C&lt;/code&gt; sin una lista de argumentos como el especificador de tipo, la deducci&amp;oacute;n proceder&amp;aacute; de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="703e91dee14a5d41272ff0618515064124c5ca74" translate="yes" xml:space="preserve">
          <source>When a lambda captures a member using implicit by-copy capture, it does not make a copy of that member variable: the use of a member variable &lt;code&gt;m&lt;/code&gt; is treated as an expression &lt;code&gt;(*this).m&lt;/code&gt;, and &lt;code&gt;*this&lt;/code&gt; is always implicitly captured by reference:</source>
          <target state="translated">Cuando una lambda captura a un miembro usando la captura impl&amp;iacute;cita por copia, no hace una copia de esa variable miembro: el uso de una variable miembro &lt;code&gt;m&lt;/code&gt; se trata como una expresi&amp;oacute;n &lt;code&gt;(*this).m&lt;/code&gt; , y &lt;code&gt;*this&lt;/code&gt; siempre se captura impl&amp;iacute;citamente por referencia:</target>
        </trans-unit>
        <trans-unit id="3ea6ad3dcd073f66ca30ba43dbc0f20952f4603c" translate="yes" xml:space="preserve">
          <source>When a local class declares an unqualified function or class as a friend, only functions and classes in the innermost non-class scope are &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt;, not the global functions:</source>
          <target state="translated">Cuando una clase local declara una funci&amp;oacute;n no calificado o clase como un amigo, s&amp;oacute;lo las funciones y clases en el &amp;aacute;mbito no-clase m&amp;aacute;s interna se &lt;a href=&quot;lookup&quot;&gt;levant&amp;oacute; la vista&lt;/a&gt; , no las funciones globales:</target>
        </trans-unit>
        <trans-unit id="8b46570618f5daf88923faf7d12da8873e3be80a" translate="yes" xml:space="preserve">
          <source>When a member is redeclared within the same class, it must do so under the same member access:</source>
          <target state="translated">Cuando un miembro es redeclarado dentro de la misma clase,debe hacerlo bajo el mismo acceso de miembro:</target>
        </trans-unit>
        <trans-unit id="f224ac0d371f052e58a2217d4de98b1976737b0e" translate="yes" xml:space="preserve">
          <source>When a non-static class member is used in any of the contexts where the &lt;code&gt;this&lt;/code&gt; keyword is allowed (non-static member function bodies, member initializer lists, default member initializers), the implicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; is automatically added before the name, resulting in a member access expression (which, if the member is a virtual member function, results in a virtual function call).</source>
          <target state="translated">Cuando se usa un miembro de clase no est&amp;aacute;tico en cualquiera de los contextos donde se permite &lt;code&gt;this&lt;/code&gt; palabra clave (cuerpos de funci&amp;oacute;n de miembro no est&amp;aacute;tico, listas de inicializador de miembro, inicializadores de miembro predeterminados), el impl&amp;iacute;cito &lt;code&gt;this-&amp;gt;&lt;/code&gt; se agrega autom&amp;aacute;ticamente antes del nombre, lo que resulta en una expresi&amp;oacute;n de acceso de miembro (que, si el miembro es una funci&amp;oacute;n de miembro virtual, da como resultado una llamada de funci&amp;oacute;n virtual).</target>
        </trans-unit>
        <trans-unit id="c996fe1da1454bb286aadf030b85cfad7cae8fed" translate="yes" xml:space="preserve">
          <source>When a pointer to a protected member is formed, it must use a derived class in its declaration:</source>
          <target state="translated">Cuando se forma un puntero a un miembro protegido,debe utilizar una clase derivada en su declaración:</target>
        </trans-unit>
        <trans-unit id="7fe22ece7b8d4604836b61b68f07304156388fd8" translate="yes" xml:space="preserve">
          <source>When a qualified name is used as a &lt;a href=&quot;declarations&quot;&gt;declarator&lt;/a&gt;, then &lt;a href=&quot;unqualified_lookup&quot;&gt;unqualified lookup&lt;/a&gt; of the names used in the same declarator that follow that qualified name, but not the names that precede it, is performed in the scope of the member's class or namespace:</source>
          <target state="translated">Cuando se utiliza un nombre calificado como &lt;a href=&quot;declarations&quot;&gt;declarador&lt;/a&gt; , la &lt;a href=&quot;unqualified_lookup&quot;&gt;b&amp;uacute;squeda no calificada&lt;/a&gt; de los nombres utilizados en el mismo declarante que sigue a ese nombre calificado, pero no los nombres que le preceden, se realiza en el &amp;aacute;mbito de la clase o espacio de nombres del miembro:</target>
        </trans-unit>
        <trans-unit id="7128500ddb4a19baad89fa94da4a6a51b2aa2144" translate="yes" xml:space="preserve">
          <source>When a signaling NaN is used as an argument to an arithmetic expression, the appropriate floating-point exception may be raised and the NaN is &quot;quieted&quot;, that is, the expression returns a quiet NaN.</source>
          <target state="translated">Cuando se utiliza una señal de NaN como argumento de una expresión aritmética,se puede plantear la excepción apropiada de punto flotante y el NaN se &quot;calla&quot;,es decir,la expresión devuelve un NaN calmo.</target>
        </trans-unit>
        <trans-unit id="7f3acde83607f5ff6b438f0d494f026c16dc4d51" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;mutex&lt;/code&gt;.</source>
          <target state="translated">Cuando un hilo posee un &lt;code&gt;mutex&lt;/code&gt; , todos los otros hilos se bloquear&amp;aacute;n (para que las llamadas se &lt;a href=&quot;mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; ) o recibir&amp;aacute;n un valor de retorno &lt;code&gt;false&lt;/code&gt; (para &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; ) si intentan reclamar la propiedad del &lt;code&gt;mutex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48235a61557c038c024774d3984da66f889dd511" translate="yes" xml:space="preserve">
          <source>When a thread owns a &lt;code&gt;recursive_mutex&lt;/code&gt;, all other threads will block (for calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt;) or receive a &lt;code&gt;false&lt;/code&gt; return value (for &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;) if they attempt to claim ownership of the &lt;code&gt;recursive_mutex&lt;/code&gt;.</source>
          <target state="translated">Cuando un hilo posee un &lt;code&gt;recursive_mutex&lt;/code&gt; , todos los otros hilos se bloquear&amp;aacute;n (para que las llamadas se &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; ) o recibir&amp;aacute;n un valor de retorno &lt;code&gt;false&lt;/code&gt; (para &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; ) si intentan reclamar la propiedad del &lt;code&gt;recursive_mutex&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78d07a1734d460127f218d90a8985eff2cc5268d" translate="yes" xml:space="preserve">
          <source>When a thread reads a value from a memory location, it may see the initial value, the value written in the same thread, or the value written in another thread. See &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; for details on the order in which writes made from threads become visible to other threads.</source>
          <target state="translated">Cuando un hilo lee un valor de una ubicaci&amp;oacute;n de memoria, puede ver el valor inicial, el valor escrito en el mismo hilo o el valor escrito en otro hilo. Consulte &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; para obtener detalles sobre el orden en que las escrituras hechas desde hilos se vuelven visibles para otros hilos.</target>
        </trans-unit>
        <trans-unit id="35914adcda38d9bc606dedbc8e87f226f4c33d60" translate="yes" xml:space="preserve">
          <source>When a unary fold is used with a pack expansion of length zero, only the following operators are allowed:</source>
          <target state="translated">Cuando se utiliza un pliegue unario con una expansión del paquete de longitud cero,sólo se permiten los siguientes operadores:</target>
        </trans-unit>
        <trans-unit id="a5725eb8b03373883cd17dd14b578f1aefe9ae18" translate="yes" xml:space="preserve">
          <source>When a union is initialized by aggregate initialization, only its first non-static data member is initialized.</source>
          <target state="translated">Cuando una unión se inicializa mediante la inicialización agregada,sólo se inicializa su primer miembro de datos no estáticos.</target>
        </trans-unit>
        <trans-unit id="75156726fb61b37daeae849a8c23a8d3e99ac431" translate="yes" xml:space="preserve">
          <source>When a user-defined class overloads the function call operator, &lt;code&gt;operator()&lt;/code&gt;, it becomes a &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; type. Many standard algorithms, from &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; accept objects of such types to customize behavior. There are no particularly notable canonical forms of &lt;code&gt;operator()&lt;/code&gt;, but to illustrate the usage.</source>
          <target state="translated">Cuando una clase definida por el usuario sobrecarga el operador de llamada de funci&amp;oacute;n, &lt;code&gt;operator()&lt;/code&gt; , se convierte en un tipo &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; . Muchos algoritmos est&amp;aacute;ndar, desde &lt;code&gt;&lt;a href=&quot;../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; a &lt;code&gt;&lt;a href=&quot;../algorithm/accumulate&quot;&gt;std::accumulate&lt;/a&gt;&lt;/code&gt; aceptan objetos de este tipo para personalizar el comportamiento. No hay formas can&amp;oacute;nicas particularmente notables de &lt;code&gt;operator()&lt;/code&gt; , sino ilustrar el uso.</target>
        </trans-unit>
        <trans-unit id="48f53b62820f7fe3746951152075f1cdb1ddd004" translate="yes" xml:space="preserve">
          <source>When a variadic function is called, after lvalue-to-rvalue, array-to-pointer, and function-to-pointer &lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;conversions&lt;/a&gt;, each argument that is a part of the variable argument list undergoes additional conversions known as</source>
          <target state="translated">Cuando una funci&amp;oacute;n variadic se llama, despu&amp;eacute;s de lvalue-a-rvalue, array-a-puntero, y la funci&amp;oacute;n-a-puntero &lt;a href=&quot;implicit_cast#Lvalue_transformations&quot;&gt;conversiones&lt;/a&gt; , cada argumento de que es una parte de la lista de argumentos variable se somete a conversiones adicionales conocidos como</target>
        </trans-unit>
        <trans-unit id="4fc2bc7f5954311ab6cd53cf773a77f33b1fad76" translate="yes" xml:space="preserve">
          <source>When a virtual function call is made, the type returned by the final overrider is &lt;a href=&quot;implicit_cast&quot;&gt;implicitly converted&lt;/a&gt; to the return type of the overridden function that was called:</source>
          <target state="translated">Cuando se realiza una llamada a una funci&amp;oacute;n virtual, el tipo devuelto por la anulaci&amp;oacute;n final se &lt;a href=&quot;implicit_cast&quot;&gt;convierte impl&amp;iacute;citamente&lt;/a&gt; en el tipo de retorno de la funci&amp;oacute;n anulada que se llam&amp;oacute;:</target>
        </trans-unit>
        <trans-unit id="93489141e89c6d227a8966329ac45e5e0c099d81" translate="yes" xml:space="preserve">
          <source>When a virtual function is called directly or indirectly from a constructor or from a destructor (including during the construction or destruction of the class&amp;rsquo;s non-static data members, e.g. in a member &lt;a href=&quot;constructor&quot;&gt;initializer list&lt;/a&gt;), and the object to which the call applies is the object under construction or destruction, the function called is the final overrider in the constructor&amp;rsquo;s or destructor&amp;rsquo;s class and not one overriding it in a more-derived class. In other words, during construction or destruction, the more-derived classes do not exist.</source>
          <target state="translated">Cuando una funci&amp;oacute;n virtual se llama directa o indirectamente desde un constructor o desde un destructor (incluso durante la construcci&amp;oacute;n o destrucci&amp;oacute;n de los miembros de datos no est&amp;aacute;ticos de la clase, por ejemplo, en una &lt;a href=&quot;constructor&quot;&gt;lista de inicializador de&lt;/a&gt; miembros ), y el objeto al que se aplica la llamada es el objeto en construcci&amp;oacute;n o destrucci&amp;oacute;n, la funci&amp;oacute;n llamada es la anulaci&amp;oacute;n final en la clase del constructor o destructor y no una anulaci&amp;oacute;n en una clase m&amp;aacute;s derivada. En otras palabras, durante la construcci&amp;oacute;n o destrucci&amp;oacute;n, las clases m&amp;aacute;s derivadas no existen.</target>
        </trans-unit>
        <trans-unit id="c93bab45e9c1d0dfc9ec2e952c16e1c1852bb4fb" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include padding bits,(until C++20) trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">Cuando una comparaci&amp;oacute;n e intercambio d&amp;eacute;bil requerir&amp;iacute;a un bucle y uno fuerte no, el preferible es preferible a menos que la representaci&amp;oacute;n del objeto de &lt;code&gt;T&lt;/code&gt; pueda incluir bits de relleno, (hasta C ++ 20) bits de trampa u ofrezca m&amp;uacute;ltiples representaciones de objetos para el mismo valor (por ejemplo, NaN de punto flotante). En esos casos, la comparaci&amp;oacute;n e intercambio d&amp;eacute;biles generalmente funciona porque converge r&amp;aacute;pidamente en alguna representaci&amp;oacute;n estable de objetos.</target>
        </trans-unit>
        <trans-unit id="b549d145a45bd55485a97603e36455b405b7f9e4" translate="yes" xml:space="preserve">
          <source>When a weak compare-and-exchange would require a loop and a strong one would not, the strong one is preferable unless the object representation of &lt;code&gt;T&lt;/code&gt; may include trap bits, or offers multiple object representations for the same value (e.g. floating-point NaN). In those cases, weak compare-and-exchange typically works because it quickly converges on some stable object representation.</source>
          <target state="translated">Cuando una comparaci&amp;oacute;n e intercambio d&amp;eacute;bil requerir&amp;iacute;a un bucle y una fuerte no, la preferible es preferible a menos que la representaci&amp;oacute;n del objeto de &lt;code&gt;T&lt;/code&gt; pueda incluir bits de trampa, u ofrezca m&amp;uacute;ltiples representaciones de objetos para el mismo valor (por ejemplo, NaN de punto flotante ) En esos casos, la comparaci&amp;oacute;n e intercambio d&amp;eacute;biles generalmente funciona porque converge r&amp;aacute;pidamente en alguna representaci&amp;oacute;n estable de objetos.</target>
        </trans-unit>
        <trans-unit id="3267a8eb3fe0cea3cd97459c2f9b3b8e6692761b" translate="yes" xml:space="preserve">
          <source>When active member of a union is switched by an assignment expression of the form &lt;code&gt;E1 = E2&lt;/code&gt; that uses either the built-in assignment operator or a trivial assignment operator, for each union member X that appears in the member access and array subscript subexpressions of &lt;code&gt;E1&lt;/code&gt; that is not a class with non-trivial or deleted default constructors, if modification of X would have undefined behavior under type aliasing rules, an object of the type of X is implicitly created in the nominated storage; no initialization is performed and the beginning of its lifetime is sequenced after the value computation of the left and right operands and before the assignment.</source>
          <target state="translated">Cuando el miembro activo de una uni&amp;oacute;n se cambia por una expresi&amp;oacute;n de asignaci&amp;oacute;n de la forma &lt;code&gt;E1 = E2&lt;/code&gt; que utiliza el operador de asignaci&amp;oacute;n incorporado o un operador de asignaci&amp;oacute;n trivial, para cada miembro de uni&amp;oacute;n X que aparece en las subexpresiones de sub&amp;iacute;ndice de acceso y matriz de &lt;code&gt;E1&lt;/code&gt; esa no es una clase con constructores predeterminados no triviales o eliminados, si la modificaci&amp;oacute;n de X tendr&amp;iacute;a un comportamiento indefinido bajo las reglas de alias de tipo, un objeto del tipo de X se crea impl&amp;iacute;citamente en el almacenamiento designado; no se realiza la inicializaci&amp;oacute;n y el comienzo de su vida &amp;uacute;til se secuencia despu&amp;eacute;s del c&amp;aacute;lculo del valor de los operandos izquierdo y derecho y antes de la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d56d5c0d1a9783bd328d5ceefac5e3f1fa5681a7" translate="yes" xml:space="preserve">
          <source>When all template arguments have been specified, deduced or obtained from default template arguments, every use of a template parameter in the function parameter list is replaced with the corresponding template arguments.</source>
          <target state="translated">Cuando todos los argumentos de la plantilla se han especificado,deducido u obtenido a partir de los argumentos de la plantilla por defecto,cada uso de un parámetro de la plantilla en la lista de parámetros de la función se sustituye por los correspondientes argumentos de la plantilla.</target>
        </trans-unit>
        <trans-unit id="b6e6698c4323b10a60e0746ae78192f4bab23b17" translate="yes" xml:space="preserve">
          <source>When allocating an object whose alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; or an array of such objects, the new-expression passes the alignment requirement (wrapped in &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) as the second argument for the allocation function (for placement forms, &lt;code&gt;placement_params&lt;/code&gt; appear after the alignment, as the third, fourth, etc arguments). If overload resolution fails (which happens when a class-specific allocation function is defined with a different signature, since it hides the globals), overload resolution is attempted a second time, without alignment in the argument list. This allows alignment-unaware class-specific allocation functions to take precedence over the global alignment-aware allocation functions.</source>
          <target state="translated">Al asignar un objeto cuyo requisito de alineaci&amp;oacute;n excede &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; o una matriz de tales objetos, la nueva expresi&amp;oacute;n pasa el requisito de alineaci&amp;oacute;n (envuelto en &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; ) como el segundo argumento para la funci&amp;oacute;n de asignaci&amp;oacute;n (para los formularios de &lt;code&gt;placement_params&lt;/code&gt; , los par&amp;aacute;metros de colocaci&amp;oacute;n aparecen despu&amp;eacute;s de la alineaci&amp;oacute;n , como el tercero, cuarto, etc. argumentos). Si la resoluci&amp;oacute;n de sobrecarga falla (lo que ocurre cuando una funci&amp;oacute;n de asignaci&amp;oacute;n espec&amp;iacute;fica de clase se define con una firma diferente, ya que oculta las variables globales), la resoluci&amp;oacute;n de sobrecarga se intenta por segunda vez, sin alineaci&amp;oacute;n en la lista de argumentos. Esto permite que las funciones de asignaci&amp;oacute;n espec&amp;iacute;ficas de clase que no tengan en cuenta la alineaci&amp;oacute;n tengan prioridad sobre las funciones de asignaci&amp;oacute;n que tengan en cuenta la alineaci&amp;oacute;n global.</target>
        </trans-unit>
        <trans-unit id="32f253fd06f69fca2aca9bf86ab82833c3ab166b" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution for placement forms is performed twice just as for regular forms: first, for alignment-aware function signatures, then for alignment-unaware function signatures.</source>
          <target state="translated">Al asignar objetos y matrices de objetos cuya alineaci&amp;oacute;n excede &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , la resoluci&amp;oacute;n de sobrecarga para los formularios de ubicaci&amp;oacute;n se realiza dos veces como para los formularios regulares: primero, para las firmas de funci&amp;oacute;n con reconocimiento de alineaci&amp;oacute;n, luego para las firmas de funci&amp;oacute;n sin conocimiento de alineaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fc6458ca664e9adb25872544f8c6cbc1b8d2ef56" translate="yes" xml:space="preserve">
          <source>When allocating objects and arrays of objects whose alignment exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, overload resolution is performed twice: first, for alignment-aware function signatures, then for alignment-unaware function signatures. This means that if a class with extended alignment has an alignment-unaware class-specific allocation function, it is the function that will be called, not the global alignment-aware allocation function. This is intentional: the class member is expected to know best how to handle that class.</source>
          <target state="translated">Al asignar objetos y matrices de objetos cuya alineaci&amp;oacute;n excede &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , la resoluci&amp;oacute;n de sobrecarga se realiza dos veces: primero, para firmas de funciones con reconocimiento de alineaci&amp;oacute;n, luego para firmas de funciones sin reconocimiento de alineaci&amp;oacute;n. Esto significa que si una clase con alineaci&amp;oacute;n extendida tiene una funci&amp;oacute;n de asignaci&amp;oacute;n espec&amp;iacute;fica de clase que no reconoce la alineaci&amp;oacute;n, se llamar&amp;aacute; a la funci&amp;oacute;n, no a la funci&amp;oacute;n de asignaci&amp;oacute;n que reconoce la alineaci&amp;oacute;n global. Esto es intencional: se espera que el miembro de la clase sepa mejor c&amp;oacute;mo manejar esa clase.</target>
        </trans-unit>
        <trans-unit id="dbe54944a43bccf5cf205c899d78217a14037efa" translate="yes" xml:space="preserve">
          <source>When an &lt;a href=&quot;eval_order&quot;&gt;evaluation&lt;/a&gt; of an expression writes to a memory location and another evaluation reads or modifies the same memory location, the expressions are said to</source>
          <target state="translated">Cuando una &lt;a href=&quot;eval_order&quot;&gt;evaluaci&amp;oacute;n&lt;/a&gt; de una expresi&amp;oacute;n escribe en una ubicaci&amp;oacute;n de memoria y otra evaluaci&amp;oacute;n lee o modifica la misma ubicaci&amp;oacute;n de memoria, se dice que las expresiones</target>
        </trans-unit>
        <trans-unit id="f54b782cb8a2443df3f24c71942278de560d6c94" translate="yes" xml:space="preserve">
          <source>When an exception of type &lt;code&gt;E&lt;/code&gt; is thrown by any statement in compound-statement, it is matched against the types of the formal parameters &lt;code&gt;T&lt;/code&gt; of each catch-clause in handler-seq, in the order in which the catch clauses are listed. The exception is a match if any of the following is true:</source>
          <target state="translated">Cuando una declaraci&amp;oacute;n de tipo compuesto emite una excepci&amp;oacute;n de tipo &lt;code&gt;E&lt;/code&gt; , se compara con los tipos de los par&amp;aacute;metros formales &lt;code&gt;T&lt;/code&gt; de cada cl&amp;aacute;usula catch en handler-seq, en el orden en que se enumeran las cl&amp;aacute;usulas catch. La excepci&amp;oacute;n es una coincidencia si se cumple alguna de las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="141971b19d6009b0db3fb823a2039b332a4e6a99" translate="yes" xml:space="preserve">
          <source>When an explicit instantiation names a class template specialization, it serves as an explicit instantiation of the same kind (declaration or definition) of each of its non-inherited non-template members that has not been previously explicitly specialized in the translation unit. If this explicit instantiation is a definition, it is also an explicit instantiation definition only for the members that have been defined at this point.</source>
          <target state="translated">Cuando una instanciación explícita nombra una especialización de plantilla de clase,sirve como una instanciación explícita del mismo tipo (declaración o definición)de cada uno de sus miembros no herederos de la plantilla que no se haya especializado explícitamente anteriormente en la unidad de traducción.Si esta instanciación explícita es una definición,también es una definición de instanciación explícita sólo para los miembros que se han definido en este punto.</target>
        </trans-unit>
        <trans-unit id="2e3df706304532f1fafe99d11c7b971952d33cd6" translate="yes" xml:space="preserve">
          <source>When an expression that uses type or non-type template parameters appears in the function parameter list or in the return type, that expression remains a part of the function template signature for the purpose of overloading:</source>
          <target state="translated">Cuando una expresión que utiliza parámetros de plantilla de tipo o no tipo aparece en la lista de parámetros de función o en el tipo de retorno,esa expresión sigue siendo parte de la firma de la plantilla de función a efectos de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="d6a2958786f5f2e3f6b231cd1ab5ade2e4415a58" translate="yes" xml:space="preserve">
          <source>When an incomplete line of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">Cuando se necesita vaciar una l&amp;iacute;nea de salida incompleta, se puede usar el manipulador &lt;code&gt;&lt;a href=&quot;flush&quot;&gt;std::flush&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ddca8d5dd1fab756efa48fbbb7d3a9d39e978269" translate="yes" xml:space="preserve">
          <source>When an object is first created, the cv-qualifiers used (which could be part of decl-specifier-seq or part of a declarator in a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt;, or part of type-id in a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;) determine the constness or volatility of the object, as follows:</source>
          <target state="translated">Cuando se crea un objeto por primera vez, los calificadores cv utilizados (que podr&amp;iacute;an ser parte de decl-specifier-seq o parte de un declarador en una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; , o parte de type-id en una &lt;a href=&quot;new&quot;&gt;nueva expresi&amp;oacute;n&lt;/a&gt; ) determinan la coherencia o volatilidad de el objeto, como sigue:</target>
        </trans-unit>
        <trans-unit id="d130a7fb0dc18dd843e992986efede0bda37daa7" translate="yes" xml:space="preserve">
          <source>When an object of class type X is passed to or returned from a function, if each copy constructor, move constructor, and destructor of X is either trivial or deleted, and X has at least one non-deleted copy or move constructor, implementations are permitted to create a temporary object to hold the function parameter or result object.</source>
          <target state="translated">Cuando se pasa o se devuelve un objeto de tipo X a una función,si cada constructor de copia,constructor de movimiento y destructor de X es trivial o se ha eliminado,y X tiene al menos un constructor de copia o de movimiento no eliminado,se permite a las implementaciones crear un objeto temporal que contenga el parámetro de la función o el objeto resultante.</target>
        </trans-unit>
        <trans-unit id="01dd171c098fe6b55329621a15cc7367dee5f1d4" translate="yes" xml:space="preserve">
          <source>When an object of class type is &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; or &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; outside a &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt; context, the candidate functions are all constructors of the class being initialized. The argument list is the expression list of the initializer.</source>
          <target state="translated">Cuando un objeto de tipo de clase se &lt;a href=&quot;direct_initialization&quot;&gt;inicializa directamente&lt;/a&gt; o se inicializa por &lt;a href=&quot;default_initialization&quot;&gt;defecto&lt;/a&gt; fuera de un contexto de &lt;a href=&quot;copy_initialization&quot;&gt;inicializaci&amp;oacute;n de copia&lt;/a&gt; , las funciones candidatas son todas constructoras de la clase que se est&amp;aacute; inicializando. La lista de argumentos es la lista de expresiones del inicializador.</target>
        </trans-unit>
        <trans-unit id="b112f8307a878b858abe15c415401e098531c633" translate="yes" xml:space="preserve">
          <source>When an object of class type is copy-initialized from an object of the same or derived class type, or default-initialized in a copy-initialization context, the candidate functions are all &lt;a href=&quot;converting_constructor&quot;&gt;converting constructors&lt;/a&gt; of the class being initialized. The argument list is the expression of the initializer.</source>
          <target state="translated">Cuando un objeto de tipo de clase se inicializa por copia desde un objeto del mismo tipo de clase o derivado, o se inicializa por defecto en un contexto de inicializaci&amp;oacute;n de copia, las funciones candidatas son todos &lt;a href=&quot;converting_constructor&quot;&gt;constructores convertidores&lt;/a&gt; de la clase que se est&amp;aacute; inicializando. La lista de argumentos es la expresi&amp;oacute;n del inicializador.</target>
        </trans-unit>
        <trans-unit id="6c417ae51346e00b8f2e04143715b97da243d164" translate="yes" xml:space="preserve">
          <source>When an object of non-aggregate class type &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt;, two-phase overload resolution takes place.</source>
          <target state="translated">Cuando un objeto de clase no agregada tipo &lt;code&gt;T&lt;/code&gt; se &lt;a href=&quot;list_initialization&quot;&gt;inicializa en la lista&lt;/a&gt; , se produce una resoluci&amp;oacute;n de sobrecarga de dos fases.</target>
        </trans-unit>
        <trans-unit id="ae6288b4e0c89ad0ee91c5bb7ab0d2b10cfef5c7" translate="yes" xml:space="preserve">
          <source>When an object of some class &lt;code&gt;C&lt;/code&gt; is created, each non-static data member of non-reference type is allocated in some part of the object representation of &lt;code&gt;C&lt;/code&gt;. Whether reference members occupy any storage is implementation-defined, but their &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt; is the same as that of the object in which they are members.</source>
          <target state="translated">Cuando un objeto de alguna clase &lt;code&gt;C&lt;/code&gt; se crea, cada miembro de datos no est&amp;aacute;tico de tipo de no referencia se asigna en alguna parte de la representaci&amp;oacute;n de objeto de &lt;code&gt;C&lt;/code&gt; . Si los miembros de referencia ocupan alg&amp;uacute;n almacenamiento est&amp;aacute; definido por la implementaci&amp;oacute;n, pero su &lt;a href=&quot;storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; es la misma que la del objeto en el que son miembros.</target>
        </trans-unit>
        <trans-unit id="63af81fffbdf1a90668b23768fdc0980bed3770a" translate="yes" xml:space="preserve">
          <source>When an object of type optional&amp;lt;T&amp;gt; is &lt;a href=&quot;../language/implicit_cast&quot;&gt;contextually converted to bool&lt;/a&gt;, the conversion returns &lt;code&gt;true&lt;/code&gt; if the object</source>
          <target state="translated">Cuando un objeto de tipo opcional &amp;lt;T&amp;gt; se &lt;a href=&quot;../language/implicit_cast&quot;&gt;convierte contextualmente a bool&lt;/a&gt; , la conversi&amp;oacute;n devuelve &lt;code&gt;true&lt;/code&gt; si el objeto</target>
        </trans-unit>
        <trans-unit id="1564a3bf1abdab4804c3b45d781d0743bc25fc6d" translate="yes" xml:space="preserve">
          <source>When an operator appears in an &lt;a href=&quot;expressions&quot;&gt;expression&lt;/a&gt;, and at least one of its operands has a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; or an &lt;a href=&quot;enum&quot;&gt;enumeration type&lt;/a&gt;, then &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; is used to determine the user-defined function to be called among all the functions whose signatures match the following:</source>
          <target state="translated">Cuando un operador aparece en una &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n&lt;/a&gt; , y al menos uno de sus operandos tiene un &lt;a href=&quot;class&quot;&gt;tipo de clase&lt;/a&gt; o un &lt;a href=&quot;enum&quot;&gt;tipo de enumeraci&amp;oacute;n&lt;/a&gt; , entonces la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; se usa para determinar la funci&amp;oacute;n definida por el usuario que se llamar&amp;aacute; entre todas las funciones cuyas firmas coinciden con lo siguiente:</target>
        </trans-unit>
        <trans-unit id="fb0096bc731b7218f872e304d201c5d20ef5e918" translate="yes" xml:space="preserve">
          <source>When an unscoped enumeration is a class member, its enumerators may be accessed using class member access operators &lt;code&gt;.&lt;/code&gt; and &lt;code&gt;-&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Cuando una enumeraci&amp;oacute;n sin &amp;aacute;mbito es un miembro de la clase, se puede acceder a sus enumeradores utilizando operadores de acceso de miembros de la clase &lt;code&gt;.&lt;/code&gt; y &lt;code&gt;-&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6f67767f1271f59038f6527a10110416f4a16657" translate="yes" xml:space="preserve">
          <source>When applied to a class type, the result is the size of an object of that class plus any additional padding required to place such object in an array.</source>
          <target state="translated">Cuando se aplica a un tipo de clase,el resultado es el tamaño de un objeto de esa clase más cualquier acolchado adicional necesario para colocar dicho objeto en un conjunto.</target>
        </trans-unit>
        <trans-unit id="ad0c1d3f6453f804c34d81d7a95f3f37e5786005" translate="yes" xml:space="preserve">
          <source>When applied to a class, the identifier &lt;code&gt;final&lt;/code&gt; appears at the beginning of the class definition, immediately after the name of the class.</source>
          <target state="translated">Cuando se aplica a una clase, el identificador &lt;code&gt;final&lt;/code&gt; aparece al comienzo de la definici&amp;oacute;n de la clase, inmediatamente despu&amp;eacute;s del nombre de la clase.</target>
        </trans-unit>
        <trans-unit id="ebcafd6f66dd47f9f7ba53777289ab2dbc04fbca" translate="yes" xml:space="preserve">
          <source>When applied to a member function, the identifier &lt;code&gt;final&lt;/code&gt; appears immediately after the &lt;a href=&quot;function&quot;&gt;declarator&lt;/a&gt; in the syntax of a member function declaration or a member function definition inside a class definition.</source>
          <target state="translated">Cuando se aplica a una funci&amp;oacute;n miembro, el identificador &lt;code&gt;final&lt;/code&gt; aparece inmediatamente despu&amp;eacute;s del &lt;a href=&quot;function&quot;&gt;declarador&lt;/a&gt; en la sintaxis de una declaraci&amp;oacute;n de funci&amp;oacute;n miembro o una definici&amp;oacute;n de funci&amp;oacute;n miembro dentro de una definici&amp;oacute;n de clase.</target>
        </trans-unit>
        <trans-unit id="64935cc54ab77b2b7e3b4674a370a21df9f2ba1a" translate="yes" xml:space="preserve">
          <source>When applied to a pointer, the subscript expression is always an lvalue.</source>
          <target state="translated">Cuando se aplica a un puntero,la expresión del subíndice es siempre un valor.</target>
        </trans-unit>
        <trans-unit id="3fa5cb2eff44efae521c7cddc759eb971197f991" translate="yes" xml:space="preserve">
          <source>When applied to a reference type, the result is the size of the referenced type.</source>
          <target state="translated">Cuando se aplica a un tipo de referencia,el resultado es el tamaño del tipo de referencia.</target>
        </trans-unit>
        <trans-unit id="f4ae2ed79afdeb8f6c2a098503944e0bac2fe877" translate="yes" xml:space="preserve">
          <source>When applied to an array, the subscript expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue&lt;/a&gt; if the array is an lvalue, and an &lt;a href=&quot;value_category&quot;&gt;xvalue&lt;/a&gt; if it isn't(since C++11).</source>
          <target state="translated">Cuando se aplica a una matriz, la expresi&amp;oacute;n del sub&amp;iacute;ndice es un valor &lt;a href=&quot;value_category&quot;&gt;l&lt;/a&gt; si la matriz es un valor l y un valor &lt;a href=&quot;value_category&quot;&gt;x&lt;/a&gt; si no lo es (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="b3759c1c966a143bdfd4814a06fb7b793ddc31c8" translate="yes" xml:space="preserve">
          <source>When applied to an expression of polymorphic type, evaluation of a typeid expression may involve runtime overhead (a virtual table lookup), otherwise typeid expression is resolved at compile time.</source>
          <target state="translated">Cuando se aplica a una expresión de tipo polimórfico,la evaluación de una expresión tipográfica puede implicar una sobrecarga de tiempo de ejecución (una búsqueda de mesa virtual),de lo contrario la expresión tipográfica se resuelve en tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="e5ed37890741158bbf054cf52a8ebbc0e73b98c9" translate="yes" xml:space="preserve">
          <source>When applied to an expression, &lt;code&gt;sizeof&lt;/code&gt; does &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;not evaluate the expression&lt;/a&gt;, and even if the expression designates a polymorphic object, the result is the size of the static type of the expression. Lvalue-to-rvalue, array-to-pointer, or function-to-pointer conversions are not performed. &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;Temporary materialization&lt;/a&gt;, however, is (formally) performed for prvalue arguments: sizeof determines the size of the result object.(since C++17).</source>
          <target state="translated">Cuando se aplica a una expresi&amp;oacute;n, &lt;code&gt;sizeof&lt;/code&gt; no &lt;a href=&quot;expressions#Unevaluated_expressions&quot;&gt;no evaluar la expresi&amp;oacute;n&lt;/a&gt; , e incluso si la expresi&amp;oacute;n designa un objeto polim&amp;oacute;rfico, el resultado es el tama&amp;ntilde;o del tipo est&amp;aacute;tico de la expresi&amp;oacute;n. No se realizan conversiones de valor a valor, matriz a puntero o funci&amp;oacute;n a puntero. Sin embargo, la &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializaci&amp;oacute;n temporal&lt;/a&gt; se realiza (formalmente) para argumentos prvalue: sizeof determina el tama&amp;ntilde;o del objeto resultante (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="902efcbdae8639c2479afc412e93c5b16435e58a" translate="yes" xml:space="preserve">
          <source>When calling the allocation function, the new-expression passes the number of bytes requested as the first argument, of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, which is exactly &lt;code&gt;sizeof(T)&lt;/code&gt; for non-array &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Cuando se llama a la funci&amp;oacute;n de asignaci&amp;oacute;n, la nueva expresi&amp;oacute;n pasa el n&amp;uacute;mero de bytes solicitados como primer argumento, de tipo &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , que es exactamente &lt;code&gt;sizeof(T)&lt;/code&gt; para los no-matriz &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7aab9cd14cb0a3097419a3a095e5a8499afb16ff" translate="yes" xml:space="preserve">
          <source>When code refers to a function in context that requires the function definition to exist, and this particular function has not been explicitly instantiated, implicit instantiation occurs. The list of template arguments does not have to be supplied if it can be &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced&lt;/a&gt; from context.</source>
          <target state="translated">Cuando el c&amp;oacute;digo se refiere a una funci&amp;oacute;n en contexto que requiere que exista la definici&amp;oacute;n de la funci&amp;oacute;n, y esta funci&amp;oacute;n particular no se ha instanciado expl&amp;iacute;citamente, se produce una instanciaci&amp;oacute;n impl&amp;iacute;cita. No es necesario proporcionar la lista de argumentos de plantilla si puede &lt;a href=&quot;template_argument_deduction&quot;&gt;deducirse&lt;/a&gt; del contexto.</target>
        </trans-unit>
        <trans-unit id="2f3a994250d478ff5309a561ec4f4f714968e84d" translate="yes" xml:space="preserve">
          <source>When code refers to a template in context that requires a completely defined type, or when the completeness of the type affects the code, and this particular type has not been explicitly instantiated, implicit instantiation occurs. For example, when an object of this type is constructed, but not when a pointer to this type is constructed.</source>
          <target state="translated">Cuando el código se refiere a una plantilla en un contexto que requiere un tipo completamente definido,o cuando la completitud del tipo afecta al código,y este tipo en particular no ha sido explícitamente instanciado,se produce una instanciación implícita.Por ejemplo,cuando se construye un objeto de este tipo,pero no cuando se construye un puntero a este tipo.</target>
        </trans-unit>
        <trans-unit id="e579a073bc59e27215b96008dac2e50df4bb57db" translate="yes" xml:space="preserve">
          <source>When comparing entire containers for equality, &lt;code&gt;operator==&lt;/code&gt; for the corresponding container are usually preferred.</source>
          <target state="translated">Al comparar contenedores enteros para igualdad, generalmente se prefiere el &lt;code&gt;operator==&lt;/code&gt; para el contenedor correspondiente.</target>
        </trans-unit>
        <trans-unit id="47745284a6ed97288740ca09ddbb9f643055ef39" translate="yes" xml:space="preserve">
          <source>When considering the argument to a constructor or to a user-defined conversion function, only one standard conversion sequence is allowed (otherwise user-defined conversions could be effectively chained). When converting from one built-in type to another built-in type, only one standard conversion sequence is allowed.</source>
          <target state="translated">Cuando se considera el argumento a un constructor o a una función de conversión definida por el usuario,sólo se permite una secuencia de conversión estándar (de lo contrario,las conversiones definidas por el usuario podrían encadenarse efectivamente).Al convertir de un tipo incorporado a otro tipo incorporado,sólo se permite una secuencia de conversión estándar.</target>
        </trans-unit>
        <trans-unit id="553ce681044a1dac36f2a3c93df19f57a9078616" translate="yes" xml:space="preserve">
          <source>When constructing a complex class with multiple branches, within a constructor that belongs to one branch, polymorphism is restricted to that class and its bases: if it obtains a pointer or reference to a base subobject outside this subhierarchy, and attempts to invoke a virtual function call (e.g. using explicit member access), the behavior is undefined:</source>
          <target state="translated">Cuando se construye una clase compleja con múltiples ramas,dentro de un constructor que pertenece a una rama,el polimorfismo se restringe a esa clase y sus bases:si obtiene un puntero o una referencia a un subobjeto base fuera de esta subjerarquía,e intenta invocar una llamada a una función virtual (por ejemplo,utilizando el acceso explícito de miembros),el comportamiento es indefinido:</target>
        </trans-unit>
        <trans-unit id="aed446bf94f330e6e0b55d02da8f34b88ffea9e7" translate="yes" xml:space="preserve">
          <source>When copy elision occurs, the implementation treats the source and target of the omitted copy/move(since C++11) operation as simply two different ways of referring to the same object, and the destruction of that object occurs at the later of the times when the two objects would have been destroyed without the optimization (except that, if the parameter of the selected constructor is an rvalue reference to object type, the destruction occurs when the target would have been destroyed)(since C++17).</source>
          <target state="translated">Cuando se produce la elisión de la copia,la implementación trata la fuente y el objetivo de la operación de copia/movimiento omitida (desde C++11)simplemente como dos formas diferentes de referirse al mismo objeto,y la destrucción de ese objeto ocurre en el último momento en que los dos objetos se habrían destruido sin la optimización (excepto que,si el parámetro del constructor seleccionado es una referencia de valor al tipo de objeto,la destrucción se produce cuando el objetivo se habría destruido)(desde C++17).</target>
        </trans-unit>
        <trans-unit id="2dc86f028e3cfb1147dc7e004b4c16749351361e" translate="yes" xml:space="preserve">
          <source>When copying overlapping ranges, &lt;code&gt;std::copy&lt;/code&gt; is appropriate when copying to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::copy_backward&lt;/code&gt; is appropriate when copying to the right (end of the destination range is outside the source range).</source>
          <target state="translated">Al copiar rangos superpuestos, &lt;code&gt;std::copy&lt;/code&gt; es apropiado cuando se copia a la izquierda (el comienzo del rango de destino est&amp;aacute; fuera del rango de origen) mientras que &lt;code&gt;std::copy_backward&lt;/code&gt; es apropiado cuando se copia a la derecha (el final del rango de destino est&amp;aacute; fuera del origen rango).</target>
        </trans-unit>
        <trans-unit id="63771776b0fe78c4297c086089bcc7b025dc8ded" translate="yes" xml:space="preserve">
          <source>When declaring a function, &lt;a href=&quot;except_spec&quot;&gt; exception specifications&lt;/a&gt; and &lt;a href=&quot;noexcept_spec&quot;&gt; noexcept specifiers&lt;/a&gt; may be provided to limit the types of the exceptions a function may throw.</source>
          <target state="translated">Al declarar una funci&amp;oacute;n, se pueden proporcionar &lt;a href=&quot;noexcept_spec&quot;&gt;especificaciones de &lt;/a&gt;&lt;a href=&quot;except_spec&quot;&gt;excepci&amp;oacute;n&lt;/a&gt; y especificadores de no excepci&amp;oacute;n para limitar los tipos de excepciones que puede lanzar una funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a46821f25349d54835cd348827a97ba1db7215ad" translate="yes" xml:space="preserve">
          <source>When defining a member of an explicitly specialized class template outside the body of the class, the syntax &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; is not used, except if it's a member of an explicitly specialized member class template, which is specialized as a class template, because otherwise, the syntax would require such definition to begin with &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; required by the nested template.</source>
          <target state="translated">Al definir un miembro de una plantilla de clase expl&amp;iacute;citamente especializada fuera del cuerpo de la clase, la &lt;code&gt;template &amp;lt;&amp;gt;&lt;/code&gt; sintaxis &amp;lt;&amp;gt; no se usa, excepto si es miembro de una plantilla de clase de miembro expl&amp;iacute;citamente especializada, que est&amp;aacute; especializada como una plantilla de clase, porque de lo contrario, la sintaxis requerir&amp;iacute;a tal definici&amp;oacute;n para comenzar con la &lt;code&gt;template&amp;lt;parameters&amp;gt;&lt;/code&gt; requerida por la plantilla anidada.</target>
        </trans-unit>
        <trans-unit id="80a330b63ba0a84c45e73880291aa572a3efa1e6" translate="yes" xml:space="preserve">
          <source>When determining if two &lt;a href=&quot;dependent_name&quot;&gt;dependent expressions&lt;/a&gt; are equivalent, only the dependent names involved are considered, not the results of name lookup. If multiple declarations of the same template differ in the result of name lookup, the first such declaration is used:</source>
          <target state="translated">Al determinar si dos &lt;a href=&quot;dependent_name&quot;&gt;expresiones dependientes&lt;/a&gt; son equivalentes, solo se consideran los nombres dependientes involucrados, no los resultados de la b&amp;uacute;squeda de nombres. Si varias declaraciones de la misma plantilla difieren en el resultado de la b&amp;uacute;squeda de nombres, se utiliza la primera declaraci&amp;oacute;n de este tipo:</target>
        </trans-unit>
        <trans-unit id="7ef9fbc568a29fc667929a02fb6d63098b804ede" translate="yes" xml:space="preserve">
          <source>When directly used as the condition of &lt;a href=&quot;../language/static_assert&quot;&gt;&lt;code&gt;static_assert&lt;/code&gt; declaration&lt;/a&gt; or &lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr if statement&lt;/a&gt;, &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; always returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa directamente como la condici&amp;oacute;n de la &lt;a href=&quot;../language/static_assert&quot;&gt;declaraci&amp;oacute;n &lt;/a&gt; &lt;code&gt;static_assert&lt;/code&gt; o la declaraci&amp;oacute;n &lt;a href=&quot;../language/if#constexpr_if&quot;&gt;constexpr if&lt;/a&gt; , &lt;code&gt;std::is_constant_evaluated()&lt;/code&gt; siempre devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b778058d4f47bf64716da2bbf948a1a5fb94a5" translate="yes" xml:space="preserve">
          <source>When earlier tiebreakers, including partial ordering, failed to distinguish between two candidate function templates, the following rules apply:</source>
          <target state="translated">Cuando los anteriores desempate,incluyendo el ordenamiento parcial,no distinguían entre dos plantillas de funciones candidatas,se aplican las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="c5dfcd38376374c25b198c54aa21d3fdad95c984" translate="yes" xml:space="preserve">
          <source>When enabled, for an object &lt;code&gt;o&lt;/code&gt; of type &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; that contains a value, &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; evaluates to the same value as &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt;. For an optional that does not contain a value, the hash is unspecified.</source>
          <target state="translated">Cuando est&amp;aacute; habilitado, para un objeto &lt;code&gt;o&lt;/code&gt; del tipo &lt;code&gt;std::optional&amp;lt;T&amp;gt;&lt;/code&gt; que contiene un valor, &lt;code&gt;std::hash&amp;lt;std::optional&amp;lt;T&amp;gt;&amp;gt;()(o)&lt;/code&gt; eval&amp;uacute;a el mismo valor que &lt;code&gt;std::hash&amp;lt;std::remove_const_t&amp;lt;T&amp;gt;&amp;gt;()(*o)&lt;/code&gt; . Para un opcional que no contiene un valor, el hash no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="903d975e1994ac3a37b90733c8025f08ecf31a3c" translate="yes" xml:space="preserve">
          <source>When enabled,(since C++17) for a given &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt;, this specialization ensures that &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt;.</source>
          <target state="translated">Cuando est&amp;aacute; habilitada (desde C ++ 17) para un &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt; p&lt;/code&gt; dado , esta especializaci&amp;oacute;n asegura que &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;&amp;gt;()(p) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;typename &lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, D&amp;gt;::pointer&amp;gt;()(p.get())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="19ae5f22223dec57ebaf47feb7ebf7c7e201fce6" translate="yes" xml:space="preserve">
          <source>When entering a catch clause, if its formal parameter is a base class of the exception type, it is &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; from the base class subobject of the exception object. Otherwise, it is copy-initialized from the exception object (this copy is subject to &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;).</source>
          <target state="translated">Al ingresar una cl&amp;aacute;usula catch, si su par&amp;aacute;metro formal es una clase base del tipo de excepci&amp;oacute;n, se &lt;a href=&quot;copy_initialization&quot;&gt;inicializa&lt;/a&gt; mediante copia desde el subobjeto de la clase base del objeto de excepci&amp;oacute;n. De lo contrario, se inicializa desde el objeto de excepci&amp;oacute;n (esta copia est&amp;aacute; sujeta a &lt;a href=&quot;copy_elision&quot;&gt;copia de elisi&amp;oacute;n&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="16fd800e4f4545dc8c54147c76bdffd06523fe14" translate="yes" xml:space="preserve">
          <source>When erasing at either end of the deque, references to non-erased elements are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Al borrar en cualquier extremo de la eliminaci&amp;oacute;n, las referencias a elementos no borrados no se invalidan con &lt;code&gt;&lt;a href=&quot;deque/erase&quot;&gt;erase&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;deque/pop_front&quot;&gt;pop_front&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;deque/pop_back&quot;&gt;pop_back&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e154c534821f10918bbd1a0adb594ebb17181d9" translate="yes" xml:space="preserve">
          <source>When every character of output needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">Cuando se necesita vaciar cada car&amp;aacute;cter de salida, se puede &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulador std :: unitbuf .</target>
        </trans-unit>
        <trans-unit id="3a9eae4e1a206e51541973ab38f172716a809f23" translate="yes" xml:space="preserve">
          <source>When every output operation needs to be flushed, the &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; manipulator may be used.</source>
          <target state="translated">Cuando cada operaci&amp;oacute;n de salida necesita ser &lt;code&gt;&lt;a href=&quot;unitbuf&quot;&gt;std::unitbuf&lt;/a&gt;&lt;/code&gt; se puede usar el manipulador std :: unitbuf .</target>
        </trans-unit>
        <trans-unit id="de9fb1f75fc610360e59b80abf945bf3f980c7f7" translate="yes" xml:space="preserve">
          <source>When formatting a floating point value as hexfloat (i.e., when &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt;), the stream's precision is not used; instead, the number is always printed with enough precision to exactly represent the value.</source>
          <target state="translated">Al formatear un valor de coma flotante como hexfloat (es decir, cuando &lt;code&gt;floatfield == (&lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt; | &lt;a href=&quot;../../io/ios_base/fmtflags&quot;&gt;std::ios_base::scientific&lt;/a&gt;)&lt;/code&gt; ), la precisi&amp;oacute;n de la secuencia no se utiliza; en cambio, el n&amp;uacute;mero siempre se imprime con suficiente precisi&amp;oacute;n para representar exactamente el valor.</target>
        </trans-unit>
        <trans-unit id="a40d58e1eae50e8055be19035d8b5887a01317a2" translate="yes" xml:space="preserve">
          <source>When given reference types, &lt;code&gt;common_reference&lt;/code&gt; attempts to find a reference type to which the supplied reference types can all be bound, but may return a non-reference type if it cannot find such a reference type.</source>
          <target state="translated">Cuando se dan tipos de referencia, &lt;code&gt;common_reference&lt;/code&gt; intenta encontrar un tipo de referencia al que se puedan vincular todos los tipos de referencia suministrados, pero puede devolver un tipo sin referencia si no puede encontrar dicho tipo de referencia.</target>
        </trans-unit>
        <trans-unit id="dd4bc57db1751ca1bef7fa50506950271e3c5d18" translate="yes" xml:space="preserve">
          <source>When indexing C++ containers, such as &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, etc, the appropriate type is the member typedef &lt;code&gt;size_type&lt;/code&gt; provided by such containers. It is usually defined as a synonym for &lt;code&gt;std::size_t&lt;/code&gt;.</source>
          <target state="translated">Al indexar contenedores C ++, como &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , etc., el tipo apropiado es el miembro typedef &lt;code&gt;size_type&lt;/code&gt; proporcionado por dichos contenedores. Generalmente se define como sin&amp;oacute;nimo de &lt;code&gt;std::size_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ac68fbcc8bc1efc6049dde60f0e30093d3a91f7" translate="yes" xml:space="preserve">
          <source>When initialization of an object of non-class type cv1 &lt;code&gt;T&lt;/code&gt; requires a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to convert from an initializer expression of class type cv &lt;code&gt;S&lt;/code&gt;, the following functions are candidates:</source>
          <target state="translated">Cuando la inicializaci&amp;oacute;n de un objeto de tipo no clase cv1 &lt;code&gt;T&lt;/code&gt; requiere una &lt;a href=&quot;cast_operator&quot;&gt;funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario&lt;/a&gt; para convertir desde una expresi&amp;oacute;n inicializadora de clase tipo cv &lt;code&gt;S&lt;/code&gt; , las siguientes funciones son candidatas:</target>
        </trans-unit>
        <trans-unit id="f2f9ef8bbb329e61c10d08ae998e3ab7e71030d3" translate="yes" xml:space="preserve">
          <source>When initializing from a single argument of a type that is a specialization of the class template at issue, copying deduction is generally preferred over wrapping by default:</source>
          <target state="translated">Cuando se inicializa a partir de un único argumento de un tipo que es una especialización de la plantilla de clase en cuestión,se suele preferir la deducción por copia a la envoltura por defecto:</target>
        </trans-unit>
        <trans-unit id="d46960739a911c065792d3eb6a771bd67fb54134" translate="yes" xml:space="preserve">
          <source>When inserting a range, the range version of &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; is generally preferable as it preserves the correct capacity growth behavior, unlike &lt;code&gt;reserve()&lt;/code&gt; followed by a series of &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt;s.</source>
          <target state="translated">Al insertar un rango, la versi&amp;oacute;n de rango de &lt;code&gt;&lt;a href=&quot;insert&quot;&gt;insert()&lt;/a&gt;&lt;/code&gt; generalmente es preferible ya que conserva el comportamiento correcto de crecimiento de la capacidad, a diferencia de &lt;code&gt;reserve()&lt;/code&gt; seguido de una serie de &lt;code&gt;&lt;a href=&quot;push_back&quot;&gt;push_back()&lt;/a&gt;&lt;/code&gt; s.</target>
        </trans-unit>
        <trans-unit id="906401050b55fc9b72b5d2421e9144fbb190452a" translate="yes" xml:space="preserve">
          <source>When inserting at either end of the deque, references are not invalidated by &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Al insertar en cualquier extremo de la eliminaci&amp;oacute;n, las referencias no se invalidan mediante &lt;code&gt;&lt;a href=&quot;deque/insert&quot;&gt;insert&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;deque/emplace&quot;&gt;emplace&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d58dc4a9c1d64bc2047ee755578c50f3b966be84" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cuando se instancia con uno de los tipos de coma flotante &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; y &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;std::atomic&lt;/code&gt; proporciona operaciones at&amp;oacute;micas adicionales apropiadas para tipos de coma flotante como &lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="552f6dfa495a4acb2aa66f36a0ba5bf21b95fae5" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the floating-point types &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, and &lt;code&gt;long double&lt;/code&gt;, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to floating-point types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Cuando se instancia con uno de los tipos de coma flotante &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; y &lt;code&gt;long double&lt;/code&gt; , &lt;code&gt;std::atomic_ref&lt;/code&gt; proporciona operaciones at&amp;oacute;micas adicionales apropiadas para tipos de coma flotante como &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5bac602845c57306b8db9e963ef0dfc1cad72696" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Cuando se instancia con uno de los siguientes tipos integrales, &lt;code&gt;std::atomic&lt;/code&gt; proporciona operaciones at&amp;oacute;micas adicionales apropiadas para tipos integrales como &lt;a href=&quot;atomic/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="baa8ebba32798819cb5a6086f1e8129674336cd6" translate="yes" xml:space="preserve">
          <source>When instantiated with one of the following integral types, &lt;code&gt;std::atomic_ref&lt;/code&gt; provides additional atomic operations appropriate to integral types such as &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt;&lt;code&gt;fetch_add&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt;&lt;code&gt;fetch_sub&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_and&quot;&gt;&lt;code&gt;fetch_and&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_or&quot;&gt;&lt;code&gt;fetch_or&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt;&lt;code&gt;fetch_xor&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Cuando se instancia con uno de los siguientes tipos integrales, &lt;code&gt;std::atomic_ref&lt;/code&gt; proporciona operaciones at&amp;oacute;micas adicionales apropiadas para tipos integrales como &lt;a href=&quot;atomic_ref/fetch_add&quot;&gt; &lt;code&gt;fetch_add&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_sub&quot;&gt; &lt;code&gt;fetch_sub&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_and&quot;&gt; &lt;code&gt;fetch_and&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_or&quot;&gt; &lt;code&gt;fetch_or&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;atomic_ref/fetch_xor&quot;&gt; &lt;code&gt;fetch_xor&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="503d40b06333e935efd323a580b4acbb78349e5a" translate="yes" xml:space="preserve">
          <source>When it is needed to interpret the bytes of an object as a value of a different type, &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;or &lt;a href=&quot;../numeric/bit_cast&quot;&gt;&lt;code&gt;std::bit_cast&lt;/code&gt;&lt;/a&gt;(since C++20)can be used:</source>
          <target state="translated">Cuando se necesita interpretar los bytes de un objeto como un valor de un tipo diferente, se puede usar &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; o &lt;a href=&quot;../numeric/bit_cast&quot;&gt; &lt;code&gt;std::bit_cast&lt;/code&gt; &lt;/a&gt; (ya que C ++ 20):</target>
        </trans-unit>
        <trans-unit id="5281af908beb7c5eb475c7aeb21afb60dcc9c864" translate="yes" xml:space="preserve">
          <source>When language specifications nest, the innermost specification is the one that is in effect.</source>
          <target state="translated">Cuando las especificaciones del lenguaje anidan,la especificación más interna es la que está en vigor.</target>
        </trans-unit>
        <trans-unit id="016122add2c9877f6072526697f450c52a1f6394" translate="yes" xml:space="preserve">
          <source>When making an explicit call to the conversion function, the type-id is greedy: it is the longest possible sequence of tokens that is a valid type id (including attributes, if any):</source>
          <target state="translated">Cuando se hace un llamado explícito a la función de conversión,el type-id es codicioso:es la secuencia más larga posible de fichas que es un type id válido (incluyendo atributos,si los hay):</target>
        </trans-unit>
        <trans-unit id="c7b5147658508bc213c62aa761a47793df025adb" translate="yes" xml:space="preserve">
          <source>When moving overlapping ranges, &lt;code&gt;std::move&lt;/code&gt; is appropriate when moving to the left (beginning of the destination range is outside the source range) while &lt;code&gt;std::move_backward&lt;/code&gt; is appropriate when moving to the right (end of the destination range is outside the source range).</source>
          <target state="translated">Al mover rangos superpuestos, &lt;code&gt;std::move&lt;/code&gt; es apropiado cuando se mueve hacia la izquierda (el comienzo del rango de destino est&amp;aacute; fuera del rango de origen) mientras que &lt;code&gt;std::move_backward&lt;/code&gt; es apropiado cuando se mueve hacia la derecha (el final del rango de destino est&amp;aacute; fuera del origen rango).</target>
        </trans-unit>
        <trans-unit id="bcc9e1f7b6bbebc1441b5e338721e2a64a3a6fc2" translate="yes" xml:space="preserve">
          <source>When no more matches are found, copies the remaining non-matched characters to &lt;code&gt;out&lt;/code&gt; as if by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; where &lt;code&gt;last_m&lt;/code&gt; is a copy of the last match found.</source>
          <target state="translated">Cuando hay m&amp;aacute;s se encuentran coincidencias, copia los restantes caracteres no emparejado a &lt;code&gt;out&lt;/code&gt; como por &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(last_m.suffix().first, last_m.suffix().second, out)&lt;/code&gt; donde &lt;code&gt;last_m&lt;/code&gt; es una copia de El &amp;uacute;ltimo partido encontrado.</target>
        </trans-unit>
        <trans-unit id="a989818254cf8030ca8ff78fd514d37b03472368" translate="yes" xml:space="preserve">
          <source>When one of them is found by &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;normal unqualified lookup&lt;/a&gt; for the name to the left of the function-call operator, it inhibits &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt;.</source>
          <target state="translated">Cuando uno de ellos es encontrado por &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;la b&amp;uacute;squeda normal no calificada&lt;/a&gt; del nombre a la izquierda del operador de llamada de funci&amp;oacute;n, inhibe la &lt;a href=&quot;../../language/adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1514e0d97ec7c21ec7cdc4fc2229658217c2a1d3" translate="yes" xml:space="preserve">
          <source>When one or more lock-free atomic functions run concurrently, at least one of them is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;lock-free&lt;/a&gt; -- it is the job of the implementation to ensure they cannot be live-locked indefinitely by other threads, such as by continuously stealing the cache line).</source>
          <target state="translated">Cuando una o m&amp;aacute;s funciones at&amp;oacute;micas sin bloqueo se ejecutan simult&amp;aacute;neamente, se garantiza que al menos una de ellas se complete (todas las operaciones est&amp;aacute;ndar sin bloqueo de la biblioteca son sin &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom&quot;&gt;bloqueo&lt;/a&gt; ; el trabajo de la implementaci&amp;oacute;n es garantizar que no se puedan bloquear en vivo indefinidamente por otros hilos, como robar continuamente la l&amp;iacute;nea de cach&amp;eacute;).</target>
        </trans-unit>
        <trans-unit id="c525266500bfb2286ded86306e069bde3c22c32c" translate="yes" xml:space="preserve">
          <source>When one statement is expected, but multiple statements need to be executed in sequence (for example, in an &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; statement or a loop), a compound statement may be used:</source>
          <target state="translated">Cuando se espera una declaraci&amp;oacute;n, pero se deben ejecutar varias instrucciones en secuencia (por ejemplo, en una declaraci&amp;oacute;n &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; o en un bucle), se puede usar una declaraci&amp;oacute;n compuesta:</target>
        </trans-unit>
        <trans-unit id="99ceddfac8288288bcf4a468dfcdde568e2b94f6" translate="yes" xml:space="preserve">
          <source>When only one thread that is not blocked in a standard library function executes an &lt;a href=&quot;../atomic&quot;&gt;atomic function&lt;/a&gt; that is lock-free, that execution is guaranteed to complete (all standard library lock-free operations are &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;obstruction-free&lt;/a&gt;).</source>
          <target state="translated">Cuando solo un subproceso que no est&amp;aacute; bloqueado en una funci&amp;oacute;n de biblioteca est&amp;aacute;ndar ejecuta una &lt;a href=&quot;../atomic&quot;&gt;funci&amp;oacute;n at&amp;oacute;mica&lt;/a&gt; que est&amp;aacute; libre de bloqueo, se garantiza que esa ejecuci&amp;oacute;n se complete (todas las operaciones est&amp;aacute;ndar libres de bloqueo de biblioteca est&amp;aacute;n &lt;a href=&quot;https://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom&quot;&gt;libres de obstrucci&amp;oacute;n&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="be17634a4507a825d9841a9ec6ecaee80238b41e" translate="yes" xml:space="preserve">
          <source>When parsing an expression, an operator which is listed on some row of the table above with a precedence will be bound tighter (as if by parentheses) to its arguments than any operator that is listed on a row further below it with a lower precedence. For example, the expressions &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; and &lt;code&gt;*p++&lt;/code&gt; are parsed as &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; and &lt;code&gt;*(p++)&lt;/code&gt;, and not as &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; or &lt;code&gt;(*p)++&lt;/code&gt;.</source>
          <target state="translated">Al analizar una expresi&amp;oacute;n, un operador que aparece en una fila de la tabla anterior con una prioridad estar&amp;aacute; m&amp;aacute;s ajustado (como entre par&amp;eacute;ntesis) a sus argumentos que cualquier operador que se enumere en una fila m&amp;aacute;s abajo con una precedencia m&amp;aacute;s baja. Por ejemplo, las expresiones &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a &amp;amp; b&lt;/code&gt; y &lt;code&gt;*p++&lt;/code&gt; se analizan como &lt;code&gt;(&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; a) &amp;amp; b&lt;/code&gt; y &lt;code&gt;*(p++)&lt;/code&gt; , y no como &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; (a &amp;amp; b)&lt;/code&gt; o &lt;code&gt;(*p)++&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8b48f697df0e524fccfbe77ccb0c6aefdae765c" translate="yes" xml:space="preserve">
          <source>When parsing an incomplete floating-point value that ends in the exponent with no digits, such as parsing &lt;code&gt;&quot;100er&quot;&lt;/code&gt; with the conversion specifier &lt;code&gt;%f&lt;/code&gt;, the sequence &lt;code&gt;&quot;100e&quot;&lt;/code&gt; (the longest prefix of a possibly valid floating-point number) is consumed, resulting in a matching error (the consumed sequence cannot be converted to a floating-point number), with &lt;code&gt;&quot;r&quot;&lt;/code&gt; remaining. Some existing implementations do not follow this rule and roll back to consume only &lt;code&gt;&quot;100&quot;&lt;/code&gt;, leaving &lt;code&gt;&quot;er&quot;&lt;/code&gt;, e.g. &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;glibc bug 1765&lt;/a&gt;.</source>
          <target state="translated">Al analizar un valor de coma flotante incompleto que termina en el exponente sin d&amp;iacute;gitos, como analizar &lt;code&gt;&quot;100er&quot;&lt;/code&gt; con el especificador de conversi&amp;oacute;n &lt;code&gt;%f&lt;/code&gt; , se &lt;code&gt;&quot;100e&quot;&lt;/code&gt; la secuencia &quot;100e&quot; (el prefijo m&amp;aacute;s largo de un n&amp;uacute;mero de coma flotante posiblemente v&amp;aacute;lido) , lo que produce un error de coincidencia (la secuencia consumida no se puede convertir a un n&amp;uacute;mero de coma flotante), con &lt;code&gt;&quot;r&quot;&lt;/code&gt; restante. Algunas implementaciones existentes no siguen esta regla y retroceden para consumir solo &lt;code&gt;&quot;100&quot;&lt;/code&gt; , dejando &lt;code&gt;&quot;er&quot;&lt;/code&gt; , por ejemplo, &lt;a href=&quot;https://sourceware.org/bugzilla/show_bug.cgi?id=1765&quot;&gt;error glibc 1765&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f862fd02527b95bbe0a34ac38eb69a8e6f210d9f" translate="yes" xml:space="preserve">
          <source>When performing N:M conversions, this function may return &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; after consuming all source characters (&lt;code&gt;from_next == from_end&lt;/code&gt;). This means that another internal character is needed to complete the conversion (e.g. when converting UTF-16 to UTF-8, if the last character in the source buffer is a high surrogate).</source>
          <target state="translated">Al realizar conversiones N: M, esta funci&amp;oacute;n puede devolver &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::partial&lt;/a&gt;&lt;/code&gt; despu&amp;eacute;s de consumir todos los caracteres de origen ( &lt;code&gt;from_next == from_end&lt;/code&gt; ). Esto significa que se necesita otro car&amp;aacute;cter interno para completar la conversi&amp;oacute;n (por ejemplo, al convertir UTF-16 a UTF-8, si el &amp;uacute;ltimo car&amp;aacute;cter en el b&amp;uacute;fer de origen es un sustituto alto).</target>
        </trans-unit>
        <trans-unit id="73238300a6abe634b092cd3c78bfa124e710c17c" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">Al realizar coincidencias, todas las subexpresiones marcadas &lt;code&gt;(expr)&lt;/code&gt; se tratan como subexpresiones sin marcas &lt;code&gt;(?:expr)&lt;/code&gt; . No se almacenan coincidencias en la estructura &lt;code&gt;&lt;a href=&quot;../regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; suministrada y &lt;code&gt;mark_count()&lt;/code&gt; es cero</target>
        </trans-unit>
        <trans-unit id="c20cd38801efcb855e60aac217866665e1148ddd" translate="yes" xml:space="preserve">
          <source>When performing matches, all marked sub-expressions &lt;code&gt;(expr)&lt;/code&gt; are treated as non-marking sub-expressions &lt;code&gt;(?:expr)&lt;/code&gt;. No matches are stored in the supplied &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; structure and &lt;code&gt;mark_count()&lt;/code&gt; is zero</source>
          <target state="translated">Al realizar coincidencias, todas las subexpresiones marcadas &lt;code&gt;(expr)&lt;/code&gt; se tratan como subexpresiones sin marcas &lt;code&gt;(?:expr)&lt;/code&gt; . No se almacenan coincidencias en la estructura &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; suministrada y &lt;code&gt;mark_count()&lt;/code&gt; es cero</target>
        </trans-unit>
        <trans-unit id="f4f7d6dbe3d540b5d3f8d4a7ca45e962b95c0edb" translate="yes" xml:space="preserve">
          <source>When placeholder types (either &lt;code&gt;auto&lt;/code&gt; or &lt;a href=&quot;../concepts&quot;&gt;Concept auto&lt;/a&gt;) appear in the parameter list of a function declaration or of a function template declaration, the declaration declares a function template, and one invented template parameter for each placeholder is appended to the template parameter list.</source>
          <target state="translated">Cuando los tipos de marcador de posici&amp;oacute;n ( &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tico o &lt;a href=&quot;../concepts&quot;&gt;Concept autom&amp;aacute;tico&lt;/a&gt; ) aparecen en la lista de par&amp;aacute;metros de una declaraci&amp;oacute;n de funci&amp;oacute;n o de una declaraci&amp;oacute;n de plantilla de funci&amp;oacute;n, la declaraci&amp;oacute;n declara una plantilla de funci&amp;oacute;n, y se agrega un par&amp;aacute;metro de plantilla inventado para cada marcador de posici&amp;oacute;n a la lista de par&amp;aacute;metros de plantilla.</target>
        </trans-unit>
        <trans-unit id="641c7fd3577d0edc6efac99f2f76379fc6931592" translate="yes" xml:space="preserve">
          <source>When reading characters, &lt;code&gt;std::istream_iterator&lt;/code&gt; skips whitespace by default (unless disabled with &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; or equivalent), while &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; does not. In addition, &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">Al leer caracteres, &lt;code&gt;std::istream_iterator&lt;/code&gt; omite los espacios en blanco por defecto (a menos que est&amp;eacute; deshabilitado con &lt;code&gt;&lt;a href=&quot;../io/manip/skipws&quot;&gt;std::noskipws&lt;/a&gt;&lt;/code&gt; o equivalente), mientras que &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; no. Adem&amp;aacute;s, &lt;code&gt;&lt;a href=&quot;istreambuf_iterator&quot;&gt;std::istreambuf_iterator&lt;/a&gt;&lt;/code&gt; es m&amp;aacute;s eficiente, ya que evita la sobrecarga de construir y destruir el objeto centinela una vez por car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="1ab1d2134a41c9628e2098e71305ab92b1cd2216" translate="yes" xml:space="preserve">
          <source>When rethrowing exceptions, the second form must be used to avoid object slicing in the (typical) case where exception objects use inheritance:</source>
          <target state="translated">Al volver a lanzar las excepciones,debe utilizarse la segunda forma para evitar el rebanado de objetos en el caso (típico)de que los objetos de excepción utilicen la herencia:</target>
        </trans-unit>
        <trans-unit id="f9fb914caea510cf6dfabbb484a007b28ab4e8a3" translate="yes" xml:space="preserve">
          <source>When signal handler is set to a function and a signal occurs, it is implementation defined whether &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; will be executed immediately before the start of signal handler. Also, the implementation can prevent some implementation-defined set of signals from occurring while the signal handler runs.</source>
          <target state="translated">Cuando el controlador de se&amp;ntilde;al se establece en una funci&amp;oacute;n y se produce una se&amp;ntilde;al, la implementaci&amp;oacute;n define si &lt;code&gt;std::signal(sig, &lt;a href=&quot;sig_strategies&quot;&gt;SIG_DFL&lt;/a&gt;)&lt;/code&gt; se ejecutar&amp;aacute; inmediatamente antes del inicio del controlador de se&amp;ntilde;al. Adem&amp;aacute;s, la implementaci&amp;oacute;n puede evitar que ocurra un conjunto de se&amp;ntilde;ales definidas por la implementaci&amp;oacute;n mientras se ejecuta el manejador de se&amp;ntilde;ales.</target>
        </trans-unit>
        <trans-unit id="a82c7324d6d1f526ac5299ac166aafff69e4a350" translate="yes" xml:space="preserve">
          <source>When signed integer arithmetic operation overflows (the result does not fit in the result type), the behavior is undefined: it may wrap around according to the rules of the representation (typically 2's complement), it may trap on some platforms or due to compiler options (e.g. &lt;code&gt;-ftrapv&lt;/code&gt; in GCC and Clang), or may be completely &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimized out by the compiler&lt;/a&gt;.</source>
          <target state="translated">Cuando se desborda la operaci&amp;oacute;n aritm&amp;eacute;tica de enteros con signo (el resultado no cabe en el tipo de resultado), el comportamiento es indefinido: puede ajustarse de acuerdo con las reglas de la representaci&amp;oacute;n (generalmente el complemento de 2), puede quedar atrapado en algunas plataformas o debido al compilador opciones (por ejemplo, &lt;code&gt;-ftrapv&lt;/code&gt; en GCC y Clang), o puede ser completamente &lt;a href=&quot;http://blog.llvm.org/2011/05/what-every-c-programmer-should-know_14.html&quot;&gt;optimizado por el compilador&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9deeffc3f0edffbc9e7bf40fc167f8af90637021" translate="yes" xml:space="preserve">
          <source>When some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrain algorithms&lt;/a&gt; that usually return an iterator or a subrange of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; take a particular rvalue &lt;code&gt;Range&lt;/code&gt; argument that does not models exposition-only concept &lt;a href=&quot;range&quot;&gt;&lt;code&gt;__ForwardingRange&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;dangling&lt;/code&gt; will be returned instead to avoid returning potentially dangling results.</source>
          <target state="translated">Cuando algunos &lt;a href=&quot;../algorithm/ranges&quot;&gt;algoritmos limitan las&lt;/a&gt; que normalmente devuelven un iterador o un subrango de un &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; toman un valor de lado derecho en particular &lt;code&gt;Range&lt;/code&gt; argumento de que no los modelos de exposici&amp;oacute;n de s&amp;oacute;lo concepto &lt;a href=&quot;range&quot;&gt; &lt;code&gt;__ForwardingRange&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;dangling&lt;/code&gt; ser&amp;aacute; devuelto en su lugar para evitar volver potencialmente colgando resultados.</target>
        </trans-unit>
        <trans-unit id="8b1e13bc5e72c1d99187d326eff8cc95c6a2ce2a" translate="yes" xml:space="preserve">
          <source>When specializing a function template, its template arguments can be omitted if &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; can provide them from the function arguments:</source>
          <target state="translated">Al especializar una plantilla de funci&amp;oacute;n, sus argumentos de plantilla se pueden omitir si &lt;a href=&quot;template_argument_deduction&quot;&gt;la deducci&amp;oacute;n de argumentos de plantilla&lt;/a&gt; puede proporcionarlos a partir de los argumentos de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="ca2cbab4c43c7973149386ddec137d524c3e9fe8" translate="yes" xml:space="preserve">
          <source>When string literal concatenation takes place in &lt;a href=&quot;translation_phases&quot;&gt;translation phase 6&lt;/a&gt;, user-defined string literals are concatenated as well, and their ud-suffixes are ignored for the purpose of concatenation, except that only one suffix may appear on all concatenated literals:</source>
          <target state="translated">Cuando la concatenaci&amp;oacute;n literal de cadenas tiene lugar en la &lt;a href=&quot;translation_phases&quot;&gt;fase de traducci&amp;oacute;n 6&lt;/a&gt; , los literales de cadena definidos por el usuario tambi&amp;eacute;n se concatenan, y sus sufijos ud se ignoran a efectos de concatenaci&amp;oacute;n, excepto que solo puede aparecer un sufijo en todos los literales concatenados:</target>
        </trans-unit>
        <trans-unit id="1799979c98bbbebaef89ed6f1828299ab2b6a5e5" translate="yes" xml:space="preserve">
          <source>When such member function is declared in class X, it performs conversion from X to conversion-type-id:</source>
          <target state="translated">Cuando dicha función de miembro se declara en la clase X,realiza la conversión de X a conversión-tipo-id:</target>
        </trans-unit>
        <trans-unit id="1b9fe1265be0c139fe6cde0ba421b142a03ada23" translate="yes" xml:space="preserve">
          <source>When template arguments are provided, or, for &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;function&lt;/a&gt; and &lt;a href=&quot;deduction_guide&quot;&gt;class&lt;/a&gt;(since C++17) templates only, deduced, they are substituted for the template parameters to obtain a</source>
          <target state="translated">Cuando se proporcionan argumentos de plantilla, o, solo para deducir las plantillas de &lt;a href=&quot;function_template#Template_argument_deduction&quot;&gt;funci&amp;oacute;n&lt;/a&gt; y &lt;a href=&quot;deduction_guide&quot;&gt;clase&lt;/a&gt; (desde C ++ 17), se sustituyen por los par&amp;aacute;metros de plantilla para obtener un</target>
        </trans-unit>
        <trans-unit id="55f3e3f1e06a97818ce0ffb33865599309fb29ae" translate="yes" xml:space="preserve">
          <source>When the</source>
          <target state="translated">Cuando el</target>
        </trans-unit>
        <trans-unit id="aa5703929047ae870cd9bedc4f9eebb911b80493" translate="yes" xml:space="preserve">
          <source>When the argument is a class template, only the primary template is considered when matching the parameter. The partial specializations, if any, are only considered when a specialization based on this template template parameter happens to be instantiated.</source>
          <target state="translated">Cuando el argumento es una plantilla de clase,sólo se considera la plantilla primaria cuando coincide con el parámetro.Las especializaciones parciales,si las hay,sólo se consideran cuando una especialización basada en este parámetro de plantilla de plantilla resulta ser instanciada.</target>
        </trans-unit>
        <trans-unit id="657c97ad1dccca00440cdc8eb7bd687219c46fbe" translate="yes" xml:space="preserve">
          <source>When the asynchronous operation is ready to send a result to the creator, it can do so by modifying</source>
          <target state="translated">Cuando la operación asíncrona está lista para enviar un resultado al creador,puede hacerlo modificando</target>
        </trans-unit>
        <trans-unit id="b3e1fc309740231aa065058d4a26e16a2e51f547" translate="yes" xml:space="preserve">
          <source>When the compiler encounters a user-defined literal with ud-suffix&lt;code&gt;X&lt;/code&gt;, it performs &lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;unqualified name lookup&lt;/a&gt;, looking for a function with the name &lt;code&gt;operator &quot;&quot; X&lt;/code&gt;. If the lookup does not find a declaration, the program is ill-formed. Otherwise,</source>
          <target state="translated">Cuando el compilador encuentra un literal con ud-sufijo definido por el usuario &lt;code&gt;X&lt;/code&gt; , realiza &lt;a href=&quot;lookup#Unqualified_name_lookup&quot;&gt;b&amp;uacute;squeda de nombre no calificado&lt;/a&gt; , en busca de una funci&amp;oacute;n con el nombre &lt;code&gt;operator &quot;&quot; X&lt;/code&gt; . Si la b&amp;uacute;squeda no encuentra una declaraci&amp;oacute;n, el programa est&amp;aacute; mal formado. De otra manera,</target>
        </trans-unit>
        <trans-unit id="a6e3ba42f8de770e69687876d93e30231038db0e" translate="yes" xml:space="preserve">
          <source>When the compiler encounters an unknown name in a program, it associates it with the declaration that introduced the name by means of &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, except for the &lt;a href=&quot;dependent_name&quot;&gt;dependent names&lt;/a&gt; in template declarations and definitions (for those names, the compiler determines whether they name a type, a template, or some other entity, which may require &lt;a href=&quot;dependent_name&quot;&gt;explicit disambiguation&lt;/a&gt;).</source>
          <target state="translated">Cuando el compilador encuentra un nombre desconocido en un programa, lo asocia con la declaraci&amp;oacute;n que introdujo el nombre mediante la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; de nombres , excepto los &lt;a href=&quot;dependent_name&quot;&gt;nombres dependientes&lt;/a&gt; en las declaraciones y definiciones de plantillas (para esos nombres, el compilador determina si nombran un tipo , una plantilla o alguna otra entidad, que puede requerir &lt;a href=&quot;dependent_name&quot;&gt;una desambiguaci&amp;oacute;n expl&amp;iacute;cita&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="3ffc67b2c989f365607047bd77316e5ecdadcda9" translate="yes" xml:space="preserve">
          <source>When the condition variable is notified, a timeout expires, or a &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;spurious wakeup&lt;/a&gt; occurs, the thread is awakened, and the mutex is atomically reacquired. The thread should then check the condition and resume waiting if the wake up was spurious.</source>
          <target state="translated">Cuando se notifica la variable de condici&amp;oacute;n, caduca el tiempo de espera o se produce una &lt;a href=&quot;https://en.wikipedia.org/wiki/Spurious_wakeup&quot;&gt;activaci&amp;oacute;n espuria&lt;/a&gt; , se despierta el subproceso y se adquiere el mutex at&amp;oacute;micamente. El subproceso debe verificar la condici&amp;oacute;n y reanudar la espera si el despertar fue espurio.</target>
        </trans-unit>
        <trans-unit id="16dd5023449c37e3ee571367f3544e6dbf21123f" translate="yes" xml:space="preserve">
          <source>When the coroutine state is destroyed either because it terminated via co_return or uncaught exception, or because it was destroyed via its handle, it does the following:</source>
          <target state="translated">Cuando se destruye el estado de corutina,ya sea porque terminó a través de co_retorno o excepción no capturada,o porque fue destruido a través de su mango,hace lo siguiente:</target>
        </trans-unit>
        <trans-unit id="d296094acb938c3d5a36e0feef5bea491289a47a" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being copy constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">Cuando se usa el asignador predeterminado, esto da como resultado que la clave se copie construida a partir de la &lt;code&gt;key&lt;/code&gt; y que el valor asignado se &lt;a href=&quot;../../language/value_initialization&quot;&gt;inicialice con valor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d9fddcbdad59ebcc2389e29ab9d251d255ff093b" translate="yes" xml:space="preserve">
          <source>When the default allocator is used, this results in the key being move constructed from &lt;code&gt;key&lt;/code&gt; and the mapped value being &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt;.</source>
          <target state="translated">Cuando se usa el asignador predeterminado, esto da como resultado que la clave se mueva construida a partir de la &lt;code&gt;key&lt;/code&gt; y que el valor asignado se &lt;a href=&quot;../../language/value_initialization&quot;&gt;inicialice con el valor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31f633e1dfad19457b495484c1fbe0072bbb264f" translate="yes" xml:space="preserve">
          <source>When the default semantics are not suitable, such as when the members must be compared out of order, or must use a comparison that's different from their natural comparison, then the programmer can write &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; and let the compiler generate the appropriate relational operators. The kind of relational operators generated depends on the return type of the user-defined &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando la sem&amp;aacute;ntica predeterminada no es adecuada, como cuando los miembros deben compararse fuera de orden, o deben usar una comparaci&amp;oacute;n que es diferente de su comparaci&amp;oacute;n natural, entonces el programador puede escribir el &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; y dejar que el compilador genere los operadores relacionales apropiados . El tipo de operadores relacionales generados depende del tipo de retorno del &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; definido por el usuario &amp;lt;=&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="5f0cf9abe0b614f53329302ad0d6b53be9c5214c" translate="yes" xml:space="preserve">
          <source>When the element type of an array is another array, it is said that the array is multidimensional:</source>
          <target state="translated">Cuando el tipo de elemento de una matriz es otra matriz,se dice que la matriz es multidimensional:</target>
        </trans-unit>
        <trans-unit id="8371d69254feffac85782c93e2437f4715cd1cb6" translate="yes" xml:space="preserve">
          <source>When the initializer is a prvalue, the move constructor call is often optimized out(until C++17)never made(since C++17), see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">Cuando el inicializador es un prvalue, la llamada del constructor de movimiento a menudo se optimiza (hasta C ++ 17) nunca se realiza (desde C ++ 17), consulte &lt;a href=&quot;copy_elision&quot;&gt;copia de elisi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="10770c6e57727da2d2faacfcf5bbaf211dbc1a9b" translate="yes" xml:space="preserve">
          <source>When the left operand has reference type, the assignment operator modifies the referred-to object.</source>
          <target state="translated">Cuando el operando izquierdo tiene el tipo de referencia,el operador de asignación modifica el objeto de referencia.</target>
        </trans-unit>
        <trans-unit id="0d0dbe17faf8b2da57c150cba1c216b9daf8702b" translate="yes" xml:space="preserve">
          <source>When the member type &lt;code&gt;pointer&lt;/code&gt; is not a raw pointer type, it is commonly referred to as a &quot;fancy pointer&quot;. Such pointers were introduced to support segmented memory architectures and are used today to access objects allocated in address spaces that differ from the homogeneous virtual address space that is accessed by raw pointers. An example of a fancy pointer is the mapping address-independent pointer &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost::interprocess::offset_ptr&lt;/a&gt;, which makes it possible to allocate node-based data structures such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; in shared memory and memory mapped files mapped in different addresses in every process. Fancy pointers can be used independently of the allocator that provided them, through the class template &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando el &lt;code&gt;pointer&lt;/code&gt; tipo de miembro no es un tipo de puntero sin formato, com&amp;uacute;nmente se conoce como un &quot;puntero elegante&quot;. Tales punteros se introdujeron para admitir arquitecturas de memoria segmentadas y se usan hoy para acceder a objetos asignados en espacios de direcciones que difieren del espacio de direcciones virtual homog&amp;eacute;neo al que acceden los punteros sin procesar. Un ejemplo de un puntero elegante es el puntero independiente de la direcci&amp;oacute;n de mapeo &lt;a href=&quot;http://www.boost.org/doc/libs/release/doc/html/interprocess/offset_ptr.html&quot;&gt;boost :: interprocess :: offset_ptr&lt;/a&gt; , que permite asignar estructuras de datos basadas en nodos como &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; en memoria compartida y archivos mapeados en memoria mapeados en diferentes direcciones en cada proceso Los punteros de fantas&amp;iacute;a se pueden usar independientemente del asignador que los proporcion&amp;oacute;, a trav&amp;eacute;s de la plantilla de clase &lt;code&gt;&lt;a href=&quot;../memory/pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e345263d3c16be0359604e2c7e37e80d322c6999" translate="yes" xml:space="preserve">
          <source>When the name of a non-type template parameter is used in an expression within the body of the class template, it is an unmodifiable &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; unless its type was an lvalue reference type, or unless its type is a class type(since C++20).</source>
          <target state="translated">Cuando el nombre de un par&amp;aacute;metro de plantilla que no es de tipo se usa en una expresi&amp;oacute;n dentro del cuerpo de la plantilla de clase, es un valor &lt;a href=&quot;value_category&quot;&gt;variable&lt;/a&gt; no modificable a menos que su tipo sea un tipo de referencia de valor, o a menos que su tipo sea un tipo de clase (ya que C ++ 20)</target>
        </trans-unit>
        <trans-unit id="0dd4c2cd3956549ff3cdd1f8a7caf6b32e2cea01" translate="yes" xml:space="preserve">
          <source>When the noexcept-specification of a function template specialization is</source>
          <target state="translated">Cuando la especialización de una plantilla de funciones sin excepción es</target>
        </trans-unit>
        <trans-unit id="cc159284033553cbafc104d522a5cf1ae76e1549" translate="yes" xml:space="preserve">
          <source>When the number of variants is zero or one, the invocation of the callable object is implemented in constant time, i.e. it does not depend on &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">Cuando el n&amp;uacute;mero de variantes es cero o uno, la invocaci&amp;oacute;n del objeto invocable se implementa en tiempo constante, es decir, no depende del &lt;code&gt;sizeof...(Types)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8b02aaeadad3d163b0d5be165966951d5f6a133" translate="yes" xml:space="preserve">
          <source>When the parameter-list is not empty, an optional comma may precede a &lt;code&gt;...&lt;/code&gt; signifying a variadic function. This provides compatibility with C (which added a requirement for a comma when it adopted function prototypes from C++).</source>
          <target state="translated">Cuando la lista de par&amp;aacute;metros no est&amp;aacute; vac&amp;iacute;a, una coma opcional puede preceder a un &lt;code&gt;...&lt;/code&gt; que significa una funci&amp;oacute;n variable. Esto proporciona compatibilidad con C (que agreg&amp;oacute; un requisito para una coma cuando adopt&amp;oacute; prototipos de funci&amp;oacute;n de C ++).</target>
        </trans-unit>
        <trans-unit id="eadbea007ec076285100c5cbd07b8a2dc8928700" translate="yes" xml:space="preserve">
          <source>When the parser encounters the character sequence &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself and not as the first character of the alternative token &lt;code&gt;&amp;lt;:&lt;/code&gt;. Thus &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; won't be wrongly treated as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando el analizador encuentra la secuencia de caracteres &lt;code&gt;&amp;lt;::&lt;/code&gt; y el car&amp;aacute;cter subsiguiente es ni &lt;code&gt;:&lt;/code&gt; ni &lt;code&gt;&amp;gt;&lt;/code&gt; , la &lt;code&gt;&amp;lt;&lt;/code&gt; se trata como un preprocesamiento TOKEN por s&amp;iacute; mismo y no como el primer car&amp;aacute;cter de la alternativa contador &lt;code&gt;&amp;lt;:&lt;/code&gt; . Por lo tanto, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;::&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; no se tratar&amp;aacute; err&amp;oacute;neamente como &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;[:&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc2032d32ca7885f140b25a96dcbee6c5397ce4" translate="yes" xml:space="preserve">
          <source>When the postfix increment and decrement appear in an expression, the corresponding user-defined function (&lt;code&gt;operator++&lt;/code&gt; or &lt;code&gt;operator--&lt;/code&gt;) is called with an integer argument &lt;code&gt;0&lt;/code&gt;. Typically, it is implemented as &lt;code&gt;T operator++(int)&lt;/code&gt;, where the argument is ignored. The postfix increment and decrement operator is usually implemented in terms of the prefix version:</source>
          <target state="translated">Cuando el incremento y la disminuci&amp;oacute;n de postfix aparecen en una expresi&amp;oacute;n, la funci&amp;oacute;n definida por el usuario correspondiente ( &lt;code&gt;operator++&lt;/code&gt; u &lt;code&gt;operator--&lt;/code&gt; ) se llama con un argumento entero &lt;code&gt;0&lt;/code&gt; . Por lo general, se implementa como &lt;code&gt;T operator++(int)&lt;/code&gt; , donde se ignora el argumento. El operador de incremento y disminuci&amp;oacute;n de postfix generalmente se implementa en t&amp;eacute;rminos de la versi&amp;oacute;n del prefijo:</target>
        </trans-unit>
        <trans-unit id="fd043f49a212d5450703bb9a052e4fa639f20396" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt;.</source>
          <target state="translated">Cuando la biblioteca de expresiones regulares necesita coincidir con dos caracteres &lt;code&gt;c1&lt;/code&gt; y &lt;code&gt;c2&lt;/code&gt; y el indicador &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::collate&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , ejecuta &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate(c1) == regex_traits&amp;lt;&amp;gt;::translate(c2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a73f957522574e9d880fc3def8f3dd16383a3e89" translate="yes" xml:space="preserve">
          <source>When the regex library needs to match two characters &lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt; and the flag &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, it executes &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt;.</source>
          <target state="translated">Cuando la biblioteca de expresiones regulares necesita coincidir con dos caracteres &lt;code&gt;c1&lt;/code&gt; y &lt;code&gt;c2&lt;/code&gt; y el indicador &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , ejecuta &lt;code&gt;regex_traits&amp;lt;&amp;gt;::translate_nocase(c1) == regex_traits&amp;lt;&amp;gt;::translate_nocase(c2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59285875d0142d5e8a1eb450e8a3f9927249ea97" translate="yes" xml:space="preserve">
          <source>When the result of specializing an alias template is a dependent &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt;, subsequent substitutions apply to that template-id:</source>
          <target state="translated">Cuando el resultado de especializar una plantilla de alias es un &lt;a href=&quot;templates#template-id&quot;&gt;id de plantilla&lt;/a&gt; dependiente , las sustituciones posteriores se aplican a ese id de plantilla:</target>
        </trans-unit>
        <trans-unit id="7e5e471d5aa433ec3a110b9d7e72faf3a90a04a9" translate="yes" xml:space="preserve">
          <source>When the same function template specialization matches more than one overloaded function template (this often results from &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;),</source>
          <target state="translated">Cuando la misma especializaci&amp;oacute;n de plantilla de funci&amp;oacute;n coincide con m&amp;aacute;s de una plantilla de funci&amp;oacute;n sobrecargada (esto a menudo resulta de &lt;a href=&quot;template_argument_deduction&quot;&gt;la deducci&amp;oacute;n de argumento de plantilla&lt;/a&gt; ),</target>
        </trans-unit>
        <trans-unit id="b2ff5fd15b40403883483bc89510d97f14914365" translate="yes" xml:space="preserve">
          <source>When the target type is</source>
          <target state="translated">Cuando el tipo de objetivo es</target>
        </trans-unit>
        <trans-unit id="511cb27754af79d62f22a1bf71b871d3d288ebcd" translate="yes" xml:space="preserve">
          <source>When the template-name of a simple-template-id names a constrained non-function template or a constrained template template-parameter, but not a member template that is a member of an unknown specialization, and all template-arguments in the simple-template-id are non-dependent, the associated constraints of the constrained template must be satisfied:</source>
          <target state="translated">Cuando el nombre de la plantilla de un identificador de plantilla simple nombra una plantilla sin funciones o un parámetro de plantilla restringido,pero no una plantilla miembro de una especialización desconocida,y todos los argumentos de la plantilla del identificador de plantilla simple no son dependientes,deben cumplirse las restricciones asociadas de la plantilla restringida:</target>
        </trans-unit>
        <trans-unit id="adb827bd0954ef807560ec125638e405788fa858" translate="yes" xml:space="preserve">
          <source>When the value of the argument corresponding to a non-type template parameter P that is declared with a dependent type is deduced from an expression, the template parameters in the type of P are deduced from the type of the value.</source>
          <target state="translated">Cuando se deduce de una expresión el valor del argumento correspondiente a un parámetro de plantilla no tipo P que se declara con un tipo dependiente,los parámetros de plantilla del tipo de P se deducen del tipo del valor.</target>
        </trans-unit>
        <trans-unit id="a1b257f783065293c124a619280ef8e578d72775" translate="yes" xml:space="preserve">
          <source>When this is the case, member functions &lt;code&gt;find&lt;/code&gt;, &lt;code&gt;contains&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, and &lt;code&gt;equal_range&lt;/code&gt; accept arguments of types other than &lt;code&gt;Key&lt;/code&gt; and expect that &lt;code&gt;Hash&lt;/code&gt; is callable with values of those types, and that &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; is a transparent comparison function such as &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando este es el caso, las funciones miembro &lt;code&gt;find&lt;/code&gt; , &lt;code&gt;contains&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; e &lt;code&gt;equal_range&lt;/code&gt; aceptan argumentos de tipos distintos de &lt;code&gt;Key&lt;/code&gt; y esperan que &lt;code&gt;Hash&lt;/code&gt; sea ​​invocable con valores de esos tipos, y que &lt;code&gt;Hash::transparent_key_equal&lt;/code&gt; es una funci&amp;oacute;n de comparaci&amp;oacute;n transparente como &lt;code&gt;std::equal_to&amp;lt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22fbcacb8ea8a01e09177002c1cd6a745c7d8006" translate="yes" xml:space="preserve">
          <source>When three-way comparison (such as &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt;) is provided, all six relational operators may be expressed through that:</source>
          <target state="translated">Cuando se proporciona una comparaci&amp;oacute;n de tres v&amp;iacute;as (como &lt;code&gt;&lt;a href=&quot;../string/byte/memcmp&quot;&gt;std::memcmp&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../string/basic_string/compare&quot;&gt;std::string::compare&lt;/a&gt;&lt;/code&gt; ), los seis operadores relacionales pueden expresarse a trav&amp;eacute;s de eso:</target>
        </trans-unit>
        <trans-unit id="1f2f2e919801487fefca6150ecd5b3b80daddef7" translate="yes" xml:space="preserve">
          <source>When three-way comparison is not required (such as when providing a &lt;code&gt;Compare&lt;/code&gt; argument to standard algorithms such as &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt;), &lt;a href=&quot;../locale/operator()&quot;&gt;&lt;code&gt;std::locale::operator()&lt;/code&gt;&lt;/a&gt; may be more appropriate.</source>
          <target state="translated">Cuando no se requiere una comparaci&amp;oacute;n de tres v&amp;iacute;as (como cuando se proporciona un argumento &lt;code&gt;Compare&lt;/code&gt; a algoritmos est&amp;aacute;ndar como &lt;code&gt;&lt;a href=&quot;../../algorithm/sort&quot;&gt;std::sort&lt;/a&gt;&lt;/code&gt; ), &lt;a href=&quot;../locale/operator()&quot;&gt; &lt;code&gt;std::locale::operator()&lt;/code&gt; &lt;/a&gt; puede ser m&amp;aacute;s apropiado.</target>
        </trans-unit>
        <trans-unit id="3b2aec7feac4af597a17debffe4c87be12d0ecab" translate="yes" xml:space="preserve">
          <source>When used as a &lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;template argument&lt;/a&gt;, &lt;code&gt;class T&lt;/code&gt; is a type template parameter named &lt;code&gt;T&lt;/code&gt;, not an unnamed non-type parameter whose type &lt;code&gt;T&lt;/code&gt; is introduced by elaborated type specifier.</source>
          <target state="translated">Cuando se usa como &lt;a href=&quot;template_parameters#Template_arguments&quot;&gt;argumento de plantilla&lt;/a&gt; , la &lt;code&gt;class T&lt;/code&gt; es un par&amp;aacute;metro de plantilla de tipo llamado &lt;code&gt;T&lt;/code&gt; , no un par&amp;aacute;metro sin nombre sin tipo cuyo tipo &lt;code&gt;T&lt;/code&gt; es introducido por un especificador de tipo elaborado.</target>
        </trans-unit>
        <trans-unit id="a89f99191dc9016965a45193765f04ce9fd16336" translate="yes" xml:space="preserve">
          <source>When used as a function argument and when &lt;a href=&quot;overload_resolution&quot;&gt;two overloads&lt;/a&gt; of the function are available, one taking rvalue reference parameter and the other taking lvalue reference to const parameter, an rvalue binds to the rvalue reference overload (thus, if both copy and move constructors are available, an rvalue argument invokes the &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, and likewise with copy and move assignment operators).</source>
          <target state="translated">Cuando se usa como argumento de funci&amp;oacute;n y cuando hay &lt;a href=&quot;overload_resolution&quot;&gt;dos sobrecargas&lt;/a&gt; de la funci&amp;oacute;n disponibles, una tomando el par&amp;aacute;metro de referencia rvalue y la otra tomando la referencia lvalue al par&amp;aacute;metro const, un rvalue se une a la sobrecarga de referencia rvalue (por lo tanto, si los constructores de copia y movimiento est&amp;aacute;n disponibles , un argumento rvalue invoca el &lt;a href=&quot;move_constructor&quot;&gt;constructor de movimiento&lt;/a&gt; , y de la misma manera con los operadores de asignaci&amp;oacute;n de copia y movimiento).</target>
        </trans-unit>
        <trans-unit id="f8ea00edd25f46b83546909c33b9f68661ba3e16" translate="yes" xml:space="preserve">
          <source>When used as an argument in a &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; expression, the placeholder objects are stored in the generated function object, and when that function object is invoked with unbound arguments, each placeholder &lt;code&gt;_N&lt;/code&gt; is replaced by the corresponding Nth unbound argument.</source>
          <target state="translated">Cuando se usa como argumento en una expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; , los objetos de marcador de posici&amp;oacute;n se almacenan en el objeto de funci&amp;oacute;n generado, y cuando ese objeto de funci&amp;oacute;n se invoca con argumentos &lt;code&gt;_N&lt;/code&gt; , cada marcador de posici&amp;oacute;n _N se reemplaza por el en&amp;eacute;simo argumento independiente correspondiente.</target>
        </trans-unit>
        <trans-unit id="4c90e24b8efd2362ba00ffddb7c37e312b7e82c3" translate="yes" xml:space="preserve">
          <source>When used at class scope, variable template declares a static data member template.</source>
          <target state="translated">Cuando se usa en el ámbito de la clase,la plantilla variable declara una plantilla de miembro de datos estáticos.</target>
        </trans-unit>
        <trans-unit id="d3e7747ab6e5ee83d7abf31291a18569eac0496f" translate="yes" xml:space="preserve">
          <source>When used immediately after whitespace-delimited input, e.g. after &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt;, &lt;code&gt;getline&lt;/code&gt; consumes the endline character left on the input stream by &lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;operator&amp;gt;&amp;gt;&lt;/a&gt;, and returns immediately. A common solution is to ignore all leftover characters on the line of input with &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; before switching to line-oriented input.</source>
          <target state="translated">Cuando se usa inmediatamente despu&amp;eacute;s de la entrada delimitada por espacios en blanco, por ejemplo, despu&amp;eacute;s de &lt;code&gt;int n; &lt;a href=&quot;../../io/cin&quot;&gt;std::cin&lt;/a&gt; &amp;gt;&amp;gt; n;&lt;/code&gt; , &lt;code&gt;getline&lt;/code&gt; consume el car&amp;aacute;cter de l&amp;iacute;nea final dejado en el flujo de entrada por el &lt;a href=&quot;../../io/basic_istream/operator_gtgt&quot;&gt;operador &amp;gt;&amp;gt;&lt;/a&gt; , y regresa inmediatamente. Una soluci&amp;oacute;n com&amp;uacute;n es ignorar todos los caracteres sobrantes en la l&amp;iacute;nea de entrada con &lt;code&gt;cin.ignore(&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../io/streamsize&quot;&gt;std::streamsize&lt;/a&gt;&amp;gt;::max(), '\n');&lt;/code&gt; antes de cambiar a entrada orientada a l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="810ee96ebb349b821e1635ff4d35660a0d38207d" translate="yes" xml:space="preserve">
          <source>When used in a class definition, &lt;code&gt;final&lt;/code&gt; specifies that this class may not appear in the base-specifier-list of another class definition (in other words, cannot be derived from). The program is ill-formed (a compile-time error is generated) otherwise. &lt;code&gt;final&lt;/code&gt; can also be used with a &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt; definition, in which case it has no effect (other than on the outcome of &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt;), since unions cannot be derived from).</source>
          <target state="translated">Cuando se usa en una definici&amp;oacute;n de clase, &lt;code&gt;final&lt;/code&gt; especifica que esta clase puede no aparecer en la lista de especificador base de otra definici&amp;oacute;n de clase (en otras palabras, no se puede derivar de). El programa est&amp;aacute; mal formado (se genera un error en tiempo de compilaci&amp;oacute;n) de lo contrario. &lt;code&gt;final&lt;/code&gt; tambi&amp;eacute;n se puede usar con una definici&amp;oacute;n de &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n&lt;/a&gt; , en cuyo caso no tiene ning&amp;uacute;n efecto (aparte del resultado de &lt;code&gt;&lt;a href=&quot;../types/is_final&quot;&gt;std::is_final&lt;/a&gt;&lt;/code&gt; ), ya que las uniones no pueden derivarse de).</target>
        </trans-unit>
        <trans-unit id="9305de135bb255cca457fdbece5abb6dd9a1674a" translate="yes" xml:space="preserve">
          <source>When used in a controlling expression of &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; or &lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elif&lt;/a&gt;, all signed integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; and all unsigned integer constants act as if they have type &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n de control de &lt;a href=&quot;../preprocessor/conditional&quot;&gt;#if&lt;/a&gt; o &lt;a href=&quot;http://en.cppreference.com/w/c/preprocessor/conditional.html&quot;&gt;#elif&lt;/a&gt; , todas las constantes enteras con signo act&amp;uacute;an como si tuvieran el tipo &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::intmax_t&lt;/a&gt;&lt;/code&gt; y todas las constantes enteras sin signo act&amp;uacute;an como si tuvieran el tipo &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uintmax_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b903d2e014bf8406262e3731d09165f67923eb1" translate="yes" xml:space="preserve">
          <source>When used in a virtual function declaration or definition, &lt;code&gt;final&lt;/code&gt; ensures that the function is virtual and specifies that it may not be overridden by derived classes. The program is ill-formed (a compile-time error is generated) otherwise.</source>
          <target state="translated">Cuando se usa en una declaraci&amp;oacute;n o definici&amp;oacute;n de funci&amp;oacute;n virtual, &lt;code&gt;final&lt;/code&gt; asegura que la funci&amp;oacute;n es virtual y especifica que no puede ser anulada por las clases derivadas. El programa est&amp;aacute; mal formado (se genera un error en tiempo de compilaci&amp;oacute;n) de lo contrario.</target>
        </trans-unit>
        <trans-unit id="1a6b7e3d85e506288364ecfff9f25bf551cd3185" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt;, parses the character input as a monetary value, as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;in&lt;/code&gt;, and stores the value in &lt;code&gt;mon&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n &lt;code&gt;in &amp;gt;&amp;gt; get_money(mon, intl)&lt;/code&gt; , analiza la entrada de caracteres como un valor monetario, seg&amp;uacute;n lo especificado por la faceta &lt;code&gt;&lt;a href=&quot;../../locale/money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; del entorno local actualmente imbuido &lt;code&gt;in&lt;/code&gt; , y almacena el valor en &lt;code&gt;mon&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dba580a9fb7386ece9bcb9047821c34efdbd2cc6" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt;, parses the character input as a date/time value according to format string &lt;code&gt;fmt&lt;/code&gt; according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the input stream &lt;code&gt;in&lt;/code&gt;. The resultant value is stored in a &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;tmb&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n &lt;code&gt;in &amp;gt;&amp;gt; get_time(tmb, fmt)&lt;/code&gt; , analiza la entrada de caracteres como un valor de fecha / hora de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; de acuerdo con la faceta &lt;code&gt;&lt;a href=&quot;../../locale/time_get&quot;&gt;std::time_get&lt;/a&gt;&lt;/code&gt; del entorno local actualmente imbuido en la secuencia de entrada &lt;code&gt;in&lt;/code&gt; . El valor resultante se almacena en un objeto &lt;code&gt;&lt;a href=&quot;../../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; que apunta &lt;code&gt;tmb&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f6b6002a8d5ee59f8db2c3ad5177196e34c65dc" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt;, converts the monetary value &lt;code&gt;mon&lt;/code&gt; to its character representation as specified by the &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n &lt;code&gt;out &amp;lt;&amp;lt; put_money(mon, intl)&lt;/code&gt; , convierte el valor monetario &lt;code&gt;mon&lt;/code&gt; en su representaci&amp;oacute;n de caracteres seg&amp;uacute;n lo especificado por la faceta &lt;code&gt;&lt;a href=&quot;../../locale/money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; del entorno local actualmente imbuido en &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf45d63014365fd6dcec8ecebade756fbe4b1751" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt;, converts the date and time information from a given calendar time &lt;code&gt;tmb&lt;/code&gt; to a character string according to format string &lt;code&gt;fmt&lt;/code&gt;, as if by calling &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt;, or analog (depending on &lt;code&gt;CharT&lt;/code&gt;), according to the &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; facet of the locale currently imbued in the output stream &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n &lt;code&gt;out &amp;lt;&amp;lt; put_time(tmb, fmt)&lt;/code&gt; , convierte la informaci&amp;oacute;n de fecha y hora de un tiempo de calendario dado &lt;code&gt;tmb&lt;/code&gt; en una cadena de caracteres de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; , como si llamara &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../chrono/c/wcsftime&quot;&gt;std::wcsftime&lt;/a&gt;&lt;/code&gt; , o anal&amp;oacute;gico (seg&amp;uacute;n &lt;code&gt;CharT&lt;/code&gt; ), de acuerdo con la faceta &lt;code&gt;&lt;a href=&quot;../../locale/time_put&quot;&gt;std::time_put&lt;/a&gt;&lt;/code&gt; del entorno local actualmente imbuido en la salida de flujo de &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4b7fe6253074e6b867e1474688d0f2693a1f7d0" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt;, where &lt;code&gt;out&lt;/code&gt; is an output stream with &lt;code&gt;char_type&lt;/code&gt; equal to &lt;code&gt;CharT&lt;/code&gt; and, for overloads 2-4, &lt;code&gt;traits_type&lt;/code&gt; equal to &lt;code&gt;Traits&lt;/code&gt;, behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;, which inserts into &lt;code&gt;out&lt;/code&gt; a sequence of characters &lt;code&gt;seq&lt;/code&gt; constructed as follows:</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n &lt;code&gt;out &amp;lt;&amp;lt; quoted(s, delim, escape)&lt;/code&gt; , donde &lt;code&gt;out&lt;/code&gt; es una secuencia de salida con &lt;code&gt;char_type&lt;/code&gt; igual a &lt;code&gt;CharT&lt;/code&gt; y, para sobrecargas 2-4, &lt;code&gt;traits_type&lt;/code&gt; igual a &lt;code&gt;Traits&lt;/code&gt; , se comporta como &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FunctiontedOutputFunction&lt;/a&gt; , que se inserta en &lt;code&gt;out&lt;/code&gt; una secuencia de caracteres &lt;code&gt;seq&lt;/code&gt; construida de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="d8ac1ad4097229286f1a455e696150cbe6d78fe1" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt;, clears all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n &lt;code&gt;out &amp;lt;&amp;lt; resetiosflags(mask)&lt;/code&gt; o &lt;code&gt;in &amp;gt;&amp;gt; resetiosflags(mask)&lt;/code&gt; , borra todos los indicadores de formato de la transmisi&amp;oacute;n &lt;code&gt;out&lt;/code&gt; o hacia &lt;code&gt;in&lt;/code&gt; seg&amp;uacute;n lo especificado por la &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="921ff88652686f85b631d9ceb7c724eb668d404a" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; sets the fill character of the stream &lt;code&gt;out&lt;/code&gt; to &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">Cuando se utiliza en una expresi&amp;oacute;n &lt;code&gt;out &amp;lt;&amp;lt; setfill(c)&lt;/code&gt; establece el car&amp;aacute;cter de relleno de la corriente de &lt;code&gt;out&lt;/code&gt; a &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cb9f3afac80724df521c61b025e7c53651f4eb2" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt;, sets all format flags of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; as specified by the &lt;code&gt;mask&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n &lt;code&gt;out &amp;lt;&amp;lt; setiosflags(mask)&lt;/code&gt; o &lt;code&gt;in &amp;gt;&amp;gt; setiosflags(mask)&lt;/code&gt; , establece todos los indicadores de formato de la secuencia &lt;code&gt;out&lt;/code&gt; o hacia &lt;code&gt;in&lt;/code&gt; seg&amp;uacute;n lo especificado por la &lt;code&gt;mask&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a87b307fde755e230f472b8260a494dc64a86904" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt;, sets the &lt;code&gt;precision&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n &lt;code&gt;out &amp;lt;&amp;lt; setprecision(n)&lt;/code&gt; o &lt;code&gt;in &amp;gt;&amp;gt; setprecision(n)&lt;/code&gt; , establece el par&amp;aacute;metro de &lt;code&gt;precision&lt;/code&gt; de la secuencia &lt;code&gt;out&lt;/code&gt; o &lt;code&gt;in&lt;/code&gt; exactamente &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6a94f6a0cf9d3d1d83f0c666f4d933e3aa6770f" translate="yes" xml:space="preserve">
          <source>When used in an expression &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; or &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt;, sets the &lt;code&gt;width&lt;/code&gt; parameter of the stream &lt;code&gt;out&lt;/code&gt; or &lt;code&gt;in&lt;/code&gt; to exactly &lt;code&gt;n&lt;/code&gt;.</source>
          <target state="translated">Cuando se usa en una expresi&amp;oacute;n &lt;code&gt;out &amp;lt;&amp;lt; setw(n)&lt;/code&gt; o &lt;code&gt;in &amp;gt;&amp;gt; setw(n)&lt;/code&gt; , establece el par&amp;aacute;metro de &lt;code&gt;width&lt;/code&gt; de la secuencia &lt;code&gt;out&lt;/code&gt; o &lt;code&gt;in&lt;/code&gt; exactamente &lt;code&gt;n&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="101375a819be934deee54d8762c9258b209a7717" translate="yes" xml:space="preserve">
          <source>When used with &lt;a href=&quot;new&quot;&gt;new[]-expression&lt;/a&gt;, the size of an array may be zero; such an array has no elements:</source>
          <target state="translated">Cuando se usa con la &lt;a href=&quot;new&quot;&gt;nueva expresi&amp;oacute;n []&lt;/a&gt; , el tama&amp;ntilde;o de una matriz puede ser cero; Tal matriz no tiene elementos:</target>
        </trans-unit>
        <trans-unit id="b5d2f5c5efbba3505a9a104fbd815a3de55bb31d" translate="yes" xml:space="preserve">
          <source>When used with a (non-const) object that has copy-on-write semantics, the range-based for loop may trigger a deep copy by (implicitly) calling the non-const &lt;code&gt;begin()&lt;/code&gt; member function. If that is undesirable (for instance because the loop is not actually modifying the object), &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; can be used:</source>
          <target state="translated">Cuando se usa con un objeto (no const) que tiene una sem&amp;aacute;ntica de copia en escritura, el bucle for basado en rango puede desencadenar una copia profunda al (impl&amp;iacute;citamente) llamar a la funci&amp;oacute;n miembro no const &lt;code&gt;begin()&lt;/code&gt; . Si eso no es deseable (por ejemplo, porque el bucle no est&amp;aacute; modificando realmente el objeto), se puede usar &lt;code&gt;&lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf6c1868cc765347d09cc64a36b7be944f8dd8fb" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Cuando se utiliza una configuraci&amp;oacute;n regional que no es de conversi&amp;oacute;n (la configuraci&amp;oacute;n regional predeterminada no es de conversi&amp;oacute;n), la anulaci&amp;oacute;n de esta funci&amp;oacute;n en &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; puede optimizarse para E / S masivas de copia cero (anulando &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sgetn&quot;&gt;std::streambuf::xsgetn&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="0986776c60c5c2e2615f44185f446f8dc94a3805" translate="yes" xml:space="preserve">
          <source>When using a non-converting locale (the default locale is non-converting), the overrider of this function in &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; may be optimized for zero-copy bulk I/O (by means of overriding &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Cuando se utiliza una configuraci&amp;oacute;n regional no convertible (la configuraci&amp;oacute;n regional predeterminada no se convierte), la anulaci&amp;oacute;n de esta funci&amp;oacute;n en &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; se puede optimizar para E / S masivas de copia cero (mediante la anulaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../basic_streambuf/sputn&quot;&gt;std::streambuf::xsputn&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="cbe8e117435e8afed934a7b78bf92466217654af" translate="yes" xml:space="preserve">
          <source>When using parallel execution policy, it is the programmer's responsibility to avoid data races and deadlocks:</source>
          <target state="translated">Cuando se utiliza la política de ejecución paralela,es responsabilidad del programador evitar las carreras de datos y los bloqueos:</target>
        </trans-unit>
        <trans-unit id="7dd97b15bcdd677ac393fd1531f4ab0a23cce05d" translate="yes" xml:space="preserve">
          <source>When working with the C++ container library, the proper type for the difference between iterators is the member typedef &lt;code&gt;difference_type&lt;/code&gt;, which is often synonymous with &lt;code&gt;std::ptrdiff_t&lt;/code&gt;.</source>
          <target state="translated">Cuando se trabaja con la biblioteca de contenedores C ++, el tipo adecuado para la diferencia entre iteradores es el miembro typedef &lt;code&gt;difference_type&lt;/code&gt; , que a menudo es sin&amp;oacute;nimo de &lt;code&gt;std::ptrdiff_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="744601d71e0a622aae7e049c96112c98fceb410b" translate="yes" xml:space="preserve">
          <source>When writing characters, &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; is more efficient, since it avoids the overhead of constructing and destructing the sentry object once per character.</source>
          <target state="translated">Al escribir caracteres, &lt;code&gt;&lt;a href=&quot;ostreambuf_iterator&quot;&gt;std::ostreambuf_iterator&lt;/a&gt;&lt;/code&gt; es m&amp;aacute;s eficiente, ya que evita la sobrecarga de construir y destruir el objeto centinela una vez por car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="6d6a0d2f37c6465daaf393a9cbcafd860707692e" translate="yes" xml:space="preserve">
          <source>Whenever a reference is bound to a temporary or to a subobject thereof, the lifetime of the temporary is extended to match the lifetime of the reference, with the following exceptions:</source>
          <target state="translated">Siempre que una referencia está vinculada a un temporal o a un subobjeto del mismo,la duración del temporal se prolonga para que coincida con la duración de la referencia,con las siguientes excepciones:</target>
        </trans-unit>
        <trans-unit id="a47ec6b9ae119d13c79d3ecadb3d357577c88006" translate="yes" xml:space="preserve">
          <source>Whenever an attempt is made to read or modify the stored value of an object of type &lt;code&gt;DynamicType&lt;/code&gt; through a glvalue of type &lt;code&gt;AliasedType&lt;/code&gt;, the behavior is undefined unless one of the following is true:</source>
          <target state="translated">Cada vez que se intenta leer o modificar el valor almacenado de un objeto de tipo &lt;code&gt;DynamicType&lt;/code&gt; a trav&amp;eacute;s de un valor de tipo &lt;code&gt;AliasedType&lt;/code&gt; , el comportamiento es indefinido a menos que uno de los siguientes sea verdadero:</target>
        </trans-unit>
        <trans-unit id="9101581b76be4f749934d75b25f2b3f56089760f" translate="yes" xml:space="preserve">
          <source>Whenever the arguments are some C++ basic types, there are no ADL-associated namespaces. Hence, those scenarios are identical with the non-ADL examples above.</source>
          <target state="translated">Siempre que los argumentos son algunos tipos básicos de C++,no hay espacios de nombres asociados a ADL.Por lo tanto,esos escenarios son idénticos a los ejemplos no ADL anteriores.</target>
        </trans-unit>
        <trans-unit id="77eef7bb821cc1a1b8c9c6ab0b0e1de54272ecdc" translate="yes" xml:space="preserve">
          <source>Where &lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;strict aliasing&lt;/a&gt; prohibits examining the same memory as values of two different types, &lt;code&gt;std::memcpy&lt;/code&gt; may be used to convert the values.</source>
          <target state="translated">Cuando el &lt;a href=&quot;../../language/objects#Strict_aliasing&quot;&gt;alias estricto&lt;/a&gt; proh&amp;iacute;be examinar la misma memoria que los valores de dos tipos diferentes, &lt;code&gt;std::memcpy&lt;/code&gt; puede usarse para convertir los valores.</target>
        </trans-unit>
        <trans-unit id="c53cccdafaba481597a722fa2959cf7a851c2ce1" translate="yes" xml:space="preserve">
          <source>Where &lt;code&gt;weak_this&lt;/code&gt; is the hidden mutable &lt;code&gt;std::weak_ptr&lt;/code&gt; member of &lt;code&gt;std::shared_from_this&lt;/code&gt;. The assignment to the &lt;code&gt;weak_this&lt;/code&gt; member is not atomic and conflicts with any potentially concurrent access to the same object. This ensures that future calls to &lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt;&lt;code&gt;shared_from_this()&lt;/code&gt;&lt;/a&gt; would share ownership with the &lt;code&gt;shared_ptr&lt;/code&gt; created by this raw pointer constructor.</source>
          <target state="translated">Donde &lt;code&gt;weak_this&lt;/code&gt; es el miembro mutable oculto &lt;code&gt;std::weak_ptr&lt;/code&gt; de &lt;code&gt;std::shared_from_this&lt;/code&gt; . La asignaci&amp;oacute;n al miembro &lt;code&gt;weak_this&lt;/code&gt; no es at&amp;oacute;mica y entra en conflicto con cualquier acceso potencialmente concurrente al mismo objeto. Esto garantiza que las futuras llamadas a &lt;a href=&quot;../enable_shared_from_this/shared_from_this&quot;&gt; &lt;code&gt;shared_from_this()&lt;/code&gt; &lt;/a&gt; compartir&amp;iacute;an la propiedad con &lt;code&gt;shared_ptr&lt;/code&gt; creado por este constructor de puntero sin formato .</target>
        </trans-unit>
        <trans-unit id="328d7d83b15b53db0928e0b402874f758e429540" translate="yes" xml:space="preserve">
          <source>Where R is the ordering category type defined above.</source>
          <target state="translated">Donde R es el tipo de categoría de ordenamiento definido anteriormente.</target>
        </trans-unit>
        <trans-unit id="582de0628906c31348c3039934a0f8563d8361ee" translate="yes" xml:space="preserve">
          <source>Where a constant expression is grammatically required, including:</source>
          <target state="translated">Donde se requiere una expresión constante gramaticalmente,incluyendo:</target>
        </trans-unit>
        <trans-unit id="a8ebf782644f9429bc1fc6810b05c7e9c3c03635" translate="yes" xml:space="preserve">
          <source>Where applicable, &lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;tag dispatch&lt;/a&gt;, &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt;, and, if available, &lt;a href=&quot;constraints&quot;&gt;concepts&lt;/a&gt;, are usually preferred over direct use of SFINAE.</source>
          <target state="translated">En su caso, el &lt;a href=&quot;../iterator/iterator_tags#Example&quot;&gt;despacho de etiquetas&lt;/a&gt; , &lt;a href=&quot;static_assert&quot;&gt;static_assert&lt;/a&gt; y, si est&amp;aacute;n disponibles, &lt;a href=&quot;constraints&quot;&gt;conceptos&lt;/a&gt; , generalmente se prefieren al uso directo de SFINAE.</target>
        </trans-unit>
        <trans-unit id="c16c807394bc564276f7b672bb496e133719e00a" translate="yes" xml:space="preserve">
          <source>Where built-in operators return &lt;code&gt;bool&lt;/code&gt;, most &lt;a href=&quot;operators&quot;&gt;user-defined overloads&lt;/a&gt; also return &lt;code&gt;bool&lt;/code&gt; so that the user-defined operators can be used in the same manner as the built-ins. However, in a user-defined operator overload, any type can be used as return type (including &lt;code&gt;void&lt;/code&gt;).</source>
          <target state="translated">Cuando los operadores integrados devuelven &lt;code&gt;bool&lt;/code&gt; , la mayor&amp;iacute;a de &lt;a href=&quot;operators&quot;&gt;las sobrecargas definidas&lt;/a&gt; por el usuario tambi&amp;eacute;n devuelven &lt;code&gt;bool&lt;/code&gt; para que los operadores definidos por el usuario puedan usarse de la misma manera que los incorporados. Sin embargo, en una sobrecarga de operador definida por el usuario, cualquier tipo puede usarse como tipo de retorno (incluido &lt;code&gt;void&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1889e8caa29d75a1818f0a931ca52b8fe1415229" translate="yes" xml:space="preserve">
          <source>Where class-name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">Cuando el nombre de la clase debe nombrar la clase actual (o la instanciación actual de una plantilla de clase),o,cuando se declare en el ámbito del espacio de nombres o en una declaración de amigo,debe ser un nombre de clase calificado.</target>
        </trans-unit>
        <trans-unit id="03f3df53bc82d8371ebdee50da2998db2016a301" translate="yes" xml:space="preserve">
          <source>Where class_name must name the current class (or current instantiation of a class template), or, when declared at namespace scope or in a friend declaration, it must be a qualified class name.</source>
          <target state="translated">Donde nombre_clase debe nombrar la clase actual (o la instanciación actual de una plantilla de clase),o,cuando se declare en el ámbito del espacio de nombres o en una declaración de amigo,debe ser un nombre de clase calificado.</target>
        </trans-unit>
        <trans-unit id="d7ad86ffa9afba91a0ed8ad0042113ba1987e71e" translate="yes" xml:space="preserve">
          <source>Where direct access to the elements of the container is not wanted or not possible or distinguishing between lvalue &lt;code&gt;c[i] = v;&lt;/code&gt; and rvalue &lt;code&gt;v = c[i];&lt;/code&gt; usage, operator[] may return a proxy. see for example &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando el acceso directo a los elementos del contenedor no es deseable o no es posible o se distingue entre lvalue &lt;code&gt;c[i] = v;&lt;/code&gt; y rvalue &lt;code&gt;v = c[i];&lt;/code&gt; uso, el operador [] puede devolver un proxy. ver por ejemplo &lt;code&gt;&lt;a href=&quot;../utility/bitset/operator_at&quot;&gt;std::bitset::operator[]&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7544bd14fb0127b9e675324fe322b59d1667847a" translate="yes" xml:space="preserve">
          <source>Where necessary, the compiler may implicitly define the &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt;, &lt;a href=&quot;copy_constructor&quot;&gt;copy constructor&lt;/a&gt;, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt;, &lt;a href=&quot;as_operator&quot;&gt;copy assignment operator&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment operator&lt;/a&gt;, and the &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;.</source>
          <target state="translated">Cuando sea necesario, el compilador puede definir impl&amp;iacute;citamente el &lt;a href=&quot;default_constructor&quot;&gt;constructor predeterminado&lt;/a&gt; , el constructor de &lt;a href=&quot;copy_constructor&quot;&gt;copia&lt;/a&gt; , &lt;a href=&quot;move_constructor&quot;&gt;el constructor de movimiento&lt;/a&gt; , el &lt;a href=&quot;as_operator&quot;&gt;operador de asignaci&amp;oacute;n de copia&lt;/a&gt; , el &lt;a href=&quot;move_operator&quot;&gt;operador de asignaci&amp;oacute;n de movimiento&lt;/a&gt; y el &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0d39fc5aa0a8a0218582cd66f3e979536d5af157" translate="yes" xml:space="preserve">
          <source>Where the input for &lt;code&gt;real&lt;/code&gt; and &lt;code&gt;imaginary&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.  If an error occurs calls &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt;.</source>
          <target state="translated">Donde la entrada de &lt;code&gt;real&lt;/code&gt; y &lt;code&gt;imaginary&lt;/code&gt; debe ser convertible en &lt;code&gt;T&lt;/code&gt; . Si se produce un error, llame a &lt;code&gt;is.setstate(ios_base::failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f939b6cebddd88e076c47ab7052d80f4f9691f8f" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is raised by the mathematical library functions is unspecified in general, but may be explicitly specified in the description of the function (e.g. &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; es generado por las funciones de la biblioteca matem&amp;aacute;tica no est&amp;aacute; especificado en general, pero puede especificarse expl&amp;iacute;citamente en la descripci&amp;oacute;n de la funci&amp;oacute;n (por ejemplo, &lt;code&gt;&lt;a href=&quot;rint&quot;&gt;std::rint&lt;/a&gt;&lt;/code&gt; vs &lt;code&gt;&lt;a href=&quot;nearbyint&quot;&gt;std::nearbyint&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="b0ef570637f0306b69eab32021437454f7aeaff6" translate="yes" xml:space="preserve">
          <source>Whether &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, and &lt;code&gt;long long&lt;/code&gt; bit fields that aren't explicitly &lt;code&gt;signed&lt;/code&gt; or &lt;code&gt;unsigned&lt;/code&gt; are signed or unsigned.</source>
          <target state="translated">Si los campos de bit &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; y &lt;code&gt;long long&lt;/code&gt; que no est&amp;aacute;n expl&amp;iacute;citamente &lt;code&gt;signed&lt;/code&gt; o &lt;code&gt;unsigned&lt;/code&gt; est&amp;aacute;n firmados o sin firmar.</target>
        </trans-unit>
        <trans-unit id="21520e7d3c4c9457f0b61f7da5be4c28fb0b2934" translate="yes" xml:space="preserve">
          <source>Whether implemented or not, this function is normally called by &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; if the get area is empty.</source>
          <target state="translated">Ya sea implementada o no, esta funci&amp;oacute;n normalmente es llamada por &lt;code&gt;std::basic_streambuf::in_avail&lt;/code&gt; si el &amp;aacute;rea de obtenci&amp;oacute;n est&amp;aacute; vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="be104b12a99ce4ffaccf474c68581deb485380ae" translate="yes" xml:space="preserve">
          <source>Whether or not the operation succeeds, the stream is no longer associated with a file, and the buffer allocated by &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt;, if any, is also disassociated and deallocated if automatic allocation was used.</source>
          <target state="translated">Independientemente de si la operaci&amp;oacute;n tiene &amp;eacute;xito o no, la secuencia ya no est&amp;aacute; asociada con un archivo, y el b&amp;uacute;fer asignado por &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;setvbuf&quot;&gt;std::setvbuf&lt;/a&gt;&lt;/code&gt; , si lo hay, tambi&amp;eacute;n se desasocia y desasigna si se utiliza la asignaci&amp;oacute;n autom&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="d46a08839feaec08adbd051313d8939dc9b21b97" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; uses pos_format for formatting positive values and neg_format for formatting negative values, &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; uses neg_format for parsing all monetary values: it assumes that neg_format is compatible with pos_format.</source>
          <target state="translated">Mientras que &lt;code&gt;&lt;a href=&quot;../money_put&quot;&gt;std::money_put&lt;/a&gt;&lt;/code&gt; usa pos_format para formatear valores positivos y neg_format para formatear valores negativos, &lt;code&gt;&lt;a href=&quot;../money_get&quot;&gt;std::money_get&lt;/a&gt;&lt;/code&gt; usa neg_format para analizar todos los valores monetarios: se supone que neg_format es compatible con pos_format.</target>
        </trans-unit>
        <trans-unit id="4882bae700593de48c423f4a185a6a87fc8e0168" translate="yes" xml:space="preserve">
          <source>While &lt;code&gt;codecvt&lt;/code&gt; supports N:M conversions (e.g. UTF-16 to UTF-8, where two internal characters may be necessary to decide what external characters to output), &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; can only use &lt;code&gt;codecvt&lt;/code&gt; facets that define a 1:N conversion, that is it must be able to process one internal character at a time when writing to a file.</source>
          <target state="translated">Si bien &lt;code&gt;codecvt&lt;/code&gt; admite las conversiones N: M (por ejemplo, UTF-16 a UTF-8, donde pueden ser necesarios dos caracteres internos para decidir qu&amp;eacute; caracteres externos emitir), &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; solo puede usar facetas &lt;code&gt;codecvt&lt;/code&gt; que definen una conversi&amp;oacute;n 1: N, es decir, debe poder procesar un car&amp;aacute;cter interno a la vez al escribir en un archivo.</target>
        </trans-unit>
        <trans-unit id="ce692aaa12dee04f1b7857662f9696d7b39d104a" translate="yes" xml:space="preserve">
          <source>While all fundamental types &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; are integer types, a library may define exact types that aren't integers, e.g. a rational arithmetics type representing fractions.</source>
          <target state="translated">Si bien todos los tipos fundamentales &lt;code&gt;T&lt;/code&gt; para los cuales &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact==true&lt;/code&gt; son tipos enteros, una biblioteca puede definir tipos exactos que no son enteros, por ejemplo, un tipo de aritm&amp;eacute;tica racional que representa fracciones.</target>
        </trans-unit>
        <trans-unit id="5c6831ef0dd5db6345bc002124c0babc32834531" translate="yes" xml:space="preserve">
          <source>While in C++, the scope of the init-statement and the scope of statement are one and the same, in C the scope of statement is nested within the scope of init-statement:</source>
          <target state="translated">Mientras que en C++el alcance de la declaración inicial y el alcance de la declaración son uno y el mismo,en C el alcance de la declaración se anida dentro del alcance de la declaración inicial:</target>
        </trans-unit>
        <trans-unit id="f6a198ae06795de880db0e81ff4942b69fa0d198" translate="yes" xml:space="preserve">
          <source>While it's not true for fundamental C++ floating-point types, a third-party floating-point type &lt;code&gt;T&lt;/code&gt; may exist such that &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt;.</source>
          <target state="translated">Si bien no es cierto para los tipos fundamentales de coma flotante de C ++, puede existir un tipo &lt;code&gt;T&lt;/code&gt; de coma flotante de terceros de manera que &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::lowest() != -&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdb7f0b47137662d6f73c67c92fda0e6b0d6c3b8" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::swprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">Si bien las cadenas estrechas proporcionan &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;std::snprintf&lt;/a&gt;&lt;/code&gt; , lo que hace posible determinar el tama&amp;ntilde;o del b&amp;uacute;fer de salida requerido, no hay equivalente para cadenas anchas, y para determinar el tama&amp;ntilde;o del b&amp;uacute;fer, el programa puede necesitar llamar a &lt;code&gt;std::swprintf&lt;/code&gt; , verificar el valor del resultado y reasignar un b&amp;uacute;fer m&amp;aacute;s grande, intentando nuevamente hasta que tenga &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="2aad7bc15a2badfcfdc2770354ab9bdb48f5b39a" translate="yes" xml:space="preserve">
          <source>While narrow strings provide &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt;, which makes it possible to determine the required output buffer size, there is no equivalent for wide strings, and in order to determine the buffer size, the program may need to call &lt;code&gt;std::vswprintf&lt;/code&gt;, check the result value, and reallocate a larger buffer, trying again until successful.</source>
          <target state="translated">Si bien las cadenas estrechas proporcionan &lt;code&gt;&lt;a href=&quot;vfprintf&quot;&gt;std::vsnprintf&lt;/a&gt;&lt;/code&gt; , lo que hace posible determinar el tama&amp;ntilde;o del b&amp;uacute;fer de salida requerido, no hay un equivalente para cadenas anchas, y para determinar el tama&amp;ntilde;o del b&amp;uacute;fer, el programa puede necesitar llamar a &lt;code&gt;std::vswprintf&lt;/code&gt; , verificar el valor del resultado y reasignar un b&amp;uacute;fer m&amp;aacute;s grande, intentando nuevamente hasta que tenga &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="3d1b9b2d47483d07a008f2f3460cb714ec262b09" translate="yes" xml:space="preserve">
          <source>While objects of any complete type and cv pointers to void may be thrown as exception objects, all standard library functions throw anonymous temporary objects by value, and the types of those objects are derived (directly or indirectly) from &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt;. User-defined exceptions usually follow this pattern.&lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Si bien los objetos de cualquier tipo completo y los punteros cv que se anulen pueden ser arrojados como objetos de excepci&amp;oacute;n, todas las funciones est&amp;aacute;ndar de la biblioteca arrojan objetos temporales an&amp;oacute;nimos por valor, y los tipos de esos objetos se derivan (directa o indirectamente) de &lt;code&gt;&lt;a href=&quot;../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; . Las excepciones definidas por el usuario generalmente siguen este patr&amp;oacute;n. &lt;sup id=&quot;cite_ref-7&quot;&gt;&lt;a href=&quot;exceptions#cite_note-7&quot;&gt;[7] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-8&quot;&gt;&lt;a href=&quot;exceptions#cite_note-8&quot;&gt;[8] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-9&quot;&gt;&lt;a href=&quot;exceptions#cite_note-9&quot;&gt;[9]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="dd014792b0e30b26904af64ce06af14ab14dade5" translate="yes" xml:space="preserve">
          <source>While the names &quot;gptr&quot; and &quot;egptr&quot; refer to the get area, the name &quot;eback&quot; refers to the end of the putback area: stepping backwards from gptr, characters can be put back until eback.</source>
          <target state="translated">Mientras que los nombres &quot;gptr&quot; y &quot;egptr&quot; se refieren al área de get,el nombre &quot;eback&quot; se refiere al final del área de putback:retrocediendo desde gptr,los caracteres se pueden poner de nuevo hasta eback.</target>
        </trans-unit>
        <trans-unit id="e6aed0f8bf11c0e2ccb4abb52781539645453846" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">Si bien la firma no necesita tener &lt;code&gt;const &amp;amp;&lt;/code&gt; , la funci&amp;oacute;n no debe modificar los objetos que se le pasan y debe poder aceptar todos los valores de type (posiblemente const) &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; independientemente de la &lt;a href=&quot;../../language/value_category&quot;&gt;categor&amp;iacute;a&lt;/a&gt; de valores (por lo tanto, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; no est&amp;aacute; permitido , tampoco lo es &lt;code&gt;Type1&lt;/code&gt; a menos que para &lt;code&gt;Type1&lt;/code&gt; un movimiento sea equivalente a una copia (desde C ++ 11)).</target>
        </trans-unit>
        <trans-unit id="b82e35d8b86e026d1b1ef3ee87feedc4e74f5048" translate="yes" xml:space="preserve">
          <source>While the signature does not need to have &lt;code&gt;const &amp;amp;&lt;/code&gt;, the function must not modify the objects passed to it and must be able to accept all values of type (possibly const) &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; regardless of &lt;a href=&quot;../language/value_category&quot;&gt;value category&lt;/a&gt; (thus, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; is not allowed, nor is &lt;code&gt;Type1&lt;/code&gt; unless for &lt;code&gt;Type1&lt;/code&gt; a move is equivalent to a copy(since C++11)).</source>
          <target state="translated">Si bien la firma no necesita tener &lt;code&gt;const &amp;amp;&lt;/code&gt; , la funci&amp;oacute;n no debe modificar los objetos que se le pasan y debe poder aceptar todos los valores de type (posiblemente const) &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; independientemente de la &lt;a href=&quot;../language/value_category&quot;&gt;categor&amp;iacute;a&lt;/a&gt; de valores (por lo tanto, &lt;code&gt;Type1 &amp;amp;&lt;/code&gt; no est&amp;aacute; permitido , tampoco lo es &lt;code&gt;Type1&lt;/code&gt; a menos que para &lt;code&gt;Type1&lt;/code&gt; un movimiento sea equivalente a una copia (desde C ++ 11)).</target>
        </trans-unit>
        <trans-unit id="90970ed5fc36e4c5fcc7d19dbc8d5693453a089b" translate="yes" xml:space="preserve">
          <source>While the stream is frozen, &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; will not reallocate the buffer and the &lt;code&gt;destructor&lt;/code&gt; will not deallocate the buffer (thereby causing a memory leak).</source>
          <target state="translated">Mientras la secuencia est&amp;aacute; congelada, &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; no reasignar&amp;aacute; el b&amp;uacute;fer y el &lt;code&gt;destructor&lt;/code&gt; no desasignar&amp;aacute; el b&amp;uacute;fer (causando una p&amp;eacute;rdida de memoria).</target>
        </trans-unit>
        <trans-unit id="51e02d156ab35053fbad0f57e42b76301b58ea18" translate="yes" xml:space="preserve">
          <source>While the variable declared in the range_declaration is usually used in the loop_statement, doing so is not required.</source>
          <target state="translated">Si bien la variable declarada en el range_declaration suele utilizarse en el loop_statement,no es necesario hacerlo.</target>
        </trans-unit>
        <trans-unit id="6c5f647e812d8ac720bd9936607ee574df0ff21f" translate="yes" xml:space="preserve">
          <source>While throw-expression can be used to transfer control to an arbitrary block of code up the execution stack, for arbitrary reasons (similar to &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt;), its intended usage is error handling.</source>
          <target state="translated">Si bien la expresi&amp;oacute;n de lanzamiento se puede usar para transferir el control a un bloque de c&amp;oacute;digo arbitrario en la pila de ejecuci&amp;oacute;n, por razones arbitrarias (similar a &lt;code&gt;&lt;a href=&quot;../utility/program/longjmp&quot;&gt;std::longjmp&lt;/a&gt;&lt;/code&gt; ), su uso previsto es el manejo de errores.</target>
        </trans-unit>
        <trans-unit id="721c1b250c710b24bfafaf9daadc9fa8642ecac8" translate="yes" xml:space="preserve">
          <source>While with &lt;code&gt;copy_options::recursive&lt;/code&gt;, the subdirectories are also copied, with their content, recursively.</source>
          <target state="translated">Mientras que con &lt;code&gt;copy_options::recursive&lt;/code&gt; , los subdirectorios tambi&amp;eacute;n se copian, con su contenido, recursivamente.</target>
        </trans-unit>
        <trans-unit id="b7402781ffeb31aaf9f29177f61c8ff4a0f44050" translate="yes" xml:space="preserve">
          <source>Wide character</source>
          <target state="translated">Carácter amplio</target>
        </trans-unit>
        <trans-unit id="1fb55327ce03b4f2af732e3d187f25baf551cf61" translate="yes" xml:space="preserve">
          <source>Wide character array manipulation</source>
          <target state="translated">Manipulación de la amplia gama de caracteres</target>
        </trans-unit>
        <trans-unit id="6808058d5dd776d7c4d9454174f9c39df21f19c7" translate="yes" xml:space="preserve">
          <source>Wide character representation of &lt;code&gt;c&lt;/code&gt; if &lt;code&gt;(unsigned char)c&lt;/code&gt; is a valid single-byte character in the initial shift state, &lt;code&gt;WEOF&lt;/code&gt; otherwise.</source>
          <target state="translated">La representaci&amp;oacute;n de caracteres anchos de &lt;code&gt;c&lt;/code&gt; if &lt;code&gt;(unsigned char)c&lt;/code&gt; es un car&amp;aacute;cter v&amp;aacute;lido de un solo byte en el estado de desplazamiento inicial, &lt;code&gt;WEOF&lt;/code&gt; de lo contrario.</target>
        </trans-unit>
        <trans-unit id="ab38913ae786de6e808a7c7241557b1856fc368e" translate="yes" xml:space="preserve">
          <source>Wide string manipulation</source>
          <target state="translated">Manipulación de cuerdas amplias</target>
        </trans-unit>
        <trans-unit id="e56ba2339bc3a2c7efd4a4f1ffa763681a4e7ccb" translate="yes" xml:space="preserve">
          <source>Widening always returns a wide character, but only the characters from the basic source character set (latin letters, digits, and punctuations required to write a C++ program) are guaranteed to have a unique, well-defined, widening transformation, which is also guaranteed to be reversible (by &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt;). In practice, all characters whose multibyte representation is a single byte are usually widened to their wide character counterparts, and the rest of the possible single-byte values are usually mapped into the same placeholder value, typically &lt;code&gt;CharT(-1)&lt;/code&gt;.</source>
          <target state="translated">La ampliaci&amp;oacute;n siempre devuelve un car&amp;aacute;cter ancho, pero solo los caracteres del conjunto de caracteres de origen b&amp;aacute;sico (letras latinas, d&amp;iacute;gitos y signos de puntuaci&amp;oacute;n necesarios para escribir un programa C ++) tienen garantizada una transformaci&amp;oacute;n de ampliaci&amp;oacute;n &amp;uacute;nica, bien definida, que tambi&amp;eacute;n est&amp;aacute; garantizada. ser reversible (por &lt;code&gt;&lt;a href=&quot;narrow&quot;&gt;narrow()&lt;/a&gt;&lt;/code&gt; ). En la pr&amp;aacute;ctica, todos los caracteres cuya representaci&amp;oacute;n multibyte es un solo byte generalmente se ampl&amp;iacute;an a sus equivalentes de caracteres anchos, y el resto de los posibles valores de un solo byte generalmente se asignan al mismo valor de marcador de posici&amp;oacute;n, generalmente &lt;code&gt;CharT(-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d388cfaf360c5681944037eaaad4926f0761c9" translate="yes" xml:space="preserve">
          <source>Widening, if successful, preserves all character classification categories known to &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La ampliaci&amp;oacute;n, si tiene &amp;eacute;xito, conserva todas las categor&amp;iacute;as de clasificaci&amp;oacute;n de caracteres conocidas por &lt;code&gt;&lt;a href=&quot;is&quot;&gt;is()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e27d3de30e21293ff54a527696fb3dc557516fd" translate="yes" xml:space="preserve">
          <source>Widens a single-byte character &lt;code&gt;c&lt;/code&gt; to its wide character equivalent.</source>
          <target state="translated">Ampl&amp;iacute;a un car&amp;aacute;cter de byte &amp;uacute;nico &lt;code&gt;c&lt;/code&gt; a su equivalente de car&amp;aacute;cter ancho.</target>
        </trans-unit>
        <trans-unit id="3cf16972858ec6c71abfb6fa6d539bdbe451dbf6" translate="yes" xml:space="preserve">
          <source>Width in bits by data model</source>
          <target state="translated">Anchura en bits por modelo de datos</target>
        </trans-unit>
        <trans-unit id="0352671572d548b1b50beb4586216b4e3764d488" translate="yes" xml:space="preserve">
          <source>Win16 API</source>
          <target state="translated">API Win16</target>
        </trans-unit>
        <trans-unit id="ae7fc6d8171e0e405ed2e200f1d2b5056d479b80" translate="yes" xml:space="preserve">
          <source>Win32 API</source>
          <target state="translated">API de Win32</target>
        </trans-unit>
        <trans-unit id="50f72286ea0c96bccbea595ccc66e3982412d267" translate="yes" xml:space="preserve">
          <source>Win64 API</source>
          <target state="translated">API de Win64</target>
        </trans-unit>
        <trans-unit id="84a4a9dac26edeb0330a247c9af1446aecf202e8" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;#pragma once&lt;/code&gt;, the same header appears as.</source>
          <target state="translated">Con &lt;code&gt;#pragma once&lt;/code&gt; , aparece el mismo encabezado que.</target>
        </trans-unit>
        <trans-unit id="1d949445faea1f549e171010cf3291f2a325074c" translate="yes" xml:space="preserve">
          <source>With &lt;code&gt;N = l - f&lt;/code&gt;, for all &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt;, &lt;code&gt;f[floor(&lt;table&gt;
&lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;)]&lt;/code&gt; does not compare less than &lt;code&gt;f[i]&lt;/code&gt;.</source>
          <target state="translated">Con &lt;code&gt;N = l - f&lt;/code&gt; , para todos &lt;code&gt;0 &amp;lt; i &amp;lt; N&lt;/code&gt; , &lt;code&gt;f[floor(&lt;table&gt; &lt;tr&gt;&lt;td&gt;i-1&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;&lt;/tr&gt; &lt;/table&gt;)]&lt;/code&gt; no compara menos de &lt;code&gt;f[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d81a9b5de91fa98a2d0ef9f4c7f4ecf47988e3" translate="yes" xml:space="preserve">
          <source>With \n instead of endl, the output would be the same, but may not appear in real time.</source>
          <target state="translated">Con \n en lugar de endl,la salida sería la misma,pero podría no aparecer en tiempo real.</target>
        </trans-unit>
        <trans-unit id="47777a8b463cd5f1e3501816b2ffaa3ea107991e" translate="yes" xml:space="preserve">
          <source>With floating point types &lt;code&gt;std::to_string&lt;/code&gt; may yield unexpected results as the number of significant digits in the returned string can be zero, see the example.</source>
          <target state="translated">Con los tipos de coma flotante &lt;code&gt;std::to_string&lt;/code&gt; puede producir resultados inesperados ya que el n&amp;uacute;mero de d&amp;iacute;gitos significativos en la cadena devuelta puede ser cero, vea el ejemplo.</target>
        </trans-unit>
        <trans-unit id="884b3b619e3ef18e83dc71855fd6e34d05de7659" translate="yes" xml:space="preserve">
          <source>With operands of arithmetic or enumeration type, the result of binary plus is the sum of the operands (after usual arithmetic conversions), and the result of the binary minus operator is the result of subtracting the second operand from the first (after usual arithmetic conversions), except that, if the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;),</source>
          <target state="translated">Con operandos de tipo aritm&amp;eacute;tico o de enumeraci&amp;oacute;n, el resultado del plus binario es la suma de los operandos (despu&amp;eacute;s de las conversiones aritm&amp;eacute;ticas habituales), y el resultado del operador menos binario es el resultado de restar el segundo operando del primero (despu&amp;eacute;s de las conversiones aritm&amp;eacute;ticas habituales). ), excepto que, si el tipo admite aritm&amp;eacute;tica de coma flotante IEEE (consulte &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt; ),</target>
        </trans-unit>
        <trans-unit id="fa16b9931c1f17c4f80ec1a246f1cc250c5dd37a" translate="yes" xml:space="preserve">
          <source>With the default allocator, this requirement is equivalent to the validity of &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;, which accepts class types with accessible destructors and all scalar types, but rejects array types, function types, reference types, and void.</source>
          <target state="translated">Con el asignador predeterminado, este requisito es equivalente a la validez de &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; , que acepta tipos de clase con destructores accesibles y todos los tipos escalares, pero rechaza los tipos de matriz, tipos de funciones, tipos de referencia y nulo.</target>
        </trans-unit>
        <trans-unit id="b4fea2c438a60cf674bf6a42d287a393b3f62920" translate="yes" xml:space="preserve">
          <source>With the exception of &lt;code&gt;complex.h&lt;/code&gt; , each &lt;code&gt;xxx.h&lt;/code&gt; header included in the C++ standard library places in the global namespace each name that the corresponding &lt;code&gt;cxxx&lt;/code&gt; header would have placed in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">Con la excepci&amp;oacute;n de &lt;code&gt;complex.h&lt;/code&gt; , cada &lt;code&gt;xxx.h&lt;/code&gt; cabecera incluida en el C ++ est&amp;aacute;ndar lugares de biblioteca en el espacio de nombres global cada nombre que el correspondiente &lt;code&gt;cxxx&lt;/code&gt; cabecera hubiera colocado en el &lt;code&gt;std&lt;/code&gt; espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="5d30f232b7061443bee920972c5d82807b94d345" translate="yes" xml:space="preserve">
          <source>With the introduction of move semantics in C++11, value categories were redefined to characterize two independent properties of expressions&lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">Con la introducci&amp;oacute;n de la sem&amp;aacute;ntica de movimiento en C ++ 11, las categor&amp;iacute;as de valores se redefinieron para caracterizar dos propiedades independientes de las expresiones &lt;sup id=&quot;cite_ref-5&quot;&gt;&lt;a href=&quot;value_category#cite_note-5&quot;&gt;[5]&lt;/a&gt;&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="d7eedc43562dbda358e0af8f66b618c9779da2ba" translate="yes" xml:space="preserve">
          <source>Within a catch-clause, &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; can be used to capture the exception in an &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; may be used to build nested exceptions.</source>
          <target state="translated">Dentro de una cl&amp;aacute;usula catch, &lt;code&gt;&lt;a href=&quot;../error/current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; se puede usar para capturar la excepci&amp;oacute;n en &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; , y &lt;code&gt;&lt;a href=&quot;../error/throw_with_nested&quot;&gt;std::throw_with_nested&lt;/a&gt;&lt;/code&gt; se puede usar para construir excepciones anidadas.</target>
        </trans-unit>
        <trans-unit id="245bc5b44f72c46518d49f6231bcdddbab7bc492" translate="yes" xml:space="preserve">
          <source>Within a class template definition (including its member functions and nested classes) some names may be deduced to refer to the</source>
          <target state="translated">Dentro de una definición de plantilla de clase (incluyendo las funciones de sus miembros y las clases anidadas)pueden deducirse algunos nombres para referirse a la</target>
        </trans-unit>
        <trans-unit id="bc89bf6548ea7d54b0a391d0d3c8b9447ce5c361" translate="yes" xml:space="preserve">
          <source>Within a scope, &lt;a href=&quot;lookup&quot;&gt;unqualified name lookup&lt;/a&gt; can be used to associate the name with its declaration.</source>
          <target state="translated">Dentro de un &amp;aacute;mbito, la &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda de nombres no calificados&lt;/a&gt; se puede utilizar para asociar el nombre con su declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="00817315634a43af97703fb51abe4ea2bd10d529" translate="yes" xml:space="preserve">
          <source>Within a template definition, certain names are deduced to belong to an</source>
          <target state="translated">Dentro de una definición de plantilla,se deduce que ciertos nombres pertenecen a una</target>
        </trans-unit>
        <trans-unit id="7119f9b6e9a5c41a2215c5c5ab587c351e88a0e6" translate="yes" xml:space="preserve">
          <source>Within a thread of execution, accesses (reads and writes) through &lt;a href=&quot;../language/cv&quot;&gt;volatile glvalues&lt;/a&gt; cannot be reordered past observable side-effects (including other volatile accesses) that are</source>
          <target state="translated">Dentro de un hilo de ejecuci&amp;oacute;n, los accesos (lecturas y escrituras) a trav&amp;eacute;s de &lt;a href=&quot;../language/cv&quot;&gt;valores vol&amp;aacute;tiles&lt;/a&gt; no se pueden reordenar m&amp;aacute;s all&amp;aacute; de los efectos secundarios observables (incluidos otros accesos vol&amp;aacute;tiles) que son</target>
        </trans-unit>
        <trans-unit id="6eda1a3a6846d50df7adc54351dedaf50fda69c3" translate="yes" xml:space="preserve">
          <source>Within the body of a function that uses variadic arguments, the values of these arguments may be accessed using the &lt;a href=&quot;../utility/variadic&quot;&gt;&amp;lt;cstdarg&amp;gt; library facilities&lt;/a&gt;:</source>
          <target state="translated">Dentro del cuerpo de una funci&amp;oacute;n que usa argumentos variados, se puede acceder a los valores de estos argumentos usando las &lt;a href=&quot;../utility/variadic&quot;&gt;instalaciones de la biblioteca &amp;lt;cstdarg&amp;gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="af7aded55b08b8ee429002640a601104c0c3e5cf" translate="yes" xml:space="preserve">
          <source>Within the body of a lambda, any use of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; on any variable with automatic storage duration is as if it were captured and odr-used, even though decltype itself isn't an odr-use and no actual capture takes place:</source>
          <target state="translated">Dentro del cuerpo de una lambda, cualquier uso de &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; en cualquier variable con duraci&amp;oacute;n de almacenamiento autom&amp;aacute;tico es como si hubiera sido capturado y utilizado por ODR, a pesar de que decltype en s&amp;iacute; mismo no es un uso de ODR y no tiene lugar una captura real:</target>
        </trans-unit>
        <trans-unit id="078ca0cc0ac40495d119f9a3fdddbbaaae3dc64d" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt;, each identifier that names a non-static member is implicitly transformed to a class member access expression &lt;code&gt;this-&amp;gt;member&lt;/code&gt;.</source>
          <target state="translated">Dentro del cuerpo de una &lt;a href=&quot;member_functions&quot;&gt;funci&amp;oacute;n de miembro&lt;/a&gt; no est&amp;aacute;tico , cada identificador que nombra un miembro no est&amp;aacute;tico se transforma impl&amp;iacute;citamente en una expresi&amp;oacute;n de acceso de miembro de clase &lt;code&gt;this-&amp;gt;member&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f7c80c73c316c30ac1674843481cc4326e1a44" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any &lt;a href=&quot;expressions&quot;&gt;id-expression&lt;/a&gt; E (e.g. an identifier) that resolves to a non-type non-static member of X or of a base class of X, is transformed to a member access expression &lt;code&gt;(*this).E&lt;/code&gt; (unless it's already a part of a member access expression). This does not occur in template definition context, so a name may have to be prefixed with &lt;code&gt;this-&amp;gt;&lt;/code&gt; explicitly to become &lt;a href=&quot;dependent_name&quot;&gt;dependent&lt;/a&gt;.</source>
          <target state="translated">Dentro del cuerpo de una funci&amp;oacute;n miembro no est&amp;aacute;tico de X, cualquier &lt;a href=&quot;expressions&quot;&gt;expresi&amp;oacute;n de&lt;/a&gt; identificaci&amp;oacute;n E (por ejemplo, un identificador) que se resuelva en un miembro no est&amp;aacute;tico no tipo de X o de una clase base de X, se transforma en un acceso de miembro expresi&amp;oacute;n &lt;code&gt;(*this).E&lt;/code&gt; (a menos que ya sea parte de una expresi&amp;oacute;n de acceso de miembro). Esto no ocurre en el contexto de definici&amp;oacute;n de plantilla, por lo que un nombre debe tener el prefijo con &lt;code&gt;this-&amp;gt;&lt;/code&gt; expl&amp;iacute;citamente para volverse &lt;a href=&quot;dependent_name&quot;&gt;dependiente&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff9fb1990c434e938a6a0e2d84512b173b30aeb8" translate="yes" xml:space="preserve">
          <source>Within the body of a non-static member function of X, any unqualified-id that resolves to a static member, an enumerator or a nested type of X or of a base class of X, is transformed to the corresponding qualified-id.</source>
          <target state="translated">Dentro del cuerpo de una función de miembro no estático de X,cualquier identificador no cualificado que se resuelva en un miembro estático,un enumerador o un tipo anidado de X o de una clase base de X,se transforma en el correspondiente identificador cualificado.</target>
        </trans-unit>
        <trans-unit id="5ba9b5ad1328d649ca86d8f4a5d41ae2a5633cf1" translate="yes" xml:space="preserve">
          <source>Within the function body, the function-local predefined variable &lt;code&gt;__func__&lt;/code&gt; is defined as if by.</source>
          <target state="translated">Dentro del cuerpo de la funci&amp;oacute;n, la variable predefinida local-funci&amp;oacute;n &lt;code&gt;__func__&lt;/code&gt; se define como por.</target>
        </trans-unit>
        <trans-unit id="f89ece3e05e483d8d6633832e929cb8220c8daba" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A may be</source>
          <target state="translated">Dentro del mismo hilo,la evaluación A puede ser</target>
        </trans-unit>
        <trans-unit id="c72f89b6f5d83e25d732495d891540e02b9e90aa" translate="yes" xml:space="preserve">
          <source>Within the same thread, evaluation A that is</source>
          <target state="translated">Dentro del mismo hilo,la evaluación A que es</target>
        </trans-unit>
        <trans-unit id="25258e5219c6e5baefb975484506b38b6aa8362b" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template specialization or partial specialization, when the injected-class-name is used as a type-name, it is equivalent to the template-name followed by the template-arguments of the class template specialization or partial specialization enclosed in &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Dentro del alcance de una especializaci&amp;oacute;n de plantilla de clase o especializaci&amp;oacute;n parcial, cuando el nombre de clase inyectado se usa como nombre de tipo, es equivalente al nombre de plantilla seguido de los argumentos de plantilla de la especializaci&amp;oacute;n de plantilla de clase o especializaci&amp;oacute;n parcial incluida en &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce2fab5742c8b33bc0537c80ea3b8dcc2cc835e1" translate="yes" xml:space="preserve">
          <source>Within the scope of a class template, the name of the template without a parameter list is an injected class name, and can be used as a type. In that case, class argument deduction does not happen and template parameters must be supplied explicitly:</source>
          <target state="translated">En el ámbito de una plantilla de clase,el nombre de la plantilla sin una lista de parámetros es un nombre de clase inyectado,y puede ser utilizado como un tipo.En ese caso,la deducción del argumento de la clase no se produce y los parámetros de la plantilla deben ser suministrados explícitamente:</target>
        </trans-unit>
        <trans-unit id="05619ddfa2c0d81e8a6ead6a708344745a722242" translate="yes" xml:space="preserve">
          <source>Without std::flush, the output would be the same, but may not appear in real time.</source>
          <target state="translated">Sin std::flush,la salida sería la misma,pero podría no aparecer en tiempo real.</target>
        </trans-unit>
        <trans-unit id="d0f55a4102a27df1431160445b96e34d20fd4f3d" translate="yes" xml:space="preserve">
          <source>Without std::unitbuf or another explicit flush, the output is the same, but does not appear in real time.</source>
          <target state="translated">Sin std::unitbuf u otra descarga explícita,la salida es la misma,pero no aparece en tiempo real.</target>
        </trans-unit>
        <trans-unit id="682b37a0a9239f633eb0a18ad35c5e23fe316950" translate="yes" xml:space="preserve">
          <source>Working with a &lt;code&gt;priority_queue&lt;/code&gt; is similar to managing a &lt;a href=&quot;../algorithm/make_heap&quot;&gt; heap&lt;/a&gt; in some random access container, with the benefit of not being able to accidentally invalidate the heap.</source>
          <target state="translated">Trabajar con una &lt;code&gt;priority_queue&lt;/code&gt; es similar a administrar un &lt;a href=&quot;../algorithm/make_heap&quot;&gt;mont&amp;oacute;n&lt;/a&gt; en alg&amp;uacute;n contenedor de acceso aleatorio, con el beneficio de no poder invalidar accidentalmente el mont&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8065f27e56565b08250cf2bdf011c92725655e0d" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a pointer to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">Contenedor alrededor de un puntero de funci&amp;oacute;n miembro. La instancia de clase cuya funci&amp;oacute;n miembro para llamar se pasa como un puntero al &lt;code&gt;operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a56128931adfe376f6d1c4233b2aee9d4414fed0" translate="yes" xml:space="preserve">
          <source>Wrapper around a member function pointer. The class instance whose member function to call is passed as a reference to the &lt;code&gt;operator()&lt;/code&gt;.</source>
          <target state="translated">Contenedor alrededor de un puntero de funci&amp;oacute;n miembro. La instancia de clase cuya funci&amp;oacute;n miembro para llamar se pasa como referencia al &lt;code&gt;operator()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd35487a2eb7da40332f7fc41452378d92a72445" translate="yes" xml:space="preserve">
          <source>Writable</source>
          <target state="translated">Writable</target>
        </trans-unit>
        <trans-unit id="a9b6a4bb633bad2e9e1e0bcdbb56726b9e0e6146" translate="yes" xml:space="preserve">
          <source>Write to end</source>
          <target state="translated">Escriba al final</target>
        </trans-unit>
        <trans-unit id="e87fd10313099f92edd69106267a002d4e8466a1" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;. Internally, the character is converted to &lt;code&gt;unsigned char&lt;/code&gt; just before being written.</source>
          <target state="translated">Escribe un car&amp;aacute;cter &lt;code&gt;ch&lt;/code&gt; para &lt;code&gt;stdout&lt;/code&gt; . Internamente, el car&amp;aacute;cter se convierte en &lt;code&gt;unsigned char&lt;/code&gt; justo antes de ser escrito.</target>
        </trans-unit>
        <trans-unit id="a96b7df507ca67492643e29e1db1884cf6663933" translate="yes" xml:space="preserve">
          <source>Writes a character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;.</source>
          <target state="translated">Escribe un car&amp;aacute;cter &lt;code&gt;ch&lt;/code&gt; en la secuencia de &lt;code&gt;stream&lt;/code&gt; salida dada .</target>
        </trans-unit>
        <trans-unit id="001712686d4b96e8257e062bf8257f5854fb0c91" translate="yes" xml:space="preserve">
          <source>Writes a horizontal tab character.</source>
          <target state="translated">Escribe un carácter de ficha horizontal.</target>
        </trans-unit>
        <trans-unit id="b8a7060cb09fe871077059dd6f46ca33bbda1f49" translate="yes" xml:space="preserve">
          <source>Writes a literal &lt;code&gt;%&lt;/code&gt; character.</source>
          <target state="translated">Escribe un car&amp;aacute;cter literal &lt;code&gt;%&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb18b1353d53796c65bfab0bce5e3151631b33c0" translate="yes" xml:space="preserve">
          <source>Writes a newline character.</source>
          <target state="translated">Escribe un nuevo personaje.</target>
        </trans-unit>
        <trans-unit id="6924072c304541be0f3e71e77883f2ec6c6a9d14" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of a thread identifier &lt;code&gt;id&lt;/code&gt; to the output stream &lt;code&gt;ost&lt;/code&gt;.</source>
          <target state="translated">Escribe una representaci&amp;oacute;n textual de un identificador de hilo &lt;code&gt;id&lt;/code&gt; de la secuencia de salida &lt;code&gt;ost&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="767a6e009054da5918825851e61b1c02bbbf738a" translate="yes" xml:space="preserve">
          <source>Writes a textual representation of the distribution parameters and internal state to &lt;code&gt;os&lt;/code&gt;. The formatting flags and fill character of &lt;code&gt;os&lt;/code&gt; are unchanged.</source>
          <target state="translated">Escribe una representaci&amp;oacute;n textual de los par&amp;aacute;metros de distribuci&amp;oacute;n y el estado interno en el sistema &lt;code&gt;os&lt;/code&gt; . Las banderas de formato y el car&amp;aacute;cter de relleno de &lt;code&gt;os&lt;/code&gt; no cambian.</target>
        </trans-unit>
        <trans-unit id="628a432848d3d2a0f439ca52671452d1eec4d9ff" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">Escribe un car&amp;aacute;cter amplio &lt;code&gt;ch&lt;/code&gt; para &lt;code&gt;stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a61cc5af43d9f51fcd06a3cacfeb3348c1595940" translate="yes" xml:space="preserve">
          <source>Writes a wide character &lt;code&gt;ch&lt;/code&gt; to the given output stream &lt;code&gt;stream&lt;/code&gt;. &lt;code&gt;putwc()&lt;/code&gt; may be implemented as a macro and may evaluate &lt;code&gt;stream&lt;/code&gt; more than once.</source>
          <target state="translated">Escribe un car&amp;aacute;cter ancho &lt;code&gt;ch&lt;/code&gt; en la secuencia de &lt;code&gt;stream&lt;/code&gt; salida dada . &lt;code&gt;putwc()&lt;/code&gt; puede implementarse como una macro y puede evaluar la &lt;code&gt;stream&lt;/code&gt; m&amp;aacute;s de una vez.</target>
        </trans-unit>
        <trans-unit id="bb34f2576c279e7725c583723fccb0fc6a3511eb" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; and one additional newline character &lt;code&gt;'\n'&lt;/code&gt; to the output stream &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Escribe cada car&amp;aacute;cter de la cadena de &lt;code&gt;str&lt;/code&gt; terminada en nulo y un car&amp;aacute;cter de nueva l&amp;iacute;nea adicional &lt;code&gt;'\n'&lt;/code&gt; en la salida &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; flujo de salida , como si se ejecutara repetidamente &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a503bcd94956c4103d38ea588d00af71b7d3a70" translate="yes" xml:space="preserve">
          <source>Writes every character from the null-terminated string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Escribe cada car&amp;aacute;cter desde la cadena de &lt;code&gt;str&lt;/code&gt; terminada en nulo en la secuencia de &lt;code&gt;stream&lt;/code&gt; salida , como si se ejecutara repetidamente &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83ab79edfcdea5e94d3e192eb9d45b8f6bebd9bf" translate="yes" xml:space="preserve">
          <source>Writes every wide character from the null-terminated wide string &lt;code&gt;str&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;, as if by repeatedly executing &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Escribe cada car&amp;aacute;cter ancho desde la cadena de &lt;code&gt;str&lt;/code&gt; ancha terminada en nulo en la secuencia de &lt;code&gt;stream&lt;/code&gt; salida , como si se ejecutara repetidamente &lt;code&gt;&lt;a href=&quot;fputwc&quot;&gt;std::fputwc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9b88a484ae89e6d4131f01f0c94c90cbf9dc18c" translate="yes" xml:space="preserve">
          <source>Writes one character to the output sequence.</source>
          <target state="translated">Escribe un carácter en la secuencia de salida.</target>
        </trans-unit>
        <trans-unit id="3aeb20d4e3a246faca11563fb03064671edc3f42" translate="yes" xml:space="preserve">
          <source>Writes some data from the put area to the associated character sequence (to the file).</source>
          <target state="translated">Escribe algunos datos de la zona de puesta a la secuencia de caracteres asociada (al archivo).</target>
        </trans-unit>
        <trans-unit id="74f04ede6f753ddec049a69f229f7dc13079d99c" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week of the year as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Escribe la semana ISO 8601 del año como un número decimal.Si el resultado es un solo dígito,se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="f7d029ddd98ce63f15114123e69a3596edcb4ab0" translate="yes" xml:space="preserve">
          <source>Writes the ISO 8601 week-based year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">Escribe el año de la semana ISO 8601 como un número decimal.Si el resultado es menos de cuatro dígitos,se rellena a la izquierda con 0 a cuatro dígitos.</target>
        </trans-unit>
        <trans-unit id="0cc1164d46d9e7c267ced7895e6152ab0b695562" translate="yes" xml:space="preserve">
          <source>Writes the ISO weekday as a decimal number (1-7), where Monday is &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="translated">Escribe el d&amp;iacute;a de la semana ISO como un n&amp;uacute;mero decimal (1-7), donde el lunes es &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71166ded75b14ffa703a04ab3f28950a6779e502" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">Escribe el día del mes como un número decimal.Si el resultado es un solo dígito decimal,se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="b0f7893ae9d8e28cab469762cfa8b52ab87190ba" translate="yes" xml:space="preserve">
          <source>Writes the day of month as a decimal number. If the result is a single decimal digit, it is prefixed with a space.</source>
          <target state="translated">Escribe el día del mes como un número decimal.Si el resultado es un solo dígito decimal,se le antepone un espacio.</target>
        </trans-unit>
        <trans-unit id="1626fbac11740992d51707eebf9b1bc3e70c4e3f" translate="yes" xml:space="preserve">
          <source>Writes the day of the year as a decimal number (January 1 is &lt;code&gt;001&lt;/code&gt;). If the result is less than three digits, it is left-padded with 0 to three digits.</source>
          <target state="translated">Escribe el d&amp;iacute;a del a&amp;ntilde;o como un n&amp;uacute;mero decimal (el 1 de enero es &lt;code&gt;001&lt;/code&gt; ). Si el resultado tiene menos de tres d&amp;iacute;gitos, se rellena a la izquierda con 0 a tres d&amp;iacute;gitos.</target>
        </trans-unit>
        <trans-unit id="c029d304cd7d0c5128b916f1b7935a6092ee6d60" translate="yes" xml:space="preserve">
          <source>Writes the hour (12-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Escribe la hora (reloj de 12 horas)como un número decimal.Si el resultado es un solo dígito,se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="d586ae48a03fbce6cab63eb6156b184051a469fd" translate="yes" xml:space="preserve">
          <source>Writes the hour (24-hour clock) as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Escribe la hora (reloj de 24 horas)como un número decimal.Si el resultado es un solo dígito,se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="67151c9d086e78a6b607bc1d8cdeea642b931db1" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the ISO 8601 week-based year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">Escribe los dos últimos dígitos decimales del año ISO 8601 basado en la semana.Si el resultado es un solo dígito se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="9ff9a700dc66f1c252bd7007b0facde18742ff7d" translate="yes" xml:space="preserve">
          <source>Writes the last two decimal digits of the year. If the result is a single digit it is prefixed by 0.</source>
          <target state="translated">Escribe los dos últimos dígitos decimales del año.Si el resultado es un solo dígito se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="30b48d91697b9f629d02ce9d83e7a421c921e234" translate="yes" xml:space="preserve">
          <source>Writes the locale's 12-hour clock time.</source>
          <target state="translated">Escribe la hora del reloj de 12 horas del lugar.</target>
        </trans-unit>
        <trans-unit id="a971b059080c39ac822e661aea1c87ec25348313" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated month name.</source>
          <target state="translated">Escribe el nombre del mes abreviado del lugar.</target>
        </trans-unit>
        <trans-unit id="f672aa4e85699374012ee1a535ef52d6be86123e" translate="yes" xml:space="preserve">
          <source>Writes the locale's abbreviated weekday name.</source>
          <target state="translated">Escribe el nombre abreviado del día de la semana del lugar.</target>
        </trans-unit>
        <trans-unit id="a93c6febd8287cd73094f5c7fa21ffc07a57cd24" translate="yes" xml:space="preserve">
          <source>Writes the locale's date and time representation.</source>
          <target state="translated">Escribe la representación de la fecha y la hora del lugar.</target>
        </trans-unit>
        <trans-unit id="8990ab22cb03b6694ce6cb909d61b54ae50e921c" translate="yes" xml:space="preserve">
          <source>Writes the locale's date representation.</source>
          <target state="translated">Escribe la representación de la fecha del lugar.</target>
        </trans-unit>
        <trans-unit id="1dec9978ca81332b5e90610cec498718c6ecefef" translate="yes" xml:space="preserve">
          <source>Writes the locale's equivalent of the AM/PM designations associated with a 12-hour clock.</source>
          <target state="translated">Escribe el equivalente de la localidad de las designaciones AM/PM asociadas a un reloj de 12 horas.</target>
        </trans-unit>
        <trans-unit id="4bd0b778c0ca16103f3037347259706f50406b6f" translate="yes" xml:space="preserve">
          <source>Writes the locale's full month name.</source>
          <target state="translated">Escribe el nombre del mes completo del lugar.</target>
        </trans-unit>
        <trans-unit id="dbcf68702a0a2c1386e6fd13ec2cac6f00c12942" translate="yes" xml:space="preserve">
          <source>Writes the locale's full weekday name.</source>
          <target state="translated">Escribe el nombre completo del lugar durante la semana.</target>
        </trans-unit>
        <trans-unit id="ba5f45187c6fabe4410c47f297770de07e96243b" translate="yes" xml:space="preserve">
          <source>Writes the locale's time representation.</source>
          <target state="translated">Escribe la representación temporal del lugar.</target>
        </trans-unit>
        <trans-unit id="fc68d043b917adc440f4f576ac7e4b54287ebed4" translate="yes" xml:space="preserve">
          <source>Writes the minute as a decimal number. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Escribe el minuto como un número decimal.Si el resultado es un solo dígito,se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="c30fe76679f32dcce8e852b50af05cbd5aefe9f6" translate="yes" xml:space="preserve">
          <source>Writes the month as a decimal number (January is &lt;code&gt;01&lt;/code&gt;). If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Escribe el mes como un n&amp;uacute;mero decimal (enero es &lt;code&gt;01&lt;/code&gt; ). Si el resultado es un solo d&amp;iacute;gito, tiene el prefijo 0.</target>
        </trans-unit>
        <trans-unit id="8032e3a64c8132ccb6ad44a63e27ef9ad4339e8a" translate="yes" xml:space="preserve">
          <source>Writes the offset from UTC in the ISO 8601 format. For example &lt;code&gt;-0430&lt;/code&gt; refers to 4 hours 30 minutes behind UTC. If the offset is zero, &lt;code&gt;+0000&lt;/code&gt; is used.</source>
          <target state="translated">Escribe el desplazamiento desde UTC en el formato ISO 8601. Por ejemplo, &lt;code&gt;-0430&lt;/code&gt; se refiere a 4 horas y 30 minutos detr&amp;aacute;s de UTC. Si el desplazamiento es cero, &lt;code&gt;+0000&lt;/code&gt; se usa +0000 .</target>
        </trans-unit>
        <trans-unit id="9d76d87840d6936192aee3cda5289202c38d7018" translate="yes" xml:space="preserve">
          <source>Writes the representation of the matched subsequence &lt;code&gt;m&lt;/code&gt; to the output stream &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">Escribe la representaci&amp;oacute;n de la subsecuencia coincidente &lt;code&gt;m&lt;/code&gt; en el flujo de salida &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17feef3d0503048639900d16af24c9e6fe4685c7" translate="yes" xml:space="preserve">
          <source>Writes the second as a decimal number. If the number of seconds is less than 10, the result is prefixed with 0.</source>
          <target state="translated">Escribe el segundo como un número decimal.Si el número de segundos es inferior a 10,el resultado se antepone al 0.</target>
        </trans-unit>
        <trans-unit id="1a73b5e51c193b1deccbfaf669b4db12b0a55d6d" translate="yes" xml:space="preserve">
          <source>Writes the time zone abbreviation.</source>
          <target state="translated">Escribe la abreviatura de la zona horaria.</target>
        </trans-unit>
        <trans-unit id="1d8938025c2761da9ede064d18f5ef84dcf58261" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Monday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Escribe el número de la semana del año como un número decimal.El primer lunes del año es el primer día de la semana 01.Los días del mismo año anterior a ese son la semana 00.Si el resultado es un solo dígito,se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="370c8fdb39d9f2b4190c27cb6e07474705f3c637" translate="yes" xml:space="preserve">
          <source>Writes the week number of the year as a decimal number. The first Sunday of the year is the first day of week 01. Days of the same year prior to that are in week 00. If the result is a single digit, it is prefixed with 0.</source>
          <target state="translated">Escribe el número de la semana del año como un número decimal.El primer domingo del año es el primer día de la semana 01.Los días del mismo año anterior a ese son en la semana 00.Si el resultado es un solo dígito,se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="dbdae9db0bd7c298a373f28a7cd0509bbbb5b272" translate="yes" xml:space="preserve">
          <source>Writes the weekday as a decimal number (0-6), where Sunday is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Escribe el d&amp;iacute;a de la semana como un n&amp;uacute;mero decimal (0-6), donde el domingo es &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb21ea8cdea47573e1038fbae721d5dca3fb901b" translate="yes" xml:space="preserve">
          <source>Writes the year as a decimal number. If the result is less than four digits it is left-padded with 0 to four digits.</source>
          <target state="translated">Escribe el año como un número decimal.Si el resultado es menos de cuatro dígitos se rellena con 0 a cuatro dígitos.</target>
        </trans-unit>
        <trans-unit id="26249ba8d699dd0df931793d3da64b00c7c31d1d" translate="yes" xml:space="preserve">
          <source>Writes the year divided by 100 using floored division. If the result is a single decimal digit, it is prefixed with 0.</source>
          <target state="translated">Escribe el año dividido por 100 usando la división por pisos.Si el resultado es un solo dígito decimal,se le antepone el 0.</target>
        </trans-unit>
        <trans-unit id="a77785063b2874f1bbee1b042250317d98d6b33a" translate="yes" xml:space="preserve">
          <source>Writes to &lt;code&gt;os&lt;/code&gt; the textual representation of &lt;code&gt;x&lt;/code&gt;'s current state. In the output, adjacent numbers are separated by one or more space characters. If &lt;code&gt;os&lt;/code&gt;'s fmtflags are not set to &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt;, the behavior may be undefined.</source>
          <target state="translated">Escribe en &lt;code&gt;os&lt;/code&gt; la representaci&amp;oacute;n textual del estado actual de &lt;code&gt;x&lt;/code&gt; . En la salida, los n&amp;uacute;meros adyacentes est&amp;aacute;n separados por uno o m&amp;aacute;s caracteres de espacio. Si los fmtflags de &lt;code&gt;os&lt;/code&gt; no est&amp;aacute;n establecidos en &lt;code&gt;ios_base::dec|ios_base::left&lt;/code&gt; , el comportamiento puede ser indefinido.</target>
        </trans-unit>
        <trans-unit id="0d621d908346c0bfe11eb811537d53c64ce8ec02" translate="yes" xml:space="preserve">
          <source>Writes to fields</source>
          <target state="translated">Escribe a los campos</target>
        </trans-unit>
        <trans-unit id="00c192b84cfa44d2bd75c59846c86d17a1e44b25" translate="yes" xml:space="preserve">
          <source>Writes uncommitted changes to the underlying output sequence.</source>
          <target state="translated">Escribe los cambios no comprometidos en la secuencia de salida subyacente.</target>
        </trans-unit>
        <trans-unit id="15ec5b51c4d780460bc9101843d2786a8b364326" translate="yes" xml:space="preserve">
          <source>Writes up to &lt;code&gt;count&lt;/code&gt; binary objects from the given array &lt;code&gt;buffer&lt;/code&gt; to the output stream &lt;code&gt;stream&lt;/code&gt;. The objects are written as if by reinterpreting each object as an array of &lt;code&gt;unsigned char&lt;/code&gt; and calling &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt;&lt;code&gt;size&lt;/code&gt; times for each object to write those &lt;code&gt;unsigned char&lt;/code&gt;s into &lt;code&gt;stream&lt;/code&gt;, in order. The file position indicator for the stream is advanced by the number of characters written.</source>
          <target state="translated">Escribe para &lt;code&gt;count&lt;/code&gt; objetos binarios desde el &lt;code&gt;buffer&lt;/code&gt; matriz dado a la secuencia de &lt;code&gt;stream&lt;/code&gt; salida . Los objetos se escriben como si reinterpretaran cada objeto como una matriz de caracteres &lt;code&gt;unsigned char&lt;/code&gt; y se &lt;code&gt;&lt;a href=&quot;fputc&quot;&gt;std::fputc&lt;/a&gt;&lt;/code&gt; tiempos de &lt;code&gt;size&lt;/code&gt; std :: fputc para que cada objeto escriba esos caracteres &lt;code&gt;unsigned char&lt;/code&gt; en la &lt;code&gt;stream&lt;/code&gt; , en orden. El indicador de posici&amp;oacute;n del archivo para la transmisi&amp;oacute;n avanza por el n&amp;uacute;mero de caracteres escritos.</target>
        </trans-unit>
        <trans-unit id="c8447596ae9170966e015adf6c315155e2268bda" translate="yes" xml:space="preserve">
          <source>Writing to the character array accessed through &lt;code&gt;c_str()&lt;/code&gt; is undefined behavior.</source>
          <target state="translated">Escribir en la matriz de caracteres a la que se accede a trav&amp;eacute;s de &lt;code&gt;c_str()&lt;/code&gt; es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="c032adc1ff629c9b66f22749ad667e6beadf144b" translate="yes" xml:space="preserve">
          <source>X</source>
          <target state="translated">X</target>
        </trans-unit>
        <trans-unit id="93cad4f773cccfbb33c80bc8546680efa75c09a4" translate="yes" xml:space="preserve">
          <source>X and X</source>
          <target state="translated">X y X</target>
        </trans-unit>
        <trans-unit id="d60cdb3a38da8a130cf91abef198ed0c8df65943" translate="yes" xml:space="preserve">
          <source>X and X appears before B in the Single Total Order</source>
          <target state="translated">X y X aparece antes de B en el orden total único</target>
        </trans-unit>
        <trans-unit id="2f3f27dde1e0deeab004667545a65bef35394ab9" translate="yes" xml:space="preserve">
          <source>X argument</source>
          <target state="translated">Argumento X</target>
        </trans-unit>
        <trans-unit id="4ca65c470ec6016fed78ab6aef93dd257702b23f" translate="yes" xml:space="preserve">
          <source>X, X</source>
          <target state="translated">X,X</target>
        </trans-unit>
        <trans-unit id="6db6535836e6c904498ebb911985cfb1ab6cbadf" translate="yes" xml:space="preserve">
          <source>X, Y is</source>
          <target state="translated">X,Y es</target>
        </trans-unit>
        <trans-unit id="9ea35756029154e9210bcca0b65c206107747ec2" translate="yes" xml:space="preserve">
          <source>X, and X</source>
          <target state="translated">X,y X</target>
        </trans-unit>
        <trans-unit id="565e6a618c216015d885283111a97727e2c3f173" translate="yes" xml:space="preserve">
          <source>X, and X is</source>
          <target state="translated">X,y X es</target>
        </trans-unit>
        <trans-unit id="6ba655c53b7c6f7ad109ea6e30e446c19a1740b7" translate="yes" xml:space="preserve">
          <source>Y argument</source>
          <target state="translated">Argumento Y</target>
        </trans-unit>
        <trans-unit id="ba12622aee8e1cee306fb2ae1705d34dc28d369e" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before F in thread B</source>
          <target state="translated">Y está secuenciada antes de F en el hilo B</target>
        </trans-unit>
        <trans-unit id="ed1a905ea4a6fcc0ca7ba73cce1620307e6d6ffa" translate="yes" xml:space="preserve">
          <source>Y is sequenced-before FB in thread B</source>
          <target state="translated">Y está secuenciada antes de FB en el hilo B</target>
        </trans-unit>
        <trans-unit id="3850869b7a202e66b87556b87c42f6e3bad33150" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or by the &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt;)</source>
          <target state="translated">Y lee el valor escrito por X (o por la &lt;a href=&quot;memory_order&quot;&gt;secuencia de lanzamiento encabezada por X&lt;/a&gt; )</target>
        </trans-unit>
        <trans-unit id="1038aa0966244ed387fbcfee4940af4843ba1a40" translate="yes" xml:space="preserve">
          <source>Y reads the value written by X (or the value would be written by &lt;a href=&quot;memory_order&quot;&gt;release sequence headed by X&lt;/a&gt; if X were a release operation)</source>
          <target state="translated">Y lee el valor escrito por X (o el valor se escribir&amp;iacute;a por &lt;a href=&quot;memory_order&quot;&gt;secuencia de lanzamiento encabezada por X&lt;/a&gt; si X fuera una operaci&amp;oacute;n de lanzamiento)</target>
        </trans-unit>
        <trans-unit id="4d77689f2569037f676a633b110bf28151defd7c" translate="yes" xml:space="preserve">
          <source>Y, and Y is</source>
          <target state="translated">Y,y Y es</target>
        </trans-unit>
        <trans-unit id="879e32326c5217968ac8e3a14e4a8a5214957264" translate="yes" xml:space="preserve">
          <source>Year</source>
          <target state="translated">Year</target>
        </trans-unit>
        <trans-unit id="869ef4891ca6fa4509dc520e3f6640c9b0cfae4a" translate="yes" xml:space="preserve">
          <source>Year, day, month</source>
          <target state="translated">Año,día,mes</target>
        </trans-unit>
        <trans-unit id="915f26f629fd3d6f51a4b7d5990e0b50d4471157" translate="yes" xml:space="preserve">
          <source>Year, month, day</source>
          <target state="translated">Año,mes,día</target>
        </trans-unit>
        <trans-unit id="5397e0583f14f6c88de06b1ef28f460a1fb5b0ae" translate="yes" xml:space="preserve">
          <source>Yes</source>
          <target state="translated">Yes</target>
        </trans-unit>
        <trans-unit id="f1e34b1b0b0addb32d44f2528bede851abf77e03" translate="yes" xml:space="preserve">
          <source>Yes, except erased element(s)</source>
          <target state="translated">Sí,excepto los elementos borrados</target>
        </trans-unit>
        <trans-unit id="7ed1f0e98f8b97a0cbc079098f9b970f72dbe20e" translate="yes" xml:space="preserve">
          <source>Yield-expression returns a value to the caller and suspends the current coroutine: it is the common building block of resumable generator functions.</source>
          <target state="translated">La expresión de rendimiento devuelve un valor a la persona que llama y suspende la cortinilla actual:es el elemento común de las funciones del generador reanudable.</target>
        </trans-unit>
        <trans-unit id="1791a81aeb4f78d0ab4f9096c83089810fc43595" translate="yes" xml:space="preserve">
          <source>Yields &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; if for some &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; and &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt;</source>
          <target state="translated">Rinde &lt;code&gt;X​::​eq(c,d)&lt;/code&gt; si para algunos &lt;code&gt;c&lt;/code&gt; y &lt;code&gt;d&lt;/code&gt; , &lt;code&gt;e == X::to_int_type(c)&lt;/code&gt; y &lt;code&gt;f == X::to_int_type(d)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="729d384e3fcd3d72644a0c1418ba7a729b79ac57" translate="yes" xml:space="preserve">
          <source>ZERO WIDTH SPACE - ZERO WIDTH JOINER</source>
          <target state="translated">ESPACIO DE ANCHO CERO-ENSAMBLADOR DE ANCHO CERO</target>
        </trans-unit>
        <trans-unit id="51c939bb7f5f0758dd76abfc0b3c05c623bebff7" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; compare equal.</source>
          <target state="translated">Cero si &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; se comparan igual.</target>
        </trans-unit>
        <trans-unit id="917c36f59225ed77c40603a32141411ab5f9fea6" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, one plus the base-2 logarithm of &lt;code&gt;x&lt;/code&gt;, with any fractional part discarded.</source>
          <target state="translated">Cero si &lt;code&gt;x&lt;/code&gt; es cero; de lo contrario, uno m&amp;aacute;s el logaritmo de base 2 de &lt;code&gt;x&lt;/code&gt; , con cualquier parte fraccional descartada.</target>
        </trans-unit>
        <trans-unit id="0f17813fad92e667b30a4557d41d38bf185f1f8c" translate="yes" xml:space="preserve">
          <source>Zero if &lt;code&gt;x&lt;/code&gt; is zero; otherwise, the largest integral power of two that is not greater than &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Cero si &lt;code&gt;x&lt;/code&gt; es cero; de lo contrario, la mayor potencia integral de dos que no es mayor que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="405ae0fba6c1904278eb371bc24b47d81b1d7d3c" translate="yes" xml:space="preserve">
          <source>Zero initialization is performed in the following situations:</source>
          <target state="translated">La inicialización cero se realiza en las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="a1be729d580f443d76655de63a066d43b5c754d5" translate="yes" xml:space="preserve">
          <source>Zero or more of the following:</source>
          <target state="translated">Cero o más de lo siguiente:</target>
        </trans-unit>
        <trans-unit id="d00bedfb8c02a9e78a0c8655d079c8a74339369e" translate="yes" xml:space="preserve">
          <source>Zero otherwise</source>
          <target state="translated">Cero de otra manera</target>
        </trans-unit>
        <trans-unit id="ca77598d8983f14f3898f59c121fdcf1e9e18087" translate="yes" xml:space="preserve">
          <source>[-]d.ddd</source>
          <target state="translated">[-]d.ddd</target>
        </trans-unit>
        <trans-unit id="913e7afee46c7a822906ed5749ddbb4805cee7d2" translate="yes" xml:space="preserve">
          <source>[-]ddd.ddd</source>
          <target state="translated">[-]ddd.ddd</target>
        </trans-unit>
        <trans-unit id="8c2b29412829eefb22455e55f53e2c249d24e11a" translate="yes" xml:space="preserve">
          <source>[-]dddd</source>
          <target state="translated">[-]dddd</target>
        </trans-unit>
        <trans-unit id="c1734847a74561b4543b119ae934914f50b4cfb4" translate="yes" xml:space="preserve">
          <source>[-x3</source>
          <target state="translated">[-x3</target>
        </trans-unit>
        <trans-unit id="d750010a709171aa3f400cbe019efe556b93b506" translate="yes" xml:space="preserve">
          <source>[0,</source>
          <target state="translated">[0,</target>
        </trans-unit>
        <trans-unit id="e61dea886117af6d2ec7f9dcb7bd9a3411c6e61f" translate="yes" xml:space="preserve">
          <source>[&lt;code&gt;ranges::begin(E)&lt;/code&gt;, &lt;code&gt;ranges::end(E)&lt;/code&gt;) denotes a range, and</source>
          <target state="translated">[ &lt;code&gt;ranges::begin(E)&lt;/code&gt; , &lt;code&gt;ranges::end(E)&lt;/code&gt; ) denota un rango, y</target>
        </trans-unit>
        <trans-unit id="228f7d207920fb84335fac5b2b06ed7b472ece9e" translate="yes" xml:space="preserve">
          <source>[deleted]</source>
          <target state="translated">[deleted]</target>
        </trans-unit>
        <trans-unit id="73a877ccfe464539ac89cb8083cf71234db18da5" translate="yes" xml:space="preserve">
          <source>[first,first)</source>
          <target state="translated">[first,first)</target>
        </trans-unit>
        <trans-unit id="7231a3611aa5bad8f818b0f7bb419a3d1200483d" translate="yes" xml:space="preserve">
          <source>[first,last)</source>
          <target state="translated">[first,last)</target>
        </trans-unit>
        <trans-unit id="2855c5627ea838aafc570baf3e8f5ddda039170b" translate="yes" xml:space="preserve">
          <source>[last,last)</source>
          <target state="translated">[last,last)</target>
        </trans-unit>
        <trans-unit id="51f320773f671463a4338fa2cd7489e0a7d0a19d" translate="yes" xml:space="preserve">
          <source>[nothrow-]swappable traits</source>
          <target state="translated">[nothrow-] rasgos intercambiables</target>
        </trans-unit>
        <trans-unit id="2706c6dc283ec831e2ea7c5771adc61d0195a5e5" translate="yes" xml:space="preserve">
          <source>[static]</source>
          <target state="translated">[static]</target>
        </trans-unit>
        <trans-unit id="44fed6b6252fc5fda7cc744792424bdd0b7b1020" translate="yes" xml:space="preserve">
          <source>[static](C++11)</source>
          <target state="translated">[static](C++11)</target>
        </trans-unit>
        <trans-unit id="e4b4e5b6ec02f085b66944f0e3a63cac3c002038" translate="yes" xml:space="preserve">
          <source>[static](C++17)</source>
          <target state="translated">[static](C++17)</target>
        </trans-unit>
        <trans-unit id="0352562c44ca57a96c86a8ce2c63b508390a988b" translate="yes" xml:space="preserve">
          <source>[static](C++20)</source>
          <target state="translated">[static](C++20)</target>
        </trans-unit>
        <trans-unit id="85894ee8b74956e4f1ad040534bebb4a92408ba9" translate="yes" xml:space="preserve">
          <source>[static](optional)</source>
          <target state="translated">[static](optional)</target>
        </trans-unit>
        <trans-unit id="e621ceda2c534b69cb910cae3059eb9ff125986d" translate="yes" xml:space="preserve">
          <source>[virtual]</source>
          <target state="translated">[virtual]</target>
        </trans-unit>
        <trans-unit id="986bbf2f9f0c3cbbc6546d685166748b60c20798" translate="yes" xml:space="preserve">
          <source>[virtual](C++11)</source>
          <target state="translated">[virtual](C++11)</target>
        </trans-unit>
        <trans-unit id="8af4f9130ab9142006b068ed0c1ed35271abd3b0" translate="yes" xml:space="preserve">
          <source>[virtual](implicitly declared)</source>
          <target state="translated">[virtual] (declarado impl&amp;iacute;citamente)</target>
        </trans-unit>
        <trans-unit id="a80e5ea0695ed7f04f7f2926fafe2f96aa4dcb23" translate="yes" xml:space="preserve">
          <source>[x2</source>
          <target state="translated">[x2</target>
        </trans-unit>
        <trans-unit id="36886f5ee53771548cf5c86e4853a8dcf06d3e14" translate="yes" xml:space="preserve">
          <source>] radians, is returned.</source>
          <target state="translated">] radianes, se devuelve.</target>
        </trans-unit>
        <trans-unit id="12ec352745ee599586db13a925319fe87a988295" translate="yes" xml:space="preserve">
          <source>], is returned.</source>
          <target state="translated">], es regresado.</target>
        </trans-unit>
        <trans-unit id="056353e23af4506e74d7003cb38640abbea6a449" translate="yes" xml:space="preserve">
          <source>]1/2</source>
          <target state="translated">]1/2</target>
        </trans-unit>
        <trans-unit id="2543ff7b78f94174e33e9adeb84f297edc54fffa" translate="yes" xml:space="preserve">
          <source>_1, _2, _3, _4, ...</source>
          <target state="translated">_1, _2, _3, _4, ...</target>
        </trans-unit>
        <trans-unit id="5903c0497b4b6110dd3051a9b31ef948bae78c64" translate="yes" xml:space="preserve">
          <source>_Exit</source>
          <target state="translated">_Exit</target>
        </trans-unit>
        <trans-unit id="a86d3649d1b2b72954d70aa40f94f98858c527ba" translate="yes" xml:space="preserve">
          <source>_IOFBF_IOLBF_IONBF</source>
          <target state="translated">_IOFBF_IOLBF_IONBF</target>
        </trans-unit>
        <trans-unit id="1b22c1d687dc7c54339d14d0aa2284796291aec8" translate="yes" xml:space="preserve">
          <source>__DATE__</source>
          <target state="translated">__DATE__</target>
        </trans-unit>
        <trans-unit id="9d5d8995523b8b8951428baa81ea663ff0bd2c77" translate="yes" xml:space="preserve">
          <source>__FILE__</source>
          <target state="translated">__FILE__</target>
        </trans-unit>
        <trans-unit id="a51b95694c81c92580bff6f580f8e200ecf86661" translate="yes" xml:space="preserve">
          <source>__LINE__</source>
          <target state="translated">__LINE__</target>
        </trans-unit>
        <trans-unit id="ce0bc0efbd8965b4d82a11aa07f4fab94777d3af" translate="yes" xml:space="preserve">
          <source>__STDCPP_DEFAULT_NEW_ALIGNMENT__</source>
          <target state="translated">__STDCPP_DEFAULT_NEW_ALIGNMENT__</target>
        </trans-unit>
        <trans-unit id="db9a3eaebbc58b7b2dff63e6d1078194a02871a4" translate="yes" xml:space="preserve">
          <source>__STDCPP_STRICT_POINTER_SAFETY__</source>
          <target state="translated">__STDCPP_STRICT_POINTER_SAFETY__</target>
        </trans-unit>
        <trans-unit id="950ee9617b60ace35791cfba67c4eda35d86e1d5" translate="yes" xml:space="preserve">
          <source>__STDCPP_THREADS__</source>
          <target state="translated">__STDCPP_THREADS__</target>
        </trans-unit>
        <trans-unit id="51f3c9479afc9737ac0812162dcb10cc18fbbd51" translate="yes" xml:space="preserve">
          <source>__STDC_HOSTED__</source>
          <target state="translated">__STDC_HOSTED__</target>
        </trans-unit>
        <trans-unit id="aa16038a596c275e6fffc69644dbad7ec1a3ceb3" translate="yes" xml:space="preserve">
          <source>__STDC_ISO_10646__</source>
          <target state="translated">__STDC_ISO_10646__</target>
        </trans-unit>
        <trans-unit id="230648d096a182990dad2c93fa8e616a0bed8465" translate="yes" xml:space="preserve">
          <source>__STDC_MB_MIGHT_NEQ_WC__</source>
          <target state="translated">__STDC_MB_MIGHT_NEQ_WC__</target>
        </trans-unit>
        <trans-unit id="aec164fb4da1e304eadad72b50ba5910b1144c03" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_16__</source>
          <target state="translated">__STDC_UTF_16__</target>
        </trans-unit>
        <trans-unit id="92432151980d707704b3ddfa392fde3ab589eb6c" translate="yes" xml:space="preserve">
          <source>__STDC_UTF_32__</source>
          <target state="translated">__STDC_UTF_32__</target>
        </trans-unit>
        <trans-unit id="04202f9ce8c923e1e74ba2bfa78f2696041116d2" translate="yes" xml:space="preserve">
          <source>__STDC_VERSION__</source>
          <target state="translated">__STDC_VERSION__</target>
        </trans-unit>
        <trans-unit id="e7fe05e43de55659e13d860cf51adc28583a4875" translate="yes" xml:space="preserve">
          <source>__STDC__</source>
          <target state="translated">__STDC__</target>
        </trans-unit>
        <trans-unit id="cf716a68ef036dac529946b2640a330f562725fe" translate="yes" xml:space="preserve">
          <source>__TIME__</source>
          <target state="translated">__TIME__</target>
        </trans-unit>
        <trans-unit id="9c3e29639fd2bfaa4db627da53f4d56eac9f0ec0" translate="yes" xml:space="preserve">
          <source>__alignas_is_defined</source>
          <target state="translated">__alignas_is_defined</target>
        </trans-unit>
        <trans-unit id="d950e8ee18472fe83432e8178dd5392fac322513" translate="yes" xml:space="preserve">
          <source>__bool_true_false_are_defined</source>
          <target state="translated">__bool_true_false_are_defined</target>
        </trans-unit>
        <trans-unit id="a6268e3a2fc1725738e330bb09c9305b72ece231" translate="yes" xml:space="preserve">
          <source>__cplusplus</source>
          <target state="translated">__cplusplus</target>
        </trans-unit>
        <trans-unit id="e03702be2b6d9f308bc474cdb111403f31d2ea87" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_bases</source>
          <target state="translated">__cpp_aggregate_bases</target>
        </trans-unit>
        <trans-unit id="78f7eebcfee8baee7f506621f7ceff180ebb38c2" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_nsdmi</source>
          <target state="translated">__cpp_aggregate_nsdmi</target>
        </trans-unit>
        <trans-unit id="aecf58d673edcb66d050d3e2e7eba5a0afe4185c" translate="yes" xml:space="preserve">
          <source>__cpp_aggregate_paren_init</source>
          <target state="translated">__cpp_aggregate_paren_init</target>
        </trans-unit>
        <trans-unit id="4db17205b03376efcf08532704df0a94b80ff2e1" translate="yes" xml:space="preserve">
          <source>__cpp_alias_templates</source>
          <target state="translated">__cpp_alias_templates</target>
        </trans-unit>
        <trans-unit id="1b50ffd26242db4d6bb36e8a073d57b42af92dbe" translate="yes" xml:space="preserve">
          <source>__cpp_aligned_new</source>
          <target state="translated">__cpp_aligned_new</target>
        </trans-unit>
        <trans-unit id="27d2797bf877b1368535c5fbc7789bf8e7a43d75" translate="yes" xml:space="preserve">
          <source>__cpp_attributes</source>
          <target state="translated">__cpp_attributes</target>
        </trans-unit>
        <trans-unit id="fa07d30cba0187822a54da7812f67ef73fb0b29b" translate="yes" xml:space="preserve">
          <source>__cpp_binary_literals</source>
          <target state="translated">__cpp_binary_literals</target>
        </trans-unit>
        <trans-unit id="9233221aaacde95fdd55b38eb0f389324843a986" translate="yes" xml:space="preserve">
          <source>__cpp_capture_star_this</source>
          <target state="translated">__cpp_capture_star_this</target>
        </trans-unit>
        <trans-unit id="fbff2a2d3bc0732868b008428dd2e17daf86c9d1" translate="yes" xml:space="preserve">
          <source>__cpp_char8_t</source>
          <target state="translated">__cpp_char8_t</target>
        </trans-unit>
        <trans-unit id="35879cf6edddadc7f07576b594f812ccd01e0e28" translate="yes" xml:space="preserve">
          <source>__cpp_conditional_explicit</source>
          <target state="translated">__cpp_conditional_explicit</target>
        </trans-unit>
        <trans-unit id="6554a18ee88c8522382d28ab36f8ebd7e175fe13" translate="yes" xml:space="preserve">
          <source>__cpp_constexpr</source>
          <target state="translated">__cpp_constexpr</target>
        </trans-unit>
        <trans-unit id="e1c9cd84aa5ce04eef2027ea160ca3290b7ad000" translate="yes" xml:space="preserve">
          <source>__cpp_coroutines</source>
          <target state="translated">__cpp_coroutines</target>
        </trans-unit>
        <trans-unit id="1a2e5b6980d3ec352ab8610b6aebe0331f7c85de" translate="yes" xml:space="preserve">
          <source>__cpp_decltype</source>
          <target state="translated">__cpp_decltype</target>
        </trans-unit>
        <trans-unit id="30e058b311be2115aab20cb7ab797af4bf73322c" translate="yes" xml:space="preserve">
          <source>__cpp_decltype_auto</source>
          <target state="translated">__cpp_decltype_auto</target>
        </trans-unit>
        <trans-unit id="242a749b73f040bf68fa933b9175781fd85d21c1" translate="yes" xml:space="preserve">
          <source>__cpp_deduction_guides</source>
          <target state="translated">__cpp_deduction_guides</target>
        </trans-unit>
        <trans-unit id="3a8bdd7fb017e4f5b12dd8b2fab50c0f9a716657" translate="yes" xml:space="preserve">
          <source>__cpp_delegating_constructors</source>
          <target state="translated">__cpp_delegating_constructors</target>
        </trans-unit>
        <trans-unit id="975250ed39319bc10f0e4f6ba32b904cf175257c" translate="yes" xml:space="preserve">
          <source>__cpp_enumerator_attributes</source>
          <target state="translated">__cpp_enumerator_attributes</target>
        </trans-unit>
        <trans-unit id="3b5c1d2ec9a03cdd0631a101d55a030f176f3d74" translate="yes" xml:space="preserve">
          <source>__cpp_fold_expressions</source>
          <target state="translated">__cpp_fold_expressions</target>
        </trans-unit>
        <trans-unit id="dd54e558a55e90a31a278a30b8a17bd0470a27e5" translate="yes" xml:space="preserve">
          <source>__cpp_generic_lambdas</source>
          <target state="translated">__cpp_generic_lambdas</target>
        </trans-unit>
        <trans-unit id="5851aabfab46bf1cf3f38d2a662260f69f39fefc" translate="yes" xml:space="preserve">
          <source>__cpp_guaranteed_copy_elision</source>
          <target state="translated">__cpp_guaranteed_copy_elision</target>
        </trans-unit>
        <trans-unit id="64dc522012e8e37b94c68ea1e95e711e0d899c02" translate="yes" xml:space="preserve">
          <source>__cpp_hex_float</source>
          <target state="translated">__cpp_hex_float</target>
        </trans-unit>
        <trans-unit id="3817658cc0a09b582191a5b7ff9d3c12fb638b2d" translate="yes" xml:space="preserve">
          <source>__cpp_if_constexpr</source>
          <target state="translated">__cpp_if_constexpr</target>
        </trans-unit>
        <trans-unit id="01e50fa24457c5e9436a8e8e470f75ec87f89e94" translate="yes" xml:space="preserve">
          <source>__cpp_impl_destroying_delete</source>
          <target state="translated">__cpp_impl_destroying_delete</target>
        </trans-unit>
        <trans-unit id="10f562ee8727c9aeeefccee7e22065b234af8837" translate="yes" xml:space="preserve">
          <source>__cpp_impl_three_way_comparison</source>
          <target state="translated">__cpp_impl_three_way_comparison</target>
        </trans-unit>
        <trans-unit id="8372b211ab7aa3d2db5ef6dbe4bf9e84d46edd52" translate="yes" xml:space="preserve">
          <source>__cpp_inheriting_constructors</source>
          <target state="translated">__cpp_inheriting_constructors</target>
        </trans-unit>
        <trans-unit id="8db78a428ed6164ef434f29d445b397d48025bd3" translate="yes" xml:space="preserve">
          <source>__cpp_init_captures</source>
          <target state="translated">__cpp_init_captures</target>
        </trans-unit>
        <trans-unit id="3331bad3edb7735ec64c6916056cfc10590dcf69" translate="yes" xml:space="preserve">
          <source>__cpp_initializer_lists</source>
          <target state="translated">__cpp_initializer_lists</target>
        </trans-unit>
        <trans-unit id="81e37cead058df9398dca1e6d13208a976c4012c" translate="yes" xml:space="preserve">
          <source>__cpp_inline_variables</source>
          <target state="translated">__cpp_inline_variables</target>
        </trans-unit>
        <trans-unit id="3c68286ccf869158575094937b8b2a98ffb48599" translate="yes" xml:space="preserve">
          <source>__cpp_lambdas</source>
          <target state="translated">__cpp_lambdas</target>
        </trans-unit>
        <trans-unit id="2590a0ceb1649ffba013a25521809a21cd1284de" translate="yes" xml:space="preserve">
          <source>__cpp_namespace_attributes</source>
          <target state="translated">__cpp_namespace_attributes</target>
        </trans-unit>
        <trans-unit id="30cc60a82cc1d4477a2e07c1fa7a6a64cc1023c3" translate="yes" xml:space="preserve">
          <source>__cpp_noexcept_function_type</source>
          <target state="translated">__cpp_noexcept_function_type</target>
        </trans-unit>
        <trans-unit id="2593d2642e9db46e71f999b1bc148024d6d0b831" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_args</source>
          <target state="translated">__cpp_nontype_template_args</target>
        </trans-unit>
        <trans-unit id="1892415e299d418abcb2ce3608af04f19ac199e1" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_auto</source>
          <target state="translated">__cpp_nontype_template_parameter_auto</target>
        </trans-unit>
        <trans-unit id="8e2497a317030abf3388ed8fcdc0f581460fd74b" translate="yes" xml:space="preserve">
          <source>__cpp_nontype_template_parameter_class</source>
          <target state="translated">__cpp_nontype_template_parameter_class</target>
        </trans-unit>
        <trans-unit id="6f298ec98a281e895e57730ee42e4b685bf1d6e1" translate="yes" xml:space="preserve">
          <source>__cpp_nsdmi</source>
          <target state="translated">__cpp_nsdmi</target>
        </trans-unit>
        <trans-unit id="7844fe22ff8583f864600cf24c8acf071a07a268" translate="yes" xml:space="preserve">
          <source>__cpp_range_based_for</source>
          <target state="translated">__cpp_range_based_for</target>
        </trans-unit>
        <trans-unit id="e94a403428d4ea97b6f263dbcb0874c541f05fc8" translate="yes" xml:space="preserve">
          <source>__cpp_raw_strings</source>
          <target state="translated">__cpp_raw_strings</target>
        </trans-unit>
        <trans-unit id="2a807128a5985f4aedc323c209f0b26cf031ddc5" translate="yes" xml:space="preserve">
          <source>__cpp_ref_qualifiers</source>
          <target state="translated">__cpp_ref_qualifiers</target>
        </trans-unit>
        <trans-unit id="ec7f8108d8bd7c3189219118c4b92ebae110f376" translate="yes" xml:space="preserve">
          <source>__cpp_return_type_deduction</source>
          <target state="translated">__cpp_return_type_deduction</target>
        </trans-unit>
        <trans-unit id="a27448bb794e05840712bcbb343a4cbf12fadae2" translate="yes" xml:space="preserve">
          <source>__cpp_rvalue_references</source>
          <target state="translated">__cpp_rvalue_references</target>
        </trans-unit>
        <trans-unit id="28d6e14e6e0b8b130a165866cca9649aa7e9d864" translate="yes" xml:space="preserve">
          <source>__cpp_sized_deallocation</source>
          <target state="translated">__cpp_sized_deallocation</target>
        </trans-unit>
        <trans-unit id="d77473f1a619fc342dfc9123063a318297214d20" translate="yes" xml:space="preserve">
          <source>__cpp_static_assert</source>
          <target state="translated">__cpp_static_assert</target>
        </trans-unit>
        <trans-unit id="af80adf8b09bcfceb7e7134decd3d99ebd88c373" translate="yes" xml:space="preserve">
          <source>__cpp_structured_bindings</source>
          <target state="translated">__cpp_structured_bindings</target>
        </trans-unit>
        <trans-unit id="5456a2323fecac083d969b4421be5b3b5e785149" translate="yes" xml:space="preserve">
          <source>__cpp_template_template_args</source>
          <target state="translated">__cpp_template_template_args</target>
        </trans-unit>
        <trans-unit id="ddc5e77386a83826283ed12a4b5d3455f2275f1a" translate="yes" xml:space="preserve">
          <source>__cpp_threadsafe_static_init</source>
          <target state="translated">__cpp_threadsafe_static_init</target>
        </trans-unit>
        <trans-unit id="a51600d8c1a1f10a16f1e43b746d8821a1ba5bff" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_characters</source>
          <target state="translated">__cpp_unicode_characters</target>
        </trans-unit>
        <trans-unit id="696ac6453d6507dd7871ba65e03fe52e19383ef5" translate="yes" xml:space="preserve">
          <source>__cpp_unicode_literals</source>
          <target state="translated">__cpp_unicode_literals</target>
        </trans-unit>
        <trans-unit id="fcfb6a809b1f0636cfdcac8dcaf0a56faf741fe9" translate="yes" xml:space="preserve">
          <source>__cpp_user_defined_literals</source>
          <target state="translated">__cpp_user_defined_literals</target>
        </trans-unit>
        <trans-unit id="793fd52dc655ccacc0d8fa1b3bf368e5266577b4" translate="yes" xml:space="preserve">
          <source>__cpp_variable_templates</source>
          <target state="translated">__cpp_variable_templates</target>
        </trans-unit>
        <trans-unit id="b2c1a1181d35bf405e3ead748a7662168e324024" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_templates</source>
          <target state="translated">__cpp_variadic_templates</target>
        </trans-unit>
        <trans-unit id="423eb61df1fcdbb8fb8c6511db90aa6fb0318eaf" translate="yes" xml:space="preserve">
          <source>__cpp_variadic_using</source>
          <target state="translated">__cpp_variadic_using</target>
        </trans-unit>
        <trans-unit id="d8db95cc58ad2925bc93429910aec8cf2d80ad01" translate="yes" xml:space="preserve">
          <source>__func__</source>
          <target state="translated">__func__</target>
        </trans-unit>
        <trans-unit id="86f7e437faa5a7fce15d1ddcb9eaeaea377667b8" translate="yes" xml:space="preserve">
          <source>a</source>
          <target state="translated">a</target>
        </trans-unit>
        <trans-unit id="d66612ccc3a3c60bbf9be396b2e583b9ad6f732e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">una expresi&amp;oacute;n &lt;a href=&quot;../../language/dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="578b0d09cf884cabb2256541be565e3232f4a2d1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../language/throw&quot;&gt;&lt;code&gt;throw&lt;/code&gt;&lt;/a&gt; expression</source>
          <target state="translated">una expresi&amp;oacute;n de &lt;a href=&quot;../../language/throw&quot;&gt; &lt;code&gt;throw&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0c35fd85853bd90c9dea0e943c9e3e345e596a8c" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt; that accepts every possible alternative from every variant</source>
          <target state="translated">Un &lt;a href=&quot;../../named_req/callable&quot;&gt;llamado&lt;/a&gt; que acepta todas las alternativas posibles de cada variante</target>
        </trans-unit>
        <trans-unit id="0f547d6f47fe102ed4af5089aaf331e46cb4bd5e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/lambda&quot;&gt;closure&lt;/a&gt; type</source>
          <target state="translated">un tipo de &lt;a href=&quot;../language/lambda&quot;&gt;cierre&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e0406f8e858cd057dce3f1a1bd186c9b49e3cd51" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;pseudo-destructor call&lt;/a&gt; (if &lt;code&gt;It&lt;/code&gt; is a scalar type)</source>
          <target state="translated">una &lt;a href=&quot;../language/operator_member_access#Built-in_member_access_operators&quot;&gt;llamada pseudo-destructor&lt;/a&gt; (si &lt;code&gt;It&lt;/code&gt; es un tipo escalar)</target>
        </trans-unit>
        <trans-unit id="2f2aa4051bfd7ae365b4f4b11cedb58bbfd66b3e" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; whose result type is convertible to &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt;</source>
          <target state="translated">un &lt;a href=&quot;../named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; cuyo tipo de resultado es convertible a &lt;code&gt;&lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;RandomIt&amp;gt;::difference_type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f35df8d2006030e7d4d979822b8a81b4761ea9f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of a sequence generated by repeatedly incrementing an initial value</source>
          <target state="translated">Una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; consiste en una secuencia generada al incrementar repetidamente un valor inicial</target>
        </trans-unit>
        <trans-unit id="f1b66b4d9a0ae57bf6f377005ad0ae6842f473ed" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the first N elements of another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; consta de los primeros N elementos de otra &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ae981f6c70dcb78f089b85eeb651ce9e721b682b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the sequence obtained from flattening a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;s&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; consiste en la secuencia obtenida al aplanar una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; de &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e20442d4936a5775a6caf427d491901e50216ebf" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of a sequence that applies a transformation function to each element</source>
          <target state="translated">Una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; de una secuencia que aplica una funci&amp;oacute;n de transformaci&amp;oacute;n a cada elemento</target>
        </trans-unit>
        <trans-unit id="289a5f74d80c8aa744c90c4ee3868ed8609c9f49" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; de los elementos de alg&amp;uacute;n otro &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a94750304f2970083f4213aac2cf32daebafda1d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; over the subranges obtained from splitting another &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; using a delimiter</source>
          <target state="translated">una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; sobre los subrangos obtenidos al dividir otra &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; usando un delimitador</target>
        </trans-unit>
        <trans-unit id="3a4653cdeeb9369cc880c44c330b4bacc547ec37" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that consists of the elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that satisfies a predicate</source>
          <target state="translated">Una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que consta de los elementos de un &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; que satisface un predicado</target>
        </trans-unit>
        <trans-unit id="6c2fbed5ca96d4b2858696b97f8e59367cd9ca66" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that contains a single element of a specified value</source>
          <target state="translated">Una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que contiene un &amp;uacute;nico elemento de un valor especificado</target>
        </trans-unit>
        <trans-unit id="c7f3a3db304dcf5be7bc978bb2552c12c8bc06fb" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que incluye todos los elementos de un &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="af11d84750e4dccfceeeab50c1f40114755c03a1" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that iterates over the elements of another bidirectional view in reverse order</source>
          <target state="translated">Una &lt;a href=&quot;../ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que itera sobre los elementos de otra vista bidireccional en orden inverso</target>
        </trans-unit>
        <trans-unit id="e8c8ad0f2aa5b2688c79e49a80f74556ff5bb1c3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;../types/is_scalar&quot;&gt;scalar type&lt;/a&gt;;</source>
          <target state="translated">un &lt;a href=&quot;../types/is_scalar&quot;&gt;tipo escalar&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="c5f1f7ebf1a60286c3263705f1ff2699892ba31a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; that establishes an ordering relation</source>
          <target state="translated">un &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; que establece una relaci&amp;oacute;n de orden</target>
        </trans-unit>
        <trans-unit id="b54276a912036a81a33307973d33e286dfbef1ac" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;bit field&lt;/i&gt;&lt;/a&gt; type can be converted to &lt;code&gt;int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise to &lt;code&gt;unsigned int&lt;/code&gt; if it can represent entire value range of the bit field, otherwise no integral promotions apply;</source>
          <target state="translated">un tipo de &lt;a href=&quot;bit_field&quot;&gt;&lt;i&gt;campo de bits&lt;/i&gt;&lt;/a&gt; se puede convertir a &lt;code&gt;int&lt;/code&gt; si puede representar el rango de valores completo del campo de bits, de lo contrario a &lt;code&gt;unsigned int&lt;/code&gt; si puede representar el rango de valores completos del campo de bits, de lo contrario no se aplican promociones integrales;</target>
        </trans-unit>
        <trans-unit id="04be27008e83afb2d331f92d72c2fab2182c7c06" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; name, such as &lt;code&gt;operator bool&lt;/code&gt;;</source>
          <target state="translated">un nombre de &lt;a href=&quot;cast_operator&quot;&gt;funci&amp;oacute;n de conversi&amp;oacute;n definido por el usuario&lt;/a&gt; , como &lt;code&gt;operator bool&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="842b9bb73f31c7a70a7a8e8933647e7f312f7d30" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class&quot;&gt;class declaration&lt;/a&gt;. The class name declared becomes a template name.</source>
          <target state="translated">Una &lt;a href=&quot;class&quot;&gt;declaraci&amp;oacute;n de clase&lt;/a&gt; . El nombre de clase declarado se convierte en un nombre de plantilla.</target>
        </trans-unit>
        <trans-unit id="58329cef5c48b9dd6d75ade29a0076bc7230f05a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;class#Member_specification&quot;&gt;class member declaration&lt;/a&gt;;</source>
          <target state="translated">una &lt;a href=&quot;class#Member_specification&quot;&gt;declaraci&amp;oacute;n de miembro de la clase&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="197dcdb99acb57525f9c2a6fe89a245471fd8142" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;expresi&amp;oacute;n constante contextualizada de tipo &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b40006546d705539bc635f3175ea4d35431ac2da" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;constraint expression&lt;/a&gt; which restricts the template parameters accepted by this function template</source>
          <target state="translated">una &lt;a href=&quot;constraints&quot;&gt;expresi&amp;oacute;n de&lt;/a&gt; restricci&amp;oacute;n que restringe los par&amp;aacute;metros de plantilla aceptados por esta plantilla de funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="dbc4d6e8690db53ad192b32cd88e3433f51c72d3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints&quot;&gt;requires-expression&lt;/a&gt;, such as &lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt;;</source>
          <target state="translated">una &lt;a href=&quot;constraints&quot;&gt;expresi&amp;oacute;n requerida&lt;/a&gt; , como &lt;code&gt;requires (T i) { typename T::type; }&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="6a7178c89e852f09b520cb3d8d0a0704888c1d34" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;constraints#Concepts&quot;&gt;concept&lt;/a&gt; name, optionally qualified, optionally followed by a template argument list enclosed in &amp;lt;&amp;gt;</source>
          <target state="translated">un nombre de &lt;a href=&quot;constraints#Concepts&quot;&gt;concepto&lt;/a&gt; , opcionalmente calificado, opcionalmente seguido de una lista de argumentos de plantilla encerrada en &amp;lt;&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e54b0edc591fc30ea27121f4b241249a88d6dd05" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a named variable, whose type is the type of the element of the sequence represented by range_expression, or a reference to that type. Often uses the &lt;a href=&quot;auto&quot;&gt;auto specifier&lt;/a&gt; for automatic type deduction</source>
          <target state="translated">una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; de una variable con nombre, cuyo tipo es el tipo del elemento de la secuencia representada por range_expression, o una referencia a ese tipo. A menudo usa el &lt;a href=&quot;auto&quot;&gt;especificador&lt;/a&gt; autom&amp;aacute;tico para la deducci&amp;oacute;n autom&amp;aacute;tica de tipo</target>
        </trans-unit>
        <trans-unit id="feba1f8215a9e5044f736d79557f6d6af77814ce" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a single variable with a brace-or-equals &lt;a href=&quot;initialization&quot;&gt;initializer&lt;/a&gt;. the initializer is evaluated before each iteration, and if the value of the declared variable converts to &lt;code&gt;false&lt;/code&gt;, the loop is exited.</source>
          <target state="translated">Una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; de una sola variable con un &lt;a href=&quot;initialization&quot;&gt;inicializador de&lt;/a&gt; par&amp;eacute;ntesis o igual . el inicializador se eval&amp;uacute;a antes de cada iteraci&amp;oacute;n, y si el valor de la variable declarada se convierte en &lt;code&gt;false&lt;/code&gt; , se cierra el bucle.</target>
        </trans-unit>
        <trans-unit id="9b8e7399060c9f5d9013f6aa031f2daeaf247245" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a variable. The declared variable name becomes a template name.</source>
          <target state="translated">Una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; de una variable. El nombre de la variable declarada se convierte en un nombre de plantilla.</target>
        </trans-unit>
        <trans-unit id="0d19b02053245fd658744be05acb66f6795dfec5" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a loop counter variable with initializer, but it may declare arbitrary many variables</source>
          <target state="translated">una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n simple&lt;/a&gt; , t&amp;iacute;picamente una declaraci&amp;oacute;n de una variable de contador de bucle con inicializador, pero puede declarar muchas variables arbitrarias</target>
        </trans-unit>
        <trans-unit id="c20d095ecceecc0d92c5b636f980edf3d560c27f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or be a &lt;a href=&quot;structured_binding&quot;&gt;structured binding declaration&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n simple&lt;/a&gt; , t&amp;iacute;picamente una declaraci&amp;oacute;n de una variable con inicializador, pero puede declarar muchas variables arbitrarias o ser una &lt;a href=&quot;structured_binding&quot;&gt;declaraci&amp;oacute;n de enlace estructurado&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c035c17095b570541b804043bd0d5c99497e6655" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or be a decomposition declaration</source>
          <target state="translated">una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n simple&lt;/a&gt; , t&amp;iacute;picamente una declaraci&amp;oacute;n de una variable con inicializador, pero puede declarar muchas variables arbitrarias o ser una declaraci&amp;oacute;n de descomposici&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="4b734860e87e75b35551beb9fadebdf9940d0be6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations&quot;&gt;simple declaration&lt;/a&gt;, typically a declaration of a variable with initializer, but it may declare arbitrary many variables or structured bindings</source>
          <target state="translated">una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n simple&lt;/a&gt; , t&amp;iacute;picamente una declaraci&amp;oacute;n de una variable con inicializador, pero puede declarar muchas variables arbitrarias o enlaces estructurados</target>
        </trans-unit>
        <trans-unit id="2201d89e3d55486c60323b0565f06038ff02c6ab" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;declarations#Simple_declaration&quot;&gt;simple declaration&lt;/a&gt; or &lt;a href=&quot;function#Function_definition&quot;&gt;function definition&lt;/a&gt; at namespace scope;</source>
          <target state="translated">una &lt;a href=&quot;declarations#Simple_declaration&quot;&gt;declaraci&amp;oacute;n simple&lt;/a&gt; o &lt;a href=&quot;function#Function_definition&quot;&gt;definici&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; en el &amp;aacute;mbito del espacio de nombres;</target>
        </trans-unit>
        <trans-unit id="c8bcda74ea89e3702ab08c50656a296f15b010fd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;expressions#Literals&quot;&gt;literal&lt;/a&gt; (except for &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;), such as &lt;code&gt;42&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;nullptr&lt;/code&gt;;</source>
          <target state="translated">un &lt;a href=&quot;expressions#Literals&quot;&gt;literal&lt;/a&gt; (excepto el &lt;a href=&quot;string_literal&quot;&gt;literal de cadena&lt;/a&gt; ), como &lt;code&gt;42&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;nullptr&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="8446974ce0d221e5eb27350acb15252dd76acf23" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt;, e.g. &lt;code&gt;&lt;a href=&quot;../concepts/swappable&quot;&gt;Swappable&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt;, &lt;code&gt;(&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object_v&lt;/a&gt;&amp;lt;Args&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt;, or any parenthesized expression</source>
          <target state="translated">una &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;expresi&amp;oacute;n primaria&lt;/a&gt; , por ejemplo, &lt;code&gt;&lt;a href=&quot;../concepts/swappable&quot;&gt;Swappable&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; , &lt;code&gt;(&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object_v&lt;/a&gt;&amp;lt;Args&amp;gt; &amp;amp;&amp;amp; ...)&lt;/code&gt; , o cualquier expresi&amp;oacute;n entre par&amp;eacute;ntesis</target>
        </trans-unit>
        <trans-unit id="500e95ea5cc0ecd68e30742d9d61e3323034d850" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt; where the type of at least one parameter uses the placeholder &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; or &lt;code&gt;Concept auto&lt;/code&gt;: the template parameter list will have one invented parameter for each placeholder (see Abbreviated function templates below</source>
          <target state="translated">una &lt;a href=&quot;function&quot;&gt;declaraci&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; donde el tipo de al menos un par&amp;aacute;metro utiliza el marcador de posici&amp;oacute;n &lt;a href=&quot;auto&quot;&gt;autom&amp;aacute;tico&lt;/a&gt; o &lt;code&gt;Concept auto&lt;/code&gt; : la lista de par&amp;aacute;metros de plantilla tendr&amp;aacute; un par&amp;aacute;metro inventado para cada marcador de posici&amp;oacute;n (consulte las plantillas de funciones abreviadas a continuaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="cf8f5a052390f7a051f82e9f9d21d32ee1c4a82a" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;. The function name declared becomes a template name.</source>
          <target state="translated">Una &lt;a href=&quot;function&quot;&gt;declaraci&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; . El nombre de la funci&amp;oacute;n declarado se convierte en un nombre de plantilla.</target>
        </trans-unit>
        <trans-unit id="c2f7755c6029f6a2726cac9e6db3c67772cad590" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function&quot;&gt;trailing return type&lt;/a&gt;,</source>
          <target state="translated">un &lt;a href=&quot;function&quot;&gt;tipo de retorno final&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="7edca23af0f84105b599f5a7b5d639d2bc955bbd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; in a &lt;a href=&quot;class#Member_specification&quot;&gt;class member declaration&lt;/a&gt; (including friend function declarations), outside of default arguments;</source>
          <target state="translated">una &lt;a href=&quot;function#Parameter_list&quot;&gt;declaraci&amp;oacute;n de par&amp;aacute;metro&lt;/a&gt; en una &lt;a href=&quot;class#Member_specification&quot;&gt;declaraci&amp;oacute;n de miembro de clase&lt;/a&gt; (incluidas las declaraciones de funci&amp;oacute;n amiga), fuera de los argumentos predeterminados;</target>
        </trans-unit>
        <trans-unit id="c118f25111af636da74b78a8eacfb1f5f20cd6c6" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; of a &lt;a href=&quot;function&quot;&gt;declarator for a function or function template&lt;/a&gt; whose name is qualified, outside of default arguments;</source>
          <target state="translated">una &lt;a href=&quot;function#Parameter_list&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; de par&amp;aacute;metro de un &lt;a href=&quot;function&quot;&gt;declarador para una funci&amp;oacute;n o plantilla de funci&amp;oacute;n&lt;/a&gt; cuyo nombre est&amp;aacute; calificado, fuera de los argumentos predeterminados;</target>
        </trans-unit>
        <trans-unit id="f1184f488a359d5c1d1504b481c38dad94714e6b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;function#Parameter_list&quot;&gt;parameter declaration&lt;/a&gt; of a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; outside of default arguments;</source>
          <target state="translated">una &lt;a href=&quot;function#Parameter_list&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; de par&amp;aacute;metro de una &lt;a href=&quot;lambda&quot;&gt;expresi&amp;oacute;n lambda&lt;/a&gt; fuera de los argumentos predeterminados;</target>
        </trans-unit>
        <trans-unit id="642baf6869f125ceaec67c589e398539c6e7f6ed" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; statement</source>
          <target state="translated">una declaraci&amp;oacute;n &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c907e534b1c94f336b7e2cf57a58189deb97fe5d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast&quot;&gt;standard conversion&lt;/a&gt;, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt;, or &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; to type &lt;code&gt;T*&lt;/code&gt; or &lt;code&gt;T&amp;amp;&lt;/code&gt;, except when converting from the &lt;a href=&quot;../types/null&quot;&gt;null pointer constant&lt;/a&gt; or from a &lt;a href=&quot;pointer#Pointers_to_void&quot;&gt;pointer to void&lt;/a&gt;;</source>
          <target state="translated">una &lt;a href=&quot;implicit_cast&quot;&gt;conversi&amp;oacute;n est&amp;aacute;ndar&lt;/a&gt; , &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; o &lt;a href=&quot;static_cast&quot;&gt;static_cast&lt;/a&gt; para escribir &lt;code&gt;T*&lt;/code&gt; o &lt;code&gt;T&amp;amp;&lt;/code&gt; , excepto cuando se convierte desde la &lt;a href=&quot;../types/null&quot;&gt;constante de puntero nulo&lt;/a&gt; o desde un &lt;a href=&quot;pointer#Pointers_to_void&quot;&gt;puntero a vac&amp;iacute;o&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="ff7412a5c700e7e775fdf95f63af3f717686860b" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast#Function_pointer_conversions&quot;&gt;function pointer conversion&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;implicit_cast#Function_pointer_conversions&quot;&gt;conversi&amp;oacute;n de puntero de funci&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="dd862ebece74d9a647884bc1f7ae05595e84d3dd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversion&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;conversi&amp;oacute;n de calificaci&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="78294718f1c4d725f8f92854d2e7408626ebcedd" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt;, such as &lt;code&gt;[](int x){ return x * x; }&lt;/code&gt;;</source>
          <target state="translated">una &lt;a href=&quot;lambda&quot;&gt;expresi&amp;oacute;n lambda&lt;/a&gt; , como &lt;code&gt;[](int x){ return x * x; }&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="84b39eaf4ad707d4a4dec485e938308dab148b12" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;sequence of names and scope resolution operators &lt;code&gt;::&lt;/code&gt; &lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;secuencia de nombres y operadores de resoluci&amp;oacute;n de alcance &lt;code&gt;::&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0b9cefe53156bc46a61aba49ceb2bcf93ec727d8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; that supports attempted lock acquisition</source>
          <target state="translated">un &lt;a href=&quot;named_req/basiclockable&quot;&gt;BasicLockable&lt;/a&gt; que admite intentos de adquisici&amp;oacute;n de bloqueo</target>
        </trans-unit>
        <trans-unit id="b2e74295624d6557dcdd2cc01e3b042f422a51a5" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; that establishes an ordering relation</source>
          <target state="translated">un &lt;a href=&quot;named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; que establece una relaci&amp;oacute;n de orden</target>
        </trans-unit>
        <trans-unit id="c9fc14a958079406695f087786e7323e37febb5f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/clock&quot;&gt;Clock&lt;/a&gt; that does not throw exceptions</source>
          <target state="translated">un &lt;a href=&quot;named_req/clock&quot;&gt;reloj&lt;/a&gt; que no arroja excepciones</target>
        </trans-unit>
        <trans-unit id="a8f9bb45156d6a61bb73c330f242efbcd3e0fcea" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that for inputs with different values has a low probability of giving the same output</source>
          <target state="translated">un objeto de &lt;a href=&quot;named_req/functionobject&quot;&gt;funci&amp;oacute;n&lt;/a&gt; que para entradas con valores diferentes tiene una baja probabilidad de dar la misma salida</target>
        </trans-unit>
        <trans-unit id="ea59a46b0fa1e2f0e7670029ccdde75669c8d886" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that returns a value convertible to &lt;code&gt;bool&lt;/code&gt; for one argument without modifying it</source>
          <target state="translated">un &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; que devuelve un valor convertible a &lt;code&gt;bool&lt;/code&gt; para un argumento sin modificarlo</target>
        </trans-unit>
        <trans-unit id="b54d733aca75c1dec32ecb63027a79406e738ca0" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; that returns a value convertible to &lt;code&gt;bool&lt;/code&gt; for two arguments without modifying them</source>
          <target state="translated">un &lt;a href=&quot;named_req/functionobject&quot;&gt;FunctionObject&lt;/a&gt; que devuelve un valor convertible a &lt;code&gt;bool&lt;/code&gt; para dos argumentos sin modificarlos</target>
        </trans-unit>
        <trans-unit id="60356dec3126ca424603f3524c2c59c0f4d0e0b3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt; that protects against data races and sequentially consistent synchronization</source>
          <target state="translated">una &lt;a href=&quot;named_req/lockable&quot;&gt;cerradura&lt;/a&gt; que protege contra razas de datos y la sincronizaci&amp;oacute;n secuencialmente consistente</target>
        </trans-unit>
        <trans-unit id="78a14075ec6e560d582c534d1ea3a8368ec01c15" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/lockable&quot;&gt;Lockable&lt;/a&gt; that supports timed lock acquisition</source>
          <target state="translated">una &lt;a href=&quot;named_req/lockable&quot;&gt;cerradura&lt;/a&gt; que los apoyos cronometrados adquisici&amp;oacute;n de bloqueo</target>
        </trans-unit>
        <trans-unit id="2420df90cbe1b6e70248694fed79e630531d3b06" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/mutex&quot;&gt;Mutex&lt;/a&gt; that supports shared ownership semantics</source>
          <target state="translated">un &lt;a href=&quot;named_req/mutex&quot;&gt;Mutex&lt;/a&gt; que admite sem&amp;aacute;ntica de propiedad compartida</target>
        </trans-unit>
        <trans-unit id="79e44acb7900ed6728581d5d8a9042f7e17f14c3" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt; that transforms the output of another &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt;</source>
          <target state="translated">un &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt; que transforma la salida de otro &lt;a href=&quot;named_req/randomnumberengine&quot;&gt;RandomNumberEngine&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="e17ffa05e7a19b50f16c2ab3c2e4a41b726df14f" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; that protects against data races and sequentially consistent synchronization</source>
          <target state="translated">un &lt;a href=&quot;named_req/timedlockable&quot;&gt;TimedLockable&lt;/a&gt; que protege contra carreras de datos y sincronizaci&amp;oacute;n secuencialmente consistente</target>
        </trans-unit>
        <trans-unit id="782471ed828c26fe873bde60284584c9dc102f92" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; that supports shared ownership semantics</source>
          <target state="translated">un &lt;a href=&quot;named_req/timedmutex&quot;&gt;TimedMutex&lt;/a&gt; que admite sem&amp;aacute;ntica de propiedad compartida</target>
        </trans-unit>
        <trans-unit id="7d0093b4c5c45dc52be9aea4ff3837e330ec42b4" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;pointer&quot;&gt;pointer type&lt;/a&gt; (to object or to function);</source>
          <target state="translated">un &lt;a href=&quot;pointer&quot;&gt;tipo de puntero&lt;/a&gt; (para objetar o para funcionar);</target>
        </trans-unit>
        <trans-unit id="ae90d6992e65874408f2a555b237871969050472" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;pointer to member type&lt;/a&gt; (to member object or to member function);</source>
          <target state="translated">un &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;puntero al tipo de miembro&lt;/a&gt; (al objeto miembro o a la funci&amp;oacute;n miembro);</target>
        </trans-unit>
        <trans-unit id="089b5759d49b3f3e3e05a4ed136cf4cb2e556331" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt;, if any name that appears to the left of &lt;code&gt;::&lt;/code&gt; is a</source>
          <target state="translated">un &lt;a href=&quot;qualified_lookup&quot;&gt;nombre calificado&lt;/a&gt; , si alg&amp;uacute;n nombre que aparece a la izquierda de &lt;code&gt;::&lt;/code&gt; es un</target>
        </trans-unit>
        <trans-unit id="49c176e338afd9bd3c2793dd3aab24e8628e50cf" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;qualified_lookup&quot;&gt;qualified name&lt;/a&gt;, whose qualifier is the</source>
          <target state="translated">un &lt;a href=&quot;qualified_lookup&quot;&gt;nombre calificado&lt;/a&gt; , cuyo calificador es el</target>
        </trans-unit>
        <trans-unit id="906617abbba3f5b3395186a0beb57b664902cb46" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of a sequence generated by repeatedly incrementing an initial value</source>
          <target state="translated">Una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; consiste en una secuencia generada al incrementar repetidamente un valor inicial</target>
        </trans-unit>
        <trans-unit id="584a08c6718b46b2d5bafb7362ec47101daa6021" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the first N elements of another &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; consta de los primeros N elementos de otra &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="87aecd3717fd037445fe9653742baf83e68058f8" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; consisting of the sequence obtained from flattening a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;s&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; consiste en la secuencia obtenida al aplanar una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; de &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; s&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a37c7d31d124ed7013e20399a2b928cc3860b13d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of a sequence that applies a transformation function to each element</source>
          <target state="translated">Una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; de una secuencia que aplica una funci&amp;oacute;n de transformaci&amp;oacute;n a cada elemento</target>
        </trans-unit>
        <trans-unit id="15d88520977b781a636bb3e5929f30daaf0cc794" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of the elements of some other &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">Una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; de los elementos de alg&amp;uacute;n otro &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="a744d52e04d21449948de57a486e1984145b091d" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; over the subranges obtained from splitting another &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; using a delimiter</source>
          <target state="translated">Una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; sobre los subranges obtenidos al dividir otra &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; usando un delimitador</target>
        </trans-unit>
        <trans-unit id="ea2a829aa46d29fe3671781db0df1002a16f9f56" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that consists of the elements of a &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; that satisfies a predicate</source>
          <target state="translated">Una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que consta de los elementos de un &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; que satisface un predicado</target>
        </trans-unit>
        <trans-unit id="3270d31c1a13794c926d9de62c84a1561042e839" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that contains a single element of a specified value</source>
          <target state="translated">Una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que contiene un &amp;uacute;nico elemento de un valor especificado</target>
        </trans-unit>
        <trans-unit id="8ee5c0dac3dcdfb720bfc6c40ed3163b50c59d15" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que incluye todos los elementos de un &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="569c82165b27db13ed5aaf3e2bd4eadc158f3978" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;ranges/view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that iterates over the elements of another bidirectional view in reverse order</source>
          <target state="translated">Una &lt;a href=&quot;ranges/view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que itera sobre los elementos de otra vista bidireccional en orden inverso</target>
        </trans-unit>
        <trans-unit id="65f096eb23ce29a61ddace2d9bc3762ad47d07e2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;, such as &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt;;</source>
          <target state="translated">un &lt;a href=&quot;string_literal&quot;&gt;literal de cadena&lt;/a&gt; , como &lt;code&gt;&quot;Hello, world!&quot;&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="f91dfaeafd98f430989545790f287e35b5f20dc9" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;string_literal&quot;&gt;string literal&lt;/a&gt;;</source>
          <target state="translated">un &lt;a href=&quot;string_literal&quot;&gt;literal de cadena&lt;/a&gt; ;</target>
        </trans-unit>
        <trans-unit id="191a5a89aef337a4a629add8645510717aab9bf2" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;default argument of a type template parameter&lt;/a&gt;, or</source>
          <target state="translated">un &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;argumento predeterminado de un par&amp;aacute;metro de plantilla de tipo&lt;/a&gt; , o</target>
        </trans-unit>
        <trans-unit id="25def632dd3eeeb127af967f287d3c112d182fe9" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;templates&quot;&gt;template&lt;/a&gt; name followed by its argument list, such as &lt;code&gt;MyTemplate&amp;lt;int&amp;gt;&lt;/code&gt;;</source>
          <target state="translated">un nombre de &lt;a href=&quot;templates&quot;&gt;plantilla&lt;/a&gt; seguido de su lista de argumentos, como &lt;code&gt;MyTemplate&amp;lt;int&amp;gt;&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="552d64c54cb700af2ff2ba1111b75b5ffde66790" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;templates#template-id&quot;&gt;template-id&lt;/a&gt; where either</source>
          <target state="translated">una &lt;a href=&quot;templates#template-id&quot;&gt;plantilla-id&lt;/a&gt; donde</target>
        </trans-unit>
        <trans-unit id="663fb41f0d766e7269a5347cbd45d461e373d362" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;try_catch&quot;&gt;catch-clause&lt;/a&gt; for an exception of type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;T&amp;amp;&lt;/code&gt;, or &lt;code&gt;T*&lt;/code&gt;.</source>
          <target state="translated">una &lt;a href=&quot;try_catch&quot;&gt;cl&amp;aacute;usula catch&lt;/a&gt; para una excepci&amp;oacute;n de tipo &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;T&amp;amp;&lt;/code&gt; o &lt;code&gt;T*&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="208a7da5d29804a28adcf5b9f0314d6ff0dd0293" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt;</source>
          <target state="translated">un &lt;a href=&quot;try_catch&quot;&gt;bloque de prueba&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="5e94d0262c8aa644df44502fbb216fd3ee7762db" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;user_literal&quot;&gt;user-defined literal operator&lt;/a&gt; name, such as &lt;code&gt;operator &quot;&quot; _km&lt;/code&gt;;</source>
          <target state="translated">un nombre de &lt;a href=&quot;user_literal&quot;&gt;operador literal definido por el usuario&lt;/a&gt; , como el &lt;code&gt;operator &quot;&quot; _km&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="99934e9b58a1babae9be931f9f2fea4fc18fc0ee" translate="yes" xml:space="preserve">
          <source>a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; that includes all elements of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">una &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; que incluye todos los elementos de un &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="316d511c8aa53b7526805d4e5457d26523ec3796" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; to insert &lt;code&gt;p&lt;/code&gt; into</source>
          <target state="translated">a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; para insertar &lt;code&gt;p&lt;/code&gt; en</target>
        </trans-unit>
        <trans-unit id="fbd12644c821ad9dd5361ab305ce3eacebcd4452" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; to insert &lt;code&gt;ptr&lt;/code&gt; into</source>
          <target state="translated">a &lt;code&gt;&lt;a href=&quot;../../io/basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; para insertar &lt;code&gt;ptr&lt;/code&gt; en</target>
        </trans-unit>
        <trans-unit id="a4b2b6efcf66147f984a4f4c3f1b193be394563b" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt;, pointer to a null-terminated character/wide character string, or an input iterator that points to a null-terminated character/wide character sequence. The character type must be one of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, (since C++20)&lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;</source>
          <target state="translated">un &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; , puntero a un car&amp;aacute;cter con terminaci&amp;oacute;n nula / cadena de caracteres anchos, o un iterador de entrada que apunta a un car&amp;aacute;cter con terminaci&amp;oacute;n nula / secuencia de caracteres anchos. El tipo de car&amp;aacute;cter debe ser &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , (desde C ++ 20) &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6b73bd2673de988b6a6630c49706a06b3e5e3bc7" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; representing the hash value.</source>
          <target state="translated">un &lt;code&gt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; representa el valor hash.</target>
        </trans-unit>
        <trans-unit id="2d166a98420f3d07a1a5cfa0f15025354bc8ab03" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; object to compare</source>
          <target state="translated">un objeto &lt;code&gt;&lt;a href=&quot;../locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; para comparar</target>
        </trans-unit>
        <trans-unit id="d5b6a5305c4cd7829271fc0bef5a5469bcdbe9cb" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; type representing the tick period of the clock, in seconds</source>
          <target state="translated">un tipo &lt;code&gt;&lt;a href=&quot;../numeric/ratio/ratio&quot;&gt;std::ratio&lt;/a&gt;&lt;/code&gt; representa el per&amp;iacute;odo de tick del reloj, en segundos</target>
        </trans-unit>
        <trans-unit id="28c282d6688b8d9817fe3654bc3aea6ec9948374" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; object</source>
          <target state="translated">un &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; de objetos</target>
        </trans-unit>
        <trans-unit id="5c15ad055910b7bab983130d3d0318587f713ea8" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; struct containing the constructor options</source>
          <target state="translated">una estructura &lt;code&gt;&lt;a href=&quot;../pool_options&quot;&gt;std::pmr::pool_options&lt;/a&gt;&lt;/code&gt; contiene las opciones del constructor</target>
        </trans-unit>
        <trans-unit id="54930ae4d23e136dcc5b456eec1ed82612b38402" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e940f25cbf8cd2aa56592576ed0c20278acc2bff" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; that will be viewed by this &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">un &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; que ser&amp;aacute; visto por este &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ecdb524f3aba763d3ff8829b8227e31bef82cacf" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;basic_string&lt;/code&gt; used to initialize the buffer</source>
          <target state="translated">Una &lt;code&gt;basic_string&lt;/code&gt; utilizada para inicializar el b&amp;uacute;fer</target>
        </trans-unit>
        <trans-unit id="a0e668eabf5840cd34ea3e0f28321b311fe77422" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;duration&lt;/code&gt; to copy from</source>
          <target state="translated">una &lt;code&gt;duration&lt;/code&gt; para copiar</target>
        </trans-unit>
        <trans-unit id="6b0c69e8badd1554c8a8794737ab30e685ebbeb0" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence Y, then A precedes Y in S c) if a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence X</source>
          <target state="translated">una cerca de &lt;code&gt;memory_order_seq_cst&lt;/code&gt; Y, entonces A precede a Y en S c) si una cerca de &lt;code&gt;memory_order_seq_cst&lt;/code&gt; X</target>
        </trans-unit>
        <trans-unit id="f0b51354e700071d41d8e696cc9589f3f0e23e24" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; fence Y, then X precedes Y in S</source>
          <target state="translated">una cerca &lt;code&gt;memory_order_seq_cst&lt;/code&gt; Y, luego X precede a Y en S</target>
        </trans-unit>
        <trans-unit id="9d2d1cf5df9aa21b5f43d6c3730e0127bacfd20a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;mutex&lt;/code&gt; from the time that it successfully calls either &lt;a href=&quot;mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt; until it calls &lt;a href=&quot;mutex/unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">un &lt;code&gt;mutex&lt;/code&gt; desde el momento en que llama con &amp;eacute;xito a &lt;a href=&quot;mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; hasta que llama a &lt;a href=&quot;mutex/unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="863d62328d5f1e3a0af927034efd3cb49a858007" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;recursive_mutex&lt;/code&gt; for a period of time that starts when it successfully calls either &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;. During this period, the thread may make additional calls to &lt;a href=&quot;recursive_mutex/lock&quot;&gt;&lt;code&gt;lock&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;recursive_mutex/try_lock&quot;&gt;&lt;code&gt;try_lock&lt;/code&gt;&lt;/a&gt;. The period of ownership ends when the thread makes a matching number of calls to &lt;a href=&quot;recursive_mutex/unlock&quot;&gt;&lt;code&gt;unlock&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">un &lt;code&gt;recursive_mutex&lt;/code&gt; por un per&amp;iacute;odo de tiempo que comienza cuando se llama correctamente, ya sea &lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; . Durante este per&amp;iacute;odo, el hilo puede hacer llamadas adicionales para&lt;a href=&quot;recursive_mutex/lock&quot;&gt; &lt;code&gt;lock&lt;/code&gt; &lt;/a&gt; o&lt;a href=&quot;recursive_mutex/try_lock&quot;&gt; &lt;code&gt;try_lock&lt;/code&gt; &lt;/a&gt; . El per&amp;iacute;odo de propiedad finaliza cuando el hilo realiza un n&amp;uacute;mero coincidente de llamadas para&lt;a href=&quot;recursive_mutex/unlock&quot;&gt; &lt;code&gt;unlock&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="60b02f0b0cd6b462a069eb540be8a96dc7f7ee1a" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;regex_iterator&lt;/code&gt; to compare to</source>
          <target state="translated">un &lt;code&gt;regex_iterator&lt;/code&gt; para comparar</target>
        </trans-unit>
        <trans-unit id="5f914aa0db45d26f593fbd3b3acb0736aa4d7f34" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::chrono::local_info&lt;/code&gt; describing the result of the conversion attempt</source>
          <target state="translated">a &lt;code&gt;std::chrono::local_info&lt;/code&gt; describe el resultado del intento de conversi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="e92b7ebf5ac6699b0419aafc5019fd69e5b495d1" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::future&lt;/code&gt; that will transfer state to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">un &lt;code&gt;std::future&lt;/code&gt; que transferir&amp;aacute; el estado a &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="45c38558d576f7077eb936fedf2e6993f71552d0" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::partial_ordering &lt;/code&gt; value to check</source>
          <target state="translated">un valor &lt;code&gt;std::partial_ordering &lt;/code&gt; para verificar</target>
        </trans-unit>
        <trans-unit id="6cb6d8aec9d0d7086c8d7b490355b651816e9f71" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::partial_ordering&lt;/code&gt; value to check</source>
          <target state="translated">un valor &lt;code&gt;std::partial_ordering&lt;/code&gt; para verificar</target>
        </trans-unit>
        <trans-unit id="2abc4eda553b7e2119f385f0dd8fe079b5901fc1" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::shared_future&lt;/code&gt; that will transfer state to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">un &lt;code&gt;std::shared_future&lt;/code&gt; que transferir&amp;aacute; el estado a &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ea1ec8d4b72649962e567349201f78a7aecef264" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::strong_equality&lt;/code&gt; value to check</source>
          <target state="translated">una &lt;code&gt;std::strong_equality&lt;/code&gt; valor std :: strong_equality para verificar</target>
        </trans-unit>
        <trans-unit id="842ba00de4d8ab8dd4f532e899b87cf7099a8622" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::strong_ordering&lt;/code&gt; value to check</source>
          <target state="translated">una &lt;code&gt;std::strong_ordering&lt;/code&gt; valor std :: strong_ordering para verificar</target>
        </trans-unit>
        <trans-unit id="0253836014928024de0859d29625df2f344d46ad" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_equality&lt;/code&gt; value to check</source>
          <target state="translated">una &lt;code&gt;std::weak_equality&lt;/code&gt; valor std :: weak_equality para verificar</target>
        </trans-unit>
        <trans-unit id="f76354e64cc6e23de23245adc7499dc00576366f" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_ordering &lt;/code&gt; value to check</source>
          <target state="translated">una &lt;code&gt;std::weak_ordering &lt;/code&gt; valor std :: weak_ordering para verificar</target>
        </trans-unit>
        <trans-unit id="05358986f183ddf4595d8859a958cc712f0ab225" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;std::weak_ordering&lt;/code&gt; value to check</source>
          <target state="translated">una &lt;code&gt;std::weak_ordering&lt;/code&gt; valor std :: weak_ordering para verificar</target>
        </trans-unit>
        <trans-unit id="d9610770cf81d239e7a04362e6d0fadfaa64deec" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;sub_match&lt;/code&gt;, &lt;code&gt;basic_string&lt;/code&gt;, pointer to a null-terminated string or a character to compare</source>
          <target state="translated">una &lt;code&gt;sub_match&lt;/code&gt; , &lt;code&gt;basic_string&lt;/code&gt; , puntero a una cadena terminada en nulo o un car&amp;aacute;cter para comparar</target>
        </trans-unit>
        <trans-unit id="63b26ec0d5fac3c3232b5ffc726c7befaaed3d72" translate="yes" xml:space="preserve">
          <source>a &lt;code&gt;time_point&lt;/code&gt; to convert from</source>
          <target state="translated">una &lt;code&gt;time_point&lt;/code&gt; para convertir</target>
        </trans-unit>
        <trans-unit id="816fe47038210aaf21ca1a99d9e95e7a3f42b5cc" translate="yes" xml:space="preserve">
          <source>a FIFO (also known as pipe) file</source>
          <target state="translated">un archivo FIFO (también conocido como pipe)</target>
        </trans-unit>
        <trans-unit id="54a9c6eed1e0626765604b3dcde6dced86c39ba2" translate="yes" xml:space="preserve">
          <source>a UTF-8 encoded &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;, a pointer to a null-terminated multibyte string, or an input iterator with char value type that points to a null-terminated multibyte string</source>
          <target state="translated">un &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; codificado en UTF-8 , &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt; , un puntero a una cadena multibyte terminada en nulo, o un iterador de entrada con tipo de valor char que apunta a una cadena multibyte terminada en nulo</target>
        </trans-unit>
        <trans-unit id="d879d1e4b9050e4ddcaaf4d1177df97586b36972" translate="yes" xml:space="preserve">
          <source>a base class subobject, or</source>
          <target state="translated">un subobjeto de clase base,o</target>
        </trans-unit>
        <trans-unit id="f4918892ac7e83e823a2320d1ac12b97395fb22e" translate="yes" xml:space="preserve">
          <source>a basic stream output function</source>
          <target state="translated">una función básica de salida de corriente</target>
        </trans-unit>
        <trans-unit id="b40f7d626aeddea7dd6317df88183469b83e1e8c" translate="yes" xml:space="preserve">
          <source>a basic_ostream of the same type to swap with</source>
          <target state="translated">una corriente básica del mismo tipo para intercambiar con</target>
        </trans-unit>
        <trans-unit id="7bf28d638858caf4f712e1c44d5c9646f9188b75" translate="yes" xml:space="preserve">
          <source>a basic_string used as a source used to initialize the regex</source>
          <target state="translated">una_cadena_básica usada como fuente para inicializar el regex</target>
        </trans-unit>
        <trans-unit id="6e9b8e3d4e8d4b69f9fcb8e7bf96871b00610a3b" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the collate facet category</source>
          <target state="translated">un valor de tipo de m&amp;aacute;scara de bits &lt;code&gt;category&lt;/code&gt; indica la categor&amp;iacute;a de facetas de clasificaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="9f85b8ca8bc6020d25703e2cd3d781082f967763" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the ctype facet category</source>
          <target state="translated">un valor de tipo de m&amp;aacute;scara de bits &lt;code&gt;category&lt;/code&gt; indica la categor&amp;iacute;a de faceta ctype</target>
        </trans-unit>
        <trans-unit id="a9222a22156a69a4cc22429a74768f81e03c8001" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the messages facet category</source>
          <target state="translated">un valor de tipo de m&amp;aacute;scara de bits &lt;code&gt;category&lt;/code&gt; indica la categor&amp;iacute;a de faceta de mensajes</target>
        </trans-unit>
        <trans-unit id="952a4bcb614afbf75d9c9379f3e6fad36cbc2407" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the monetary facet category</source>
          <target state="translated">un valor de tipo de m&amp;aacute;scara de bits &lt;code&gt;category&lt;/code&gt; indica la categor&amp;iacute;a de faceta monetaria</target>
        </trans-unit>
        <trans-unit id="a321349b7f9b76dc26dc645283a6f6c0d3935161" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the numeric facet category</source>
          <target state="translated">un valor de tipo de m&amp;aacute;scara de bits &lt;code&gt;category&lt;/code&gt; indica la categor&amp;iacute;a de faceta num&amp;eacute;rica</target>
        </trans-unit>
        <trans-unit id="b2849fb686ecb1e5989a880cd4bb3d2e85d8c6f8" translate="yes" xml:space="preserve">
          <source>a bitmask value of type &lt;code&gt;category&lt;/code&gt; indicating the time facet category</source>
          <target state="translated">un valor de tipo de m&amp;aacute;scara de bits &lt;code&gt;category&lt;/code&gt; indica la categor&amp;iacute;a de faceta de tiempo</target>
        </trans-unit>
        <trans-unit id="5378f3a4e98f36da8d1cc7ac9fde2e0f766b8ce0" translate="yes" xml:space="preserve">
          <source>a block special file</source>
          <target state="translated">un archivo especial de bloque</target>
        </trans-unit>
        <trans-unit id="31510aaf6cad0411c7217a1f61ae7d5e0d11e988" translate="yes" xml:space="preserve">
          <source>a callable object used to determine equality</source>
          <target state="translated">un objeto llamable usado para determinar la igualdad</target>
        </trans-unit>
        <trans-unit id="16cbd5bc356bd1da4d6938d770e5e05cf23f18f0" translate="yes" xml:space="preserve">
          <source>a callable object used to hash the elements of the string</source>
          <target state="translated">un objeto llamable usado para trocear los elementos de la cuerda</target>
        </trans-unit>
        <trans-unit id="e104c12ef41e3cdab35da94692fcec6545e90e82" translate="yes" xml:space="preserve">
          <source>a callable to initialize the</source>
          <target state="translated">una llamada para inicializar la</target>
        </trans-unit>
        <trans-unit id="a43b347761e3e1642f174ca5ec98e18e3c558b21" translate="yes" xml:space="preserve">
          <source>a callable used to initialize &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">un invocable utilizado para inicializar &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc6aead76d9ee30f0a5c5d4684ed174e264c2836" translate="yes" xml:space="preserve">
          <source>a cast expression to lvalue reference type, such as &lt;code&gt;static_cast&amp;lt;int&amp;amp;&amp;gt;(x)&lt;/code&gt;;</source>
          <target state="translated">una expresi&amp;oacute;n de conversi&amp;oacute;n al tipo de referencia &lt;code&gt;static_cast&amp;lt;int&amp;amp;&amp;gt;(x)&lt;/code&gt; , como static_cast &amp;lt;int &amp;amp;&amp;gt; (x) ;</target>
        </trans-unit>
        <trans-unit id="9115722d18c29f111bc7117bd95ced839664bc51" translate="yes" xml:space="preserve">
          <source>a cast expression to non-reference type, such as &lt;code&gt;static_cast&amp;lt;double&amp;gt;(x)&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;{}&lt;/code&gt;, or &lt;code&gt;(int)42&lt;/code&gt;;</source>
          <target state="translated">una expresi&amp;oacute;n de &lt;code&gt;static_cast&amp;lt;double&amp;gt;(x)&lt;/code&gt; tipo sin referencia, como static_cast &amp;lt;double&amp;gt; (x) , &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;{}&lt;/code&gt; o &lt;code&gt;(int)42&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="e763fd172d6152f43975ef5910f0aa8ba9d50062" translate="yes" xml:space="preserve">
          <source>a cast expression to rvalue reference to function type, such as &lt;code&gt;static_cast&amp;lt;void (&amp;amp;&amp;amp;)(int)&amp;gt;(x)&lt;/code&gt;.</source>
          <target state="translated">una expresi&amp;oacute;n de conversi&amp;oacute;n a rvalue referencia al tipo de funci&amp;oacute;n, como &lt;code&gt;static_cast&amp;lt;void (&amp;amp;&amp;amp;)(int)&amp;gt;(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be2abbbe2e0dfe771f0371f123450bb9bd07c9bb" translate="yes" xml:space="preserve">
          <source>a cast expression to rvalue reference to object type, such as &lt;code&gt;static_cast&amp;lt;char&amp;amp;&amp;amp;&amp;gt;(x)&lt;/code&gt;;</source>
          <target state="translated">una expresi&amp;oacute;n de conversi&amp;oacute;n a rvalue la referencia al tipo de objeto, como &lt;code&gt;static_cast&amp;lt;char&amp;amp;&amp;amp;&amp;gt;(x)&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="53484ba10b1e424e0b9496d35157e69373bf554a" translate="yes" xml:space="preserve">
          <source>a character from the source character set minus single-quote (&lt;code&gt;'&lt;/code&gt;), backslash (&lt;code&gt;\&lt;/code&gt;), or the newline character,</source>
          <target state="translated">un car&amp;aacute;cter del conjunto de caracteres de origen menos comillas simples ( &lt;code&gt;'&lt;/code&gt; ), barra diagonal inversa ( &lt;code&gt;\&lt;/code&gt; ) o el car&amp;aacute;cter de nueva l&amp;iacute;nea,</target>
        </trans-unit>
        <trans-unit id="242427c6b2eafcaf248ee1b9d7c883407593539a" translate="yes" xml:space="preserve">
          <source>a character input stream</source>
          <target state="translated">un flujo de entrada de caracteres</target>
        </trans-unit>
        <trans-unit id="0efbbee14797deed6a7056276c65b5e154453b0a" translate="yes" xml:space="preserve">
          <source>a character output stream</source>
          <target state="translated">un flujo de salida de caracteres</target>
        </trans-unit>
        <trans-unit id="70a6bbc7a457f3e06d375719052224054e262911" translate="yes" xml:space="preserve">
          <source>a character range to use</source>
          <target state="translated">un rango de caracteres a utilizar</target>
        </trans-unit>
        <trans-unit id="f1cf02ceb7cec86411208ea818ed5141785e1a23" translate="yes" xml:space="preserve">
          <source>a character range to use, represented as &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt;, pointer to a null-terminated multibyte string, or as an input iterator with char value type that points to a null-terminated multibyte string</source>
          <target state="translated">un rango de caracteres para usar, representado como &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../string/basic_string_view&quot;&gt;std::string_view&lt;/a&gt;&lt;/code&gt; , puntero a una cadena multibyte terminada en nulo, o como un iterador de entrada con tipo de valor char que apunta a una cadena multibyte terminada en nulo</target>
        </trans-unit>
        <trans-unit id="1736d8d35a09815a4736564ec0af7bbafefb5389" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the end of the string</source>
          <target state="translated">una secuencia de caracteres o un solo carácter para comparar con el final de la cadena</target>
        </trans-unit>
        <trans-unit id="eb17e0910a8a3e8109807493a04ca35e79111c97" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the end of the string view</source>
          <target state="translated">una secuencia de caracteres o un solo carácter para comparar con el final de la vista de la cadena</target>
        </trans-unit>
        <trans-unit id="792cac041ed6c9d94e7546b52a466c7057d1833f" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the start of the string</source>
          <target state="translated">una secuencia de caracteres o un solo carácter para comparar con el inicio de la cadena</target>
        </trans-unit>
        <trans-unit id="cf6ca109dc96019eacef9105cfc32c6bb8adf9f3" translate="yes" xml:space="preserve">
          <source>a character sequence or a single character to compare to the start of the string view</source>
          <target state="translated">una secuencia de caracteres o un solo carácter para comparar con el inicio de la vista de la cadena</target>
        </trans-unit>
        <trans-unit id="a36ddc3729dac1840b73df74f47d5b5381de7021" translate="yes" xml:space="preserve">
          <source>a character special file</source>
          <target state="translated">un archivo especial de caracteres</target>
        </trans-unit>
        <trans-unit id="a5250d7e3929a03629a280317471b3d3c146b682" translate="yes" xml:space="preserve">
          <source>a class type (&lt;code&gt;class&lt;/code&gt; or &lt;code&gt;struct&lt;/code&gt; or &lt;code&gt;union&lt;/code&gt;) that:</source>
          <target state="translated">un tipo de clase ( &lt;code&gt;class&lt;/code&gt; o &lt;code&gt;struct&lt;/code&gt; o &lt;code&gt;union&lt;/code&gt; ) que:</target>
        </trans-unit>
        <trans-unit id="f075c0a2aeaae5daa8fce7ca9d846ae302099ae2" translate="yes" xml:space="preserve">
          <source>a class type that contains allocation information</source>
          <target state="translated">un tipo de clase que contiene información de asignación</target>
        </trans-unit>
        <trans-unit id="691a4be3772ad8ef069a61765f06c1d8bc2961d8" translate="yes" xml:space="preserve">
          <source>a class/function/variable template</source>
          <target state="translated">una clase/función/plantilla variable</target>
        </trans-unit>
        <trans-unit id="8af3fd16bec574be1984ea9e734c9bf45f25959e" translate="yes" xml:space="preserve">
          <source>a comma-separated list of parameters like in a function declaration, except that default arguments are not allowed and it cannot end with an ellipsis (other than one signifying a pack expansion). These parameters have no storage, linkage or lifetime, and are only used to assist in specifying requirements. These parameters are in scope until the closing &lt;code&gt;} &lt;/code&gt; of the requirement-seq.</source>
          <target state="translated">una lista de par&amp;aacute;metros separados por comas, como en una declaraci&amp;oacute;n de funci&amp;oacute;n, excepto que los argumentos predeterminados no est&amp;aacute;n permitidos y no pueden terminar con puntos suspensivos (que no sean uno que signifique una expansi&amp;oacute;n del paquete). Estos par&amp;aacute;metros no tienen almacenamiento, vinculaci&amp;oacute;n o vida &amp;uacute;til, y solo se utilizan para ayudar a especificar los requisitos. Estos par&amp;aacute;metros est&amp;aacute;n dentro del alcance hasta el cierre &lt;code&gt;} &lt;/code&gt; del requisito-seq.</target>
        </trans-unit>
        <trans-unit id="f11728936e3c6825ff0c40fb8190cad46110b798" translate="yes" xml:space="preserve">
          <source>a comma-separated list of zero or more &lt;a href=&quot;lambda#Lambda_capture&quot;&gt;captures&lt;/a&gt;, optionally beginning with a capture-default.</source>
          <target state="translated">una lista separada por comas de cero o m&amp;aacute;s &lt;a href=&quot;lambda#Lambda_capture&quot;&gt;capturas&lt;/a&gt; , opcionalmente comenzando con un valor predeterminado de captura.</target>
        </trans-unit>
        <trans-unit id="34fd2e1333d218ba0d65569377b79829eed062f3" translate="yes" xml:space="preserve">
          <source>a compatible &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt;</source>
          <target state="translated">un &lt;a href=&quot;../node_handle&quot;&gt;mango de nodo&lt;/a&gt; compatible</target>
        </trans-unit>
        <trans-unit id="12cf74b9d504b7de17cb8733f3089bb0c746c26c" translate="yes" xml:space="preserve">
          <source>a complex number determined by &lt;code&gt;r&lt;/code&gt; and &lt;code&gt;theta&lt;/code&gt;.</source>
          <target state="translated">un n&amp;uacute;mero complejo determinado por &lt;code&gt;r&lt;/code&gt; y &lt;code&gt;theta&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="832f4c5d564988716ce6fc985261dbaeef18716f" translate="yes" xml:space="preserve">
          <source>a complex number type</source>
          <target state="translated">un tipo de número complejo</target>
        </trans-unit>
        <trans-unit id="87f7888775f37c05d22b86f373fe58cc238751cb" translate="yes" xml:space="preserve">
          <source>a complex or scalar value of matching type (&lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;)</source>
          <target state="translated">Un valor complejo o escalar de tipo coincidente ( &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b420ae5c7d6bcd895849ec43707c9cd9b5295f2a" translate="yes" xml:space="preserve">
          <source>a compound type constructed from a dependent type</source>
          <target state="translated">un tipo compuesto construido a partir de un tipo dependiente</target>
        </trans-unit>
        <trans-unit id="3e10ceabf9c0862a21d4c968a88d28cf606e6ae4" translate="yes" xml:space="preserve">
          <source>a concept (&lt;a href=&quot;constraints&quot;&gt;constraints and concepts&lt;/a&gt;) (since C++20)</source>
          <target state="translated">un concepto ( &lt;a href=&quot;constraints&quot;&gt;restricciones y conceptos&lt;/a&gt; ) (desde C ++ 20)</target>
        </trans-unit>
        <trans-unit id="705840ece91c45959e8d8b85562f78f90621fb91" translate="yes" xml:space="preserve">
          <source>a constant &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; with a &lt;code&gt;value_type&lt;/code&gt; of &lt;code&gt;path&lt;/code&gt;, except that for dereferenceable iterators &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; of type &lt;code&gt;path::iterator&lt;/code&gt; with &lt;code&gt;a == b&lt;/code&gt;, there is no requirement that &lt;code&gt;*a&lt;/code&gt; and &lt;code&gt;*b&lt;/code&gt; are bound to the same object</source>
          <target state="translated">una constante &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; con un &lt;code&gt;value_type&lt;/code&gt; de &lt;code&gt;path&lt;/code&gt; , excepto que para los iteradores Dereferenceable &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; de tipo &lt;code&gt;path::iterator&lt;/code&gt; con &lt;code&gt;a == b&lt;/code&gt; , no hay requisito de que &lt;code&gt;*a&lt;/code&gt; y &lt;code&gt;*b&lt;/code&gt; est&amp;aacute;n unidos al mismo objeto</target>
        </trans-unit>
        <trans-unit id="0861d8f96c22cf00ddd38be06d579dc5846fa4bb" translate="yes" xml:space="preserve">
          <source>a constant expression of the same type as the type of condition after conversions and &lt;a href=&quot;implicit_cast&quot;&gt;integral promotions&lt;/a&gt;</source>
          <target state="translated">una expresi&amp;oacute;n constante del mismo tipo que el tipo de condici&amp;oacute;n despu&amp;eacute;s de conversiones y &lt;a href=&quot;implicit_cast&quot;&gt;promociones integrales&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fa1e013cc131d9284341359f6bccff749d73ab2d" translate="yes" xml:space="preserve">
          <source>a constant of type &lt;code&gt;&lt;a href=&quot;codecvt_mode&quot;&gt;std::codecvt_mode&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">una constante de tipo &lt;code&gt;&lt;a href=&quot;codecvt_mode&quot;&gt;std::codecvt_mode&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2092e802512bd4b6672ffecf3059eab3c2dc675a" translate="yes" xml:space="preserve">
          <source>a constant of type &lt;code&gt;size_t&lt;/code&gt; signifying that the &lt;code&gt;span&lt;/code&gt; has dynamic extent</source>
          <target state="translated">una constante de tipo &lt;code&gt;size_t&lt;/code&gt; que significa que el &lt;code&gt;span&lt;/code&gt; tiene una extensi&amp;oacute;n din&amp;aacute;mica</target>
        </trans-unit>
        <trans-unit id="43883e62b71e2ce20764378f921e1463f7c5e2fb" translate="yes" xml:space="preserve">
          <source>a constructor for a base or member that the implicit definition of the constructor would call is</source>
          <target state="translated">un constructor para una base o miembro que la definición implícita del constructor llamaría es</target>
        </trans-unit>
        <trans-unit id="1e0e47bbea0419696dda53a2c740d527152ed34a" translate="yes" xml:space="preserve">
          <source>a container (such as &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;) of non-recursive &lt;a href=&quot;directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;s&lt;/a&gt; that forms the recursion stack</source>
          <target state="translated">un recipiente (tal como &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; ) de no recursivos &lt;a href=&quot;directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; s&lt;/a&gt; que forma la pila de recursi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="6da0ef251a56bef0d297d95fb6f03dcddc9d4d68" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;begin&lt;/code&gt; method</source>
          <target state="translated">un contenedor con un m&amp;eacute;todo de &lt;code&gt;begin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3ab7db750fffecfbea2fd7f3a1826d7a47ff6dfd" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;data()&lt;/code&gt; method</source>
          <target state="translated">un contenedor con un m&amp;eacute;todo de &lt;code&gt;data()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d42aaf6f8dfa2ceb1302ac9a7aae99e65ad76dd7" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;rbegin&lt;/code&gt; method</source>
          <target state="translated">un contenedor con un m&amp;eacute;todo &lt;code&gt;rbegin&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a255f3578bec602079f216affbbb6421964db15" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;rend&lt;/code&gt; method</source>
          <target state="translated">un contenedor con un m&amp;eacute;todo de &lt;code&gt;rend&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d76e199c3451be874b54d52909a700c365bc58d9" translate="yes" xml:space="preserve">
          <source>a container with a &lt;code&gt;size&lt;/code&gt; method</source>
          <target state="translated">un contenedor con un m&amp;eacute;todo de &lt;code&gt;size&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5936962ad861e75e91156317d373da013aa2a18b" translate="yes" xml:space="preserve">
          <source>a container with an &lt;code&gt;empty&lt;/code&gt; method</source>
          <target state="translated">un contenedor con un m&amp;eacute;todo &lt;code&gt;empty&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8eecf2dba113b51a014b2681b5af4fc06cf180a3" translate="yes" xml:space="preserve">
          <source>a container with an &lt;code&gt;end&lt;/code&gt; method</source>
          <target state="translated">un contenedor con un m&amp;eacute;todo &lt;code&gt;end&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="32ae34e0c2ff3b97cd9427b79233b671fd97c530" translate="yes" xml:space="preserve">
          <source>a copy of the base() iterator</source>
          <target state="translated">una copia del iterador base()</target>
        </trans-unit>
        <trans-unit id="7332ce803122087bfbb9401270891b4faedd3f1f" translate="yes" xml:space="preserve">
          <source>a copy of the base() iterator, the name is for exposition only</source>
          <target state="translated">una copia del iterador de la base(),el nombre es sólo para la exposición</target>
        </trans-unit>
        <trans-unit id="311bf83f22bc4bb383f24fd37ba3cb18d0aeb36d" translate="yes" xml:space="preserve">
          <source>a copy of the value returned by &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;</source>
          <target state="translated">una copia del valor devuelto por &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f958f7a6a78be01a6805b5c1af1d682eeb8a134" translate="yes" xml:space="preserve">
          <source>a cv-qualified version of a dependent type</source>
          <target state="translated">una versión calificada de un tipo dependiente</target>
        </trans-unit>
        <trans-unit id="fc96c9e2930591a8d0a0e1f5aef8a747ab1ae764" translate="yes" xml:space="preserve">
          <source>a declaration</source>
          <target state="translated">una declaración</target>
        </trans-unit>
        <trans-unit id="de382bf6f6303f1d66d3ee9fa105e4cb909ae0fb" translate="yes" xml:space="preserve">
          <source>a default member initializer (for default constructor only) is</source>
          <target state="translated">un inicializador de miembros por defecto (sólo para el constructor por defecto)es</target>
        </trans-unit>
        <trans-unit id="c35c5385471cf8ca008de727f3a8bb03a39d8fc4" translate="yes" xml:space="preserve">
          <source>a default-constructed &lt;code&gt;path()&lt;/code&gt; followed by</source>
          <target state="translated">una &lt;code&gt;path()&lt;/code&gt; construida por defecto () seguida de</target>
        </trans-unit>
        <trans-unit id="3720dd36cc49fe927d2449b3b2fe294001d00344" translate="yes" xml:space="preserve">
          <source>a definition of a variable for which &lt;a href=&quot;default_initialization&quot;&gt;no initialization is performed&lt;/a&gt;.</source>
          <target state="translated">Una definici&amp;oacute;n de una variable para la que &lt;a href=&quot;default_initialization&quot;&gt;no se realiza ninguna inicializaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8574bc2dee7611873d6999d1419b5b65057eda6e" translate="yes" xml:space="preserve">
          <source>a definition of a variable of non-literal type</source>
          <target state="translated">una definición de una variable de tipo no literal</target>
        </trans-unit>
        <trans-unit id="bf8e57bf98d46c7f4282d67c960acf8da327fef4" translate="yes" xml:space="preserve">
          <source>a definition of a variable of static or thread &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;</source>
          <target state="translated">Una definici&amp;oacute;n de una variable de &lt;a href=&quot;storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; est&amp;aacute;tico o de subprocesos</target>
        </trans-unit>
        <trans-unit id="39cd8bcb29b6ae12a4df802c4fe0c9397f3f8893" translate="yes" xml:space="preserve">
          <source>a deleter to copy from</source>
          <target state="translated">un deleter para copiar de</target>
        </trans-unit>
        <trans-unit id="94a71c43d37808b7131ebf1bfafb843815bd7985" translate="yes" xml:space="preserve">
          <source>a deleter to use to destroy the object</source>
          <target state="translated">un deletéreo para usar para destruir el objeto</target>
        </trans-unit>
        <trans-unit id="24ff51d02f7ddaf5794e2da95d7baf8bf41c271f" translate="yes" xml:space="preserve">
          <source>a deterministic &lt;a href=&quot;named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt;, defined by the seed</source>
          <target state="translated">un determinista &lt;a href=&quot;named_req/uniformrandombitgenerator&quot;&gt;UniformRandomBitGenerator&lt;/a&gt; , definido por la semilla</target>
        </trans-unit>
        <trans-unit id="534eb8b60097429551e576498f52d179c2f4e5dd" translate="yes" xml:space="preserve">
          <source>a directory</source>
          <target state="translated">un directorio</target>
        </trans-unit>
        <trans-unit id="8bddca722adcb261998df0de3bb3c97a6c748832" translate="yes" xml:space="preserve">
          <source>a directory entry</source>
          <target state="translated">una entrada en el directorio</target>
        </trans-unit>
        <trans-unit id="927fd0565fdd62ffef9d7df984e6c6f5ed72f85d" translate="yes" xml:space="preserve">
          <source>a directory_iterator</source>
          <target state="translated">un editor de directorios</target>
        </trans-unit>
        <trans-unit id="867723c6d0ee2b6557184f124ed60f12f45d1dd0" translate="yes" xml:space="preserve">
          <source>a discarded-value expression.</source>
          <target state="translated">una expresión de valor desechado.</target>
        </trans-unit>
        <trans-unit id="336c91ab3bd545d36262022c4abcf1ea256c10d5" translate="yes" xml:space="preserve">
          <source>a disjunctive clause subsumes a conjunctive clause if and only if there is an atomic constraint &lt;code&gt;U&lt;/code&gt; in the disjunctive clause and an atomic constraint &lt;code&gt;V&lt;/code&gt; in the conjunctive clause such that &lt;code&gt;U&lt;/code&gt; subsumes &lt;code&gt;V&lt;/code&gt;;</source>
          <target state="translated">una cl&amp;aacute;usula disyuntiva subsume una cl&amp;aacute;usula conjuntiva si y solo si hay una restricci&amp;oacute;n at&amp;oacute;mica &lt;code&gt;U&lt;/code&gt; en la cl&amp;aacute;usula disyuntiva y una restricci&amp;oacute;n at&amp;oacute;mica &lt;code&gt;V&lt;/code&gt; en la cl&amp;aacute;usula conjuntiva tal que &lt;code&gt;U&lt;/code&gt; subsume &lt;code&gt;V&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="6b5747ff852acba8c48d1a6cb5da34fc9e296730" translate="yes" xml:space="preserve">
          <source>a duration to copy from</source>
          <target state="translated">una duración para copiar de</target>
        </trans-unit>
        <trans-unit id="c350a90cf1671cc555d57758875af84ffdbe33a9" translate="yes" xml:space="preserve">
          <source>a family of classes (&lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt;), which may be &lt;a href=&quot;member_template&quot;&gt;nested classes&lt;/a&gt;</source>
          <target state="translated">una familia de clases ( &lt;a href=&quot;class_template&quot;&gt;plantilla de clase&lt;/a&gt; ), que pueden ser &lt;a href=&quot;member_template&quot;&gt;clases anidadas&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="7ac66b538aae3ff5b2eebbb9164d6b15968c2655" translate="yes" xml:space="preserve">
          <source>a family of functions (&lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;), which may be &lt;a href=&quot;member_template&quot;&gt;member functions&lt;/a&gt;</source>
          <target state="translated">una familia de funciones ( &lt;a href=&quot;function_template&quot;&gt;plantilla de funciones&lt;/a&gt; ), que pueden ser &lt;a href=&quot;member_template&quot;&gt;funciones miembro&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b225fab8be27928cedcf387d1202d942115cf6f7" translate="yes" xml:space="preserve">
          <source>a family of variables (&lt;a href=&quot;variable_template&quot;&gt;variable template&lt;/a&gt;) (since C++14)</source>
          <target state="translated">una familia de variables ( &lt;a href=&quot;variable_template&quot;&gt;plantilla variable&lt;/a&gt; ) (desde C ++ 14)</target>
        </trans-unit>
        <trans-unit id="fa031b408b61feecac632070eb11680ef7afef0a" translate="yes" xml:space="preserve">
          <source>a function call expression that calls a function (or a constructor) that is not declared &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;</source>
          <target state="translated">una expresi&amp;oacute;n de llamada de funci&amp;oacute;n que llama a una funci&amp;oacute;n (o un constructor) que no se declara &lt;a href=&quot;constexpr&quot;&gt;constexpr&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1cc0ab25d190ee32f3fbd65c276911c0bf316acb" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is lvalue reference, such as &lt;code&gt;&lt;a href=&quot;../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;(&lt;a href=&quot;../io/cin&quot;&gt;std::cin&lt;/a&gt;, str)&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 1&lt;/code&gt;, &lt;code&gt;str1 = str2&lt;/code&gt;, or &lt;code&gt;++it&lt;/code&gt;;</source>
          <target state="translated">una llamada a funci&amp;oacute;n o una expresi&amp;oacute;n de operador sobrecargada, cuyo tipo de retorno es una referencia de valor, como &lt;code&gt;&lt;a href=&quot;../string/basic_string/getline&quot;&gt;std::getline&lt;/a&gt;(&lt;a href=&quot;../io/cin&quot;&gt;std::cin&lt;/a&gt;, str)&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/cout&quot;&gt;std::cout&lt;/a&gt; &amp;lt;&amp;lt; 1&lt;/code&gt; , &lt;code&gt;str1 = str2&lt;/code&gt; o &lt;code&gt;++it&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="fe3271b2a2bdf8654d96145285508cb27eb7fa3c" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is non-reference, such as &lt;code&gt;str.substr(1, 2)&lt;/code&gt;, &lt;code&gt;str1 + str2&lt;/code&gt;, or &lt;code&gt;it++&lt;/code&gt;;</source>
          <target state="translated">una llamada a funci&amp;oacute;n o una expresi&amp;oacute;n de operador sobrecargada, cuyo tipo de retorno no es de referencia, como &lt;code&gt;str.substr(1, 2)&lt;/code&gt; , &lt;code&gt;str1 + str2&lt;/code&gt; o &lt;code&gt;it++&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="0aac9ce8ff230dee25d75b3c0b2e89e1a93af6fb" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is rvalue reference to function;</source>
          <target state="translated">una llamada de función o una expresión de operador sobrecargada,cuyo tipo de retorno es la referencia de valor a la función;</target>
        </trans-unit>
        <trans-unit id="06b3616b9a0b9e911ad389bfd163627a7c1c34bc" translate="yes" xml:space="preserve">
          <source>a function call or an overloaded operator expression, whose return type is rvalue reference to object, such as &lt;code&gt;std::move(x)&lt;/code&gt;;</source>
          <target state="translated">una llamada a funci&amp;oacute;n o una expresi&amp;oacute;n de operador sobrecargada, cuyo tipo de retorno es rvalue referencia al objeto, como &lt;code&gt;std::move(x)&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="89282f06fce2e206dcc5d91b9a98ea7c21e34204" translate="yes" xml:space="preserve">
          <source>a function call to a &lt;code&gt;constexpr&lt;/code&gt; function which is declared, but not defined</source>
          <target state="translated">una llamada a una funci&amp;oacute;n &lt;code&gt;constexpr&lt;/code&gt; que se declara pero no se define</target>
        </trans-unit>
        <trans-unit id="10915ad1ef913f2efda469b6ef4db5fda7260bf8" translate="yes" xml:space="preserve">
          <source>a function call to a &lt;code&gt;constexpr&lt;/code&gt; function/constructor template instantiation where the instantiation fails to satisfy &lt;a href=&quot;constexpr&quot;&gt;constexpr function/constructor&lt;/a&gt; requirements.</source>
          <target state="translated">una llamada de funci&amp;oacute;n a una instancia de plantilla &lt;code&gt;constexpr&lt;/code&gt; funci&amp;oacute;n / constructor donde la instanciaci&amp;oacute;n no satisface los &lt;a href=&quot;constexpr&quot;&gt;requisitos de funci&amp;oacute;n / constructor constexpr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a1e14620347e6a891947bb343ed08d832b480d5" translate="yes" xml:space="preserve">
          <source>a function object type. The behavior is undefined if its return type is not one of the five comparison category types (strong_equality, weak_equality, strong_ordering, weak_ordering, or partial_ordering)</source>
          <target state="translated">un tipo de objeto de función.El comportamiento es indefinido si su tipo de retorno no es uno de los cinco tipos de categoría de comparación (igualdad_fuerte,igualdad_débil,ordenamiento_fuerte,ordenamiento_débil o ordenamiento_parcial)</target>
        </trans-unit>
        <trans-unit id="8d0e3c882e6f573300e1c9692eab26458b8cdc46" translate="yes" xml:space="preserve">
          <source>a function type whose exception specification is value-dependent</source>
          <target state="translated">un tipo de función cuya especificación de excepción depende del valor</target>
        </trans-unit>
        <trans-unit id="e47b118e9260ac46b886dbed4343d2d945bd3192" translate="yes" xml:space="preserve">
          <source>a glvalue</source>
          <target state="translated">un glvalue</target>
        </trans-unit>
        <trans-unit id="7ba358203ed2199073a8967bad6e8c7ab1203303" translate="yes" xml:space="preserve">
          <source>a glvalue (&amp;ldquo;generalized&amp;rdquo; lvalue) is an expression whose evaluation determines the identity of an object, bit-field, or function;</source>
          <target state="translated">un glvalue (lvalue &quot;generalizado&quot;) es una expresi&amp;oacute;n cuya evaluaci&amp;oacute;n determina la identidad de un objeto, campo de bits o funci&amp;oacute;n;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
