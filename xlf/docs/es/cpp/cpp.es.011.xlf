<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="622dca44b962cc1f074838d9efdbe8759696a1de" translate="yes" xml:space="preserve">
          <source>Associative containers implement sorted data structures that can be quickly searched (O(log n) complexity).</source>
          <target state="translated">Los contenedores asociativos implementan estructuras de datos ordenados que pueden ser buscados rápidamente (complejidad O(log n)).</target>
        </trans-unit>
        <trans-unit id="1c6a25ab3379bdd54a1512bb45e9d133927a1700" translate="yes" xml:space="preserve">
          <source>Associative containers in the standard library</source>
          <target state="translated">Contenedores asociativos en la biblioteca estándar</target>
        </trans-unit>
        <trans-unit id="f3b3c941634aac79492f857fc539fd4c9d008a56" translate="yes" xml:space="preserve">
          <source>AssociativeContainer</source>
          <target state="translated">AssociativeContainer</target>
        </trans-unit>
        <trans-unit id="d20b5a26a1cdf631954b50a5206246dff93d9c8a" translate="yes" xml:space="preserve">
          <source>Associativity</source>
          <target state="translated">Associativity</target>
        </trans-unit>
        <trans-unit id="b3392e5205fe590e481f972619ef5508947ebdc5" translate="yes" xml:space="preserve">
          <source>Associativity specification is redundant for unary operators and is only shown for completeness: unary prefix operators always associate right-to-left (&lt;code&gt;delete ++*p&lt;/code&gt; is &lt;code&gt;delete(++(*p))&lt;/code&gt;) and unary postfix operators always associate left-to-right (&lt;code&gt;a[1][2]++&lt;/code&gt; is &lt;code&gt;((a[1])[2])++&lt;/code&gt;). Note that the associativity is meaningful for member access operators, even though they are grouped with unary postfix operators: &lt;code&gt;a.b++&lt;/code&gt; is parsed &lt;code&gt;(a.b)++&lt;/code&gt; and not &lt;code&gt;a.(b++)&lt;/code&gt;.</source>
          <target state="translated">La especificaci&amp;oacute;n de asociatividad es redundante para operadores unarios y solo se muestra para completar: los operadores de prefijo unarios siempre se asocian de derecha a izquierda ( &lt;code&gt;delete ++*p&lt;/code&gt; es &lt;code&gt;delete(++(*p))&lt;/code&gt; ) y los operadores de postfix unarios siempre se asocian de izquierda a -derecho ( &lt;code&gt;a[1][2]++&lt;/code&gt; es &lt;code&gt;((a[1])[2])++&lt;/code&gt; ). Tenga en cuenta que la asociatividad es significativa para los operadores de acceso de miembros, aunque est&amp;eacute;n agrupados con operadores de postfix unarios: &lt;code&gt;a.b++&lt;/code&gt; se analiza &lt;code&gt;(a.b)++&lt;/code&gt; y no &lt;code&gt;a.(b++)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6062b342e2d9e9c70ef9a02f2326265c628746c" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;i&lt;/code&gt; has built-in type or the postincrement operator is not &lt;a href=&quot;operators&quot;&gt;overloaded&lt;/a&gt; to return by lvalue reference.</source>
          <target state="translated">Suponiendo &lt;code&gt;i&lt;/code&gt; se ha incorporado en el tipo o el operador postincremento no est&amp;aacute; &lt;a href=&quot;operators&quot;&gt;sobrecargado&lt;/a&gt; para volver por referencia lvalue.</target>
        </trans-unit>
        <trans-unit id="74f381465fb7e488d40ff21e2669ec9bd0efa9fd" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;i&lt;/code&gt; has built-in type or the pre-increment operator is &lt;a href=&quot;operators&quot;&gt;overloaded&lt;/a&gt; to return by lvalue reference.</source>
          <target state="translated">Suponiendo que &lt;code&gt;i&lt;/code&gt; un tipo incorporado o que el operador de pre-incremento est&amp;aacute; &lt;a href=&quot;operators&quot;&gt;sobrecargado&lt;/a&gt; para regresar por referencia de lvalue.</target>
        </trans-unit>
        <trans-unit id="033599246c3928bd9bbc1f63fef180f75f1d6fa6" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;CD&lt;/code&gt; is the function return type and &lt;code&gt;CR&amp;lt;A, B&amp;gt; = &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;A, B&amp;gt;::type&lt;/code&gt;, then:</source>
          <target state="translated">Suponiendo que &lt;code&gt;CD&lt;/code&gt; es el tipo de retorno de funci&amp;oacute;n y &lt;code&gt;CR&amp;lt;A, B&amp;gt; = &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;A, B&amp;gt;::type&lt;/code&gt; , entonces:</target>
        </trans-unit>
        <trans-unit id="f51aeb937353e872aa16e888ad3642d2d51989e0" translate="yes" xml:space="preserve">
          <source>Assuming that &lt;code&gt;CT =&lt;br/&gt; &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep1, Period1&amp;gt;,&lt;br/&gt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep2, Period2&amp;gt;&amp;gt;::type&lt;/code&gt;, then:</source>
          <target state="translated">Suponiendo que &lt;code&gt;CT =&lt;br/&gt; &lt;a href=&quot;../../types/common_type&quot;&gt;std::common_type&lt;/a&gt;&amp;lt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep1, Period1&amp;gt;,&lt;br/&gt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&amp;lt;Rep2, Period2&amp;gt;&amp;gt;::type&lt;/code&gt; , entonces:</target>
        </trans-unit>
        <trans-unit id="16dad30e22d9f8f0b187b91674cdf99f5bfa4cfb" translate="yes" xml:space="preserve">
          <source>Assuming that alignment requirements are met, a &lt;code&gt;reinterpret_cast&lt;/code&gt; does not change the &lt;a href=&quot;pointer#Pointers&quot;&gt;value of a pointer&lt;/a&gt; outside of a few limited cases dealing with &lt;a href=&quot;static_cast#pointer-interconvertible&quot;&gt;&lt;i&gt;pointer-interconvertible&lt;/i&gt;&lt;/a&gt; objects:</source>
          <target state="translated">Suponiendo que se cumplen los requisitos de alineaci&amp;oacute;n, un &lt;code&gt;reinterpret_cast&lt;/code&gt; no cambia el &lt;a href=&quot;pointer#Pointers&quot;&gt;valor de un puntero&lt;/a&gt; fuera de unos pocos casos limitados relacionados con objetos &lt;a href=&quot;static_cast#pointer-interconvertible&quot;&gt;&lt;i&gt;interconvertibles por puntero&lt;/i&gt;&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="eaa51d32fe12f955eec03f2bc4bdb2751f3da027" translate="yes" xml:space="preserve">
          <source>At first, a local variable of type &lt;code&gt;BidirIt&lt;/code&gt; is constructed with the value of &lt;code&gt;match[0].second&lt;/code&gt;.</source>
          <target state="translated">Al principio, una variable local de tipo &lt;code&gt;BidirIt&lt;/code&gt; se construye con el valor de &lt;code&gt;match[0].second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9ec839d7fa04addb5ce25ff54e78bc29c079bf1" translate="yes" xml:space="preserve">
          <source>At least one major implementation does not implement these rules and instead optimizes out the store to &lt;code&gt;n&lt;/code&gt;. The lifetime rules are under reconsideration as &lt;a href=&quot;https://wg21.link/CWG2256&quot;&gt;core issue 2256&lt;/a&gt;.</source>
          <target state="translated">Al menos una implementaci&amp;oacute;n importante no implementa estas reglas y, en cambio, optimiza la tienda a &lt;code&gt;n&lt;/code&gt; . Las reglas de por vida est&amp;aacute;n siendo reconsideradas como &lt;a href=&quot;https://wg21.link/CWG2256&quot;&gt;cuesti&amp;oacute;n central 2256&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5357281e6d1ead597f87156333dc4e4a2d371458" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; depends on a user-defined type, and</source>
          <target state="translated">Al menos uno de &lt;code&gt;T1&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; depende de un tipo definido por el usuario, y</target>
        </trans-unit>
        <trans-unit id="b7ff6c8662e2b7c4ac75ca0560a6904f05eb0097" translate="yes" xml:space="preserve">
          <source>At most</source>
          <target state="translated">A lo sumo</target>
        </trans-unit>
        <trans-unit id="a065be791d5f07e9b9b28e1a3ee4de5830efc2d5" translate="yes" xml:space="preserve">
          <source>At most 2&amp;middot;(N&lt;sub&gt;1&lt;/sub&gt;+N&lt;sub&gt;2&lt;/sub&gt;-1) comparisons, where N&lt;sub&gt;1&lt;/sub&gt;&lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; and N&lt;sub&gt;2&lt;/sub&gt;&lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt;.</source>
          <target state="translated">A lo sumo 2 &amp;middot; (N &lt;sub&gt;1&lt;/sub&gt; + N &lt;sub&gt;2&lt;/sub&gt; -1) comparaciones, donde N &lt;sub&gt;1 &lt;/sub&gt; &lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; y N &lt;sub&gt;2 &lt;/sub&gt; &lt;code&gt;= &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f417027ea40c23a98d041983aee663fe84c4fd8a" translate="yes" xml:space="preserve">
          <source>At most 2&amp;middot;min(N1, N2) applications of the comparison operation, where &lt;code&gt;N1 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; and &lt;code&gt;N2 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt;.</source>
          <target state="translated">Como m&amp;aacute;ximo, 2 min (N1, N2) aplicaciones de la operaci&amp;oacute;n de comparaci&amp;oacute;n, donde &lt;code&gt;N1 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; y &lt;code&gt;N2 = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82ec885967ce3dacad15402cd2d8eb2b10af93f5" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;(last-first)/2&lt;/code&gt; swaps. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.</source>
          <target state="translated">A lo sumo &lt;code&gt;(last-first)/2&lt;/code&gt; intercambios. Como promedio de toda la secuencia de permutaciones, las implementaciones t&amp;iacute;picas usan aproximadamente 3 comparaciones y 1.5 intercambios por llamada.</target>
        </trans-unit>
        <trans-unit id="ddecdfce8186bf2f225c5a792633c5ddf7b502c1" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;3*&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; comparisons.</source>
          <target state="translated">A lo sumo &lt;code&gt;3*&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; comparaciones.</target>
        </trans-unit>
        <trans-unit id="37142ec0061a83658ba826e1c1afead3f11e0ec2" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;d_last - d_first&lt;/code&gt; of the elements are placed sorted to the range &lt;code&gt;[d_first, d_first + n)&lt;/code&gt;. &lt;code&gt;n&lt;/code&gt; is the number of elements to sort (&lt;code&gt;n = min(last - first, d_last - d_first)&lt;/code&gt;). The order of equal elements is not guaranteed to be preserved.</source>
          <target state="translated">Como m&amp;aacute;ximo &lt;code&gt;d_last - d_first&lt;/code&gt; de los elementos se colocan ordenados al rango &lt;code&gt;[d_first, d_first + n)&lt;/code&gt; . &lt;code&gt;n&lt;/code&gt; es el n&amp;uacute;mero de elementos para ordenar ( &lt;code&gt;n = min(last - first, d_last - d_first)&lt;/code&gt; ). No se garantiza la preservaci&amp;oacute;n del orden de elementos iguales.</target>
        </trans-unit>
        <trans-unit id="d2675fe7d12495f05dcdb52627fa675c17129e6a" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last - first&lt;/code&gt; applications of the predicate and the projection.</source>
          <target state="translated">A lo sumo &lt;code&gt;last - first&lt;/code&gt; aplicaciones del predicado y la proyecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="29eb338ad07d90987b424a3ee5360988d67741cd" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last - first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">A lo sumo &lt;code&gt;last - first&lt;/code&gt; aplicaciones del predicado.</target>
        </trans-unit>
        <trans-unit id="c36a9685749cdd93b9b788e8f13203a1e8dd5a28" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; applications of the predicate.</source>
          <target state="translated">En la mayor&amp;iacute;a de &lt;code&gt;last&lt;/code&gt; - &lt;code&gt;first&lt;/code&gt; aplicaciones del predicado.</target>
        </trans-unit>
        <trans-unit id="835c572fed24e005461e8303ab401feae3c77b72" translate="yes" xml:space="preserve">
          <source>At most &lt;code&gt;std::distance(first, last)&lt;/code&gt; applications of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">En la mayor&amp;iacute;a de las aplicaciones &lt;code&gt;std::distance(first, last)&lt;/code&gt; de &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28b847c1c9ad7813c6cd6afbca6893f3a89d3246" translate="yes" xml:space="preserve">
          <source>At most N/2 swaps, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;. Averaged over the entire sequence of permutations, typical implementations use about 3 comparisons and 1.5 swaps per call.</source>
          <target state="translated">A lo sumo N / 2 intercambios, donde &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; . Como promedio de toda la secuencia de permutaciones, las implementaciones t&amp;iacute;picas usan aproximadamente 3 comparaciones y 1.5 intercambios por llamada.</target>
        </trans-unit>
        <trans-unit id="87d08107753bb0853d26d589fe4f49b4791d7a3c" translate="yes" xml:space="preserve">
          <source>At most O(N&lt;sup&gt;2&lt;/sup&gt;) applications of the predicate, or exactly N if the sequences are already equal, where &lt;code&gt;N=&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt;.</source>
          <target state="translated">En la mayor&amp;iacute;a de las aplicaciones O (N &lt;sup&gt;2&lt;/sup&gt; ) del predicado, o exactamente N si las secuencias ya son iguales, donde &lt;code&gt;N=&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e9957d5de91d4b7c6c68d594aa3aa480005b9e3" translate="yes" xml:space="preserve">
          <source>At most linear in the &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; of the container.</source>
          <target state="translated">Como m&amp;aacute;ximo lineal en el &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; del contenedor.</target>
        </trans-unit>
        <trans-unit id="7b67cf2f323c75240ad28ea0936fabdb2eb7dfd2" translate="yes" xml:space="preserve">
          <source>At most linear in the &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; of the string.</source>
          <target state="translated">Como m&amp;aacute;ximo lineal en el &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; de la cadena.</target>
        </trans-unit>
        <trans-unit id="1f95351bbc9191f119c0c979d668c0b60be5e7b1" translate="yes" xml:space="preserve">
          <source>At most linear in the size of the container.</source>
          <target state="translated">A lo sumo lineal en el tamaño del contenedor.</target>
        </trans-unit>
        <trans-unit id="a42136bb0320d6ac91f01ed89b5ec95ea11cd801" translate="yes" xml:space="preserve">
          <source>At most max(floor((3/2)*(N&amp;minus;1)), 0) applications of the predicate, where &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt;.</source>
          <target state="translated">Como m&amp;aacute;ximo, max (floor ((3/2) * (N &amp;minus; 1)), 0) aplicaciones del predicado, donde &lt;code&gt;N = &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d7bca3c1a2d078e776e71dcbe99b35a321e5167" translate="yes" xml:space="preserve">
          <source>At most one &lt;a href=&quot;union#Union-like_classes&quot;&gt;variant member&lt;/a&gt; can have a &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializer&lt;/a&gt;.</source>
          <target state="translated">Como m&amp;aacute;ximo, un &lt;a href=&quot;union#Union-like_classes&quot;&gt;miembro variante&lt;/a&gt; puede tener un &lt;a href=&quot;data_members#Member_initialization&quot;&gt;inicializador de miembro predeterminado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c1f6896df7e191deb062d81024e89c21817f2db" translate="yes" xml:space="preserve">
          <source>At most one copy option in each of the following options groups may be present, otherwise the behavior of the copy functions is undefined.</source>
          <target state="translated">Puede haber como máximo una opción de copia en cada uno de los siguientes grupos de opciones,de lo contrario el comportamiento de las funciones de copia no está definido.</target>
        </trans-unit>
        <trans-unit id="4d4b41d6c4f9d31917e8132872ca199c890aa525" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="translated">Como m&amp;aacute;ximo, se debe elegir una opci&amp;oacute;n de gram&amp;aacute;tica de &lt;code&gt;ECMAScript&lt;/code&gt; , &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;awk&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;egrep&lt;/code&gt; . Si no se elige gram&amp;aacute;tica, se supone que se selecciona &lt;code&gt;ECMAScript&lt;/code&gt; . Las otras opciones sirven como modificadores, de modo que &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; es equivalente a &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4664e42aaeebe95a9d1a078a45a775bf60943bc7" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="translated">Como m&amp;aacute;ximo, se debe elegir una opci&amp;oacute;n de gram&amp;aacute;tica de &lt;code&gt;ECMAScript&lt;/code&gt; , &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;awk&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;egrep&lt;/code&gt; . Si no se elige gram&amp;aacute;tica, se supone que se selecciona &lt;code&gt;ECMAScript&lt;/code&gt; . Las otras opciones sirven como modificadores, de modo que &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; es equivalente a &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5e31fa82af84a5c287a47f543cebf5aedf134031" translate="yes" xml:space="preserve">
          <source>At most one grammar option must be chosen out of &lt;code&gt;ECMAScript&lt;/code&gt;, &lt;code&gt;basic&lt;/code&gt;, &lt;code&gt;extended&lt;/code&gt;, &lt;code&gt;awk&lt;/code&gt;, &lt;code&gt;grep&lt;/code&gt;, &lt;code&gt;egrep&lt;/code&gt;. If no grammar is chosen, &lt;code&gt;ECMAScript&lt;/code&gt; is assumed to be selected. The other options serve as modifiers, such that &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; is equivalent to &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt;.</source>
          <target state="translated">Como m&amp;aacute;ximo, se debe elegir una opci&amp;oacute;n de gram&amp;aacute;tica de &lt;code&gt;ECMAScript&lt;/code&gt; , &lt;code&gt;basic&lt;/code&gt; , &lt;code&gt;extended&lt;/code&gt; , &lt;code&gt;awk&lt;/code&gt; , &lt;code&gt;grep&lt;/code&gt; , &lt;code&gt;egrep&lt;/code&gt; . Si no se elige gram&amp;aacute;tica, se supone que se selecciona &lt;code&gt;ECMAScript&lt;/code&gt; . Las otras opciones sirven como modificadores, de modo que &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::icase)&lt;/code&gt; es equivalente a &lt;code&gt;std::regex(&quot;meow&quot;, std::regex::ECMAScript|std::regex::icase)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="311d67e063c452f5ead23f742890b672f660636b" translate="yes" xml:space="preserve">
          <source>At most one of &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt; may be present, otherwise the behavior of the permissions function is undefined.</source>
          <target state="translated">A lo sumo, uno de &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; puede estar presente, de lo contrario, el comportamiento de la funci&amp;oacute;n de permisos no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="2395ecfd633261d1a9cd5400cd07b765cc2f7a58" translate="yes" xml:space="preserve">
          <source>At most two comparisons.</source>
          <target state="translated">A lo sumo dos comparaciones.</target>
        </trans-unit>
        <trans-unit id="5c3f1418c87059f4cdb7e84bd90cc9bbf999a3c8" translate="yes" xml:space="preserve">
          <source>At or after modified element(s)</source>
          <target state="translated">En o después de los elementos modificados</target>
        </trans-unit>
        <trans-unit id="b99b53e1b81171c73a473d86eb4eba8e01df0ac3" translate="yes" xml:space="preserve">
          <source>At program startup,</source>
          <target state="translated">Al inicio del programa,</target>
        </trans-unit>
        <trans-unit id="bc78dcde97d0faac3fa0ab3c4057950ede8cc9fd" translate="yes" xml:space="preserve">
          <source>At the point in the code the operator() is called, the type must be complete. In some implementations a &lt;code&gt;static_assert&lt;/code&gt; is used to make sure this is the case. The reason for this requirement is that calling &lt;a href=&quot;../language/delete&quot;&gt;delete&lt;/a&gt; on an incomplete type is undefined behavior in C++ if the complete class type has a nontrivial destructor or a deallocation function, as the compiler has no way of knowing whether such functions exist and must be invoked.</source>
          <target state="translated">En el punto del c&amp;oacute;digo al que se llama el operador (), el tipo debe estar completo. En algunas implementaciones, se utiliza un &lt;code&gt;static_assert&lt;/code&gt; para asegurarse de que este sea el caso. La raz&amp;oacute;n de este requisito es que llamar a &lt;a href=&quot;../language/delete&quot;&gt;delete&lt;/a&gt; en un tipo incompleto es un comportamiento indefinido en C ++ si el tipo de clase completo tiene un destructor no trivial o una funci&amp;oacute;n de desasignaci&amp;oacute;n, ya que el compilador no tiene forma de saber si tales funciones existen y deben invocarse.</target>
        </trans-unit>
        <trans-unit id="e34285cac72686e9e93e2ea071243a4d166878b4" translate="yes" xml:space="preserve">
          <source>Atomic Operations library</source>
          <target state="translated">Biblioteca de Operaciones Atómicas</target>
        </trans-unit>
        <trans-unit id="8c9d8d00b5cb702da9e8a277758916eb4dd3cc1c" translate="yes" xml:space="preserve">
          <source>Atomic and synchronized blocks</source>
          <target state="translated">Bloques atómicos y sincronizados</target>
        </trans-unit>
        <trans-unit id="6816e21f31c82f13f142f06d907125e6d3ac7b98" translate="yes" xml:space="preserve">
          <source>Atomic and synchronized blocks are used to implement &lt;a href=&quot;transactional_memory&quot;&gt;transactional memory&lt;/a&gt;.</source>
          <target state="translated">Los bloques at&amp;oacute;micos y sincronizados se utilizan para implementar &lt;a href=&quot;transactional_memory&quot;&gt;memoria transaccional&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="82b6893aff5aea02a2292327874493a700ee80ae" translate="yes" xml:space="preserve">
          <source>Atomic blocks</source>
          <target state="translated">Bloques atómicos</target>
        </trans-unit>
        <trans-unit id="17b2c09204bb130f11f065ef3080da8ab1f767cb" translate="yes" xml:space="preserve">
          <source>Atomic constraints</source>
          <target state="translated">Restricciones atómicas</target>
        </trans-unit>
        <trans-unit id="401a31bc657222e6c53d68e589a5e6bc2cfed3b4" translate="yes" xml:space="preserve">
          <source>Atomic constraints are formed during &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;constraint normalization&lt;/a&gt;. &lt;code&gt;E&lt;/code&gt; is never a logical AND or logical OR expression (those form conjunctions and disjunctions, respectively).</source>
          <target state="translated">Las restricciones at&amp;oacute;micas se forman durante &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;la normalizaci&amp;oacute;n de restricciones&lt;/a&gt; . &lt;code&gt;E&lt;/code&gt; nunca es una expresi&amp;oacute;n l&amp;oacute;gica AND o l&amp;oacute;gica OR (esas forman conjunciones y disyunciones, respectivamente).</target>
        </trans-unit>
        <trans-unit id="ab3668521ac1e65f2c9a3ca3cc545235dc9f88c8" translate="yes" xml:space="preserve">
          <source>Atomic load with &lt;code&gt;memory_order_acquire&lt;/code&gt; or stronger is an acquire operation. The lock() operation on a &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; is also an acquire operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than an acquire operation.</source>
          <target state="translated">La carga at&amp;oacute;mica con &lt;code&gt;memory_order_acquire&lt;/code&gt; o m&amp;aacute;s fuerte es una operaci&amp;oacute;n de adquisici&amp;oacute;n. La operaci&amp;oacute;n de bloqueo () en un &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; tambi&amp;eacute;n es una operaci&amp;oacute;n de adquisici&amp;oacute;n. Tenga en cuenta que &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; impone requisitos de sincronizaci&amp;oacute;n m&amp;aacute;s fuertes que una operaci&amp;oacute;n de adquisici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="783585c8300c9cdf7a66c42d7b14307cfec6d73d" translate="yes" xml:space="preserve">
          <source>Atomic load with &lt;code&gt;memory_order_consume&lt;/code&gt; or stronger is a consume operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than a consume operation.</source>
          <target state="translated">La carga at&amp;oacute;mica con &lt;code&gt;memory_order_consume&lt;/code&gt; o m&amp;aacute;s fuerte es una operaci&amp;oacute;n de consumo. Tenga en cuenta que &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; impone requisitos de sincronizaci&amp;oacute;n m&amp;aacute;s fuertes que una operaci&amp;oacute;n de consumo.</target>
        </trans-unit>
        <trans-unit id="fb34ad6782840b3609292d56d50524837de11852" translate="yes" xml:space="preserve">
          <source>Atomic operations</source>
          <target state="translated">Operaciones atómicas</target>
        </trans-unit>
        <trans-unit id="99d4cd5536d79615f44163fe8a9526d16ce5bfca" translate="yes" xml:space="preserve">
          <source>Atomic operations applied to an object through an &lt;code&gt;atomic_ref&lt;/code&gt; are atomic with respect to atomic operations applied through any other &lt;code&gt;atomic_ref&lt;/code&gt; referencing the same object.</source>
          <target state="translated">Las operaciones at&amp;oacute;micas aplicadas a un objeto a trav&amp;eacute;s de &lt;code&gt;atomic_ref&lt;/code&gt; son at&amp;oacute;micas con respecto a las operaciones at&amp;oacute;micas aplicadas a trav&amp;eacute;s de cualquier otra &lt;code&gt;atomic_ref&lt;/code&gt; que haga referencia al mismo objeto.</target>
        </trans-unit>
        <trans-unit id="ec45a74e461d6d1f9a6d6860119c9137a6fed5b2" translate="yes" xml:space="preserve">
          <source>Atomic operations library</source>
          <target state="translated">Biblioteca de operaciones atómicas</target>
        </trans-unit>
        <trans-unit id="ac1cfc02a52dba8b178a48b4597760d28fb77ccd" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_relaxed&lt;/code&gt; are not synchronization operations; they do not impose an order among concurrent memory accesses. They only guarantee atomicity and modification order consistency.</source>
          <target state="translated">Las operaciones at&amp;oacute;micas etiquetadas &lt;code&gt;memory_order_relaxed&lt;/code&gt; no son operaciones de sincronizaci&amp;oacute;n; no imponen un orden entre los accesos concurrentes de memoria. Solo garantizan la atomicidad y la coherencia del orden de modificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4f6d4f2c68a571824e3f43d98c75cbda9d541c52" translate="yes" xml:space="preserve">
          <source>Atomic operations tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; not only order memory the same way as release/acquire ordering (everything that</source>
          <target state="translated">Las operaciones at&amp;oacute;micas etiquetadas &lt;code&gt;memory_order_seq_cst&lt;/code&gt; no solo ordenan la memoria de la misma manera que la orden de liberaci&amp;oacute;n / adquisici&amp;oacute;n (todo lo que</target>
        </trans-unit>
        <trans-unit id="72d4efbfff4cc7a737493b1c1c5054ea34242989" translate="yes" xml:space="preserve">
          <source>Atomic store with &lt;code&gt;memory_order_release&lt;/code&gt; or stronger is a release operation. The unlock() operation on a &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; is also a release operation. Note that &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; imposes stronger synchronization requirements than a release operation.</source>
          <target state="translated">La tienda at&amp;oacute;mica con &lt;code&gt;memory_order_release&lt;/code&gt; o m&amp;aacute;s fuerte es una operaci&amp;oacute;n de lanzamiento. La operaci&amp;oacute;n de desbloqueo () en un &lt;a href=&quot;../named_req/mutex&quot;&gt;Mutex&lt;/a&gt; tambi&amp;eacute;n es una operaci&amp;oacute;n de liberaci&amp;oacute;n. Tenga en cuenta que &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; impone requisitos de sincronizaci&amp;oacute;n m&amp;aacute;s fuertes que una operaci&amp;oacute;n de lanzamiento.</target>
        </trans-unit>
        <trans-unit id="6bd53298c2672a3d3501c1b3d668970f3f55e051" translate="yes" xml:space="preserve">
          <source>Atomic types</source>
          <target state="translated">Los tipos atómicos</target>
        </trans-unit>
        <trans-unit id="90945bda736ccd52d67480431115772e6ed72f07" translate="yes" xml:space="preserve">
          <source>Atomic-fence synchronization</source>
          <target state="translated">Sincronización de la valla atómica</target>
        </trans-unit>
        <trans-unit id="5d6ac2f41530550ee308dc296f9a8b617587365b" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Cambia at&amp;oacute;micamente el estado de &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; a clear ( &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="29366d9f87188ae24c9efa9144aa990ffcfc84da" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the value it held before.</source>
          <target state="translated">Cambia at&amp;oacute;micamente el estado de &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; para establecer ( &lt;code&gt;true&lt;/code&gt; ) y devuelve el valor que ten&amp;iacute;a antes.</target>
        </trans-unit>
        <trans-unit id="1ad9c0fc62bc1537d54b4759ea20c55784c16070" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pointed to by &lt;code&gt;p&lt;/code&gt; to clear (&lt;code&gt;false&lt;/code&gt;).</source>
          <target state="translated">Cambia at&amp;oacute;micamente el estado de un &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; se&amp;ntilde;alado por &lt;code&gt;p&lt;/code&gt; para borrar ( &lt;code&gt;false&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="75a7c684721b08be0f1216c929374cec16cea043" translate="yes" xml:space="preserve">
          <source>Atomically changes the state of a &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; pointed to by &lt;code&gt;p&lt;/code&gt; to set (&lt;code&gt;true&lt;/code&gt;) and returns the value it held before.</source>
          <target state="translated">Cambia at&amp;oacute;micamente el estado de un &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; se&amp;ntilde;alado por &lt;code&gt;p&lt;/code&gt; para establecer ( &lt;code&gt;true&lt;/code&gt; ) y devuelve el valor que ten&amp;iacute;a antes.</target>
        </trans-unit>
        <trans-unit id="2222bc337f08cf3ae8d66cc236b81d457d5ceac1" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../../language/objects&quot;&gt;object representation&lt;/a&gt;(until C++20)&lt;a href=&quot;../../language/objects&quot;&gt;value representation&lt;/a&gt;(since C++20) of &lt;code&gt;*this&lt;/code&gt; with that of &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual value stored in &lt;code&gt;*this&lt;/code&gt; into &lt;code&gt;expected&lt;/code&gt; (performs load operation).</source>
          <target state="translated">Compara at&amp;oacute;micamente la &lt;a href=&quot;../../language/objects&quot;&gt;representaci&amp;oacute;n del &lt;/a&gt;&lt;a href=&quot;../../language/objects&quot;&gt;valor de la representaci&amp;oacute;n&lt;/a&gt; del objeto (hasta C ++ 20) (desde C ++ 20) de &lt;code&gt;*this&lt;/code&gt; con la de lo &lt;code&gt;expected&lt;/code&gt; , y si son iguales en bits, reemplaza la primera con la &lt;code&gt;desired&lt;/code&gt; (realiza la operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura ) De lo contrario, carga el valor real almacenado en &lt;code&gt;*this&lt;/code&gt; en el &lt;code&gt;expected&lt;/code&gt; (realiza la operaci&amp;oacute;n de carga).</target>
        </trans-unit>
        <trans-unit id="7b40ae57bd4976e100c4d9ee74cf8c6179fd8839" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../../language/objects&quot;&gt;value representation&lt;/a&gt; of the referenced object with that of &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs a read-modify-write operation). Otherwise, loads the actual value stored in the referenced object into &lt;code&gt;expected&lt;/code&gt; (performs a load operation).</source>
          <target state="translated">Compara at&amp;oacute;micamente la &lt;a href=&quot;../../language/objects&quot;&gt;representaci&amp;oacute;n&lt;/a&gt; del valor del objeto referenciado con la &lt;code&gt;expected&lt;/code&gt; , y si son iguales en bits, reemplaza el primero con el &lt;code&gt;desired&lt;/code&gt; (realiza una operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura). De lo contrario, carga el valor real almacenado en el objeto referenciado en el &lt;code&gt;expected&lt;/code&gt; (realiza una operaci&amp;oacute;n de carga).</target>
        </trans-unit>
        <trans-unit id="aeaea937abc0bf67a8421b823386eae91292163e" translate="yes" xml:space="preserve">
          <source>Atomically compares the &lt;a href=&quot;../language/objects&quot;&gt;object representation&lt;/a&gt;(until C++20)&lt;a href=&quot;../language/objects&quot;&gt;value representation&lt;/a&gt;(since C++20) of the object pointed to by &lt;code&gt;obj&lt;/code&gt; with that of the object pointed to by &lt;code&gt;expected&lt;/code&gt;, and if those are bitwise-equal, replaces the former with &lt;code&gt;desired&lt;/code&gt; (performs read-modify-write operation). Otherwise, loads the actual value pointed to by &lt;code&gt;obj&lt;/code&gt; into &lt;code&gt;*expected&lt;/code&gt; (performs load operation). Copying is performed as if by &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Compara at&amp;oacute;micamente la &lt;a href=&quot;../language/objects&quot;&gt;representaci&amp;oacute;n del &lt;/a&gt;&lt;a href=&quot;../language/objects&quot;&gt;valor de la representaci&amp;oacute;n&lt;/a&gt; del objeto (hasta C ++ 20) (desde C ++ 20) del objeto se&amp;ntilde;alado por &lt;code&gt;obj&lt;/code&gt; con la del objeto se&amp;ntilde;alado por &lt;code&gt;expected&lt;/code&gt; , y si esos son iguales en bits, reemplaza el primero con &lt;code&gt;desired&lt;/code&gt; (realiza la operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura). De lo contrario, carga el valor real al que apunta &lt;code&gt;obj&lt;/code&gt; en &lt;code&gt;*expected&lt;/code&gt; (realiza la operaci&amp;oacute;n de carga). La copia se realiza como por &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="100502f70f849b38ac64477081a65ec2c013fbb9" translate="yes" xml:space="preserve">
          <source>Atomically increments or decrements the current value of the referenced object. These operations are read-modify-write operations.</source>
          <target state="translated">Aumenta o disminuye atómicamente el valor actual del objeto referido.Estas operaciones son operaciones de lecturamodificación-escritura.</target>
        </trans-unit>
        <trans-unit id="478a2d2041d2790f2221395bbe5bc4e3d3f3c4ae" translate="yes" xml:space="preserve">
          <source>Atomically increments or decrements the current value. The operation is read-modify-write operation.</source>
          <target state="translated">Aumenta o disminuye atómicamente el valor actual.La operación es de lecturamodificación-escritura.</target>
        </trans-unit>
        <trans-unit id="f7bed069080eb00025095bf335aa11983b2283e1" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable. Equivalent to &lt;code&gt;load()&lt;/code&gt;.</source>
          <target state="translated">Carga y devuelve at&amp;oacute;micamente el valor actual de la variable at&amp;oacute;mica. Equivalente a &lt;code&gt;load()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1952cd629d030a2fa8403e27ef4aeced380b94ae" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the atomic variable. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Carga y devuelve at&amp;oacute;micamente el valor actual de la variable at&amp;oacute;mica. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f83aead02c429c2fa534aa09292be21ef4c6405" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the referenced object. Equivalent to &lt;code&gt;load()&lt;/code&gt;.</source>
          <target state="translated">Carga y devuelve at&amp;oacute;micamente el valor actual del objeto referenciado. Equivalente a &lt;code&gt;load()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e52c7a399bc235c4dbc0b29092d8308432fa02c0" translate="yes" xml:space="preserve">
          <source>Atomically loads and returns the current value of the referenced object. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Carga y devuelve at&amp;oacute;micamente el valor actual del objeto referenciado. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f53b29272e48fca5f9671422bca6315e7e6fd8c3" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with &lt;code&gt;desired&lt;/code&gt;. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor actual del objeto referenciado con el &lt;code&gt;desired&lt;/code&gt; . La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a19feea96676cb1f3c159f83afde19f4a6539c3e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of arithmetic addition of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor actual del objeto referenciado con el resultado de la suma aritm&amp;eacute;tica del valor y &lt;code&gt;arg&lt;/code&gt; . Esta operaci&amp;oacute;n es una operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b3d0c0959425f2182650fbfbac226f664e7ddf7" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of arithmetic subtraction of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Reemplaza at&amp;oacute;micamente el valor actual del objeto referenciado con el resultado de la resta aritm&amp;eacute;tica del valor y &lt;code&gt;arg&lt;/code&gt; . Esta operaci&amp;oacute;n es una operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99dda00379caf075c4d39211472eaedafbd4f762" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise AND of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Reemplaza at&amp;oacute;micamente el valor actual del objeto referenciado con el resultado de AND bit a bit del valor y &lt;code&gt;arg&lt;/code&gt; . Esta operaci&amp;oacute;n es una operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="323c91d66c8118d7dbee222ab3de24a8cae5e0b1" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise OR of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor actual del objeto referenciado con el resultado de OR bit a bit del valor y &lt;code&gt;arg&lt;/code&gt; . Esta operaci&amp;oacute;n es una operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adf79a00626da82188ce094554607a0fe2a38357" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of bitwise XOR of the value and &lt;code&gt;arg&lt;/code&gt;. This operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Reemplaza at&amp;oacute;micamente el valor actual del objeto referenciado con el resultado de XOR bit a bit del valor y &lt;code&gt;arg&lt;/code&gt; . Esta operaci&amp;oacute;n es una operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed67e3ed1c1744cb0f490f47975b11310f42139e" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value of the referenced object with the result of computation involving the previous value and &lt;code&gt;arg&lt;/code&gt;. These operations are read-modify-write operations.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor actual del objeto referenciado con el resultado del c&amp;aacute;lculo que involucra el valor anterior y &lt;code&gt;arg&lt;/code&gt; . Estas operaciones son operaciones de lectura-modificaci&amp;oacute;n-escritura.</target>
        </trans-unit>
        <trans-unit id="f9b3020972d1b8ef0fae02f3fff0adbd8b1bd992" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with &lt;code&gt;desired&lt;/code&gt;. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor actual con el &lt;code&gt;desired&lt;/code&gt; . La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c638ee73c1897f53905a40e8ba22b46e8d59e4e1" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of arithmetic addition of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Reemplaza at&amp;oacute;micamente el valor actual con el resultado de la suma aritm&amp;eacute;tica del valor y &lt;code&gt;arg&lt;/code&gt; . La operaci&amp;oacute;n es operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b99663e5dfaace40d5f5294851f50381ac55b0bc" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of arithmetic subtraction of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">Reemplaza at&amp;oacute;micamente el valor actual con el resultado de la resta aritm&amp;eacute;tica del valor y &lt;code&gt;arg&lt;/code&gt; . La operaci&amp;oacute;n es operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79ead769b0375ec14ce72a88030040dd2a0e44be" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise AND of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor actual con el resultado de Y bit a bit del valor y &lt;code&gt;arg&lt;/code&gt; . La operaci&amp;oacute;n es operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7fe2746833cc38f05662da6d971a85fc32df09" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise OR of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor actual con el resultado de OR bit a bit del valor y &lt;code&gt;arg&lt;/code&gt; . La operaci&amp;oacute;n es operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea95b2c69d82181c7d1ab5a7c21e9a5addde310" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of bitwise XOR of the value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor actual con el resultado de XOR bit a bit del valor y &lt;code&gt;arg&lt;/code&gt; . La operaci&amp;oacute;n es operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10212a346ea05ad906b686a41eca7ff8ef3b510f" translate="yes" xml:space="preserve">
          <source>Atomically replaces the current value with the result of computation involving the previous value and &lt;code&gt;arg&lt;/code&gt;. The operation is read-modify-write operation.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor actual con el resultado del c&amp;aacute;lculo que involucra el valor anterior y &lt;code&gt;arg&lt;/code&gt; . La operaci&amp;oacute;n es operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura.</target>
        </trans-unit>
        <trans-unit id="3467c0dccb0c6c9b65479a9107e17419103cfb53" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; and returns a copy of the value that &lt;code&gt;p&lt;/code&gt; had immediately before the swap. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. This is an atomic read-modify-write operation.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; subyacente con el &lt;code&gt;desired&lt;/code&gt; como si fuera &lt;code&gt;p.swap(desired)&lt;/code&gt; donde &lt;code&gt;p&lt;/code&gt; es el &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; subyacente y devuelve una copia del valor que &lt;code&gt;p&lt;/code&gt; ten&amp;iacute;a inmediatamente antes del intercambio. La memoria se ordena seg&amp;uacute;n el &lt;code&gt;order&lt;/code&gt; . Esta es una operaci&amp;oacute;n at&amp;oacute;mica de lectura-modificaci&amp;oacute;n-escritura.</target>
        </trans-unit>
        <trans-unit id="85d280e69a1a33e2d68aa75acba96c49fd3e46b4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; with &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;, and returns a copy of the value that &lt;code&gt;p&lt;/code&gt; had immediately before the swap. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. This is an atomic read-modify-write operation.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; subyacente con &lt;code&gt;desired&lt;/code&gt; como si fuera &lt;code&gt;p.swap(desired)&lt;/code&gt; donde &lt;code&gt;p&lt;/code&gt; es el &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; subyacente , y devuelve una copia del valor que &lt;code&gt;p&lt;/code&gt; ten&amp;iacute;a inmediatamente antes del intercambio. La memoria se ordena seg&amp;uacute;n el &lt;code&gt;order&lt;/code&gt; . Esta es una operaci&amp;oacute;n at&amp;oacute;mica de lectura-modificaci&amp;oacute;n-escritura.</target>
        </trans-unit>
        <trans-unit id="0a463d97ca8c0c667a93bc169dce0bad4944f951" translate="yes" xml:space="preserve">
          <source>Atomically replaces the underlying value with &lt;code&gt;desired&lt;/code&gt;. The operation is read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor subyacente con el &lt;code&gt;desired&lt;/code&gt; . La operaci&amp;oacute;n es operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="718b9a19aefebfb54908169ba35b035711a206bc" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of &lt;code&gt;*this&lt;/code&gt; with the value of &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor de &lt;code&gt;*this&lt;/code&gt; con el valor &lt;code&gt;desired&lt;/code&gt; como si fuera &lt;code&gt;p.swap(desired)&lt;/code&gt; donde &lt;code&gt;p&lt;/code&gt; es el &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; subyacente . La memoria se ordena seg&amp;uacute;n el &lt;code&gt;order&lt;/code&gt; . El comportamiento no est&amp;aacute; definido si el &lt;code&gt;order&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc343521b195a9638c26a309b38189be49c6ff1c" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of &lt;code&gt;*this&lt;/code&gt; with the value of &lt;code&gt;desired&lt;/code&gt; as if by &lt;code&gt;p.swap(desired)&lt;/code&gt; where &lt;code&gt;p&lt;/code&gt; is the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor de &lt;code&gt;*this&lt;/code&gt; con el valor &lt;code&gt;desired&lt;/code&gt; como si fuera &lt;code&gt;p.swap(desired)&lt;/code&gt; donde &lt;code&gt;p&lt;/code&gt; es el &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; subyacente . La memoria se ordena seg&amp;uacute;n el &lt;code&gt;order&lt;/code&gt; . El comportamiento no est&amp;aacute; definido si el &lt;code&gt;order&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_consume&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eccb30a10adac1732c948846412c97a22323cf04" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the referenced object with &lt;code&gt;desired&lt;/code&gt;. The operation is a read-modify-write operation. Memory is affected according to the value of &lt;code&gt;order&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor del objeto referenciado con el &lt;code&gt;desired&lt;/code&gt; . La operaci&amp;oacute;n es una operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura. La memoria se ve afectada seg&amp;uacute;n el valor del &lt;code&gt;order&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80dd75e8d600a19f4770f91cf5757274b7f5c6c5" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise AND between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="translated">Reemplaza at&amp;oacute;micamente el valor se&amp;ntilde;alado por &lt;code&gt;obj&lt;/code&gt; con el resultado de Y bit a bit entre el valor anterior de &lt;code&gt;obj&lt;/code&gt; y &lt;code&gt;arg&lt;/code&gt; . Devuelve el valor &lt;code&gt;obj&lt;/code&gt; mantenido anteriormente.</target>
        </trans-unit>
        <trans-unit id="790044bcc17db31e5c336936470c4daa1b6b3cd4" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise OR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="translated">Reemplaza at&amp;oacute;micamente el valor se&amp;ntilde;alado por &lt;code&gt;obj&lt;/code&gt; con el resultado de OR bit a bit entre el valor anterior de &lt;code&gt;obj&lt;/code&gt; y &lt;code&gt;arg&lt;/code&gt; . Devuelve el valor &lt;code&gt;obj&lt;/code&gt; mantenido anteriormente.</target>
        </trans-unit>
        <trans-unit id="f251ecee591189cacdcc48a0936a14e913d943df" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value pointed by &lt;code&gt;obj&lt;/code&gt; with the result of bitwise XOR between the old value of &lt;code&gt;obj&lt;/code&gt; and &lt;code&gt;arg&lt;/code&gt;. Returns the value &lt;code&gt;obj&lt;/code&gt; held previously.</source>
          <target state="translated">At&amp;oacute;micamente reemplaza el valor se&amp;ntilde;alado por &lt;code&gt;obj&lt;/code&gt; con el resultado de XOR bit a bit entre el valor anterior de &lt;code&gt;obj&lt;/code&gt; y &lt;code&gt;arg&lt;/code&gt; . Devuelve el valor &lt;code&gt;obj&lt;/code&gt; mantenido anteriormente.</target>
        </trans-unit>
        <trans-unit id="3d9f4d98a3780918fb788b0a5026571e73af577e" translate="yes" xml:space="preserve">
          <source>Atomically returns a copy of the underlying &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt;. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente devuelve una copia del &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; subyacente . La memoria se ordena seg&amp;uacute;n el &lt;code&gt;order&lt;/code&gt; . El comportamiento no est&amp;aacute; definido si el &lt;code&gt;order&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33f67f81fe0865ff25fe2875aabcaf4cb3ed91ca" translate="yes" xml:space="preserve">
          <source>Atomically returns a copy of the underlying shared pointer. Memory is ordered according to &lt;code&gt;order&lt;/code&gt;. The behavior is undefined if &lt;code&gt;order&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">At&amp;oacute;micamente devuelve una copia del puntero compartido subyacente. La memoria se ordena seg&amp;uacute;n el &lt;code&gt;order&lt;/code&gt; . El comportamiento no est&amp;aacute; definido si el &lt;code&gt;order&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c88562518723a64d9fcb4f31aa71ec0eefafe8" translate="yes" xml:space="preserve">
          <source>Atomically stores the exception pointer &lt;code&gt;p&lt;/code&gt; into the shared state and makes the state ready.</source>
          <target state="translated">At&amp;oacute;micamente almacena el puntero de excepci&amp;oacute;n &lt;code&gt;p&lt;/code&gt; en el estado compartido y prepara el estado.</target>
        </trans-unit>
        <trans-unit id="c5a3aae2b82d6bc278809f7ca79720a49ddb5e50" translate="yes" xml:space="preserve">
          <source>Atomically transmits all pending output to the wrapped stream.</source>
          <target state="translated">La transmisión atómica de toda la producción pendiente a la corriente envuelta.</target>
        </trans-unit>
        <trans-unit id="22cd0cbd81dee9dcd227285a4fb456261af24ea4" translate="yes" xml:space="preserve">
          <source>Atomics</source>
          <target state="translated">Atomics</target>
        </trans-unit>
        <trans-unit id="a0416416d30eca6a7701e0924dc48acb5d8ff422" translate="yes" xml:space="preserve">
          <source>Attempting to forward an rvalue as an lvalue, such as by instantiating the form (2) with lvalue reference type T, is a compile-time error.</source>
          <target state="translated">Intentar reenviar un valor como un valor l,por ejemplo,instanciando la forma (2)con un valor l de referencia tipo T,es un error en tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="76a4004354e2dd4daf0348cba6cc1fc1999f48f1" translate="yes" xml:space="preserve">
          <source>Attempting to modify a string literal results in</source>
          <target state="translated">Intentar modificar el literal de una cadena resulta en</target>
        </trans-unit>
        <trans-unit id="abad2c050ad896c23b0ad28b3e223e6dd62344dd" translate="yes" xml:space="preserve">
          <source>Attempting to specialize a template defined in the &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; header results in undefined behavior, except that &lt;code&gt;&lt;a href=&quot;types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; may be specialized &lt;a href=&quot;types/common_type#Specializations&quot;&gt;as described in its description&lt;/a&gt;.</source>
          <target state="translated">Intentar especializar una plantilla definida en el &lt;code&gt;&amp;lt;type_traits&amp;gt;&lt;/code&gt; resulta en un comportamiento indefinido, excepto que &lt;code&gt;&lt;a href=&quot;types/common_type&quot;&gt;std::common_type&lt;/a&gt;&lt;/code&gt; puede especializarse &lt;a href=&quot;types/common_type#Specializations&quot;&gt;como se describe en su descripci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="78a4a89b2d2486832b4cafece47f12bab7a55776" translate="yes" xml:space="preserve">
          <source>Attempts to acquire the lock for the current execution agent (thread, process, task) without blocking. If an exception is thrown, no lock is obtained.</source>
          <target state="translated">Intenta adquirir el bloqueo para el agente de ejecución actual (hilo,proceso,tarea)sin bloqueo.Si se lanza una excepción,no se obtiene el bloqueo.</target>
        </trans-unit>
        <trans-unit id="baca3810d2cde4b7e1025b84062248c5223beff5" translate="yes" xml:space="preserve">
          <source>Attempts to clear the floating-point exceptions that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">Intenta borrar las excepciones de punto flotante que se enumeran en las &lt;code&gt;excepts&lt;/code&gt; argumento de m&amp;aacute;scara de bits , que es un OR bit a bit de las &lt;a href=&quot;fe_exceptions&quot;&gt;macros de excepci&amp;oacute;n de punto flotante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7dbed2ba20cbcb53c66e4a383e6c53bad4b2eb39" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the comparison object of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Intenta extraer (&quot;empalmar&quot;) cada elemento en la &lt;code&gt;source&lt;/code&gt; e insertarlo en &lt;code&gt;*this&lt;/code&gt; utilizando el objeto de comparaci&amp;oacute;n de &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69638346260f8c39f54ee09036f959b95caeb136" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the comparison object of &lt;code&gt;*this&lt;/code&gt;. If there is an element in &lt;code&gt;*this&lt;/code&gt; with key equivalent to the key of an element from &lt;code&gt;source&lt;/code&gt;, then that element is not extracted from &lt;code&gt;source&lt;/code&gt;. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;.</source>
          <target state="translated">Intenta extraer (&quot;empalmar&quot;) cada elemento en la &lt;code&gt;source&lt;/code&gt; e insertarlo en &lt;code&gt;*this&lt;/code&gt; utilizando el objeto de comparaci&amp;oacute;n de &lt;code&gt;*this&lt;/code&gt; . Si hay un elemento en &lt;code&gt;*this&lt;/code&gt; con clave equivalente a la clave de un elemento de &lt;code&gt;source&lt;/code&gt; , entonces ese elemento no se extrae de &lt;code&gt;source&lt;/code&gt; . No se copian ni mueven elementos, solo se vuelven a asignar los punteros internos de los nodos del contenedor. Todos los punteros y referencias a los elementos transferidos siguen siendo v&amp;aacute;lidos, pero ahora se refieren a &lt;code&gt;*this&lt;/code&gt; , no a la &lt;code&gt;source&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95555f012243a16b5fbac5ece1355dd665253556" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the hash function and key equality predicate of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Intenta extraer (&quot;empalmar&quot;) cada elemento en la &lt;code&gt;source&lt;/code&gt; e insertarlo en &lt;code&gt;*this&lt;/code&gt; utilizando la funci&amp;oacute;n hash y el predicado de igualdad de clave de &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5462c1b9abbfcaedbee9e1ed5c5c12b594c2335b" translate="yes" xml:space="preserve">
          <source>Attempts to extract (&quot;splice&quot;) each element in &lt;code&gt;source&lt;/code&gt; and insert it into &lt;code&gt;*this&lt;/code&gt; using the hash function and key equality predicate of &lt;code&gt;*this&lt;/code&gt;. If there is an element in &lt;code&gt;*this&lt;/code&gt; with key equivalent to the key of an element from &lt;code&gt;source&lt;/code&gt;, then that element is not extracted from &lt;code&gt;source&lt;/code&gt;. No elements are copied or moved, only the internal pointers of the container nodes are repointed. All pointers and references to the transferred elements remain valid, but now refer into &lt;code&gt;*this&lt;/code&gt;, not into &lt;code&gt;source&lt;/code&gt;. Iterators referring to the transferred elements and all iterators referring to &lt;code&gt;*this&lt;/code&gt; are invalidated. Iterators to elements remaining in &lt;code&gt;source&lt;/code&gt; remain valid.</source>
          <target state="translated">Intenta extraer (&quot;empalmar&quot;) cada elemento en la &lt;code&gt;source&lt;/code&gt; e insertarlo en &lt;code&gt;*this&lt;/code&gt; utilizando la funci&amp;oacute;n hash y el predicado de igualdad de clave de &lt;code&gt;*this&lt;/code&gt; . Si hay un elemento en &lt;code&gt;*this&lt;/code&gt; con clave equivalente a la clave de un elemento de &lt;code&gt;source&lt;/code&gt; , entonces ese elemento no se extrae de &lt;code&gt;source&lt;/code&gt; . No se copian ni mueven elementos, solo se vuelven a asignar los punteros internos de los nodos del contenedor. Todos los punteros y referencias a los elementos transferidos siguen siendo v&amp;aacute;lidos, pero ahora se refieren a &lt;code&gt;*this&lt;/code&gt; , no a la &lt;code&gt;source&lt;/code&gt; . Iteradores que hacen referencia a los elementos transferidos y todos los iteradores que hacen referencia a &lt;code&gt;*this&lt;/code&gt; est&amp;aacute;n invalidados Los iteradores de elementos que permanecen en la &lt;code&gt;source&lt;/code&gt; siguen siendo v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="92bc4254a3b00d301ffc057c9e050501ca173c4b" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex for the calling thread without blocking. If ownership is not obtained, returns immediately. The function is allowed to spuriously fail and return even if the mutex is not currently owned by another thread.</source>
          <target state="translated">Intenta obtener la propiedad exclusiva del mutex para el hilo de llamada sin bloquearlo.Si no se obtiene la propiedad,regresa inmediatamente.Se permite que la función falle y regrese de manera espuria,incluso si el mutex no es actualmente propiedad de otro hilo.</target>
        </trans-unit>
        <trans-unit id="9d99e4cbad6e4e7caa7d20dc148d4b12dfad9de6" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex within the duration specified by &lt;code&gt;duration&lt;/code&gt;. If &lt;code&gt;duration&lt;/code&gt; is less or equal &lt;code&gt;duration.zero()&lt;/code&gt;, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;duration&lt;/code&gt; passes. It returns within &lt;code&gt;duration&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time during &lt;code&gt;duration&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Intenta obtener la propiedad exclusiva del mutex dentro de la duraci&amp;oacute;n especificada por la &lt;code&gt;duration&lt;/code&gt; . Si la &lt;code&gt;duration&lt;/code&gt; es menor o igual a la &lt;code&gt;duration.zero()&lt;/code&gt; , intenta obtener la propiedad sin bloquear (como por &lt;code&gt;try_lock()&lt;/code&gt; ). De lo contrario, esta funci&amp;oacute;n se bloquea hasta que se adquiere el mutex o hasta que pasa el tiempo especificado por la &lt;code&gt;duration&lt;/code&gt; . Regresa dentro de la &lt;code&gt;duration&lt;/code&gt; solo si tiene &amp;eacute;xito, pero permiti&amp;oacute; no adquirir el mutex incluso si en alg&amp;uacute;n momento durante la &lt;code&gt;duration&lt;/code&gt; no fue propiedad de otro hilo. En cualquier caso, devuelve &lt;code&gt;true&lt;/code&gt; si se adquiri&amp;oacute; el mutex y &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="80bd748efa455b573b135d3617ebfa1fd13b34d8" translate="yes" xml:space="preserve">
          <source>Attempts to obtain exclusive ownership of the mutex within the time left until &lt;code&gt;time_point&lt;/code&gt;. If &lt;code&gt;time_point&lt;/code&gt; already passed, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;time_point&lt;/code&gt; passes. It returns before &lt;code&gt;time_point&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time before &lt;code&gt;time_point&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Intenta obtener la propiedad exclusiva del mutex dentro del tiempo restante hasta &lt;code&gt;time_point&lt;/code&gt; . Si &lt;code&gt;time_point&lt;/code&gt; ya pas&amp;oacute;, intenta obtener la propiedad sin bloquear (como si fuera &lt;code&gt;try_lock()&lt;/code&gt; ). De lo contrario, esta funci&amp;oacute;n se bloquea hasta que se adquiere el mutex o hasta que pasa el tiempo especificado por &lt;code&gt;time_point&lt;/code&gt; . Regresa antes de &lt;code&gt;time_point&lt;/code&gt; solo si tiene &amp;eacute;xito, pero permiti&amp;oacute; no adquirir el mutex incluso si en alg&amp;uacute;n momento antes de &lt;code&gt;time_point&lt;/code&gt; no era propiedad de otro hilo. En cualquier caso, devuelve &lt;code&gt;true&lt;/code&gt; si se adquiri&amp;oacute; el mutex y &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="7fb190dc6b50cac16e4189df447478fcf3a9d392" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex for the calling thread without blocking. If ownership is not obtained, returns immediately. The function is allowed to spuriously fail and return even if the mutex is not currently owned by any threads in any mode.</source>
          <target state="translated">Intenta obtener la propiedad compartida del mutex para el hilo de llamada sin bloquearlo.Si no se obtiene la propiedad,regresa inmediatamente.Se permite que la función falle y regrese de manera espuria,incluso si el mutex no es actualmente propiedad de ningún hilo en ningún modo.</target>
        </trans-unit>
        <trans-unit id="f1ab0535323ac87b863427dcfd803c52e2e71c97" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex within the duration specified by &lt;code&gt;duration&lt;/code&gt;. If &lt;code&gt;duration&lt;/code&gt; is less or equal &lt;code&gt;duration.zero()&lt;/code&gt;, attempts to obtain the ownership without waiting (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;duration&lt;/code&gt; passes. It returns within &lt;code&gt;duration&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time during &lt;code&gt;duration&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Intenta obtener la propiedad compartida del mutex dentro de la duraci&amp;oacute;n especificada por la &lt;code&gt;duration&lt;/code&gt; . Si la &lt;code&gt;duration&lt;/code&gt; es menor o igual a la &lt;code&gt;duration.zero()&lt;/code&gt; , intenta obtener la propiedad sin esperar (como por &lt;code&gt;try_lock()&lt;/code&gt; ). De lo contrario, esta funci&amp;oacute;n se bloquea hasta que se adquiere el mutex o hasta que pasa el tiempo especificado por la &lt;code&gt;duration&lt;/code&gt; . Regresa dentro de la &lt;code&gt;duration&lt;/code&gt; solo si tiene &amp;eacute;xito, pero permiti&amp;oacute; no adquirir el mutex incluso si en alg&amp;uacute;n momento durante la &lt;code&gt;duration&lt;/code&gt; no fue propiedad de otro hilo. En cualquier caso, devuelve &lt;code&gt;true&lt;/code&gt; si se adquiri&amp;oacute; el mutex y &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="7e1b61606843aa888af598e0c261d938b302f15a" translate="yes" xml:space="preserve">
          <source>Attempts to obtain shared ownership of the mutex within the time left until &lt;code&gt;time_point&lt;/code&gt;. If &lt;code&gt;time_point&lt;/code&gt; already passed, attempts to obtain the ownership without locking (as if by &lt;code&gt;try_lock()&lt;/code&gt;). Otherwise, this function blocks until the mutex is acquired or until the time specified by &lt;code&gt;time_point&lt;/code&gt; passes. It returns before &lt;code&gt;time_point&lt;/code&gt; only if it succeeds, but it allowed to fail to acquire the mutex even if at some point in time before &lt;code&gt;time_point&lt;/code&gt; it was not owned by another thread. In any case, it returns &lt;code&gt;true&lt;/code&gt; if the mutex was acquired and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Intenta obtener la propiedad compartida del mutex dentro del tiempo restante hasta &lt;code&gt;time_point&lt;/code&gt; . Si &lt;code&gt;time_point&lt;/code&gt; ya pas&amp;oacute;, intenta obtener la propiedad sin bloquear (como si fuera &lt;code&gt;try_lock()&lt;/code&gt; ). De lo contrario, esta funci&amp;oacute;n se bloquea hasta que se adquiere el mutex o hasta que pasa el tiempo especificado por &lt;code&gt;time_point&lt;/code&gt; . Regresa antes de &lt;code&gt;time_point&lt;/code&gt; solo si tiene &amp;eacute;xito, pero permiti&amp;oacute; no adquirir el mutex incluso si en alg&amp;uacute;n momento antes de &lt;code&gt;time_point&lt;/code&gt; no era propiedad de otro hilo. En cualquier caso, devuelve &lt;code&gt;true&lt;/code&gt; si se adquiri&amp;oacute; el mutex y &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="52d6b2b14e6e6fe30ee7f8d64fe95f33b5f6832a" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;&lt;code&gt;d&lt;/code&gt;, interpreted as the time of day since midnight, according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;../duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; , interpretados como la hora del d&amp;iacute;a desde la medianoche, de acuerdo con el formato de cadena &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="376efd8a04cc4bbd4dec0c37c8f77d83f331d150" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::day&lt;/code&gt;&lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en el &lt;code&gt;std::chrono::day&lt;/code&gt; &lt;code&gt;d&lt;/code&gt; de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ca1a9386d370561e811dd985b14a1c196b3e9e6" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::month&lt;/code&gt;&lt;code&gt;m&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en el &lt;code&gt;std::chrono::month&lt;/code&gt; &lt;code&gt;m&lt;/code&gt; acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40506d7d67c8bce66782b683f245a3f3fdf40954" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::month_day&lt;/code&gt;&lt;code&gt;md&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en el &lt;code&gt;std::chrono::month_day&lt;/code&gt; &lt;code&gt;md&lt;/code&gt; acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40de5b5311f786d5adb9ba2992f4f537c57266b8" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::weekday&lt;/code&gt;&lt;code&gt;wd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en el &lt;code&gt;std::chrono::weekday&lt;/code&gt; &lt;code&gt;wd&lt;/code&gt; acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c5714af52ba60c907aab16771ef9fc12f5e61b9" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year&lt;/code&gt;&lt;code&gt;y&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en el &lt;code&gt;std::chrono::year&lt;/code&gt; &lt;code&gt;y&lt;/code&gt; de acuerdo a la cadena de formato &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40c30b9ec9cc1fd3faebf2fb9fdfd4762f1dbc0a" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year_month&lt;/code&gt;&lt;code&gt;ym&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en el &lt;code&gt;std::chrono::year_month&lt;/code&gt; &lt;code&gt;ym&lt;/code&gt; acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca0d091ecc65883512fa43e7446c9c5bb23b7dda" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the &lt;code&gt;std::chrono::year_month_day&lt;/code&gt;&lt;code&gt;ymd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en el &lt;code&gt;std::chrono::year_month_day&lt;/code&gt; &lt;code&gt;ymd&lt;/code&gt; acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31bf10609fbb5d90b5c351b1efc2680a881a160b" translate="yes" xml:space="preserve">
          <source>Attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into the time point &lt;code&gt;tp&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;.</source>
          <target state="translated">Los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en el punto de tiempo &lt;code&gt;tp&lt;/code&gt; de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ba342b8785a08804a333bbfedec341d6d1c9c0" translate="yes" xml:space="preserve">
          <source>Attempts to raise all floating point exceptions listed in &lt;code&gt;excepts&lt;/code&gt; (a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;). If one of the exceptions is &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt;, this function may additionally raise &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;. The order in which the exceptions are raised is unspecified, except that &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; are always raised before &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Intenta aumentar todas las excepciones de coma flotante enumeradas en las &lt;code&gt;excepts&lt;/code&gt; (un OR bit a bit de las &lt;a href=&quot;fe_exceptions&quot;&gt;macros de excepci&amp;oacute;n de coma flotante&lt;/a&gt; ). Si una de las excepciones es &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; , esta funci&amp;oacute;n tambi&amp;eacute;n puede aumentar &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; . El orden en que se &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_OVERFLOW&lt;/a&gt;&lt;/code&gt; las excepciones no se especifica, excepto que FE_OVERFLOW y &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; siempre se &lt;code&gt;&lt;a href=&quot;fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; antes de FE_INEXACT .</target>
        </trans-unit>
        <trans-unit id="a086d942884a301b827479029ba19c2746237425" translate="yes" xml:space="preserve">
          <source>Attribute</source>
          <target state="translated">Attribute</target>
        </trans-unit>
        <trans-unit id="a902057674f85199d3ac1499e38efca7a4896e56" translate="yes" xml:space="preserve">
          <source>Attribute declaration (&lt;a href=&quot;attributes&quot;&gt;attr&lt;/a&gt;&lt;code&gt;;&lt;/code&gt;) (since C++11)</source>
          <target state="translated">Declaraci&amp;oacute;n de atributos ( &lt;a href=&quot;attributes&quot;&gt;attr &lt;/a&gt; &lt;code&gt;;&lt;/code&gt; ) (desde C ++ 11)</target>
        </trans-unit>
        <trans-unit id="73fed77350865417033e78f8ec9ca2448d835567" translate="yes" xml:space="preserve">
          <source>Attribute list</source>
          <target state="translated">Lista de atributos</target>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="fad8ef5207a6faf8cf0a093eff47035c565b35b8" translate="yes" xml:space="preserve">
          <source>Attributes for &lt;a href=&quot;language/enum&quot;&gt;enumerators&lt;/a&gt;</source>
          <target state="translated">Atributos para &lt;a href=&quot;language/enum&quot;&gt;enumeradores&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c24797e2f08fead2ed265ebddf05756fe163fa39" translate="yes" xml:space="preserve">
          <source>Attributes for &lt;a href=&quot;language/namespace&quot;&gt;namespaces&lt;/a&gt;</source>
          <target state="translated">Atributos para &lt;a href=&quot;language/namespace&quot;&gt;espacios&lt;/a&gt; de nombres</target>
        </trans-unit>
        <trans-unit id="24a93aad8da8b2ecc0fb62d3635f7bcad0973aee" translate="yes" xml:space="preserve">
          <source>Attributes provide the unified standard syntax for implementation-defined language extensions, such as the GNU and IBM language extensions &lt;code&gt;__attribute__((...))&lt;/code&gt;, Microsoft extension &lt;code&gt;__declspec()&lt;/code&gt;, etc.</source>
          <target state="translated">Los atributos proporcionan la sintaxis est&amp;aacute;ndar unificada para las extensiones de lenguaje definidas por la implementaci&amp;oacute;n, como las extensiones de lenguaje GNU e IBM &lt;code&gt;__attribute__((...))&lt;/code&gt; , la extensi&amp;oacute;n de Microsoft &lt;code&gt;__declspec()&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="35d5b17890aadedb8aadfe40da01d18e88c0f170" translate="yes" xml:space="preserve">
          <source>Average case O(N), worst case O(N*size()+N), where N is &lt;code&gt;source.size()&lt;/code&gt;.</source>
          <target state="translated">Caso promedio O (N), peor caso O (N * tama&amp;ntilde;o () + N), donde N es &lt;code&gt;source.size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca02a8758f4a48f9665324811a74024dd77f1084" translate="yes" xml:space="preserve">
          <source>Average case linear in the number of elements with the key &lt;code&gt;key&lt;/code&gt;, worst case linear in the size of the container.</source>
          <target state="translated">Caso promedio lineal en el n&amp;uacute;mero de elementos con la tecla &lt;code&gt;key&lt;/code&gt; , peor caso lineal en el tama&amp;ntilde;o del contenedor.</target>
        </trans-unit>
        <trans-unit id="500ca2374c6717aa20d965b6fb6566e425ffa363" translate="yes" xml:space="preserve">
          <source>Average case linear in the size of the container, worst case quadratic.</source>
          <target state="translated">Promedio de casos lineales en el tamaño del contenedor,en el peor de los casos cuadráticos.</target>
        </trans-unit>
        <trans-unit id="0cf15213abbcf806e052466023c496d374b93c5e" translate="yes" xml:space="preserve">
          <source>Average case: constant, worst case: linear in size.</source>
          <target state="translated">Caso promedio:constante,el peor caso:lineal en tamaño.</target>
        </trans-unit>
        <trans-unit id="c69ec73023882fcdb14f4029c8b28967cb6b9150" translate="yes" xml:space="preserve">
          <source>Average number of elements per bucket.</source>
          <target state="translated">Número medio de elementos por cubo.</target>
        </trans-unit>
        <trans-unit id="5af1300096bdfebd096b49bf84d70a955eb1b7f9" translate="yes" xml:space="preserve">
          <source>Avoiding implicit copy assignment.</source>
          <target state="translated">Evitar la asignación implícita de copias.</target>
        </trans-unit>
        <trans-unit id="8c40560d40ca8b01a27ce21af51b6bb3a0aa5d77" translate="yes" xml:space="preserve">
          <source>Avoiding implicit generation of the copy constructor.</source>
          <target state="translated">Evitando la generación implícita del constructor de la copia.</target>
        </trans-unit>
        <trans-unit id="55a6c927298fd43f61b985a13d7c9627855c38d0" translate="yes" xml:space="preserve">
          <source>Avoiding implicit move assignment.</source>
          <target state="translated">Evitar la asignación de movimientos implícitos.</target>
        </trans-unit>
        <trans-unit id="21e51124dadde6f26a27f5ade3d091ebb552a9a3" translate="yes" xml:space="preserve">
          <source>Avoiding implicit move constructor.</source>
          <target state="translated">Evitando el constructor de movimientos implícitos.</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="4c39141080123158d56211e39765a42a9728de5f" translate="yes" xml:space="preserve">
          <source>B 2) A</source>
          <target state="translated">B 2)A</target>
        </trans-unit>
        <trans-unit id="62706ba741ba699cbebde8104c0834806fb26022" translate="yes" xml:space="preserve">
          <source>B 3) A</source>
          <target state="translated">B 3)A</target>
        </trans-unit>
        <trans-unit id="0a1b08f2698d8eaa357ae4e4639ab5964829b92d" translate="yes" xml:space="preserve">
          <source>B 4) A</source>
          <target state="translated">B 4)A</target>
        </trans-unit>
        <trans-unit id="fc28f53619db61ee68c4c2b6467d93002c47863a" translate="yes" xml:space="preserve">
          <source>B and A appears before Y in the Single Total Order</source>
          <target state="translated">B y A aparecen antes de Y en el orden total único</target>
        </trans-unit>
        <trans-unit id="403422f66cba2adadb0da593596292864fb30e29" translate="yes" xml:space="preserve">
          <source>B within thread 1 and C is</source>
          <target state="translated">B dentro del hilo 1 y C es</target>
        </trans-unit>
        <trans-unit id="4e54499211164f4b65d4e8324b3d4ca2593386d6" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order, then B observes either:</source>
          <target state="translated">B,y X aparece antes que Y en el orden total único,entonces B observa cualquiera de los dos:</target>
        </trans-unit>
        <trans-unit id="45e5662cbbb3c35284b81863cd8050953ac79093" translate="yes" xml:space="preserve">
          <source>B, and X appears before Y in the Single Total Order.</source>
          <target state="translated">B,y X aparece antes de Y en el orden total único.</target>
        </trans-unit>
        <trans-unit id="a4bf1b75c4f0c15c46e32fb9f6447c95ca649c7c" translate="yes" xml:space="preserve">
          <source>B, and both A and B are sequentially consistent atomic operations 3) A is</source>
          <target state="translated">B,y tanto A como B son operaciones atómicas secuenciales 3)A es</target>
        </trans-unit>
        <trans-unit id="f4bf2b61e8848faddd0e0998dfeaa5d79d2e597c" translate="yes" xml:space="preserve">
          <source>B, then A appears to be evaluated before B in all contexts.</source>
          <target state="translated">B,entonces A parece ser evaluado antes que B en todos los contextos.</target>
        </trans-unit>
        <trans-unit id="cd0adbaaff060b07baf50fd24c9446ab105890da" translate="yes" xml:space="preserve">
          <source>B, then A precedes B in S 2) for every pair of atomic operations A and B on an object M, where A is</source>
          <target state="translated">B,entonces A precede a B en S 2)para cada par de operaciones atómicas A y B en un objeto M,donde A es</target>
        </trans-unit>
        <trans-unit id="b23fad0d216b95f70509ee04aeb30c3631070eb7" translate="yes" xml:space="preserve">
          <source>B, then B observes one of the following:</source>
          <target state="translated">B,entonces B observa uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="bfcc02cf7f3d23e187eac12bb5d9ac766d223025" translate="yes" xml:space="preserve">
          <source>B. Stroustrup (2000), &quot;The C++ Programming Language&quot;&lt;a href=&quot;http://stroustrup.com/3rd_safe.pdf&quot;&gt;Appendix E&quot;&lt;/a&gt;</source>
          <target state="translated">B. Stroustrup (2000), &quot;El lenguaje de programaci&amp;oacute;n C ++&quot; &lt;a href=&quot;http://stroustrup.com/3rd_safe.pdf&quot;&gt;Ap&amp;eacute;ndice E &quot;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c1a4c571996703e3e33bba826b70616b63fd77ac" translate="yes" xml:space="preserve">
          <source>B...</source>
          <target state="translated">B...</target>
        </trans-unit>
        <trans-unit id="56809777eee50fda776cf36fcf8f615216fd8cfd" translate="yes" xml:space="preserve">
          <source>B: a) if A and B are both &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, then A precedes B in S b) if A is a &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operation, and B</source>
          <target state="translated">B: a) si A y B son operaciones &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , entonces A precede a B en S b) si A es una operaci&amp;oacute;n &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , y B</target>
        </trans-unit>
        <trans-unit id="90973d18393c2644dbda93e71ed88917ecac4b89" translate="yes" xml:space="preserve">
          <source>BLAS-like slice of a valarray: starting index, length, stride</source>
          <target state="translated">BLAS-como una rebanada de un valarray:índice de partida,longitud,zancada</target>
        </trans-unit>
        <trans-unit id="6909406a48bd13f476c9416147defba89909eee5" translate="yes" xml:space="preserve">
          <source>BUFSIZ</source>
          <target state="translated">BUFSIZ</target>
        </trans-unit>
        <trans-unit id="1afefdad8f394c65ed6d000a865d699a38489c6f" translate="yes" xml:space="preserve">
          <source>Bad address</source>
          <target state="translated">Mala dirección</target>
        </trans-unit>
        <trans-unit id="100269e198b12a051ab659ff66bd324a08031278" translate="yes" xml:space="preserve">
          <source>Bad file descriptor</source>
          <target state="translated">Mal descriptor de archivos</target>
        </trans-unit>
        <trans-unit id="551cd91c11cd1216214e9eb9e26d84be076f8948" translate="yes" xml:space="preserve">
          <source>Bad message</source>
          <target state="translated">Un mal mensaje</target>
        </trans-unit>
        <trans-unit id="6bda91ea312720b2ec09940e98682034dcace7af" translate="yes" xml:space="preserve">
          <source>Barebones valarray-backed Matrix class with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&quot;&gt;trace&lt;/a&gt; calculating function.</source>
          <target state="translated">Barebones clase Matrix respaldada por valarray con una funci&amp;oacute;n de c&amp;aacute;lculo de &lt;a href=&quot;https://en.wikipedia.org/wiki/Trace_(linear_algebra)&quot;&gt;trazas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="077fe9c54ed5ed26fa547f4ded3ef9a9bb066d65" translate="yes" xml:space="preserve">
          <source>Base</source>
          <target state="translated">Base</target>
        </trans-unit>
        <trans-unit id="3bcdbe728e1760eac3fdacb54d72efd9ba89bbaa" translate="yes" xml:space="preserve">
          <source>Base specifiers and member initializer lists</source>
          <target state="translated">Especificadores de base y listas de inicialización de miembros</target>
        </trans-unit>
        <trans-unit id="b1604e75055b78b9111dd5b59253504e535b02f2" translate="yes" xml:space="preserve">
          <source>Base::vf (whether or not the word &lt;code&gt;override&lt;/code&gt; is used in its declaration).</source>
          <target state="translated">Base :: vf (si la palabra &lt;code&gt;override&lt;/code&gt; se usa o no en su declaraci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="5899059fb2d20a463b2a04266836e60a1b0645c6" translate="yes" xml:space="preserve">
          <source>BaseCharacteristic</source>
          <target state="translated">BaseCharacteristic</target>
        </trans-unit>
        <trans-unit id="aa2c96dacf00c451ef465f6115a45a20bccf1256" translate="yes" xml:space="preserve">
          <source>Basic</source>
          <target state="translated">Basic</target>
        </trans-unit>
        <trans-unit id="e4e7ae591b0abd861a75d3fa39a7cab907d2a5c8" translate="yes" xml:space="preserve">
          <source>Basic concepts</source>
          <target state="translated">Conceptos básicos</target>
        </trans-unit>
        <trans-unit id="1dda37dbdb1d5ae832ec94dde2b8248f41206b6f" translate="yes" xml:space="preserve">
          <source>Basic exception guarantee</source>
          <target state="translated">Garantía de excepción básica</target>
        </trans-unit>
        <trans-unit id="beb8cd5e0f8e7a06f8d36dc83c4364f7f79078fa" translate="yes" xml:space="preserve">
          <source>Basic operations</source>
          <target state="translated">Operaciones básicas</target>
        </trans-unit>
        <trans-unit id="3fc431b29bb2c2516db706b2f480a558166eba6d" translate="yes" xml:space="preserve">
          <source>Basic types</source>
          <target state="translated">Tipos básicos</target>
        </trans-unit>
        <trans-unit id="928b9aad5c0144f195e57231e11400d2c46ac0fb" translate="yes" xml:space="preserve">
          <source>Basic types (e.g. &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;), RTTI (e.g. &lt;code&gt;&lt;a href=&quot;types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt;), type traits (e.g. &lt;code&gt;&lt;a href=&quot;types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;types/rank&quot;&gt;std::rank&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Tipos b&amp;aacute;sicos (por ejemplo, &lt;code&gt;&lt;a href=&quot;types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; ), RTTI (por ejemplo, &lt;code&gt;&lt;a href=&quot;types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; ), rasgos de tipo (por ejemplo, &lt;code&gt;&lt;a href=&quot;types/is_integral&quot;&gt;std::is_integral&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;types/rank&quot;&gt;std::rank&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5c2ef712eeb88ff3db947441935726076c82c0bb" translate="yes" xml:space="preserve">
          <source>BasicLockable</source>
          <target state="translated">BasicLockable</target>
        </trans-unit>
        <trans-unit id="90870ca4432acfd7b541273fcb2661e871119daf" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; does not consider implicit conversions, these operators cannot be used for mixed integer/complex arithmetic. In all cases, the scalar must have the same type as the underlying type of the complex number.</source>
          <target state="translated">Debido a &lt;a href=&quot;../../language/template_argument_deduction&quot;&gt;que la deducci&amp;oacute;n de argumentos de plantilla&lt;/a&gt; no considera las conversiones impl&amp;iacute;citas, estos operadores no pueden usarse para aritm&amp;eacute;tica mixta de enteros / complejos. En todos los casos, el escalar debe tener el mismo tipo que el tipo subyacente del n&amp;uacute;mero complejo.</target>
        </trans-unit>
        <trans-unit id="d1f6ad19289944156463986759f118c4be88ae5a" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; requires that the pointed-to type is a complete type in any context where the deleter is called, the destructor and the copy/move assignment operators must be user-declared and defined out-of-line, in the implementation file, where the implementation class is complete. This suppresses the move constructor, which has to be defined or defaulted.</source>
          <target state="translated">Debido a que &lt;code&gt;&lt;a href=&quot;../memory/unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&lt;/code&gt; requiere que el tipo apuntado sea un tipo completo en cualquier contexto donde se llame al eliminador, el destructor y los operadores de asignaci&amp;oacute;n de copia / movimiento deben ser declarados por el usuario y definidos fuera de l&amp;iacute;nea, en la implementaci&amp;oacute;n archivo, donde se completa la clase de implementaci&amp;oacute;n. Esto suprime el constructor de movimiento, que tiene que estar definido o predeterminado.</target>
        </trans-unit>
        <trans-unit id="ee2e8f20b5463733118ed9ad438d1e579dcd6096" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;assert&lt;/code&gt; is a &lt;a href=&quot;../preprocessor/replace&quot;&gt;function-like macro&lt;/a&gt;, commas anywhere in condition that are not protected by parentheses are interpreted as macro argument separators. Such commas are often found in template argument lists and list-initialization:</source>
          <target state="translated">Debido a que &lt;code&gt;assert&lt;/code&gt; es una &lt;a href=&quot;../preprocessor/replace&quot;&gt;macro similar a&lt;/a&gt; una funci&amp;oacute;n , las comas en cualquier lugar que no est&amp;eacute;n protegidas por par&amp;eacute;ntesis se interpretan como separadores de argumentos macro. Tales comas a menudo se encuentran en las listas de argumentos de plantilla y en la inicializaci&amp;oacute;n de listas:</target>
        </trans-unit>
        <trans-unit id="53424f213e903d21acf1145501cd3bd319bc65a2" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;regex_match&lt;/code&gt; only considers full matches, the same regex may give different matches between &lt;code&gt;regex_match&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Debido a que &lt;code&gt;regex_match&lt;/code&gt; solo considera coincidencias completas, la misma expresi&amp;oacute;n regular puede dar diferentes coincidencias entre &lt;code&gt;regex_match&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4c2c9164d9adc62f94d817ac748a2112477652ed" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;setlocale&lt;/code&gt; modifies global state which affects execution of locale-dependent functions, it is undefined behavior to call it from one thread, while another thread is executing any of the following functions: &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isprint&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;std::iswdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;std::localeconv&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::tolower&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::ispunct&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;std::iswgraph&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;std::mblen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::toupper&lt;/code&gt;, &lt;code&gt;std::isalnum&lt;/code&gt;, &lt;code&gt;std::isspace&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;std::iswlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;std::mbstowcs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;std::towlower&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isalpha&lt;/code&gt;, &lt;code&gt;std::isupper&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;std::iswprint&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;std::towupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isblank&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;std::iswalnum&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;std::iswpunct&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::setlocale&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::iscntrl&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;std::iswalpha&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;std::iswspace&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isdigit&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;std::iswblank&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;std::iswupper&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;std::wcstombs&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isgraph&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;std::iswcntrl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;std::wcsxfrm&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::islower&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;std::iswctype&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::isxdigit&lt;/code&gt;.</source>
          <target state="translated">Debido a que &lt;code&gt;setlocale&lt;/code&gt; modifica el estado global que afecta la ejecuci&amp;oacute;n de funciones dependientes de la configuraci&amp;oacute;n regional, es un comportamiento indefinido llamarlo desde un hilo, mientras que otro hilo ejecuta cualquiera de las siguientes funciones: &lt;code&gt;&lt;a href=&quot;../io/c/printf&quot;&gt;std::fprintf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isprint&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswdigit&quot;&gt;std::iswdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;localeconv&quot;&gt;std::localeconv&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::tolower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../io/c/scanf&quot;&gt;std::fscanf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::ispunct&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswgraph&quot;&gt;std::iswgraph&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mblen&quot;&gt;std::mblen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::toupper&lt;/code&gt; , &lt;code&gt;std::isalnum&lt;/code&gt; , &lt;code&gt;std::isspace&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswlower&quot;&gt;std::iswlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbstowcs&quot;&gt;std::mbstowcs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/towlower&quot;&gt;std::towlower&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isalpha&lt;/code&gt; , &lt;code&gt;std::isupper&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswprint&quot;&gt;std::iswprint&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/towupper&quot;&gt;std::towupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isblank&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalnum&quot;&gt;std::iswalnum&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswpunct&quot;&gt;std::iswpunct&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::setlocale&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::iscntrl&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswalpha&quot;&gt;std::iswalpha&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswspace&quot;&gt;std::iswspace&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isdigit&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswblank&quot;&gt;std::iswblank&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswupper&quot;&gt;std::iswupper&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strerror&quot;&gt;std::strerror&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/multibyte/wcstombs&quot;&gt;std::wcstombs&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isgraph&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswcntrl&quot;&gt;std::iswcntrl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswxdigit&quot;&gt;std::iswxdigit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/strtof&quot;&gt;std::strtod&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/wcsxfrm&quot;&gt;std::wcsxfrm&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::islower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/wide/iswctype&quot;&gt;std::iswctype&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;std::isxdigit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89d8571118516caef2a1d25c02e79eb519ae1beb" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;std::remove&lt;/code&gt; takes &lt;code&gt;value&lt;/code&gt; by reference, it can have unexpected behavior if it is a reference to an element of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Debido a que &lt;code&gt;std::remove&lt;/code&gt; toma &lt;code&gt;value&lt;/code&gt; por referencia, puede tener un comportamiento inesperado si se trata de una referencia a un elemento del rango &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20471d58e5d2833a1993c6fb0cc59d825025d821" translate="yes" xml:space="preserve">
          <source>Because C++ copies and copy-assigns objects of user-defined types in various situations (passing/returning by value, manipulating a container, etc), these special member functions will be called, if accessible, and if they are not user-defined, they are implicitly-defined by the compiler.</source>
          <target state="translated">Dado que C++copia y asigna objetos de tipos definidos por el usuario en diversas situaciones (pasar/devolver por valor,manipular un contenedor,etc.),estas funciones especiales de los miembros se llamarán,si son accesibles,y si no son definidas por el usuario,serán definidas implícitamente por el compilador.</target>
        </trans-unit>
        <trans-unit id="517acf744121042d5f84823be03eeb3b29badaed" translate="yes" xml:space="preserve">
          <source>Because C++ interprets a character immediately following a string literal as a &lt;a href=&quot;../language/user_literal&quot;&gt;user-defined string literal&lt;/a&gt;, C code such as &lt;code&gt;printf(&quot;%&quot;PRId64&quot;\n&quot;,n);&lt;/code&gt; is invalid C++ and requires a space before &lt;code&gt;PRId64&lt;/code&gt;.</source>
          <target state="translated">Debido a que C ++ interpreta un car&amp;aacute;cter que sigue inmediatamente a un literal de cadena como un &lt;a href=&quot;../language/user_literal&quot;&gt;literal de cadena definido por el usuario&lt;/a&gt; , un c&amp;oacute;digo C como &lt;code&gt;printf(&quot;%&quot;PRId64&quot;\n&quot;,n);&lt;/code&gt; es inv&amp;aacute;lido C ++ y requiere un espacio antes de &lt;code&gt;PRId64&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="219e7d89011a786888d2482ec713003b1ecb5238" translate="yes" xml:space="preserve">
          <source>Because POSIX uses &quot;leftmost longest&quot; matching rule (the longest matching subsequence is matched, and if there are several such subsequences, the first one is matched), it is not suitable, for example, for parsing markup languages: a POSIX regex such as &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; would match everything from the first &lt;code&gt;&quot;&amp;lt;tag&quot;&lt;/code&gt; to the last &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt;, including every &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; and &lt;code&gt;&quot;&amp;lt;tag&amp;gt;&quot;&lt;/code&gt; inbetween. On the other hand, ECMAScript supports non-greedy matches, and the ECMAScript regex &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*?&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; would match only until the first closing tag.</source>
          <target state="translated">Debido a que POSIX usa la regla de coincidencia &quot;m&amp;aacute;s larga m&amp;aacute;s a la izquierda&quot; (la subsecuencia de coincidencia m&amp;aacute;s larga coincide, y si hay varias subsecuencias similares, la primera coincide), no es adecuada, por ejemplo, para analizar lenguajes de marcado: una expresi&amp;oacute;n regular POSIX como &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; coincidir&amp;iacute;a con todo, desde la primera &lt;code&gt;&quot;&amp;lt;tag&quot;&lt;/code&gt; hasta la &amp;uacute;ltima &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; , incluyendo cada &lt;code&gt;&quot;&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; y &lt;code&gt;&quot;&amp;lt;tag&amp;gt;&quot;&lt;/code&gt; entre. Por otro lado, ECMAScript admite coincidencias no codiciosas, y la expresi&amp;oacute;n regular ECMAScript &lt;code&gt;&quot;&amp;lt;tag[^&amp;gt;]*&amp;gt;.*?&amp;lt;/tag&amp;gt;&quot;&lt;/code&gt; coincidir&amp;aacute; solo hasta la primera etiqueta de cierre.</target>
        </trans-unit>
        <trans-unit id="b08396994d212dfe6289df9ec245e89c348fd76a" translate="yes" xml:space="preserve">
          <source>Because a pair of brackets following the keyword &lt;code&gt;delete&lt;/code&gt; is always interpreted as the array form of delete, a lambda-expression with empty capture list immediately after &lt;code&gt;delete&lt;/code&gt; must be enclosed in parentheses.</source>
          <target state="translated">Debido a que un par de par&amp;eacute;ntesis despu&amp;eacute;s de la palabra clave &lt;code&gt;delete&lt;/code&gt; siempre se interpreta como la forma de matriz de delete, una expresi&amp;oacute;n lambda con una lista de captura vac&amp;iacute;a inmediatamente despu&amp;eacute;s de &lt;code&gt;delete&lt;/code&gt; debe encerrarse entre par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="672ca8a2390d44e9109a5b0f60fc6036a7a4d8de" translate="yes" xml:space="preserve">
          <source>Because a temporary copy of the object is constructed during post-increment and post-decrement,</source>
          <target state="translated">Porque una copia temporal del objeto se construye durante el post-incremento y el post-decrecimiento,</target>
        </trans-unit>
        <trans-unit id="52aa0f31213848ac5fabf7dcecdd2f55a132ed32" translate="yes" xml:space="preserve">
          <source>Because array elements cannot have incomplete type, multidimensional arrays cannot have unknown bound in a dimension other than the first:</source>
          <target state="translated">Debido a que los elementos de la matriz no pueden tener un tipo incompleto,las matrices multidimensionales no pueden tener un límite desconocido en una dimensión que no sea la primera:</target>
        </trans-unit>
        <trans-unit id="ebfd5a82361d89ed63a37a3062866f4e78777689" translate="yes" xml:space="preserve">
          <source>Because bit fields do not necessarily begin at the beginning of a byte, address of a bit field cannot be taken. Pointers and non-const references to bit fields are not possible. When &lt;a href=&quot;reference_initialization&quot;&gt;initializing a const reference&lt;/a&gt; from a bit field, a temporary is created (its type is the type of the bit field), copy initialized with the value of the bit field, and the reference is bound to that temporary.</source>
          <target state="translated">Debido a que los campos de bits no comienzan necesariamente al comienzo de un byte, no se puede tomar la direcci&amp;oacute;n de un campo de bits. Los punteros y las referencias no constantes a los campos de bits no son posibles. Al &lt;a href=&quot;reference_initialization&quot;&gt;inicializar una referencia constante&lt;/a&gt; desde un campo de bits, se crea un temporal (su tipo es el tipo del campo de bits), la copia inicializada con el valor del campo de bits y la referencia est&amp;aacute; vinculada a ese temporal.</target>
        </trans-unit>
        <trans-unit id="165915841c598e436e4f4ef5949ddbdf66094494" translate="yes" xml:space="preserve">
          <source>Because both &lt;code&gt;iterator&lt;/code&gt; and &lt;code&gt;const_iterator&lt;/code&gt; are constant iterators (and may in fact be the same type), it is not possible to mutate the elements of the container through an iterator returned by any of these member functions.</source>
          <target state="translated">Debido a que tanto &lt;code&gt;iterator&lt;/code&gt; y &lt;code&gt;const_iterator&lt;/code&gt; son iteradores constantes (y de hecho pueden ser del mismo tipo), no es posible mutar los elementos del recipiente a trav&amp;eacute;s de un iterador devuelto por cualquiera de estas funciones miembro.</target>
        </trans-unit>
        <trans-unit id="b5ebf1a72c58aab22e302945eaa39d0cb80ef7c4" translate="yes" xml:space="preserve">
          <source>Because comments &lt;a href=&quot;language/translation_phases&quot;&gt;are removed&lt;/a&gt; before the preprocessor stage, a macro cannot be used to form a comment and an unterminated C-style comment doesn't spill over from an #include'd file.</source>
          <target state="translated">Debido a que los comentarios &lt;a href=&quot;language/translation_phases&quot;&gt;se eliminan&lt;/a&gt; antes de la etapa de preprocesador, una macro no se puede usar para formar un comentario y un comentario de estilo C sin terminar no se derrama desde un archivo # incluido.</target>
        </trans-unit>
        <trans-unit id="8283f8b80380fa4e852889799ea8ad590ba8476b" translate="yes" xml:space="preserve">
          <source>Because condition #2 is tested before condition #3, the input line that exactly fits the buffer does not trigger failbit.</source>
          <target state="translated">Debido a que la condición #2 se prueba antes de la condición #3,la línea de entrada que encaja exactamente en el buffer no dispara el failbit.</target>
        </trans-unit>
        <trans-unit id="515369749f5f51688eb83df1f7be779be9524043" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::domain_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Debido a que copiar &lt;code&gt;std::domain_error&lt;/code&gt; no tiene permitido generar excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado. Esta es tambi&amp;eacute;n la raz&amp;oacute;n por la cual no hay ning&amp;uacute;n constructor que tome &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : de todos modos, tendr&amp;iacute;a que copiar el contenido.</target>
        </trans-unit>
        <trans-unit id="6ecb376ab21a6f256feb79f178105c51676d0d60" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::exception&lt;/code&gt; is not permitted to throw exceptions, when derived classes (such as &lt;code&gt;&lt;a href=&quot;../runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt;) have to manage a user-defined diagnostic message, it is typically implemented as a copy-on-write string.</source>
          <target state="translated">Debido a que no se permite copiar &lt;code&gt;std::exception&lt;/code&gt; para generar excepciones, cuando las clases derivadas (como &lt;code&gt;&lt;a href=&quot;../runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; ) tienen que administrar un mensaje de diagn&amp;oacute;stico definido por el usuario, generalmente se implementa como una cadena de copia en escritura.</target>
        </trans-unit>
        <trans-unit id="3da5bbc4235f4c93a80ce50bc387f0b13711c29a" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::invalid_argument&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Debido a que copiar &lt;code&gt;std::invalid_argument&lt;/code&gt; no tiene permitido generar excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado. Esta es tambi&amp;eacute;n la raz&amp;oacute;n por la cual no hay ning&amp;uacute;n constructor que tome &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : de todos modos, tendr&amp;iacute;a que copiar el contenido.</target>
        </trans-unit>
        <trans-unit id="976f924388c6dee8de713ae69d4c65520bd93b74" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::length_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Debido a que no se permite copiar &lt;code&gt;std::length_error&lt;/code&gt; excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado. Esta es tambi&amp;eacute;n la raz&amp;oacute;n por la cual no hay ning&amp;uacute;n constructor que tome &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : de todos modos, tendr&amp;iacute;a que copiar el contenido.</target>
        </trans-unit>
        <trans-unit id="d329778fe1d9574d6ed3f3facfee5d31e87476c0" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::logic_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Debido a que no se permite copiar &lt;code&gt;std::logic_error&lt;/code&gt; para generar excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado. Esta es tambi&amp;eacute;n la raz&amp;oacute;n por la cual no hay ning&amp;uacute;n constructor que tome &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : de todos modos, tendr&amp;iacute;a que copiar el contenido.</target>
        </trans-unit>
        <trans-unit id="018a393e39e3b182ca10487c347de04d186be7cb" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::out_of_range&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Debido a que no se permite copiar &lt;code&gt;std::out_of_range&lt;/code&gt; excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado. Esta es tambi&amp;eacute;n la raz&amp;oacute;n por la cual no hay ning&amp;uacute;n constructor que tome &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : de todos modos, tendr&amp;iacute;a que copiar el contenido.</target>
        </trans-unit>
        <trans-unit id="6f345edfef34a7652c4a3e8c88a8d58867553acd" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::overflow_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Debido a que copiar &lt;code&gt;std::overflow_error&lt;/code&gt; no tiene permitido generar excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado. Esta es tambi&amp;eacute;n la raz&amp;oacute;n por la cual no hay ning&amp;uacute;n constructor que tome &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : de todos modos, tendr&amp;iacute;a que copiar el contenido.</target>
        </trans-unit>
        <trans-unit id="57850b32155ea45ecb9e2f25f07c6b9ec1154de7" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::range_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Debido a que copiar &lt;code&gt;std::range_error&lt;/code&gt; no tiene permitido generar excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado. Esta es tambi&amp;eacute;n la raz&amp;oacute;n por la cual no hay ning&amp;uacute;n constructor que tome &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : de todos modos, tendr&amp;iacute;a que copiar el contenido.</target>
        </trans-unit>
        <trans-unit id="402cb452aa1c6e8357e1ec6173212b86a7d33f65" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::runtime_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Debido a que no se permite copiar &lt;code&gt;std::runtime_error&lt;/code&gt; para generar excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado. Esta es tambi&amp;eacute;n la raz&amp;oacute;n por la cual no hay ning&amp;uacute;n constructor que tome &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : de todos modos, tendr&amp;iacute;a que copiar el contenido.</target>
        </trans-unit>
        <trans-unit id="37068db94b3bf966577e4aa45601ece784efa76c" translate="yes" xml:space="preserve">
          <source>Because copying &lt;code&gt;std::underflow_error&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string. This is also why there is no constructor taking &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt;: it would have to copy the content anyway.</source>
          <target state="translated">Debido a que copiar &lt;code&gt;std::underflow_error&lt;/code&gt; no tiene permitido generar excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado. Esta es tambi&amp;eacute;n la raz&amp;oacute;n por la cual no hay ning&amp;uacute;n constructor que tome &lt;code&gt;std::string&amp;amp;&amp;amp;&lt;/code&gt; : de todos modos, tendr&amp;iacute;a que copiar el contenido.</target>
        </trans-unit>
        <trans-unit id="9379074a5072b78ee4eeef2326fa80c14b76e9c1" translate="yes" xml:space="preserve">
          <source>Because copying a standard library class derived from &lt;code&gt;std::exception&lt;/code&gt; is not permitted to throw exceptions, this message is typically stored internally as a separately-allocated reference-counted string.</source>
          <target state="translated">Debido a que no se permite copiar una clase de biblioteca est&amp;aacute;ndar derivada de &lt;code&gt;std::exception&lt;/code&gt; para generar excepciones, este mensaje generalmente se almacena internamente como una cadena contada por referencia asignada por separado.</target>
        </trans-unit>
        <trans-unit id="7ae6e0e63afdccc5b632c5cb746027af8b35d225" translate="yes" xml:space="preserve">
          <source>Because correct C++ programs are free of undefined behavior, compilers may produce unexpected results when a program that actually has UB is compiled with optimization enabled:</source>
          <target state="translated">Debido a que los programas correctos de C++no tienen un comportamiento indefinido,los compiladores pueden producir resultados inesperados cuando un programa que realmente tiene UB se compila con la optimización activada:</target>
        </trans-unit>
        <trans-unit id="4626ae145ee72ecf116829f511a5171a1ace5607" translate="yes" xml:space="preserve">
          <source>Because currency symbol is optional if &lt;code&gt;showbase&lt;/code&gt; is off but the entire multicharacter &lt;code&gt;negative_sign()&lt;/code&gt; is required, given the formatting pattern &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; with &lt;code&gt;showbase&lt;/code&gt; off and negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, the string &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; parses as &lt;code&gt;-123&lt;/code&gt; and leaves &quot;&amp;euro;&quot; unconsumed on the input stream, but if negative_sign is &lt;code&gt;&quot;()&quot;&lt;/code&gt;, the string &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; is consumed completely.</source>
          <target state="translated">Debido a que el s&amp;iacute;mbolo de moneda es opcional si &lt;code&gt;showbase&lt;/code&gt; est&amp;aacute; desactivado pero se requiere el &lt;code&gt;{sign, value, space, symbol}&lt;/code&gt; &lt;code&gt;negative_sign()&lt;/code&gt; completo de m&amp;uacute;ltiples caracteres () , dado el patr&amp;oacute;n de formato {signo, valor, espacio, s&amp;iacute;mbolo} con &lt;code&gt;showbase&lt;/code&gt; desactivado y signo negativo de &lt;code&gt;&quot;-&quot;&lt;/code&gt; , la cadena &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; analiza como &lt;code&gt;-123&lt;/code&gt; y deja &quot;&amp;euro;&quot; sin consumir en la secuencia de entrada, pero si el signo negativo es &lt;code&gt;&quot;()&quot;&lt;/code&gt; , la cadena &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; se consume por completo.</target>
        </trans-unit>
        <trans-unit id="9c7bc26a7deccd5754905307ee4096fdff25e864" translate="yes" xml:space="preserve">
          <source>Because each &lt;code&gt;std::array&amp;lt;T, N&amp;gt;&lt;/code&gt; is a fixed-size container, the value returned by &lt;code&gt;max_size&lt;/code&gt; equals &lt;code&gt;N&lt;/code&gt; (which is also the value returned by &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Debido a que cada &lt;code&gt;std::array&amp;lt;T, N&amp;gt;&lt;/code&gt; es un contenedor de tama&amp;ntilde;o fijo, el valor devuelto por &lt;code&gt;max_size&lt;/code&gt; es igual a &lt;code&gt;N&lt;/code&gt; (que tambi&amp;eacute;n es el valor devuelto por el &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d1d63aeceb4f0e5680d16d7c267971930a3bce18" translate="yes" xml:space="preserve">
          <source>Because locales and facets must be available for the IO stream objects with static storage duration, such as &lt;code&gt;&lt;a href=&quot;../../../io/cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, typical implementations let implicit default constructor zero-initialize the contents of &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; during static initialization (before constructors run for static objects), and when a facet is added to any locale for the first time, the locale completes initialization of the facet's &lt;code&gt;id&lt;/code&gt;.</source>
          <target state="translated">Debido a que los entornos locales y las facetas deben estar disponibles para los objetos de flujo de E / S con una duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico, como &lt;code&gt;&lt;a href=&quot;../../../io/cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; , las implementaciones t&amp;iacute;picas permiten que el constructor predeterminado impl&amp;iacute;cito inicialice cero el contenido de &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; durante la inicializaci&amp;oacute;n est&amp;aacute;tica (antes de que se ejecuten los constructores para objetos est&amp;aacute;ticos), y cuando se agrega una faceta a cualquier configuraci&amp;oacute;n regional por primera vez, la configuraci&amp;oacute;n regional completa la inicializaci&amp;oacute;n de la &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n de la faceta .</target>
        </trans-unit>
        <trans-unit id="bad967f19eac295089f2fac67901872b755b210a" translate="yes" xml:space="preserve">
          <source>Because most conversion specifiers first consume all consecutive whitespace, code such as.</source>
          <target state="translated">Porque la mayoría de los especificadores de conversión consumen primero todos los espacios en blanco consecutivos,código como.</target>
        </trans-unit>
        <trans-unit id="baeb5892e67350663f292930f0546a18e00a4338" translate="yes" xml:space="preserve">
          <source>Because of argument-dependent lookup, non-member functions and non-member operators defined in the same namespace as a class are considered part of the public interface of that class (if they are found through ADL) &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;adl#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;.  ADL is the reason behind the established idiom for swapping two objects in generic code:</source>
          <target state="translated">Debido a la b&amp;uacute;squeda dependiente de argumentos, las funciones no miembros y los operadores no miembros definidos en el mismo espacio de nombres que una clase se consideran parte de la interfaz p&amp;uacute;blica de esa clase (si se encuentran a trav&amp;eacute;s de ADL) &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;adl#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt; . ADL es la raz&amp;oacute;n detr&amp;aacute;s del idioma establecido para intercambiar dos objetos en c&amp;oacute;digo gen&amp;eacute;rico:</target>
        </trans-unit>
        <trans-unit id="e744698bc894ffd70f35015c02148587a2699846" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;implicit_cast&quot;&gt;array-to-pointer&lt;/a&gt; implicit conversion, pointer to the first element of an array can be initialized with an expression of array type:</source>
          <target state="translated">Debido a la conversi&amp;oacute;n impl&amp;iacute;cita de &lt;a href=&quot;implicit_cast&quot;&gt;matriz a puntero&lt;/a&gt; , el puntero al primer elemento de una matriz se puede inicializar con una expresi&amp;oacute;n de tipo de matriz:</target>
        </trans-unit>
        <trans-unit id="940a6ecf2484f5047dcbde372b969605698443fc" translate="yes" xml:space="preserve">
          <source>Because of the &lt;a href=&quot;implicit_cast&quot;&gt;derived-to-base&lt;/a&gt; implicit conversion for pointers, pointer to a base class can be initialized with the address of a derived class:</source>
          <target state="translated">Debido a la conversi&amp;oacute;n impl&amp;iacute;cita &lt;a href=&quot;implicit_cast&quot;&gt;derivada a base&lt;/a&gt; para punteros, el puntero a una clase base se puede inicializar con la direcci&amp;oacute;n de una clase derivada:</target>
        </trans-unit>
        <trans-unit id="6d22544963a037f06cda7296c1659e0c18ea6896" translate="yes" xml:space="preserve">
          <source>Because of the rule above, if initialization of some object &lt;code&gt;o1&lt;/code&gt; refers to an namespace-scope object &lt;code&gt;o2&lt;/code&gt;, which potentially requires dynamic initialization, but is defined later in the same translation unit, it is unspecified whether the value of &lt;code&gt;o2&lt;/code&gt; used will be the value of the fully initialized &lt;code&gt;o2&lt;/code&gt; (because the compiler promoted initialization of &lt;code&gt;o2&lt;/code&gt; to compile time) or will be the value of &lt;code&gt;o2&lt;/code&gt; merely zero-initialized.</source>
          <target state="translated">Debido a la regla anterior, si la inicializaci&amp;oacute;n de alg&amp;uacute;n objeto &lt;code&gt;o1&lt;/code&gt; se refiere a un objeto de alcance de espacio de nombres &lt;code&gt;o2&lt;/code&gt; , que potencialmente requiere una inicializaci&amp;oacute;n din&amp;aacute;mica, pero se define m&amp;aacute;s adelante en la misma unidad de traducci&amp;oacute;n, no se especifica si el valor de &lt;code&gt;o2&lt;/code&gt; utilizado ser&amp;aacute; el valor del &lt;code&gt;o2&lt;/code&gt; completamente inicializado (porque el compilador promovi&amp;oacute; la inicializaci&amp;oacute;n de &lt;code&gt;o2&lt;/code&gt; al tiempo de compilaci&amp;oacute;n) o ser&amp;aacute; el valor de &lt;code&gt;o2&lt;/code&gt; simplemente inicializado en cero.</target>
        </trans-unit>
        <trans-unit id="f9dfa5b6f4b206c84c88479521272aa1a77080bd" translate="yes" xml:space="preserve">
          <source>Because of the side-effects involved, built-in increment and decrement operators must be used with care to avoid undefined behavior due to violations of &lt;a href=&quot;eval_order&quot;&gt;sequencing rules&lt;/a&gt;.</source>
          <target state="translated">Debido a los efectos secundarios involucrados, los operadores incorporados de incremento y decremento deben usarse con cuidado para evitar comportamientos indefinidos debido a violaciones de las &lt;a href=&quot;eval_order&quot;&gt;reglas&lt;/a&gt; de secuenciaci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="7e487fcdc25049314ba3c1aa8b2d5bde8e083329" translate="yes" xml:space="preserve">
          <source>Because of these rules, the following function declarations declare exactly the same function:</source>
          <target state="translated">Debido a estas reglas,las siguientes declaraciones de función declaran exactamente la misma función:</target>
        </trans-unit>
        <trans-unit id="d688b7551f970383439094dc77352596d64c75aa" translate="yes" xml:space="preserve">
          <source>Because operator&amp;lt; is defined for pairs, containers of pairs can be sorted.</source>
          <target state="translated">Debido a que el operador &amp;lt;se define para pares, los contenedores de pares se pueden ordenar.</target>
        </trans-unit>
        <trans-unit id="6d70357852eee5a3977fc8f45f9558148ea3110c" translate="yes" xml:space="preserve">
          <source>Because operator&amp;lt; is defined for tuples, containers of tuples can be sorted.</source>
          <target state="translated">Debido a que el operador &amp;lt;est&amp;aacute; definido para tuplas, los contenedores de tuplas se pueden ordenar.</target>
        </trans-unit>
        <trans-unit id="9988c3b00612ee646fb4689ee722feac6456ce93" translate="yes" xml:space="preserve">
          <source>Because private data members of a class participate in its object representation, affecting size and layout, and because private member functions of a class participate in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; (which takes place before member access checking), any change to those implementation details requires recompilation of all users of the class.</source>
          <target state="translated">Debido a que los miembros de datos privados de una clase participan en su representaci&amp;oacute;n de objetos, lo que afecta el tama&amp;ntilde;o y el dise&amp;ntilde;o, y porque las funciones de miembros privados de una clase participan en la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; (que tiene lugar antes de la verificaci&amp;oacute;n de acceso de miembros), cualquier cambio en los detalles de implementaci&amp;oacute;n requiere la recopilaci&amp;oacute;n de todos usuarios de la clase.</target>
        </trans-unit>
        <trans-unit id="c3b6294e7526f54f684e9230a46827a20327483e" translate="yes" xml:space="preserve">
          <source>Because reallocation may involve bytewise copying (regardless of whether it's to expand or to contract), only the objects of &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types are safe to access in the preserved part of the memory block after a call to &lt;code&gt;realloc&lt;/code&gt;.</source>
          <target state="translated">Debido a que la reasignaci&amp;oacute;n puede implicar la copia bytewise (independientemente de si se trata de expandir o contraer), solo los objetos de los tipos &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; son seguros para acceder en la parte preservada del bloque de memoria despu&amp;eacute;s de una llamada a &lt;code&gt;realloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7a4b66b6298eef0d24f634e1a2d845ff026b299" translate="yes" xml:space="preserve">
          <source>Because references are not objects, there are no arrays of references, no pointers to references, and no references to references:</source>
          <target state="translated">Debido a que las referencias no son objetos,no hay conjuntos de referencias,ni punteros a las referencias,ni referencias a las referencias:</target>
        </trans-unit>
        <trans-unit id="f2058d826c2c292a12210fe0965fc4ca9d8da0fd" translate="yes" xml:space="preserve">
          <source>Because rvalue references can bind to xvalues, they can refer to non-temporary objects:</source>
          <target state="translated">Debido a que las referencias de valores pueden unirse a los valores x,pueden referirse a objetos no temporales:</target>
        </trans-unit>
        <trans-unit id="04759d29e77b0401f5cb7e54b5a9ccc5b0666e57" translate="yes" xml:space="preserve">
          <source>Because some assignment operator (move or copy) is always declared for any class, the base class assignment operator is always hidden. If a using-declaration is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</source>
          <target state="translated">Debido a que siempre se declara algún operador de asignación (mover o copiar)para cualquier clase,el operador de asignación de la clase base siempre se oculta.Si se utiliza una declaración de empleo para traer el operador de asignación de la clase base,y su tipo de argumento podría ser el mismo que el del operador de asignación implícito de la clase derivada,la declaración de empleo también se oculta por la declaración implícita.</target>
        </trans-unit>
        <trans-unit id="00f0a274c1ab8c40e7bb092c85aefd4a4d48b525" translate="yes" xml:space="preserve">
          <source>Because stage 2 filters out characters such as 'p', 'N' or 'i', the hexadecimal floating-point numbers such as &quot;0x1.23p-10&quot; and the strings &quot;NaN&quot; or &quot;inf&quot; may be rejected by &lt;code&gt;do_get(double)&lt;/code&gt; even if they are valid input to &lt;code&gt;strtod&lt;/code&gt;: this is &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2381&quot;&gt;LWG #2381&lt;/a&gt;.</source>
          <target state="translated">Debido a que la etapa 2 filtra caracteres como 'p', 'N' o 'i', &lt;code&gt;do_get(double)&lt;/code&gt; puede rechazar los n&amp;uacute;meros hexadecimales de coma flotante como &quot;0x1.23p-10&quot; y las cadenas &quot;NaN&quot; o &quot;inf&quot; . (doble) incluso si son entradas v&amp;aacute;lidas para &lt;code&gt;strtod&lt;/code&gt; : este es &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2381&quot;&gt;LWG # 2381&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa02ffb6258aec2d2486ffca8631f59286ef5ce5" translate="yes" xml:space="preserve">
          <source>Because the &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt; operator always returns &lt;code&gt;true&lt;/code&gt; for a constant expression, it can be used to check if a particular invocation of a constexpr function takes the constant expression branch:</source>
          <target state="translated">Debido a que el operador &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt; siempre devuelve &lt;code&gt;true&lt;/code&gt; para una expresi&amp;oacute;n constante, se puede usar para verificar si una invocaci&amp;oacute;n particular de una funci&amp;oacute;n constexpr toma la rama de expresi&amp;oacute;n constante:</target>
        </trans-unit>
        <trans-unit id="13956b893efc09b160ae84ba33c1cbb13cb7bc62" translate="yes" xml:space="preserve">
          <source>Because the C++ program terminates if a destructor throws an exception during stack unwinding (which usually cannot be predicted), all practical destructors are non-throwing even if they are not declared noexcept. All destructors found in the C++ standard library are non-throwing.</source>
          <target state="translated">Debido a que el programa C++termina si un destructor lanza una excepción durante el desenrollado de la pila (lo que normalmente no se puede predecir),todos los destructores prácticos no se lanzan aunque no se declaren como no excepcionales.Todos los destructores que se encuentran en la biblioteca estándar de C++no son lanzables.</target>
        </trans-unit>
        <trans-unit id="a4b14ea26ead34a1997c4a30b1317b3b91b17acb" translate="yes" xml:space="preserve">
          <source>Because the algorithm takes &lt;code&gt;old_value&lt;/code&gt; and &lt;code&gt;new_value&lt;/code&gt; by reference, it can have unexpected behavior if either is a reference to an element of the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Debido a que el algoritmo toma &lt;code&gt;old_value&lt;/code&gt; y &lt;code&gt;new_value&lt;/code&gt; por referencia, puede tener un comportamiento inesperado si cualquiera es una referencia a un elemento de la gama &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="265f1e5e363f13b331939f8d44a25ab55d331f5b" translate="yes" xml:space="preserve">
          <source>Because the compiler is (usually) unable to analyze the code of an external library to determine whether it does or does not perform I/O or volatile access, third-party library calls also aren't affected by optimization. However, standard library calls may be replaced by other calls, eliminated, or added to the program during optimization. Statically-linked third-party library code may be subject to link-time optimization.</source>
          <target state="translated">Dado que el compilador es (normalmente)incapaz de analizar el código de una biblioteca externa para determinar si realiza o no E/S o acceso volátil,las llamadas a bibliotecas de terceros tampoco se ven afectadas por la optimización.Sin embargo,las llamadas a las bibliotecas estándar pueden ser reemplazadas por otras llamadas,eliminadas o añadidas al programa durante la optimización.El código de biblioteca de terceros vinculado estáticamente puede estar sujeto a la optimización del tiempo de enlace.</target>
        </trans-unit>
        <trans-unit id="3f7a16168cd91eaf4c419d45869f4dbf9eb22f7c" translate="yes" xml:space="preserve">
          <source>Because the copy assignment operator is always declared for any class, the base class assignment operator is always hidden. If a &lt;a href=&quot;using_declaration#In_class_definition&quot;&gt;using-declaration&lt;/a&gt; is used to bring in the assignment operator from the base class, and its argument type could be the same as the argument type of the implicit assignment operator of the derived class, the using-declaration is also hidden by the implicit declaration.</source>
          <target state="translated">Como el operador de asignaci&amp;oacute;n de copia siempre se declara para cualquier clase, el operador de asignaci&amp;oacute;n de clase base siempre est&amp;aacute; oculto. Si se &lt;a href=&quot;using_declaration#In_class_definition&quot;&gt;usa una declaraci&amp;oacute;n de&lt;/a&gt; uso para traer el operador de asignaci&amp;oacute;n de la clase base, y su tipo de argumento podr&amp;iacute;a ser el mismo que el tipo de argumento del operador de asignaci&amp;oacute;n impl&amp;iacute;cito de la clase derivada, la declaraci&amp;oacute;n de uso tambi&amp;eacute;n est&amp;aacute; oculta por el impl&amp;iacute;cito declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4f97ab617bba2611157c1c18672811c19cf4fbf8" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static &lt;code&gt;std::any&lt;/code&gt;s are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use an object of type &lt;code&gt;std::any&lt;/code&gt; in a constructor of any static object.</source>
          <target state="translated">Debido a que el constructor predeterminado es &lt;code&gt;constexpr&lt;/code&gt; , static &lt;code&gt;std::any&lt;/code&gt; s se inicializa como parte de la inicializaci&amp;oacute;n &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;est&amp;aacute;tica no local&lt;/a&gt; , antes de que comience cualquier inicializaci&amp;oacute;n din&amp;aacute;mica no local. Esto hace que sea seguro usar un objeto de tipo &lt;code&gt;std::any&lt;/code&gt; en un constructor de cualquier objeto est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="42b540f8fad9f3f5b7e3465475a9831636bf020b" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static &lt;code&gt;weak_ptr&lt;/code&gt;s are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a weak_ptr in a constructor of any static object.</source>
          <target state="translated">Debido a que el constructor predeterminado es &lt;code&gt;constexpr&lt;/code&gt; , los &lt;code&gt;weak_ptr&lt;/code&gt; s est&amp;aacute;ticos se inicializan como parte de la inicializaci&amp;oacute;n &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;est&amp;aacute;tica no local&lt;/a&gt; , antes de que comience cualquier inicializaci&amp;oacute;n din&amp;aacute;mica no local. Esto hace que sea seguro usar un d&amp;eacute;bil_ptr en un constructor de cualquier objeto est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="fe59378ecb23670abf397ca1ed600f6c13757f88" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static mutexes are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to lock a mutex in a constructor of any static object.</source>
          <target state="translated">Debido a que el constructor predeterminado es &lt;code&gt;constexpr&lt;/code&gt; , los mutexes est&amp;aacute;ticos se inicializan como parte de &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;la inicializaci&amp;oacute;n no local est&amp;aacute;tica&lt;/a&gt; , antes de que comience cualquier inicializaci&amp;oacute;n no local din&amp;aacute;mica. Esto hace que sea seguro bloquear un mutex en un constructor de cualquier objeto est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="920e4279426f6b2bafbfaf754987ba73067a3aed" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static shared_ptrs are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a shared_ptr in a constructor of any static object.</source>
          <target state="translated">Debido a que el constructor predeterminado es &lt;code&gt;constexpr&lt;/code&gt; , los static_ptrs est&amp;aacute;ticos se inicializan como parte de &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;la inicializaci&amp;oacute;n no local est&amp;aacute;tica&lt;/a&gt; , antes de que comience cualquier inicializaci&amp;oacute;n no local din&amp;aacute;mica. Esto hace que sea seguro usar shared_ptr en un constructor de cualquier objeto est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="534359d78874e4479c30413b7cac076114495993" translate="yes" xml:space="preserve">
          <source>Because the default constructor is &lt;code&gt;constexpr&lt;/code&gt;, static unique_ptrs are initialized as part of &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;static non-local initialization&lt;/a&gt;, before any dynamic non-local initialization begins. This makes it safe to use a unique_ptr in a constructor of any static object.</source>
          <target state="translated">Como el constructor predeterminado es &lt;code&gt;constexpr&lt;/code&gt; , los static_ptrs est&amp;aacute;ticos se inicializan como parte de la inicializaci&amp;oacute;n &lt;a href=&quot;../../language/initialization#Non-local_variables&quot;&gt;est&amp;aacute;tica no local&lt;/a&gt; , antes de que comience cualquier inicializaci&amp;oacute;n din&amp;aacute;mica no local. Esto hace que sea seguro usar un unique_ptr en un constructor de cualquier objeto est&amp;aacute;tico.</target>
        </trans-unit>
        <trans-unit id="ebbf73d1f46f71b596f1282630351e427e8477a7" translate="yes" xml:space="preserve">
          <source>Because the meaning of the keyword inline for functions came to mean &quot;multiple definitions are permitted&quot; rather than &quot;inlining is preferred&quot;, that meaning was extended to variables.</source>
          <target state="translated">Dado que el significado de la palabra clave inline para las funciones pasó a significar &quot;se permiten múltiples definiciones&quot; en lugar de &quot;se prefiere el inlining&quot;,ese significado se extendió a las variables.</target>
        </trans-unit>
        <trans-unit id="006cf008ab0b4c79aa08791fcfe4af60405cca97" translate="yes" xml:space="preserve">
          <source>Because the presence of a user-defined destructor, copy-constructor, or copy-assignment operator prevents implicit definition of the &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt; and the &lt;a href=&quot;move_operator&quot;&gt;move assignment operator&lt;/a&gt;, any class for which move semantics are desirable, has to declare all five special member functions:</source>
          <target state="translated">Debido a que la presencia de un destructor, un constructor de copia o un operador de asignaci&amp;oacute;n de copia definido por el usuario impide la definici&amp;oacute;n impl&amp;iacute;cita del &lt;a href=&quot;move_constructor&quot;&gt;constructor de movimiento&lt;/a&gt; y el &lt;a href=&quot;move_operator&quot;&gt;operador de asignaci&amp;oacute;n de movimiento&lt;/a&gt; , cualquier clase para la que sea deseable la sem&amp;aacute;ntica de movimiento tiene que declarar las cinco funciones miembro especiales:</target>
        </trans-unit>
        <trans-unit id="b6dd2c080a889192fcdc9756c073e592957f9bd5" translate="yes" xml:space="preserve">
          <source>Because the short-circuiting properties of &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;operator||&lt;/code&gt; do not apply to overloads, and because types with boolean semantics are uncommon, only two standard library classes overload these operators:</source>
          <target state="translated">Debido a las propiedades de cortocircuito del &lt;code&gt;operator&amp;amp;&amp;amp;&lt;/code&gt; y el &lt;code&gt;operator||&lt;/code&gt; no se aplican a sobrecargas, y dado que los tipos con sem&amp;aacute;ntica booleana son poco comunes, solo dos clases de biblioteca est&amp;aacute;ndar sobrecargan estos operadores:</target>
        </trans-unit>
        <trans-unit id="da716a2068c8a4a0779a87e17e684144cccab8b0" translate="yes" xml:space="preserve">
          <source>Because the terminating character is counted as an extracted character, an empty input line does not trigger failbit.</source>
          <target state="translated">Debido a que el carácter de terminación se cuenta como un carácter extraído,una línea de entrada vacía no desencadena un failbit.</target>
        </trans-unit>
        <trans-unit id="4d2b809785ffb9b84788684b26543ec41eac3af8" translate="yes" xml:space="preserve">
          <source>Because these operators group left-to-right, the expression &lt;code&gt;a&amp;lt;b&amp;lt;c&lt;/code&gt; is parsed &lt;code&gt;(a&amp;lt;b)&amp;lt;c&lt;/code&gt;, and not &lt;code&gt;a&amp;lt;(b&amp;lt;c)&lt;/code&gt; or &lt;code&gt;(a&amp;lt;b)&amp;amp;&amp;amp;(b&amp;lt;c)&lt;/code&gt;.</source>
          <target state="translated">Debido a que estos operadores se agrupan de izquierda a derecha, la expresi&amp;oacute;n &lt;code&gt;a&amp;lt;b&amp;lt;c&lt;/code&gt; se analiza &lt;code&gt;(a&amp;lt;b)&amp;lt;c&lt;/code&gt; , y no &lt;code&gt;a&amp;lt;(b&amp;lt;c)&lt;/code&gt; o &lt;code&gt;(a&amp;lt;b)&amp;amp;&amp;amp;(b&amp;lt;c)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70619bda160666d212cde7b85f1f8b5a55f4c5a2" translate="yes" xml:space="preserve">
          <source>Because this function provides the automatic fall back to direct call to the destructor, the member function &lt;code&gt;destroy()&lt;/code&gt; is an optional &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirement since C++11.</source>
          <target state="translated">Debido a que esta funci&amp;oacute;n proporciona el retroceso autom&amp;aacute;tico a la llamada directa al destructor, la funci&amp;oacute;n miembro &lt;code&gt;destroy()&lt;/code&gt; es un requisito opcional de &lt;a href=&quot;../../named_req/allocator&quot;&gt;Asignaci&amp;oacute;n&lt;/a&gt; desde C ++ 11.</target>
        </trans-unit>
        <trans-unit id="7687252b20cc0d88dc4dda04b2b393cf7f223dc8" translate="yes" xml:space="preserve">
          <source>Because this function provides the automatic fall back to placement new, the member function &lt;code&gt;construct()&lt;/code&gt; is an optional &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirement since C++11.</source>
          <target state="translated">Debido a que esta funci&amp;oacute;n proporciona el retroceso autom&amp;aacute;tico a la ubicaci&amp;oacute;n nueva, la funci&amp;oacute;n miembro &lt;code&gt;construct()&lt;/code&gt; es un requisito de &lt;a href=&quot;../../named_req/allocator&quot;&gt;Asignador&lt;/a&gt; opcional desde C ++ 11.</target>
        </trans-unit>
        <trans-unit id="7f86afd7df6f8079055e111a54ab1c7b1acee01f" translate="yes" xml:space="preserve">
          <source>Because this function takes an &lt;code&gt;int&lt;/code&gt;, it cannot manipulate buffers larger than &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt; characters (&lt;a href=&quot;http://wg21.link/lwg255&quot;&gt;LWG 255&lt;/a&gt;).</source>
          <target state="translated">Debido a que esta funci&amp;oacute;n toma un &lt;code&gt;int&lt;/code&gt; , no puede manipular buffers mayores que &lt;code&gt;std::numeric_limits&amp;lt;int&amp;gt;::max()&lt;/code&gt; caracteres ( &lt;a href=&quot;http://wg21.link/lwg255&quot;&gt;LWG 255&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="96b9e8b9f2beaa29d6fe717de5892c225fc24e46" translate="yes" xml:space="preserve">
          <source>Because transfer of control is &lt;a href=&quot;goto&quot;&gt;not permitted to enter the scope&lt;/a&gt; of a variable, if a declaration statement is encountered inside the statement, it has to be scoped in its own compound statement:</source>
          <target state="translated">Debido a que &lt;a href=&quot;goto&quot;&gt;no se permite que la&lt;/a&gt; transferencia de control ingrese al alcance de una variable, si se encuentra una declaraci&amp;oacute;n de declaraci&amp;oacute;n dentro de la declaraci&amp;oacute;n, debe definirse en su propia declaraci&amp;oacute;n compuesta:</target>
        </trans-unit>
        <trans-unit id="8087588a9b0c2147f6476231103eced47874ee97" translate="yes" xml:space="preserve">
          <source>Because trigraphs are processed early, a comment such as &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; will effectively comment out the following line, and the string literal such as &lt;code&gt;&quot;Enter date ??/??/??&quot;&lt;/code&gt; is parsed as &lt;code&gt;&quot;Enter date \\??&quot;&lt;/code&gt;.</source>
          <target state="translated">Debido a que los trigrafos se procesan temprano, un comentario como &lt;code&gt;// Will the next line be executed?????/&lt;/code&gt; efectivamente comentar&amp;aacute; la siguiente l&amp;iacute;nea y el literal de cadena como &lt;code&gt;&quot;Enter date ??/??/??&quot;&lt;/code&gt; se analiza como &lt;code&gt;&quot;Enter date \\??&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48a81f0ee3ab4431a19bb6ed8bbbce0c2c607478" translate="yes" xml:space="preserve">
          <source>Because variadic parameters have the lowest rank for the purpose of &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;, they are commonly used as the catch-all fallbacks in &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;.</source>
          <target state="translated">Debido a que los par&amp;aacute;metros variables tienen el rango m&amp;aacute;s bajo con el prop&amp;oacute;sito de la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n&lt;/a&gt; de sobrecarga , se usan com&amp;uacute;nmente como las &lt;a href=&quot;sfinae&quot;&gt;trampas generales&lt;/a&gt; en SFINAE .</target>
        </trans-unit>
        <trans-unit id="3342f0b566e3613e9188ea93ab88f717f12a0f2c" translate="yes" xml:space="preserve">
          <source>Because when const member function calls a function through a non-const member pointer, the non-const overload of the implementation function is called, the pointer has to be wrapped in &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/propagate_const&quot;&gt;std::experimental::propagate_const&lt;/a&gt;&lt;/code&gt; or equivalent.</source>
          <target state="translated">Porque cuando la funci&amp;oacute;n miembro const llama a una funci&amp;oacute;n a trav&amp;eacute;s de un puntero de miembro no const, se llama a la sobrecarga no constante de la funci&amp;oacute;n de implementaci&amp;oacute;n, el puntero debe estar envuelto en &lt;code&gt;&lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/propagate_const&quot;&gt;std::experimental::propagate_const&lt;/a&gt;&lt;/code&gt; o equivalente.</target>
        </trans-unit>
        <trans-unit id="8374ae1ab38ced7f1c45fb4cad278a13b4530170" translate="yes" xml:space="preserve">
          <source>Before &lt;code&gt;std::bit_cast&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; can be used when it is needed to interpret the object representation as one of another type:</source>
          <target state="translated">Antes de &lt;code&gt;std::bit_cast&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; se puede usar cuando sea necesario para interpretar la representaci&amp;oacute;n del objeto como una de otro tipo:</target>
        </trans-unit>
        <trans-unit id="fea4659c4c01a5438272693831b7a6cf369a447e" translate="yes" xml:space="preserve">
          <source>Before C++11, floating-point exceptions were not specified, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; was required for any domain error, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; was required for overflows and implementation-defined for underflows.</source>
          <target state="translated">Antes de C ++ 11, no se especificaban excepciones de punto flotante, se requer&amp;iacute;a &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;EDOM&lt;/a&gt;&lt;/code&gt; para cualquier error de dominio, &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; se requer&amp;iacute;a para desbordamientos e implementaci&amp;oacute;n definida para desbordamientos.</target>
        </trans-unit>
        <trans-unit id="8315db453a2a5506755072ec6a7820d4232e1cea" translate="yes" xml:space="preserve">
          <source>Before a call to &lt;code&gt;str()&lt;/code&gt; that uses the result as a C string, the stream buffer must be null-terminated. Regular output such as with &lt;code&gt;stream &amp;lt;&amp;lt; 1.2&lt;/code&gt; does not store a null terminator, it must be appended explicitly, typically with the manipulator &lt;code&gt;&lt;a href=&quot;../manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Antes de una llamada a &lt;code&gt;str()&lt;/code&gt; que usa el resultado como una cadena C, el b&amp;uacute;fer de flujo debe estar terminado en nulo. La salida regular, como con la &lt;code&gt;stream &amp;lt;&amp;lt; 1.2&lt;/code&gt; , no almacena un terminador nulo, debe agregarse expl&amp;iacute;citamente, normalmente con el manipulador &lt;code&gt;&lt;a href=&quot;../manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94bcd5b8d87a105ad9ebe672411a4e5e7749b2c" translate="yes" xml:space="preserve">
          <source>Before any call to &lt;code&gt;str()&lt;/code&gt; that uses the result as a C string, the buffer must be null-terminated, typically with &lt;code&gt;&lt;a href=&quot;manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Antes de cualquier llamada a &lt;code&gt;str()&lt;/code&gt; que use el resultado como una cadena en C, el b&amp;uacute;fer debe tener terminaci&amp;oacute;n nula, generalmente con &lt;code&gt;&lt;a href=&quot;manip/ends&quot;&gt;std::ends&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c35792e95cf3b07cb316904dfad082217f59a440" translate="yes" xml:space="preserve">
          <source>Before any catch clauses of a function-try-block on a constructor are entered, all fully-constructed members and bases have already been destroyed.</source>
          <target state="translated">Antes de que se introduzcan las cláusulas de captura de una función-trato-bloqueo en un constructor,todos los miembros y bases completamente construidos ya han sido destruidos.</target>
        </trans-unit>
        <trans-unit id="d25af084b2d0cf872bc310ddc2b32c2b646e23c4" translate="yes" xml:space="preserve">
          <source>Before any catch clauses of a function-try-block on a destructor are entered, all bases and non-variant members have already been destroyed.</source>
          <target state="translated">Antes de que se introduzcan las cláusulas de captura de una función-trato-bloqueo en un destructor,todas las bases y miembros no-variantes ya han sido destruidos.</target>
        </trans-unit>
        <trans-unit id="73e853eca15162afc8c02a1bedca567760609d5c" translate="yes" xml:space="preserve">
          <source>Before any further analysis, constraints are &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;normalized&lt;/a&gt; by substituting the body of every name concept and every requires expression until what is left is a sequence of conjunctions and disjunctions on atomic constraints.</source>
          <target state="translated">Antes de cualquier an&amp;aacute;lisis posterior, las restricciones se &lt;a href=&quot;constraints#Constraint_normalization&quot;&gt;normalizan&lt;/a&gt; sustituyendo el cuerpo de cada concepto de nombre y cada uno requiere expresi&amp;oacute;n hasta que lo que queda es una secuencia de conjunciones y disyunciones en restricciones at&amp;oacute;micas.</target>
        </trans-unit>
        <trans-unit id="6aa106196ee396275230e60cf51ed929654bbc97" translate="yes" xml:space="preserve">
          <source>Before any of the member functions would yield undefined results, calls callbacks, registered by &lt;a href=&quot;register_callback&quot;&gt;&lt;code&gt;register_callback()&lt;/code&gt;&lt;/a&gt; passing &lt;a href=&quot;event&quot;&gt;&lt;code&gt;erase_event&lt;/code&gt;&lt;/a&gt; as parameter.</source>
          <target state="translated">Antes de que cualquiera de las funciones miembro produzca resultados indefinidos, las devoluciones de llamada, registradas por &lt;a href=&quot;register_callback&quot;&gt; &lt;code&gt;register_callback()&lt;/code&gt; &lt;/a&gt; pasan &lt;a href=&quot;event&quot;&gt; &lt;code&gt;erase_event&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="32981297d13de998df78a59af43e17581b0c92e7" translate="yes" xml:space="preserve">
          <source>Before class template argument deduction was introduced, a common approach to avoiding explicitly specifying arguments is to use a function template:</source>
          <target state="translated">Antes de que se introdujera la deducción de los argumentos de la plantilla de clases,un enfoque común para evitar especificar explícitamente los argumentos es utilizar una plantilla de funciones:</target>
        </trans-unit>
        <trans-unit id="448996df8021b850305d2f1a744547e3fb5a961d" translate="yes" xml:space="preserve">
          <source>Before deduction begins, the following adjustments to &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are made:</source>
          <target state="translated">Antes de que comience la deducci&amp;oacute;n, se realizan los siguientes ajustes a &lt;code&gt;P&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ec06b6296ed6cd7c8b9af0261c5f6873359d381f" translate="yes" xml:space="preserve">
          <source>Before doing anything else, &lt;code&gt;seekg&lt;/code&gt; clears &lt;code&gt;eofbit&lt;/code&gt;.</source>
          <target state="translated">Antes de hacer cualquier otra cosa, &lt;code&gt;seekg&lt;/code&gt; borra &lt;code&gt;eofbit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7de5fab850d46a3b252876719b32d89d2a9ae789" translate="yes" xml:space="preserve">
          <source>Before insertion, first, all characters are widened using &lt;code&gt;os.widen()&lt;/code&gt;, then padding is determined as follows: if the number of characters to insert is less than &lt;code&gt;os.width()&lt;/code&gt;, then enough copies of &lt;code&gt;os.fill()&lt;/code&gt; are added to the character sequence to make its length equal &lt;code&gt;os.width()&lt;/code&gt;. If &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, the fill characters are added at the end of the output sequence, otherwise they are added before the output sequence. After insertion, &lt;code&gt;width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.  The behavior is undefined if &lt;code&gt;s&lt;/code&gt; is a null pointer.</source>
          <target state="translated">Antes de la inserci&amp;oacute;n, en primer lugar, todos los caracteres se ensanchan utilizando &lt;code&gt;os.widen()&lt;/code&gt; , a continuaci&amp;oacute;n, el relleno se determina como sigue: si el n&amp;uacute;mero de caracteres para insertar es menor que &lt;code&gt;os.width()&lt;/code&gt; , entonces suficientes copias de &lt;code&gt;os.fill()&lt;/code&gt; se a&amp;ntilde;aden a la secuencia de caracteres para que su longitud sea igual a &lt;code&gt;os.width()&lt;/code&gt; . Si &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; , los caracteres de relleno se agregan al final de la secuencia de salida, de lo contrario se agregan antes de la secuencia de salida. Despu&amp;eacute;s de la inserci&amp;oacute;n, se llama al &lt;code&gt;width(0)&lt;/code&gt; para cancelar los efectos de &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , si corresponde. El comportamiento no est&amp;aacute; definido si &lt;code&gt;s&lt;/code&gt; es un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="66a732adfdd2f159eb6ed563c85a4950c2ff838b" translate="yes" xml:space="preserve">
          <source>Before modified element(s)</source>
          <target state="translated">Antes de los elementos modificados</target>
        </trans-unit>
        <trans-unit id="d97a4012796ad8947371e2ae9f789d3c201395de" translate="yes" xml:space="preserve">
          <source>Before name lookup can be performed for the name on the right hand side of &lt;code&gt;::&lt;/code&gt;, lookup must be completed for the name on its left hand side (unless a &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; expression is used, or there is nothing on the left). This lookup, which may be qualified or unqualified, depending on whether there's another &lt;code&gt;::&lt;/code&gt; to the left of that name, considers only namespaces, class types, enumerations, and templates whose specializations are types:</source>
          <target state="translated">Antes de que se pueda realizar una b&amp;uacute;squeda de nombre para el nombre en el lado derecho de &lt;code&gt;::&lt;/code&gt; , se debe completar la b&amp;uacute;squeda para el nombre en su lado izquierdo (a menos que se &lt;a href=&quot;decltype&quot;&gt;use&lt;/a&gt; una expresi&amp;oacute;n decltype o no haya nada a la izquierda). Esta b&amp;uacute;squeda, que puede ser calificada o no, dependiendo de si hay otro &lt;code&gt;::&lt;/code&gt; a la izquierda de ese nombre, considera solo espacios de nombres, tipos de clase, enumeraciones y plantillas cuyas especializaciones son tipos:</target>
        </trans-unit>
        <trans-unit id="82707517c83290ff1d38dc49904b3bfd7e902adb" translate="yes" xml:space="preserve">
          <source>Before overload resolution begins, the functions selected by name lookup and template argument deduction are combined to form the set of</source>
          <target state="translated">Antes de que comience la resolución de la sobrecarga,las funciones seleccionadas por la búsqueda del nombre y la deducción del argumento de la plantilla se combinan para formar el conjunto de</target>
        </trans-unit>
        <trans-unit id="ff5ff5557a213e5cbabe46f3d7e81258ac04a845" translate="yes" xml:space="preserve">
          <source>Before the compound statement that forms the function body of the constructor begins executing, initialization of all direct bases, virtual bases, and non-static data members is finished. Member initializer list is the place where non-default initialization of these objects can be specified. For members that cannot be default-initialized, such as members of reference and const-qualified types, member initializers must be specified. No initialization is performed for &lt;a href=&quot;union#Anonymous_unions&quot;&gt;anonymous unions&lt;/a&gt; or &lt;a href=&quot;union#Union-like_class&quot;&gt;variant members&lt;/a&gt; that do not have a member initializer.</source>
          <target state="translated">Antes de que la declaraci&amp;oacute;n compuesta que forma el cuerpo de la funci&amp;oacute;n del constructor comience a ejecutarse, finaliza la inicializaci&amp;oacute;n de todas las bases directas, bases virtuales y miembros de datos no est&amp;aacute;ticos. La lista de inicializador de miembros es el lugar donde se puede especificar la inicializaci&amp;oacute;n no predeterminada de estos objetos. Para los miembros que no se pueden inicializar por defecto, como los miembros de referencia y los tipos const, se deben especificar los inicializadores de miembros. No se realiza la inicializaci&amp;oacute;n para &lt;a href=&quot;union#Anonymous_unions&quot;&gt;uniones an&amp;oacute;nimas&lt;/a&gt; o &lt;a href=&quot;union#Union-like_class&quot;&gt;miembros variantes&lt;/a&gt; que no tienen un inicializador de miembro.</target>
        </trans-unit>
        <trans-unit id="c0c425b7763137b46eb294c01dcbca3225e7768a" translate="yes" xml:space="preserve">
          <source>Before the lifetime of an object has started but after the storage which the object will occupy has been allocated or, after the lifetime of an object has ended and before the storage which the object occupied is reused or released, the following uses of the glvalue expression that identifies that object are undefined:</source>
          <target state="translated">Antes de que comience la vida útil de un objeto,pero después de que se haya asignado el almacenamiento que ocupará el objeto o,después de que haya terminado la vida útil de un objeto y antes de que se reutilice o se libere el almacenamiento que ocupó el objeto,no se definen los siguientes usos de la expresión glvalue que identifica a ese objeto:</target>
        </trans-unit>
        <trans-unit id="01ee3728daf49b9887894e9051143ca70683a003" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object,</source>
          <target state="translated">Se comporta como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , excepto que &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; no se ve afectado. Despu&amp;eacute;s de construir y verificar el objeto centinela,</target>
        </trans-unit>
        <trans-unit id="afa456ec56112ff3b6b761bd5b74f63ce75d28ec" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; is not affected. After constructing and checking the sentry object, if &lt;code&gt;fail() == true&lt;/code&gt;, returns &lt;code&gt;pos_type(-1)&lt;/code&gt;. Otherwise, returns &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">Se comporta como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , excepto que &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; no se ve afectado. Despu&amp;eacute;s de construir y verificar el objeto centinela, si &lt;code&gt;fail() == true&lt;/code&gt; , devuelve &lt;code&gt;pos_type(-1)&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;rdbuf()-&amp;gt;pubseekoff(0, &lt;a href=&quot;../ios_base/seekdir&quot;&gt;std::ios_base::cur&lt;/a&gt;, &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::in&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a77bac3067d3940c6b684599ba369eb392602c9" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object,</source>
          <target state="translated">Se comporta como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela,</target>
        </trans-unit>
        <trans-unit id="9678066f0a18b755a7a83de41a67b8f539cf21e5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, extracts characters and stores them into successive locations of the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. Characters are extracted and stored until any of the following conditions occurs:</source>
          <target state="translated">Se comporta como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, extrae los caracteres y los almacena en ubicaciones sucesivas de la matriz de caracteres cuyo primer elemento se&amp;ntilde;ala &lt;code&gt;s&lt;/code&gt; . Los caracteres se extraen y almacenan hasta que se produce cualquiera de las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="5452e2d70444e38dce8d1658572b189b3491c062" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, extracts characters from &lt;code&gt;*this&lt;/code&gt; and stores them in successive locations of the array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;, until any of the following occurs (tested in the order shown):</source>
          <target state="translated">Se comporta como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, extrae los caracteres de &lt;code&gt;*this&lt;/code&gt; y los almacena en ubicaciones sucesivas de la matriz cuyo primer elemento es se&amp;ntilde;alado por &lt;code&gt;s&lt;/code&gt; , hasta que ocurra algo de lo siguiente (probado en el orden mostrado):</target>
        </trans-unit>
        <trans-unit id="2ce9bf750568029bd6c252857e382b90c6756ee0" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and testing the sentry object, reads the next character from the input stream without extracting it.</source>
          <target state="translated">Se comporta como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . Despu&amp;eacute;s de construir y probar el objeto centinela, lee el siguiente car&amp;aacute;cter de la secuencia de entrada sin extraerlo.</target>
        </trans-unit>
        <trans-unit id="0749de46c88cb22f7c4409a2cfcef6bf1f8046f6" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt; (except without actually performing output). After constructing and checking the sentry object,</source>
          <target state="translated">Se comporta como &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt; (excepto sin realizar realmente la salida). Despu&amp;eacute;s de construir y verificar el objeto centinela,</target>
        </trans-unit>
        <trans-unit id="4672c00972c0e6a7e7c5cce22e6b19b90240fb04" translate="yes" xml:space="preserve">
          <source>Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, determines the output format padding as follows:</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;salida formateada&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, determina el relleno del formato de salida de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="fd13a34bc371a84520ebfd6305bba27395aa1de8" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;is.gcount()&lt;/code&gt; is not modified. After constructing and checking the sentry object, extracts characters from the stream and discards them until any one of the following conditions occurs:</source>
          <target state="translated">Se comporta como un &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , excepto que &lt;code&gt;is.gcount()&lt;/code&gt; no se modifica. Despu&amp;eacute;s de construir y verificar el objeto centinela, extrae los caracteres de la secuencia y los descarta hasta que ocurra cualquiera de las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="fb87348382a678ef761dc7c93eddfa49c60fd167" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;d&lt;/code&gt; is not modified.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de entrada no &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;formateada&lt;/a&gt; , excepto que tiene un efecto no especificado en &lt;code&gt;is.gcount()&lt;/code&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;d&lt;/code&gt; e acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; . Si el an&amp;aacute;lisis no puede decodificar un &lt;code&gt;day&lt;/code&gt; v&amp;aacute;lido , se &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; y &lt;code&gt;d&lt;/code&gt; no se modifica.</target>
        </trans-unit>
        <trans-unit id="1fa65d008ed7c245aef54a0ea0b67364379c951b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;d&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;duration&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;d&lt;/code&gt; is not modified.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de entrada no &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;formateada&lt;/a&gt; , excepto que tiene un efecto no especificado en &lt;code&gt;is.gcount()&lt;/code&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;d&lt;/code&gt; e acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; . Si el an&amp;aacute;lisis no puede decodificar una &lt;code&gt;duration&lt;/code&gt; v&amp;aacute;lida , se &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; y &lt;code&gt;d&lt;/code&gt; no se modifica.</target>
        </trans-unit>
        <trans-unit id="d2831b6a6c206e8d8a233d91bfdec888a2de732b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;m&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;month&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;m&lt;/code&gt; is not modified.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de entrada no &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;formateada&lt;/a&gt; , excepto que tiene un efecto no especificado en &lt;code&gt;is.gcount()&lt;/code&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;m&lt;/code&gt; de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; . Si el an&amp;aacute;lisis no puede decodificar un &lt;code&gt;month&lt;/code&gt; v&amp;aacute;lido , se &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; y &lt;code&gt;m&lt;/code&gt; no se modifica.</target>
        </trans-unit>
        <trans-unit id="faffa23b913d2432b4e5d59afb1027604b07f00e" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;md&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;month_day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;md&lt;/code&gt; is not modified.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de entrada no &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;formateada&lt;/a&gt; , excepto que tiene un efecto no especificado en &lt;code&gt;is.gcount()&lt;/code&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;md&lt;/code&gt; de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; . Si el an&amp;aacute;lisis no puede decodificar un &lt;code&gt;month_day&lt;/code&gt; v&amp;aacute;lido , se &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; y no se modifica &lt;code&gt;md&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e065fe398d7803bd86c6a7e26d51804b3b96c6b0" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;tp&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid time point, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;tp&lt;/code&gt; is not modified.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de entrada no &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;formateada&lt;/a&gt; , excepto que tiene un efecto no especificado en &lt;code&gt;is.gcount()&lt;/code&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;tp&lt;/code&gt; de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; . Si el an&amp;aacute;lisis no puede decodificar un punto de tiempo v&amp;aacute;lido, se &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; y no se modifica &lt;code&gt;tp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e916f1ce3a09969712030a89b921f22ad91cde6" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;wd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;weekday&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;wd&lt;/code&gt; is not modified.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de entrada no &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;formateada&lt;/a&gt; , excepto que tiene un efecto no especificado en &lt;code&gt;is.gcount()&lt;/code&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;wd&lt;/code&gt; de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; . Si el an&amp;aacute;lisis no puede decodificar un &lt;code&gt;weekday&lt;/code&gt; v&amp;aacute;lido , se &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; y no se modifica &lt;code&gt;wd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="534f077e6bac2d7fcd7ec6bfbd2ce8a229d9e671" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;y&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;y&lt;/code&gt; is not modified.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de entrada no &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;formateada&lt;/a&gt; , excepto que tiene un efecto no especificado en &lt;code&gt;is.gcount()&lt;/code&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;y&lt;/code&gt; de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; . Si el an&amp;aacute;lisis sint&amp;aacute;ctico no logra decodificar un v&amp;aacute;lido &lt;code&gt;year&lt;/code&gt; , &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; se llama y &lt;code&gt;y&lt;/code&gt; no se modifica.</target>
        </trans-unit>
        <trans-unit id="9d1a3df7d8a7fca81ecb344ddc22950a523c840e" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;ym&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year_month&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;ym&lt;/code&gt; is not modified.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de entrada no &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;formateada&lt;/a&gt; , excepto que tiene un efecto no especificado en &lt;code&gt;is.gcount()&lt;/code&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;ym&lt;/code&gt; de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; . Si el an&amp;aacute;lisis no puede decodificar un &lt;code&gt;year_month&lt;/code&gt; v&amp;aacute;lido , se &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; y no se modifica &lt;code&gt;ym&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="354ffd6415a45c8148f6d721a7550f4e07921a44" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that it has an unspecified effect on &lt;code&gt;is.gcount()&lt;/code&gt;. After constructing and checking the sentry object, attempts to parse the input stream &lt;code&gt;is&lt;/code&gt; into &lt;code&gt;ymd&lt;/code&gt; according to the format string &lt;code&gt;fmt&lt;/code&gt;. If the parse fails to decode a valid &lt;code&gt;year_month_day&lt;/code&gt;, &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; is called and &lt;code&gt;ymd&lt;/code&gt; is not modified.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de entrada no &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;formateada&lt;/a&gt; , excepto que tiene un efecto no especificado en &lt;code&gt;is.gcount()&lt;/code&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, los intentos de analizar el flujo de entrada &lt;code&gt;is&lt;/code&gt; en &lt;code&gt;ymd&lt;/code&gt; de acuerdo con la cadena de formato &lt;code&gt;fmt&lt;/code&gt; . Si el an&amp;aacute;lisis no puede decodificar un &lt;code&gt;year_month_day&lt;/code&gt; v&amp;aacute;lido , se &lt;code&gt;is.setstate(&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;)&lt;/code&gt; y no se modifica &lt;code&gt;ymd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b31240671d71f38c08c6175c2a624c5485aa3e4b" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, outputs the characters from successive locations in the character array whose first element is pointed to by &lt;code&gt;s&lt;/code&gt;. Characters are inserted into the output sequence until one of the following occurs:</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;salida sin formato&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, genera los caracteres de ubicaciones sucesivas en la matriz de caracteres cuyo primer elemento se&amp;ntilde;ala &lt;code&gt;s&lt;/code&gt; . Los caracteres se insertan en la secuencia de salida hasta que ocurre uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="420d1377b9bbd844155a88eb257414b14d2edd8c" translate="yes" xml:space="preserve">
          <source>Behaves as an &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;UnformattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, writes the character &lt;code&gt;ch&lt;/code&gt; to the output stream.</source>
          <target state="translated">Se comporta como una funci&amp;oacute;n de &lt;a href=&quot;../../named_req/unformattedoutputfunction&quot;&gt;salida sin formato&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, escribe el car&amp;aacute;cter &lt;code&gt;ch&lt;/code&gt; en la secuencia de salida.</target>
        </trans-unit>
        <trans-unit id="82ff397227b9a7ad0f8b7b725088913fce6ee471" translate="yes" xml:space="preserve">
          <source>Behaves as an atomic operation.</source>
          <target state="translated">Se comporta como una operación atómica.</target>
        </trans-unit>
        <trans-unit id="b9dc5d13ce0d39d79ca5f8d6c575a41f58014821" translate="yes" xml:space="preserve">
          <source>Behaves as if applying &lt;code&gt;&lt;a href=&quot;iter_swap&quot;&gt;std::iter_swap&lt;/a&gt;&lt;/code&gt; to every pair of iterators &lt;code&gt;first+i, (last-i) - 1&lt;/code&gt; for each non-negative &lt;code&gt;i &amp;lt; (last-first)/2&lt;/code&gt;</source>
          <target state="translated">Se comporta como si aplicara &lt;code&gt;&lt;a href=&quot;iter_swap&quot;&gt;std::iter_swap&lt;/a&gt;&lt;/code&gt; a cada par de iteradores &lt;code&gt;first+i, (last-i) - 1&lt;/code&gt; por cada no negativo &lt;code&gt;i &amp;lt; (last-first)/2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bed410844ec9fd5b13e393d20c755ef0b8dfbf2d" translate="yes" xml:space="preserve">
          <source>Behaves as if by executing the assignment &lt;code&gt;*(d_first + (last - first) - 1 - i) = *(first + i)&lt;/code&gt; once for each non-negative &lt;code&gt;i &amp;lt; (last - first)&lt;/code&gt;</source>
          <target state="translated">Se comporta como si ejecutara la asignaci&amp;oacute;n &lt;code&gt;*(d_first + (last - first) - 1 - i) = *(first + i)&lt;/code&gt; una vez para cada no negativo &lt;code&gt;i &amp;lt; (last - first)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c2095bbba3a93f2559c0792b761c684cd2ef1312" translate="yes" xml:space="preserve">
          <source>Behaves as if it forms a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt;&lt;code&gt;str&lt;/code&gt; initially consisting of the characters in &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;(d.count())&lt;/code&gt; (if &lt;code&gt;CharT&lt;/code&gt; is &lt;code&gt;char&lt;/code&gt;) or &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;(d.count())&lt;/code&gt; (if &lt;code&gt;CharT&lt;/code&gt; is &lt;code&gt;wchar_t&lt;/code&gt;). Appends to &lt;code&gt;str&lt;/code&gt; a suffix based on &lt;code&gt;Period::type&lt;/code&gt; according to the following table, and inserts &lt;code&gt;str&lt;/code&gt; into the stream with &lt;code&gt;os &amp;lt;&amp;lt; str;&lt;/code&gt;.</source>
          <target state="translated">Se comporta como si forma una &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; &lt;code&gt;str&lt;/code&gt; inicialmente que consiste en los caracteres en &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_string&quot;&gt;std::to_string&lt;/a&gt;(d.count())&lt;/code&gt; (si &lt;code&gt;CharT&lt;/code&gt; es &lt;code&gt;char&lt;/code&gt; ) o &lt;code&gt;&lt;a href=&quot;../../string/basic_string/to_wstring&quot;&gt;std::to_wstring&lt;/a&gt;(d.count())&lt;/code&gt; (si &lt;code&gt;CharT&lt;/code&gt; es &lt;code&gt;wchar_t&lt;/code&gt; ). Agrega a &lt;code&gt;str&lt;/code&gt; un sufijo basado en &lt;code&gt;Period::type&lt;/code&gt; acuerdo con la siguiente tabla, e inserta &lt;code&gt;str&lt;/code&gt; en la secuencia con &lt;code&gt;os &amp;lt;&amp;lt; str;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ba1f2a3eb212b1fa99c5e19994960cbf5cc4c56" translate="yes" xml:space="preserve">
          <source>Behaves like the &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;, except that if &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; succeeds (does not return &lt;code&gt;Traits::eof()&lt;/code&gt;), then advances the next pointer for the get area. In other words, consumes one of the characters obtained by &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se comporta como &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; , excepto que si &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; tiene &amp;eacute;xito (no devuelve &lt;code&gt;Traits::eof()&lt;/code&gt; ), entonces avanza el siguiente puntero para el &amp;aacute;rea get. En otras palabras, consume uno de los caracteres obtenidos por &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7424443eb2a5187f8df088d1e24d7b153e76c40" translate="yes" xml:space="preserve">
          <source>Behaves like the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;std::basic_streambuf::overflow&lt;/a&gt;&lt;/code&gt;, except that to write the data, first uses &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; of the imbued locale to convert the characters into external (possibly multibyte) representation, stored in a temporary buffer (allocated as large as necessary), then uses file I/O to copy all fully-converted bytes into the file.</source>
          <target state="translated">Se comporta como la clase base &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;std::basic_streambuf::overflow&lt;/a&gt;&lt;/code&gt; , excepto que para escribir los datos, primero usa &lt;code&gt;&lt;a href=&quot;../../locale/codecvt/out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; del entorno local imbuido para convertir los caracteres en representaci&amp;oacute;n externa (posiblemente multibyte), almacenada en un b&amp;uacute;fer temporal (asignado tan grande como sea necesario), luego usa la E / S de archivo para copiar todos los bytes convertidos completamente en el archivo.</target>
        </trans-unit>
        <trans-unit id="ead68b316b3a5bb13de60a50d4b049c735bc0457" translate="yes" xml:space="preserve">
          <source>Behaves like the base class &lt;code&gt;std::basic_streambuf::underflow&lt;/code&gt;, except that to read the data from the associated character sequence (the file) into the get area, first reads the bytes from the file into a temporary buffer (allocated as large as necessary), then uses &lt;code&gt;std::codecvt::in&lt;/code&gt; of the imbued locale to convert the external (typically, multibyte) representation to the internal form which is then used to populate the get area. The conversion may be skipped if the locale's &lt;code&gt;std::codecvt::always_noconv&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Se comporta como la clase base &lt;code&gt;std::basic_streambuf::underflow&lt;/code&gt; , excepto que para leer los datos de la secuencia de caracteres asociada (el archivo) en el &amp;aacute;rea de obtenci&amp;oacute;n, primero lee los bytes del archivo en un b&amp;uacute;fer temporal (asignado tan grande como sea necesario) ), luego usa &lt;code&gt;std::codecvt::in&lt;/code&gt; del entorno local imbuido para convertir la representaci&amp;oacute;n externa (t&amp;iacute;picamente, multibyte) en la forma interna que luego se usa para llenar el &amp;aacute;rea de obtenci&amp;oacute;n. La conversi&amp;oacute;n se puede omitir si &lt;code&gt;std::codecvt::always_noconv&lt;/code&gt; la configuraci&amp;oacute;n regional devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8144558f99cdff249c2ee868ada81e832e47eeb4" translate="yes" xml:space="preserve">
          <source>Behavior as published</source>
          <target state="translated">Comportamiento según lo publicado</target>
        </trans-unit>
        <trans-unit id="3b4de82624ef063c5570a0aa0bb2fd68f2dc6163" translate="yes" xml:space="preserve">
          <source>Bernoulli distributions</source>
          <target state="translated">Distribuciones Bernoulli</target>
        </trans-unit>
        <trans-unit id="1e5ebe6f1289f29133bcd6572d2c2241857b3a1a" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;operator_other&quot;&gt;function-call expressions&lt;/a&gt;, where &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; takes place, the name of an overloaded function may appear in the following 7 contexts:</source>
          <target state="translated">Adem&amp;aacute;s &lt;a href=&quot;operator_other&quot;&gt;de las expresiones de llamada a funciones&lt;/a&gt; , donde tiene lugar la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; , el nombre de una funci&amp;oacute;n sobrecargada puede aparecer en los siguientes 7 contextos:</target>
        </trans-unit>
        <trans-unit id="35a9468290c3394c97c047fe437a550a62007c54" translate="yes" xml:space="preserve">
          <source>Besides commenting out, other mechanisms used for source code exclusion are.</source>
          <target state="translated">Además de los comentarios,otros mecanismos utilizados para la exclusión del código fuente son.</target>
        </trans-unit>
        <trans-unit id="03958a7c9ad1213ec526869eb4c84b20e58f0961" translate="yes" xml:space="preserve">
          <source>Besides establishing new parse state and position, a call to this function undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file state, if it is set.</source>
          <target state="translated">Adem&amp;aacute;s de establecer un nuevo estado y posici&amp;oacute;n de an&amp;aacute;lisis, una llamada a esta funci&amp;oacute;n deshace los efectos de &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; y borra el estado de fin de archivo, si est&amp;aacute; configurado.</target>
        </trans-unit>
        <trans-unit id="cde31df5b3a6edf2b668225ad16ccbe6298bf72e" translate="yes" xml:space="preserve">
          <source>Besides function calls and operator expressions, template argument deduction is used in the following situations:</source>
          <target state="translated">Además de las llamadas a funciones y las expresiones de los operadores,la deducción de los argumentos de la plantilla se utiliza en las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="1ea3de9ed1aa39d9d12037783bc2af648287a89b" translate="yes" xml:space="preserve">
          <source>Besides function lvalues, the function call expression supports pointers to functions, dereferenced pointers to member functions, &lt;a href=&quot;lambda&quot;&gt;lambda-expressions&lt;/a&gt;, and any variable of class type that overloads the function-call operator. Together, these types are known as &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObjects&lt;/a&gt;, and they are used ubiquitously through the C++ standard library, see for example, usages of &lt;a href=&quot;../named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; and &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de los valores de funci&amp;oacute;n, la expresi&amp;oacute;n de llamada de funci&amp;oacute;n admite punteros a funciones, punteros desreferenciados a funciones miembro, &lt;a href=&quot;lambda&quot;&gt;expresiones lambda&lt;/a&gt; y cualquier variable de tipo de clase que sobrecargue el operador de llamada de funci&amp;oacute;n. Juntos, estos tipos se conocen como &lt;a href=&quot;../named_req/functionobject&quot;&gt;FunctionObjects&lt;/a&gt; , y se usan de forma ubicua a trav&amp;eacute;s de la biblioteca est&amp;aacute;ndar de C ++; consulte, por ejemplo, los usos de &lt;a href=&quot;../named_req/binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; y &lt;a href=&quot;../named_req/compare&quot;&gt;Compare&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eadda9e8c93ae861b29d0afee13d836c6af0e0f7" translate="yes" xml:space="preserve">
          <source>Besides introducing the new exception template &lt;a href=&quot;../error/tx_exception&quot;&gt;&lt;code&gt;std::tx_exception&lt;/code&gt;&lt;/a&gt;, the transactional memory technical specification makes the following changes to the standard library:</source>
          <target state="translated">Adem&amp;aacute;s de presentar la nueva plantilla de excepci&amp;oacute;n &lt;a href=&quot;../error/tx_exception&quot;&gt; &lt;code&gt;std::tx_exception&lt;/code&gt; &lt;/a&gt; , la especificaci&amp;oacute;n t&amp;eacute;cnica de la memoria transaccional realiza los siguientes cambios en la biblioteca est&amp;aacute;ndar:</target>
        </trans-unit>
        <trans-unit id="f85f4cbfeeefb97ce1a4ae209c4036553a0f1353" translate="yes" xml:space="preserve">
          <source>Besides suitably declared identifiers, the following can be used in expressions in the same role:</source>
          <target state="translated">Además de los identificadores convenientemente declarados,en las expresiones de la misma función se puede utilizar lo siguiente</target>
        </trans-unit>
        <trans-unit id="dc609bbb82549ba7934f717ed858b800830e4534" translate="yes" xml:space="preserve">
          <source>Besides the minimal bit counts, the C++ Standard guarantees that  &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s del recuento m&amp;iacute;nimo de bits, el est&amp;aacute;ndar C ++ garantiza que &lt;code&gt;1 == sizeof(char) &amp;lt;= sizeof(short) &amp;lt;= sizeof(int) &amp;lt;= sizeof(long) &amp;lt;= sizeof(long long)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c97ed01493243e69d10ffc8e50648f78cab73dcd" translate="yes" xml:space="preserve">
          <source>Besides the standard attributes listed below, implementations may support arbitrary non-standard attributes with implementation-defined behavior. All attributes unknown to an implementation are ignored without causing an error.(since C++17).</source>
          <target state="translated">Además de los atributos estándar que se enumeran a continuación,las implementaciones pueden soportar atributos no estándar arbitrarios con un comportamiento definido por la implementación.Todos los atributos desconocidos para una implementación son ignorados sin causar un error (desde C++17).</target>
        </trans-unit>
        <trans-unit id="326ce75ab410687b03d60753ab3b5a7bc3c6aa60" translate="yes" xml:space="preserve">
          <source>Besides the system-specific information necessary to access the device (e.g. a POSIX file descriptor), each C stream object holds the following:</source>
          <target state="translated">Además de la información específica del sistema necesaria para acceder al dispositivo (por ejemplo,un descriptor de archivo POSIX),cada objeto de flujo C contiene lo siguiente:</target>
        </trans-unit>
        <trans-unit id="987751c78ae2b93d437defad81b5467e3258fa00" translate="yes" xml:space="preserve">
          <source>Best viable function</source>
          <target state="translated">La mejor función viable</target>
        </trans-unit>
        <trans-unit id="5445f48f941a5ad1d1542f8d66aef55a24056167" translate="yes" xml:space="preserve">
          <source>Between threads, evaluation A</source>
          <target state="translated">Entre los hilos,la evaluación A</target>
        </trans-unit>
        <trans-unit id="08921ac97281717dcf3cc5edee55ed9ec1246d18" translate="yes" xml:space="preserve">
          <source>Between threads, evaluation A is</source>
          <target state="translated">Entre los hilos,la evaluación A es</target>
        </trans-unit>
        <trans-unit id="2451baa075c4c2006f43575b68fffc6be3054416" translate="yes" xml:space="preserve">
          <source>BidirIt first</source>
          <target state="translated">Primero,el bidirit...</target>
        </trans-unit>
        <trans-unit id="d0770f96a62e4dba7b78dc8ded5a3d2559e0c17b" translate="yes" xml:space="preserve">
          <source>BidirIt second</source>
          <target state="translated">Bidir It segundo</target>
        </trans-unit>
        <trans-unit id="ffdf5ba9df9ed49abf7794c76ef97818235d86f9" translate="yes" xml:space="preserve">
          <source>BidirectionalIterator</source>
          <target state="translated">BidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="482ad58667e3f2f9817b420cb310aa97436e0bbd" translate="yes" xml:space="preserve">
          <source>BidirectionalRange</source>
          <target state="translated">BidirectionalRange</target>
        </trans-unit>
        <trans-unit id="c460d3f926dfc813742e2a51770def855d27f159" translate="yes" xml:space="preserve">
          <source>Binary and text modes</source>
          <target state="translated">Los modos binario y de texto</target>
        </trans-unit>
        <trans-unit id="91150bd6516ac5f77628d936130ba9cf5ec13ae6" translate="yes" xml:space="preserve">
          <source>Binary arithmetic operators</source>
          <target state="translated">Operadores de aritmética binaria</target>
        </trans-unit>
        <trans-unit id="b85455cd395dfbce0c44e85498fb4706eb3346ce" translate="yes" xml:space="preserve">
          <source>Binary literals in the C++ core language</source>
          <target state="translated">Literales binarios en el lenguaje central de C++</target>
        </trans-unit>
        <trans-unit id="cc724df4c71a335d592593fb78d0f54cdc71de39" translate="yes" xml:space="preserve">
          <source>Binary operators are typically implemented as non-members to maintain symmetry (for example, when adding a complex number and an integer, if &lt;code&gt;operator+&lt;/code&gt; is a member function of the complex type, then only &lt;code&gt;complex+integer&lt;/code&gt; would compile, and not &lt;code&gt;integer+complex&lt;/code&gt;). Since for every binary arithmetic operator there exists a corresponding compound assignment operator, canonical forms of binary operators are implemented in terms of their compound assignments:</source>
          <target state="translated">Los operadores binarios generalmente se implementan como no miembros para mantener la simetr&amp;iacute;a (por ejemplo, al agregar un n&amp;uacute;mero complejo y un n&amp;uacute;mero entero, si &lt;code&gt;operator+&lt;/code&gt; es una funci&amp;oacute;n miembro del tipo complejo, entonces solo se compilar&amp;aacute; &lt;code&gt;complex+integer&lt;/code&gt; y no &lt;code&gt;integer+complex&lt;/code&gt; ) . Dado que para cada operador aritm&amp;eacute;tico binario existe un operador de asignaci&amp;oacute;n compuesto correspondiente, las formas can&amp;oacute;nicas de operadores binarios se implementan en t&amp;eacute;rminos de sus asignaciones compuestas:</target>
        </trans-unit>
        <trans-unit id="9b181c7beda214f4532f13b77ba42314ece1f768" translate="yes" xml:space="preserve">
          <source>Binary search operations (on sorted ranges)</source>
          <target state="translated">Operaciones de búsqueda binaria (en rangos ordenados)</target>
        </trans-unit>
        <trans-unit id="9b0e681b6c800f7b05bda65505fa83f5f1a1be72" translate="yes" xml:space="preserve">
          <source>BinaryPredicate</source>
          <target state="translated">BinaryPredicate</target>
        </trans-unit>
        <trans-unit id="d7b9396086e5ec8058fd32dd688322acc6d2bf68" translate="yes" xml:space="preserve">
          <source>BinaryTypeTrait</source>
          <target state="translated">BinaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="3dbc95d187c9e90ca622a826dd7edb08cc9cacfa" translate="yes" xml:space="preserve">
          <source>Binders</source>
          <target state="translated">Binders</target>
        </trans-unit>
        <trans-unit id="f4e69ca5e425a4bf55911c4e6db32c6119febe30" translate="yes" xml:space="preserve">
          <source>Binding a reference to a virtual base class subobject.</source>
          <target state="translated">Vinculando una referencia a un subobjeto de clase base virtual.</target>
        </trans-unit>
        <trans-unit id="e9f04cf314fb7952075910e2f9ba75070c56f9c6" translate="yes" xml:space="preserve">
          <source>Binding of</source>
          <target state="translated">La encuadernación de</target>
        </trans-unit>
        <trans-unit id="c0cece0851be5efd26379576b4bcef2caf1dd812" translate="yes" xml:space="preserve">
          <source>Binding of a reference parameter directly to the argument expression is either Identity or a derived-to-base Conversion:</source>
          <target state="translated">La vinculación de un parámetro de referencia directamente a la expresión del argumento es o bien Identidad o bien Conversión derivada a base:</target>
        </trans-unit>
        <trans-unit id="d829dc6fbeb72ba40b4a6193d7c09ca8de6d9c66" translate="yes" xml:space="preserve">
          <source>Binding rules</source>
          <target state="translated">Normas vinculantes</target>
        </trans-unit>
        <trans-unit id="f722c7dc45abe867103665120ef13603cd9867f6" translate="yes" xml:space="preserve">
          <source>Binds a given argument &lt;code&gt;x&lt;/code&gt; to a first or second parameter of the given binary function object &lt;code&gt;f&lt;/code&gt;. That is, stores &lt;code&gt;x&lt;/code&gt; within the resulting wrapper, which, if called, passes &lt;code&gt;x&lt;/code&gt; as the first or the second parameter of &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">Vincula un argumento dado &lt;code&gt;x&lt;/code&gt; a un primer o segundo par&amp;aacute;metro del objeto de funci&amp;oacute;n binaria dado &lt;code&gt;f&lt;/code&gt; . Es decir, almacena &lt;code&gt;x&lt;/code&gt; dentro del contenedor resultante, que, si se llama, pasa &lt;code&gt;x&lt;/code&gt; como el primer o el segundo par&amp;aacute;metro de &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2587e5513df92e2184a69043d5b2d8c64896348f" translate="yes" xml:space="preserve">
          <source>Binds a reference to an object.</source>
          <target state="translated">Hace referencia a un objeto.</target>
        </trans-unit>
        <trans-unit id="7ff0b1c06c14891fb48b824df8e7692aa76016b3" translate="yes" xml:space="preserve">
          <source>Binds the specified names to subobjects or elements of the initializer.</source>
          <target state="translated">Vincula los nombres especificados a subobjetos o elementos del inicializador.</target>
        </trans-unit>
        <trans-unit id="48c22d075b084cd5b8d711e4184eb43a90b6c4ef" translate="yes" xml:space="preserve">
          <source>Binomial coefficients can be expressed in terms of the beta function: \(\binom{n}{k} = \frac{1}{(n+1)B(n-k+1,k+1)}\).</source>
          <target state="translated">Los coeficientes binomiales pueden expresarse en términos de la función beta:\N-(\Nbinom{n}{k}=\Nfrac{1}{(n+1)B(n-k+1,k+1)}).</target>
        </trans-unit>
        <trans-unit id="e8835c712451999e0a892ac12f5715c4350423b1" translate="yes" xml:space="preserve">
          <source>Bit</source>
          <target state="translated">Bit</target>
        </trans-unit>
        <trans-unit id="b5630cfa9108a371c432ca1b8e629cf6bc1b012a" translate="yes" xml:space="preserve">
          <source>Bit field</source>
          <target state="translated">Campo de bits</target>
        </trans-unit>
        <trans-unit id="b045376f837c7f5b36378c8f4a5c40a869f8ef92" translate="yes" xml:space="preserve">
          <source>Bit fields</source>
          <target state="translated">Campos de bits</target>
        </trans-unit>
        <trans-unit id="443a8710a8bef103647191f97f7cd879bcad9c73" translate="yes" xml:space="preserve">
          <source>Bit manipulation</source>
          <target state="translated">Manipulación de bits</target>
        </trans-unit>
        <trans-unit id="491df97cfa5e39f515f28ec7e2a2d72a45a33da8" translate="yes" xml:space="preserve">
          <source>Bit manipulation (since C++20)</source>
          <target state="translated">Manipulación de bits (desde C++20)</target>
        </trans-unit>
        <trans-unit id="e6078ce7cb8ef5cea6018354d8a889b9edde5cbc" translate="yes" xml:space="preserve">
          <source>BitmaskType</source>
          <target state="translated">BitmaskType</target>
        </trans-unit>
        <trans-unit id="5ec768dbd17e419b41b32bba46a2d38687d9a71f" translate="yes" xml:space="preserve">
          <source>Bitset</source>
          <target state="translated">Bitset</target>
        </trans-unit>
        <trans-unit id="741c773876c69e2cd07b549c1ea8ece454c609e3" translate="yes" xml:space="preserve">
          <source>Bitwise &lt;a href=&quot;operator_arithmetic#Bitwise_shift_operators&quot;&gt;left shift and right shift&lt;/a&gt;</source>
          <target state="translated">Bitwise &lt;a href=&quot;operator_arithmetic#Bitwise_shift_operators&quot;&gt;desplazamiento a la izquierda y desplazamiento a la derecha&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">Un poco más inteligente y...</target>
        </trans-unit>
        <trans-unit id="306fd7520aac5bd6625750560fd55f52696ffa54" translate="yes" xml:space="preserve">
          <source>Bitwise OR of the floating-point exception macros that are both included in &lt;code&gt;excepts&lt;/code&gt; and correspond to floating-point exceptions currently set.</source>
          <target state="translated">O bit a bit de las macros de excepci&amp;oacute;n de punto flotante que est&amp;aacute;n incluidas en las &lt;code&gt;excepts&lt;/code&gt; y corresponden a las excepciones de punto flotante establecidas actualmente.</target>
        </trans-unit>
        <trans-unit id="35355cba328d12df3bd3dca4cc2c3703b1246bb3" translate="yes" xml:space="preserve">
          <source>Bitwise arithmetic operators</source>
          <target state="translated">Operadores de aritmética bituminosa</target>
        </trans-unit>
        <trans-unit id="9137bddcb31c15dd59efa0751eb46d78510d3c77" translate="yes" xml:space="preserve">
          <source>Bitwise logic operators</source>
          <target state="translated">Los operadores lógicos de bits</target>
        </trans-unit>
        <trans-unit id="67445a8812f7cd259e3b6e21272d2fddff30a9e2" translate="yes" xml:space="preserve">
          <source>Bitwise operations</source>
          <target state="translated">Operaciones de bitácora</target>
        </trans-unit>
        <trans-unit id="d49fb1543c1cf037be882f516f8283e8411c03af" translate="yes" xml:space="preserve">
          <source>Bitwise shift operators</source>
          <target state="translated">Operadores de cambio de bits</target>
        </trans-unit>
        <trans-unit id="5bf1d047debbacfb72d2c4727d98ae3d266e79f4" translate="yes" xml:space="preserve">
          <source>Block declaration (a declaration that can appear inside a &lt;a href=&quot;statements#Compound_statement&quot;&gt;block&lt;/a&gt;), which, in turn, can be one of the following:</source>
          <target state="translated">Declaraci&amp;oacute;n de bloque (una declaraci&amp;oacute;n que puede aparecer dentro de un &lt;a href=&quot;statements#Compound_statement&quot;&gt;bloque&lt;/a&gt; ), que, a su vez, puede ser una de las siguientes:</target>
        </trans-unit>
        <trans-unit id="e681513340338ab189ae37b3a82732813788fc1e" translate="yes" xml:space="preserve">
          <source>Block scope</source>
          <target state="translated">Bloquear el alcance</target>
        </trans-unit>
        <trans-unit id="ab7474d238eb40c9da20e933f1c1d4048b69acd4" translate="yes" xml:space="preserve">
          <source>Blocks for the provided duration or until a lock on &lt;code&gt;m&lt;/code&gt; is acquired.</source>
          <target state="translated">Bloques por la duraci&amp;oacute;n proporcionada o hasta que se adquiera un bloqueo en &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92391cb25322ebaeda3d45357ca30e226b318b27" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until exclusive ownership of the mutex can be obtained.</source>
          <target state="translated">Bloquea el hilo de llamada hasta que se pueda obtener la propiedad exclusiva del mutex.</target>
        </trans-unit>
        <trans-unit id="8f7f11c61615ab6fa684880437bc9968e692fba9" translate="yes" xml:space="preserve">
          <source>Blocks the calling thread until shared ownership of the mutex can be obtained.</source>
          <target state="translated">Bloquea el hilo de llamada hasta que se pueda obtener la propiedad compartida del mutex.</target>
        </trans-unit>
        <trans-unit id="2fd2dcd848502428b39dc60b6225e09d3f0e7e57" translate="yes" xml:space="preserve">
          <source>Blocks the current thread until the thread identified by &lt;code&gt;*this&lt;/code&gt; finishes its execution.</source>
          <target state="translated">Bloquea el subproceso actual hasta que el subproceso identificado por &lt;code&gt;*this&lt;/code&gt; finalice su ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="6e00d4fd15cea4053d3d66470eca6ff8a4eb81f0" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread for</source>
          <target state="translated">Bloquea la ejecución del hilo actual para</target>
        </trans-unit>
        <trans-unit id="74a224c0de9a1fe8a0d5475e7041194e73e5a53a" translate="yes" xml:space="preserve">
          <source>Blocks the execution of the current thread until specified &lt;code&gt;sleep_time&lt;/code&gt; has been reached.</source>
          <target state="translated">Bloquea la ejecuci&amp;oacute;n del subproceso actual hasta que se haya alcanzado el tiempo de &lt;code&gt;sleep_time&lt;/code&gt; especificado .</target>
        </trans-unit>
        <trans-unit id="9af45472a96a859ddc1794b6abf6298174b74613" translate="yes" xml:space="preserve">
          <source>Blocks until a lock can be obtained for the current execution agent (thread, process, task). If an exception is thrown, no lock is obtained.</source>
          <target state="translated">Bloquea hasta que se pueda obtener un bloqueo para el agente de ejecución actual (hilo,proceso,tarea).Si se lanza una excepción,no se obtiene un bloqueo.</target>
        </trans-unit>
        <trans-unit id="eba863ee2c609bd20888a9ee01d8f0bc03fe3b0b" translate="yes" xml:space="preserve">
          <source>Blocks until the provided time limit point is reached or a lock on &lt;code&gt;m&lt;/code&gt; is acquired.</source>
          <target state="translated">Bloquea hasta que se alcanza el l&amp;iacute;mite de tiempo proporcionado o se adquiere un bloqueo en &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb596caefce629504fd3a475f3183426b8a356e3" translate="yes" xml:space="preserve">
          <source>Blocks until the result becomes available. &lt;code&gt;valid() == true&lt;/code&gt; after the call.</source>
          <target state="translated">Bloques hasta que el resultado est&amp;eacute; disponible. &lt;code&gt;valid() == true&lt;/code&gt; despu&amp;eacute;s de la llamada.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="7bb852d637486dd2f9b852b32fe5bd9ba4fa4b63" translate="yes" xml:space="preserve">
          <source>Boolean conversions</source>
          <target state="translated">Conversiones booleanas</target>
        </trans-unit>
        <trans-unit id="c9a26dc7a812c76d486afec462ae9a205a68b3e6" translate="yes" xml:space="preserve">
          <source>Boolean literals</source>
          <target state="translated">Literales booleanos</target>
        </trans-unit>
        <trans-unit id="74e13cd703ad7a9a0db9e8fcedf7a2cbccdea7d3" translate="yes" xml:space="preserve">
          <source>Boolean negation operator</source>
          <target state="translated">Operador de negación booleana</target>
        </trans-unit>
        <trans-unit id="49f29c844f200eead7503c6d10737135d242ba2b" translate="yes" xml:space="preserve">
          <source>Boolean type</source>
          <target state="translated">Tipo booleano</target>
        </trans-unit>
        <trans-unit id="a14c6ec0166e69a3cf0be1f4ccc882e1dc773e55" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt; and &lt;a href=&quot;../../language/delete&quot;&gt;delete-expression&lt;/a&gt;, when used with objects whose alignment requirement is greater than &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, pass that alignment requirement as an argument of type &lt;code&gt;std::align_val_t&lt;/code&gt; to the selected allocation/deallocation function.</source>
          <target state="translated">Tanto &lt;a href=&quot;../../language/new&quot;&gt;nuevo-expresi&amp;oacute;n&lt;/a&gt; y &lt;a href=&quot;../../language/delete&quot;&gt;delete-expresi&amp;oacute;n&lt;/a&gt; , cuando se utiliza con objetos cuyo requisito de alineaci&amp;oacute;n es mayor que &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , pasan a ese requisito de alineaci&amp;oacute;n tal como un argumento de tipo &lt;code&gt;std::align_val_t&lt;/code&gt; a la funci&amp;oacute;n de asignaci&amp;oacute;n / desasignaci&amp;oacute;n seleccionado.</target>
        </trans-unit>
        <trans-unit id="efa828bc8c6e261a85369b79ad278f982b80b478" translate="yes" xml:space="preserve">
          <source>Both &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt; and &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt; declarations may appear with the &lt;code&gt;friend&lt;/code&gt; specifier in any non-local class or class template (although only function templates may be defined within the class or class template that is granting friendship). In this case, every specialization of the template becomes a friend, whether it is implicitly instantiated, partially specialized, or explicitly specialized.</source>
          <target state="translated">Tanto la &lt;a href=&quot;function_template&quot;&gt;plantilla de funci&amp;oacute;n&lt;/a&gt; como &lt;a href=&quot;class_template&quot;&gt;las&lt;/a&gt; declaraciones de plantilla de clase pueden aparecer con el especificador de &lt;code&gt;friend&lt;/code&gt; en cualquier clase o plantilla de clase no local (aunque solo se pueden definir plantillas de funci&amp;oacute;n dentro de la clase o plantilla de clase que otorga amistad). En este caso, cada especializaci&amp;oacute;n de la plantilla se convierte en un amigo, ya sea impl&amp;iacute;citamente instanciado, parcialmente especializado o expl&amp;iacute;citamente especializado.</target>
        </trans-unit>
        <trans-unit id="63016d3fee2638a4d3429bfc299eeab7075b466b" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; and the value zero indicate successful program execution status (see &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;), although it is not required that &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; equals zero.</source>
          <target state="translated">Tanto &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; como el valor cero indican un estado de ejecuci&amp;oacute;n exitoso del programa (consulte &lt;code&gt;&lt;a href=&quot;exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; ), aunque no es necesario que &lt;code&gt;EXIT_SUCCESS&lt;/code&gt; sea igual a cero.</target>
        </trans-unit>
        <trans-unit id="ff19dd1cff37c69bcf7f62a061f0632df661ad27" translate="yes" xml:space="preserve">
          <source>Both constructors (other than &lt;a href=&quot;copy_constructor&quot;&gt;copy&lt;/a&gt;/&lt;a href=&quot;move_constructor&quot;&gt;move&lt;/a&gt;) and user-defined conversion functions may be function templates; the meaning of &lt;code&gt;explicit&lt;/code&gt; doesn't change.</source>
          <target state="translated">Ambos constructores (aparte de &lt;a href=&quot;copy_constructor&quot;&gt;copiar&lt;/a&gt; / &lt;a href=&quot;move_constructor&quot;&gt;mover&lt;/a&gt; ) y las funciones de conversi&amp;oacute;n definidas por el usuario pueden ser plantillas de funciones; El significado de &lt;code&gt;explicit&lt;/code&gt; no cambia.</target>
        </trans-unit>
        <trans-unit id="6b2dfd50c4fa7ea73355cbddda751f4dda04b1d2" translate="yes" xml:space="preserve">
          <source>Both constructors are protected, and are only called by the concrete streambuf classes, such as &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ambos constructores est&amp;aacute;n protegidos y solo son llamados por las clases concretas de streambuf, como &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a919957c7deab2ea5acd8f4154fbcf839bb6dac2" translate="yes" xml:space="preserve">
          <source>Both copy- and move-assignment operators for directory_entry are are defaulted.</source>
          <target state="translated">Los operadores de asignación de copias y movimientos para directory_entry están predeterminados.</target>
        </trans-unit>
        <trans-unit id="5bb05230f21307e6f1e1d771c4a72fefe561d481" translate="yes" xml:space="preserve">
          <source>Both scoped enumeration types and unscoped enumeration types whose underlying type is fixed can be initialized from an integer without a cast, using &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, if all of the following is true:</source>
          <target state="translated">Tanto los tipos de enumeraci&amp;oacute;n con &amp;aacute;mbito como los tipos de enumeraci&amp;oacute;n sin &amp;aacute;mbito cuyo tipo subyacente es fijo se pueden inicializar desde un entero sin conversi&amp;oacute;n, utilizando la &lt;a href=&quot;list_initialization&quot;&gt;inicializaci&amp;oacute;n de lista&lt;/a&gt; , si todo lo siguiente es verdadero:</target>
        </trans-unit>
        <trans-unit id="5deba5db9615b12e705c1e44fac1908355100dcb" translate="yes" xml:space="preserve">
          <source>Both single-object and array allocation functions may be defined as public static member functions of a class (versions (15-18)). If defined, these allocation functions are called by &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate memory for single objects and arrays of this class, unless the new expression used the form &lt;code&gt;::new&lt;/code&gt; which bypasses class-scope lookup. The keyword &lt;code&gt;static&lt;/code&gt; is optional for these functions: whether used or not, the allocation function is a static member function.</source>
          <target state="translated">Tanto las funciones de asignaci&amp;oacute;n de un solo objeto como de matriz pueden definirse como funciones miembro p&amp;uacute;blicas est&amp;aacute;ticas de una clase (versiones (15-18)). Si se definen, estas funciones de asignaci&amp;oacute;n se invocan mediante &lt;a href=&quot;../../language/new&quot;&gt;nuevas expresiones&lt;/a&gt; para asignar memoria para objetos individuales y matrices de esta clase, a menos que la nueva expresi&amp;oacute;n use form &lt;code&gt;::new&lt;/code&gt; , que omite la b&amp;uacute;squeda de alcance de clase. La palabra clave &lt;code&gt;static&lt;/code&gt; es opcional para estas funciones: se use o no, la funci&amp;oacute;n de asignaci&amp;oacute;n es una funci&amp;oacute;n miembro est&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="0028861eddd8245788364237b82fa610aebd0d8e" translate="yes" xml:space="preserve">
          <source>Both this function and the constructor of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; may be used to acquire temporary ownership of the managed object referred to by a &lt;code&gt;std::weak_ptr&lt;/code&gt;. The difference is that the constructor of &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; throws an exception when its &lt;code&gt;std::weak_ptr&lt;/code&gt; argument is empty, while &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;::lock()&lt;/code&gt; constructs an empty &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Tanto esta funci&amp;oacute;n como el constructor de &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; pueden usarse para adquirir la propiedad temporal del objeto administrado al que hace referencia &lt;code&gt;std::weak_ptr&lt;/code&gt; . La diferencia es que el constructor de &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; lanza una excepci&amp;oacute;n cuando su argumento &lt;code&gt;std::weak_ptr&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, mientras que &lt;code&gt;std::weak_ptr&amp;lt;T&amp;gt;::lock()&lt;/code&gt; construye un &lt;code&gt;std::shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; vac&amp;iacute;o .</target>
        </trans-unit>
        <trans-unit id="c71adfce132d82af6ce298cc94111b2a04e3c1ab" translate="yes" xml:space="preserve">
          <source>Both versions are constant expressions of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Ambas versiones son expresiones constantes de tipo &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="943facfd40f56533abfb37b73ee46c45ee23481a" translate="yes" xml:space="preserve">
          <source>Boyer-Moore search algorithm implementation</source>
          <target state="translated">Implementación del algoritmo de búsqueda Boyer-Moore</target>
        </trans-unit>
        <trans-unit id="498eeb65762b20bc8f5d61f62b5b2037e626f9c9" translate="yes" xml:space="preserve">
          <source>Boyer-Moore-Horspool search algorithm implementation</source>
          <target state="translated">Implementación del algoritmo de búsqueda Boyer-Moore-Horspool</target>
        </trans-unit>
        <trans-unit id="f87d9810eeab220cb3bd2cc07cbf939aafc31cb1" translate="yes" xml:space="preserve">
          <source>Brace-enclosed initializers</source>
          <target state="translated">Inicializadores con abrazaderas</target>
        </trans-unit>
        <trans-unit id="014d790a3d5a9df8c0ff4408ebe540186f635544" translate="yes" xml:space="preserve">
          <source>Breaks the association of the associated mutex, if any, and &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Rompe la asociaci&amp;oacute;n del mutex asociado, si lo hay, y &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7dfd8323fd5e72ce649953eb9bbb100abdbf328" translate="yes" xml:space="preserve">
          <source>Broken pipe</source>
          <target state="translated">Trozos de tubería</target>
        </trans-unit>
        <trans-unit id="e5817b915ebc6c65487325f1fad96d1830f9ec3a" translate="yes" xml:space="preserve">
          <source>Bucket index for the key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">&amp;Iacute;ndice de cubo para la clave &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1578c16566abfd5ed0ac525177c29f906ca89176" translate="yes" xml:space="preserve">
          <source>Bucket interface</source>
          <target state="translated">Interfaz del cubo</target>
        </trans-unit>
        <trans-unit id="39da5ebcfeabc5cbfab75222627dd08adc0b92bb" translate="yes" xml:space="preserve">
          <source>Build level and violation handling</source>
          <target state="translated">Nivel de construcción y manejo de las violaciones</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="5620451e3028694b641893b89d306b16dd893957" translate="yes" xml:space="preserve">
          <source>Built-in &lt;a href=&quot;operator_comparison#Three-way_comparison&quot;&gt;three-way comparison operator&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;operator_comparison#Three-way_comparison&quot;&gt;Operador de comparaci&amp;oacute;n de tres v&amp;iacute;as&lt;/a&gt; incorporado</target>
        </trans-unit>
        <trans-unit id="ba57c0678fa197d58d012dcdbd8ff367ded4373c" translate="yes" xml:space="preserve">
          <source>Built-in address-of operator</source>
          <target state="translated">Dirección incorporada del operador</target>
        </trans-unit>
        <trans-unit id="89c57ad877bc748c74e85159feaaf08e70f5f5a1" translate="yes" xml:space="preserve">
          <source>Built-in comma operator</source>
          <target state="translated">Operador de coma incorporado</target>
        </trans-unit>
        <trans-unit id="29c41e2e5a519d072283f8900cfb2aecddea654d" translate="yes" xml:space="preserve">
          <source>Built-in function call operator</source>
          <target state="translated">Operador de llamadas con función incorporada</target>
        </trans-unit>
        <trans-unit id="6a837a52363a7caaa8043442690c260da71652ff" translate="yes" xml:space="preserve">
          <source>Built-in indirection operator</source>
          <target state="translated">Operador indirecto incorporado</target>
        </trans-unit>
        <trans-unit id="667f2d7df45e4a7b467abfa721de0d718054104f" translate="yes" xml:space="preserve">
          <source>Built-in member access operators</source>
          <target state="translated">Operadores de acceso a miembros incorporados</target>
        </trans-unit>
        <trans-unit id="76bd10380a7941d509b7c26c3c0d87d1eddae2bc" translate="yes" xml:space="preserve">
          <source>Built-in pointer-to-member access operators</source>
          <target state="translated">Operadores de acceso puntero a miembros incorporados</target>
        </trans-unit>
        <trans-unit id="74faee7794760c0f5ba932d0cc3927a1f7c63af0" translate="yes" xml:space="preserve">
          <source>Built-in postfix operators</source>
          <target state="translated">Operadores de postfijo incorporados</target>
        </trans-unit>
        <trans-unit id="c49aba310c5c949e131422dc6d86594cd3fd9999" translate="yes" xml:space="preserve">
          <source>Built-in prefix operators</source>
          <target state="translated">Operadores de prefijos incorporados</target>
        </trans-unit>
        <trans-unit id="01e1dbd00564662647a6c23a14ae45eff862413d" translate="yes" xml:space="preserve">
          <source>Built-in subscript operator</source>
          <target state="translated">Operador de subíndice incorporado</target>
        </trans-unit>
        <trans-unit id="97de26f6f9f063ed744153d8d933e88e0b59a100" translate="yes" xml:space="preserve">
          <source>Builtin compound assignment</source>
          <target state="translated">Asignación del compuesto construido</target>
        </trans-unit>
        <trans-unit id="860269ba76f59f407f62610e614523ed6bb2b17c" translate="yes" xml:space="preserve">
          <source>Builtin direct assignment</source>
          <target state="translated">Asignación directa construida</target>
        </trans-unit>
        <trans-unit id="cd27a3b8b65f3e0b8397cd40fb51bd882218435c" translate="yes" xml:space="preserve">
          <source>Builtin operators &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; perform short-circuit evaluation (do not evaluate the second operand if the result is known after evaluating the first), but overloaded operators behave like regular function calls and always evaluate both operands</source>
          <target state="translated">Operadores incorporados &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; realiza una evaluaci&amp;oacute;n de cortocircuito (no eval&amp;uacute;e el segundo operando si se conoce el resultado despu&amp;eacute;s de evaluar el primero), pero los operadores sobrecargados se comportan como llamadas de funci&amp;oacute;n regulares y siempre eval&amp;uacute;an ambos operandos</target>
        </trans-unit>
        <trans-unit id="05d591efb279e3a248c17303baf5ea55526a4063" translate="yes" xml:space="preserve">
          <source>But the same parameter cannot be given default arguments twice in the same scope.</source>
          <target state="translated">Pero no se puede dar al mismo parámetro argumentos por defecto dos veces en el mismo ámbito.</target>
        </trans-unit>
        <trans-unit id="ae372236d69794d1162dbcde117c87725ee50599" translate="yes" xml:space="preserve">
          <source>By default (with the default &lt;code&gt;&lt;a href=&quot;../char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt;), this function is not locale-sensitive. See &lt;code&gt;&lt;a href=&quot;../../locale/collate/compare&quot;&gt;std::collate::compare&lt;/a&gt;&lt;/code&gt; for locale-aware three-way string comparison.</source>
          <target state="translated">Por defecto (con el est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;../char_traits&quot;&gt;std::char_traits&lt;/a&gt;&lt;/code&gt; ), esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional. Consulte &lt;code&gt;&lt;a href=&quot;../../locale/collate/compare&quot;&gt;std::collate::compare&lt;/a&gt;&lt;/code&gt; para la comparaci&amp;oacute;n de cadenas de tres v&amp;iacute;as con reconocimiento de la configuraci&amp;oacute;n regional.</target>
        </trans-unit>
        <trans-unit id="f3a260b7cae289fb8e1fb6ad3c38b354a5c26916" translate="yes" xml:space="preserve">
          <source>By default, all eight standard C++ streams are synchronized with their respective C streams.</source>
          <target state="translated">Por defecto,las ocho corrientes C++estándar están sincronizadas con sus respectivas corrientes C.</target>
        </trans-unit>
        <trans-unit id="ce023180676c6490743b29e9926007bad4819315" translate="yes" xml:space="preserve">
          <source>By default, symlinks are not followed, but this can be enabled by specifying the directory option &lt;a href=&quot;directory_options&quot;&gt;&lt;code&gt;follow_directory_symlink&lt;/code&gt;&lt;/a&gt; at construction time.</source>
          <target state="translated">De forma predeterminada, no se siguen los enlaces simb&amp;oacute;licos, pero esto se puede habilitar especificando la opci&amp;oacute;n de directorio &lt;a href=&quot;directory_options&quot;&gt; &lt;code&gt;follow_directory_symlink&lt;/code&gt; &lt;/a&gt; en el momento de la construcci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0eb851d780be859c6cd08434ab3959f35e91fa13" translate="yes" xml:space="preserve">
          <source>By default, the standard streams &lt;code&gt;cin&lt;/code&gt; and &lt;code&gt;cerr&lt;/code&gt; are tied to &lt;code&gt;cout&lt;/code&gt;. Similarly, their wide counterparts &lt;code&gt;wcin&lt;/code&gt; and &lt;code&gt;wcerr&lt;/code&gt; are tied to &lt;code&gt;wcout&lt;/code&gt;.</source>
          <target state="translated">Por defecto, las transmisiones est&amp;aacute;ndar &lt;code&gt;cin&lt;/code&gt; y &lt;code&gt;cerr&lt;/code&gt; est&amp;aacute;n vinculadas a &lt;code&gt;cout&lt;/code&gt; . Del mismo modo, sus anchos hom&amp;oacute;logos &lt;code&gt;wcin&lt;/code&gt; y &lt;code&gt;wcerr&lt;/code&gt; est&amp;aacute;n vinculados a &lt;code&gt;wcout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0541acf21651250dc0b8e2afd7f3da25009343a" translate="yes" xml:space="preserve">
          <source>By default, this will call placement-new, as by &lt;code&gt;::new((void*)p) T()&lt;/code&gt; (that is, &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialize&lt;/a&gt; the object pointed to by &lt;code&gt;p&lt;/code&gt;). If value-initialization is undesirable, for example, if the object is of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="translated">Por defecto, esto llamar&amp;aacute; ubicaci&amp;oacute;n-nueva, como por &lt;code&gt;::new((void*)p) T()&lt;/code&gt; (es decir, &lt;a href=&quot;../language/value_initialization&quot;&gt;inicializa&lt;/a&gt; el objeto al que apunta &lt;code&gt;p&lt;/code&gt; ). Si la inicializaci&amp;oacute;n del valor no es deseable, por ejemplo, si el objeto no es de clase y no se necesita poner a cero, puede evitarse proporcionando un &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;Allocator :: construct personalizado&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7803ee252527503b67d1eeb0deb252622746cebd" translate="yes" xml:space="preserve">
          <source>Byte</source>
          <target state="translated">Byte</target>
        </trans-unit>
        <trans-unit id="8e26337cf6bb10967dc0cb055379c6312a7a94ee" translate="yes" xml:space="preserve">
          <source>Byte/multibyte character</source>
          <target state="translated">Carácter byte/multibyte</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="15c24806702abe5ea48e31ecde1d9e103ea60746" translate="yes" xml:space="preserve">
          <source>C &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; is not allowed.</source>
          <target state="translated">El &lt;a href=&quot;language_linkage&quot;&gt;enlace en lenguaje&lt;/a&gt; C no est&amp;aacute; permitido.</target>
        </trans-unit>
        <trans-unit id="09b5b3333cb4ff4683a9d0855cb7f956ff522e8f" translate="yes" xml:space="preserve">
          <source>C Date and time utilities</source>
          <target state="translated">C Utilidades de fecha y hora</target>
        </trans-unit>
        <trans-unit id="1eca25182c934c202df4d629e6f313747250a6f1" translate="yes" xml:space="preserve">
          <source>C compatibility header.</source>
          <target state="translated">Cabecera de compatibilidad C.</target>
        </trans-unit>
        <trans-unit id="f27d46df9dc50736ed4e3b3843a69d430fee37b8" translate="yes" xml:space="preserve">
          <source>C compatibility headers</source>
          <target state="translated">Cabezales de compatibilidad C</target>
        </trans-unit>
        <trans-unit id="b75858e6f52757d42995120144302a816dcfb58b" translate="yes" xml:space="preserve">
          <source>C compatibility macro constant, expands to integer constant &lt;code&gt;1&lt;/code&gt;</source>
          <target state="translated">Constante de macro de compatibilidad C, se expande a constante constante &lt;code&gt;1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a96bb87493004f593e10038ce1e6395886cc3ef" translate="yes" xml:space="preserve">
          <source>C library</source>
          <target state="translated">Biblioteca C</target>
        </trans-unit>
        <trans-unit id="085bb2391a15d3dae8b4fa9f82fd51d51923f45e" translate="yes" xml:space="preserve">
          <source>C library locales</source>
          <target state="translated">C locales de la biblioteca</target>
        </trans-unit>
        <trans-unit id="401eb191196e5e41faa446684424f56e654762b8" translate="yes" xml:space="preserve">
          <source>C localization utilities</source>
          <target state="translated">Utilidades de localización C</target>
        </trans-unit>
        <trans-unit id="f247a737aad973565e0ba61f676327ab62c8b7fc" translate="yes" xml:space="preserve">
          <source>C memory management library</source>
          <target state="translated">Biblioteca de gestión de la memoria C</target>
        </trans-unit>
        <trans-unit id="726cf0d2d039a3d7cb20400e7f928d472fbf197c" translate="yes" xml:space="preserve">
          <source>C numeric limits interface</source>
          <target state="translated">Interfaz de límites numéricos C</target>
        </trans-unit>
        <trans-unit id="b970bd670bcff0b0de508ab26d86ee7e72402f93" translate="yes" xml:space="preserve">
          <source>C random library</source>
          <target state="translated">C biblioteca aleatoria</target>
        </trans-unit>
        <trans-unit id="56b2ac8093b8f482b9514d65903de1ddffba1b90" translate="yes" xml:space="preserve">
          <source>C streams are objects of type &lt;code&gt;std::FILE&lt;/code&gt; that can only be accessed and manipulated through pointers of type &lt;code&gt;std::FILE*&lt;/code&gt; (Note: while it may be possible to create a local object of type &lt;code&gt;std::FILE&lt;/code&gt; by dereferencing and copying a valid &lt;code&gt;std::FILE*&lt;/code&gt;, using the address of such copy in the I/O functions is undefined behavior). Each C stream is associated with an external physical device (file, standard input stream, printer, serial port, etc).</source>
          <target state="translated">Las secuencias C son objetos de tipo &lt;code&gt;std::FILE&lt;/code&gt; que solo se puede acceder y manipular a trav&amp;eacute;s de punteros de tipo &lt;code&gt;std::FILE*&lt;/code&gt; (Nota: si bien es posible crear un objeto local de tipo &lt;code&gt;std::FILE&lt;/code&gt; desreferenciando y copiando un v&amp;aacute;lido &lt;code&gt;std::FILE*&lt;/code&gt; , el uso de la direcci&amp;oacute;n de dicha copia en las funciones de E / S es un comportamiento indefinido). Cada flujo C est&amp;aacute; asociado con un dispositivo f&amp;iacute;sico externo (archivo, flujo de entrada est&amp;aacute;ndar, impresora, puerto serie, etc.).</target>
        </trans-unit>
        <trans-unit id="a6cb82dfe4668eb03399d738975e3f7f2a00e75b" translate="yes" xml:space="preserve">
          <source>C streams can be used for both unformatted and formatted input and output. They are locale-sensitive and may perform wide/multibyte conversions as necessary. Unlike C++ streams, where each stream is associated with its own locale, all C streams access the same locale object: the one most recently installed with &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;std::setlocale&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Las transmisiones en C se pueden usar para entradas y salidas sin formato y formateadas. Son sensibles a la configuraci&amp;oacute;n regional y pueden realizar conversiones de ancho / multibyte seg&amp;uacute;n sea necesario. A diferencia de las secuencias de C ++, donde cada secuencia est&amp;aacute; asociada con su propia configuraci&amp;oacute;n regional, todas las secuencias de C acceden al mismo objeto de configuraci&amp;oacute;n regional: el que se instal&amp;oacute; m&amp;aacute;s recientemente con &lt;code&gt;&lt;a href=&quot;../locale/setlocale&quot;&gt;std::setlocale&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79c384f1ba053ea6a78d8c958d790e56d9052ca1" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired category</source>
          <target state="translated">La cadena C que contiene el nombre de la categoría deseada</target>
        </trans-unit>
        <trans-unit id="437c617752c611b36293355138fcbc5720307f88" translate="yes" xml:space="preserve">
          <source>C string holding the name of the desired mapping.</source>
          <target state="translated">La cadena C que contiene el nombre de la cartografía deseada.</target>
        </trans-unit>
        <trans-unit id="136b0b9b8ee0529927aebb743b29982272ffa9e4" translate="yes" xml:space="preserve">
          <source>C&amp;amp;</source>
          <target state="translated">C&amp;amp;</target>
        </trans-unit>
        <trans-unit id="fc2b4216164cfb01ac45112054b3fedda8b56c86" translate="yes" xml:space="preserve">
          <source>C++</source>
          <target state="translated">C++</target>
        </trans-unit>
        <trans-unit id="2f6d341776b09562a2d3ff15e2b8fa6906d9644e" translate="yes" xml:space="preserve">
          <source>C++ (and C) source code may be written in any non-ASCII 7-bit character set that includes the &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646:1983&lt;/a&gt; invariant character set. However, several C++ operators and punctuators require characters that are outside of the ISO 646 codeset: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt;. To be able to use character encodings where some or all of these symbols do not exist (such as the German &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt;), C++ defines the following alternatives composed of ISO 646 compatible characters.</source>
          <target state="translated">El c&amp;oacute;digo fuente de C ++ (y C) puede escribirse en cualquier conjunto de caracteres de 7 bits no ASCII que incluya el conjunto de caracteres invariante &lt;a href=&quot;https://en.wikipedia.org/wiki/ISO_646&quot;&gt;ISO 646: 1983&lt;/a&gt; . Sin embargo, varios operadores y signos de puntuaci&amp;oacute;n de C ++ requieren caracteres que est&amp;aacute;n fuera del conjunto de c&amp;oacute;digos ISO 646: &lt;code&gt;{, }, [, ], #, \, ^, |, ~&lt;/code&gt; . Para poder usar codificaciones de caracteres donde algunos o todos estos s&amp;iacute;mbolos no existen (como el &lt;a href=&quot;http://de.wikipedia.org/wiki/DIN_66003&quot;&gt;DIN 66003&lt;/a&gt; alem&amp;aacute;n ), C ++ define las siguientes alternativas compuestas de caracteres compatibles con ISO 646.</target>
        </trans-unit>
        <trans-unit id="3c7d95b436ecd68b95eaa98a87bac58f93c37e6b" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types&quot;&gt;E.14&lt;/a&gt;</source>
          <target state="translated">Pautas principales de C ++ &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e14-use-purpose-designed-user-defined-types-as-exceptions-not-built-in-types&quot;&gt;E.14&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8cd612f2751329bbc16fee8f0091854df9f6031e" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e15-catch-exceptions-from-a-hierarchy-by-reference&quot;&gt;E.15&lt;/a&gt;</source>
          <target state="translated">Pautas principales de C ++ &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#e15-catch-exceptions-from-a-hierarchy-by-reference&quot;&gt;E.15&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="98881b02a247b26f94eb74fc06a45d722e646dd5" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i10-use-exceptions-to-signal-a-failure-to-perform-a-required-task&quot;&gt;I.10&lt;/a&gt;</source>
          <target state="translated">Pautas principales de C ++ &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#i10-use-exceptions-to-signal-a-failure-to-perform-a-required-task&quot;&gt;I.10&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="c8be3e815f49596e499ad72b4130d9ecd2f1b149" translate="yes" xml:space="preserve">
          <source>C++ Core Guidelines E.6 &quot;Use RAII to prevent leaks&quot;</source>
          <target state="translated">C++Core Guidelines E.6 &quot;Usar RAII para prevenir fugas&quot;</target>
        </trans-unit>
        <trans-unit id="147230a86e1c7e0bef8e1878444e4fbcc383fa96" translate="yes" xml:space="preserve">
          <source>C++ Operator Precedence</source>
          <target state="translated">C++Precedente del operador</target>
        </trans-unit>
        <trans-unit id="c31eca9ef3dcd7526b7195249185a9729b743830" translate="yes" xml:space="preserve">
          <source>C++ Programming Language</source>
          <target state="translated">Lenguaje de programación C++</target>
        </trans-unit>
        <trans-unit id="e7e7bcbec1050d7f0d883fbb8bc2748f84236f39" translate="yes" xml:space="preserve">
          <source>C++ also includes the &lt;a href=&quot;io/c&quot;&gt; input/output functions defined by C&lt;/a&gt;, such as &lt;code&gt;&lt;a href=&quot;io/c/fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;io/c/fgetc&quot;&gt;std::getc&lt;/a&gt;&lt;/code&gt;, etc.</source>
          <target state="translated">C ++ tambi&amp;eacute;n incluye las &lt;a href=&quot;io/c&quot;&gt;funciones de entrada / salida definidas por C&lt;/a&gt; , como &lt;code&gt;&lt;a href=&quot;io/c/fopen&quot;&gt;std::fopen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;io/c/fgetc&quot;&gt;std::getc&lt;/a&gt;&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="06557fdbe17d2e091891cc63144b53692b2f4c27" translate="yes" xml:space="preserve">
          <source>C++ attribute: carries_dependency (since C++11)</source>
          <target state="translated">Atributo de C++:carries_dependency (desde C++11)</target>
        </trans-unit>
        <trans-unit id="3a80c78aa3d0be4365d4a4aace53df1894fafefe" translate="yes" xml:space="preserve">
          <source>C++ attribute: deprecated (since C++14)</source>
          <target state="translated">Atributo de C++:desaprobado (desde C++14)</target>
        </trans-unit>
        <trans-unit id="ad4b4ad5889a95c53ae7ededcaefccd580e10788" translate="yes" xml:space="preserve">
          <source>C++ attribute: expects, ensures, assert (C++20)</source>
          <target state="translated">Atributo C++:espera,asegura,afirma (C++20)</target>
        </trans-unit>
        <trans-unit id="1f01e78c670736bcfbc7cbb131e20f9036aefa35" translate="yes" xml:space="preserve">
          <source>C++ attribute: fallthrough (since C++17)</source>
          <target state="translated">Atributo de C++:fallthrough (desde C++17)</target>
        </trans-unit>
        <trans-unit id="a55af33c93fad900d8f3c516df19e406f43533ff" translate="yes" xml:space="preserve">
          <source>C++ attribute: likely, unlikely (since C++20)</source>
          <target state="translated">Atributo de C++:probable,improbable (desde C++20)</target>
        </trans-unit>
        <trans-unit id="69ebed955bad0cdef08a090954f7632df7b64103" translate="yes" xml:space="preserve">
          <source>C++ attribute: maybe_unused (since C++17)</source>
          <target state="translated">Atributo de C++:maybe_unused (desde C++17)</target>
        </trans-unit>
        <trans-unit id="127add9901453ff701417a6b814f3ecc1b88d1ac" translate="yes" xml:space="preserve">
          <source>C++ attribute: no_unique_address (since C++20)</source>
          <target state="translated">Atributo de C++:no_unique_address (desde C++20)</target>
        </trans-unit>
        <trans-unit id="f9e91b3dd1ac40fbbb8928fd5021a1da6124dcb0" translate="yes" xml:space="preserve">
          <source>C++ attribute: nodiscard (since C++17)</source>
          <target state="translated">Atributo de C++:nodiscard (desde C++17)</target>
        </trans-unit>
        <trans-unit id="1f8de489858717f3061b65d4e3dae9adad203d70" translate="yes" xml:space="preserve">
          <source>C++ attribute: noreturn (since C++11)</source>
          <target state="translated">Atributo de C++:noreturn (desde C++11)</target>
        </trans-unit>
        <trans-unit id="387814363c5c1f906d9da1e85cb5bc67e4f38c05" translate="yes" xml:space="preserve">
          <source>C++ attribute: optimize_for_synchronized (TM TS)</source>
          <target state="translated">Atributo de C++:optimizar_para_sincronizar (TM TS)</target>
        </trans-unit>
        <trans-unit id="4583aeee6b4e07e7a7eb1f6b99f908d66bf96f40" translate="yes" xml:space="preserve">
          <source>C++ defines several function objects that represent common arithmetic and logical operations:</source>
          <target state="translated">C++define varios objetos de función que representan operaciones aritméticas y lógicas comunes:</target>
        </trans-unit>
        <trans-unit id="c67f57f6a26a137cf9bc71e8f9c5a5af0559e777" translate="yes" xml:space="preserve">
          <source>C++ includes a variety of utility libraries that provide functionality ranging from &lt;a href=&quot;utility/bitset&quot;&gt;bit-counting&lt;/a&gt; to &lt;a href=&quot;utility/functional/bind&quot;&gt;partial function application&lt;/a&gt;. These libraries can be broadly divided into two groups:</source>
          <target state="translated">C ++ incluye una variedad de bibliotecas de utilidades que proporcionan funcionalidades que van desde &lt;a href=&quot;utility/bitset&quot;&gt;el conteo&lt;/a&gt; de bits hasta &lt;a href=&quot;utility/functional/bind&quot;&gt;la aplicaci&amp;oacute;n de funciones parciales&lt;/a&gt; . Estas bibliotecas se pueden dividir ampliamente en dos grupos:</target>
        </trans-unit>
        <trans-unit id="76aad39fcff3282441a6d5280586f60940cc31a5" translate="yes" xml:space="preserve">
          <source>C++ includes built-in support for threads, mutual exclusion, condition variables, and futures.</source>
          <target state="translated">C++incluye soporte incorporado para hilos,exclusión mutua,variables de condición y futuros.</target>
        </trans-unit>
        <trans-unit id="3934f659aacbf1f001d3645344748b8c444cd791" translate="yes" xml:space="preserve">
          <source>C++ includes support for two types of time manipulation:</source>
          <target state="translated">C++incluye soporte para dos tipos de manipulación del tiempo:</target>
        </trans-unit>
        <trans-unit id="92a2c968a34da23e4708e71892c2ffb721fa839a" translate="yes" xml:space="preserve">
          <source>C++ includes the following types of statements:</source>
          <target state="translated">C++incluye los siguientes tipos de declaraciones:</target>
        </trans-unit>
        <trans-unit id="49dd66f99c3d0ac54dc62b7ee7eb01eca487493b" translate="yes" xml:space="preserve">
          <source>C++ includes two input/output libraries: a modern, stream-based I/O library and the standard set of C-style I/O functions.</source>
          <target state="translated">C++incluye dos bibliotecas de entrada/salida:una moderna biblioteca de E/S basada en flujos y el conjunto estándar de funciones de E/S de estilo C.</target>
        </trans-unit>
        <trans-unit id="e0e04efcb6a316f4e833950df1ac7962ec66959a" translate="yes" xml:space="preserve">
          <source>C++ keywords</source>
          <target state="translated">Palabras clave de C++</target>
        </trans-unit>
        <trans-unit id="3aee0b831c4708d12c9406617e0cc1e8018f2d74" translate="yes" xml:space="preserve">
          <source>C++ keywords: alignas (since C++11)</source>
          <target state="translated">Palabras clave de C++:alignas (desde C++11)</target>
        </trans-unit>
        <trans-unit id="29507b9a59ffc6150615d0d338bd1beb939dfad0" translate="yes" xml:space="preserve">
          <source>C++ keywords: alignof (since C++11)</source>
          <target state="translated">Palabras clave de C++:alignof (desde C++11)</target>
        </trans-unit>
        <trans-unit id="183b1dcdba07c3b1be4b49fab102e89c9a7de240" translate="yes" xml:space="preserve">
          <source>C++ keywords: and</source>
          <target state="translated">Palabras clave de C++:y</target>
        </trans-unit>
        <trans-unit id="3a6e38d19cc3dc2909a3faa576f245fdf6217690" translate="yes" xml:space="preserve">
          <source>C++ keywords: and_eq</source>
          <target state="translated">Palabras clave de C++:y_eq</target>
        </trans-unit>
        <trans-unit id="124a64afaa6c8c5bfca6047dd460511a6b97db33" translate="yes" xml:space="preserve">
          <source>C++ keywords: asm</source>
          <target state="translated">Palabras clave de C++:asm</target>
        </trans-unit>
        <trans-unit id="a0612d43a8ba92fee978df18206be3adce6458fa" translate="yes" xml:space="preserve">
          <source>C++ keywords: audit (since C++20)</source>
          <target state="translated">Palabras clave de C++:auditoría (desde C++20)</target>
        </trans-unit>
        <trans-unit id="b2ccdccd648a0f0a224169f56af64c5a94ea2b07" translate="yes" xml:space="preserve">
          <source>C++ keywords: auto</source>
          <target state="translated">Palabras clave de C++:auto</target>
        </trans-unit>
        <trans-unit id="526ec64f9498eb1229f0b99304e24893a3786743" translate="yes" xml:space="preserve">
          <source>C++ keywords: axiom (since C++20)</source>
          <target state="translated">Palabras clave de C++:axioma (desde C++20)</target>
        </trans-unit>
        <trans-unit id="163810b967745c12225f305e7e817d651df13205" translate="yes" xml:space="preserve">
          <source>C++ keywords: bitand</source>
          <target state="translated">Palabras clave de C++:bitand</target>
        </trans-unit>
        <trans-unit id="05bce8999813ae5f7d868f68ce64fcade539f423" translate="yes" xml:space="preserve">
          <source>C++ keywords: bitor</source>
          <target state="translated">Palabras clave de C++:bitor</target>
        </trans-unit>
        <trans-unit id="ba78f8f4b5950d9d7ebfc170c7afd751c59bdc1f" translate="yes" xml:space="preserve">
          <source>C++ keywords: bool</source>
          <target state="translated">Palabras clave de C++:bool</target>
        </trans-unit>
        <trans-unit id="d69d38c5fa6d513f4ee223cae0f80ada3cf1eb0b" translate="yes" xml:space="preserve">
          <source>C++ keywords: break</source>
          <target state="translated">Palabras clave de C++:romper</target>
        </trans-unit>
        <trans-unit id="1b869375d71945d8fecb773bf590ce8095cc4588" translate="yes" xml:space="preserve">
          <source>C++ keywords: case</source>
          <target state="translated">Palabras clave de C++:caso</target>
        </trans-unit>
        <trans-unit id="a7c81faed45b85c8dcd86de0734ee278e34df717" translate="yes" xml:space="preserve">
          <source>C++ keywords: catch</source>
          <target state="translated">Palabras clave de C++:atrapar</target>
        </trans-unit>
        <trans-unit id="fb289f167e01192a7926393875a6c8672f6c6f9e" translate="yes" xml:space="preserve">
          <source>C++ keywords: char</source>
          <target state="translated">Palabras clave de C++:char</target>
        </trans-unit>
        <trans-unit id="eacf79f3f8a785c01bc0ce19bb78a42fbe110d2b" translate="yes" xml:space="preserve">
          <source>C++ keywords: char16_t (since C++11)</source>
          <target state="translated">Palabras clave de C++:char16_t (desde C++11)</target>
        </trans-unit>
        <trans-unit id="d42a327c13fbb384479588185d9a50190dde3cf8" translate="yes" xml:space="preserve">
          <source>C++ keywords: char32_t (since C++11)</source>
          <target state="translated">Palabras clave de C++:char32_t (desde C++11)</target>
        </trans-unit>
        <trans-unit id="e2545bdc74a2da147dd1af1123e6aa8edbc09e87" translate="yes" xml:space="preserve">
          <source>C++ keywords: char8_t (since C++20)</source>
          <target state="translated">Palabras clave de C++:char8_t (desde C++20)</target>
        </trans-unit>
        <trans-unit id="c2ebb8c0d088a0587ab8ccaeece91bd9e176a491" translate="yes" xml:space="preserve">
          <source>C++ keywords: class</source>
          <target state="translated">Palabras clave de C++:clase</target>
        </trans-unit>
        <trans-unit id="29b898e1bb17af4eedf763c0844dd1fbb1bdd22d" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_await</source>
          <target state="translated">C++palabras clave:co_await</target>
        </trans-unit>
        <trans-unit id="16a636816ed7f754d904e9002adf34e537a3bbfa" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_return</source>
          <target state="translated">Palabras clave de C++:co_retorno</target>
        </trans-unit>
        <trans-unit id="33bc95e36c6779fdbd2d85867f4c0f747ae853fe" translate="yes" xml:space="preserve">
          <source>C++ keywords: co_yield</source>
          <target state="translated">Palabras clave de C++:co_yield</target>
        </trans-unit>
        <trans-unit id="01848e98ae4887d344100accfb0dc0f687fda24d" translate="yes" xml:space="preserve">
          <source>C++ keywords: compl</source>
          <target state="translated">Palabras clave de C++:compl</target>
        </trans-unit>
        <trans-unit id="6f9e6b0ca42a7a44125068643d4aeacd6ed22adc" translate="yes" xml:space="preserve">
          <source>C++ keywords: concept</source>
          <target state="translated">Palabras clave de C++:concepto</target>
        </trans-unit>
        <trans-unit id="26d8438420078942bafe0fcabb0f3a9ff8f21c57" translate="yes" xml:space="preserve">
          <source>C++ keywords: const</source>
          <target state="translated">Palabras clave de C++:const</target>
        </trans-unit>
        <trans-unit id="69601052b6f31cbc68f401b4565ce386a65a23c2" translate="yes" xml:space="preserve">
          <source>C++ keywords: const_cast</source>
          <target state="translated">C++palabras clave:const_cast</target>
        </trans-unit>
        <trans-unit id="bf6dfea8cb8956898c49e4b94e6e3b12224c1209" translate="yes" xml:space="preserve">
          <source>C++ keywords: consteval</source>
          <target state="translated">Palabras clave de C++:consteval</target>
        </trans-unit>
        <trans-unit id="527aef1fbeeb02aed3a5fdbfc85d582ce0f515aa" translate="yes" xml:space="preserve">
          <source>C++ keywords: constexpr (since C++11)</source>
          <target state="translated">Palabras clave de C++:constexpr (desde C++11)</target>
        </trans-unit>
        <trans-unit id="395fd0f15c5d8fac44a7288a59ea5a86379a156b" translate="yes" xml:space="preserve">
          <source>C++ keywords: continue</source>
          <target state="translated">Palabras clave de C++:continuar</target>
        </trans-unit>
        <trans-unit id="36bf9192492d110977874a62802f3f0cbf1c7005" translate="yes" xml:space="preserve">
          <source>C++ keywords: decltype</source>
          <target state="translated">Palabras clave de C++:decltype</target>
        </trans-unit>
        <trans-unit id="f30dc791d0616219ea0defdde70ed1cfef4ff5c8" translate="yes" xml:space="preserve">
          <source>C++ keywords: default</source>
          <target state="translated">Palabras clave de C++:por defecto</target>
        </trans-unit>
        <trans-unit id="94d1f98ddc77ffbdfd69b93ceca8b8d435110d3c" translate="yes" xml:space="preserve">
          <source>C++ keywords: delete</source>
          <target state="translated">Palabras clave de C++:borrar</target>
        </trans-unit>
        <trans-unit id="2fec1767b7b69a4a327e04a5a4c3a4f27379bdd2" translate="yes" xml:space="preserve">
          <source>C++ keywords: do</source>
          <target state="translated">Palabras clave de C++:do</target>
        </trans-unit>
        <trans-unit id="7bafac1a9bd6cde00b59ed3cdcbd753151e0a51a" translate="yes" xml:space="preserve">
          <source>C++ keywords: double</source>
          <target state="translated">Palabras clave de C++:doble</target>
        </trans-unit>
        <trans-unit id="0b4a595b8bfbe949f6ca15f733e9e13331a42383" translate="yes" xml:space="preserve">
          <source>C++ keywords: dynamic_cast</source>
          <target state="translated">Palabras clave de C++:dynamic_cast</target>
        </trans-unit>
        <trans-unit id="b32114b3f766f8a6739a7358915b26ea1b71457a" translate="yes" xml:space="preserve">
          <source>C++ keywords: else</source>
          <target state="translated">Palabras clave de C++:más</target>
        </trans-unit>
        <trans-unit id="9917c70089a8094b6d2fbb8e852e373f906a704b" translate="yes" xml:space="preserve">
          <source>C++ keywords: enum</source>
          <target state="translated">Palabras clave de C++:enum</target>
        </trans-unit>
        <trans-unit id="d544a09b352faa3a994cc54ccff972a5a3cb000b" translate="yes" xml:space="preserve">
          <source>C++ keywords: explicit</source>
          <target state="translated">Palabras clave de C++:explícito</target>
        </trans-unit>
        <trans-unit id="3c3210a8eec85af05733531fd5df52b05cdd6aa9" translate="yes" xml:space="preserve">
          <source>C++ keywords: export</source>
          <target state="translated">Palabras clave de C++:exportación</target>
        </trans-unit>
        <trans-unit id="de55ab46e46dffbf77fad964ecd27e3f0d9ef421" translate="yes" xml:space="preserve">
          <source>C++ keywords: extern</source>
          <target state="translated">Palabras clave de C++:externo</target>
        </trans-unit>
        <trans-unit id="e57865b70fcda2180074588769785ddc1a36b1c4" translate="yes" xml:space="preserve">
          <source>C++ keywords: false</source>
          <target state="translated">Palabras clave de C++:falso</target>
        </trans-unit>
        <trans-unit id="a700071e23581008cd76b45c2c69fea512ecb640" translate="yes" xml:space="preserve">
          <source>C++ keywords: final (since C++11)</source>
          <target state="translated">Palabras clave de C++:final (desde C++11)</target>
        </trans-unit>
        <trans-unit id="d02f9afd3fb00647e6a8e3424d891ceecd47fa78" translate="yes" xml:space="preserve">
          <source>C++ keywords: float</source>
          <target state="translated">Palabras clave de C++:flotar</target>
        </trans-unit>
        <trans-unit id="a5cd84453036526e60fa4e42dda9e069ff310fd3" translate="yes" xml:space="preserve">
          <source>C++ keywords: for</source>
          <target state="translated">Palabras clave de C++:para</target>
        </trans-unit>
        <trans-unit id="48f95d56f056fed8728e03635e48afcd5b420407" translate="yes" xml:space="preserve">
          <source>C++ keywords: friend</source>
          <target state="translated">C++palabras clave:amigo</target>
        </trans-unit>
        <trans-unit id="1e68fa94e046f072a7ff1b219e912a351a979625" translate="yes" xml:space="preserve">
          <source>C++ keywords: goto</source>
          <target state="translated">Palabras clave de C++:goto</target>
        </trans-unit>
        <trans-unit id="4725b0f2dcc6d3119ce93a5f3e3d49658b9f6ae7" translate="yes" xml:space="preserve">
          <source>C++ keywords: if</source>
          <target state="translated">Palabras clave de C++:si</target>
        </trans-unit>
        <trans-unit id="e499739fb3e6977144ad9e1eeb2e5bc4a8ddc540" translate="yes" xml:space="preserve">
          <source>C++ keywords: inline</source>
          <target state="translated">Palabras clave de C++:en línea</target>
        </trans-unit>
        <trans-unit id="b3fd1b872d293865c0aefeed8e6183dd1c548684" translate="yes" xml:space="preserve">
          <source>C++ keywords: int</source>
          <target state="translated">Palabras clave de C++:int</target>
        </trans-unit>
        <trans-unit id="c27210515d0813a21164dfce05ea3be2f9ae3b66" translate="yes" xml:space="preserve">
          <source>C++ keywords: long</source>
          <target state="translated">Palabras clave de C++:largo</target>
        </trans-unit>
        <trans-unit id="4d43f4cb276936dd386b3bd9758fc75c328cc95f" translate="yes" xml:space="preserve">
          <source>C++ keywords: mutable</source>
          <target state="translated">Palabras clave de C++:mutable</target>
        </trans-unit>
        <trans-unit id="b02800bd96f0d61d78a098b7b68899cdbbd6afe6" translate="yes" xml:space="preserve">
          <source>C++ keywords: namespace</source>
          <target state="translated">Palabras clave de C++:namespace</target>
        </trans-unit>
        <trans-unit id="4f9a52b4836fa43713e1e3fa4d56214068cc8def" translate="yes" xml:space="preserve">
          <source>C++ keywords: new</source>
          <target state="translated">Palabras clave de C++:nuevo</target>
        </trans-unit>
        <trans-unit id="9c0ca031ba0d25429ecf94970709e58032f30ab8" translate="yes" xml:space="preserve">
          <source>C++ keywords: noexcept (since C++11)</source>
          <target state="translated">Palabras clave de C++:noexcepto (desde C++11)</target>
        </trans-unit>
        <trans-unit id="c89b31c825167c40b35e37235a165123fdf5b4e4" translate="yes" xml:space="preserve">
          <source>C++ keywords: not</source>
          <target state="translated">Palabras clave de C++:no</target>
        </trans-unit>
        <trans-unit id="3cc0c7490348f3b3ba14089762bd72de7bd639ce" translate="yes" xml:space="preserve">
          <source>C++ keywords: not_eq</source>
          <target state="translated">Palabras clave de C++:not_eq</target>
        </trans-unit>
        <trans-unit id="b19ba534185a30e68c38be176f0412bc1f2bc6b5" translate="yes" xml:space="preserve">
          <source>C++ keywords: nullptr (since C++11)</source>
          <target state="translated">Palabras clave de C++:nullptr (desde C++11)</target>
        </trans-unit>
        <trans-unit id="70814bfe02a7af8b95ce36bc95a7da1123095a6a" translate="yes" xml:space="preserve">
          <source>C++ keywords: operator</source>
          <target state="translated">Palabras clave de C++:operador</target>
        </trans-unit>
        <trans-unit id="c23df376605d78f63a5500160b48ee512157ad7c" translate="yes" xml:space="preserve">
          <source>C++ keywords: or</source>
          <target state="translated">Palabras clave de C++:o</target>
        </trans-unit>
        <trans-unit id="d20cac1ee4d77d9ffa9e5793ad0383aa3ad51475" translate="yes" xml:space="preserve">
          <source>C++ keywords: or_eq</source>
          <target state="translated">Palabras clave de C++:or_eq</target>
        </trans-unit>
        <trans-unit id="8a0293371d55246ce973ae3e75626127f1504b6a" translate="yes" xml:space="preserve">
          <source>C++ keywords: override (since C++11)</source>
          <target state="translated">Palabras clave de C++:anular (desde C++11)</target>
        </trans-unit>
        <trans-unit id="03786ae3b9f628796529d09b809dbfc8b46793fe" translate="yes" xml:space="preserve">
          <source>C++ keywords: private</source>
          <target state="translated">Palabras clave de C++:privado</target>
        </trans-unit>
        <trans-unit id="df7d4ea5bc32cb787a6f750294cd5227c2fcd0d1" translate="yes" xml:space="preserve">
          <source>C++ keywords: protected</source>
          <target state="translated">Palabras clave de C++:protegido</target>
        </trans-unit>
        <trans-unit id="bfab844551173e61ef5a9ab220a29b66c69734b6" translate="yes" xml:space="preserve">
          <source>C++ keywords: public</source>
          <target state="translated">Palabras clave de C++:público</target>
        </trans-unit>
        <trans-unit id="1f1f72ef9a8c96008d1a90280fd58c243aa19f0b" translate="yes" xml:space="preserve">
          <source>C++ keywords: register</source>
          <target state="translated">Palabras clave C++:registro</target>
        </trans-unit>
        <trans-unit id="cd98a0128d90a9233e207ec1405b9a7e57585055" translate="yes" xml:space="preserve">
          <source>C++ keywords: reinterpret_cast</source>
          <target state="translated">Palabras clave de C++:reinterpretar_cast</target>
        </trans-unit>
        <trans-unit id="e57ca4acf8809388dce3238247eb7aa0f55ae138" translate="yes" xml:space="preserve">
          <source>C++ keywords: requires</source>
          <target state="translated">Palabras clave de C++:requiere</target>
        </trans-unit>
        <trans-unit id="1abcca2b0e66ee60c977a4e5782dd98d5b4d457d" translate="yes" xml:space="preserve">
          <source>C++ keywords: return</source>
          <target state="translated">Palabras clave de C++:retorno</target>
        </trans-unit>
        <trans-unit id="4b1adaad1115bcff0759ad4794ff292ed78b3c23" translate="yes" xml:space="preserve">
          <source>C++ keywords: short</source>
          <target state="translated">Palabras clave de C++:corto</target>
        </trans-unit>
        <trans-unit id="7bd3bfdfb2f3297c5564232cb8f3314290cdc7cf" translate="yes" xml:space="preserve">
          <source>C++ keywords: signed</source>
          <target state="translated">Palabras clave de C++:firmado</target>
        </trans-unit>
        <trans-unit id="4ff280c7a565563348f26be8d65133c336d662d3" translate="yes" xml:space="preserve">
          <source>C++ keywords: sizeof</source>
          <target state="translated">Palabras clave de C++:tamaño</target>
        </trans-unit>
        <trans-unit id="1a6d44df359c5334d919f430e3f3a4ac0d088d64" translate="yes" xml:space="preserve">
          <source>C++ keywords: static</source>
          <target state="translated">Palabras clave de C++:estático</target>
        </trans-unit>
        <trans-unit id="94bea4546792cb644fbf90e8a6f9c16d09f62ef3" translate="yes" xml:space="preserve">
          <source>C++ keywords: static_assert (since C++11)</source>
          <target state="translated">Palabras clave de C++:static_assert (desde C++11)</target>
        </trans-unit>
        <trans-unit id="72096556dc877cb5f85ffd02a8ca80027a3dd3aa" translate="yes" xml:space="preserve">
          <source>C++ keywords: static_cast</source>
          <target state="translated">Palabras clave de C++:static_cast</target>
        </trans-unit>
        <trans-unit id="b2fb75279739ad8e2dec4f932c10feab705444ec" translate="yes" xml:space="preserve">
          <source>C++ keywords: struct</source>
          <target state="translated">Palabras clave de C++:estructura</target>
        </trans-unit>
        <trans-unit id="1d55fcffd470c877223faca7c22ebb0001352b9e" translate="yes" xml:space="preserve">
          <source>C++ keywords: switch</source>
          <target state="translated">Palabras clave de C++:cambiar</target>
        </trans-unit>
        <trans-unit id="8a86cf3a93c4b52678e6d0617edc0697e04f2ca0" translate="yes" xml:space="preserve">
          <source>C++ keywords: template</source>
          <target state="translated">Palabras clave de C++:plantilla</target>
        </trans-unit>
        <trans-unit id="917e6e9b4ef5b0862e8ac7fdc4490ad8424f619e" translate="yes" xml:space="preserve">
          <source>C++ keywords: this</source>
          <target state="translated">Palabras clave de C++:esto</target>
        </trans-unit>
        <trans-unit id="7be930465dc63b127e9244e46b51e76cf2df9d25" translate="yes" xml:space="preserve">
          <source>C++ keywords: thread_local (since C++11)</source>
          <target state="translated">Palabras clave de C++:thread_local (desde C++11)</target>
        </trans-unit>
        <trans-unit id="b6e56566966d5710214d6f3ea6c95ab6c44200df" translate="yes" xml:space="preserve">
          <source>C++ keywords: throw</source>
          <target state="translated">Palabras clave de C++:lanzar</target>
        </trans-unit>
        <trans-unit id="0044cc96e436f4b21ecd72cd8dfbd5e16f91d829" translate="yes" xml:space="preserve">
          <source>C++ keywords: true</source>
          <target state="translated">Palabras clave de C++:verdadero</target>
        </trans-unit>
        <trans-unit id="98ac0c70a9cb341c8cd03989ea0fb7d75b0bb05a" translate="yes" xml:space="preserve">
          <source>C++ keywords: try</source>
          <target state="translated">Palabras clave de C++:probar</target>
        </trans-unit>
        <trans-unit id="ef86b57182f4ee052964937a9ab5e68c63c4ce5f" translate="yes" xml:space="preserve">
          <source>C++ keywords: typedef</source>
          <target state="translated">Palabras clave de C++:typedef</target>
        </trans-unit>
        <trans-unit id="454d53b90b0b8d7c3a3e8ad398ac791969143134" translate="yes" xml:space="preserve">
          <source>C++ keywords: typeid</source>
          <target state="translated">Palabras clave de C++:typeid</target>
        </trans-unit>
        <trans-unit id="f09f8d522055844ed39f38a10e8d3068231112c5" translate="yes" xml:space="preserve">
          <source>C++ keywords: typename</source>
          <target state="translated">Palabras clave de C++:nombre de pila</target>
        </trans-unit>
        <trans-unit id="e9cfe8a8699032565be2259c78cf9cf21c03061f" translate="yes" xml:space="preserve">
          <source>C++ keywords: union</source>
          <target state="translated">Palabras clave de C++:unión</target>
        </trans-unit>
        <trans-unit id="3a2039a0d25e07bab54ea79e32cbb688dd58e12e" translate="yes" xml:space="preserve">
          <source>C++ keywords: unsigned</source>
          <target state="translated">Palabras clave de C++:sin firmar</target>
        </trans-unit>
        <trans-unit id="8471d9f4d77d2e5eb14371c1da076716f02eaa32" translate="yes" xml:space="preserve">
          <source>C++ keywords: using</source>
          <target state="translated">Palabras clave de C++:usando</target>
        </trans-unit>
        <trans-unit id="ca2d0f00321b8103f435fd2b14b1924abd2dfb05" translate="yes" xml:space="preserve">
          <source>C++ keywords: virtual</source>
          <target state="translated">Palabras clave de C++:virtual</target>
        </trans-unit>
        <trans-unit id="624f83b1ecef18ff894e0bb447112f9f3014800a" translate="yes" xml:space="preserve">
          <source>C++ keywords: void</source>
          <target state="translated">Palabras clave de C++:vacío</target>
        </trans-unit>
        <trans-unit id="f78e5cc4134b90e370b281fe8d44693b1ec58e36" translate="yes" xml:space="preserve">
          <source>C++ keywords: volatile</source>
          <target state="translated">Palabras clave de C++:volátil</target>
        </trans-unit>
        <trans-unit id="9c61c84d1b44e56098d4c56e5048e58138e3fbc7" translate="yes" xml:space="preserve">
          <source>C++ keywords: wchar_t</source>
          <target state="translated">C++palabras clave:wchar_t</target>
        </trans-unit>
        <trans-unit id="2c909f57896904cc34b1cc4e253dd5d79ed3ab7b" translate="yes" xml:space="preserve">
          <source>C++ keywords: while</source>
          <target state="translated">Palabras clave de C++:mientras</target>
        </trans-unit>
        <trans-unit id="7b74b5079b0e1bc6b6d3a9df3f3dcaf748b4fdf4" translate="yes" xml:space="preserve">
          <source>C++ keywords: xor</source>
          <target state="translated">Palabras clave de C++:xor</target>
        </trans-unit>
        <trans-unit id="eb3705de2bf421a4730d1843c818dc31e4324286" translate="yes" xml:space="preserve">
          <source>C++ keywords: xor_eq</source>
          <target state="translated">Palabras clave de C++:xor_eq</target>
        </trans-unit>
        <trans-unit id="00d4296327feae05e7f754006f1f81e7b3df74e7" translate="yes" xml:space="preserve">
          <source>C++ language</source>
          <target state="translated">Lenguaje C++</target>
        </trans-unit>
        <trans-unit id="5c6e1f137cae8deef2fe086c3a40c23cb3abd95c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Allocator</source>
          <target state="translated">C++nombró los requisitos:Asignador</target>
        </trans-unit>
        <trans-unit id="68093762465efd54450ba8bcd9c0a91c4dbf0f1b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: AllocatorAwareContainer</source>
          <target state="translated">C++nombró los requisitos:AllocatorAwareContainer</target>
        </trans-unit>
        <trans-unit id="ab7ac32bec349da4c19ab2096d1b1255564f39b0" translate="yes" xml:space="preserve">
          <source>C++ named requirements: AssociativeContainer</source>
          <target state="translated">C++nombró los requisitos:AssociativeContainer</target>
        </trans-unit>
        <trans-unit id="bce38a21c7a5a1ec76fbe77837afdf562ff1649d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BasicLockable</source>
          <target state="translated">C++nombró los requisitos:BasicLockable</target>
        </trans-unit>
        <trans-unit id="e1a9abc4c52e314d687b58fdfa28003600137949" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BinaryPredicate</source>
          <target state="translated">C++nombró los requisitos:BinaryPredicate</target>
        </trans-unit>
        <trans-unit id="77f706b668a619259c5204b16d231a4b5f303147" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BinaryTypeTrait</source>
          <target state="translated">C++nombró los requisitos:BinaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="2dac169f409edf4d6004eeef2aa80e3ce234acba" translate="yes" xml:space="preserve">
          <source>C++ named requirements: BitmaskType</source>
          <target state="translated">C++nombró los requisitos:BitmaskType</target>
        </trans-unit>
        <trans-unit id="3ac90618765ee9c85f861c53f0604fe5b1bece8f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Callable</source>
          <target state="translated">C++nombró los requisitos:Llamable</target>
        </trans-unit>
        <trans-unit id="ee45309ee631f97e8c54fdd32dd4c7314a219410" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CharTraits</source>
          <target state="translated">C++nombró los requisitos:CharTraits</target>
        </trans-unit>
        <trans-unit id="e49e0b2de04ceaac02567e3c466ce7f34aa9139b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Clock</source>
          <target state="translated">C++nombró los requisitos:Reloj</target>
        </trans-unit>
        <trans-unit id="03d4cd85a40261a51658ef8d686e3877be8fb96e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Compare</source>
          <target state="translated">C++nombró los requisitos:Compare</target>
        </trans-unit>
        <trans-unit id="ac0da8de55de872e9c67b652831ec7e483b09c3b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ConstexprIterator</source>
          <target state="translated">C++nombró los requisitos:ConstexprIterator</target>
        </trans-unit>
        <trans-unit id="d0267fe31b3826841ff7251625998f2fcb06717e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Container</source>
          <target state="translated">C++nombró los requisitos:Contenedor</target>
        </trans-unit>
        <trans-unit id="cf843c7d6d3dc3a137cc532583586f04e6c312a3" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ContiguousContainer</source>
          <target state="translated">C++nombró los requisitos:Contenedor contiguo</target>
        </trans-unit>
        <trans-unit id="8f039fec7eb71a74ef921bce40ef720e3e7301f7" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyAssignable</source>
          <target state="translated">C++nombró los requisitos:CopyAssignable</target>
        </trans-unit>
        <trans-unit id="a5a5a4d38564c8be046908e5b71fa8fc1c5617c2" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyConstructible</source>
          <target state="translated">C++nombró los requisitos:CopyConstructible</target>
        </trans-unit>
        <trans-unit id="8a6121d6fc5b64e9265c4080e5c5342c8e2ea499" translate="yes" xml:space="preserve">
          <source>C++ named requirements: CopyInsertable</source>
          <target state="translated">C++nombró los requisitos:CopyInsertable</target>
        </trans-unit>
        <trans-unit id="e0410f086a810b23ccfa34f4b0166c8fba23f310" translate="yes" xml:space="preserve">
          <source>C++ named requirements: DefaultConstructible</source>
          <target state="translated">C++nombró los requisitos:DefaultConstructible</target>
        </trans-unit>
        <trans-unit id="a0e9c4ff46f14ebb3f87a8006d8b76bdc0d3803b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: DefaultInsertable</source>
          <target state="translated">C++nombró los requisitos:DefaultInsertable</target>
        </trans-unit>
        <trans-unit id="5f0c828f8de0769b3ee1f87f72ae6283f03e4208" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Destructible</source>
          <target state="translated">C++nombró los requisitos:Destructible</target>
        </trans-unit>
        <trans-unit id="a3846bfd4ceb5970ead3569546441faa22d6f618" translate="yes" xml:space="preserve">
          <source>C++ named requirements: EmplaceConstructible (since C++11)</source>
          <target state="translated">C++nombró los requisitos:EmplaceConstruible (desde C++11)</target>
        </trans-unit>
        <trans-unit id="0f00c016cd8d60c879ed8f11a065a6cdb2245c1a" translate="yes" xml:space="preserve">
          <source>C++ named requirements: EqualityComparable</source>
          <target state="translated">C++nombró los requisitos:EqualityComparative</target>
        </trans-unit>
        <trans-unit id="a4bdf57055cd7c0dae92592574976fad30e86740" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Erasable</source>
          <target state="translated">C++nombró los requisitos:Borrable</target>
        </trans-unit>
        <trans-unit id="c9dce4c90e1ab07bd8e4f26bfd59c7bb93d2c13b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FormattedInputFunction</source>
          <target state="translated">C++nombró los requisitos:FormattedInputFunction</target>
        </trans-unit>
        <trans-unit id="78390db68319248607d73e238aa034d36af5547e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FormattedOutputFunction</source>
          <target state="translated">C++nombró los requisitos:FormattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="17341909637487f66a0a51420af28ebc0ff53f17" translate="yes" xml:space="preserve">
          <source>C++ named requirements: FunctionObject</source>
          <target state="translated">C++nombró los requisitos:FunctionObject</target>
        </trans-unit>
        <trans-unit id="83eafac0e33fd85d404291ef083b29a6c21e4bd5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Hash</source>
          <target state="translated">C++nombró los requisitos:Hash</target>
        </trans-unit>
        <trans-unit id="b7114351c4bbaa9528560ef257598f798ddb3de5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyBidirectionalIterator</source>
          <target state="translated">C++nombró los requisitos:LegacyBidirectionalIterator</target>
        </trans-unit>
        <trans-unit id="333591b546d46f2b2872fef1e1d696156e3d4da4" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyContiguousIterator</source>
          <target state="translated">C++nombró los requisitos:LegacyContiguousIterator</target>
        </trans-unit>
        <trans-unit id="49fdc557343b56a30b7a499efbbea9f6e8d5ea27" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyForwardIterator</source>
          <target state="translated">C++nombró los requisitos:LegacyForwardIterator</target>
        </trans-unit>
        <trans-unit id="b0ca593d796d2c1f1cdfea5aaaa5bcc718fed510" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyInputIterator</source>
          <target state="translated">C++nombró los requisitos:LegacyInputIterator</target>
        </trans-unit>
        <trans-unit id="daac43c9c4fb82513fe27e3efbdb288f38305a58" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyIterator</source>
          <target state="translated">C++nombró los requisitos:LegacyIterator</target>
        </trans-unit>
        <trans-unit id="491d2d06bd47da0deeddf998db8a57451119a47e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyOutputIterator</source>
          <target state="translated">C++nombró los requisitos:LegacyOutputIterator</target>
        </trans-unit>
        <trans-unit id="2bae53a7d3573b63c5126a51eeda215a90f01f27" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LegacyRandomAccessIterator</source>
          <target state="translated">C++nombró los requisitos:LegacyRandomAccessIterator</target>
        </trans-unit>
        <trans-unit id="234fc9eae136300c3a84df869801ddac1bc39e85" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LessThanComparable</source>
          <target state="translated">C++nombró los requisitos:LessThanComparable</target>
        </trans-unit>
        <trans-unit id="fa488eac6c38cb8817603703df4bd4bc17b5bc3c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: LiteralType</source>
          <target state="translated">C++nombró los requisitos:LiteralType</target>
        </trans-unit>
        <trans-unit id="7e27d143c2848bfc04da8fa00c12fc56eba98a8f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Lockable</source>
          <target state="translated">C++nombró los requisitos:Bloqueable</target>
        </trans-unit>
        <trans-unit id="ffa229dee12fb9a9290b1083466a57ea9ef88cb2" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveAssignable (since C++11)</source>
          <target state="translated">C++nombró los requisitos:MoveAssignable (desde C++11)</target>
        </trans-unit>
        <trans-unit id="3c7af72e00db75b25a6339c6bc85b14f40833ea5" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveConstructible (since C++11)</source>
          <target state="translated">C++nombró los requisitos:MoveConstructible (desde C++11)</target>
        </trans-unit>
        <trans-unit id="596d45856032c8c30536491e6532eb33250543a6" translate="yes" xml:space="preserve">
          <source>C++ named requirements: MoveInsertable (since C++11)</source>
          <target state="translated">C++nombró los requisitos:MoveInsertable (desde C++11)</target>
        </trans-unit>
        <trans-unit id="1c772f99ba3b1d592fe8bec17544a1e701895811" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Mutex</source>
          <target state="translated">C++nombró los requisitos:Mutex</target>
        </trans-unit>
        <trans-unit id="e88a54faa0bd94e7b4c8d3cd5b28da3afb45b924" translate="yes" xml:space="preserve">
          <source>C++ named requirements: NullablePointer (since C++11)</source>
          <target state="translated">C++nombró los requisitos:NullablePointer (desde C++11)</target>
        </trans-unit>
        <trans-unit id="dc4469e68ff2c5b54f8ee6d9e3f309ac6b21c5bb" translate="yes" xml:space="preserve">
          <source>C++ named requirements: NumericType</source>
          <target state="translated">C++nombró los requisitos:NumericType</target>
        </trans-unit>
        <trans-unit id="c535b9a77f5571dd0ffba42bac2b8d4ab54373c3" translate="yes" xml:space="preserve">
          <source>C++ named requirements: PODType</source>
          <target state="translated">C++nombró los requisitos:PODType</target>
        </trans-unit>
        <trans-unit id="f8a0530ac14d26f5e08f4d837ff5542a4988b36d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Predicate</source>
          <target state="translated">C++nombró los requisitos:Predicar</target>
        </trans-unit>
        <trans-unit id="84db291a7430e53241b723b9cdb6f5c57cf85f43" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberDistribution</source>
          <target state="translated">C++nombró los requisitos:RandomNumberDistribution</target>
        </trans-unit>
        <trans-unit id="16dd49ad42be796cea9fe6814de48219bd526a22" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberEngine</source>
          <target state="translated">C++nombró los requisitos:RandomNumberEngine</target>
        </trans-unit>
        <trans-unit id="57db25a8dd2fe59f88627a14f0d9f4454923652f" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RandomNumberEngineAdaptor</source>
          <target state="translated">C++nombró los requisitos:RandomNumberEngineAdaptor</target>
        </trans-unit>
        <trans-unit id="ada05a46bb39c300a568907c930d2a57c5b9005d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: RegexTraits</source>
          <target state="translated">C++nombró los requisitos:RegexTraits</target>
        </trans-unit>
        <trans-unit id="016355c7ec2c0cd838b6de26f8a355d0c2f26913" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ReversibleContainer</source>
          <target state="translated">C++nombró los requisitos:Contenedor Reversible</target>
        </trans-unit>
        <trans-unit id="19a660b52b4b8c99460cfc9a560b03a16cf9cb42" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SeedSequence</source>
          <target state="translated">C++nombró los requisitos:SeedSequence</target>
        </trans-unit>
        <trans-unit id="331ae8b25a90d44993d56e79517cc81206e0068d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SequenceContainer</source>
          <target state="translated">C++nombró los requisitos:SequenceContainer</target>
        </trans-unit>
        <trans-unit id="5f9909d09bcc4eb0bdaada38cd2e514913d23668" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SharedMutex</source>
          <target state="translated">C++nombró los requisitos:SharedMutex</target>
        </trans-unit>
        <trans-unit id="f60730295a5aa0cd12e4416e599d5f966530ef4d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: SharedTimedMutex</source>
          <target state="translated">C++nombró los requisitos:SharedTimedMutex</target>
        </trans-unit>
        <trans-unit id="d03f73195120ea59f692bd306fc14c4f75ddea6e" translate="yes" xml:space="preserve">
          <source>C++ named requirements: StandardLayoutType</source>
          <target state="translated">C++nombró los requisitos:StandardLayoutType</target>
        </trans-unit>
        <trans-unit id="7c2afe9643847a18800f6549859cddf158aebfc0" translate="yes" xml:space="preserve">
          <source>C++ named requirements: Swappable</source>
          <target state="translated">C++nombró los requisitos:Intercambiable</target>
        </trans-unit>
        <trans-unit id="2699ee8a713e7d4efdc2e45280ccf4b85602bf33" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TimedLockable</source>
          <target state="translated">C++nombró los requisitos:TimedLockable</target>
        </trans-unit>
        <trans-unit id="e4b09ebf2a8a166fe825d2ef813341e3cf6c00c4" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TimedMutex</source>
          <target state="translated">C++nombró los requisitos:TimedMutex</target>
        </trans-unit>
        <trans-unit id="0f87af6136487f4529c077f27de7397f9b71930c" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TransformationTrait</source>
          <target state="translated">C++nombró los requisitos:TransformationTrait</target>
        </trans-unit>
        <trans-unit id="90ecc6e1cfa9c37cd7a9058209da8423a4e1b338" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TrivialClock</source>
          <target state="translated">C++nombró los requisitos:TrivialClock</target>
        </trans-unit>
        <trans-unit id="6e4be673e637f57a59a671d691fed257e408bde7" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TrivialType</source>
          <target state="translated">C++nombró los requisitos:TrivialType</target>
        </trans-unit>
        <trans-unit id="547fb3490fe494ac4547d562d1e3a4efcf9201ea" translate="yes" xml:space="preserve">
          <source>C++ named requirements: TriviallyCopyable</source>
          <target state="translated">C++nombró los requisitos:TriviallyCopyable</target>
        </trans-unit>
        <trans-unit id="5dbb493f4749a745c93c18f6210f4d60d51e03a6" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnaryTypeTrait</source>
          <target state="translated">C++nombró los requisitos:UnaryTypeTrait</target>
        </trans-unit>
        <trans-unit id="4994b5268d59d59fba759c4ba742ecf79924693a" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnformattedInputFunction</source>
          <target state="translated">C++nombró los requisitos:UnformattedInputFunction</target>
        </trans-unit>
        <trans-unit id="d5d9e9fb8d202091be5c90998db3426e13ad8496" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnformattedOutputFunction</source>
          <target state="translated">C++nombró los requisitos:UnformattedOutputFunction</target>
        </trans-unit>
        <trans-unit id="6e75c2aeea843d06f31a9ca2caeb62946537533d" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UniformRandomBitGenerator</source>
          <target state="translated">C++nombró los requisitos:UniformRandomBitGenerator</target>
        </trans-unit>
        <trans-unit id="87ad5436e94ce7e8b55c4f29d6f5a45aad21cf59" translate="yes" xml:space="preserve">
          <source>C++ named requirements: UnorderedAssociativeContainer</source>
          <target state="translated">C++nombró los requisitos:UnorderedAssociativeContainer</target>
        </trans-unit>
        <trans-unit id="15fe7066a6555232e049a6b5ae3a3b40fcc5e98b" translate="yes" xml:space="preserve">
          <source>C++ named requirements: ValueSwappable</source>
          <target state="translated">C++nombró los requisitos:ValueSwappable</target>
        </trans-unit>
        <trans-unit id="bb6995247feeb0031e28871e5d52bb0bde2f6ab2" translate="yes" xml:space="preserve">
          <source>C++ pragmas in Visual Studio 2015</source>
          <target state="translated">C++pragmas en Visual Studio 2015</target>
        </trans-unit>
        <trans-unit id="7b72da128624ab00dbe11304128e495f5b161352" translate="yes" xml:space="preserve">
          <source>C++ programs create, destroy, refer to, access, and manipulate</source>
          <target state="translated">Los programas de C++crean,destruyen,consultan,acceden y manipulan</target>
        </trans-unit>
        <trans-unit id="cc223fe085208876202452b5634bdb87b28fe03f" translate="yes" xml:space="preserve">
          <source>C++ standard</source>
          <target state="translated">Estándar C++</target>
        </trans-unit>
        <trans-unit id="1a70571302b7aef91f6a1709d3bff98dbbe103cc" translate="yes" xml:space="preserve">
          <source>C++ time utilites</source>
          <target state="translated">Utilidades de tiempo en C++</target>
        </trans-unit>
        <trans-unit id="4ae06f5fc59967a95d7d2edd41265fb164cde198" translate="yes" xml:space="preserve">
          <source>C++ type system overview</source>
          <target state="translated">Visión general del sistema de tipo C</target>
        </trans-unit>
        <trans-unit id="59267432adf8c9336c020edab8c6d1687c5a8555" translate="yes" xml:space="preserve">
          <source>C++-style</source>
          <target state="translated">C++-style</target>
        </trans-unit>
        <trans-unit id="741b2c379deb40170659b19eb9ef222dbd5fa167" translate="yes" xml:space="preserve">
          <source>C++-style comments are usually used to comment single lines, however, multiple C++-style comments can be placed together to form multi-line comments. C++-style comments tell the compiler to ignore all content between &lt;code&gt;//&lt;/code&gt; and a new line.</source>
          <target state="translated">Los comentarios de estilo C ++ generalmente se usan para comentar l&amp;iacute;neas individuales, sin embargo, se pueden colocar varios comentarios de estilo C ++ juntos para formar comentarios de varias l&amp;iacute;neas. Los comentarios de estilo C ++ le dicen al compilador que ignore todo el contenido entre &lt;code&gt;//&lt;/code&gt; y una nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="59fa0388313caf4655070a0038f68ffbc408c139" translate="yes" xml:space="preserve">
          <source>C++03</source>
          <target state="translated">C++03</target>
        </trans-unit>
        <trans-unit id="afd7c0601f217ac99e680979ea51cdb99e023353" translate="yes" xml:space="preserve">
          <source>C++03 POD with deleted non-trivial assignment was not trivial</source>
          <target state="translated">C++03 POD con asignación no trivial suprimida no era trivial</target>
        </trans-unit>
        <trans-unit id="d030954e126ef3cc7aa28e489ff18c492566d17e" translate="yes" xml:space="preserve">
          <source>C++03 standard (ISO/IEC 14882:2003):</source>
          <target state="translated">Norma C++03 (ISO/IEC 14882:2003):</target>
        </trans-unit>
        <trans-unit id="aa182f32a2b889bab8bb654d1c6efd34ac494dd1" translate="yes" xml:space="preserve">
          <source>C++11</source>
          <target state="translated">C++11</target>
        </trans-unit>
        <trans-unit id="eb6204614cbf77403cd382a95e0f929788c6393d" translate="yes" xml:space="preserve">
          <source>C++11 (class type)</source>
          <target state="translated">C++11 (tipo de clase)</target>
        </trans-unit>
        <trans-unit id="bca730909e080a8fc13db2273be471dfdb358b21" translate="yes" xml:space="preserve">
          <source>C++11 standard (ISO/IEC 14882:2011):</source>
          <target state="translated">Norma C++11 (ISO/IEC 14882:2011):</target>
        </trans-unit>
        <trans-unit id="526d8c7b1c46f07481431485812086e8bde79cad" translate="yes" xml:space="preserve">
          <source>C++14</source>
          <target state="translated">C++14</target>
        </trans-unit>
        <trans-unit id="3cf652fe8eeb36408d7f957624dd1e5feb276abf" translate="yes" xml:space="preserve">
          <source>C++14 (void)</source>
          <target state="translated">C++14 (vacío)</target>
        </trans-unit>
        <trans-unit id="451b62af75ef22e7c1ee3794a50c6a6c3fdd7f7e" translate="yes" xml:space="preserve">
          <source>C++14 standard (ISO/IEC 14882:2014):</source>
          <target state="translated">Norma C++14 (ISO/IEC 14882:2014):</target>
        </trans-unit>
        <trans-unit id="69ae287a1096db334e322d2404e3cd62fc5f7016" translate="yes" xml:space="preserve">
          <source>C++17</source>
          <target state="translated">C++17</target>
        </trans-unit>
        <trans-unit id="4c20ccb3f39c8ffe021987c4ad44fbb012e0262a" translate="yes" xml:space="preserve">
          <source>C++17 standard (ISO/IEC 14882:2017):</source>
          <target state="translated">Norma C++17 (ISO/IEC 14882:2017):</target>
        </trans-unit>
        <trans-unit id="9f0db8e1214a8ccf376f0bc5ba61385a18fbb5cc" translate="yes" xml:space="preserve">
          <source>C++20 defines a set of &lt;a href=&quot;../language/constraints&quot;&gt;constrained&lt;/a&gt; comparison function objects. The equality operators (&lt;code&gt;ranges::equal_to&lt;/code&gt; and &lt;code&gt;ranges::not_equal_to&lt;/code&gt;) require the types of the arguments to model &lt;a href=&quot;../concepts/equalitycomparable&quot;&gt;&lt;code&gt;EqualityComparableWith&lt;/code&gt;&lt;/a&gt;. The relational operators (&lt;code&gt;ranges::less&lt;/code&gt;, &lt;code&gt;ranges::greater&lt;/code&gt;, &lt;code&gt;ranges::less_equal&lt;/code&gt;, and &lt;code&gt;ranges::greater_equal&lt;/code&gt;) require the types of the arguments to model &lt;a href=&quot;../concepts/stricttotallyordered&quot;&gt;&lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">C ++ 20 define un conjunto de objetos de funci&amp;oacute;n de comparaci&amp;oacute;n &lt;a href=&quot;../language/constraints&quot;&gt;restringidos&lt;/a&gt; . Los operadores de igualdad ( &lt;code&gt;ranges::equal_to&lt;/code&gt; y &lt;code&gt;ranges::not_equal_to&lt;/code&gt; ) requieren los tipos de argumentos para modelar &lt;a href=&quot;../concepts/equalitycomparable&quot;&gt; &lt;code&gt;EqualityComparableWith&lt;/code&gt; &lt;/a&gt; . Los operadores relacionales ( &lt;code&gt;ranges::less&lt;/code&gt; , &lt;code&gt;ranges::greater&lt;/code&gt; , &lt;code&gt;ranges::less_equal&lt;/code&gt; y &lt;code&gt;ranges::greater_equal&lt;/code&gt; ) requieren los tipos de argumentos para modelar &lt;a href=&quot;../concepts/stricttotallyordered&quot;&gt; &lt;code&gt;StrictTotallyOrderedWith&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05eb29d2d943895480cbf23e5a4b02a727a6e2db" translate="yes" xml:space="preserve">
          <source>C++20 introduces a new system of iterators based on &lt;a href=&quot;language/constraints&quot;&gt;concepts&lt;/a&gt; that are different from C++17 iterators. While the basic taxonomy remains similar, the requirements for individual iterator categories are somewhat different.</source>
          <target state="translated">C ++ 20 presenta un nuevo sistema de iteradores basado en &lt;a href=&quot;language/constraints&quot;&gt;conceptos&lt;/a&gt; que son diferentes de los iteradores de C ++ 17. Si bien la taxonom&amp;iacute;a b&amp;aacute;sica sigue siendo similar, los requisitos para las categor&amp;iacute;as de iteradores individuales son algo diferentes.</target>
        </trans-unit>
        <trans-unit id="2e528f3cc4d3fc3ca8b281cef54dbb5b071d694e" translate="yes" xml:space="preserve">
          <source>C++20 iterator concepts</source>
          <target state="translated">Conceptos del iterador C++20</target>
        </trans-unit>
        <trans-unit id="098b2706a0a08c620a10641456b665a828dbc0fa" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;../language/constraints&quot;&gt;constrained&lt;/a&gt; versions of most algorithms in the namespace &lt;code&gt;std::ranges&lt;/code&gt;. In these algorithms, a range can be specified as either a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;-&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt;&lt;/a&gt; pair or as a single &lt;a href=&quot;../ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument, and projections and pointer-to-member callables are supported. Additionally, the return type of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.</source>
          <target state="translated">C ++ 20 proporciona versiones &lt;a href=&quot;../language/constraints&quot;&gt;restringidas&lt;/a&gt; de la mayor&amp;iacute;a de los algoritmos en el espacio de nombres &lt;code&gt;std::ranges&lt;/code&gt; . En estos algoritmos, un rango puede especificarse como un par &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; - &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Sentinel&lt;/code&gt; &lt;/a&gt; o como un solo argumento de &lt;a href=&quot;../ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , y se admiten proyecciones y callables de puntero a miembro. Adem&amp;aacute;s, el tipo de retorno de la mayor&amp;iacute;a de los algoritmos se ha cambiado para devolver toda la informaci&amp;oacute;n potencialmente &amp;uacute;til calculada durante la ejecuci&amp;oacute;n del algoritmo.</target>
        </trans-unit>
        <trans-unit id="1e947bf13606a87a8b5513ba351822e6dad8eca6" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;language/constraints&quot;&gt;constrained&lt;/a&gt; uninitialized memory algorithms that accept range arguments or iterator-sentinel pairs.</source>
          <target state="translated">C ++ 20 proporciona algoritmos de memoria no inicializados &lt;a href=&quot;language/constraints&quot;&gt;restringidos&lt;/a&gt; que aceptan argumentos de rango o pares de iterador-centinela.</target>
        </trans-unit>
        <trans-unit id="02dac318248d623e3712f39050dab4b9f4c60683" translate="yes" xml:space="preserve">
          <source>C++20 provides &lt;a href=&quot;language/constraints&quot;&gt;constrained&lt;/a&gt; versions of most algorithms in the namespace &lt;code&gt;std::ranges&lt;/code&gt;. In these algorithms, a range can be specified as either an &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Iterator&lt;/code&gt;&lt;/a&gt;-&lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Sentinel&lt;/code&gt;&lt;/a&gt; pair or as a single &lt;a href=&quot;ranges/range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; argument, and projections and pointer-to-member callables are supported. Additionally, the return types of most algorithms have been changed to return all potentially useful information computed during the execution of the algorithm.</source>
          <target state="translated">C ++ 20 proporciona versiones &lt;a href=&quot;language/constraints&quot;&gt;restringidas&lt;/a&gt; de la mayor&amp;iacute;a de los algoritmos en el espacio de nombres &lt;code&gt;std::ranges&lt;/code&gt; . En estos algoritmos, un rango puede especificarse como un par &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Iterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Iterator&lt;/code&gt; &lt;/a&gt; - &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Sentinel&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Sentinel&lt;/code&gt; &lt;/a&gt; o como un solo argumento de &lt;a href=&quot;ranges/range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; , y se admiten proyecciones y callables de puntero a miembro. Adem&amp;aacute;s, los tipos de retorno de la mayor&amp;iacute;a de los algoritmos se han cambiado para devolver toda la informaci&amp;oacute;n potencialmente &amp;uacute;til calculada durante la ejecuci&amp;oacute;n del algoritmo.</target>
        </trans-unit>
        <trans-unit id="b22ed7e9c883004117343b0e71726914a2fd2287" translate="yes" xml:space="preserve">
          <source>C++98</source>
          <target state="translated">C++98</target>
        </trans-unit>
        <trans-unit id="ba0489b5be9b76c42ad4405b0950fd7062f9aa6d" translate="yes" xml:space="preserve">
          <source>C++98 standard (ISO/IEC 14882:1998):</source>
          <target state="translated">Norma C++98 (ISO/IEC 14882:1998):</target>
        </trans-unit>
        <trans-unit id="f192047d0579fa733e3007a4b4927c4192eec128" translate="yes" xml:space="preserve">
          <source>C, but C precedes A in the single total order C-E-F-A of &lt;code&gt;memory_order_seq_cst&lt;/code&gt; (see &lt;a href=&quot;https://plv.mpi-sws.org/scfix/paper.pdf&quot;&gt;Lahav et al&lt;/a&gt;).</source>
          <target state="translated">C, pero C precede a A en el CEFA de orden total &amp;uacute;nico de &lt;code&gt;memory_order_seq_cst&lt;/code&gt; (ver &lt;a href=&quot;https://plv.mpi-sws.org/scfix/paper.pdf&quot;&gt;Lahav et al&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="f56f539774c9129a13109892792a99de9ce3ec15" translate="yes" xml:space="preserve">
          <source>C-string or char array to use as the contents of the stream</source>
          <target state="translated">Cuerda-C o matriz de caracteres para usar como el contenido de la corriente</target>
        </trans-unit>
        <trans-unit id="bd39761895022d52ef2184edffb0689497519cb3" translate="yes" xml:space="preserve">
          <source>C-style</source>
          <target state="translated">C-style</target>
        </trans-unit>
        <trans-unit id="7526d60a0c8e276994609ec345feddbe30ee8465" translate="yes" xml:space="preserve">
          <source>C-style &lt;a href=&quot;string/multibyte&quot;&gt; Unicode character conversion functions&lt;/a&gt;</source>
          <target state="translated">&lt;a href=&quot;string/multibyte&quot;&gt;Funciones de conversi&amp;oacute;n de caracteres Unicode de&lt;/a&gt; estilo C</target>
        </trans-unit>
        <trans-unit id="56a020c22140d662b6720ea7925672fd8f454173" translate="yes" xml:space="preserve">
          <source>C-style IO</source>
          <target state="translated">IO estilo C</target>
        </trans-unit>
        <trans-unit id="44c1448ec5b283e6541ef6028da691d71017b995" translate="yes" xml:space="preserve">
          <source>C-style cast</source>
          <target state="translated">Yeso de estilo C</target>
        </trans-unit>
        <trans-unit id="c2150e9d35b98ece63e7d4b63009872a56f2d872" translate="yes" xml:space="preserve">
          <source>C-style cast expression</source>
          <target state="translated">La expresión del molde en forma de C</target>
        </trans-unit>
        <trans-unit id="c663a9e8a239cedd93c5da9c15d557da154de974" translate="yes" xml:space="preserve">
          <source>C-style comments are usually used to comment large blocks of text, however, they can be used to comment single lines. To insert a C-style comment, simply surround text with &lt;code&gt;/*&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt;; this will cause the contents of the comment to be ignored by the compiler. Although it is not part of the C++ standard, &lt;code&gt;/**&lt;/code&gt; and &lt;code&gt;*/&lt;/code&gt; are often used to indicate documentation blocks; this is legal because the second asterisk is simply treated as part of the comment. C-style comments cannot be nested.</source>
          <target state="translated">Los comentarios de estilo C generalmente se usan para comentar grandes bloques de texto, sin embargo, se pueden usar para comentar l&amp;iacute;neas individuales. Para insertar un comentario de estilo C, simplemente rodee el texto con &lt;code&gt;/*&lt;/code&gt; y &lt;code&gt;*/&lt;/code&gt; ; esto har&amp;aacute; que el contenido del comentario sea ignorado por el compilador. Aunque no es parte del est&amp;aacute;ndar C ++, &lt;code&gt;/**&lt;/code&gt; y &lt;code&gt;*/&lt;/code&gt; se usan a menudo para indicar bloques de documentaci&amp;oacute;n; Esto es legal porque el segundo asterisco simplemente se trata como parte del comentario. Los comentarios de estilo C no se pueden anidar.</target>
        </trans-unit>
        <trans-unit id="48253fbd0ad94c130de734e904780378dbaf86ae" translate="yes" xml:space="preserve">
          <source>C-style date and time library</source>
          <target state="translated">Biblioteca de fecha y hora al estilo C</target>
        </trans-unit>
        <trans-unit id="2f7dc08f72f32281ebb854326effae89b085e12d" translate="yes" xml:space="preserve">
          <source>C-style date and time library (e.g. &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Biblioteca de fecha y hora de estilo C (por ejemplo, &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="f58953ee114042660a40fb46cdbb6561045fdd9e" translate="yes" xml:space="preserve">
          <source>C-style file input/output</source>
          <target state="translated">Entrada/salida de archivos de estilo C</target>
        </trans-unit>
        <trans-unit id="ee69eba17157f0bd643ab8f69127f0bbfedd84dc" translate="yes" xml:space="preserve">
          <source>C-style input-output functions</source>
          <target state="translated">Funciones de entrada-salida de estilo C</target>
        </trans-unit>
        <trans-unit id="78e1709449ee6d0679c98c9e988b4d20f58cb3c2" translate="yes" xml:space="preserve">
          <source>C-style memory management</source>
          <target state="translated">Gestión de la memoria al estilo C</target>
        </trans-unit>
        <trans-unit id="b3df26bb0867d25f5ab994e73d5725e15e0b58b0" translate="yes" xml:space="preserve">
          <source>C-style time/date utilites</source>
          <target state="translated">Utilidades de tiempo/fecha de estilo C</target>
        </trans-unit>
        <trans-unit id="52aea3b6618c4eb66aee74f7ff3b04621de74570" translate="yes" xml:space="preserve">
          <source>C-style variadic functions</source>
          <target state="translated">Funciones variadas de estilo C</target>
        </trans-unit>
        <trans-unit id="24fc58ea2f98cd20a27008421ec7f7e3dfc35435" translate="yes" xml:space="preserve">
          <source>CHAR_BIT</source>
          <target state="translated">CHAR_BIT</target>
        </trans-unit>
        <trans-unit id="725f72738449b33d5ed2db35158ace2f646b043c" translate="yes" xml:space="preserve">
          <source>CHAR_MAX</source>
          <target state="translated">CHAR_MAX</target>
        </trans-unit>
        <trans-unit id="b30c9342a5465cef0a56934460b3bfa4e2e74c49" translate="yes" xml:space="preserve">
          <source>CHAR_MIN</source>
          <target state="translated">CHAR_MIN</target>
        </trans-unit>
        <trans-unit id="c820f67f5827175c8c204a8b983dc8a39b93cac1" translate="yes" xml:space="preserve">
          <source>CIRCLED DIGIT ONE - NEGATIVE CIRCLED DIGIT ZERO</source>
          <target state="translated">DÍGITO CIRCULADO UNO-DÍGITO CIRCULADO NEGATIVO CERO</target>
        </trans-unit>
        <trans-unit id="fff8f67cf9fc327818272d81ae72e6f4b9164d0a" translate="yes" xml:space="preserve">
          <source>CJK COMPATIBILITY IDEOGRAPH-F900 - ARABIC LIGATURE ALEF WITH FATHATAN ISOLATED FORM</source>
          <target state="translated">CJK COMPATIBILIDAD IDEOGRAPH-F900-LIGADURA ÁRABE ALEF CON FATHATAN FORMA AISLADA</target>
        </trans-unit>
        <trans-unit id="190e1ea5952f0d388e456800d46304578b3a93e8" translate="yes" xml:space="preserve">
          <source>CJK RADICAL REPEAT - IDEOGRAPHIC DESCRIPTION CHARACTER OVERLAID</source>
          <target state="translated">CJK RADICAL REPEAT-DESCRIPCIÓN IDEOGRÁFICA CARÁCTER SUPERPUESTO</target>
        </trans-unit>
        <trans-unit id="789b032a45d264e7a02138bff69b47aacb370fca" translate="yes" xml:space="preserve">
          <source>CLOCKS_PER_SEC</source>
          <target state="translated">CLOCKS_PER_SEC</target>
        </trans-unit>
        <trans-unit id="8b6654ec4bc3d0c514cc6e4b4ad72a0db37a1444" translate="yes" xml:space="preserve">
          <source>COMBINING DOTTED GRAVE ACCENT - COMBINING RIGHT ARROWHEAD AND DOWN ARROWHEAD BELOW</source>
          <target state="translated">COMBINANDO ACENTO GRAVE PUNTEADO-COMBINANDO LA PUNTA DE FLECHA DERECHA Y LA PUNTA DE FLECHA ABAJO ABAJO</target>
        </trans-unit>
        <trans-unit id="714ab47a0e6f413b3bf281d1f4cbe410847fe7f1" translate="yes" xml:space="preserve">
          <source>COMBINING GRAVE ACCENT - COMBINING LATIN SMALL LETTER X</source>
          <target state="translated">COMBINANDO ACENTO GRAVE-COMBINANDO LETRA MINÚSCULA LATINA X</target>
        </trans-unit>
        <trans-unit id="35575c776ae958fb9883f5bf9ba9b6cfaf676fb9" translate="yes" xml:space="preserve">
          <source>COMBINING LEFT HARPOON ABOVE - COMBINING ASTERISK ABOVE</source>
          <target state="translated">COMBINANDO EL ARPÓN IZQUIERDO ARRIBA-COMBINANDO EL ASTERISCO ARRIBA</target>
        </trans-unit>
        <trans-unit id="7febb4b03096c80654f363847dc95a2cfb84fefe" translate="yes" xml:space="preserve">
          <source>COMBINING LIGATURE LEFT HALF - COMBINING CYRILLIC TITLO RIGHT HALF</source>
          <target state="translated">COMBINANDO LA MITAD IZQUIERDA DE LA LIGADURA-COMBINANDO LA MITAD DERECHA DEL TITLO CIRÍLICO</target>
        </trans-unit>
        <trans-unit id="9560447a54fd74d0cf86900665e48394b8c2274d" translate="yes" xml:space="preserve">
          <source>CPL</source>
          <target state="translated">CPL</target>
        </trans-unit>
        <trans-unit id="b24be71613a88ae74ef2222af07f1f8532a2eb06" translate="yes" xml:space="preserve">
          <source>CRTP</source>
          <target state="translated">CRTP</target>
        </trans-unit>
        <trans-unit id="a59d9bcee7f8794c67d0f8eaac8b827616f73808" translate="yes" xml:space="preserve">
          <source>CTAD</source>
          <target state="translated">CTAD</target>
        </trans-unit>
        <trans-unit id="47563e02f34b97527aa11cd2660b1c531f28a7a0" translate="yes" xml:space="preserve">
          <source>CWG 1213</source>
          <target state="translated">CWG 1213</target>
        </trans-unit>
        <trans-unit id="4b2c33f3b2901add653231f28b9837371837d438" translate="yes" xml:space="preserve">
          <source>CWG 1301</source>
          <target state="translated">CWG 1301</target>
        </trans-unit>
        <trans-unit id="6ffd78fdcfc97704227c81ed211b654ae584f03c" translate="yes" xml:space="preserve">
          <source>CWG 1313</source>
          <target state="translated">CWG 1313</target>
        </trans-unit>
        <trans-unit id="e72262c1f7923c69acd5b6e632a6ea0b0ee13223" translate="yes" xml:space="preserve">
          <source>CWG 1315</source>
          <target state="translated">CWG 1315</target>
        </trans-unit>
        <trans-unit id="74b12783757c5081b7fb53b3cd6b878928af8eae" translate="yes" xml:space="preserve">
          <source>CWG 1391</source>
          <target state="translated">CWG 1391</target>
        </trans-unit>
        <trans-unit id="d9e49fbd701bbcdc956dcedc347ee4c2dab0f2ed" translate="yes" xml:space="preserve">
          <source>CWG 1394</source>
          <target state="translated">CWG 1394</target>
        </trans-unit>
        <trans-unit id="4fb7724609c8a8b0dcca0bada49c63e843cf4195" translate="yes" xml:space="preserve">
          <source>CWG 1395</source>
          <target state="translated">CWG 1395</target>
        </trans-unit>
        <trans-unit id="7154988f61117199c76a049798a28cf90de02420" translate="yes" xml:space="preserve">
          <source>CWG 1397</source>
          <target state="translated">CWG 1397</target>
        </trans-unit>
        <trans-unit id="b449890ac0834487b5eaf123c275fd35b1137504" translate="yes" xml:space="preserve">
          <source>CWG 1423</source>
          <target state="translated">CWG 1423</target>
        </trans-unit>
        <trans-unit id="9a7b9cc74202f3c29fa36c900f6ba27c585313fc" translate="yes" xml:space="preserve">
          <source>CWG 1458</source>
          <target state="translated">CWG 1458</target>
        </trans-unit>
        <trans-unit id="40d23e9f1ab69a460e82608189870f9b5cac5e51" translate="yes" xml:space="preserve">
          <source>CWG 1467</source>
          <target state="translated">CWG 1467</target>
        </trans-unit>
        <trans-unit id="d9c41df53bb29177228be09033e92e1deef54502" translate="yes" xml:space="preserve">
          <source>CWG 1550</source>
          <target state="translated">CWG 1550</target>
        </trans-unit>
        <trans-unit id="2749cb8bd08487f07f57b026d7f0a32906248fc7" translate="yes" xml:space="preserve">
          <source>CWG 1558</source>
          <target state="translated">CWG 1558</target>
        </trans-unit>
        <trans-unit id="1930e406ede3e006c8d9aac6e7043f5d94676955" translate="yes" xml:space="preserve">
          <source>CWG 1560</source>
          <target state="translated">CWG 1560</target>
        </trans-unit>
        <trans-unit id="e6ba8d164871c6a798203d13dfcb1e6e4da6da78" translate="yes" xml:space="preserve">
          <source>CWG 1579</source>
          <target state="translated">CWG 1579</target>
        </trans-unit>
        <trans-unit id="73c5f99cc638773086e35615fade4d4947d1d60e" translate="yes" xml:space="preserve">
          <source>CWG 1591</source>
          <target state="translated">CWG 1591</target>
        </trans-unit>
        <trans-unit id="735a2e213b861827190fdf465dd014f41f1f5684" translate="yes" xml:space="preserve">
          <source>CWG 1601</source>
          <target state="translated">CWG 1601</target>
        </trans-unit>
        <trans-unit id="f698a022a799e476a4b5d90908c4f0968039b3a4" translate="yes" xml:space="preserve">
          <source>CWG 1638</source>
          <target state="translated">CWG 1638</target>
        </trans-unit>
        <trans-unit id="9d6075634dd8060a300813233ee99f173cd90be3" translate="yes" xml:space="preserve">
          <source>CWG 1672</source>
          <target state="translated">CWG 1672</target>
        </trans-unit>
        <trans-unit id="b72ace2ad31c1e2fb91f1346d396608578b35f79" translate="yes" xml:space="preserve">
          <source>CWG 1696</source>
          <target state="translated">CWG 1696</target>
        </trans-unit>
        <trans-unit id="28347337bf2cc1f1919d510e1adbb168425a77c2" translate="yes" xml:space="preserve">
          <source>CWG 1719</source>
          <target state="translated">CWG 1719</target>
        </trans-unit>
        <trans-unit id="be03df1470395dcc9eeb7f3194fc4e5a81102ad5" translate="yes" xml:space="preserve">
          <source>CWG 1722</source>
          <target state="translated">CWG 1722</target>
        </trans-unit>
        <trans-unit id="0c7f27ab354ac1a80a384197c76d4e3d24b3a644" translate="yes" xml:space="preserve">
          <source>CWG 1734</source>
          <target state="translated">CWG 1734</target>
        </trans-unit>
        <trans-unit id="93fb30cfc8e126fb5fe13f8d64ea000c6669b4e0" translate="yes" xml:space="preserve">
          <source>CWG 1781</source>
          <target state="translated">CWG 1781</target>
        </trans-unit>
        <trans-unit id="75c74907ac6a6383a90bffab070b3ef5f33e6cdb" translate="yes" xml:space="preserve">
          <source>CWG 1813</source>
          <target state="translated">CWG 1813</target>
        </trans-unit>
        <trans-unit id="2eaa057756492b48b304275aed682a52bf13bef5" translate="yes" xml:space="preserve">
          <source>CWG 1838</source>
          <target state="translated">CWG 1838</target>
        </trans-unit>
        <trans-unit id="0d25ef040ac6f3edbf12f878493bba23ddbf903d" translate="yes" xml:space="preserve">
          <source>CWG 1863</source>
          <target state="translated">CWG 1863</target>
        </trans-unit>
        <trans-unit id="d31cb5a2e409347064465cd90ecdb5de73cbbcca" translate="yes" xml:space="preserve">
          <source>CWG 1866</source>
          <target state="translated">CWG 1866</target>
        </trans-unit>
        <trans-unit id="af6cfdd2ae9b748b30376111eb2e1a4d17271d87" translate="yes" xml:space="preserve">
          <source>CWG 1878</source>
          <target state="translated">CWG 1878</target>
        </trans-unit>
        <trans-unit id="76b6b3653d71fac1420ccfc68013d1df012f6885" translate="yes" xml:space="preserve">
          <source>CWG 1885</source>
          <target state="translated">CWG 1885</target>
        </trans-unit>
        <trans-unit id="80077256fcd7c8d10a1735e2561b5761dc72781c" translate="yes" xml:space="preserve">
          <source>CWG 1891</source>
          <target state="translated">CWG 1891</target>
        </trans-unit>
        <trans-unit id="1028a0754e9331957ee9dec60315a06334455543" translate="yes" xml:space="preserve">
          <source>CWG 1895</source>
          <target state="translated">CWG 1895</target>
        </trans-unit>
        <trans-unit id="715e6f5a0af4ea83c2adbba2e1c4a84c4cdf4c23" translate="yes" xml:space="preserve">
          <source>CWG 1911</source>
          <target state="translated">CWG 1911</target>
        </trans-unit>
        <trans-unit id="d59063371cbbf3c50fa4004a2c980a915a5a3712" translate="yes" xml:space="preserve">
          <source>CWG 1932</source>
          <target state="translated">CWG 1932</target>
        </trans-unit>
        <trans-unit id="fee2040205e11bfb3c90d627d95a3ef1b06bf7c8" translate="yes" xml:space="preserve">
          <source>CWG 1940</source>
          <target state="translated">CWG 1940</target>
        </trans-unit>
        <trans-unit id="7be04ab603086e1fe7b3d69077927db8d61e60df" translate="yes" xml:space="preserve">
          <source>CWG 195</source>
          <target state="translated">CWG 195</target>
        </trans-unit>
        <trans-unit id="401b02ff04774bdf69dfc351c0fc646e8c52792c" translate="yes" xml:space="preserve">
          <source>CWG 1951</source>
          <target state="translated">CWG 1951</target>
        </trans-unit>
        <trans-unit id="28c16abcb79a7d2985fffaea2e7091ceaeedcb15" translate="yes" xml:space="preserve">
          <source>CWG 1952</source>
          <target state="translated">CWG 1952</target>
        </trans-unit>
        <trans-unit id="78e6d54c5d8c416b62b8bc7f6de701b3133dfbaa" translate="yes" xml:space="preserve">
          <source>CWG 1955</source>
          <target state="translated">CWG 1955</target>
        </trans-unit>
        <trans-unit id="41f749570a89d069549057499232a1cc43471407" translate="yes" xml:space="preserve">
          <source>CWG 1992</source>
          <target state="translated">CWG 1992</target>
        </trans-unit>
        <trans-unit id="1463942fad687beb04e017d429368db857b7bf10" translate="yes" xml:space="preserve">
          <source>CWG 2004</source>
          <target state="translated">CWG 2004</target>
        </trans-unit>
        <trans-unit id="24b2f326ff1dbd6e75b7fe0777847a2048e25f64" translate="yes" xml:space="preserve">
          <source>CWG 2012</source>
          <target state="translated">CWG 2012</target>
        </trans-unit>
        <trans-unit id="a252ff07735443b3b89651fd3662e3f4c3a99e40" translate="yes" xml:space="preserve">
          <source>CWG 2022</source>
          <target state="translated">CWG 2022</target>
        </trans-unit>
        <trans-unit id="585fa29096b9165f2e65d4ab7ac3d55d4ccca16d" translate="yes" xml:space="preserve">
          <source>CWG 2026</source>
          <target state="translated">CWG 2026</target>
        </trans-unit>
        <trans-unit id="8190296876c615aed0b58aa2986f2e3603ff068b" translate="yes" xml:space="preserve">
          <source>CWG 2039</source>
          <target state="translated">CWG 2039</target>
        </trans-unit>
        <trans-unit id="9fac3c0f458bed3f35cc6e7ea77169bfd642f791" translate="yes" xml:space="preserve">
          <source>CWG 2052</source>
          <target state="translated">CWG 2052</target>
        </trans-unit>
        <trans-unit id="905971b8c2ebad4151cef0c505c6db3c3443e509" translate="yes" xml:space="preserve">
          <source>CWG 2082</source>
          <target state="translated">CWG 2082</target>
        </trans-unit>
        <trans-unit id="a60400639f386cc83b091425fd72478bd78dccb6" translate="yes" xml:space="preserve">
          <source>CWG 2084</source>
          <target state="translated">CWG 2084</target>
        </trans-unit>
        <trans-unit id="d0912de9c62ce2a759dd40ba5c95059625c84704" translate="yes" xml:space="preserve">
          <source>CWG 2091</source>
          <target state="translated">CWG 2091</target>
        </trans-unit>
        <trans-unit id="97ce1e0c528bfc8a4aee8f304b082d78f3313d15" translate="yes" xml:space="preserve">
          <source>CWG 2094</source>
          <target state="translated">CWG 2094</target>
        </trans-unit>
        <trans-unit id="bb553bbdccad20b58a6287507179e7aaac1138f8" translate="yes" xml:space="preserve">
          <source>CWG 2100</source>
          <target state="translated">CWG 2100</target>
        </trans-unit>
        <trans-unit id="7d55f979aebc02a17a304196dbaedd6e39446715" translate="yes" xml:space="preserve">
          <source>CWG 2120</source>
          <target state="translated">CWG 2120</target>
        </trans-unit>
        <trans-unit id="57a98d99b6d9403964ab62e7650db4ce2125747b" translate="yes" xml:space="preserve">
          <source>CWG 2137</source>
          <target state="translated">CWG 2137</target>
        </trans-unit>
        <trans-unit id="5e7983e2eff1437835ae2c5af3c0e619bb441ca6" translate="yes" xml:space="preserve">
          <source>CWG 2163</source>
          <target state="translated">CWG 2163</target>
        </trans-unit>
        <trans-unit id="fab7f39f8b013bbf0a59f2fe8002534da773c8aa" translate="yes" xml:space="preserve">
          <source>CWG 2167</source>
          <target state="translated">CWG 2167</target>
        </trans-unit>
        <trans-unit id="3f873603897faddf9e479a2f3afd854cd91d6381" translate="yes" xml:space="preserve">
          <source>CWG 2171</source>
          <target state="translated">CWG 2171</target>
        </trans-unit>
        <trans-unit id="fe9644b244394c2eabfc31e02ec47a961f67cb01" translate="yes" xml:space="preserve">
          <source>CWG 2176</source>
          <target state="translated">CWG 2176</target>
        </trans-unit>
        <trans-unit id="203df293763ce0d669052a6832f14d3fafcf7792" translate="yes" xml:space="preserve">
          <source>CWG 2268</source>
          <target state="translated">CWG 2268</target>
        </trans-unit>
        <trans-unit id="0654e95544b6a3934ee54bf50137e9773bf4eece" translate="yes" xml:space="preserve">
          <source>CWG 2278</source>
          <target state="translated">CWG 2278</target>
        </trans-unit>
        <trans-unit id="1e706907058df91acb35f56258b08ab09a4a3a70" translate="yes" xml:space="preserve">
          <source>CWG 2387</source>
          <target state="translated">CWG 2387</target>
        </trans-unit>
        <trans-unit id="82d53da8356c3ca3b92f1c7356ff3db1988d1b75" translate="yes" xml:space="preserve">
          <source>CWG 330</source>
          <target state="translated">CWG 330</target>
        </trans-unit>
        <trans-unit id="ccb6c3b42336d94c15bb3870d96c4815af38060e" translate="yes" xml:space="preserve">
          <source>CWG 393</source>
          <target state="translated">CWG 393</target>
        </trans-unit>
        <trans-unit id="e15dfefc20dc9707f7b3d7e3bfd742f4ba2fe0e6" translate="yes" xml:space="preserve">
          <source>CWG 45</source>
          <target state="translated">CWG 45</target>
        </trans-unit>
        <trans-unit id="a683182b298c47030d15a78fb9455cd68db3f4e1" translate="yes" xml:space="preserve">
          <source>CWG 496</source>
          <target state="translated">CWG 496</target>
        </trans-unit>
        <trans-unit id="f6a4d2d7852a929bdef3282acacef0950c6827a3" translate="yes" xml:space="preserve">
          <source>CWG 500</source>
          <target state="translated">CWG 500</target>
        </trans-unit>
        <trans-unit id="8168079f990033b28ee30baf555b21dac700dbe5" translate="yes" xml:space="preserve">
          <source>CWG 577</source>
          <target state="translated">CWG 577</target>
        </trans-unit>
        <trans-unit id="6fc7f7d941214d7e90028d76ec9df5aece8e4b10" translate="yes" xml:space="preserve">
          <source>CWG 613</source>
          <target state="translated">CWG 613</target>
        </trans-unit>
        <trans-unit id="65ecce3064605f43be72ea3dd69ca82afaeced68" translate="yes" xml:space="preserve">
          <source>CWG 616</source>
          <target state="translated">CWG 616</target>
        </trans-unit>
        <trans-unit id="de85001d3da367b6bc9e3cd052c9bab51ab5abda" translate="yes" xml:space="preserve">
          <source>CWG 727</source>
          <target state="translated">CWG 727</target>
        </trans-unit>
        <trans-unit id="1617da0092a5442eeec85cdd1cb1225081fe44bf" translate="yes" xml:space="preserve">
          <source>CWG 903</source>
          <target state="translated">CWG 903</target>
        </trans-unit>
        <trans-unit id="af14bcf58f1a68925b0a5504ba2c3fedd31bf275" translate="yes" xml:space="preserve">
          <source>CWG 975</source>
          <target state="translated">CWG 975</target>
        </trans-unit>
        <trans-unit id="883938ab5275fd7f506eef92dcbd07ff4e7d5615" translate="yes" xml:space="preserve">
          <source>Cache size access</source>
          <target state="translated">Acceso al tamaño de la caché</target>
        </trans-unit>
        <trans-unit id="abd58164af939ff4d9cde0c5a458880ac0375eb1" translate="yes" xml:space="preserve">
          <source>Calculates the length of a null-terminated character sequence, that is, the smallest &lt;code&gt;i&lt;/code&gt; such that &lt;code&gt;p[i]==0&lt;/code&gt;.</source>
          <target state="translated">Calcula la longitud de una secuencia de caracteres terminada en nulo, es decir, la m&amp;aacute;s peque&amp;ntilde;a &lt;code&gt;i&lt;/code&gt; tal que &lt;code&gt;p[i]==0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf186f04df8bd87628a780c3378dd3632fd2a3a3" translate="yes" xml:space="preserve">
          <source>Calculates the phase angle (in radians) of the complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Calcula el &amp;aacute;ngulo de fase (en radianes) del n&amp;uacute;mero complejo &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57f0569da38bf80c03db47109bd43da72eb97f7c" translate="yes" xml:space="preserve">
          <source>Calculates the smallest integral power of two that is not smaller than &lt;code&gt;x&lt;/code&gt;. If that value is not representable in &lt;code&gt;T&lt;/code&gt;, the result is unspecified.</source>
          <target state="translated">Calcula la potencia integral m&amp;aacute;s peque&amp;ntilde;a de dos que no es menor que &lt;code&gt;x&lt;/code&gt; . Si ese valor no es representable en &lt;code&gt;T&lt;/code&gt; , el resultado no se especifica.</target>
        </trans-unit>
        <trans-unit id="adab5090ac6a1b7b5420faac7be86c41721ba27c" translate="yes" xml:space="preserve">
          <source>Calendar</source>
          <target state="translated">Calendar</target>
        </trans-unit>
        <trans-unit id="77ea7aa743c8ae5ceebe6476bf7df6ad49a72839" translate="yes" xml:space="preserve">
          <source>Call once</source>
          <target state="translated">Llama una vez</target>
        </trans-unit>
        <trans-unit id="f4eba4ac4450eda1340606ecffb5eb5859411715" translate="yes" xml:space="preserve">
          <source>Call signature</source>
          <target state="translated">Firma de la llamada</target>
        </trans-unit>
        <trans-unit id="31298f54f958dfd787e62fd18a5dfa0ea246238e" translate="yes" xml:space="preserve">
          <source>Call to a class object</source>
          <target state="translated">Llamada a un objeto de clase</target>
        </trans-unit>
        <trans-unit id="788d2b3c20bc6bb4acdf2e12c362e93fcf9f86e9" translate="yes" xml:space="preserve">
          <source>Call to a named function</source>
          <target state="translated">Llamar a una función nombrada</target>
        </trans-unit>
        <trans-unit id="25e89ac78843ab3e453d550dab696b1c2685d9c8" translate="yes" xml:space="preserve">
          <source>Call to an overloaded operator</source>
          <target state="translated">Llamar a un operador sobrecargado</target>
        </trans-unit>
        <trans-unit id="3b55289fd0c473d42c2d6be6391e6a9f53a24056" translate="yes" xml:space="preserve">
          <source>Callable</source>
          <target state="translated">Callable</target>
        </trans-unit>
        <trans-unit id="23d949dfc4bd360aaa190a7d8b95216e5ade27f3" translate="yes" xml:space="preserve">
          <source>Callable concepts</source>
          <target state="translated">Conceptos llamables</target>
        </trans-unit>
        <trans-unit id="26f12919d9abcbe806f8a77ed9eb33b55d766a0f" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;back&lt;/code&gt; on an empty container is undefined.</source>
          <target state="translated">&lt;code&gt;back&lt;/code&gt; llamar en un contenedor vac&amp;iacute;o no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="ff2ffbf673a19e18259ea1cb76992f714681e368" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;back&lt;/code&gt; on an empty span results in undefined behavior.</source>
          <target state="translated">&lt;code&gt;back&lt;/code&gt; llamar en un espacio vac&amp;iacute;o da como resultado un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="6717d3aa8431f388fa22c83faef176dba4e916c3" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;front&lt;/code&gt; on an empty container is undefined.</source>
          <target state="translated">Llamar al &lt;code&gt;front&lt;/code&gt; en un contenedor vac&amp;iacute;o no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="1b224fd770585fb9a84773057036aa9e7e6d3a7e" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;front&lt;/code&gt; on an empty span results in undefined behavior.</source>
          <target state="translated">Llamar al &lt;code&gt;front&lt;/code&gt; en un espacio vac&amp;iacute;o da como resultado un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="2c9aa3a9eae1452c28134c585eb3820a002e81bd" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;pop_back&lt;/code&gt; on an empty container is undefined.</source>
          <target state="translated">Llamar a &lt;code&gt;pop_back&lt;/code&gt; en un contenedor vac&amp;iacute;o no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="3735210d481937108546f459443e5f1fd0f227c2" translate="yes" xml:space="preserve">
          <source>Calling &lt;code&gt;std::snprintf&lt;/code&gt; with zero &lt;code&gt;buf_size&lt;/code&gt; and null pointer for &lt;code&gt;buffer&lt;/code&gt; is useful to determine the necessary buffer size to contain the output:</source>
          <target state="translated">Llamar a &lt;code&gt;std::snprintf&lt;/code&gt; con cero &lt;code&gt;buf_size&lt;/code&gt; y puntero nulo para el &lt;code&gt;buffer&lt;/code&gt; es &amp;uacute;til para determinar el tama&amp;ntilde;o del b&amp;uacute;fer necesario para contener la salida:</target>
        </trans-unit>
        <trans-unit id="8ca41836763a311e7e3b63538aadbcd41b01f43b" translate="yes" xml:space="preserve">
          <source>Calling a member function of class X on an object of any other type invokes undefined behavior.</source>
          <target state="translated">Llamar a una función miembro de la clase X en un objeto de cualquier otro tipo invoca un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="b21d6934e73f94ffe04f7672733609014752fd4f" translate="yes" xml:space="preserve">
          <source>Calling any non-const member function of a &lt;code&gt;path&lt;/code&gt; invalidates all iterators referring to elements of that object.</source>
          <target state="translated">Llamar a cualquier funci&amp;oacute;n miembro no constante de una &lt;code&gt;path&lt;/code&gt; invalida todos los iteradores que hacen referencia a elementos de ese objeto.</target>
        </trans-unit>
        <trans-unit id="6605741078828d4b9eb94a61e28230ca57d44e38" translate="yes" xml:space="preserve">
          <source>Calling non-const member functions on the string, excluding &lt;a href=&quot;operator_at&quot;&gt;&lt;code&gt;operator[]()&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Llamando a funciones de miembros no constantes en la cadena, excluyendo &lt;a href=&quot;operator_at&quot;&gt; &lt;code&gt;operator[]()&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe2bc9fc50f90ff08c540ee75e64a547ec4aa73" translate="yes" xml:space="preserve">
          <source>Calling non-const member functions on the string, excluding &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Llamando a funciones de miembros no constantes en la cadena, excluyendo &lt;code&gt;&lt;a href=&quot;operator_at&quot;&gt;operator[]&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;at&quot;&gt;at()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;front&quot;&gt;front()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;back&quot;&gt;back()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;begin&quot;&gt;begin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;rbegin&quot;&gt;rbegin()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;rend&quot;&gt;rend()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1590423ec88dccd74976d9c0b4a15cd539e5de0f" translate="yes" xml:space="preserve">
          <source>Calling the function from several threads does not induce a data race. The implementation shall support the registration of at least &lt;code&gt;32&lt;/code&gt; functions.</source>
          <target state="translated">Llamar a la funci&amp;oacute;n desde varios hilos no induce una carrera de datos. La implementaci&amp;oacute;n deber&amp;aacute; soportar el registro de al menos &lt;code&gt;32&lt;/code&gt; funciones.</target>
        </trans-unit>
        <trans-unit id="ae706e35be31c74437d8b879378de31abca1e947" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;a href=&quot;../unique_lock/mutex&quot;&gt;&lt;code&gt;lock.mutex()&lt;/code&gt;&lt;/a&gt; is not locked by the current thread is undefined behavior.</source>
          <target state="translated">Llamar a esta funci&amp;oacute;n si &lt;a href=&quot;../unique_lock/mutex&quot;&gt; &lt;code&gt;lock.mutex()&lt;/code&gt; &lt;/a&gt; no est&amp;aacute; bloqueado por el hilo actual es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="75bbd4aac5cc1d989e699d782da569785e80372d" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;a href=&quot;../unique_lock/mutex&quot;&gt;&lt;code&gt;lock.mutex()&lt;/code&gt;&lt;/a&gt; is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</source>
          <target state="translated">Llamar a esta funci&amp;oacute;n si &lt;a href=&quot;../unique_lock/mutex&quot;&gt; &lt;code&gt;lock.mutex()&lt;/code&gt; &lt;/a&gt; no es el mismo mutex que el utilizado por todos los otros subprocesos que actualmente est&amp;aacute;n esperando la misma variable de condici&amp;oacute;n es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="4dc1176c569db8cabf9eb9a19f697b5eace8b739" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;code&gt;lock.mutex()&lt;/code&gt; is not locked by the current thread is undefined behavior.</source>
          <target state="translated">Llamar a esta funci&amp;oacute;n si &lt;code&gt;lock.mutex()&lt;/code&gt; no est&amp;aacute; bloqueado por el hilo actual es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="59ddebba5c0c5f3cf16d2db3348b2a06ea675f9c" translate="yes" xml:space="preserve">
          <source>Calling this function if &lt;code&gt;lock.mutex()&lt;/code&gt; is not the same mutex as the one used by all other threads that are currently waiting on the same condition variable is undefined behavior.</source>
          <target state="translated">Llamar a esta funci&amp;oacute;n si &lt;code&gt;lock.mutex()&lt;/code&gt; no es el mismo mutex que el utilizado por todos los otros subprocesos que actualmente est&amp;aacute;n esperando la misma variable de condici&amp;oacute;n es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="ca1101d4e72ebfdcdf0ad75bb31490874ef21229" translate="yes" xml:space="preserve">
          <source>Calling wait on the same &lt;code&gt;std::shared_future&lt;/code&gt; from multiple threads is not safe; the intended use is for each thread that waits on the same shared state to have a copy of a &lt;code&gt;std::shared_future&lt;/code&gt;.</source>
          <target state="translated">Llamar a wait en el mismo &lt;code&gt;std::shared_future&lt;/code&gt; desde varios subprocesos no es seguro; el uso previsto es para cada subproceso que espera en el mismo estado compartido para tener una copia de un &lt;code&gt;std::shared_future&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fe2219fd2346b0443d87479d3d6381482c45d02" translate="yes" xml:space="preserve">
          <source>Calls &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt; to transmit all pending output (and delayed flush, if any) to the wrapped stream. If an exception is thrown by this call, it is caught and ignored.</source>
          <target state="translated">Las llamadas &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; para transmitir toda la salida pendiente (y descarga diferida, si la hay) a la secuencia envuelta. Si esta llamada genera una excepci&amp;oacute;n, se captura e ignora.</target>
        </trans-unit>
        <trans-unit id="e7211e6009a18f7a09fbc9ac46b8a624714b4410" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*)&lt;/code&gt;or &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt;(since C++17), but it is unspecified when and how it is called.</source>
          <target state="translated">Llama a &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*)&lt;/code&gt; o &lt;code&gt;::&lt;a href=&quot;../new/operator_delete&quot;&gt;operator delete&lt;/a&gt;(void*, &lt;a href=&quot;../new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;)&lt;/code&gt; (desde C ++ 17), pero no se especifica cu&amp;aacute;ndo y c&amp;oacute;mo se llama.</target>
        </trans-unit>
        <trans-unit id="d77a5af1e4348b5987265920ffaec5aa8d151398" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; to close the associated file and destructs all other members of &lt;code&gt;basic_filebuf&lt;/code&gt;. If an exception is thrown by &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt;, it is caught and not rethrown.</source>
          <target state="translated">Llama a &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; para cerrar el archivo asociado y destruye a todos los dem&amp;aacute;s miembros de &lt;code&gt;basic_filebuf&lt;/code&gt; . Si &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; lanza una excepci&amp;oacute;n , se captura y no se vuelve a lanzar.</target>
        </trans-unit>
        <trans-unit id="36548e9702a28bd62ee76fcd892dc9bc23d3cf34" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze()&lt;/a&gt;&lt;/code&gt;, then returns a copy of start pointer of the get area, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::streambuf::eback()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Llama a &lt;code&gt;&lt;a href=&quot;freeze&quot;&gt;freeze()&lt;/a&gt;&lt;/code&gt; , luego devuelve una copia del puntero de inicio del &amp;aacute;rea get, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;std::streambuf::eback()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5eeb168b574d3d4c252825f4a3753f9379de82e" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; to swap all data members of the base class except for &lt;code&gt;rdbuf()&lt;/code&gt;, and swaps the values of the &lt;code&gt;gcount()&lt;/code&gt; counters between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. This swap function is protected: it is called by the swap functions of the swappable input stream classes &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">Llama a &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; para intercambiar todos los miembros de datos de la clase base, excepto &lt;code&gt;rdbuf()&lt;/code&gt; , y cambia los valores de los contadores &lt;code&gt;gcount()&lt;/code&gt; entre &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; . Esta funci&amp;oacute;n de intercambio est&amp;aacute; protegida: se llama mediante las funciones de intercambio de las clases de flujo de entrada intercambiables &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; , que saben c&amp;oacute;mo intercambiar correctamente los streambuffers asociados.</target>
        </trans-unit>
        <trans-unit id="7ac56e091391242bbdc4ad807edc846cff28d837" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; to swap all data members of the base class, except for &lt;code&gt;rdbuf()&lt;/code&gt;, between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;. This swap function is protected: it is called by the swap functions of the swappable output stream classes &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">Llama a &lt;code&gt;basic_ios::swap(rhs)&lt;/code&gt; para intercambiar todos los miembros de datos de la clase base, excepto &lt;code&gt;rdbuf()&lt;/code&gt; , entre &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; . Esta funci&amp;oacute;n de intercambio est&amp;aacute; protegida: se llama mediante las funciones de intercambio de las clases de flujo de salida intercambiables &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../basic_ostringstream&quot;&gt;std::basic_ostringstream&lt;/a&gt;&lt;/code&gt; , que saben c&amp;oacute;mo intercambiar correctamente los streambuffers asociados.</target>
        </trans-unit>
        <trans-unit id="e3dc184d2193e1837c7b1ab6ae910b4a5a68b463" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;clear()&lt;/code&gt; on success.</source>
          <target state="translated">Llamadas &lt;code&gt;clear()&lt;/code&gt; en caso de &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="3934f9f9eebfbb559e3c31093566b7ed8b1d4ffc" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;setstate(failbit)&lt;/code&gt; on failure.</source>
          <target state="translated">Llamadas &lt;code&gt;setstate(failbit)&lt;/code&gt; en caso de falla.</target>
        </trans-unit>
        <trans-unit id="d2c103774ce296202589b581a39e2733fbd14eeb" translate="yes" xml:space="preserve">
          <source>Calls &lt;code&gt;swap&lt;/code&gt; (which might be &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt;, or might be found via ADL) for each element in &lt;code&gt;*this&lt;/code&gt; and its corresponding element in &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">Llama a &lt;code&gt;swap&lt;/code&gt; (que podr&amp;iacute;a ser &lt;code&gt;&lt;a href=&quot;../../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; , o podr&amp;iacute;a encontrarse a trav&amp;eacute;s de ADL) para cada elemento en &lt;code&gt;*this&lt;/code&gt; y su elemento correspondiente en &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="481431a2735414dcd8592892b784b43366935f35" translate="yes" xml:space="preserve">
          <source>Calls the &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object, reference to which is stored. This function is available only if the stored reference points to a &lt;a href=&quot;../../../named_req/callable&quot;&gt;Callable&lt;/a&gt; object.</source>
          <target state="translated">Llama al objeto &lt;a href=&quot;../../../named_req/callable&quot;&gt;invocable&lt;/a&gt; , referencia al cual se almacena. Esta funci&amp;oacute;n solo est&amp;aacute; disponible si la referencia almacenada apunta a un objeto &lt;a href=&quot;../../../named_req/callable&quot;&gt;invocable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0bbf1dcddfa6e1ab86b5f404a8df59c3e805b815" translate="yes" xml:space="preserve">
          <source>Calls the appropriate extraction operator, given an rvalue reference to an input stream object (equivalent to &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt;). This function does not participate in overload resolution unless the expression &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; is well-formed.</source>
          <target state="translated">Llama al operador de extracci&amp;oacute;n apropiado, dada una referencia de valor r a un objeto de flujo de entrada (equivalente a &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; ). Esta funci&amp;oacute;n no participa en la resoluci&amp;oacute;n de sobrecarga a menos que la expresi&amp;oacute;n &lt;code&gt;st &amp;gt;&amp;gt; &lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value)&lt;/code&gt; est&amp;eacute; bien formada.</target>
        </trans-unit>
        <trans-unit id="9c48a860ccae7d78225a13d6988e12c01b392911" translate="yes" xml:space="preserve">
          <source>Calls the appropriate extraction operator, given an rvalue reference to an input stream object (equivalent to &lt;code&gt;st &amp;gt;&amp;gt; value&lt;/code&gt;).</source>
          <target state="translated">Llama al operador de extracci&amp;oacute;n apropiado, dada una referencia de valor r a un objeto de flujo de entrada (equivalente al &lt;code&gt;st &amp;gt;&amp;gt; value&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7b5b7a129b3ced37543947e6912ecc3cecfa84d6" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;, as if by &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;.</source>
          <target state="translated">Llama al destructor del objeto al que apunta &lt;code&gt;p&lt;/code&gt; , como si &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b405a9cd2b966c4bc34d98cc6f9f7cf4e95fe857" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Llama al destructor del objeto al que apunta &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78b1409922d2e4a9785fcea7996d5ce02b31a4ce" translate="yes" xml:space="preserve">
          <source>Calls the destructor of the object pointed to by &lt;code&gt;p&lt;/code&gt;. If possible, does so by calling &lt;code&gt;a.destroy(p)&lt;/code&gt;. If not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;destroy()&lt;/code&gt;), then calls the destructor of &lt;code&gt;*p&lt;/code&gt; directly, as &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt;.</source>
          <target state="translated">Llama al destructor del objeto al que apunta &lt;code&gt;p&lt;/code&gt; . Si es posible, lo hace llamando a &lt;code&gt;a.destroy(p)&lt;/code&gt; . Si no es posible (por ejemplo, &lt;code&gt;a&lt;/code&gt; no tiene la funci&amp;oacute;n de miembro &lt;code&gt;destroy()&lt;/code&gt; ), a continuaci&amp;oacute;n, llama al destructor de &lt;code&gt;*p&lt;/code&gt; directamente, como &lt;code&gt;p-&amp;gt;~T()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d65d02c76675e1ef2e0ab59d434954fbf4aab1b9" translate="yes" xml:space="preserve">
          <source>Calls the function named &lt;code&gt;swap()&lt;/code&gt; found by overload resolution among all functions with that name that are found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; and the two &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; templates defined in the header &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Llama a la funci&amp;oacute;n denominada &lt;code&gt;swap()&lt;/code&gt; encontrada por resoluci&amp;oacute;n de sobrecarga entre todas las funciones con ese nombre que se encuentran en la &lt;a href=&quot;../language/adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; y las dos plantillas &lt;code&gt;&lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;&lt;/code&gt; definidas en el encabezado &lt;code&gt;&amp;lt;utility&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb046b6586e057bb9aae9a1e6bfffa31963ec5ed" translate="yes" xml:space="preserve">
          <source>Calls the host environment's command processor (e.g. &lt;code&gt;/bin/sh&lt;/code&gt;, &lt;code&gt;cmd.exe&lt;/code&gt;, &lt;code&gt;command.com&lt;/code&gt;) with the parameter &lt;code&gt;command&lt;/code&gt;. Returns an implementation-defined value (usually the value that the invoked program returns).</source>
          <target state="translated">Llama al procesador de comandos del entorno host (por ejemplo, &lt;code&gt;/bin/sh&lt;/code&gt; , &lt;code&gt;cmd.exe&lt;/code&gt; , &lt;code&gt;command.com&lt;/code&gt; ) con el &lt;code&gt;command&lt;/code&gt; par&amp;aacute;metro . Devuelve un valor definido por la implementaci&amp;oacute;n (generalmente el valor que devuelve el programa invocado).</target>
        </trans-unit>
        <trans-unit id="b26b8306a6c31504edbc512428e1a837332ab1bd" translate="yes" xml:space="preserve">
          <source>Calls the stored function.</source>
          <target state="translated">Llama a la función almacenada.</target>
        </trans-unit>
        <trans-unit id="afca4766bb42b40e6c34338087393e97b7c59c19" translate="yes" xml:space="preserve">
          <source>Calls the stored task with &lt;code&gt;args&lt;/code&gt; as the arguments. The return value of the task or any exceptions thrown are stored in the shared state. The shared state is made ready and any threads waiting for this are unblocked.</source>
          <target state="translated">Llama a la tarea almacenado con &lt;code&gt;args&lt;/code&gt; como los argumentos. El valor de retorno de la tarea o cualquier excepci&amp;oacute;n lanzada se almacenan en el estado compartido. El estado compartido est&amp;aacute; listo y los subprocesos que lo esperan se desbloquean.</target>
        </trans-unit>
        <trans-unit id="dd90a8cace7a8f14fa555e29a7e7953fe85896a1" translate="yes" xml:space="preserve">
          <source>Calls the stored task with forwarded &lt;code&gt;args&lt;/code&gt; as the arguments. The return value of the task or any exception thrown by it is stored in the shared state of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Llama a la tarea almacenado con reenviados &lt;code&gt;args&lt;/code&gt; como los argumentos. El valor de retorno de la tarea o cualquier excepci&amp;oacute;n lanzada por ella se almacena en el estado compartido de &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ee1a97db496e5e5a537daa1da0e2cec32168671" translate="yes" xml:space="preserve">
          <source>Calls to &lt;a href=&quot;synchronized_pool_resource/do_allocate&quot;&gt;&lt;code&gt;do_allocate&lt;/code&gt;&lt;/a&gt; are dispatched to the pool serving the smallest blocks accommodating the requested size.</source>
          <target state="translated">Las llamadas a &lt;a href=&quot;synchronized_pool_resource/do_allocate&quot;&gt; &lt;code&gt;do_allocate&lt;/code&gt; &lt;/a&gt; se env&amp;iacute;an al grupo que atiende a los bloques m&amp;aacute;s peque&amp;ntilde;os que acomodan el tama&amp;ntilde;o solicitado.</target>
        </trans-unit>
        <trans-unit id="40a3a9a4b8f56ea0c9cc9b74ebd031cfe3acb404" translate="yes" xml:space="preserve">
          <source>Calls to &lt;a href=&quot;unsynchronized_pool_resource/do_allocate&quot;&gt;&lt;code&gt;do_allocate&lt;/code&gt;&lt;/a&gt; are dispatched to the pool serving the smallest blocks accommodating the requested size.</source>
          <target state="translated">Las llamadas a &lt;a href=&quot;unsynchronized_pool_resource/do_allocate&quot;&gt; &lt;code&gt;do_allocate&lt;/code&gt; &lt;/a&gt; se env&amp;iacute;an al grupo que atiende a los bloques m&amp;aacute;s peque&amp;ntilde;os que acomodan el tama&amp;ntilde;o solicitado.</target>
        </trans-unit>
        <trans-unit id="2bc1581a9b7b77d7540b30aeb4545a58a025742b" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;Allocator::allocate&lt;/code&gt; may throw.</source>
          <target state="translated">Se pueden lanzar llamadas a &lt;code&gt;Allocator::allocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e921f3a7ab8c6ee7f214b9ae25dfd4e6dac7ed9" translate="yes" xml:space="preserve">
          <source>Calls to &lt;code&gt;c8rtomb&lt;/code&gt; with a null pointer argument for &lt;code&gt;s&lt;/code&gt; may introduce a data race with other calls to &lt;code&gt;c8rtomb&lt;/code&gt; with a null pointer argument for &lt;code&gt;s&lt;/code&gt;.</source>
          <target state="translated">Las llamadas a &lt;code&gt;c8rtomb&lt;/code&gt; con un argumento de puntero nulo para &lt;code&gt;s&lt;/code&gt; pueden introducir una carrera de datos con otras llamadas a &lt;code&gt;c8rtomb&lt;/code&gt; con un argumento de puntero nulo para &lt;code&gt;s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="842bfa338f91c208278bfed4b504f42e1234ae0a" translate="yes" xml:space="preserve">
          <source>Calls to const member functions of the distribution and &lt;code&gt;os &amp;lt;&amp;lt; d&lt;/code&gt; do not affect the sequence of numbers produced by repeated &lt;code&gt;d(g)&lt;/code&gt;.</source>
          <target state="translated">Las llamadas a const funciones miembro de la distribuci&amp;oacute;n y &lt;code&gt;os &amp;lt;&amp;lt; d&lt;/code&gt; no afectan la secuencia de n&amp;uacute;meros producidos por &lt;code&gt;d(g)&lt;/code&gt; repetido .</target>
        </trans-unit>
        <trans-unit id="8f6bda6c551be6982977241156d440ef692185ef" translate="yes" xml:space="preserve">
          <source>Calls to these functions that allocate or deallocate a particular unit of storage occur in a single total order, and each such deallocation call &lt;a href=&quot;../../atomic/memory_order&quot;&gt;happens-before&lt;/a&gt; the next allocation (if any) in this order.</source>
          <target state="translated">Las llamadas a estas funciones que asignan o desasignan una unidad de almacenamiento en particular se producen en un solo pedido total, y cada una de esas llamadas de desasignaci&amp;oacute;n &lt;a href=&quot;../../atomic/memory_order&quot;&gt;ocurre antes de&lt;/a&gt; la siguiente asignaci&amp;oacute;n (si corresponde) en este orden.</target>
        </trans-unit>
        <trans-unit id="e7f6d16e4b3fb1f8e6d8ebfda2e4deaa82522158" translate="yes" xml:space="preserve">
          <source>Calls to this function do not introduce data races with calls to &lt;code&gt;&lt;a href=&quot;get_future&quot;&gt;get_future&lt;/a&gt;&lt;/code&gt; (but they need not synchronize with each other).</source>
          <target state="translated">Las llamadas a esta funci&amp;oacute;n no introducen carreras de datos con llamadas a &lt;code&gt;&lt;a href=&quot;get_future&quot;&gt;get_future&lt;/a&gt;&lt;/code&gt; (pero no necesitan sincronizarse entre s&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="0e8b087d01af0042b03fbd3b40cf94cd4b629f74" translate="yes" xml:space="preserve">
          <source>Calls to this function do not introduce data races with calls to &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; (but they need not synchronize with each other).</source>
          <target state="translated">Las llamadas a esta funci&amp;oacute;n no introducen carreras de datos con llamadas a &lt;code&gt;&lt;a href=&quot;set_value&quot;&gt;set_value&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_exception&quot;&gt;set_exception&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;set_value_at_thread_exit&quot;&gt;set_value_at_thread_exit&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;set_exception_at_thread_exit&quot;&gt;set_exception_at_thread_exit&lt;/a&gt;&lt;/code&gt; (pero no necesitan sincronizarse entre s&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="978f12bb4868b3da1bd6017109c32a97b6cc062a" translate="yes" xml:space="preserve">
          <source>Can be used to iterate through a single bucket</source>
          <target state="translated">Se puede usar para iterar a través de un solo cubo</target>
        </trans-unit>
        <trans-unit id="0754caffdf7dc1f3c428a31d5458447d8f2078b5" translate="yes" xml:space="preserve">
          <source>Can be variadic as well</source>
          <target state="translated">También puede ser variado</target>
        </trans-unit>
        <trans-unit id="32df764f4a004f4803750cb06a6e1038b85f5ab0" translate="yes" xml:space="preserve">
          <source>Can throw the exceptions thrown from &lt;code&gt;Alloc::allocate()&lt;/code&gt; or from the constructor of &lt;code&gt;T&lt;/code&gt;. If an exception is thrown, (1) has no effect. If an exception is thrown during the construction of the array, already-initialized elements are destroyed in reverse order(since C++20).</source>
          <target state="translated">Puede lanzar las excepciones lanzadas desde &lt;code&gt;Alloc::allocate()&lt;/code&gt; o desde el constructor de la &lt;code&gt;T&lt;/code&gt; . Si se produce una excepci&amp;oacute;n, (1) no tiene efecto. Si se produce una excepci&amp;oacute;n durante la construcci&amp;oacute;n de la matriz, los elementos ya inicializados se destruyen en orden inverso (desde C ++ 20).</target>
        </trans-unit>
        <trans-unit id="a4c126ec0c1d28e21fc971d14fbf29c30650c27c" translate="yes" xml:space="preserve">
          <source>Candidate functions</source>
          <target state="translated">Funciones del candidato</target>
        </trans-unit>
        <trans-unit id="3a1ea5de25db4a707e5b97c9c93167ca46913fc0" translate="yes" xml:space="preserve">
          <source>Cannot be called and thus never returns a value. The return type is &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; unless &lt;code&gt;T&lt;/code&gt; is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, in which case the return type is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">No se puede llamar y, por lo tanto, nunca devuelve un valor. El tipo de retorno es &lt;code&gt;T&amp;amp;&amp;amp;&lt;/code&gt; menos que &lt;code&gt;T&lt;/code&gt; es (posiblemente cv-cualificado) &lt;code&gt;void&lt;/code&gt; , en cuyo caso el tipo de retorno es &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a47709738a13682382a8bb47d1c3c176fb6cf434" translate="yes" xml:space="preserve">
          <source>Canonical implementations</source>
          <target state="translated">Implementaciones canónicas</target>
        </trans-unit>
        <trans-unit id="ca09c54bff74a82bae543ebe259f7452ee8c5293" translate="yes" xml:space="preserve">
          <source>Capabilities</source>
          <target state="translated">Capabilities</target>
        </trans-unit>
        <trans-unit id="45bd908df490edd79694ba0daff82fc092970b55" translate="yes" xml:space="preserve">
          <source>Capacity</source>
          <target state="translated">Capacity</target>
        </trans-unit>
        <trans-unit id="8c8a5e126ef7ec6a6ad77d0edf96fa8a146e07ff" translate="yes" xml:space="preserve">
          <source>Capacity of the currently allocated storage.</source>
          <target state="translated">Capacidad de almacenamiento actualmente asignada.</target>
        </trans-unit>
        <trans-unit id="b17823bc1728ea261d27feb54556ae24540f0e72" translate="yes" xml:space="preserve">
          <source>Capture and storage of exception objects</source>
          <target state="translated">Captura y almacenamiento de objetos de excepción</target>
        </trans-unit>
        <trans-unit id="dc6500dd683ae5c40011f02be84c903248d14d1b" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::clamp&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="translated">Capturar el resultado de &lt;code&gt;std::clamp&lt;/code&gt; por referencia si uno de los par&amp;aacute;metros es rvalue produce una referencia colgante si se devuelve ese par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="f412180178dea3bf686bb7206b2a1c6f412f169f" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::max&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="translated">Capturar el resultado de &lt;code&gt;std::max&lt;/code&gt; por referencia si uno de los par&amp;aacute;metros es rvalue produce una referencia colgante si se devuelve ese par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="37013b98a907be74378196d00c40398eaed52529" translate="yes" xml:space="preserve">
          <source>Capturing the result of &lt;code&gt;std::min&lt;/code&gt; by reference if one of the parameters is rvalue produces a dangling reference if that parameter is returned:</source>
          <target state="translated">Capturar el resultado de &lt;code&gt;std::min&lt;/code&gt; por referencia si uno de los par&amp;aacute;metros es rvalue produce una referencia colgante si se devuelve ese par&amp;aacute;metro:</target>
        </trans-unit>
        <trans-unit id="aeac558c74f367c4d77b33a3b991b9293571a506" translate="yes" xml:space="preserve">
          <source>Care should be taken when using &lt;code&gt;enable_if&lt;/code&gt; in the type of a template non-type parameter of a namespace-scope function template. Some ABI specifications like the Itanium ABI do not include the instantiation-dependent portions of non-type template parameters in the mangling, meaning that specializations of two distinct function templates might end up with the same mangled name and be erroneously linked together. For example:</source>
          <target state="translated">Se debe tener cuidado al usar &lt;code&gt;enable_if&lt;/code&gt; en el tipo de una plantilla que no sea un par&amp;aacute;metro de tipo de una plantilla de funci&amp;oacute;n de espacio de nombres. Algunas especificaciones ABI como Itanium ABI no incluyen las porciones dependientes de instanciaci&amp;oacute;n de par&amp;aacute;metros de plantilla que no son de tipo en la distribuci&amp;oacute;n, lo que significa que las especializaciones de dos plantillas de funci&amp;oacute;n distintas podr&amp;iacute;an terminar con el mismo nombre mutilado y estar err&amp;oacute;neamente unidas. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="bbfb9c69143915569ecc52059ab10ea7a1d14360" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;) is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">El uso cuidadoso del &lt;code&gt;emplace&lt;/code&gt; permite que se construya el nuevo elemento mientras se evitan las operaciones innecesarias de copiar o mover. El constructor del nuevo elemento (es decir, &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; ) se llama con exactamente los mismos argumentos que suministra a &lt;code&gt;emplace&lt;/code&gt; , reenv&amp;iacute;a a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52b9bfebd40c006ea3917327fed74d66704c9687" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element (i.e. &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt;) is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</source>
          <target state="translated">El uso cuidadoso del &lt;code&gt;emplace&lt;/code&gt; permite que se construya el nuevo elemento mientras se evitan las operaciones innecesarias de copiar o mover. El constructor del nuevo elemento (es decir, &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&amp;lt;const Key, T&amp;gt;&lt;/code&gt; ) se llama con exactamente los mismos argumentos que suministra a &lt;code&gt;emplace&lt;/code&gt; , reenv&amp;iacute;a a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; . El elemento puede construirse incluso si ya hay un elemento con la clave en el contenedor, en cuyo caso el elemento reci&amp;eacute;n construido ser&amp;aacute; destruido inmediatamente.</target>
        </trans-unit>
        <trans-unit id="4714de10bb9278addf37bd8e9cf61fba91ba9335" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;.</source>
          <target state="translated">El uso cuidadoso del &lt;code&gt;emplace&lt;/code&gt; permite que se construya el nuevo elemento mientras se evitan las operaciones innecesarias de copiar o mover. El constructor del nuevo elemento se llama con exactamente los mismos argumentos que suministra a &lt;code&gt;emplace&lt;/code&gt; , reenv&amp;iacute;a a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d62f1320fbf353fbac4ea498ae530ee45805f5d" translate="yes" xml:space="preserve">
          <source>Careful use of &lt;code&gt;emplace&lt;/code&gt; allows the new element to be constructed while avoiding unnecessary copy or move operations. The constructor of the new element is called with exactly the same arguments as supplied to &lt;code&gt;emplace&lt;/code&gt;, forwarded via &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;. The element may be constructed even if there already is an element with the key in the container, in which case the newly constructed element will be destroyed immediately.</source>
          <target state="translated">El uso cuidadoso del &lt;code&gt;emplace&lt;/code&gt; permite que se construya el nuevo elemento mientras se evitan las operaciones innecesarias de copiar o mover. El constructor del nuevo elemento se llama con exactamente los mismos argumentos que suministra a &lt;code&gt;emplace&lt;/code&gt; , reenv&amp;iacute;a a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; . El elemento puede construirse incluso si ya hay un elemento con la clave en el contenedor, en cuyo caso el elemento reci&amp;eacute;n construido ser&amp;aacute; destruido inmediatamente.</target>
        </trans-unit>
        <trans-unit id="9ba8ece0eb57ce634431d006ebb786d69e1c0fb8" translate="yes" xml:space="preserve">
          <source>Carries dependency</source>
          <target state="translated">Lleva la dependencia</target>
        </trans-unit>
        <trans-unit id="349f4b2217e91ab2d1ba3827cff21266a8c0e7bc" translate="yes" xml:space="preserve">
          <source>Case 1: binding an array</source>
          <target state="translated">Caso 1:atar una matriz</target>
        </trans-unit>
        <trans-unit id="56f64fdbefc9674a22cdd908d97b4da3d5e9aac5" translate="yes" xml:space="preserve">
          <source>Case 1: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is an array type, then the names are bound to the array elements.</source>
          <target state="translated">Caso 1: si &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; es un tipo de matriz, entonces los nombres est&amp;aacute;n vinculados a los elementos de la matriz.</target>
        </trans-unit>
        <trans-unit id="8fc50ba85c9e0bf4533570a0c18a73541e34b19c" translate="yes" xml:space="preserve">
          <source>Case 2: binding a tuple-like type</source>
          <target state="translated">Caso 2:la unión de un tipo similar a una tupla</target>
        </trans-unit>
        <trans-unit id="a28b6bd53fab5c5518781c66d9367f259e8a1a8b" translate="yes" xml:space="preserve">
          <source>Case 2: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is a non-union class type and &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is a complete type, then the &quot;tuple-like&quot; binding protocol is used.</source>
          <target state="translated">Caso 2: si &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; es un tipo de clase no sindical y &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; es un tipo completo, entonces se usa el protocolo de enlace &quot;tipo tupla&quot;.</target>
        </trans-unit>
        <trans-unit id="511322fb92a18ad6c803db32b44850aa3b21431d" translate="yes" xml:space="preserve">
          <source>Case 3: binding to data members</source>
          <target state="translated">Caso 3:vinculación a los miembros de los datos</target>
        </trans-unit>
        <trans-unit id="d6570c00b51cbb8acf7b8685b39e65082f79bd7f" translate="yes" xml:space="preserve">
          <source>Case 3: if &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; is a non-union class type but &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is not a complete type, then the names are bound to the accessible data members of &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt;.</source>
          <target state="translated">Caso 3: si &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; es un tipo de clase no uni&amp;oacute;n, pero &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; no es un tipo completo, a continuaci&amp;oacute;n, los nombres se unen a los miembros de datos accesibles de &lt;code&gt;&lt;i&gt;E&lt;/i&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74473f63620ac45f2911b86a7f11c6501a7660cd" translate="yes" xml:space="preserve">
          <source>Cast and assignment strip away any extraneous range and precision: this models the action of storing a value from an extended-precision FPU register into a standard-sized memory location.</source>
          <target state="translated">El lanzamiento y la asignación despojan de cualquier rango y precisión extraños:esto modela la acción de almacenar un valor de un registro FPU de precisión extendida en una ubicación de memoria de tamaño estándar.</target>
        </trans-unit>
        <trans-unit id="8107a9770cf1c808e1686a8e8b7cced06eac8bfc" translate="yes" xml:space="preserve">
          <source>Casting between integer durations where the source period is exactly divisible by the target period (e.g. hours to minutes) or between floating-point durations can be performed with ordinary casts or implicitly via &lt;a href=&quot;duration&quot;&gt;std::chrono::duration constructors&lt;/a&gt;, no &lt;code&gt;duration_cast&lt;/code&gt; is needed.</source>
          <target state="translated">La conversi&amp;oacute;n entre duraciones de n&amp;uacute;meros enteros donde el per&amp;iacute;odo de origen es exactamente divisible por el per&amp;iacute;odo de destino (por ejemplo, horas a minutos) o entre duraciones de punto flotante se puede realizar con conversiones ordinarias o impl&amp;iacute;citamente a trav&amp;eacute;s de &lt;a href=&quot;duration&quot;&gt;constructores std :: chrono :: Duration&lt;/a&gt; , no se necesita &lt;code&gt;duration_cast&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f784c0dfdd40d5aecdcc755d6d0d02557b2aa7e" translate="yes" xml:space="preserve">
          <source>Casting from a floating-point duration to an integer duration is &lt;a href=&quot;../../language/implicit_cast#Floating_-_integral_conversions&quot;&gt;subject to undefined behavior&lt;/a&gt; when the floating-point value is NaN, infinity, or too large to be representable by the target's integer type. Otherwise, casting to an integer duration is subject to truncation as with any static_cast to an integer type.</source>
          <target state="translated">La conversi&amp;oacute;n de una duraci&amp;oacute;n de punto flotante a una duraci&amp;oacute;n entera est&amp;aacute; &lt;a href=&quot;../../language/implicit_cast#Floating_-_integral_conversions&quot;&gt;sujeta a un comportamiento indefinido&lt;/a&gt; cuando el valor de punto flotante es NaN, infinito o demasiado grande para ser representable por el tipo entero del objetivo. De lo contrario, la conversi&amp;oacute;n a una duraci&amp;oacute;n entera est&amp;aacute; sujeta a truncamiento como con cualquier static_cast a un tipo entero.</target>
        </trans-unit>
        <trans-unit id="d1bd210bf015301c8468da6b036f05fe262ff0f0" translate="yes" xml:space="preserve">
          <source>Catch clause of a function-try block</source>
          <target state="translated">Cláusula de captura de un bloque de prueba de funciones</target>
        </trans-unit>
        <trans-unit id="a3c686e711e4720f99b4562bb3dbaae7ab658cf2" translate="yes" xml:space="preserve">
          <source>Category</source>
          <target state="translated">Category</target>
        </trans-unit>
        <trans-unit id="8610c7e6c1a1322fdf2ebc74043f66b624b393a8" translate="yes" xml:space="preserve">
          <source>Causes abnormal program termination unless &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; is being caught by a signal handler passed to &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; and the handler does not return.</source>
          <target state="translated">Provoca la finalizaci&amp;oacute;n anormal del programa a menos que &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGABRT&lt;/a&gt;&lt;/code&gt; sea ​​capturado por un controlador de se&amp;ntilde;al pasado a &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal&lt;/a&gt;&lt;/code&gt; y el controlador no regrese.</target>
        </trans-unit>
        <trans-unit id="a5fc98a179eaefefc7383473561adf59469b047c" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur without completely cleaning the resources.</source>
          <target state="translated">Hace que la terminación normal del programa ocurra sin limpiar completamente los recursos.</target>
        </trans-unit>
        <trans-unit id="03d84237d77c18a1ea9454f00c0d5a2c4def6e6a" translate="yes" xml:space="preserve">
          <source>Causes normal program termination to occur.</source>
          <target state="translated">Causa la terminación normal del programa.</target>
        </trans-unit>
        <trans-unit id="e1f612c1cf7abef4418592e6cc6efbf397106128" translate="yes" xml:space="preserve">
          <source>Causes reallocation if the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than the old &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;. If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</source>
          <target state="translated">Provoca la reasignaci&amp;oacute;n si el nuevo &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; es mayor que la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; . Si el nuevo &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; es mayor que la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , se invalidan todos los iteradores y referencias. De lo contrario, solo los iteradores y las referencias antes del punto de inserci&amp;oacute;n siguen siendo v&amp;aacute;lidos. El iterador pasado al final tambi&amp;eacute;n se invalida.</target>
        </trans-unit>
        <trans-unit id="1b3b922a89d7fd2178e02a2f975053d39cd95e01" translate="yes" xml:space="preserve">
          <source>Causes the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt;do-while&lt;/a&gt; loop or &lt;a href=&quot;switch&quot;&gt; switch statement&lt;/a&gt; to terminate.</source>
          <target state="translated">Hace que finalice el &lt;a href=&quot;switch&quot;&gt;enunciado de&lt;/a&gt; cierre o de enunciado &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; , &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; o &lt;a href=&quot;do&quot;&gt;do-&lt;/a&gt; while .</target>
        </trans-unit>
        <trans-unit id="c910b43d8c16258ce3d66377f217e9ecf4da3d0f" translate="yes" xml:space="preserve">
          <source>Causes the remaining portion of the enclosing &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt;, &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt;, &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; or &lt;a href=&quot;do&quot;&gt; do-while&lt;/a&gt; loop body to be skipped.</source>
          <target state="translated">Provoca que se omita la parte restante del cuerpo del bucle envolvente &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; , &lt;a href=&quot;range-for&quot;&gt;range-for&lt;/a&gt; , &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; o &lt;a href=&quot;do&quot;&gt;do-&lt;/a&gt; while.</target>
        </trans-unit>
        <trans-unit id="e2cc09c65ee94e9da20a5da53ff7a1764aa2d212" translate="yes" xml:space="preserve">
          <source>Certain &lt;a href=&quot;operator_arithmetic#Additive_operators&quot;&gt;addition, subtraction&lt;/a&gt;, &lt;a href=&quot;operator_incdec&quot;&gt;increment, and decrement&lt;/a&gt; operators are defined for pointers to elements of arrays: such pointers satisfy the &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; requirements and allow the C++ library &lt;a href=&quot;../algorithm&quot;&gt;algorithms&lt;/a&gt; to work with raw arrays.</source>
          <target state="translated">Ciertos operadores de &lt;a href=&quot;operator_arithmetic#Additive_operators&quot;&gt;suma, resta&lt;/a&gt; , &lt;a href=&quot;operator_incdec&quot;&gt;incremento y decremento&lt;/a&gt; se definen para punteros a elementos de matrices: tales punteros satisfacen los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; y permiten que los &lt;a href=&quot;../algorithm&quot;&gt;algoritmos de la&lt;/a&gt; biblioteca C ++ trabajen con matrices sin procesar.</target>
        </trans-unit>
        <trans-unit id="16ced4992002374e1ee48c60ab57aa3dd53629bb" translate="yes" xml:space="preserve">
          <source>Certain words in a C++ program have special meaning, and these are known as &lt;a href=&quot;../keywords&quot;&gt;keywords&lt;/a&gt;. Others can be used as &lt;a href=&quot;name&quot;&gt;identifiers&lt;/a&gt;. &lt;a href=&quot;../comments&quot;&gt;Comments&lt;/a&gt; are ignored during translation. Certain characters in the program have to be represented with &lt;a href=&quot;escape&quot;&gt;escape sequences&lt;/a&gt;.</source>
          <target state="translated">Ciertas palabras en un programa C ++ tienen un significado especial, y se conocen como &lt;a href=&quot;../keywords&quot;&gt;palabras clave&lt;/a&gt; . Otros pueden ser utilizados como &lt;a href=&quot;name&quot;&gt;identificadores&lt;/a&gt; . &lt;a href=&quot;../comments&quot;&gt;Los comentarios&lt;/a&gt; se ignoran durante la traducci&amp;oacute;n. Ciertos personajes en el programa tienen que ser representados con &lt;a href=&quot;escape&quot;&gt;secuencias de escape&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="191f1780427cc9f433fedbcd960fd714be286f24" translate="yes" xml:space="preserve">
          <source>Change the return type of the &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove_if()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;container/list/unique&quot;&gt;unique()&lt;/a&gt;&lt;/code&gt; members of &lt;code&gt;&lt;a href=&quot;container/forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Cambie el tipo de retorno de los miembros &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;container/list/remove&quot;&gt;remove_if()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;container/list/unique&quot;&gt;unique()&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;container/forward_list&quot;&gt;std::forward_list&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;container/list&quot;&gt;std::list&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a51058c46332744397288d2669e24ba920dc2025" translate="yes" xml:space="preserve">
          <source>Changes access permissions of the file to which &lt;code&gt;p&lt;/code&gt; resolves, as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html&quot;&gt;fchmodat&lt;/a&gt;. Symlinks are followed unless &lt;code&gt;perm_options::nofollow&lt;/code&gt; is set in &lt;code&gt;opts&lt;/code&gt;.</source>
          <target state="translated">Cambia los permisos de acceso del archivo al que se resuelve &lt;code&gt;p&lt;/code&gt; , como si fuera POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/fchmodat.html&quot;&gt;fchmodat&lt;/a&gt; . Se siguen los enlaces simb&amp;oacute;licos a menos que &lt;code&gt;perm_options::nofollow&lt;/code&gt; se establezca en &lt;code&gt;opts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d059f7f607e7b98754449b95b9c9f18d224be17e" translate="yes" xml:space="preserve">
          <source>Changes the associated locale so that all characters inserted or extracted after this call (and until another call to &lt;code&gt;imbue()&lt;/code&gt;) are converted using the &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet of &lt;code&gt;loc&lt;/code&gt;.</source>
          <target state="translated">Cambia la configuraci&amp;oacute;n regional asociada para que todos los caracteres insertados o extra&amp;iacute;dos despu&amp;eacute;s de esta llamada (y hasta que otra llamada a &lt;code&gt;imbue()&lt;/code&gt; ) se conviertan utilizando la faceta &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;loc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59519c86c11d2513037e609c3becf73e19a3102f" translate="yes" xml:space="preserve">
          <source>Changes the associated locale.</source>
          <target state="translated">Cambia el lugar asociado.</target>
        </trans-unit>
        <trans-unit id="e1931e70aa0ae325fe795a9e9d024fe1264be193" translate="yes" xml:space="preserve">
          <source>Changes the contained object to one of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; constructed from the arguments.</source>
          <target state="translated">Cambia el objeto contenido a uno de tipo &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; construido a partir de los argumentos.</target>
        </trans-unit>
        <trans-unit id="7260987e96fdc55dd04ca01a135da1cbdd6808b1" translate="yes" xml:space="preserve">
          <source>Changes the current emit-on-sync policy.</source>
          <target state="translated">Cambia la actual política de emisión-en-sincronización.</target>
        </trans-unit>
        <trans-unit id="900063105ed808c1839aeda96993e8913c65dcff" translate="yes" xml:space="preserve">
          <source>Changes the current file name and number in the preprocessor.</source>
          <target state="translated">Cambia el nombre y el número de archivo actual en el preprocesador.</target>
        </trans-unit>
        <trans-unit id="bcd3bc7bc25f117f48576a1067f3eab87dc09962" translate="yes" xml:space="preserve">
          <source>Changes the filename of a file. The file is identified by character string pointed to by &lt;code&gt;old_filename&lt;/code&gt;. The new filename is identified by character string pointed to by &lt;code&gt;new_filename&lt;/code&gt;.</source>
          <target state="translated">Cambia el nombre de archivo de un archivo. El archivo se identifica mediante una cadena de caracteres a la que apunta &lt;code&gt;old_filename&lt;/code&gt; . El nuevo nombre de archivo se identifica mediante la cadena de caracteres a la que apunta &lt;code&gt;new_filename&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a983560b5611c7eaf3bbb1134baa772fadd17a2a" translate="yes" xml:space="preserve">
          <source>Changes the filename of the directory entry.</source>
          <target state="translated">Cambia el nombre de archivo de la entrada del directorio.</target>
        </trans-unit>
        <trans-unit id="15ca90f2bd5d157747f2bcfd7fd13098d9365990" translate="yes" xml:space="preserve">
          <source>Changes the output format.</source>
          <target state="translated">Cambia el formato de salida.</target>
        </trans-unit>
        <trans-unit id="028cce033fce6f33e2a026dffc3790dff3f7ae1a" translate="yes" xml:space="preserve">
          <source>Changes the size of the regular file named by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html&quot;&gt;truncate&lt;/a&gt;: if the file size was previously larger than &lt;code&gt;new_size&lt;/code&gt;, the remainder of the file is discarded. If the file was previously smaller than &lt;code&gt;new_size&lt;/code&gt;, the file size is increased and the new area appears as if zero-filled.</source>
          <target state="translated">Cambia el tama&amp;ntilde;o del archivo normal nombrado por &lt;code&gt;p&lt;/code&gt; como por POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html&quot;&gt;truncate&lt;/a&gt; : si el tama&amp;ntilde;o del archivo era anteriormente mayor que &lt;code&gt;new_size&lt;/code&gt; , el resto del archivo se descarta. Si el archivo era anteriormente m&amp;aacute;s peque&amp;ntilde;o que &lt;code&gt;new_size&lt;/code&gt; , el tama&amp;ntilde;o del archivo aumenta y la nueva &amp;aacute;rea aparece como si estuviera llena de cero.</target>
        </trans-unit>
        <trans-unit id="9f1702f311546e930d8f583ff60c5b7dafb56f91" translate="yes" xml:space="preserve">
          <source>Changes the the buffering mode of the given file stream &lt;code&gt;stream&lt;/code&gt; as indicated by the argument &lt;code&gt;mode&lt;/code&gt;. In addition,</source>
          <target state="translated">Cambia el modo de almacenamiento en b&amp;uacute;fer de la secuencia de &lt;code&gt;stream&lt;/code&gt; archivo dada como lo indica el &lt;code&gt;mode&lt;/code&gt; argumento . Adicionalmente,</target>
        </trans-unit>
        <trans-unit id="db66637e4bd602383b9a36e093d02ad744d50d19" translate="yes" xml:space="preserve">
          <source>CharT</source>
          <target state="translated">CharT</target>
        </trans-unit>
        <trans-unit id="075d1aa22da1d1a791ea28f036dd3029899ef7df" translate="yes" xml:space="preserve">
          <source>CharTarray&lt;code&gt;[&lt;/code&gt;n&lt;code&gt;]&lt;/code&gt;&lt;code&gt;= &quot;&quot;;&lt;/code&gt;</source>
          <target state="translated">CharTarray &lt;code&gt;[&lt;/code&gt; n &lt;code&gt;]&lt;/code&gt; &lt;code&gt;= &quot;&quot;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3a40d3a3e7cab1d5912b21bb9180e2c135f3d1b0" translate="yes" xml:space="preserve">
          <source>CharTraits</source>
          <target state="translated">CharTraits</target>
        </trans-unit>
        <trans-unit id="ea0427dd5d6f2fd22fb387a84f007ebffee5c102" translate="yes" xml:space="preserve">
          <source>CharTraits is required by the following standard library class templates as a template type parameter:</source>
          <target state="translated">CharTraits es requerido por las siguientes plantillas de clase de la biblioteca estándar como un parámetro de tipo de plantilla:</target>
        </trans-unit>
        <trans-unit id="0f52782a792cc00d2892c8162c4d20455ac882bd" translate="yes" xml:space="preserve">
          <source>CharTraits is satisfied by the following standard library classes:</source>
          <target state="translated">CharTraits se satisface con las siguientes clases estándar de la biblioteca:</target>
        </trans-unit>
        <trans-unit id="ee9946c82d4a077c5be79e3015a3d2479d9fcaf2" translate="yes" xml:space="preserve">
          <source>Character</source>
          <target state="translated">Character</target>
        </trans-unit>
        <trans-unit id="f72882235ad60f37016237d8303fb8c1162e42f0" translate="yes" xml:space="preserve">
          <source>Character and character string arguments (e.g., of type &lt;code&gt;char&lt;/code&gt; or &lt;code&gt;const char*&lt;/code&gt;) are handled by the &lt;a href=&quot;operator_ltlt2&quot;&gt;non-member overloads&lt;/a&gt; of &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;. Attempting to output a character using the member function call syntax (e.g., &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.operator&amp;lt;&amp;lt;('c');&lt;/code&gt;) will call one of overloads (2-4) and output the numerical value. Attempting to output a character string using the member function call syntax will call overload (7) and print the pointer value instead.</source>
          <target state="translated">Los argumentos de caracteres y cadenas de caracteres (por ejemplo, de tipo &lt;code&gt;char&lt;/code&gt; o &lt;code&gt;const char*&lt;/code&gt; ) son manejados por las &lt;a href=&quot;operator_ltlt2&quot;&gt;sobrecargas no miembros&lt;/a&gt; del &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; . Intentar generar un car&amp;aacute;cter utilizando la sintaxis de llamada a la funci&amp;oacute;n miembro (por ejemplo, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.operator&amp;lt;&amp;lt;('c');&lt;/code&gt; ) llamar&amp;aacute; a una de las sobrecargas (2-4) y generar&amp;aacute; el valor num&amp;eacute;rico. Intentar generar una cadena de caracteres usando la sintaxis de llamada de funci&amp;oacute;n miembro llamar&amp;aacute; a sobrecarga (7) e imprimir&amp;aacute; el valor del puntero en su lugar.</target>
        </trans-unit>
        <trans-unit id="6512adfeb2b6b71a8085a0b4569a9025105f6ea1" translate="yes" xml:space="preserve">
          <source>Character array manipulation</source>
          <target state="translated">Manipulación de la matriz de caracteres</target>
        </trans-unit>
        <trans-unit id="e6c2fd1aae71d170866344f96ee158518de8bbea" translate="yes" xml:space="preserve">
          <source>Character arrays</source>
          <target state="translated">Matrices de personajes</target>
        </trans-unit>
        <trans-unit id="11a965778572465b297760373bc0ab9a5fe50dd4" translate="yes" xml:space="preserve">
          <source>Character classification</source>
          <target state="translated">Clasificación de caracteres</target>
        </trans-unit>
        <trans-unit id="5e46fee36b88268f4391d4aab452946b36ee208f" translate="yes" xml:space="preserve">
          <source>Character conversions</source>
          <target state="translated">Conversiones de caracteres</target>
        </trans-unit>
        <trans-unit id="ea3303247b226441481c96408e89f86363fc056f" translate="yes" xml:space="preserve">
          <source>Character converted to &lt;code&gt;char_type&lt;/code&gt;.</source>
          <target state="translated">Car&amp;aacute;cter convertido a &lt;code&gt;char_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c75ca2fc8c1a6a863ef50c02a9cfe0d0c2a00888" translate="yes" xml:space="preserve">
          <source>Character converted to its standard equivalent and then to &lt;code&gt;char&lt;/code&gt;. &lt;code&gt;dfault&lt;/code&gt; is returned if the conversion fails.</source>
          <target state="translated">Car&amp;aacute;cter convertido a su equivalente est&amp;aacute;ndar y luego a &lt;code&gt;char&lt;/code&gt; . Se devuelve el valor &lt;code&gt;dfault&lt;/code&gt; si la conversi&amp;oacute;n falla.</target>
        </trans-unit>
        <trans-unit id="71abf6f6cdd425368811b306d03c5406b82396a5" translate="yes" xml:space="preserve">
          <source>Character manipulation</source>
          <target state="translated">Manipulación de personajes</target>
        </trans-unit>
        <trans-unit id="4c58f86ca967b4e419cb22f348fc6985fce2677c" translate="yes" xml:space="preserve">
          <source>Character matching should be performed without regard to case.</source>
          <target state="translated">La comparación de caracteres debe realizarse sin tener en cuenta el caso.</target>
        </trans-unit>
        <trans-unit id="2c0613c06e2948d7013037f534e1060ec71035f9" translate="yes" xml:space="preserve">
          <source>Character ranges of the form</source>
          <target state="translated">Los rangos de caracteres de la forma</target>
        </trans-unit>
        <trans-unit id="01b4f31695ebfef5e54e268eeccaa5f720d189d9" translate="yes" xml:space="preserve">
          <source>Character string identifying the value of the environmental variable or null pointer if such variable is not found.</source>
          <target state="translated">Cadena de caracteres que identifica el valor de la variable ambiental o el puntero nulo si no se encuentra dicha variable.</target>
        </trans-unit>
        <trans-unit id="ce6ddaa694e2a7b4942fbc87cf18e8f64d26f9b2" translate="yes" xml:space="preserve">
          <source>Character types</source>
          <target state="translated">Tipos de caracteres</target>
        </trans-unit>
        <trans-unit id="2fa17410341c773958ab0b06148ed01369e49360" translate="yes" xml:space="preserve">
          <source>Characteristics</source>
          <target state="translated">Characteristics</target>
        </trans-unit>
        <trans-unit id="b6f59f08fd6d58c6725e21a9ec24e068148ec586" translate="yes" xml:space="preserve">
          <source>Characters</source>
          <target state="translated">Characters</target>
        </trans-unit>
        <trans-unit id="f75befe1513c72cfd4b48f48e3e273b661b4521f" translate="yes" xml:space="preserve">
          <source>Characters are extracted until either.</source>
          <target state="translated">Los personajes se extraen hasta que cualquiera de ellos.</target>
        </trans-unit>
        <trans-unit id="5d0fadb68912f46be7478bf1dc2a449a1ccab7e3" translate="yes" xml:space="preserve">
          <source>Characters following the null character are not compared.</source>
          <target state="translated">Los caracteres que siguen al carácter nulo no se comparan.</target>
        </trans-unit>
        <trans-unit id="bbb7ac13141743e85ef9cf35d0729e5e44ee839e" translate="yes" xml:space="preserve">
          <source>Checks for the presence of an &lt;a href=&quot;language/attributes&quot;&gt;attribute&lt;/a&gt;.</source>
          <target state="translated">Comprueba la presencia de un &lt;a href=&quot;language/attributes&quot;&gt;atributo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5c239cb24da30a931bb645a231c2c1a422922f55" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; is the only &lt;code&gt;shared_ptr&lt;/code&gt; instance managing the current object, i.e. whether &lt;code&gt;use_count() == 1&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;*this&lt;/code&gt; es la &amp;uacute;nica instancia &lt;code&gt;shared_ptr&lt;/code&gt; que administra el objeto actual, es decir, si &lt;code&gt;use_count() == 1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64fe6c568f795adfd098e0d63f6859cec6831cc6" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; represents a valid date. Because a &lt;code&gt;year_month_day_last&lt;/code&gt; represents the last day of a particular month, it represents a valid date as long as the year and month are valid.</source>
          <target state="translated">Comprueba si &lt;code&gt;*this&lt;/code&gt; representa una fecha v&amp;aacute;lida. Como &lt;code&gt;year_month_day_last&lt;/code&gt; representa el &amp;uacute;ltimo d&amp;iacute;a de un mes en particular, representa una fecha v&amp;aacute;lida siempre que el a&amp;ntilde;o y el mes sean v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="0373b2fbb18e3c084d0c6cb8a8392f2d23211bd2" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;*this&lt;/code&gt; stores a non-null pointer, i.e. whether &lt;code&gt;get() != nullptr&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;*this&lt;/code&gt; almacena un puntero no nulo, es decir, si &lt;code&gt;get() != nullptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4fb57d3244245c7b2c53e5525199fd6990e81a5" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate type&lt;/a&gt;. The member constant &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is an aggregate type and &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;tipo agregado&lt;/a&gt; . El &lt;code&gt;value&lt;/code&gt; constante del miembro es igual a &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es un tipo agregado y &lt;code&gt;false&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="46810c15e7731f0bcc598e64e82c003580066f60" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;ch&lt;/code&gt; is a printable character as classified by the currently installed C locale. In the default, &quot;C&quot; locale, the following characters are printable:</source>
          <target state="translated">Comprueba si &lt;code&gt;ch&lt;/code&gt; es un car&amp;aacute;cter imprimible clasificado por la configuraci&amp;oacute;n regional C actualmente instalada. En la configuraci&amp;oacute;n regional &quot;C&quot; predeterminada, se pueden imprimir los siguientes caracteres:</target>
        </trans-unit>
        <trans-unit id="bef2c39f0952ee3e2e6df2eb7c4b6c1cb97c1231" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">Comprueba si &lt;code&gt;lhs&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="8742a8ea58f9f8b2f58eab45ce84322d20b1ef7e" translate="yes" xml:space="preserve">
          <source>Checks if &lt;code&gt;x&lt;/code&gt; is an integral power of two.</source>
          <target state="translated">Comprueba si &lt;code&gt;x&lt;/code&gt; es una potencia integral de dos.</target>
        </trans-unit>
        <trans-unit id="e01f0ff952438d49e950107b31dc2f6d176fb839" translate="yes" xml:space="preserve">
          <source>Checks if all, any or none of the bits are set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Comprueba si todos, ninguno o ninguno de los bits est&amp;aacute;n establecidos en &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd2ed423ea71f7993be85315a4cf55c91df927f" translate="yes" xml:space="preserve">
          <source>Checks if an element equivalent to &lt;code&gt;value&lt;/code&gt; appears within the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">Comprueba si un elemento equivalente al &lt;code&gt;value&lt;/code&gt; aparece dentro del rango &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3df65edb22a1ea82942fb937399112c261a1ddf5" translate="yes" xml:space="preserve">
          <source>Checks if the &lt;code&gt;month&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt; is valid.</source>
          <target state="translated">Comprueba si el objeto de &lt;code&gt;month&lt;/code&gt; almacenado en &lt;code&gt;*this&lt;/code&gt; es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="cf1c1960bf8bd117039d083bce42dfd50d32f263" translate="yes" xml:space="preserve">
          <source>Checks if the contained &lt;a href=&quot;../month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../weekday_indexed&quot;&gt;&lt;code&gt;weekday_indexed&lt;/code&gt;&lt;/a&gt; objects are valid.</source>
          <target state="translated">Verifica si los objetos contenidos &lt;a href=&quot;../month&quot;&gt; &lt;code&gt;month&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../weekday_indexed&quot;&gt; &lt;code&gt;weekday_indexed&lt;/code&gt; &lt;/a&gt; son v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="c0e9dbc22fbac3c623e99fa4b12c00c784887ebb" translate="yes" xml:space="preserve">
          <source>Checks if the contained &lt;a href=&quot;../month&quot;&gt;&lt;code&gt;month&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../weekday_last&quot;&gt;&lt;code&gt;weekday_last&lt;/code&gt;&lt;/a&gt; objects are valid.</source>
          <target state="translated">Comprueba si los objetos &lt;a href=&quot;../month&quot;&gt; &lt;code&gt;month&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../weekday_last&quot;&gt; &lt;code&gt;weekday_last&lt;/code&gt; &lt;/a&gt; son v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="a186fda0be6fbf8b4f0463ca58545aab4b63c811" translate="yes" xml:space="preserve">
          <source>Checks if the container has no elements, i.e. whether &lt;code&gt;begin() == end()&lt;/code&gt;.</source>
          <target state="translated">Comprueba si el contenedor no tiene elementos, es decir, si &lt;code&gt;begin() == end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdababdda3b078e8a754954e78f43fa63c1e9fca" translate="yes" xml:space="preserve">
          <source>Checks if the day value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [1, 31].</source>
          <target state="translated">Comprueba si el valor del d&amp;iacute;a almacenado en &lt;code&gt;*this&lt;/code&gt; est&amp;aacute; dentro del rango v&amp;aacute;lido, es decir, [1, 31].</target>
        </trans-unit>
        <trans-unit id="883d61f7b86b64216417405d15836a0059e52c16" translate="yes" xml:space="preserve">
          <source>Checks if the elements in range &lt;code&gt;[first, last)&lt;/code&gt; are a</source>
          <target state="translated">Comprueba si los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; son un</target>
        </trans-unit>
        <trans-unit id="edd5932dbd43271b51bea92b6301c914eb0d9627" translate="yes" xml:space="preserve">
          <source>Checks if the elements in range &lt;code&gt;[first, last)&lt;/code&gt; are sorted in non-descending order.</source>
          <target state="translated">Comprueba si los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; est&amp;aacute;n ordenados en orden no descendente.</target>
        </trans-unit>
        <trans-unit id="7583a23f352a0114e03ecd5b421ac82f127e76d4" translate="yes" xml:space="preserve">
          <source>Checks if the end of the given file stream has been reached.</source>
          <target state="translated">Comprueba si se ha alcanzado el final del flujo de archivos dado.</target>
        </trans-unit>
        <trans-unit id="0ea631da0eac64b4493283ac77224a99a20a1afb" translate="yes" xml:space="preserve">
          <source>Checks if the error value is valid, i.e. non-zero.</source>
          <target state="translated">Comprueba si el valor de error es válido,es decir,no es cero.</target>
        </trans-unit>
        <trans-unit id="e0a4ec6efbb9408286b1f97366f614bd6aebe167" translate="yes" xml:space="preserve">
          <source>Checks if the file stream has an associated file.</source>
          <target state="translated">Comprueba si el flujo de archivos tiene un archivo asociado.</target>
        </trans-unit>
        <trans-unit id="9939f20d92c8448e034a9fb2ce041b3a30041e38" translate="yes" xml:space="preserve">
          <source>Checks if the first range &lt;code&gt;[first1, last1)&lt;/code&gt; is lexicographically</source>
          <target state="translated">Comprueba si el primer rango &lt;code&gt;[first1, last1)&lt;/code&gt; es lexicogr&amp;aacute;fico</target>
        </trans-unit>
        <trans-unit id="9c9cf6d9c81ca1a6f48142b146482b5a7d92c18d" translate="yes" xml:space="preserve">
          <source>Checks if the future refers to a shared state.</source>
          <target state="translated">Comprueba si el futuro se refiere a un estado compartido.</target>
        </trans-unit>
        <trans-unit id="1f541bb8843b33c6aed03a6b4cf9d5e87a333b18" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as a graphic character (i.e. printable, excluding space) by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado se clasific&amp;oacute; como un car&amp;aacute;cter gr&amp;aacute;fico (es decir, imprimible, excluyendo el espacio) por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; la localidad dada .</target>
        </trans-unit>
        <trans-unit id="2b8c77159013c45824384fde718470edb60e4d82" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as a printable character (including space) by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado se clasific&amp;oacute; como un car&amp;aacute;cter imprimible (incluido el espacio) por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; la localidad dada .</target>
        </trans-unit>
        <trans-unit id="8c2b1f4fcd055b704d957a1b2cdeb2187a3b7dbc" translate="yes" xml:space="preserve">
          <source>Checks if the given character classified as an alphanumeric character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado est&amp;aacute; clasificado como un car&amp;aacute;cter alfanum&amp;eacute;rico por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; la localidad dada .</target>
        </trans-unit>
        <trans-unit id="4f79c82fa33d708a83fc2cde057f0b8a25d9b077" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a blank character as classified by the currently installed C locale. Blank characters are whitespace characters used to separate words within a sentence. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are classified as blank characters.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado es un car&amp;aacute;cter en blanco seg&amp;uacute;n la clasificaci&amp;oacute;n de la configuraci&amp;oacute;n regional C actualmente instalada. Los caracteres en blanco son espacios en blanco que se usan para separar palabras dentro de una oraci&amp;oacute;n. En la configuraci&amp;oacute;n regional C predeterminada, solo el espacio ( &lt;code&gt;0x20&lt;/code&gt; ) y la pesta&amp;ntilde;a horizontal ( &lt;code&gt;0x09&lt;/code&gt; ) se clasifican como caracteres en blanco.</target>
        </trans-unit>
        <trans-unit id="63924bd06b9cfc417682f6f2da0b8cccc1b40b2a" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a control character as classified by the currently installed C locale. In the default, &quot;C&quot; locale, the control characters are the characters with the codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt;.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado es un car&amp;aacute;cter de control clasificado por la configuraci&amp;oacute;n regional C actualmente instalada. En la configuraci&amp;oacute;n regional &quot;C&quot; predeterminada, los caracteres de control son los caracteres con los c&amp;oacute;digos &lt;code&gt;0x00-0x1F&lt;/code&gt; y &lt;code&gt;0x7F&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="620ca22193327aabe490bc69707b719cd34918b4" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a hexadecimal numeric character (&lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;).</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado es un car&amp;aacute;cter num&amp;eacute;rico hexadecimal ( &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="8b960e379d1de64e4dd59c0a98f8f7ba08f6e01b" translate="yes" xml:space="preserve">
          <source>Checks if the given character is a punctuation character as classified by the current C locale. The default C locale classifies the characters &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; as punctuation.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado es un car&amp;aacute;cter de puntuaci&amp;oacute;n seg&amp;uacute;n la clasificaci&amp;oacute;n de la configuraci&amp;oacute;n regional actual de C. &amp;iexcl;La configuraci&amp;oacute;n regional predeterminada de C clasifica los caracteres &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; Como puntuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e36cb86f2350ed7cbcb8c08ff869f068fcb37a55" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphabetic character as classified by the currently installed C locale. In the default locale, the following characters are alphabetic:</source>
          <target state="translated">Comprueba si el carácter dado es un carácter alfabético según la clasificación del local C actualmente instalado.En la localización predeterminada,los siguientes caracteres son alfabéticos:</target>
        </trans-unit>
        <trans-unit id="8460053f4f6257cbef25ff160120cc6c7e959e75" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an alphanumeric character as classified by the current C locale. In the default locale, the following characters are alphanumeric:</source>
          <target state="translated">Comprueba si el carácter dado es un carácter alfanumérico según la clasificación de la actual localidad C.En la localidad predeterminada,los siguientes caracteres son alfanuméricos:</target>
        </trans-unit>
        <trans-unit id="e7168f1ddb2b4d425325e246ea920d97240da433" translate="yes" xml:space="preserve">
          <source>Checks if the given character is an uppercase character as classified by the currently installed C locale. In the default &quot;C&quot; locale, &lt;code&gt;isupper&lt;/code&gt; returns a nonzero value only for the uppercase letters (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;).</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado es un car&amp;aacute;cter en may&amp;uacute;sculas seg&amp;uacute;n la clasificaci&amp;oacute;n de la configuraci&amp;oacute;n regional C actualmente instalada. En la configuraci&amp;oacute;n regional &quot;C&quot; predeterminada, &lt;code&gt;isupper&lt;/code&gt; devuelve un valor distinto de cero solo para las letras may&amp;uacute;sculas ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11145349eb5a7ce12671e4ea9c07676f5f562772" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a blank character by the given locale's ctype facet.</source>
          <target state="translated">Comprueba si el carácter dado se clasifica como un carácter en blanco por la faceta de tipo c de la localidad dada.</target>
        </trans-unit>
        <trans-unit id="6d19f846387e2564dd01a4273fc111bb0f3752b9" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a control character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado est&amp;aacute; clasificado como un car&amp;aacute;cter de control por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; del entorno local dado .</target>
        </trans-unit>
        <trans-unit id="d1d14d696222c936849b54795e37e65ab005fff8" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a digit by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado est&amp;aacute; clasificado como un d&amp;iacute;gito por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; la localidad dada .</target>
        </trans-unit>
        <trans-unit id="65f5cc11ad968a30d5184556f3ca2929d52f75ca" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a hexadecimal digit by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado est&amp;aacute; clasificado como un d&amp;iacute;gito hexadecimal por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; la localidad dada .</target>
        </trans-unit>
        <trans-unit id="5a564f70b3df82a305537021cab411cdbd81adce" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado est&amp;aacute; clasificado como un car&amp;aacute;cter alfab&amp;eacute;tico en min&amp;uacute;sculas por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; la localidad dada .</target>
        </trans-unit>
        <trans-unit id="2a2d197badc519c2b6d6b8c1c0f0089443b1e3e0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a lowercase character according to the current C locale. In the default &quot;C&quot; locale, &lt;code&gt;islower&lt;/code&gt; returns a nonzero value only for the lowercase letters (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;).</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado se clasifica como un car&amp;aacute;cter en min&amp;uacute;scula de acuerdo con la configuraci&amp;oacute;n regional actual de C. En la configuraci&amp;oacute;n regional &quot;C&quot; predeterminada, &lt;code&gt;islower&lt;/code&gt; devuelve un valor distinto de cero solo para las letras min&amp;uacute;sculas ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="23434ffbce64a443ceebe9b25bfd4dee6b410a4d" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as a whitespace character by the given locale's ctype facet.</source>
          <target state="translated">Comprueba si el carácter dado se clasifica como un carácter de espacio en blanco por la faceta de tipo c de la localidad dada.</target>
        </trans-unit>
        <trans-unit id="29b8c4707acb6f5f5b0af799234d886e0c8bdb59" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado est&amp;aacute; clasificado como un car&amp;aacute;cter alfab&amp;eacute;tico por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; la localidad dada .</target>
        </trans-unit>
        <trans-unit id="f13395f8feb0b1900f02da016716c265861d48bd" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an punctuation character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado est&amp;aacute; clasificado como un car&amp;aacute;cter de puntuaci&amp;oacute;n por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; del entorno local dado .</target>
        </trans-unit>
        <trans-unit id="06bebae7934c976345409e18e4892deb4f07b810" translate="yes" xml:space="preserve">
          <source>Checks if the given character is classified as an uppercase alphabetic character by the given locale's &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado est&amp;aacute; clasificado como un car&amp;aacute;cter alfab&amp;eacute;tico en may&amp;uacute;sculas por la faceta &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; la localidad dada .</target>
        </trans-unit>
        <trans-unit id="05ecdcea5d58ceaa8ef5f1b140c063bf55d26ae8" translate="yes" xml:space="preserve">
          <source>Checks if the given character is graphic (has a graphical representation) as classified by the currently installed C locale. In the default C locale, the following characters are graphic:</source>
          <target state="translated">Comprueba si el personaje dado es gráfico (tiene una representación gráfica)según la clasificación de la localidad C actualmente instalada.En el local C por defecto,los siguientes caracteres son gráficos:</target>
        </trans-unit>
        <trans-unit id="53e2f7b7aaa15bbc121a001ba778520977aa5a41" translate="yes" xml:space="preserve">
          <source>Checks if the given character is one of the 10 decimal digits: &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter dado es uno de los 10 d&amp;iacute;gitos decimales: &lt;code&gt;0123456789&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe8cd0a6bef5c367f22c30f7a34e386596daca0" translate="yes" xml:space="preserve">
          <source>Checks if the given character is whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:</source>
          <target state="translated">Comprueba si el carácter dado es un carácter de espacio en blanco según la clasificación de la localidad C actualmente instalada.En la localización predeterminada,los caracteres de espacio en blanco son los siguientes:</target>
        </trans-unit>
        <trans-unit id="eb1f23b247c77dd957a70ee1a23c0abb19665059" translate="yes" xml:space="preserve">
          <source>Checks if the given file status is known, Equivalent to &lt;code&gt;s.type() != file_type::none&lt;/code&gt;.</source>
          <target state="translated">Comprueba si se conoce el estado del archivo dado, equivalente a &lt;code&gt;s.type() != file_type::none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="218bbbf54d03f6b2078dbf8b7f02244dc7b15314" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a FIFO or pipe file as if determined by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISFIFO&lt;/a&gt;.</source>
          <target state="translated">Comprueba si el estado o la ruta del archivo dado corresponde a un FIFO o un archivo de tuber&amp;iacute;a como lo determina POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISFIFO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a5bbc2239e82c8c44869791aa800f48187a92cdb" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a block special file, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISBLK &lt;/a&gt;. Examples of block special files are block devices such as &lt;code&gt;/dev/sda&lt;/code&gt; or &lt;code&gt;/dev/loop0&lt;/code&gt; on Linux.</source>
          <target state="translated">Comprueba si el estado o la ruta del archivo dado corresponde a un archivo especial de bloque, como lo determina POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISBLK&lt;/a&gt; . Ejemplos de archivos especiales de bloque son dispositivos de bloque como &lt;code&gt;/dev/sda&lt;/code&gt; o &lt;code&gt;/dev/loop0&lt;/code&gt; en Linux.</target>
        </trans-unit>
        <trans-unit id="cd5468dc57f1c432cf3158ebdd4f2506febe1e97" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a character special file, as if determined by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISCHR&lt;/a&gt;. Examples of character special files are character devices such as &lt;code&gt;/dev/null&lt;/code&gt;, &lt;code&gt;/dev/tty&lt;/code&gt;, &lt;code&gt;/dev/audio&lt;/code&gt;, or &lt;code&gt;/dev/nvram&lt;/code&gt; on Linux.</source>
          <target state="translated">Comprueba si el estado o la ruta del archivo dado corresponde a un archivo especial de caracteres, como lo determina POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_ISCHR&lt;/a&gt; . Ejemplos de archivos especiales de caracteres son los dispositivos de caracteres como &lt;code&gt;/dev/null&lt;/code&gt; , &lt;code&gt;/dev/tty&lt;/code&gt; , &lt;code&gt;/dev/audio&lt;/code&gt; o &lt;code&gt;/dev/nvram&lt;/code&gt; en Linux.</target>
        </trans-unit>
        <trans-unit id="5800e2498685522757fe31c5c55c07d4ca923fef" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a directory.</source>
          <target state="translated">Comprueba si el estado o la ruta del archivo dado corresponde a un directorio.</target>
        </trans-unit>
        <trans-unit id="1a93cdcd4a85825d11b2a20b899602004622f63c" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a file of type</source>
          <target state="translated">Comprueba si el estado o la ruta del archivo dado corresponde a un archivo de tipo</target>
        </trans-unit>
        <trans-unit id="bac818da5390c8dda2cd14c441525beaeb1ca7ce" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a named IPC socket, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFSOCK&lt;/a&gt;.</source>
          <target state="translated">Comprueba si el estado o la ruta del archivo dado corresponde a un socket IPC con nombre, como lo determina POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFSOCK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5cbb58c72659913381cfab0101affa7e32b4218a" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a regular file.</source>
          <target state="translated">Comprueba si el estado o la ruta del archivo dado corresponde a un archivo regular.</target>
        </trans-unit>
        <trans-unit id="069358c7a4934c3a0eff64f5a19fd200748050f4" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to a symbolic link, as if determined by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFLNK&lt;/a&gt;.</source>
          <target state="translated">Comprueba si el estado o la ruta del archivo dado corresponde a un enlace simb&amp;oacute;lico, como lo determina POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/sys_stat.h.html&quot;&gt;S_IFLNK&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7887d8d69526f9ccd0654883e159eed9a48b721d" translate="yes" xml:space="preserve">
          <source>Checks if the given file status or path corresponds to an existing file or directory.</source>
          <target state="translated">Comprueba si el estado o la ruta del archivo dado corresponde a un archivo o directorio existente.</target>
        </trans-unit>
        <trans-unit id="86e15e5f001ace8d5ed732d67f679b17b8027345" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character can be printed, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;), space or any printable character specific to the current C locale.</source>
          <target state="translated">Comprueba si se puede imprimir el car&amp;aacute;cter ancho dado, es decir, si es un n&amp;uacute;mero ( &lt;code&gt;0123456789&lt;/code&gt; ), una letra may&amp;uacute;scula ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), una letra min&amp;uacute;scula ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), un car&amp;aacute;cter de puntuaci&amp;oacute;n ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ), espacio o cualquier car&amp;aacute;cter imprimible espec&amp;iacute;fico de la ubicaci&amp;oacute;n C actual.</target>
        </trans-unit>
        <trans-unit id="6ddf1d4606203515c454d3cbf72c353c2b7a5550" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to a hexadecimal numeric character, i.e. one of &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt;.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado corresponde (si se reduce) a un car&amp;aacute;cter num&amp;eacute;rico hexadecimal, es decir, uno de &lt;code&gt;0123456789abcdefABCDEF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9737563245a39a0f23f82812e136487feb35b8a3" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character corresponds (if narrowed) to one of the ten decimal digit characters &lt;code&gt;0123456789&lt;/code&gt;.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado corresponde (si se reduce) a uno de los diez d&amp;iacute;gitos decimales &lt;code&gt;0123456789&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="901c321d30a4b9e0c1bb0f4ce4f0b7f3fc5086ff" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character has a graphical representation, i.e. it is either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;), a punctuation character(&lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt;) or any graphical character specific to the current C locale.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado tiene una representaci&amp;oacute;n gr&amp;aacute;fica, es decir, es un n&amp;uacute;mero ( &lt;code&gt;0123456789&lt;/code&gt; ), una letra may&amp;uacute;scula ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), una letra min&amp;uacute;scula ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ), un car&amp;aacute;cter de puntuaci&amp;oacute;n ( &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; ) o cualquier car&amp;aacute;cter gr&amp;aacute;fico espec&amp;iacute;fico del entorno local actual de C.</target>
        </trans-unit>
        <trans-unit id="69347e858d3166f00f30fe95f9dd5f5ae37bc816" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a control character, i.e. codes &lt;code&gt;0x00-0x1F&lt;/code&gt; and &lt;code&gt;0x7F&lt;/code&gt; and any control characters specific to the current locale.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado es un car&amp;aacute;cter de control, es decir, c&amp;oacute;digos &lt;code&gt;0x00-0x1F&lt;/code&gt; y &lt;code&gt;0x7F&lt;/code&gt; y cualquier car&amp;aacute;cter de control espec&amp;iacute;fico de la configuraci&amp;oacute;n regional actual.</target>
        </trans-unit>
        <trans-unit id="f75e93760224f49060fa9daae484b93562cec26c" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a lowercase letter, i.e. one of &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; or any lowercase letter specific to the current locale.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado es una letra min&amp;uacute;scula, es decir, una de &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; o cualquier letra min&amp;uacute;scula espec&amp;iacute;fica del entorno local actual.</target>
        </trans-unit>
        <trans-unit id="d3bc1df8c65e55dc36b4066a3cfbf00b5eb6d139" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a punctuation character, i.e. it is one of &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; or any punctuation character specific to the current locale.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado es un car&amp;aacute;cter de puntuaci&amp;oacute;n, es decir, es uno de &lt;code&gt;!&quot;#$%&amp;amp;'()*+,-./:;&amp;lt;=&amp;gt;?@[\]^_`{|}~&lt;/code&gt; O cualquiera car&amp;aacute;cter de puntuaci&amp;oacute;n espec&amp;iacute;fico del entorno local actual.</target>
        </trans-unit>
        <trans-unit id="7082207d2a2725304cb1acc7985965ef85b95446" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is a wide whitespace character as classified by the currently installed C locale. In the default locale, the whitespace characters are the following:</source>
          <target state="translated">Comprueba si el carácter ancho dado es un carácter de espacio blanco ancho según la clasificación de la localidad C actualmente instalada.En la localización predeterminada,los caracteres de espacio en blanco son los siguientes:</target>
        </trans-unit>
        <trans-unit id="ecee395d873139c5f79bbced8e5ab2094298ef99" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphabetic character, i.e. either an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphabetic character specific to the current locale.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado es un car&amp;aacute;cter alfab&amp;eacute;tico, es decir, una letra may&amp;uacute;scula ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), una letra min&amp;uacute;scula ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) o cualquier car&amp;aacute;cter alfab&amp;eacute;tico espec&amp;iacute;fico de la ubicaci&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="5467527cb982943f926960fa171baeacafcc85de" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an alphanumeric character, i.e. either a number (&lt;code&gt;0123456789&lt;/code&gt;), an uppercase letter (&lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;), a lowercase letter (&lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;) or any alphanumeric character specific to the current locale.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado es un car&amp;aacute;cter alfanum&amp;eacute;rico, es decir, un n&amp;uacute;mero ( &lt;code&gt;0123456789&lt;/code&gt; ), una letra may&amp;uacute;scula ( &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; ), una letra min&amp;uacute;scula ( &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; ) o cualquier car&amp;aacute;cter alfanum&amp;eacute;rico espec&amp;iacute;fico de la ubicaci&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="43c33322c3d3cfbcbf8bd68f060fd927a3eb782d" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is an uppercase letter, i.e. one of &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; or any uppercase letter specific to the current locale.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado es una letra may&amp;uacute;scula, es decir, una de &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; o cualquier letra may&amp;uacute;scula espec&amp;iacute;fica del entorno local actual.</target>
        </trans-unit>
        <trans-unit id="1541b6076382859c29bdb454303ad0411f5bf188" translate="yes" xml:space="preserve">
          <source>Checks if the given wide character is classified as blank character (that is, a whitespace character used to separate words in a sentence) by the current C locale. In the default C locale, only space (&lt;code&gt;0x20&lt;/code&gt;) and horizontal tab (&lt;code&gt;0x09&lt;/code&gt;) are blank characters.</source>
          <target state="translated">Comprueba si el car&amp;aacute;cter ancho dado se clasifica como un car&amp;aacute;cter en blanco (es decir, un car&amp;aacute;cter de espacio en blanco utilizado para separar las palabras en una oraci&amp;oacute;n) seg&amp;uacute;n la configuraci&amp;oacute;n regional actual de C. En la configuraci&amp;oacute;n regional C predeterminada, solo el espacio ( &lt;code&gt;0x20&lt;/code&gt; ) y la pesta&amp;ntilde;a horizontal ( &lt;code&gt;0x09&lt;/code&gt; ) son caracteres en blanco.</target>
        </trans-unit>
        <trans-unit id="5b129df05edbccc2dbdbb661453142c518a02f19" translate="yes" xml:space="preserve">
          <source>Checks if the identifier was &lt;a href=&quot;replace&quot;&gt;defined as a macro name&lt;/a&gt;.</source>
          <target state="translated">Comprueba si el identificador se &lt;a href=&quot;replace&quot;&gt;defini&amp;oacute; como un nombre de macro&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64cb0aa280d8c5b49543261dbfb062c65e2ea369" translate="yes" xml:space="preserve">
          <source>Checks if the locale &lt;code&gt;loc&lt;/code&gt; implements the facet &lt;code&gt;Facet&lt;/code&gt;.</source>
          <target state="translated">Comprueba si la configuraci&amp;oacute;n regional &lt;code&gt;loc&lt;/code&gt; implementa la faceta &lt;code&gt;Facet&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9985c18b99c624309993b776322be3e5b6066d2" translate="yes" xml:space="preserve">
          <source>Checks if the month value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [1, 12].</source>
          <target state="translated">Comprueba si el valor del mes almacenado en &lt;code&gt;*this&lt;/code&gt; est&amp;aacute; dentro del rango v&amp;aacute;lido, es decir, [1, 12].</target>
        </trans-unit>
        <trans-unit id="f0dd7dcb8d83418ab5c1982a79ec6863927fac41" translate="yes" xml:space="preserve">
          <source>Checks if the objects refer to the same types.</source>
          <target state="translated">Comprueba si los objetos se refieren a los mismos tipos.</target>
        </trans-unit>
        <trans-unit id="afce813d540f870643a2e6dca3dce7be3e73c275" translate="yes" xml:space="preserve">
          <source>Checks if the path in generic format is empty.</source>
          <target state="translated">Comprueba si la ruta en formato genérico está vacía.</target>
        </trans-unit>
        <trans-unit id="071d812ba3714e0179abe833e7757fda078f2ab3" translate="yes" xml:space="preserve">
          <source>Checks if the span is empty.</source>
          <target state="translated">Comprueba si el palo está vacío.</target>
        </trans-unit>
        <trans-unit id="8d21231b9c8a7c7e4c607dfb289d854bd85592b5" translate="yes" xml:space="preserve">
          <source>Checks if the string begins with the given prefix, where.</source>
          <target state="translated">Comprueba si la cadena comienza con el prefijo dado,dónde.</target>
        </trans-unit>
        <trans-unit id="71b7c6ae3905a663f394b1116d26498963174727" translate="yes" xml:space="preserve">
          <source>Checks if the string ends with the given suffix, where.</source>
          <target state="translated">Comprueba si la cuerda termina con el sufijo dado,dónde.</target>
        </trans-unit>
        <trans-unit id="49c8ee0c41c7b9956041b8533f0a3c22e35fb914" translate="yes" xml:space="preserve">
          <source>Checks if the string has no characters, i.e. whether &lt;code&gt;begin() == end()&lt;/code&gt;.</source>
          <target state="translated">Comprueba si la cadena no tiene caracteres, es decir, si &lt;code&gt;begin() == end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f75909c8025e14e89620cb4160aa02ff233aed4b" translate="yes" xml:space="preserve">
          <source>Checks if the string view begins with the given prefix, where.</source>
          <target state="translated">Comprueba si la vista de la cadena comienza con el prefijo dado,donde.</target>
        </trans-unit>
        <trans-unit id="7427d8a4aadff39d88d1b06e6bec36a6333d8cae" translate="yes" xml:space="preserve">
          <source>Checks if the string view ends with the given suffix, where.</source>
          <target state="translated">Comprueba si la vista de la cadena termina con el sufijo dado,dónde.</target>
        </trans-unit>
        <trans-unit id="4c97dbdbc5ab4d6a6b9d169e205e7ed31539d6f2" translate="yes" xml:space="preserve">
          <source>Checks if the thread object identifies an active thread of execution. Specifically, returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;get_id() != &lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;()&lt;/code&gt;. So a default constructed &lt;code&gt;thread&lt;/code&gt; is not joinable.</source>
          <target state="translated">Comprueba si el objeto de hilo identifica un hilo activo de ejecuci&amp;oacute;n. Espec&amp;iacute;ficamente, devuelve &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;get_id() != &lt;a href=&quot;id&quot;&gt;std::thread::id&lt;/a&gt;()&lt;/code&gt; . Por lo tanto, un &lt;code&gt;thread&lt;/code&gt; construido por defecto no se puede unir.</target>
        </trans-unit>
        <trans-unit id="c5f3b8028d75916c6cdb6ba96aa95864bd377eef" translate="yes" xml:space="preserve">
          <source>Checks if the underlying container has no elements, i.e. whether &lt;code&gt;c.empty()&lt;/code&gt;.</source>
          <target state="translated">Comprueba si el contenedor subyacente no tiene elementos, es decir, si &lt;code&gt;c.empty()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a67620d24bc287120096a35fb784d0aa23f510f3" translate="yes" xml:space="preserve">
          <source>Checks if the variant &lt;code&gt;v&lt;/code&gt; holds the alternative &lt;code&gt;T&lt;/code&gt;. The call is ill-formed if &lt;code&gt;T&lt;/code&gt; does not appear exactly once in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">Comprueba si la variante &lt;code&gt;v&lt;/code&gt; posee la alternativa &lt;code&gt;T&lt;/code&gt; . La llamada est&amp;aacute; mal formada si &lt;code&gt;T&lt;/code&gt; no aparece exactamente una vez en &lt;code&gt;Types...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="af699c2fb33c530d4e019c89f05d9a81a1ed9be7" translate="yes" xml:space="preserve">
          <source>Checks if the view has no characters, i.e. whether &lt;code&gt;size() == 0&lt;/code&gt;.</source>
          <target state="translated">Comprueba si la vista no tiene caracteres, es decir, si &lt;code&gt;size() == 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bb1c34feb70b41fb26ff6f15e61488cf7b90f70" translate="yes" xml:space="preserve">
          <source>Checks if the weekday object and the index stored in &lt;code&gt;*this&lt;/code&gt; are both valid.</source>
          <target state="translated">Comprueba si el objeto del d&amp;iacute;a de la semana y el &amp;iacute;ndice almacenados en &lt;code&gt;*this&lt;/code&gt; son v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="2f994a993b7fef807fb525562e15e1525c1a69a9" translate="yes" xml:space="preserve">
          <source>Checks if the weekday object stored in &lt;code&gt;*this&lt;/code&gt; is valid.</source>
          <target state="translated">Comprueba si el objeto del d&amp;iacute;a de la semana almacenado en &lt;code&gt;*this&lt;/code&gt; es v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="1b7ab4115c5420b5077429b962479db9584a2da3" translate="yes" xml:space="preserve">
          <source>Checks if the weekday value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [0, 6].</source>
          <target state="translated">Comprueba si el valor del d&amp;iacute;a de la semana almacenado en &lt;code&gt;*this&lt;/code&gt; est&amp;aacute; dentro del rango v&amp;aacute;lido, es decir, [0, 6].</target>
        </trans-unit>
        <trans-unit id="9931d20719fee825f5a129c05c9d24c6dd21e79b" translate="yes" xml:space="preserve">
          <source>Checks if the year and month values stored in this object are valid.</source>
          <target state="translated">Comprueba si los valores del año y del mes almacenados en este objeto son válidos.</target>
        </trans-unit>
        <trans-unit id="dd3b595aeae50a14c0fc3a412a6eb6ed2aaf74d7" translate="yes" xml:space="preserve">
          <source>Checks if the year value stored in &lt;code&gt;*this&lt;/code&gt; is in the valid range, i.e., [-32767, 32767].</source>
          <target state="translated">Comprueba si el valor del a&amp;ntilde;o almacenado en &lt;code&gt;*this&lt;/code&gt; est&amp;aacute; dentro del rango v&amp;aacute;lido, es decir, [-32767, 32767].</target>
        </trans-unit>
        <trans-unit id="464075ee2620831863a05ac3a062d2394191d131" translate="yes" xml:space="preserve">
          <source>Checks if this &lt;code&gt;year_month_day&lt;/code&gt; object represents a valid calendar date.</source>
          <target state="translated">Comprueba si este objeto &lt;code&gt;year_month_day&lt;/code&gt; representa una fecha de calendario v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="2f08fd0aa437da8d48e5c7e55ec6138f44d1d5e3" translate="yes" xml:space="preserve">
          <source>Checks if this &lt;code&gt;year_month_weekday&lt;/code&gt; object represents a valid date.</source>
          <target state="translated">Comprueba si este objeto &lt;code&gt;year_month_weekday&lt;/code&gt; representa una fecha v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="7012f03f45a478e758270c82fce18acc13dfab8e" translate="yes" xml:space="preserve">
          <source>Checks if this object represents a valid date. Since a &lt;code&gt;year_month_weekday_last&lt;/code&gt; represents the last weekday of a particular month, it is valid as long as the year, month and weekday are valid.</source>
          <target state="translated">Comprueba si este objeto representa una fecha v&amp;aacute;lida. Dado que &lt;code&gt;year_month_weekday_last&lt;/code&gt; representa el &amp;uacute;ltimo d&amp;iacute;a de la semana de un mes en particular, es v&amp;aacute;lido siempre que el a&amp;ntilde;o, el mes y el d&amp;iacute;a de la semana sean v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="587976447f530aa6d25584b121ecdd151dbddd88" translate="yes" xml:space="preserve">
          <source>Checks the given stream for errors.</source>
          <target state="translated">Comprueba si la corriente dada tiene errores.</target>
        </trans-unit>
        <trans-unit id="e063831806b4abf69aa95a8f1d0b948f8c9a0902" translate="yes" xml:space="preserve">
          <source>Checks the status of the sentry by calling &lt;code&gt;sentry::operator bool()&lt;/code&gt;, which is equivalent to &lt;a href=&quot;../io/basic_ios/good&quot;&gt;&lt;code&gt;basic_ios::good&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Comprueba el estado del centinela llamando a &lt;code&gt;sentry::operator bool()&lt;/code&gt; , que es equivalente a &lt;a href=&quot;../io/basic_ios/good&quot;&gt; &lt;code&gt;basic_ios::good&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="635ea4eba5accbfc249cd25209bcc3997533d8d6" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; contains a value.</source>
          <target state="translated">Comprueba si &lt;code&gt;*this&lt;/code&gt; contiene un valor.</target>
        </trans-unit>
        <trans-unit id="c38bd2aaae4ae9aad431571bc2897944efdb92f3" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; has a shared state.</source>
          <target state="translated">Comprueba si &lt;code&gt;*this&lt;/code&gt; tiene un estado compartido.</target>
        </trans-unit>
        <trans-unit id="71b816d1cfbb4f8588b6af2666d0efc8ea0c81d9" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; owns a locked mutex or not.</source>
          <target state="translated">Comprueba si &lt;code&gt;*this&lt;/code&gt; posee un mutex bloqueado o no.</target>
        </trans-unit>
        <trans-unit id="ed68d48f6a1e0644798c3fa0bfc8f385861ea72e" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; owns a locked mutex or not. Effectively calls &lt;code&gt;&lt;a href=&quot;owns_lock&quot;&gt;owns_lock()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;*this&lt;/code&gt; posee un mutex bloqueado o no. Efectivamente llama a &lt;code&gt;&lt;a href=&quot;owns_lock&quot;&gt;owns_lock()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f31ae0eaa08456edf17a19eb82949ee2db0b8878" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; owns an object, i.e. whether &lt;code&gt;get() != nullptr&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;*this&lt;/code&gt; posee un objeto, es decir, si &lt;code&gt;get() != nullptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ed8174a7598bc58814343000b3811be1096f8ba" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;*this&lt;/code&gt; stores a callable function target, i.e. is not empty.</source>
          <target state="translated">Comprueba si &lt;code&gt;*this&lt;/code&gt; almacena un objetivo de funci&amp;oacute;n invocable, es decir, no est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="7022e1e52a32f5446f404931d6fe2823c8c69dd3" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a &lt;a href=&quot;../language/pointer&quot;&gt;pointer to object&lt;/a&gt; or a pointer to function (but not a pointer to member/member function). Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a object/function pointer type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../language/pointer&quot;&gt;puntero al objeto&lt;/a&gt; o un puntero a la funci&amp;oacute;n (pero no un puntero al miembro / funci&amp;oacute;n miembro). Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de puntero de objeto / funci&amp;oacute;n. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8a0aab7ac34afa964604fd6771adf4104c3b8e7" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a floating-point type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;float&lt;/code&gt;, &lt;code&gt;double&lt;/code&gt;, &lt;code&gt;long double&lt;/code&gt;, including any cv-qualified variants. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo de punto flotante. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es el tipo &lt;code&gt;float&lt;/code&gt; , &lt;code&gt;double&lt;/code&gt; , &lt;code&gt;long double&lt;/code&gt; , incluidas las variantes calificadas por cv. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e59abc34df71bdf6c32c2c5ea33dd17229fe5b19" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a function type. Types like &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, lambdas, classes with overloaded &lt;code&gt;operator()&lt;/code&gt; and pointers to functions don't count as function types. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a function type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo de funci&amp;oacute;n. Tipos como &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , lambdas, clases con &lt;code&gt;operator()&lt;/code&gt; sobrecargado () y punteros a funciones no cuentan como tipos de funci&amp;oacute;n. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de funci&amp;oacute;n. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e28cb24a251f49a5aebb9fae5f5a3ec5667c582" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a lvalue reference type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a lvalue reference type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo de referencia lvalue. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de referencia lvalue. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b883e14dd2e029695b8fd5542cec26d4e9260ac" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a non-static member function pointer. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a non-static member function pointer type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un puntero de funci&amp;oacute;n miembro no est&amp;aacute;tico. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de puntero de funci&amp;oacute;n miembro no est&amp;aacute;tico. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9164f6a53718da4919f5f96385b37cf47562a131" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a non-static member object. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a non-static member object type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un objeto miembro no est&amp;aacute;tico. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de objeto miembro no est&amp;aacute;tico. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ecf7dc059b4ed93776d32d000af1b4107668e74" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a non-union class type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a class type (but not union). Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo de clase no sindical. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de clase (pero no uni&amp;oacute;n). De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bedc64ebaaa15f40dee6eca6d599bd4bb747d7b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a rvalue reference type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is a rvalue reference type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo de referencia rvalue. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de referencia rvalue. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a8715fd468c9164b80d434876b0f9a130176110" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a standard or implementation-defined execution policy type.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo de pol&amp;iacute;tica de ejecuci&amp;oacute;n est&amp;aacute;ndar o de implementaci&amp;oacute;n definida.</target>
        </trans-unit>
        <trans-unit id="dfe90d9b7dabaa2818a7d2a0d184dea435b97627" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a union type. Provides the member constant &lt;code&gt;value&lt;/code&gt;, which is equal to &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is a union type . Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo de uni&amp;oacute;n. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro , que es igual a &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es un tipo de uni&amp;oacute;n. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6df4126bdcc6310ebb0cdad5780493d77d0c187" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is a void type. Provides the member constant &lt;code&gt;value&lt;/code&gt; that is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;void&lt;/code&gt;, &lt;code&gt;const void&lt;/code&gt;, &lt;code&gt;volatile void&lt;/code&gt;, or &lt;code&gt;const volatile void&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo vac&amp;iacute;o. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es el tipo &lt;code&gt;void&lt;/code&gt; , &lt;code&gt;const void&lt;/code&gt; , &lt;code&gt;volatile void&lt;/code&gt; o &lt;code&gt;const volatile void&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2be34e132a60607ab5dd9c04136e75642192abbf" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/array#Arrays_of_unknown_bound&quot;&gt;array type of unknown bound&lt;/a&gt;. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an array type of unknown bound. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un &lt;a href=&quot;../language/array#Arrays_of_unknown_bound&quot;&gt;tipo de matriz de l&amp;iacute;mite desconocido&lt;/a&gt; . Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz de l&amp;iacute;mite desconocido. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1833b30272f19f6543d86fb787e9532baf6350d0" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an &lt;a href=&quot;../language/enum&quot;&gt;enumeration type&lt;/a&gt;. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an enumeration type . Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un&lt;a href=&quot;../language/enum&quot;&gt; tipo de enumeraci&amp;oacute;n&lt;/a&gt; . Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de enumeraci&amp;oacute;n. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="130f7441ba35a78873bfe867bf57a2fe54bb8190" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an array type of known bound. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an array type of known bound. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz de enlace conocido. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz de l&amp;iacute;mite conocido. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f1fcc5981b134a62c10ce0c25e9c946467ed28b" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an array type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is an array type. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d91afb5a075ac60e9677a8cc4754febe1adbc79" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is an integral type. Provides the member constant &lt;code&gt;value&lt;/code&gt; which is equal to &lt;code&gt;true&lt;/code&gt;, if &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;bool&lt;/code&gt;, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt;, &lt;code&gt;char32_t&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;long long&lt;/code&gt;, or any implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants. Otherwise, &lt;code&gt;value&lt;/code&gt; is equal to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es un tipo integral. Proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro que es igual a &lt;code&gt;true&lt;/code&gt; , si &lt;code&gt;T&lt;/code&gt; es del tipo &lt;code&gt;bool&lt;/code&gt; , &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; , &lt;code&gt;char32_t&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; , &lt;code&gt;short&lt;/code&gt; , &lt;code&gt;int&lt;/code&gt; , &lt;code&gt;long&lt;/code&gt; , &lt;code&gt;long long&lt;/code&gt; o cualquier tipo de entero extendido definido por la implementaci&amp;oacute;n, incluido cualquier firmado, variantes sin signo y calificadas para cv. De lo contrario, el &lt;code&gt;value&lt;/code&gt; es igual a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bffa9e6d94cce1dcc42a4c7c509890d27926c672" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;T&lt;/code&gt; is the type &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Comprueba si &lt;code&gt;T&lt;/code&gt; es del tipo &lt;code&gt;&lt;a href=&quot;nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f73a2b89f64c132a7a2db95ab8f3890b3255a62a" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;e&lt;/code&gt; is not equivalent to</source>
          <target state="translated">Comprueba si &lt;code&gt;e&lt;/code&gt; no es equivalente a</target>
        </trans-unit>
        <trans-unit id="a77ef24ff3015dfba3640ad0d13f58fcf1e32d5e" translate="yes" xml:space="preserve">
          <source>Checks whether &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">Comprueba si &lt;code&gt;lhs&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="f66fee9824887853dd82d29f509864b5623f6f69" translate="yes" xml:space="preserve">
          <source>Checks whether both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;it&lt;/code&gt; are valid, or both are invalid, regardless of the stream buffer objects they use.</source>
          <target state="translated">Comprueba si ambos &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;it&lt;/code&gt; son v&amp;aacute;lidos, o ambos no son v&amp;aacute;lidos, independientemente de los objetos de b&amp;uacute;fer de flujo que utilizan.</target>
        </trans-unit>
        <trans-unit id="b4244940d730169d64aee1da2da131b1ed135f26" translate="yes" xml:space="preserve">
          <source>Checks whether both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal. Two stream iterators are equal if both of them are end-of-stream iterators or both of them refer to the same stream.</source>
          <target state="translated">Comprueba si ambos &lt;code&gt;lhs&lt;/code&gt; como &lt;code&gt;rhs&lt;/code&gt; son iguales. Dos iteradores de flujo son iguales si ambos son iteradores de fin de flujo o si ambos se refieren al mismo flujo.</target>
        </trans-unit>
        <trans-unit id="87eaad996e60cbb3cfe0fcdde3be3c14e4f9c4d4" translate="yes" xml:space="preserve">
          <source>Checks whether both &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are valid, or both are invalid, regardless of the stream buffer objects they use.</source>
          <target state="translated">Comprueba si ambos &lt;code&gt;lhs&lt;/code&gt; como &lt;code&gt;rhs&lt;/code&gt; son v&amp;aacute;lidas o ambas no son v&amp;aacute;lidas, independientemente de los objetos de b&amp;uacute;fer de flujo que utilicen.</target>
        </trans-unit>
        <trans-unit id="229342a11042ce2ed84a995d5ff77f850ed69020" translate="yes" xml:space="preserve">
          <source>Checks whether error code is equivalent to an error condition for the error category represented by &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Comprueba si el c&amp;oacute;digo de error es equivalente a una condici&amp;oacute;n de error para la categor&amp;iacute;a de error representada por &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43194b114099424f38087d59c9ce8423ad80e636" translate="yes" xml:space="preserve">
          <source>Checks whether the atomic operations on all objects of this type are lock-free.</source>
          <target state="translated">Comprueba si las operaciones atómicas de todos los objetos de este tipo están libres de bloqueo.</target>
        </trans-unit>
        <trans-unit id="7846cd20df099e25c9a395f85406d0c13c14521b" translate="yes" xml:space="preserve">
          <source>Checks whether the atomic operations on this object are lock-free.</source>
          <target state="translated">Comprueba si las operaciones atómicas de este objeto están libres de bloqueo.</target>
        </trans-unit>
        <trans-unit id="c1704ab82dfc96f2bfbaf877fe0ee93b65d75c37" translate="yes" xml:space="preserve">
          <source>Checks whether the given path refers to an empty file or directory.</source>
          <target state="translated">Comprueba si la ruta dada se refiere a un archivo o directorio vacío.</target>
        </trans-unit>
        <trans-unit id="b5fe5582e4c95a42678f653d245fc0d8ca7e77c8" translate="yes" xml:space="preserve">
          <source>Checks whether the match was successful.</source>
          <target state="translated">Comprueba si el partido tuvo éxito.</target>
        </trans-unit>
        <trans-unit id="37b6b4e530b3a44ad4560ab7cb9ddc3bdf92e02b" translate="yes" xml:space="preserve">
          <source>Checks whether the object contains a value.</source>
          <target state="translated">Comprueba si el objeto contiene un valor.</target>
        </trans-unit>
        <trans-unit id="4dea1801ed41e688c9e6537be30704d3706b1021" translate="yes" xml:space="preserve">
          <source>Checks whether the path contains the corresponding path element.</source>
          <target state="translated">Comprueba si el camino contiene el elemento de camino correspondiente.</target>
        </trans-unit>
        <trans-unit id="f5ac19b39ecb671ac7a345baa1d1f56bbccd9a62" translate="yes" xml:space="preserve">
          <source>Checks whether the path is absolute or relative. An absolute path is a path that unambiguously identifies the location of a file without reference to an additional starting location. The first version returns &lt;code&gt;true&lt;/code&gt; if the path, in native format, is absolute, &lt;code&gt;false&lt;/code&gt; otherwise; the second version the other way round.</source>
          <target state="translated">Comprueba si la ruta es absoluta o relativa. Una ruta absoluta es una ruta que identifica inequ&amp;iacute;vocamente la ubicaci&amp;oacute;n de un archivo sin referencia a una ubicaci&amp;oacute;n de inicio adicional. La primera versi&amp;oacute;n regresa &lt;code&gt;true&lt;/code&gt; si la ruta, en formato nativo, es absoluta, de lo contrario es &lt;code&gt;false&lt;/code&gt; ; la segunda versi&amp;oacute;n al rev&amp;eacute;s.</target>
        </trans-unit>
        <trans-unit id="1c6d7504c98282a80ee4254b4ab667a6d5ecaf40" translate="yes" xml:space="preserve">
          <source>Checks whether the paths &lt;code&gt;p1&lt;/code&gt; and &lt;code&gt;p2&lt;/code&gt; resolve to the same file system entity.</source>
          <target state="translated">Comprueba si las rutas &lt;code&gt;p1&lt;/code&gt; y &lt;code&gt;p2&lt;/code&gt; se resuelven en la misma entidad del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="d03ecb587e7beec78ef27e7550fba2bb1b68ac55" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object exists. Effectively returns &lt;code&gt;std::filesystem::exists(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::exists(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">Comprueba si el objeto se&amp;ntilde;alado existe. Efectivamente devuelve &lt;code&gt;std::filesystem::exists(status())&lt;/code&gt; o &lt;code&gt;std::filesystem::exists(status(ec))&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="7ea5dd068aa953cd3a0e1bd7233cfb66ad43dfac" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a FIFO or pipe file. Effectively returns &lt;code&gt;std::filesystem::is_fifo(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_fifo(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">Comprueba si el objeto se&amp;ntilde;alado es un FIFO o un archivo de tuber&amp;iacute;a. Efectivamente devuelve &lt;code&gt;std::filesystem::is_fifo(status())&lt;/code&gt; o &lt;code&gt;std::filesystem::is_fifo(status(ec))&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="38196c9d5c220a32c0349e4637ac5aa258b11038" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a block device. Effectively returns &lt;code&gt;std::filesystem::is_block_file(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_block_file(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">Comprueba si el objeto se&amp;ntilde;alado es un dispositivo de bloque. Efectivamente devuelve &lt;code&gt;std::filesystem::is_block_file(status())&lt;/code&gt; o &lt;code&gt;std::filesystem::is_block_file(status(ec))&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="751e0118d57f62587cc9a3a0af0af434ad3c1600" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a character device. Effectively returns &lt;code&gt;std::filesystem::is_character_file(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_character_file(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">Comprueba si el objeto se&amp;ntilde;alado es un dispositivo de caracteres. Efectivamente devuelve &lt;code&gt;std::filesystem::is_character_file(status())&lt;/code&gt; o &lt;code&gt;std::filesystem::is_character_file(status(ec))&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="0540859f0b874033d66529a5545b918e9abbefb3" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a directory. Effectively returns &lt;code&gt;std::filesystem::is_directory(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_directory(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">Comprueba si el objeto se&amp;ntilde;alado es un directorio. Efectivamente devuelve &lt;code&gt;std::filesystem::is_directory(status())&lt;/code&gt; o &lt;code&gt;std::filesystem::is_directory(status(ec))&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="2308e9815e22ffba2f923b2d946ea52b4cda4576" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a named socket. Effectively returns &lt;code&gt;std::filesystem::is_socket(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_socket(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">Comprueba si el objeto se&amp;ntilde;alado es un socket con nombre. Efectivamente devuelve &lt;code&gt;std::filesystem::is_socket(status())&lt;/code&gt; o &lt;code&gt;std::filesystem::is_socket(status(ec))&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="b951526e00e6f97e074e12e389d2a9920ec6315e" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a regular file. Effectively returns &lt;code&gt;std::filesystem::is_regular_file(status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_regular_file(status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">Comprueba si el objeto se&amp;ntilde;alado es un archivo normal. Efectivamente devuelve &lt;code&gt;std::filesystem::is_regular_file(status())&lt;/code&gt; o &lt;code&gt;std::filesystem::is_regular_file(status(ec))&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="acf48ae97d4d120a878b0e576cd023878de18fa6" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is a symlink. Effectively returns &lt;code&gt;std::filesystem::is_symlink(symlink_status())&lt;/code&gt; or &lt;code&gt;std::filesystem::is_symlink(symlink_status(ec))&lt;/code&gt;, respectively.</source>
          <target state="translated">Comprueba si el objeto se&amp;ntilde;alado es un enlace simb&amp;oacute;lico. Efectivamente devuelve &lt;code&gt;std::filesystem::is_symlink(symlink_status())&lt;/code&gt; o &lt;code&gt;std::filesystem::is_symlink(symlink_status(ec))&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="279a1e6eab42861c169fe61939f083dce62d93e0" translate="yes" xml:space="preserve">
          <source>Checks whether the pointed-to object is an</source>
          <target state="translated">Comprueba si el objeto señalado es un</target>
        </trans-unit>
        <trans-unit id="8e8a0961bfa95374e31de6c178abd1091a03292e" translate="yes" xml:space="preserve">
          <source>Checks whether the preparation of the input stream was successful.</source>
          <target state="translated">Comprueba si la preparación del flujo de entrada fue exitosa.</target>
        </trans-unit>
        <trans-unit id="6813cbedc840219b2040df151acc0737b0c8c377" translate="yes" xml:space="preserve">
          <source>Checks whether the preparation of the output stream was successful.</source>
          <target state="translated">Comprueba si la preparación del flujo de salida tuvo éxito.</target>
        </trans-unit>
        <trans-unit id="34d57af6172a5843af278992c90022d6be885f65" translate="yes" xml:space="preserve">
          <source>Checks whether the stored error code is not zero.</source>
          <target state="translated">Comprueba si el código de error almacenado no es cero.</target>
        </trans-unit>
        <trans-unit id="a10aac416e423604412995d69f280cd38d6aa63f" translate="yes" xml:space="preserve">
          <source>Checks whether the stream has no errors.</source>
          <target state="translated">Comprueba si la corriente no tiene errores.</target>
        </trans-unit>
        <trans-unit id="7558d5daa29a73a6092a6bb0ffb197bd0adfe9f6" translate="yes" xml:space="preserve">
          <source>Checks whether this &lt;code&gt;shared_ptr&lt;/code&gt; precedes &lt;code&gt;other&lt;/code&gt; in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="translated">Comprueba si este &lt;code&gt;shared_ptr&lt;/code&gt; precede &lt;code&gt;other&lt;/code&gt; en la implementaci&amp;oacute;n definida en el orden basado en el propietario (en oposici&amp;oacute;n al valor). El orden es tal que dos punteros inteligentes comparan el equivalente solo si ambos est&amp;aacute;n vac&amp;iacute;os o si ambos poseen el mismo objeto, incluso si los valores de los punteros obtenidos por get () son diferentes (por ejemplo, porque apuntan a diferentes subobjetos dentro del mismo objeto).</target>
        </trans-unit>
        <trans-unit id="c75ecfbdc7f9038d0ac97b90b6953481e5484923" translate="yes" xml:space="preserve">
          <source>Checks whether this &lt;code&gt;weak_ptr&lt;/code&gt; precedes &lt;code&gt;other&lt;/code&gt; in implementation defined owner-based (as opposed to value-based) order. The order is such that two smart pointers compare equivalent only if they are both empty or if they both own the same object, even if the values of the pointers obtained by get() are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="translated">Comprueba si este &lt;code&gt;weak_ptr&lt;/code&gt; precede &lt;code&gt;other&lt;/code&gt; en el orden definido por la implementaci&amp;oacute;n basado en el propietario (en oposici&amp;oacute;n al valor). El orden es tal que dos punteros inteligentes comparan el equivalente solo si ambos est&amp;aacute;n vac&amp;iacute;os o si ambos poseen el mismo objeto, incluso si los valores de los punteros obtenidos por get () son diferentes (por ejemplo, porque apuntan a diferentes subobjetos dentro del mismo objeto).</target>
        </trans-unit>
        <trans-unit id="9e99c517d029e72bf940a22ccc78ab9409097406" translate="yes" xml:space="preserve">
          <source>Checks whether two values of type &lt;code&gt;int_type&lt;/code&gt; are equal.</source>
          <target state="translated">Comprueba si dos valores de tipo &lt;code&gt;int_type&lt;/code&gt; son iguales.</target>
        </trans-unit>
        <trans-unit id="34eb3f9df1785987205174d978835deeb45e94ad" translate="yes" xml:space="preserve">
          <source>Choose clang to observe the output shown.</source>
          <target state="translated">Elija el clang para observar la salida que se muestra.</target>
        </trans-unit>
        <trans-unit id="0dd1c8b596b65fa50cf7f5efdd880ad3089168ac" translate="yes" xml:space="preserve">
          <source>Clang++3.0 libc++</source>
          <target state="translated">Clang++3.0 libc++</target>
        </trans-unit>
        <trans-unit id="128f6dc5d7caa59dda6044d3e8e6c55352499ea0" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Clase &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="04c10a537c6bab1bf5c4017ce72824562df9ab4f" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../atomic/atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Clase &lt;code&gt;&lt;a href=&quot;../atomic/atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0d939a5c95da9331b931381710149919c5d9fa22" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../chrono/c/timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Class &lt;code&gt;&lt;a href=&quot;../chrono/c/timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a0fa1da504a8e1edfacf0be0377679a386d14664" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Clase &lt;code&gt;&lt;a href=&quot;../chrono/c/tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a55038579f31c03e4e93f4a6273203742021c97" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Clase &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="225da75ec2fdc972d380bbb0e74573b3ffe5aab4" translate="yes" xml:space="preserve">
          <source>Class &lt;code&gt;&lt;a href=&quot;../container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Clase &lt;code&gt;&lt;a href=&quot;../container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
