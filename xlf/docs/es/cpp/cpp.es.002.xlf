<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="a4e09b6b6e2a7b3a2ac2a06b04359abecdd52cc3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (3-6). The ordering relation must establish total order.</source>
          <target state="translated">- La &lt;code&gt;Key&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; para poder utilizar sobrecargas (3-6). La relaci&amp;oacute;n de pedido debe establecer el orden total.</target>
        </trans-unit>
        <trans-unit id="b9361c83e3b358d5a3956e330cbd7371301b7ad7" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt1, OutputIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt1, OutputIt2&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="698247f9c442eed3999e5a308ab1fc6756e36992" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; Debe cumplir los requisitos de &lt;a href=&quot;../../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="55c36864300a0332162362f1e29021f2ab4046bf" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; Debe cumplir los requisitos de &lt;a href=&quot;../../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="deed4a8e960de7cf907cc39e9c0acfd7ac778bf6" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; Debe cumplir los requisitos de &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e86ead3f4d883e644468b1c73f514708a02964c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;OutputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;. both &lt;code&gt;acc&lt;/code&gt; (the accumulated value) and the result of &lt;code&gt;val - acc&lt;/code&gt; or &lt;code&gt;op(val, acc)&lt;/code&gt;(until C++20)&lt;code&gt;val - std::move(acc)&lt;/code&gt; or &lt;code&gt;op(val, std::move(acc))&lt;/code&gt;(since C++20) must be writable to &lt;code&gt;OutputIt&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;OutputIt&lt;/code&gt; Debe cumplir los requisitos de &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; . tanto &lt;code&gt;acc&lt;/code&gt; (el valor acumulado) como el resultado de &lt;code&gt;val - acc&lt;/code&gt; u &lt;code&gt;op(val, acc)&lt;/code&gt; (hasta C ++ 20) &lt;code&gt;val - std::move(acc)&lt;/code&gt; u &lt;code&gt;op(val, std::move(acc))&lt;/code&gt; (desde C ++ 20) debe poder escribirse en &lt;code&gt;OutputIt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29da965fe354af11657ff5012d6cd7bb66771aa3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;PopulationIterator&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;PopulationIterator&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d962f474ba3dfaef590a955a0518ed4efa12212e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;PopulationIterator&lt;/code&gt;'s value type must be writeable to &lt;code&gt;out&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;PopulationIterator&lt;/code&gt; tipo de valor 's debe tener permiso de escritura a &lt;code&gt;out&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="71157d30139e1a4b4b81eda084b08fc43eb764e1" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d2f607ae40468ef5797894774fc38482f0178173" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="98251c9b55e7f4abf11f37378ad898be6c5fadbe" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/valueswappable&quot;&gt;ValueSwappable&lt;/a&gt; and &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;RandomIt&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/valueswappable&quot;&gt;ValueSwappable&lt;/a&gt; y &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="eaa2c05a56bacd05704242d3bd6df30c4b6e4975" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;SampleIterator&lt;/code&gt; must also meet the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; if &lt;code&gt;PopulationIterator&lt;/code&gt; doesn't meet &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">- &lt;code&gt;SampleIterator&lt;/code&gt; tambi&amp;eacute;n debe cumplir los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; si &lt;code&gt;PopulationIterator&lt;/code&gt; no cumple con &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d5cd603525645d89d81ecb0a97fa5b1104647059" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;SampleIterator&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;SampleIterator&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6c4c58a4b3733fe1a63015c88ad95da66afcddc7" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;Searcher&lt;/code&gt; must meet the requirements of &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;Searcher&lt;/a&gt;.</source>
          <target state="translated">- El &lt;code&gt;Searcher&lt;/code&gt; debe cumplir los requisitos del &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/named_req/Searcher&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;buscador&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="49b4b6f9f94d3a83ae0da6bac2f0d41b3f5ec92f" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;State&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt;, &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- El &lt;code&gt;State&lt;/code&gt; debe cumplir con los requisitos de &lt;a href=&quot;../named_req/destructible&quot;&gt;Destructible&lt;/a&gt; , &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; y &lt;a href=&quot;../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5a348b317d61568eab4c548d7c228a34e3f64305" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (if init is provided)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T (if init is provided)&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . Todos &lt;code&gt;binary_op(init, *first)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; y &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; deben ser convertibles a T</target>
        </trans-unit>
        <trans-unit id="c2a5020c510f0262502557c93ed89e0865951c7c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (if init is provided)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T (if init is provided)&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . Todos &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; y &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; deben ser convertibles a T</target>
        </trans-unit>
        <trans-unit id="7810d2997b36f05550f6cb1bf31a4fa633ff590f" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="905e21cacfad5c81bbffce9900de32849620bb35" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; y &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5106e515e150117a5ed081858723525bce75264" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T (the container's element type)&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T (the container's element type)&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; y &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="084180c1730ee9ff3511af3a7074aed52956ecd0" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T, Key&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- &lt;code&gt;T, Key&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; para poder utilizar sobrecargas (1-2).</target>
        </trans-unit>
        <trans-unit id="fa70cdcafe4b0432bf8e4d5ec413cbc51a7d1ce1" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T2&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff7f4cc18db9ac03597b82461300318cff643a4e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be a complete object type for overload (2)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe ser un tipo de objeto completo para sobrecarga (2)</target>
        </trans-unit>
        <trans-unit id="22d8a29c2d428307356a96301dfe48b10dd001df" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be an arithmetic type other than &lt;code&gt;bool&lt;/code&gt; for overload (1)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe ser un tipo aritm&amp;eacute;tico distinto de &lt;code&gt;bool&lt;/code&gt; para sobrecarga (1)</target>
        </trans-unit>
        <trans-unit id="d4b7bba184604960afabdacbe04cef7c29efc646" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be constructible from &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Args...&lt;/code&gt; for overload (2)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe ser construible desde &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Args...&lt;/code&gt; para sobrecarga (2)</target>
        </trans-unit>
        <trans-unit id="14bba7cc3b7a63c191dec2116f925714b85fb80e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must be constructible from &lt;code&gt;Args...&lt;/code&gt; for overload (1)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe ser construible a partir de &lt;code&gt;Args...&lt;/code&gt; para sobrecarga (1)</target>
        </trans-unit>
        <trans-unit id="cffb5df90bd109b7434a393187dfa1b30b748828" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; y &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; para poder utilizar la sobrecarga (1).</target>
        </trans-unit>
        <trans-unit id="7930781c7243e63a8390ec04eb0aa2c04af85f82" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (3).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; y &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; para poder utilizar la sobrecarga (3).</target>
        </trans-unit>
        <trans-unit id="471088387fa31e08d2a02da4c72d9a7a716ef167" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; para poder utilizar la sobrecarga (1).</target>
        </trans-unit>
        <trans-unit id="73f5abb3110caba0a3cbfda038bb47a33bd701aa" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; para poder utilizar la sobrecarga (1).</target>
        </trans-unit>
        <trans-unit id="e73f59dbfdbaf5c4dcce09ce496037063fb9358b" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; para utilizar la sobrecarga (2).</target>
        </trans-unit>
        <trans-unit id="eb108a09e5c7c38be67b06f6c9bffab1dded20be" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; para poder utilizar la sobrecarga (1).</target>
        </trans-unit>
        <trans-unit id="81a64d3f2c5aed9f2ea58d39ee0dc7d25692b198" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; in order to use overload (4,5).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; para poder utilizar la sobrecarga (4,5).</target>
        </trans-unit>
        <trans-unit id="f777ee2027b95d030923b905f9b74c5248eea4b9" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; in order to use overloads (1-2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; para utilizar sobrecargas (1-2).</target>
        </trans-unit>
        <trans-unit id="96a89708385e36960066ed1cb1ad4a6270b18f9e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f655a15216004caebe0d4c1842ff1c7c85e72dc8" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (3-6). The ordering relation must establish total order.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; para utilizar sobrecargas (3-6). La relaci&amp;oacute;n de pedido debe establecer el orden total.</target>
        </trans-unit>
        <trans-unit id="8bc0ec3645431f4a729c83f7d0b332dedc67a6c2" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; y &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; para poder utilizar la sobrecarga (2).</target>
        </trans-unit>
        <trans-unit id="83b8abfb3b109f24460367855ff84231d42acd86" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (4). required only if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; but not &lt;a href=&quot;../../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;. (until C++17)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; y &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; para poder utilizar la sobrecarga (4). se requiere solo si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; pero no &lt;a href=&quot;../../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; . (hasta C ++ 17)</target>
        </trans-unit>
        <trans-unit id="46f5218ad771272834f2938c2efb000b08e092d8" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a30288177c8d2ae9070305e88321759803254602" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; para poder utilizar la sobrecarga (2).</target>
        </trans-unit>
        <trans-unit id="df2dc067304b7bdd11cb64bd744da7390dc15e7c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; and &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; in order to use overload (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; y &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; para poder utilizar la sobrecarga (1).</target>
        </trans-unit>
        <trans-unit id="c75ea7942181849fe154d4fe56f7d5a7e8e077b3" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (2).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; para utilizar la sobrecarga (2).</target>
        </trans-unit>
        <trans-unit id="dd12a83a8a21dd2faf8db14c717a62119dacb3df" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="955e988bcc8c424fa42f194f883da98cda7a48a2" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; in order to use overload (4,5). (since C++17)</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/swappable&quot;&gt;Swappable&lt;/a&gt; , &lt;a href=&quot;../../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; y &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; para poder utilizar la sobrecarga (4,5). (desde C ++ 17)</target>
        </trans-unit>
        <trans-unit id="afbeaf062ea6fd0595970eeb503e2e6f5c5e7744" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir con los requisitos de &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; y &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ab460245f5ca1cfa08f3d1ec2722e5c78976ffcb" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; in order to use overloads (3,4).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; para utilizar sobrecargas (3,4).</target>
        </trans-unit>
        <trans-unit id="7b670662fdaf16909ed9b4448468795dec02b564" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (1).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; para poder utilizar sobrecargas (1).</target>
        </trans-unit>
        <trans-unit id="a320cda4651b152682eb79c8e8e99ea2769e8c5e" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; in order to use overloads (1,3).</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; para utilizar sobrecargas (1,3).</target>
        </trans-unit>
        <trans-unit id="48fe196760fc1f1946ea79d3075055f7b6aeaabd" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; y &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="32c23e4f427e0609ed933c05aa132bcda1ee2718" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overloads (2,5). and the result of the expressions &lt;code&gt;binary_op1(init, binary_op2(*first1, *first2))&lt;/code&gt;, &lt;code&gt;binary_op1(binary_op2(*first1, *first2), init)&lt;/code&gt;, &lt;code&gt;binary_op1(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; para utilizar sobrecargas (2,5). y el resultado de las expresiones &lt;code&gt;binary_op1(init, binary_op2(*first1, *first2))&lt;/code&gt; , &lt;code&gt;binary_op1(binary_op2(*first1, *first2), init)&lt;/code&gt; , &lt;code&gt;binary_op1(init, init)&lt;/code&gt; y &lt;code&gt;binary_op1(binary_op2(*first1, *first2), binary_op2(*first1, *first2))&lt;/code&gt; debe ser convertible a T</target>
        </trans-unit>
        <trans-unit id="b61c2e4c2acdbcf060f22b54d7687f0c61f22811" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; in order to use overloads (3,6). and the result of the expressions &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(unary_op(*first), init)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to T</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; para utilizar sobrecargas (3,6). y el resultado de las expresiones &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; , &lt;code&gt;binary_op(unary_op(*first), init)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; y &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; debe ser convertible a T</target>
        </trans-unit>
        <trans-unit id="735f48ddde8598786438eb6c8a0e27a9a20e41fa" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. All of &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . Todas &lt;code&gt;binary_op(init, unary_op(*first))&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; , y &lt;code&gt;binary_op(unary_op(*first), unary_op(*first))&lt;/code&gt; debe ser convertible en &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4830e7790cb0a3a97c614ec99dee4fd4f76bde82" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. Also, it must be possible to move-assign objects of type &lt;code&gt;U&lt;/code&gt; to objects of type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . Adem&amp;aacute;s, debe ser posible mover-asignar objetos de tipo &lt;code&gt;U&lt;/code&gt; a objetos de tipo &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="070995c3e11380f1a759c287d70004246a336f84" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. and &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(*first, init)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . y &lt;code&gt;binary_op(init, *first)&lt;/code&gt; , &lt;code&gt;binary_op(*first, init)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; , y &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; deben ser convertible a &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ebbe51e0d271ce6d4ccbb7dd18d09cb13e0244" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;T&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. and &lt;code&gt;binary_op(init, *first)&lt;/code&gt;, &lt;code&gt;binary_op(init, init)&lt;/code&gt;, and &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;T&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . y &lt;code&gt;binary_op(init, *first)&lt;/code&gt; , &lt;code&gt;binary_op(init, init)&lt;/code&gt; y &lt;code&gt;binary_op(*first, *first)&lt;/code&gt; deben ser convertibles a &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="240b36ac63aedc5650c0eebdca5e66141ce3bde5" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;U&amp;amp;&amp;amp;&lt;/code&gt; must be convertible to &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">- &lt;code&gt;U&amp;amp;&amp;amp;&lt;/code&gt; debe ser convertible a &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b81d5e3c63c353df7206ad9ffec731b9d09453db" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryFunction2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;UnaryFunction2&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6014d7e4016480f38e962647d7142d9618786712" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryFunction&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;. Does not have to be &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</source>
          <target state="translated">- &lt;code&gt;UnaryFunction&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; . No tiene que ser &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ec2173dc69a67195292305ee0f463384bf04a493" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;UnaryPredicate&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/predicate&quot;&gt;Predicate&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;UnaryPredicate&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../named_req/predicate&quot;&gt;Predicate&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="29292267e10038a5997139362f189f03885b9b0c" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;W&lt;/code&gt; must be greater than zero, and no greater than &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;UIntType&amp;gt;::digits&lt;/code&gt;.</source>
          <target state="translated">- &lt;code&gt;W&lt;/code&gt; debe ser mayor que cero y no mayor que &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;UIntType&amp;gt;::digits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f89b6a8131c4a3381b15946e9051f71792126a60" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;key_type&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;key_type&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="129d57481bdef249acefaffbce24cd66b9f3b73a" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;mapped_type&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;mapped_type&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; y &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="debd7c798d0035e7d613bf22525a497feb4eac68" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;std::decay_t&amp;lt;ValueType&amp;gt;&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;std::decay_t&amp;lt;ValueType&amp;gt;&lt;/code&gt; debe cumplir los requisitos de &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d5acc57403e947250368f57577287097a8c8cc4" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;std::is_constructible_v&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;, F&amp;gt;&lt;/code&gt; is required to be true</source>
          <target state="translated">- &lt;code&gt;std::is_constructible_v&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;, F&amp;gt;&lt;/code&gt; debe ser verdadero</target>
        </trans-unit>
        <trans-unit id="3a79a46e3b7ff92c381844fb9a39002a4b0fa232" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;value_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt;. When the default allocator is used, this means that &lt;code&gt;key_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;code&gt;mapped_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;value_type&lt;/code&gt; debe ser &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; desde &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; . Cuando se utiliza el asignador predeterminado, esto significa que &lt;code&gt;key_type&lt;/code&gt; debe ser &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; y &lt;code&gt;mapped_type&lt;/code&gt; debe ser &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d97831a170788f8d67b47b8d93ff132ec0bb8c06" translate="yes" xml:space="preserve">
          <source>-&lt;code&gt;value_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt;. When the default allocator is used, this means that &lt;code&gt;key_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; and &lt;code&gt;mapped_type&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;.</source>
          <target state="translated">- &lt;code&gt;value_type&lt;/code&gt; debe ser &lt;a href=&quot;../../named_req/emplaceconstructible&quot;&gt;EmplaceConstructible&lt;/a&gt; desde &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(std::move(key)), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; . Cuando se utiliza el asignador predeterminado, esto significa que &lt;code&gt;key_type&lt;/code&gt; debe ser &lt;a href=&quot;../../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; y &lt;code&gt;mapped_type&lt;/code&gt; debe ser &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ff8015eb2b1855f53bb4336bf8d4411ac6c84c5b" translate="yes" xml:space="preserve">
          <source>-E</source>
          <target state="translated">-E</target>
        </trans-unit>
        <trans-unit id="47c47adf6da44571449c368a24b1dbbce9c4896b" translate="yes" xml:space="preserve">
          <source>-No increment, assignment, comparison, or indirection through valid instances of &lt;code&gt;ForwardIt&lt;/code&gt; may throw exceptions.</source>
          <target state="translated">-No hay incremento, asignaci&amp;oacute;n, comparaci&amp;oacute;n o indirecci&amp;oacute;n a trav&amp;eacute;s de instancias v&amp;aacute;lidas de &lt;code&gt;ForwardIt&lt;/code&gt; Puede arrojar excepciones.</target>
        </trans-unit>
        <trans-unit id="eb831d16a34da446211de736f7a976a6da2d183b" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;BidirIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">-El tipo de &lt;code&gt;BidirIt&lt;/code&gt; desreferenciado debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; y &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fea212bdfb63511131a24166d6cf8c37f24a9977" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;ForwardIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">-El tipo de &lt;code&gt;ForwardIt&lt;/code&gt; desreferenciado debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; y &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9070dc7500842363fa2c05017f765046615dbb95" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;ForwardIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;.</source>
          <target state="translated">-El tipo de &lt;code&gt;ForwardIt&lt;/code&gt; desreferenciado debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e6111d8d5184d2a92b766306033c8f746e15ff45" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">-El tipo de sin referencia &lt;code&gt;InputIt&lt;/code&gt; debe cumplir con los requisitos de &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5377d372d149a9da9efea14ca7295541e3b278" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;. if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">-El tipo de sin referencia &lt;code&gt;InputIt&lt;/code&gt; debe cumplir con los requisitos de &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; . si &lt;code&gt;InputIt&lt;/code&gt; no satisface &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="35d8052956297290de757a81ca77db43e329f302" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;InputIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;. if neither &lt;code&gt;InputIt&lt;/code&gt; nor &lt;code&gt;OutputIt&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, or if &lt;code&gt;InputIt&lt;/code&gt; does not satisfy &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; and the value type of &lt;code&gt;InputIt&lt;/code&gt; differs from that of &lt;code&gt;OutputIt&lt;/code&gt;</source>
          <target state="translated">-El tipo de sin referencia &lt;code&gt;InputIt&lt;/code&gt; debe cumplir con los requisitos de &lt;a href=&quot;../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; . si ni &lt;code&gt;InputIt&lt;/code&gt; ni &lt;code&gt;OutputIt&lt;/code&gt; satisfacen &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , o si &lt;code&gt;InputIt&lt;/code&gt; no satisface &lt;a href=&quot;../named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; y el tipo de valor de &lt;code&gt;InputIt&lt;/code&gt; difiere del de &lt;code&gt;OutputIt&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1033b058712ba4bd32d56b528177040435614bb2" translate="yes" xml:space="preserve">
          <source>-The type of dereferenced &lt;code&gt;RandomIt&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; and &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;.</source>
          <target state="translated">-El tipo de &lt;code&gt;RandomIt&lt;/code&gt; desreferenciado debe cumplir los requisitos de &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; y &lt;a href=&quot;../named_req/moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="961a73e39e89cb3f2795f5bbf3cbdb9625270fdd" translate="yes" xml:space="preserve">
          <source>-The types of dereferenced &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; must meet the requirements of &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;</source>
          <target state="translated">-Los tipos de &lt;code&gt;ForwardIt1&lt;/code&gt; y &lt;code&gt;ForwardIt2&lt;/code&gt; desreferenciados deben cumplir los requisitos de &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ee0fc4c6e8c36c2cdf1bf0caedd9cb01843102d7" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be &lt;code&gt;char&lt;/code&gt;</source>
          <target state="translated">-El tipo de valor de &lt;code&gt;InputIt&lt;/code&gt; debe ser &lt;code&gt;char&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="943fa25d062c8405568c4ff3a57ad45d9288723a" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be &lt;code&gt;char&lt;/code&gt; to use the overload (7))</source>
          <target state="translated">-El tipo de valor de &lt;code&gt;InputIt&lt;/code&gt; debe ser &lt;code&gt;char&lt;/code&gt; para usar la sobrecarga (7))</target>
        </trans-unit>
        <trans-unit id="386d13b86abcf4b9bca6e76ef852ed6b2ad732cb" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be one of the character types &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char8_t&lt;/code&gt;, (since C++20)&lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt; to use the overload (5))</source>
          <target state="translated">-El tipo de valor de &lt;code&gt;InputIt&lt;/code&gt; debe ser uno de los tipos de caracteres &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; , &lt;code&gt;char8_t&lt;/code&gt; , (desde C ++ 20) &lt;code&gt;char16_t&lt;/code&gt; y &lt;code&gt;char32_t&lt;/code&gt; para usar la sobrecarga (5))</target>
        </trans-unit>
        <trans-unit id="85af98cd8f2584c8a1bf3193d2a9453c4a0696b3" translate="yes" xml:space="preserve">
          <source>-The value type of &lt;code&gt;InputIt&lt;/code&gt; must be one of the encoded character types (&lt;code&gt;char&lt;/code&gt;, &lt;code&gt;wchar_t&lt;/code&gt;, &lt;code&gt;char16_t&lt;/code&gt; and &lt;code&gt;char32_t&lt;/code&gt;)</source>
          <target state="translated">-El tipo de valor de &lt;code&gt;InputIt&lt;/code&gt; debe ser uno de los tipos de caracteres codificados ( &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;wchar_t&lt;/code&gt; , &lt;code&gt;char16_t&lt;/code&gt; y &lt;code&gt;char32_t&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="781c92c6f4232004d3a5ca088f526ac147d9db22" translate="yes" xml:space="preserve">
          <source>-a, where &lt;code&gt;b&lt;/code&gt; is the number of bits after promotion.</source>
          <target state="translated">-a, donde &lt;code&gt;b&lt;/code&gt; es el n&amp;uacute;mero de bits despu&amp;eacute;s de la promoci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8a9cd7781044a79a622806d2c71e18d259189aab" translate="yes" xml:space="preserve">
          <source>-arg</source>
          <target state="translated">-arg</target>
        </trans-unit>
        <trans-unit id="16372868051b38c9793bfcfb1bab9865824a7cf8" translate="yes" xml:space="preserve">
          <source>-e-arg</source>
          <target state="translated">-e-arg</target>
        </trans-unit>
        <trans-unit id="36105b9bc31e91d70aff56af9dcd73894e1e5181" translate="yes" xml:space="preserve">
          <source>-e-iz</source>
          <target state="translated">-e-iz</target>
        </trans-unit>
        <trans-unit id="c6ea641826a7102b4cb61da3fbe5c8784257cca9" translate="yes" xml:space="preserve">
          <source>-e-z</source>
          <target state="translated">-e-z</target>
        </trans-unit>
        <trans-unit id="af8605005221d6158480c209167abfb0fad20613" translate="yes" xml:space="preserve">
          <source>-eiz</source>
          <target state="translated">-eiz</target>
        </trans-unit>
        <trans-unit id="6d358556e5f27dfee6bf6eb686c8965aebf7a90e" translate="yes" xml:space="preserve">
          <source>-th</source>
          <target state="translated">-th</target>
        </trans-unit>
        <trans-unit id="3a52ce780950d4d969792a2559cd519d7ee8c727" translate="yes" xml:space="preserve">
          <source>.</source>
          <target state="translated">.</target>
        </trans-unit>
        <trans-unit id="9ab9cbe186911e3306c2471a07f4d73488a998c2" translate="yes" xml:space="preserve">
          <source>. (the value of M, determined by B, will be the value stored by one of these side effects).</source>
          <target state="translated">. (el valor de M, determinado por B, ser&amp;aacute; el valor almacenado por uno de estos efectos secundarios).</target>
        </trans-unit>
        <trans-unit id="4c867670cfdf2b3d78e9b9332a77e4cae54f2ca7" translate="yes" xml:space="preserve">
          <source>. &lt;code&gt;*this&lt;/code&gt; is</source>
          <target state="translated">. &lt;code&gt;*this&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="858e49b217359edfde089556fcb3a0afd53dff9d" translate="yes" xml:space="preserve">
          <source>. A program that has two conflicting evaluations has a</source>
          <target state="translated">. Un programa que tiene dos evaluaciones en conflicto tiene un</target>
        </trans-unit>
        <trans-unit id="40cdcbb4fcaaf112141529b2f4aa097584351c61" translate="yes" xml:space="preserve">
          <source>. Always stores a null character in addition to the characters matched (so the argument array must have room for at least</source>
          <target state="translated">. Siempre almacena un car&amp;aacute;cter nulo adem&amp;aacute;s de los caracteres coincidentes (por lo que la matriz de argumentos debe tener espacio para al menos</target>
        </trans-unit>
        <trans-unit id="6c8c268081021c567c19d1d620072b0fc7e50c0e" translate="yes" xml:space="preserve">
          <source>. Any use of a deleted function is ill-formed (the program will not compile). This includes calls, both explicit (with a function call operator) and implicit (a call to deleted overloaded operator, special member function, allocation function etc), constructing a pointer or pointer-to-member to a deleted function, and even the use of a deleted function in an unevaluated expression. However, implicit &lt;a href=&quot;definition#ODR-use&quot;&gt;ODR-use&lt;/a&gt; of a non-pure virtual member function that happens to be deleted is allowed.</source>
          <target state="translated">. Cualquier uso de una funci&amp;oacute;n eliminada est&amp;aacute; mal formado (el programa no se compilar&amp;aacute;). Esto incluye llamadas, tanto expl&amp;iacute;citas (con un operador de llamada de funci&amp;oacute;n) como impl&amp;iacute;citas (una llamada al operador sobrecargado eliminado, funci&amp;oacute;n de miembro especial, funci&amp;oacute;n de asignaci&amp;oacute;n, etc.), construir un puntero o puntero a miembro para una funci&amp;oacute;n eliminada, e incluso el uso de una funci&amp;oacute;n eliminada en una expresi&amp;oacute;n no evaluada. Sin embargo, se &lt;a href=&quot;definition#ODR-use&quot;&gt;permite el uso&lt;/a&gt; impl&amp;iacute;cito de ODR de una funci&amp;oacute;n miembro virtual no pura que se elimina.</target>
        </trans-unit>
        <trans-unit id="a1b0da760b32f18ba3fc29ea2034487403e7abfa" translate="yes" xml:space="preserve">
          <source>. Each byte in memory has a unique</source>
          <target state="translated">. Cada byte en la memoria tiene un &amp;uacute;nico</target>
        </trans-unit>
        <trans-unit id="5cddd5dfbecb9801772fe2221afa601ead96b52d" translate="yes" xml:space="preserve">
          <source>. Each concept is a predicate, evaluated at compile time, and becomes a part of the interface of a template where it is used as a constraint:</source>
          <target state="translated">. Cada concepto es un predicado, evaluado en tiempo de compilaci&amp;oacute;n, y se convierte en una parte de la interfaz de una plantilla donde se usa como restricci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="33dec4f9c20f32729da42cd862630e951a31724b" translate="yes" xml:space="preserve">
          <source>. Each expression has some non-reference type, and each expression belongs to exactly one of the three primary value categories:</source>
          <target state="translated">. Cada expresi&amp;oacute;n tiene alg&amp;uacute;n tipo de no referencia, y cada expresi&amp;oacute;n pertenece exactamente a una de las tres categor&amp;iacute;as de valores principales:</target>
        </trans-unit>
        <trans-unit id="b705286f65efb9ff5d067129a4b52aa7b3a64f86" translate="yes" xml:space="preserve">
          <source>. Evaluation of the predicate must not have any side effects other than modification of non-volatile objects whose lifetimes begin and end within that evaluation; otherwise the behavior is undefined. If the evaluation of a predicate exits via an exception, &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">. La evaluaci&amp;oacute;n del predicado no debe tener ning&amp;uacute;n efecto secundario que no sea la modificaci&amp;oacute;n de objetos no vol&amp;aacute;tiles cuyas vidas comienzan y terminan dentro de esa evaluaci&amp;oacute;n; de lo contrario, el comportamiento es indefinido. Si la evaluaci&amp;oacute;n de un predicado sale a trav&amp;eacute;s de una excepci&amp;oacute;n, se llama a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdbadb9492e1aaa923f351b943afd53e801082db" translate="yes" xml:space="preserve">
          <source>. For example, &lt;code&gt;&quot;ch&quot;&lt;/code&gt; in Czech follows &lt;code&gt;&quot;h&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;i&quot;&lt;/code&gt;, and &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; in Hungarian follows &lt;code&gt;&quot;dz&quot;&lt;/code&gt; and precedes &lt;code&gt;&quot;g&quot;&lt;/code&gt;.</source>
          <target state="translated">. Por ejemplo, &lt;code&gt;&quot;ch&quot;&lt;/code&gt; en checo sigue a &lt;code&gt;&quot;h&quot;&lt;/code&gt; y precede a &lt;code&gt;&quot;i&quot;&lt;/code&gt; , y &lt;code&gt;&quot;dzs&quot;&lt;/code&gt; en h&amp;uacute;ngaro sigue a &lt;code&gt;&quot;dz&quot;&lt;/code&gt; y precede a &lt;code&gt;&quot;g&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d82d917e197ae463a094b584241f35f782aec1e5" translate="yes" xml:space="preserve">
          <source>. Four data models found wide acceptance:</source>
          <target state="translated">. Cuatro modelos de datos encontraron amplia aceptaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a33d10a95384cd1ea7eb9f897911c689939d7a04" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; the first substring is &lt;code&gt;[pos1, size())&lt;/code&gt;. Likewise, &lt;code&gt;count2 &amp;gt; str.size() - pos2&lt;/code&gt; the second substring is &lt;code&gt;[pos2, str.size())&lt;/code&gt;.</source>
          <target state="translated">. Si &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; la primera subcadena es &lt;code&gt;[pos1, size())&lt;/code&gt; . Del mismo modo, &lt;code&gt;count2 &amp;gt; str.size() - pos2&lt;/code&gt; la segunda subcadena es &lt;code&gt;[pos2, str.size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60d4561c4e6d1d28e7602ab1f96bac585b6ca3dc" translate="yes" xml:space="preserve">
          <source>. If &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; the substring is &lt;code&gt;[pos1, size())&lt;/code&gt;.</source>
          <target state="translated">. Si &lt;code&gt;count1 &amp;gt; size() - pos1&lt;/code&gt; la subcadena es &lt;code&gt;[pos1, size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b84f7bfde392ca0b0a0eb7c2fd807319d5660eee" translate="yes" xml:space="preserve">
          <source>. If a name has linkage, it refers to the same entity as the same name introduced by a declaration in another scope. If a variable, function, or another entity with the same name is declared in several scopes, but does not have sufficient linkage, then several instances of the entity are generated.</source>
          <target state="translated">. Si un nombre tiene vinculaci&amp;oacute;n, se refiere a la misma entidad que el mismo nombre introducido por una declaraci&amp;oacute;n en otro &amp;aacute;mbito. Si una variable, funci&amp;oacute;n u otra entidad con el mismo nombre se declara en varios &amp;aacute;mbitos, pero no tiene una vinculaci&amp;oacute;n suficiente, se generan varias instancias de la entidad.</target>
        </trans-unit>
        <trans-unit id="68e5fa4e1855031b0502b2881746502d1ee32b93" translate="yes" xml:space="preserve">
          <source>. If an expression of class type is used where an integral constant expression is expected, the expression is &lt;a href=&quot;implicit_cast&quot;&gt;contextually implicitly converted&lt;/a&gt; to an integral or unscoped enumeration type.</source>
          <target state="translated">. Si se usa una expresi&amp;oacute;n de tipo de clase donde se espera una expresi&amp;oacute;n constante integral, la expresi&amp;oacute;n se &lt;a href=&quot;implicit_cast&quot;&gt;convierte contextualmente impl&amp;iacute;citamente&lt;/a&gt; en un tipo de enumeraci&amp;oacute;n integral o sin &amp;aacute;mbito.</target>
        </trans-unit>
        <trans-unit id="bf4f7b247734c7ffb151a9d2d9c1116744a29510" translate="yes" xml:space="preserve">
          <source>. If it is missing (and the first element other than the root name is a file name), then the path is</source>
          <target state="translated">. Si falta (y el primer elemento que no sea el nombre ra&amp;iacute;z es un nombre de archivo), entonces la ruta es</target>
        </trans-unit>
        <trans-unit id="3cdae61a821a7400c029c87da2e0ad8e4d9f82b6" translate="yes" xml:space="preserve">
          <source>. If new_type is (possibly &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;) &lt;code&gt;void&lt;/code&gt;, the expression is a void prvalue without a result object(since C++17).. This is the only cast expression that can create an &lt;a href=&quot;array#Array_rvalues&quot;&gt;array prvalue&lt;/a&gt;.</source>
          <target state="translated">. Si new_type es (posiblemente &lt;a href=&quot;cv&quot;&gt;calificado por cv&lt;/a&gt; ) &lt;code&gt;void&lt;/code&gt; , la expresi&amp;oacute;n es un valor vac&amp;iacute;o sin un objeto de resultado (desde C ++ 17). Esta es la &amp;uacute;nica expresi&amp;oacute;n de &lt;a href=&quot;array#Array_rvalues&quot;&gt;conversi&amp;oacute;n&lt;/a&gt; que puede crear un valor de matriz .</target>
        </trans-unit>
        <trans-unit id="77e403132e08047bd2d3bc12dda0f4a4a2d76de8" translate="yes" xml:space="preserve">
          <source>. If the character specified by a universal character name isn't a member of the execution character set, the result is implementation-defined, but is guaranteed not to be a null (wide) character.</source>
          <target state="translated">. Si el car&amp;aacute;cter especificado por un nombre de car&amp;aacute;cter universal no es miembro del conjunto de caracteres de ejecuci&amp;oacute;n, el resultado est&amp;aacute; definido por la implementaci&amp;oacute;n, pero se garantiza que no ser&amp;aacute; un car&amp;aacute;cter nulo (ancho).</target>
        </trans-unit>
        <trans-unit id="2055582e493f90d8029965151d08ca03337c25b6" translate="yes" xml:space="preserve">
          <source>. In other words, class members in each of the three member access modes are positioned in memory in order of declaration.</source>
          <target state="translated">. En otras palabras, los miembros de la clase en cada uno de los tres modos de acceso de miembros se colocan en la memoria en orden de declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a005fba78ddbc77b4129b39813eedeab22a6e135" translate="yes" xml:space="preserve">
          <source>. In other words, they results of comparing the pointers is the same as the result of comparing the indexes of the elements they point to.</source>
          <target state="translated">. En otras palabras, el resultado de comparar los punteros es el mismo que el resultado de comparar los &amp;iacute;ndices de los elementos a los que apuntan.</target>
        </trans-unit>
        <trans-unit id="99a683fd566c429de6986c8efcc6c2533955f501" translate="yes" xml:space="preserve">
          <source>. In particular, OS-dependent end-of-line indicators are replaced by newline characters. The</source>
          <target state="translated">. En particular, los indicadores de fin de l&amp;iacute;nea dependientes del sistema operativo se reemplazan por caracteres de nueva l&amp;iacute;nea. los</target>
        </trans-unit>
        <trans-unit id="2971dbfe9f7c9e49e1f8b10e03b7c5f6dac51f41" translate="yes" xml:space="preserve">
          <source>. Invoking the</source>
          <target state="translated">. Invocando el</target>
        </trans-unit>
        <trans-unit id="c1128618249b42b2681dcf948859823c7068abc2" translate="yes" xml:space="preserve">
          <source>. It is a form of &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt;(since C++11) or &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt;(since C++20).</source>
          <target state="translated">. Es una forma de &lt;a href=&quot;list_initialization&quot;&gt;inicializaci&amp;oacute;n&lt;/a&gt; de lista (desde C ++ 11) o &lt;a href=&quot;direct_initialization&quot;&gt;inicializaci&amp;oacute;n directa&lt;/a&gt; (desde C ++ 20).</target>
        </trans-unit>
        <trans-unit id="356bc0604f7850722bb7374a264e1089f903613e" translate="yes" xml:space="preserve">
          <source>. It is implementation-defined if &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../memory/allocator/allocate&quot;&gt;std::allocator::allocate&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../memory/get_temporary_buffer&quot;&gt;std::get_temporary_buffer&lt;/a&gt;&lt;/code&gt; support over-aligned types. &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocators&lt;/a&gt; instantiated with over-aligned types are allowed to fail to instantiate at compile time, to throw &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; at runtime, to silently ignore unsupported alignment requirement, or to handle them correctly.</source>
          <target state="translated">. Est&amp;aacute; definido por la implementaci&amp;oacute;n si &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../memory/allocator/allocate&quot;&gt;std::allocator::allocate&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../memory/get_temporary_buffer&quot;&gt;std::get_temporary_buffer&lt;/a&gt;&lt;/code&gt; admiten tipos sobrealineados . &lt;a href=&quot;../named_req/allocator&quot;&gt;Los asignadores&lt;/a&gt; instanciados con tipos &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; no pueden crear instancias en tiempo de compilaci&amp;oacute;n, lanzar std :: bad_alloc en tiempo de ejecuci&amp;oacute;n, ignorar silenciosamente los requisitos de alineaci&amp;oacute;n no compatibles o manejarlos correctamente.</target>
        </trans-unit>
        <trans-unit id="ab7e947eb2a49ecc9700edf726245f07e8311cd4" translate="yes" xml:space="preserve">
          <source>. It is often used to provide an empty body to a &lt;a href=&quot;for&quot;&gt;for&lt;/a&gt; or &lt;a href=&quot;while&quot;&gt;while&lt;/a&gt; loop. It can also be used to carry a label in the end of a compound statement.</source>
          <target state="translated">. A menudo se utiliza para proporcionar un cuerpo vac&amp;iacute;o a una &lt;a href=&quot;for&quot;&gt;de&lt;/a&gt; o &lt;a href=&quot;while&quot;&gt;mientras&lt;/a&gt; bucle. Tambi&amp;eacute;n se puede usar para llevar una etiqueta al final de una declaraci&amp;oacute;n compuesta.</target>
        </trans-unit>
        <trans-unit id="ab056dbc0ad8ac12b777fec3697e10f3e1de1b4a" translate="yes" xml:space="preserve">
          <source>. It takes no arguments, returns void, and performs no action other than initial evaluation of &lt;code&gt;E1&lt;/code&gt;. This is the only case where the left-hand operand of &lt;code&gt;operator.&lt;/code&gt; has non-class type. Allowing pseudo destructor call makes it possible to write code without having to know if a destructor exists for a given type.</source>
          <target state="translated">. No toma argumentos, devuelve nulo y no realiza ninguna acci&amp;oacute;n que no sea la evaluaci&amp;oacute;n inicial de &lt;code&gt;E1&lt;/code&gt; . Este es el &amp;uacute;nico caso donde el operando izquierdo del &lt;code&gt;operator.&lt;/code&gt; tiene tipo no clase. Permitir llamadas de pseudodestructor hace posible escribir c&amp;oacute;digo sin tener que saber si existe un destructor para un tipo dado.</target>
        </trans-unit>
        <trans-unit id="eef30cb415d5d8eda6e82cbfa234d079d7a185fc" translate="yes" xml:space="preserve">
          <source>. Language linkage encapsulates the set of requirements necessary to link with a module written in another programming language: &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;calling convention&lt;/a&gt;, &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling&quot;&gt;name mangling&lt;/a&gt; algorithm, etc.</source>
          <target state="translated">. El enlace de lenguaje encapsula el conjunto de requisitos necesarios para enlazar con un m&amp;oacute;dulo escrito en otro lenguaje de programaci&amp;oacute;n: &lt;a href=&quot;https://en.wikipedia.org/wiki/Calling_convention&quot;&gt;convenci&amp;oacute;n de llamada&lt;/a&gt; , algoritmo de cambio de &lt;a href=&quot;https://en.wikipedia.org/wiki/Name_mangling&quot;&gt;nombre&lt;/a&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="5e2ad60e04fa8a32b82dd4ab36a67fe1ce73577f" translate="yes" xml:space="preserve">
          <source>. Literal types are the types of &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr variables&lt;/a&gt; and they can be constructed, manipulated, and returned from &lt;a href=&quot;../language/constexpr&quot;&gt;constexpr functions&lt;/a&gt;.</source>
          <target state="translated">. Los tipos literales son los tipos de &lt;a href=&quot;../language/constexpr&quot;&gt;variables constexpr&lt;/a&gt; y se pueden construir, manipular y devolver desde &lt;a href=&quot;../language/constexpr&quot;&gt;las funciones constexpr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fd05493594e79b94be80621c509c9e737da3b3c" translate="yes" xml:space="preserve">
          <source>. No memory reads or writes in the current thread can be reordered before or after this store. All writes in other threads that release the same atomic variable are visible before the modification and the modification is visible in other threads that acquire the same atomic variable.</source>
          <target state="translated">. No se pueden reordenar lecturas o escrituras de memoria en el hilo actual antes o despu&amp;eacute;s de esta tienda. Todas las escrituras en otros hilos que liberan la misma variable at&amp;oacute;mica son visibles antes de la modificaci&amp;oacute;n y la modificaci&amp;oacute;n es visible en otros hilos que adquieren la misma variable at&amp;oacute;mica.</target>
        </trans-unit>
        <trans-unit id="4043f50b8367eb4e26dc8f87a7a82decf69d22dd" translate="yes" xml:space="preserve">
          <source>. Objects of this type are &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic objects&lt;/a&gt; and have runtime type information stored as part of the object representation, which may be queried with &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; and &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt;. Virtual member functions participate in dynamic binding.</source>
          <target state="translated">. Los objetos de este tipo son &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;objetos polim&amp;oacute;rficos&lt;/a&gt; y tienen informaci&amp;oacute;n de tipo de tiempo de ejecuci&amp;oacute;n almacenada como parte de la representaci&amp;oacute;n del objeto, que puede consultarse con &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; y &lt;a href=&quot;typeid&quot;&gt;typeid&lt;/a&gt; . Las funciones miembro virtuales participan en el enlace din&amp;aacute;mico.</target>
        </trans-unit>
        <trans-unit id="a9a5f93018a465748262f4fd922c0b10831e96e6" translate="yes" xml:space="preserve">
          <source>. Only then &lt;code&gt;std::feof&lt;/code&gt; returns non-zero.</source>
          <target state="translated">. Solo entonces &lt;code&gt;std::feof&lt;/code&gt; devuelve valores distintos de cero.</target>
        </trans-unit>
        <trans-unit id="2a930ffd122a65a9f25ff1e6d9f9938ba49636a8" translate="yes" xml:space="preserve">
          <source>. Otherwise the pointer value is unchanged. Conversion of any pointer to pointer to void and back to pointer to the original (or more cv-qualified) type preserves its original value.</source>
          <target state="translated">. De lo contrario, el valor del puntero no cambia. La conversi&amp;oacute;n de cualquier puntero a puntero a vac&amp;iacute;o y de vuelta a puntero al tipo original (o m&amp;aacute;s calificado por cv) conserva su valor original.</target>
        </trans-unit>
        <trans-unit id="f7c05934e49017a55ffd7f8db5e6be448b7c6949" translate="yes" xml:space="preserve">
          <source>. Otherwise, it is a</source>
          <target state="translated">. De lo contrario, es un</target>
        </trans-unit>
        <trans-unit id="7d7ba1a37c76c90cfc05299fdb7d66d00cdf8dca" translate="yes" xml:space="preserve">
          <source>. Pointers to single objects are treated as pointers to arrays of one: &lt;code&gt;&amp;amp;obj+1&lt;/code&gt; compares greater than &lt;code&gt;&amp;amp;obj&lt;/code&gt;(since C++17)</source>
          <target state="translated">. Los punteros a objetos individuales se tratan como punteros a matrices de uno: &lt;code&gt;&amp;amp;obj+1&lt;/code&gt; compara mayor que &lt;code&gt;&amp;amp;obj&lt;/code&gt; (desde C ++ 17)</target>
        </trans-unit>
        <trans-unit id="79ab5295086cf1cff1d188640da5082b74e6f20b" translate="yes" xml:space="preserve">
          <source>. Rounding to nearest representable value results in 0x1.999999999999a*2-4</source>
          <target state="translated">. El redondeo al valor representable m&amp;aacute;s cercano da como resultado 0x1.999999999999a * 2-4</target>
        </trans-unit>
        <trans-unit id="cbad6d2df5c35e8f921fcaa593ace506841238a7" translate="yes" xml:space="preserve">
          <source>. See &lt;a href=&quot;virtual&quot;&gt;virtual functions&lt;/a&gt; and &lt;a href=&quot;abstract_class&quot;&gt;abstract classes&lt;/a&gt; for details.</source>
          <target state="translated">. Ver &lt;a href=&quot;virtual&quot;&gt;funciones virtuales&lt;/a&gt; y &lt;a href=&quot;abstract_class&quot;&gt;clases abstractas&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="1ac736feb756a0662765565c1ddf5c54714fbc2b" translate="yes" xml:space="preserve">
          <source>. That is, the last iterator &lt;code&gt;it&lt;/code&gt; for which range &lt;code&gt;[first, it)&lt;/code&gt; is a</source>
          <target state="translated">. Es decir, el &amp;uacute;ltimo iterador &lt;code&gt;it&lt;/code&gt; para los que cubre la &lt;code&gt;[first, it)&lt;/code&gt; es una</target>
        </trans-unit>
        <trans-unit id="3cb17b45da870b7ec9baaca006a81afb0e3f404f" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first character that</source>
          <target state="translated">. A partir de ese momento, la funci&amp;oacute;n busca el primer car&amp;aacute;cter que</target>
        </trans-unit>
        <trans-unit id="2923ece4a0bd3546cfdc4f62787758294b263ad1" translate="yes" xml:space="preserve">
          <source>. The function then searches from that point on for the first wide character that</source>
          <target state="translated">. A partir de ese momento, la funci&amp;oacute;n busca el primer car&amp;aacute;cter ancho que</target>
        </trans-unit>
        <trans-unit id="61b94db5d99f08f0c694055d17375cb798fa4521" translate="yes" xml:space="preserve">
          <source>. The name</source>
          <target state="translated">. El nombre</target>
        </trans-unit>
        <trans-unit id="85de12fb456918c6facd124a016788e336a84025" translate="yes" xml:space="preserve">
          <source>. The name can be referred to from all scopes in the current translation unit.</source>
          <target state="translated">. Se puede hacer referencia al nombre desde todos los &amp;aacute;mbitos en la unidad de traducci&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="f523417ea4918f53f6a9f95baf7712b34a86eae4" translate="yes" xml:space="preserve">
          <source>. The name can be referred to from the scopes in the other translation units. Variables and functions with external linkage also have &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt;, which makes it possible to link translation units written in different programming languages.</source>
          <target state="translated">. Se puede hacer referencia al nombre desde los &amp;aacute;mbitos en las otras unidades de traducci&amp;oacute;n. Las variables y funciones con enlace externo tambi&amp;eacute;n tienen &lt;a href=&quot;language_linkage&quot;&gt;enlace de idioma&lt;/a&gt; , lo que hace posible vincular unidades de traducci&amp;oacute;n escritas en diferentes lenguajes de programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8a09d851d0a6928714c77e7574c1b6d959c9da3c" translate="yes" xml:space="preserve">
          <source>. The name can be referred to only from the scope it is in.</source>
          <target state="translated">. Se puede hacer referencia al nombre solo desde el alcance en el que se encuentra.</target>
        </trans-unit>
        <trans-unit id="b998270ca375ea5551f58f59298525f0cd92ff73" translate="yes" xml:space="preserve">
          <source>. The name of such a class only exists within the function scope, and is not accessible outside.</source>
          <target state="translated">. El nombre de dicha clase solo existe dentro del alcance de la funci&amp;oacute;n y no es accesible desde afuera.</target>
        </trans-unit>
        <trans-unit id="3aca28dc5685eb1627cfa6227295b744c7c32887" translate="yes" xml:space="preserve">
          <source>. The parent directory can be represented by the relative pathname &lt;code&gt;&quot;..&quot;&lt;/code&gt;.</source>
          <target state="translated">. El directorio principal se puede representar con el nombre de ruta relativo &lt;code&gt;&quot;..&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af5191925264a6f1222eec36d0e558d7114acafb" translate="yes" xml:space="preserve">
          <source>. The point of declaration of the name is immediately following the opening brace of the class definition.</source>
          <target state="translated">. El punto de declaraci&amp;oacute;n del nombre sigue inmediatamente a la llave de apertura de la definici&amp;oacute;n de clase.</target>
        </trans-unit>
        <trans-unit id="d73ce905c7e8caed5bcf6a0c8b9740ee594fd215" translate="yes" xml:space="preserve">
          <source>. The syntax of the type-id that names type T is exactly the syntax of a &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; of a variable or function of type T, with the identifier omitted, except that</source>
          <target state="translated">. La sintaxis de la identificaci&amp;oacute;n de tipo que nombra el tipo T es exactamente la sintaxis de una &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; de una variable o funci&amp;oacute;n del tipo T, con el identificador omitido, excepto que</target>
        </trans-unit>
        <trans-unit id="0cd178f8d5684f66e16a2083635f91143d51a96e" translate="yes" xml:space="preserve">
          <source>. These attributes may be applied to the function type in a function declaration:</source>
          <target state="translated">. Estos atributos pueden aplicarse al tipo de funci&amp;oacute;n en una declaraci&amp;oacute;n de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e0b9b65bd5ab61cf0eba414c562588f6d88e9b46" translate="yes" xml:space="preserve">
          <source>. These include.</source>
          <target state="translated">. &amp;Eacute;stos incluyen.</target>
        </trans-unit>
        <trans-unit id="9b6b8144c37744c4c78e2ca9a7775e22e96ba479" translate="yes" xml:space="preserve">
          <source>. This allows certain errors to be detected at the point of definition, rather than instantiation, and removes the requirement on the &lt;code&gt;typename&lt;/code&gt; and &lt;code&gt;template&lt;/code&gt; disambiguators for dependent names, see below.</source>
          <target state="translated">. Esto permite detectar ciertos errores en el punto de definici&amp;oacute;n, en lugar de crear instancias, y elimina el requisito sobre el &lt;code&gt;typename&lt;/code&gt; y los desambigadores de &lt;code&gt;template&lt;/code&gt; para nombres dependientes, ver m&amp;aacute;s abajo.</target>
        </trans-unit>
        <trans-unit id="844564e7cf1c47f7ea75e5e1bf440e8f19afffd2" translate="yes" xml:space="preserve">
          <source>. This allows more efficient implementation of &lt;code&gt;memory_order_acquire&lt;/code&gt; and &lt;code&gt;memory_order_release&lt;/code&gt; on some CPUs. It can produce surprising results when &lt;code&gt;memory_order_acquire&lt;/code&gt; and &lt;code&gt;memory_order_release&lt;/code&gt; are mixed with &lt;code&gt;memory_order_seq_cst&lt;/code&gt;.</source>
          <target state="translated">. Esto permite una implementaci&amp;oacute;n m&amp;aacute;s eficiente de &lt;code&gt;memory_order_acquire&lt;/code&gt; y &lt;code&gt;memory_order_release&lt;/code&gt; en algunas CPU. Puede producir resultados sorprendentes cuando &lt;code&gt;memory_order_acquire&lt;/code&gt; y &lt;code&gt;memory_order_release&lt;/code&gt; se mezclan con &lt;code&gt;memory_order_seq_cst&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6ccbd031282697c64122e93a678f06f4c45fff4" translate="yes" xml:space="preserve">
          <source>. This constructor does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;. It is a trivial constructor if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">. Este constructor no participa en la resoluci&amp;oacute;n de sobrecarga a menos que &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; sea &lt;code&gt;true&lt;/code&gt; . Es un constructor trivial si &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_trivially_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="732d85aea2bce0e040fb4cd1659b35c6d1bc3c4a" translate="yes" xml:space="preserve">
          <source>. This constructor is defined as deleted if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. It is a trivial constructor if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">. Este constructor se define como eliminado si &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; . Es un constructor trivial si &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_trivially_copy_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="026c3d7e9a1fe8d5a967d61011a3beec752b15fd" translate="yes" xml:space="preserve">
          <source>. This distribution is used when estimating the</source>
          <target state="translated">. Esta distribuci&amp;oacute;n se utiliza al estimar el</target>
        </trans-unit>
        <trans-unit id="b316862e19fe4e350514297be86c991beb03e9ba" translate="yes" xml:space="preserve">
          <source>. This downcast is ill-formed if &lt;code&gt;B&lt;/code&gt; is ambiguous, inaccessible, or virtual base (or a base of a virtual base) of &lt;code&gt;D&lt;/code&gt;. Such &lt;code&gt;static_cast&lt;/code&gt; makes no runtime checks to ensure that the object's runtime type is actually &lt;code&gt;D&lt;/code&gt;, and may only be used safely if this precondition is guaranteed by other means, such as when implementing &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism&quot;&gt;static polymorphism&lt;/a&gt;. Safe downcast may be done with &lt;a href=&quot;dynamic_cast&quot;&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">. Este abatido est&amp;aacute; mal formada, si &lt;code&gt;B&lt;/code&gt; es la base ambigua, inaccesible, o virtual (o una base de una base virtual) de &lt;code&gt;D&lt;/code&gt; . Tal &lt;code&gt;static_cast&lt;/code&gt; no realiza comprobaciones de tiempo de ejecuci&amp;oacute;n para garantizar que el tipo de tiempo de ejecuci&amp;oacute;n del objeto sea realmente &lt;code&gt;D&lt;/code&gt; , y solo se puede usar de forma segura si esta condici&amp;oacute;n previa est&amp;aacute; garantizada por otros medios, como cuando se implementa &lt;a href=&quot;https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern#Static_polymorphism&quot;&gt;el polimorfismo est&amp;aacute;tico&lt;/a&gt; . El &lt;a href=&quot;dynamic_cast&quot;&gt; &lt;code&gt;dynamic_cast&lt;/code&gt; &lt;/a&gt; seguro se puede hacer con dynamic_cast .</target>
        </trans-unit>
        <trans-unit id="b398f2ef722f3eef80e8eb8655b49aa4fcb0fcec" translate="yes" xml:space="preserve">
          <source>. This has the effect of removing the first (largest) element from the heap defined by the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">. Esto tiene el efecto de eliminar el primer elemento (el m&amp;aacute;s grande) del mont&amp;oacute;n definido por el rango &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23e6923e524364fd639ec62ad6d11c97fd7da1cf" translate="yes" xml:space="preserve">
          <source>. Two types are covariant if they satisfy all of the following requirements:</source>
          <target state="translated">. Dos tipos son covariantes si satisfacen todos los siguientes requisitos:</target>
        </trans-unit>
        <trans-unit id="a9b5d1fd23fc7c5b4e6066615fc95994a5d113ca" translate="yes" xml:space="preserve">
          <source>. init-declarator-list is optional when declaring a named class/struct/union or a named enumeration</source>
          <target state="translated">. init-declarator-list es opcional cuando se declara una clase / estructura / uni&amp;oacute;n con nombre o una enumeraci&amp;oacute;n con nombre</target>
        </trans-unit>
        <trans-unit id="e996ce306a5268a292c41ab30ab0b1d4f7db02b0" translate="yes" xml:space="preserve">
          <source>. where S is the sum of all weights.</source>
          <target state="translated">. donde S es la suma de todos los pesos.</target>
        </trans-unit>
        <trans-unit id="9786fc35b53afb831a179c1e43a95571ec28165a" translate="yes" xml:space="preserve">
          <source>.(since C++14)</source>
          <target state="translated">. (desde C ++ 14)</target>
        </trans-unit>
        <trans-unit id="6eae3a5b062c6d0d79f070c26e6d62486b40cb46" translate="yes" xml:space="preserve">
          <source>...</source>
          <target state="translated">...</target>
        </trans-unit>
        <trans-unit id="faffb901ea5e603d448d5c651bc2ce1feb7ab56d" translate="yes" xml:space="preserve">
          <source>...Ints</source>
          <target state="translated">...Ints</target>
        </trans-unit>
        <trans-unit id="f29a917fc93c5cb1d8973220b883033399f48be1" translate="yes" xml:space="preserve">
          <source>...Ts</source>
          <target state="translated">...Ts</target>
        </trans-unit>
        <trans-unit id="e5f0d5fb385bca81078ad2a8707bbb8625cae265" translate="yes" xml:space="preserve">
          <source>...unless the parameter was expanded from a parameter pack</source>
          <target state="translated">... a menos que el par&amp;aacute;metro se haya expandido desde un paquete de par&amp;aacute;metros</target>
        </trans-unit>
        <trans-unit id="19f7ec135b5a79de79d6e7cc40d22413fe2af23d" translate="yes" xml:space="preserve">
          <source>/* implementation-defined */</source>
          <target state="translated">/ * definido por la implementaci&amp;oacute;n * /</target>
        </trans-unit>
        <trans-unit id="1ac5a1a38af02527751fd769c995e2b77199e5bf" translate="yes" xml:space="preserve">
          <source>/* non-specialized */</source>
          <target state="translated">/ * no especializado * /</target>
        </trans-unit>
        <trans-unit id="3555c1ad8bfe63c321204c247721dcd8a380c1e1" translate="yes" xml:space="preserve">
          <source>/* proxy */</source>
          <target state="translated">/ * proxy * /</target>
        </trans-unit>
        <trans-unit id="a269eaf502d0961ec13dad33647c50aef6df1f0b" translate="yes" xml:space="preserve">
          <source>/* unspecified */</source>
          <target state="translated">/ * sin especificar * /</target>
        </trans-unit>
        <trans-unit id="b6589fc6ab0dc82cf12099d1c2d40ab994e8410c" translate="yes" xml:space="preserve">
          <source>0</source>
          <target state="translated">0</target>
        </trans-unit>
        <trans-unit id="3e51cc904afd7e59e35c80a6ddcf5cd8135109f4" translate="yes" xml:space="preserve">
          <source>0 and the rest are initialized iteratively, for i=1-n,...,-1, each X</source>
          <target state="translated">0 y el resto se inicializan de forma iterativa,para i=1-n,...,-1,cada X</target>
        </trans-unit>
        <trans-unit id="a234edb1dd1ba7b125c0f9eacd66f79c2ee53496" translate="yes" xml:space="preserve">
          <source>0 are zero, and if all other X</source>
          <target state="translated">0 son cero,y si todas las otras X</target>
        </trans-unit>
        <trans-unit id="cbdfc7a60b2a1b991b37673e31df028f7727131b" translate="yes" xml:space="preserve">
          <source>0 if for each &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0,n)&lt;/code&gt;, &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; is true</source>
          <target state="translated">0 si para cada &lt;code&gt;i&lt;/code&gt; en &lt;code&gt;[0,n)&lt;/code&gt; , &lt;code&gt;X​::​eq(p[i], q[i])&lt;/code&gt; es verdadero</target>
        </trans-unit>
        <trans-unit id="a385b6d4430ed31871595e71093124d9e635d5b3" translate="yes" xml:space="preserve">
          <source>0 with 2w-1</source>
          <target state="translated">0 con 2w-1</target>
        </trans-unit>
        <trans-unit id="a0bd242d4e9823dde121cf81241caa8cb18b052a" translate="yes" xml:space="preserve">
          <source>0&amp;ndash;8</source>
          <target state="translated">0&amp;ndash;8</target>
        </trans-unit>
        <trans-unit id="a8df62a2404776e4a9f650425f66aba3e1c6eafd" translate="yes" xml:space="preserve">
          <source>0&amp;radic;1-k2</source>
          <target state="translated">0&amp;radic;1-k2</target>
        </trans-unit>
        <trans-unit id="b7a2c9b34dc2f4bec112398ca4ad2750f1912a7c" translate="yes" xml:space="preserve">
          <source>0,...,P</source>
          <target state="translated">0,...,P</target>
        </trans-unit>
        <trans-unit id="2bd186dce3970b7834f34e8ecaf95f82ee6270fe" translate="yes" xml:space="preserve">
          <source>0-qualified pointer to cv1</source>
          <target state="translated">0-puntero calificado para cv1</target>
        </trans-unit>
        <trans-unit id="fe1e007660532039a2e8edd7bcd53a0d3a1d5908" translate="yes" xml:space="preserve">
          <source>0-qualified pointer to cv2</source>
          <target state="translated">Puntero de 0 a cv2</target>
        </trans-unit>
        <trans-unit id="7abe581e3bbbaa5fdd179596f8a0dc409c4c5006" translate="yes" xml:space="preserve">
          <source>0tx-1</source>
          <target state="translated">0tx-1</target>
        </trans-unit>
        <trans-unit id="356a192b7913b04c54574d18c28d46e6395428ab" translate="yes" xml:space="preserve">
          <source>1</source>
          <target state="translated">1</target>
        </trans-unit>
        <trans-unit id="6811f7a8f41e917fb0d97233a1567d9f7103a1c6" translate="yes" xml:space="preserve">
          <source>1 &amp;lt; K+1 = M &amp;le; N</source>
          <target state="translated">1 &amp;lt;K + 1 = M &amp;le; N</target>
        </trans-unit>
        <trans-unit id="f785463204330c080875e98ef24f1d1d3a6bddb4" translate="yes" xml:space="preserve">
          <source>1 &amp;minus; p if &lt;code&gt;b == false&lt;/code&gt;</source>
          <target state="translated">1 - p si &lt;code&gt;b == false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1948bd668a05b546ade4e87c5dc1e44b28d6388d" translate="yes" xml:space="preserve">
          <source>1 if the first string is greater than the second (that is, follows the second in the collation order), -1 if the first string is less than the second (precedes the second in the collation order), zero if the two strings are equivalent.</source>
          <target state="translated">1 si la primera cadena es mayor que la segunda (es decir,sigue a la segunda en el orden de cotejo),-1 si la primera cadena es menor que la segunda (precede a la segunda en el orden de cotejo),cero si las dos cadenas son equivalentes.</target>
        </trans-unit>
        <trans-unit id="47b4d0a7e4e7a4b47f71461424c2bc278b9cf1bf" translate="yes" xml:space="preserve">
          <source>1 op (... op (E</source>
          <target state="translated">1 en ...en (E</target>
        </trans-unit>
        <trans-unit id="86fb1242522651d4f696d9af9c16480d53bf7888" translate="yes" xml:space="preserve">
          <source>1 op E</source>
          <target state="translated">1 en E</target>
        </trans-unit>
        <trans-unit id="7856021a1dd28ad72b926a915ecc0aad8c99768f" translate="yes" xml:space="preserve">
          <source>1) (deprecated in C++17) If &lt;code&gt;F&lt;/code&gt; is a pointer to function or a pointer to member function, &lt;code&gt;result_type&lt;/code&gt; is the return type of &lt;code&gt;F&lt;/code&gt;. If &lt;code&gt;F&lt;/code&gt; is a class type with nested typedef &lt;code&gt;result_type&lt;/code&gt;, then &lt;code&gt;result_type&lt;/code&gt; is &lt;code&gt;F::result_type&lt;/code&gt;. Otherwise no &lt;code&gt;result_type&lt;/code&gt; is defined.</source>
          <target state="translated">1) (en desuso en C ++ 17) Si &lt;code&gt;F&lt;/code&gt; es un puntero a funci&amp;oacute;n o un puntero a la funci&amp;oacute;n miembro, &lt;code&gt;result_type&lt;/code&gt; es el tipo de retorno de &lt;code&gt;F&lt;/code&gt; . Si &lt;code&gt;F&lt;/code&gt; es un tipo de clase con typedef anidado &lt;code&gt;result_type&lt;/code&gt; , &lt;code&gt;result_type&lt;/code&gt; es &lt;code&gt;F::result_type&lt;/code&gt; . De lo contrario, no se define &lt;code&gt;result_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83ea50c76bc44cdd9e4f766c317db5c2037df0e1" translate="yes" xml:space="preserve">
          <source>1) (none)</source>
          <target state="translated">1)(ninguno)</target>
        </trans-unit>
        <trans-unit id="86452ff75dcaffc8160d808ad365b65ef26fd4f4" translate="yes" xml:space="preserve">
          <source>1) (none)  2).</source>
          <target state="translated">1)(ninguno)2).</target>
        </trans-unit>
        <trans-unit id="34a572a24e5822c38c6b3ac46db113826995572c" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;CT(lhs).count() == CT(rhs).count()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;CT(lhs).count() == CT(rhs).count()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6a38143daa43b50349154fefdef085b81c3ad69" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;U&amp;amp;&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt;; &lt;code&gt;T&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;U&amp;amp;&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; ; &lt;code&gt;T&lt;/code&gt; de lo contrario.</target>
        </trans-unit>
        <trans-unit id="356a0877a891d6c9b60ef01cb7aaa9edeed1d1b1" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;os&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;os&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c22d94e3201de96926713e0b0f3b78a82a762b89" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;other&lt;/code&gt; is a copy of &lt;code&gt;*this&lt;/code&gt; or has an identical name, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;other&lt;/code&gt; es una copia de &lt;code&gt;*this&lt;/code&gt; o tiene un nombre id&amp;eacute;ntico, &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="d6622eb011b611aae7e8c72a24755377368ad3a3" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;std::get&amp;lt;i&amp;gt;(lhs) == std::get&amp;lt;i&amp;gt;(rhs)&lt;/code&gt; for all i in &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;. For two empty tuples returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;std::get&amp;lt;i&amp;gt;(lhs) == std::get&amp;lt;i&amp;gt;(rhs)&lt;/code&gt; para todo i en &lt;code&gt;[0, sizeof...(Types))&lt;/code&gt; , de lo contrario es &lt;code&gt;false&lt;/code&gt; . Para dos tuplas vac&amp;iacute;as devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="287dd3f95063f279870312b22bda28b87cd0fd6d" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if both &lt;code&gt;lhs.first == rhs.first&lt;/code&gt; and &lt;code&gt;lhs.second == rhs.second&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; si tanto &lt;code&gt;lhs.first == rhs.first&lt;/code&gt; como &lt;code&gt;lhs.second == rhs.second&lt;/code&gt; , de lo contrario es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27a520d2b54a1f6646b3759539dd07d9fa75978e" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the distribution objects are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; si los objetos de distribuci&amp;oacute;n son iguales, &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="1288e43751f25875bb27e07c4078a20e14710ced" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the underlying &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; objects refer to the same type, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; si los objetos &lt;code&gt;&lt;a href=&quot;../type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; subyacentes se refieren al mismo tipo, de lo contrario , &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="104870c8f3088e1326f88bd2c5413aebdc6b362c" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;true&lt;/code&gt; if the value of each bit in &lt;code&gt;*this&lt;/code&gt; equals the value of the corresponding bit in &lt;code&gt;rhs&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;true&lt;/code&gt; si el valor de cada bit en &lt;code&gt;*this&lt;/code&gt; es igual al valor del bit correspondiente en &lt;code&gt;rhs&lt;/code&gt; , de lo contrario es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f71bf93702e13dec1d236cb721728da440f6f871" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;x.get() == y.get()&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;x.get() == y.get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11d9b8b52ebd3e1a3a024e6ccd57926c21a2e926" translate="yes" xml:space="preserve">
          <source>1) &lt;code&gt;​0​&lt;/code&gt; on success, non-zero otherwise.</source>
          <target state="translated">1) &lt;code&gt;​0​&lt;/code&gt; en caso de &amp;eacute;xito, no cero en caso contrario.</target>
        </trans-unit>
        <trans-unit id="6a3ae1acf7b6dec0a07ba83e824584db212e3584" translate="yes" xml:space="preserve">
          <source>1) A</source>
          <target state="translated">1)A</target>
        </trans-unit>
        <trans-unit id="20fbef856206918a3d8fb45dbe16ba8dc8b0ab41" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;std::chrono::sys_info&lt;/code&gt; structure &lt;code&gt;i&lt;/code&gt; containing the time zone information in effect for this time zone at the time point &lt;code&gt;tp&lt;/code&gt;. &lt;code&gt;tp&lt;/code&gt; will be in the range &lt;code&gt;[i.begin, i.end)&lt;/code&gt;.</source>
          <target state="translated">1) A &lt;code&gt;std::chrono::sys_info&lt;/code&gt; estructurar &lt;code&gt;i&lt;/code&gt; que contiene la informaci&amp;oacute;n de zona horaria en efecto para esta zona de tiempo en el punto de tiempo &lt;code&gt;tp&lt;/code&gt; . &lt;code&gt;tp&lt;/code&gt; estar&amp;aacute; en el rango &lt;code&gt;[i.begin, i.end)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d73fc0de5837fb35ed94e495176a1ab53919bb87" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;sys_time&lt;/code&gt; representing the same point in time as the argument.</source>
          <target state="translated">1) Un &lt;code&gt;sys_time&lt;/code&gt; que representa el mismo punto en el tiempo que el argumento.</target>
        </trans-unit>
        <trans-unit id="cabaf2c8fe8bd5c8a1098bdc266583d59f4973d7" translate="yes" xml:space="preserve">
          <source>1) A &lt;code&gt;utc_time&lt;/code&gt; representing the same point in time as the argument.</source>
          <target state="translated">1) Un &lt;code&gt;utc_time&lt;/code&gt; que representa el mismo punto en el tiempo que el argumento.</target>
        </trans-unit>
        <trans-unit id="b8328f6a84aae122e8939d2fec2a952c6930f619" translate="yes" xml:space="preserve">
          <source>1) A is</source>
          <target state="translated">1)A es</target>
        </trans-unit>
        <trans-unit id="5f587efae23c247ca28924e943089a9746064083" translate="yes" xml:space="preserve">
          <source>1) A is a modification, and B reads the value stored by A 2) A precedes B in the</source>
          <target state="translated">1)A es una modificación,y B lee el valor almacenado por A 2)A precede a B en el</target>
        </trans-unit>
        <trans-unit id="2dbafc39b4109d874a6ef2cacd1b60fbe55da610" translate="yes" xml:space="preserve">
          <source>1) A non-type template parameter pack with an optional name</source>
          <target state="translated">1)Un paquete de parámetros de plantilla sin tipo con un nombre opcional</target>
        </trans-unit>
        <trans-unit id="af46537a854cfc07af90d00edb90238c2ee6d6fd" translate="yes" xml:space="preserve">
          <source>1) A non-type template parameter with an optional name.</source>
          <target state="translated">1)Un parámetro de plantilla sin tipo con un nombre opcional.</target>
        </trans-unit>
        <trans-unit id="4fe90bdfc834565a8e6349626f28a49a60b68cd0" translate="yes" xml:space="preserve">
          <source>1) A performs a</source>
          <target state="translated">1)A realiza una</target>
        </trans-unit>
        <trans-unit id="fbc6fe14c6af3cf8418f033f94d06174d8d80ddb" translate="yes" xml:space="preserve">
          <source>1) A range adaptor that produces a &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of no elements of a particular type.</source>
          <target state="translated">1) Un adaptador de rango que produce una &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; sin elementos de un tipo particular.</target>
        </trans-unit>
        <trans-unit id="0b9ae19f16d299250d9ad0aaf00550a8d1c41fae" translate="yes" xml:space="preserve">
          <source>1) A range adaptor that represents &lt;a href=&quot;view&quot;&gt;&lt;code&gt;View&lt;/code&gt;&lt;/a&gt; of an underlying sequence without the elements that fail to satisfy a predicate.</source>
          <target state="translated">1) Un adaptador de rango que representa la &lt;a href=&quot;view&quot;&gt; &lt;code&gt;View&lt;/code&gt; &lt;/a&gt; de una secuencia subyacente sin los elementos que no satisfacen un predicado.</target>
        </trans-unit>
        <trans-unit id="b9956ba464175b6f57bff8b5d832269a811d8115" translate="yes" xml:space="preserve">
          <source>1) A range factory that generates a sequence of elements by repeatedly incrementing an initial value. Can be both bounded and unbounded (infinite)</source>
          <target state="translated">1)Una fábrica de rango que genera una secuencia de elementos incrementando repetidamente un valor inicial.Puede ser tanto limitada como ilimitada (infinita)</target>
        </trans-unit>
        <trans-unit id="fe4686de1a7da6422a6cf066a0610a3a80118153" translate="yes" xml:space="preserve">
          <source>1) A reference to the global &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; singleton.</source>
          <target state="translated">1) Una referencia al &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; singleton global .</target>
        </trans-unit>
        <trans-unit id="82947af8d2369ef592a5e98e3d4604eb5d6af50d" translate="yes" xml:space="preserve">
          <source>1) A set of</source>
          <target state="translated">1)Un conjunto de</target>
        </trans-unit>
        <trans-unit id="a299040649a8f9f824a466b99cd8accb4069fd60" translate="yes" xml:space="preserve">
          <source>1) A span constructed with &lt;code&gt;{reinterpret_cast&amp;lt;const &lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt;.</source>
          <target state="translated">1) Un lapso construido con &lt;code&gt;{reinterpret_cast&amp;lt;const &lt;a href=&quot;../../types/byte&quot;&gt;std::byte&lt;/a&gt;*&amp;gt;(s.data()), s.size_bytes()}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="424f7940a81075143bd01c42816d096ec4cc3e70" translate="yes" xml:space="preserve">
          <source>1) A standard conversion sequence is always</source>
          <target state="translated">1)Una secuencia de conversión estándar es siempre</target>
        </trans-unit>
        <trans-unit id="a46604118cc45bb8f1fc823ba39ae021f0682a23" translate="yes" xml:space="preserve">
          <source>1) A string object holding a copy of this buffer's underlying character sequence.</source>
          <target state="translated">1)Un objeto de cadena que contiene una copia de la secuencia de caracteres subyacente de esta memoria intermedia.</target>
        </trans-unit>
        <trans-unit id="46e69a24f3f32aa99efec236d8f802a03d6df127" translate="yes" xml:space="preserve">
          <source>1) A template template parameter with an optional name.</source>
          <target state="translated">1)Un parámetro de plantilla con un nombre opcional.</target>
        </trans-unit>
        <trans-unit id="bf76071f8f71da36945babb431edddf84fe21626" translate="yes" xml:space="preserve">
          <source>1) A type alias declaration introduces a name which can be used as a synonym for the type denoted by type-id. It does not introduce a new type and it cannot change the meaning of an existing type name. There is no difference between a type alias declaration and &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; declaration. This declaration may appear in block scope, class scope, or namespace scope.</source>
          <target state="translated">1) Una declaraci&amp;oacute;n de alias de tipo introduce un nombre que puede usarse como sin&amp;oacute;nimo del tipo denotado por type-id. No introduce un nuevo tipo y no puede cambiar el significado de un nombre de tipo existente. No hay diferencia entre una declaraci&amp;oacute;n de alias de tipo y una declaraci&amp;oacute;n de &lt;a href=&quot;typedef&quot;&gt;typedef&lt;/a&gt; . Esta declaraci&amp;oacute;n puede aparecer en el alcance del bloque, el alcance de la clase o el alcance del espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="d39d12e44cd655e37c42c123e3133548497ae9ed" translate="yes" xml:space="preserve">
          <source>1) A type template parameter without a default.</source>
          <target state="translated">1)Un tipo de parámetro de plantilla sin un valor por defecto.</target>
        </trans-unit>
        <trans-unit id="173390dfcc7b8ee2a586fea4454de09b477814e3" translate="yes" xml:space="preserve">
          <source>1) Accesses (reads and writes) to &lt;a href=&quot;cv&quot;&gt;volatile&lt;/a&gt; objects occur strictly according to the semantics of the expressions in which they occur. In particular, they are &lt;a href=&quot;../atomic/memory_order&quot;&gt;not reordered&lt;/a&gt; with respect to other volatile accesses on the same thread.</source>
          <target state="translated">1) Los accesos (lecturas y escrituras) a objetos &lt;a href=&quot;cv&quot;&gt;vol&amp;aacute;tiles&lt;/a&gt; ocurren estrictamente de acuerdo con la sem&amp;aacute;ntica de las expresiones en las que ocurren. En particular, no se &lt;a href=&quot;../atomic/memory_order&quot;&gt;reordenan&lt;/a&gt; con respecto a otros accesos vol&amp;aacute;tiles en el mismo hilo.</target>
        </trans-unit>
        <trans-unit id="82db348ccd128d42ca8c97273d60b073e85127a3" translate="yes" xml:space="preserve">
          <source>1) All characters in &lt;a href=&quot;character_literal&quot;&gt;character literals&lt;/a&gt; and &lt;a href=&quot;string_literal&quot;&gt;string literals&lt;/a&gt; are converted from the source character set to the</source>
          <target state="translated">1) Todos los caracteres en &lt;a href=&quot;character_literal&quot;&gt;literales de caracteres&lt;/a&gt; y literales de &lt;a href=&quot;string_literal&quot;&gt;cadena&lt;/a&gt; se convierten del conjunto de caracteres de origen a</target>
        </trans-unit>
        <trans-unit id="66bfdbf9083c74e9a1866c3e2e464fc8189cefc5" translate="yes" xml:space="preserve">
          <source>1) All memory allocations are performed by &lt;code&gt;a&lt;/code&gt;.</source>
          <target state="translated">1) Todas las asignaciones de memoria son realizadas por &lt;code&gt;a&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="048a26efa0caafdd751840d3dafcd66eba62dbea" translate="yes" xml:space="preserve">
          <source>1) Amortized constant</source>
          <target state="translated">1)Constante amortizada</target>
        </trans-unit>
        <trans-unit id="5981b7305017c9545a89a5a35fe66de383130acf" translate="yes" xml:space="preserve">
          <source>1) An expression of integral, enumeration, pointer, or pointer-to-member type can be converted to its own type. The resulting value is the same as the value of &lt;code&gt;expression&lt;/code&gt;. (since C++11)</source>
          <target state="translated">1) Una expresi&amp;oacute;n de tipo integral, enumeraci&amp;oacute;n, puntero o puntero a miembro se puede convertir a su propio tipo. El valor resultante es el mismo que el valor de &lt;code&gt;expression&lt;/code&gt; . (desde C ++ 11)</target>
        </trans-unit>
        <trans-unit id="95cffb88bccbe314e1530157850332433d961b24" translate="yes" xml:space="preserve">
          <source>1) An implementation-defined type that holds a reference to &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1) Un tipo definido por la implementaci&amp;oacute;n que contiene una referencia a &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66c9b9f664df38161f10437106d4643e64c7e947" translate="yes" xml:space="preserve">
          <source>1) An object of class &lt;code&gt;any&lt;/code&gt; stores an instance of any type that satisfies the constructor requirements or is empty, and this is referred to as the</source>
          <target state="translated">1) Un objeto de clase &lt;code&gt;any&lt;/code&gt; almacena una instancia de cualquier tipo que satisfaga los requisitos del constructor o est&amp;eacute; vac&amp;iacute;a, y esto se conoce como</target>
        </trans-unit>
        <trans-unit id="61dc882dd7d34d7d4ad75d6cb735240681e1867e" translate="yes" xml:space="preserve">
          <source>1) Analyzes generic range &lt;code&gt;[first,last)&lt;/code&gt;. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1) Analiza el rango gen&amp;eacute;rico &lt;code&gt;[first,last)&lt;/code&gt; . Los resultados del partido se devuelven en &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80ba3076eb89d7a3ef079f9e8618c645e77976f7" translate="yes" xml:space="preserve">
          <source>1) Appends &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;</source>
          <target state="translated">1) Agrega copias de &lt;code&gt;count&lt;/code&gt; de caracteres &lt;code&gt;ch&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f4fd2232e22aac2b19529e6e3b82510ab23c6ef" translate="yes" xml:space="preserve">
          <source>1) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, first + n)&lt;/code&gt;, in order.</source>
          <target state="translated">1) Aplica el objeto de funci&amp;oacute;n dado &lt;code&gt;f&lt;/code&gt; al resultado de desreferenciar cada iterador en el rango &lt;code&gt;[first, first + n)&lt;/code&gt; , en orden.</target>
        </trans-unit>
        <trans-unit id="9326d78a127c522e3d8f1f7afedde286e2d81452" translate="yes" xml:space="preserve">
          <source>1) Applies the given function object &lt;code&gt;f&lt;/code&gt; to the result of dereferencing every iterator in the range &lt;code&gt;[first, last)&lt;/code&gt;, in order.</source>
          <target state="translated">1) Aplica el objeto de funci&amp;oacute;n dado &lt;code&gt;f&lt;/code&gt; al resultado de desreferenciar cada iterador en el rango &lt;code&gt;[first, last)&lt;/code&gt; , en orden.</target>
        </trans-unit>
        <trans-unit id="a269e932f278e6dc2ae1bfe911e2855a58c5ae13" translate="yes" xml:space="preserve">
          <source>1) Applies the language specification string-literal to all function types, function names with external linkage and variables with external linkage declared in declaration-seq.</source>
          <target state="translated">1)Aplica la especificación del lenguaje string-literal a todos los tipos de funciones,nombres de funciones con vinculación externa y variables con vinculación externa declaradas en la declaración-seq.</target>
        </trans-unit>
        <trans-unit id="0f9581ab834f137fbae8882fe84416428e32951d" translate="yes" xml:space="preserve">
          <source>1) Applies the offset &lt;code&gt;d&lt;/code&gt; to &lt;code&gt;pt&lt;/code&gt;. Effectively, &lt;code&gt;d&lt;/code&gt; is added to the internally stored duration &lt;code&gt;d_&lt;/code&gt; as &lt;code&gt;d_ += d&lt;/code&gt;.</source>
          <target state="translated">1) Aplica el desplazamiento &lt;code&gt;d&lt;/code&gt; a &lt;code&gt;pt&lt;/code&gt; . Efectivamente, &lt;code&gt;d&lt;/code&gt; se agrega a la duraci&amp;oacute;n internamente almacenada &lt;code&gt;d_&lt;/code&gt; como &lt;code&gt;d_ += d&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd44368f1ec313c9be1e54cec6967210632f57be" translate="yes" xml:space="preserve">
          <source>1) Applies to a statement to allow the compiler to optimize for the case where paths of execution including that statement are more likely than any alternative path of execution that does not include such a statement.</source>
          <target state="translated">1)Se aplica a una declaración para permitir que el compilador optimice para el caso en que las vías de ejecución que incluyan esa declaración sean más probables que cualquier otra vía de ejecución que no incluya dicha declaración.</target>
        </trans-unit>
        <trans-unit id="8f5ccf9c295ab95bc3305d17a3414892b4f79ae1" translate="yes" xml:space="preserve">
          <source>1) As a part of class member access expression, in which the class either has this member or is derived from a class that has this member, including the implicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; member access expressions that appear when a non-static member name is used in any of the contexts where &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; is allowed (inside member function bodies, in member initializer lists, in the in-class default member initializers).</source>
          <target state="translated">1) Como parte de la expresi&amp;oacute;n de acceso de miembro de clase, en la que la clase tiene este miembro o se deriva de una clase que tiene este miembro, incluidas las expresiones de acceso impl&amp;iacute;cito &lt;code&gt;this-&amp;gt;&lt;/code&gt; member que aparecen cuando se usa un nombre de miembro no est&amp;aacute;tico en cualquiera de los contextos donde &lt;a href=&quot;this&quot;&gt;esto&lt;/a&gt; est&amp;aacute; permitido (dentro de los cuerpos de funciones miembro, en las listas de inicializadores de miembros, en los inicializadores de miembros predeterminados en su clase).</target>
        </trans-unit>
        <trans-unit id="0cc54ba39b78a1ff9452057d5e234e2f1c5cc09c" translate="yes" xml:space="preserve">
          <source>1) As the comma may be used in the current locale as decimal separator, the output may be ambiguous. This can be solved with &lt;code&gt;&lt;a href=&quot;../../io/manip/showpoint&quot;&gt;std::showpoint&lt;/a&gt;&lt;/code&gt; which forces the decimal separator to be visible.</source>
          <target state="translated">1) Como la coma se puede usar en el entorno local actual como separador decimal, la salida puede ser ambigua. Esto se puede resolver con &lt;code&gt;&lt;a href=&quot;../../io/manip/showpoint&quot;&gt;std::showpoint&lt;/a&gt;&lt;/code&gt; que obliga al separador decimal a ser visible.</target>
        </trans-unit>
        <trans-unit id="bf4f5eebb3756e5992406e2db6b3544a4860b1b1" translate="yes" xml:space="preserve">
          <source>1) Assigns &lt;code&gt;value&lt;/code&gt; to all of the elements.</source>
          <target state="translated">1) Asigna &lt;code&gt;value&lt;/code&gt; a todos los elementos.</target>
        </trans-unit>
        <trans-unit id="0471cc16b46b1f8592b99a5def70ecd023e5db86" translate="yes" xml:space="preserve">
          <source>1) Assigns &lt;code&gt;x&lt;/code&gt; to the real part of the complex number. Imaginary part is set to zero.</source>
          <target state="translated">1) Asigna &lt;code&gt;x&lt;/code&gt; a la parte real del n&amp;uacute;mero complejo. La parte imaginaria se establece en cero.</target>
        </trans-unit>
        <trans-unit id="bd74c1606493d2cb5c5263fcb597f13362ee0e84" translate="yes" xml:space="preserve">
          <source>1) Assigns a copy of</source>
          <target state="translated">1)Asigna una copia de</target>
        </trans-unit>
        <trans-unit id="14686248fd4c999e4263d1cbae14e46f33834fac" translate="yes" xml:space="preserve">
          <source>1) Assigns by copying the state of &lt;code&gt;rhs&lt;/code&gt;, as if by &lt;code&gt;any(rhs).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1) Asigna copiando el estado de &lt;code&gt;rhs&lt;/code&gt; , como si fuera &lt;code&gt;any(rhs).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79f8283f561eb803af10bf64d307d128f5f83943" translate="yes" xml:space="preserve">
          <source>1) Assigns character &lt;code&gt;a&lt;/code&gt; to character &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">1) Asigna el car&amp;aacute;cter &lt;code&gt;a&lt;/code&gt; al car&amp;aacute;cter &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b50adfd66ed3872fa645e5d68c15f0490c3528ad" translate="yes" xml:space="preserve">
          <source>1) Assigns each element in range &lt;code&gt;[first, last)&lt;/code&gt; a value generated by the given function object &lt;code&gt;g&lt;/code&gt;.</source>
          <target state="translated">1) Asigna a cada elemento en el rango &lt;code&gt;[first, last)&lt;/code&gt; un valor generado por el objeto de funci&amp;oacute;n dado &lt;code&gt;g&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27023b4931499f367feb0a7ac32948b060a43b0d" translate="yes" xml:space="preserve">
          <source>1) Assigns the contents of &lt;code&gt;other&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; are equivalent to the values of &lt;code&gt;other.flags()&lt;/code&gt; and &lt;code&gt;other.mark_count()&lt;/code&gt; after the call.</source>
          <target state="translated">1) Asigna los contenidos de &lt;code&gt;other&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;flags&quot;&gt;flags()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;mark_count&quot;&gt;mark_count()&lt;/a&gt;&lt;/code&gt; son equivalentes a los valores de &lt;code&gt;other.flags()&lt;/code&gt; y &lt;code&gt;other.mark_count()&lt;/code&gt; despu&amp;eacute;s de la llamada.</target>
        </trans-unit>
        <trans-unit id="3cb923639f2556c1a0b92d6585fc6bae83d4f775" translate="yes" xml:space="preserve">
          <source>1) Assigns the given &lt;code&gt;value&lt;/code&gt; to the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">1) Asigna el &lt;code&gt;value&lt;/code&gt; dado a los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc010e5348cf35fe3386539e2bcb8ef2deb9b2f0" translate="yes" xml:space="preserve">
          <source>1) Assigns the given &lt;code&gt;value&lt;/code&gt; to the first &lt;code&gt;count&lt;/code&gt; elements in the range beginning at &lt;code&gt;first&lt;/code&gt; if &lt;code&gt;count &amp;gt; 0&lt;/code&gt;. Does nothing otherwise.</source>
          <target state="translated">1) Asigna el &lt;code&gt;value&lt;/code&gt; dado a los primeros elementos de &lt;code&gt;count&lt;/code&gt; en el rango que comienza en &lt;code&gt;first&lt;/code&gt; si &lt;code&gt;count &amp;gt; 0&lt;/code&gt; . No hace nada de otra manera.</target>
        </trans-unit>
        <trans-unit id="44657b2873420948c5a550c8cea126cd3bcf8a02" translate="yes" xml:space="preserve">
          <source>1) Assigns the pathname identified by the detected-format string &lt;code&gt;source&lt;/code&gt;, which is left in valid, but unspecified state.</source>
          <target state="translated">1) Asigna el nombre de ruta identificado por la &lt;code&gt;source&lt;/code&gt; cadena de formato detectado , que se deja en estado v&amp;aacute;lido, pero no especificado.</target>
        </trans-unit>
        <trans-unit id="1c5a2378f7a4b4f8c3112c22372e803c7c5df859" translate="yes" xml:space="preserve">
          <source>1) Assigns values, generated by given function object &lt;code&gt;g&lt;/code&gt;, to the first &lt;code&gt;count&lt;/code&gt; elements in the range beginning at &lt;code&gt;first&lt;/code&gt;, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;. Does nothing otherwise.</source>
          <target state="translated">1) Asigna valores, generados por el objeto de funci&amp;oacute;n dado &lt;code&gt;g&lt;/code&gt; , a los primeros elementos de &lt;code&gt;count&lt;/code&gt; en el rango que comienza al &lt;code&gt;first&lt;/code&gt; , si &lt;code&gt;count&amp;gt;0&lt;/code&gt; . No hace nada de otra manera.</target>
        </trans-unit>
        <trans-unit id="1eab96dc5e46fc4e8f1977dffe840d7d81e24fe4" translate="yes" xml:space="preserve">
          <source>1) At every &lt;a href=&quot;eval_order&quot;&gt;sequence point&lt;/a&gt;, the values of all &lt;a href=&quot;cv&quot;&gt;volatile&lt;/a&gt; objects are stable (previous evaluations are complete, new evaluations not started)</source>
          <target state="translated">1) En cada &lt;a href=&quot;eval_order&quot;&gt;punto de secuencia&lt;/a&gt; , los valores de todos &lt;a href=&quot;cv&quot;&gt;los&lt;/a&gt; objetos vol&amp;aacute;tiles son estables (las evaluaciones anteriores est&amp;aacute;n completas, las nuevas evaluaciones no se iniciaron)</target>
        </trans-unit>
        <trans-unit id="2d2df9e87c835521a32a8b38e0df7638b8c0360b" translate="yes" xml:space="preserve">
          <source>1) Atomic types are not copy/move assignable</source>
          <target state="translated">1)Los tipos atómicos no son asignables por copia/movimiento</target>
        </trans-unit>
        <trans-unit id="1e1dd757f206c6d84410b18d446f5857c8473733" translate="yes" xml:space="preserve">
          <source>1) Atomically assigns a value &lt;code&gt;desired&lt;/code&gt; to the atomic variable. Equivalent to &lt;code&gt;store(desired)&lt;/code&gt;.</source>
          <target state="translated">1) Asigna at&amp;oacute;micamente un valor &lt;code&gt;desired&lt;/code&gt; a la variable at&amp;oacute;mica. Equivalente a &lt;code&gt;store(desired)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20eba43ce6c7c735f06737453bb9f5d0dcd49f5a" translate="yes" xml:space="preserve">
          <source>1) Atomically assigns a value &lt;code&gt;desired&lt;/code&gt; to the referenced object. Equivalent to &lt;code&gt;store(desired)&lt;/code&gt;.</source>
          <target state="translated">1) Asigna at&amp;oacute;micamente un valor &lt;code&gt;desired&lt;/code&gt; al objeto referenciado. Equivalente a &lt;code&gt;store(desired)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="917158b5056f9fcbc3944d1e3cd72bab0516b4f5" translate="yes" xml:space="preserve">
          <source>1) Atomically obtains the value pointed to by &lt;code&gt;obj&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;load()&lt;/code&gt;</source>
          <target state="translated">1) Obtiene at&amp;oacute;micamente el valor apuntado por &lt;code&gt;obj&lt;/code&gt; como si por &lt;code&gt;obj-&amp;gt;load()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d17583e702426f0634bea84e519c1633a6c029e1" translate="yes" xml:space="preserve">
          <source>1) Atomically releases &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed, or when the absolute time point &lt;code&gt;timeout_time&lt;/code&gt; is reached. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait_until&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1) Libera at&amp;oacute;micamente el &lt;code&gt;lock&lt;/code&gt; , bloquea el subproceso actual en ejecuci&amp;oacute;n y lo agrega a la lista de subprocesos que esperan &lt;code&gt;*this&lt;/code&gt; . El subproceso se desbloquear&amp;aacute; cuando se &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; , o cuando se &lt;code&gt;timeout_time&lt;/code&gt; punto de tiempo absoluto timeout_time . Tambi&amp;eacute;n puede ser desbloqueado espuriosamente. Cuando se desbloquea, independientemente del motivo, se recupera el &lt;code&gt;lock&lt;/code&gt; y se cierra &lt;code&gt;wait_until&lt;/code&gt; . Si esta funci&amp;oacute;n sale por excepci&amp;oacute;n, tambi&amp;eacute;n se vuelve a adquirir el &lt;code&gt;lock&lt;/code&gt; . (Hasta C ++ 14)</target>
        </trans-unit>
        <trans-unit id="39228d6c9d016ca7d710e477075b422412a6e3a1" translate="yes" xml:space="preserve">
          <source>1) Atomically releases &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed, or when the relative timeout &lt;code&gt;rel_time&lt;/code&gt; expires. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait_for()&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1) Libera at&amp;oacute;micamente el &lt;code&gt;lock&lt;/code&gt; , bloquea el subproceso actual en ejecuci&amp;oacute;n y lo agrega a la lista de subprocesos que esperan &lt;code&gt;*this&lt;/code&gt; . El hilo se desbloquear&amp;aacute; cuando se &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; , o cuando expire el tiempo de espera relativo &lt;code&gt;rel_time&lt;/code&gt; . Tambi&amp;eacute;n puede ser desbloqueado espuriosamente. Cuando se desbloquea, independientemente de la raz&amp;oacute;n, se recupera el &lt;code&gt;lock&lt;/code&gt; y se &lt;code&gt;wait_for()&lt;/code&gt; . Si esta funci&amp;oacute;n sale por excepci&amp;oacute;n, tambi&amp;eacute;n se vuelve a adquirir el &lt;code&gt;lock&lt;/code&gt; . (Hasta C ++ 14)</target>
        </trans-unit>
        <trans-unit id="2fda25784c4cf15cdc68975c9a93b19127874b2f" translate="yes" xml:space="preserve">
          <source>1) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; and returns the value &lt;code&gt;obj&lt;/code&gt; held previously, as if by &lt;code&gt;obj-&amp;gt;exchange(desr)&lt;/code&gt;</source>
          <target state="translated">1) Reemplaza at&amp;oacute;micamente el valor apuntado por &lt;code&gt;obj&lt;/code&gt; con el valor de &lt;code&gt;desr&lt;/code&gt; y devuelve el valor &lt;code&gt;obj&lt;/code&gt; mantenido anteriormente, como si &lt;code&gt;obj-&amp;gt;exchange(desr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5a87743df627f94e6483569a8db0b5f5cafd7d8e" translate="yes" xml:space="preserve">
          <source>1) Atomically replaces the value pointed to by &lt;code&gt;obj&lt;/code&gt; with the value of &lt;code&gt;desr&lt;/code&gt; as if by &lt;code&gt;obj-&amp;gt;store(desr)&lt;/code&gt;</source>
          <target state="translated">1) Reemplaza at&amp;oacute;micamente el valor se&amp;ntilde;alado por &lt;code&gt;obj&lt;/code&gt; con el valor de &lt;code&gt;desr&lt;/code&gt; como si fuera &lt;code&gt;obj-&amp;gt;store(desr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="407470d00a6b62854b98afb591359164b8cb7889" translate="yes" xml:space="preserve">
          <source>1) Atomically unlocks &lt;code&gt;lock&lt;/code&gt;, blocks the current executing thread, and adds it to the list of threads waiting on &lt;code&gt;*this&lt;/code&gt;. The thread will be unblocked when &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; is executed. It may also be unblocked spuriously. When unblocked, regardless of the reason, &lt;code&gt;lock&lt;/code&gt; is reacquired and &lt;code&gt;wait&lt;/code&gt; exits. If this function exits via exception, &lt;code&gt;lock&lt;/code&gt; is also reacquired.(until C++14)</source>
          <target state="translated">1) Desbloquea at&amp;oacute;micamente el &lt;code&gt;lock&lt;/code&gt; , bloquea el subproceso actual en ejecuci&amp;oacute;n y lo agrega a la lista de subprocesos que esperan &lt;code&gt;*this&lt;/code&gt; . El hilo se desbloquear&amp;aacute; cuando se &lt;code&gt;&lt;a href=&quot;notify_all&quot;&gt;notify_all()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;notify_one&quot;&gt;notify_one()&lt;/a&gt;&lt;/code&gt; . Tambi&amp;eacute;n puede ser desbloqueado espuriosamente. Cuando se desbloquea, independientemente de la raz&amp;oacute;n, se recupera el &lt;code&gt;lock&lt;/code&gt; y &lt;code&gt;wait&lt;/code&gt; salir. Si esta funci&amp;oacute;n sale por excepci&amp;oacute;n, tambi&amp;eacute;n se vuelve a adquirir el &lt;code&gt;lock&lt;/code&gt; . (Hasta C ++ 14)</target>
        </trans-unit>
        <trans-unit id="84cf693490eeb5e15a9f6ac3f4c02c6a3441ac7b" translate="yes" xml:space="preserve">
          <source>1) Attempts to create an object of type, denoted by the &lt;a href=&quot;type-id#Type_naming&quot;&gt;type-id&lt;/a&gt;&lt;code&gt;type&lt;/code&gt;, which may be array type, and may include a &lt;a href=&quot;auto&quot;&gt;placeholder type specifier&lt;/a&gt;(since C++11), or include a class template name whose argument is to be deduced by &lt;a href=&quot;deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;(since C++17).</source>
          <target state="translated">1) Intenta crear un objeto de tipo, denotado por el &lt;a href=&quot;type-id#Type_naming&quot;&gt;tipo de identificaci&amp;oacute;n de &lt;/a&gt; &lt;code&gt;type&lt;/code&gt; , que puede ser de tipo matriz y puede incluir un &lt;a href=&quot;auto&quot;&gt;especificador de tipo de marcador de posici&amp;oacute;n&lt;/a&gt; (desde C ++ 11), o incluir un nombre de plantilla de clase cuyo argumento debe ser deducido por la &lt;a href=&quot;deduction_guide&quot;&gt;deducci&amp;oacute;n de argumento de plantilla de clase&lt;/a&gt; (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="f48a394185752e2c4944c4fec900dc772a3b157b" translate="yes" xml:space="preserve">
          <source>1) Attempts to establish the floating-point rounding direction equal to the argument &lt;code&gt;round&lt;/code&gt;, which is expected to be one of the &lt;a href=&quot;fe_round&quot;&gt;floating point rounding macros&lt;/a&gt;.</source>
          <target state="translated">1) Intenta establecer la direcci&amp;oacute;n de redondeo de punto flotante igual a la &lt;code&gt;round&lt;/code&gt; argumento , que se espera que sea una de las &lt;a href=&quot;fe_round&quot;&gt;macros de redondeo de punto flotante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e3a5800b099aa0f75fced4ac6f2262d5f08936e" translate="yes" xml:space="preserve">
          <source>1) Attempts to obtain the full contents of the floating-point exception flags that are listed in the bitmask argument &lt;code&gt;excepts&lt;/code&gt;, which is a bitwise OR of the &lt;a href=&quot;fe_exceptions&quot;&gt;floating point exception macros&lt;/a&gt;.</source>
          <target state="translated">1) Intenta obtener el contenido completo de los indicadores de excepci&amp;oacute;n de punto flotante que se enumeran en las &lt;code&gt;excepts&lt;/code&gt; argumento de m&amp;aacute;scara de bits , que es un OR bit a bit de las &lt;a href=&quot;fe_exceptions&quot;&gt;macros de excepci&amp;oacute;n de punto flotante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="76935444316711f1ef025f07ccf80865f5a71493" translate="yes" xml:space="preserve">
          <source>1) Attempts to store the status of the floating-point environment in the object pointed to by &lt;code&gt;envp&lt;/code&gt;.</source>
          <target state="translated">1) Intenta almacenar el estado del entorno de punto flotante en el objeto al que apunta &lt;code&gt;envp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c537d0344b241074eb3e0571ce11684b3a4576f9" translate="yes" xml:space="preserve">
          <source>1) Average case: constant, worst case: &lt;code&gt;c.size()&lt;/code&gt;</source>
          <target state="translated">1) Caso promedio: constante, peor de los casos: &lt;code&gt;c.size()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9b3845de48d795b10c6d53a55eac9b66f856548" translate="yes" xml:space="preserve">
          <source>1) Behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;, except that &lt;code&gt;input.gcount()&lt;/code&gt; is not affected. After constructing and checking the sentry object, performs the following:</source>
          <target state="translated">1) Se comporta como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; , excepto que &lt;code&gt;input.gcount()&lt;/code&gt; no se ve afectado. Despu&amp;eacute;s de construir y verificar el objeto centinela, realiza lo siguiente:</target>
        </trans-unit>
        <trans-unit id="6af5c4964210e22b364a62aef34f203069bc01d3" translate="yes" xml:space="preserve">
          <source>1) Behaves as a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, determines the output format padding as follows:</source>
          <target state="translated">1) Se comporta como una funci&amp;oacute;n de &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;salida formateada&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, determina el relleno del formato de salida de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="abde054c511c98ef59ea6a6219a0d40067429c5f" translate="yes" xml:space="preserve">
          <source>1) Behaves as an &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, which may skip leading whitespace, extracts a character and stores it to &lt;code&gt;ch&lt;/code&gt;. If no character is available, sets &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; (in addition to &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;eofbit&lt;/code&gt;&lt;/a&gt; that is set as required of a &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;FormattedInputFunction&lt;/a&gt;).</source>
          <target state="translated">1) Se comporta como una funci&amp;oacute;n de entrada &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;formateada&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, que puede omitir los espacios en blanco iniciales, extrae un car&amp;aacute;cter y lo almacena en &lt;code&gt;ch&lt;/code&gt; . Si no hay ning&amp;uacute;n car&amp;aacute;cter disponible, establece el &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;failbit&lt;/code&gt; &lt;/a&gt; (adem&amp;aacute;s del &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;eofbit&lt;/code&gt; &lt;/a&gt; que se establece como se requiere de una funci&amp;oacute;n de entrada &lt;a href=&quot;../../named_req/formattedinputfunction&quot;&gt;formateada&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="66cf5e2bc278327aafd28d7df89e620a0de46000" translate="yes" xml:space="preserve">
          <source>1) Behaves as an &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt;. After constructing and checking the sentry object, inserts the character &lt;code&gt;ch&lt;/code&gt;. If the type of the character is not &lt;code&gt;CharT&lt;/code&gt;, it is first converted with &lt;code&gt;os.widen(ch)&lt;/code&gt;. Padding is determined as follows: if &lt;code&gt;os.width()&amp;gt;1&lt;/code&gt;, then &lt;code&gt;os.width()-1&lt;/code&gt; copies of &lt;code&gt;os.fill()&lt;/code&gt; are added to the output character to form the output character sequence. If &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt;, the fill characters are placed after the output character, otherwise before. After insertion, &lt;code&gt;os.width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.</source>
          <target state="translated">1) Se comporta como una funci&amp;oacute;n de &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;salida formateada&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, inserta el car&amp;aacute;cter &lt;code&gt;ch&lt;/code&gt; . Si el tipo de personaje no es &lt;code&gt;CharT&lt;/code&gt; , primero se convierte con &lt;code&gt;os.widen(ch)&lt;/code&gt; . El relleno se determina de la siguiente manera: si &lt;code&gt;os.width()&amp;gt;1&lt;/code&gt; , entonces &lt;code&gt;os.width()-1&lt;/code&gt; copias de &lt;code&gt;os.fill()&lt;/code&gt; se agregan al car&amp;aacute;cter de salida para formar la secuencia de caracteres de salida. Si &lt;code&gt;(out.flags()&amp;amp;&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::adjustfield&lt;/a&gt;) == &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::left&lt;/a&gt;&lt;/code&gt; , los caracteres de relleno se colocan despu&amp;eacute;s del car&amp;aacute;cter de salida, de lo contrario antes. Despu&amp;eacute;s de la inserci&amp;oacute;n, se llama a &lt;code&gt;os.width(0)&lt;/code&gt; para cancelar los efectos de &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , si hay alguno.</target>
        </trans-unit>
        <trans-unit id="c4d17ec70cbf5d4f592fc6b2f432bf9f5427d7e3" translate="yes" xml:space="preserve">
          <source>1) Behaves as if (2) is called with &lt;code&gt;policy&lt;/code&gt; being &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt; | &lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt;. In other words, &lt;code&gt;f&lt;/code&gt; may be executed in another thread or it may be run synchronously when the resulting &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; is queried for a value.</source>
          <target state="translated">1) se comporta como si (2) se llama con &lt;code&gt;policy&lt;/code&gt; siendo &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt; | &lt;a href=&quot;launch&quot;&gt;std::launch::deferred&lt;/a&gt;&lt;/code&gt; . En otras palabras, &lt;code&gt;f&lt;/code&gt; puede ejecutarse en otro subproceso o puede ejecutarse sincr&amp;oacute;nicamente cuando se consulta el valor de &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; resultante .</target>
        </trans-unit>
        <trans-unit id="1561ba4be61858948b7fed01763fdb3a6eb95b15" translate="yes" xml:space="preserve">
          <source>1) Behaves as if defined as follows:</source>
          <target state="translated">1)Se comporta como si se definiera de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="8175e77df8cae0e91832bcbf197a16dc79ef925d" translate="yes" xml:space="preserve">
          <source>1) Behaves in implementation-defined manner</source>
          <target state="translated">1)Se comporta de manera definida en la aplicación</target>
        </trans-unit>
        <trans-unit id="9b4755491e2aea36644386cd6d0dbcbbe4600c5a" translate="yes" xml:space="preserve">
          <source>1) Binds the first argument of &lt;code&gt;f&lt;/code&gt; to &lt;code&gt;x&lt;/code&gt;. Effectively calls &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder1st&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::first_argument_type(x))&lt;/code&gt;.</source>
          <target state="translated">1) Vincula el primer argumento de &lt;code&gt;f&lt;/code&gt; con &lt;code&gt;x&lt;/code&gt; . Llama efectivamente a &lt;code&gt;&lt;a href=&quot;binder12&quot;&gt;std::binder1st&lt;/a&gt;&amp;lt;F&amp;gt;(f, typename F::first_argument_type(x))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="984a8150c7ac39a66022118522276911d7cc5f49" translate="yes" xml:space="preserve">
          <source>1) Binds the first parameter to the value &lt;code&gt;value&lt;/code&gt; given at the construction of the object.</source>
          <target state="translated">1) Vincula el primer par&amp;aacute;metro al valor del &lt;code&gt;value&lt;/code&gt; dado en la construcci&amp;oacute;n del objeto.</target>
        </trans-unit>
        <trans-unit id="64831980f81dae6254ff1d82d0c72182c81bbba9" translate="yes" xml:space="preserve">
          <source>1) Both ranges must be sorted with &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">1) Ambos rangos deben ordenarse con el &lt;code&gt;operator&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e7001be6592e516d5b51c004a74838c40e04025" translate="yes" xml:space="preserve">
          <source>1) Called by &lt;a href=&quot;../../language/delete&quot;&gt;delete-expressions&lt;/a&gt; to deallocate storage previously allocated for a single object. The behavior of the standard library implementation of this function is undefined unless &lt;code&gt;ptr&lt;/code&gt; is a null pointer or is a pointer previously obtained from the standard library implementation of &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) Llamado por &lt;a href=&quot;../../language/delete&quot;&gt;delete-expressions&lt;/a&gt; para desasignar el almacenamiento previamente asignado para un solo objeto. El comportamiento de la implementaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar de esta funci&amp;oacute;n no est&amp;aacute; definido a menos que &lt;code&gt;ptr&lt;/code&gt; sea ​​un puntero nulo o sea un puntero obtenido previamente de la implementaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar del &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t)&lt;/code&gt; u &lt;code&gt;&lt;a href=&quot;operator_new&quot;&gt;operator new&lt;/a&gt;(size_t, &lt;a href=&quot;nothrow_t&quot;&gt;std::nothrow_t&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b29fa0fabda5d69f4442be6c5fdef616a24dd581" translate="yes" xml:space="preserve">
          <source>1) Called by non-array &lt;a href=&quot;../../language/new&quot;&gt;new-expressions&lt;/a&gt; to allocate storage required for a single object. The standard library implementation allocates &lt;code&gt;count&lt;/code&gt; bytes from free store. In case of failure, the standard library implementation calls the function pointer returned by &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; and repeats allocation attempts until new handler does not return or becomes a null pointer, at which time it throws &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;. This function is required to return a pointer suitably aligned to hold an object of any fundamental alignment.</source>
          <target state="translated">1) Llamado por &lt;a href=&quot;../../language/new&quot;&gt;nuevas expresiones&lt;/a&gt; sin matriz para asignar el almacenamiento requerido para un solo objeto. La implementaci&amp;oacute;n est&amp;aacute;ndar de la biblioteca asigna bytes de &lt;code&gt;count&lt;/code&gt; de la tienda libre. En caso de falla, la implementaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar llama al puntero de funci&amp;oacute;n devuelto por &lt;code&gt;&lt;a href=&quot;get_new_handler&quot;&gt;std::get_new_handler&lt;/a&gt;&lt;/code&gt; y repite los intentos de asignaci&amp;oacute;n hasta que el nuevo controlador no regrese o se convierta en un puntero nulo, momento en el cual arroja &lt;code&gt;&lt;a href=&quot;bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; . Esta funci&amp;oacute;n es necesaria para devolver un puntero adecuadamente alineado para contener un objeto de cualquier alineaci&amp;oacute;n fundamental.</target>
        </trans-unit>
        <trans-unit id="1201c06b6c4799b1fe55caec61e97450a74c02c7" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;((T*)p)-&amp;gt;~T()&lt;/code&gt;</source>
          <target state="translated">1) Llamadas &lt;code&gt;((T*)p)-&amp;gt;~T()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="60cf179e7f48d67030a9b02c5b10f02cbd88fc74" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n)&lt;/code&gt;</source>
          <target state="translated">1) Llamadas &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;OuterAlloc&amp;gt;::allocate(outer_allocator(), n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75d0c1937c63022053420ca73afdc6c6c3f42d8d" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;a.allocate(n)&lt;/code&gt;</source>
          <target state="translated">1) Llamadas &lt;code&gt;a.allocate(n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="612ce7599a47183d9e5a7f878c33edddf6b15c5f" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;delete&lt;/code&gt; (primary template) or &lt;code&gt;delete[]&lt;/code&gt; (array specialization) on &lt;code&gt;ptr&lt;/code&gt;2) Defined as deleted</source>
          <target state="translated">1) Llamadas &lt;code&gt;delete&lt;/code&gt; (plantilla principal) o &lt;code&gt;delete[]&lt;/code&gt; (especializaci&amp;oacute;n de matriz) en &lt;code&gt;ptr&lt;/code&gt; 2) Definido como eliminado</target>
        </trans-unit>
        <trans-unit id="f9949dd29b950802c3d58375f6e80bddb5aa08d9" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;delete&lt;/code&gt; on &lt;code&gt;ptr&lt;/code&gt;2) Calls &lt;code&gt;delete[]&lt;/code&gt; on &lt;code&gt;ptr&lt;/code&gt;. This function will only participate in overload resolution if &lt;code&gt;U(*)[]&lt;/code&gt; is implicitly convertible to &lt;code&gt;T(*)[]&lt;/code&gt;.</source>
          <target state="translated">1) &lt;code&gt;delete&lt;/code&gt; llamadas en &lt;code&gt;ptr&lt;/code&gt; 2) &lt;code&gt;delete[]&lt;/code&gt; llamadas [] en &lt;code&gt;ptr&lt;/code&gt; . Esta funci&amp;oacute;n solo participar&amp;aacute; en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;U(*)[]&lt;/code&gt; es impl&amp;iacute;citamente convertible a &lt;code&gt;T(*)[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18edfbb5ff4b58d729699ca4db1ff32af0d3018f" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;new((void *)p) T(val)&lt;/code&gt;</source>
          <target state="translated">1) Llamadas &lt;code&gt;new((void *)p) T(val)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d55a7910f52d41d1727553c431ed7d3dd8fbe500" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Llama a la &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="1275e8a0c91e8f2137761ada491aefdcab7cbfe3" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;seekpos(pos, which)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Llama a &lt;code&gt;seekpos(pos, which)&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="2ce04d40fb13795e660c624012ebc10673555aff" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;setbuf(s, n)&lt;/code&gt; of the most derived class</source>
          <target state="translated">1) Llama a &lt;code&gt;setbuf(s, n)&lt;/code&gt; de la clase m&amp;aacute;s derivada</target>
        </trans-unit>
        <trans-unit id="189c8c3b03cc9ff928fbd4420e4f08a2f0060d6d" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;str.erase()&lt;/code&gt;</source>
          <target state="translated">1) Llamadas &lt;code&gt;str.erase()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="968bf3d903f71b89d9f7ec9294f33c57ce120fc1" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;sync()&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Llamadas &lt;code&gt;sync()&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="730f19f3ac0934ef27532bf7c9384f807d2f9aed" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;xsgetn(s, count)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Llama a &lt;code&gt;xsgetn(s, count)&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="ec64be5663b85a72b50b7ff9f40df45f3c1977e7" translate="yes" xml:space="preserve">
          <source>1) Calls &lt;code&gt;xsputn(s, count)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Llama a &lt;code&gt;xsputn(s, count)&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="168b614f9f40ac5f9718c1bbf48c0be54f15eee3" translate="yes" xml:space="preserve">
          <source>1) Calls every callback registered by &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; passing &lt;a href=&quot;../ios_base/event&quot;&gt;&lt;code&gt;erase_event&lt;/code&gt;&lt;/a&gt; as parameter</source>
          <target state="translated">1) Llama a cada devoluci&amp;oacute;n de llamada registrada por &lt;code&gt;&lt;a href=&quot;../ios_base/register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; pasando &lt;a href=&quot;../ios_base/event&quot;&gt; &lt;code&gt;erase_event&lt;/code&gt; &lt;/a&gt; como par&amp;aacute;metro</target>
        </trans-unit>
        <trans-unit id="9815ff59a707fc80fc245c084207918bbda81cd8" translate="yes" xml:space="preserve">
          <source>1) Catch-clause that declares a named formal parameter</source>
          <target state="translated">1)Cláusula de captura que declara un parámetro formal nombrado</target>
        </trans-unit>
        <trans-unit id="a2e6973b14cedb89a76d6c2303ae23c129573389" translate="yes" xml:space="preserve">
          <source>1) Changes the current preprocessor line number to lineno. Expansions of the macro &lt;code&gt;__LINE__&lt;/code&gt; beyond this point will expand to lineno plus the number of actual source code lines encountered since.</source>
          <target state="translated">1) Cambia el n&amp;uacute;mero de l&amp;iacute;nea actual del preprocesador a lineno. Las expansiones de la macro &lt;code&gt;__LINE__&lt;/code&gt; m&amp;aacute;s all&amp;aacute; de este punto se expandir&amp;aacute;n a lineno m&amp;aacute;s el n&amp;uacute;mero de l&amp;iacute;neas de c&amp;oacute;digo fuente reales encontradas desde entonces.</target>
        </trans-unit>
        <trans-unit id="251ac3216df00c46dba0c1fcacce145761ea51d6" translate="yes" xml:space="preserve">
          <source>1) Character width: unset, narrow or wide</source>
          <target state="translated">1)Anchura de los caracteres:no se ha fijado,es estrecho o ancho</target>
        </trans-unit>
        <trans-unit id="528a3c47bcb0f4bda9d76624cab85acce69f7c8b" translate="yes" xml:space="preserve">
          <source>1) Checks if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1) Comprueba si &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; son iguales.</target>
        </trans-unit>
        <trans-unit id="653944661bbab0d4335db30edc3fcd7d09dead4d" translate="yes" xml:space="preserve">
          <source>1) Checks if all bits are set to &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1) Comprueba si todos los bits est&amp;aacute;n establecidos en &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c372d3881ed1d3880dc2bcd3c0763ed5a3e843a" translate="yes" xml:space="preserve">
          <source>1) Checks if the character &lt;code&gt;c&lt;/code&gt; is classified by the mask &lt;code&gt;m&lt;/code&gt; according to the classification table returned by the member function &lt;code&gt;table()&lt;/code&gt;. Effectively calculates &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt;</source>
          <target state="translated">1) Comprueba si el car&amp;aacute;cter &lt;code&gt;c&lt;/code&gt; est&amp;aacute; clasificado por la m&amp;aacute;scara &lt;code&gt;m&lt;/code&gt; de acuerdo con la tabla de clasificaci&amp;oacute;n devuelta por la &lt;code&gt;table()&lt;/code&gt; funciones miembro () . Calcula efectivamente la &lt;code&gt;table()[(unsigned char)c] &amp;amp; m&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="055fc3ccc188ca6bb065e219ee940c38e7022dff" translate="yes" xml:space="preserve">
          <source>1) Checks if there is an element with key equivalent to &lt;code&gt;key&lt;/code&gt; in the container.</source>
          <target state="translated">1) Comprueba si hay un elemento con clave equivalente a &lt;code&gt;key&lt;/code&gt; en el contenedor.</target>
        </trans-unit>
        <trans-unit id="01ce0d85d642a69a60a7bd7021acaa1e1acddc49" translate="yes" xml:space="preserve">
          <source>1) Checks if unary predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements in the range &lt;code&gt;[first, last)&lt;/code&gt;.</source>
          <target state="translated">1) Comprueba si el predicado unario &lt;code&gt;p&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; para todos los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="807fd23a250c000cd2d3ce89e2e7e20500a459ae" translate="yes" xml:space="preserve">
          <source>1) Checks if unary predicate &lt;code&gt;pred&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; for all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; (after projecting with the projection &lt;code&gt;proj&lt;/code&gt;).</source>
          <target state="translated">1) Comprueba si predicado unario &lt;code&gt;pred&lt;/code&gt; retornos &lt;code&gt;true&lt;/code&gt; para todos los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; (despu&amp;eacute;s de la proyecci&amp;oacute;n con la proyecci&amp;oacute;n &lt;code&gt;proj&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af5a0d7b95029857fc67f9aec30edea70c5bdbe5" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;a href=&quot;root_path&quot;&gt;&lt;code&gt;root_path()&lt;/code&gt;&lt;/a&gt; is empty.</source>
          <target state="translated">1) Comprueba si &lt;a href=&quot;root_path&quot;&gt; &lt;code&gt;root_path()&lt;/code&gt; &lt;/a&gt; est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="faa74b887ee96c25a3492d6735e13770ce680b0e" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; refer to the same object.</source>
          <target state="translated">1) Comprueba si &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; se refieren al mismo objeto.</target>
        </trans-unit>
        <trans-unit id="2dba4b22cc7fa19bfacb9c9df88e70c92a237039" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1) Comprueba si &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; son iguales.</target>
        </trans-unit>
        <trans-unit id="e8185a1925a4fbfb166981361f79075e2ee33f60" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal. Equivalent to &lt;code&gt;!(lhs &amp;lt; rhs) &amp;amp;&amp;amp; !(rhs &amp;lt; lhs)&lt;/code&gt;.</source>
          <target state="translated">1) Comprueba si &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; son iguales. Equivalente a &lt;code&gt;!(lhs &amp;lt; rhs) &amp;amp;&amp;amp; !(rhs &amp;lt; lhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0fcbd95aabb4ff5227cf670c7cd313a716db3f1b" translate="yes" xml:space="preserve">
          <source>1) Checks whether &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">1) Comprueba si &lt;code&gt;lhs&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="025b85874b3e1d46d1eddf5eb17f542191097060" translate="yes" xml:space="preserve">
          <source>1) Compares &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; for equality.</source>
          <target state="translated">1) Compara &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; por la igualdad.</target>
        </trans-unit>
        <trans-unit id="ba27d1cf06b36c7b4c27679328ea9f73d35759e5" translate="yes" xml:space="preserve">
          <source>1) Compares &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; for equality.</source>
          <target state="translated">1) Compara &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; para la igualdad.</target>
        </trans-unit>
        <trans-unit id="379cb0f357c5f6804b447714bf22e588013d0adb" translate="yes" xml:space="preserve">
          <source>1) Compares this string to</source>
          <target state="translated">1)Compara esta cuerda con</target>
        </trans-unit>
        <trans-unit id="95bc5c17aaacd83f1d13fbd093132d7300e74abf" translate="yes" xml:space="preserve">
          <source>1) Compares two &lt;code&gt;sub_match&lt;/code&gt; directly by comparing their underlying character sequences. Equivalent to &lt;code&gt;str().compare(m.str())&lt;/code&gt;.</source>
          <target state="translated">1) Compara dos &lt;code&gt;sub_match&lt;/code&gt; directamente comparando sus secuencias de caracteres subyacentes. Equivalente a &lt;code&gt;str().compare(m.str())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="babefe1ac4774ec2ba6d2f9315221ca39913970c" translate="yes" xml:space="preserve">
          <source>1) Compares two distribution objects for equality.</source>
          <target state="translated">1)Compara dos objetos de distribución para la igualdad.</target>
        </trans-unit>
        <trans-unit id="35a9eb1fa11c8a233e6c0a2c9a6bd06330c5cb30" translate="yes" xml:space="preserve">
          <source>1) Computes the</source>
          <target state="translated">1)Calcula el</target>
        </trans-unit>
        <trans-unit id="29e45200813ec27005f84e8b35b75cfdc6f3c406" translate="yes" xml:space="preserve">
          <source>1) Computes the (physicist's) &lt;a href=&quot;https://en.wikipedia.org/wiki/Hermite_polynomials&quot;&gt;Hermite polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Calcula los &lt;a href=&quot;https://en.wikipedia.org/wiki/Hermite_polynomials&quot;&gt;polinomios&lt;/a&gt; de Hermite (del f&amp;iacute;sico) del grado &lt;code&gt;n&lt;/code&gt; y argumento &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cd529178d75829687d759cf3575835519db392b" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Associated_Legendre_polynomials&quot;&gt;associated Legendre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Calcula los &lt;a href=&quot;https://en.wikipedia.org/wiki/Associated_Legendre_polynomials&quot;&gt;polinomios Legendre asociados&lt;/a&gt; del grado &lt;code&gt;n&lt;/code&gt; , orden &lt;code&gt;m&lt;/code&gt; y argumento &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="11b6095d1bbc46a80dd8c941788ea2de6b4c76aa" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1&quot;&gt;cylindrical Bessel function of the first kind&lt;/a&gt; of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_first_kind:_J.CE.B1&quot;&gt;funci&amp;oacute;n cil&amp;iacute;ndrica de Bessel del primer tipo&lt;/a&gt; de &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a1bb2811a36108b87f462b1c39d364fc3d72dc" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_second_kind:_Y.CE.B1&quot;&gt;cylindrical Neumann function&lt;/a&gt; (also known as Bessel function of the second kind or Weber function) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Bessel_functions_of_the_second_kind:_Y.CE.B1&quot;&gt;funci&amp;oacute;n cil&amp;iacute;ndrica de Neumann&lt;/a&gt; (tambi&amp;eacute;n conocida como funci&amp;oacute;n Bessel del segundo tipo o funci&amp;oacute;n Weber) de &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c4124d09b398c54819810bb7083904eeb5106df" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;irregular modified cylindrical Bessel function&lt;/a&gt; (also known as modified Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;funci&amp;oacute;n de Bessel cil&amp;iacute;ndrica modificada irregular&lt;/a&gt; (tambi&amp;eacute;n conocida como funci&amp;oacute;n de Bessel modificada del segundo tipo) de &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccf9684995d2a46db4ec7d7201afb8deb62574e0" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;regular modified cylindrical Bessel function&lt;/a&gt; of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Modified_Bessel_functions:_I.CE.B1_.2C_K.CE.B1&quot;&gt;funci&amp;oacute;n&lt;/a&gt; de Bessel cil&amp;iacute;ndrica modificada regular de &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61a6248b455016d83fb9f4ae46600e92647e97f9" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;spherical Bessel function of the first kind&lt;/a&gt; of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;funci&amp;oacute;n esf&amp;eacute;rica de Bessel del primer tipo&lt;/a&gt; de &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58bd3e8ee95098c0c96f4de4b3b5b3f2da549f3f" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;spherical Bessel function of the second kind&lt;/a&gt;, also known as the spherical Neumann function, of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Bessel_function#Spherical_Bessel_functions:_jn.2C_yn&quot;&gt;funci&amp;oacute;n esf&amp;eacute;rica de Bessel del segundo tipo&lt;/a&gt; , tambi&amp;eacute;n conocida como la funci&amp;oacute;n esf&amp;eacute;rica de Neumann, de &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd5509c7dd414eeed186d9c04f5e19a8ae9447d6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function&quot;&gt;beta function&lt;/a&gt; of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Beta_function&quot;&gt;funci&amp;oacute;n beta&lt;/a&gt; de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20e020a9e1ce8ef730c0d0cab5e6865004161b48" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;complex conjugate&lt;/a&gt; of &lt;code&gt;z&lt;/code&gt; by reversing the sign of the imaginary part.</source>
          <target state="translated">1) Calcula el &lt;a href=&quot;https://en.wikipedia.org/wiki/Complex_conjugate&quot;&gt;complejo conjugado&lt;/a&gt; de &lt;code&gt;z&lt;/code&gt; invirtiendo el signo de la parte imaginaria.</target>
        </trans-unit>
        <trans-unit id="bed7cd35295f9a8460aa9f26a5fd423e0f5632e6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_first_kind&quot;&gt;complete elliptic integral of the first kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_first_kind&quot;&gt;integral el&amp;iacute;ptica completa del primer tipo&lt;/a&gt; de &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33b1e6d2c533af4241eec10ee1fc6c7a568c2e97" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_second_kind&quot;&gt;complete elliptic integral of the second kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_second_kind&quot;&gt;integral el&amp;iacute;ptica completa del segundo tipo&lt;/a&gt; de &lt;code&gt;k&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d44887ee66b13404fd46bfb48d18761afabeb530" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_third_kind&quot;&gt;complete elliptic integral of the third kind&lt;/a&gt; of the arguments &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;nu;&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Complete_elliptic_integral_of_the_third_kind&quot;&gt;integral el&amp;iacute;ptica completa del tercer tipo&lt;/a&gt; de argumentos &lt;code&gt;k&lt;/code&gt; y &lt;code&gt;&amp;nu;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34c90fd51c4b11003b3fbb3c42c725019e1184d5" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Elliptic_integral_of_the_first_kind&quot;&gt;incomplete elliptic integral of the first kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Elliptic_integral_of_the_first_kind&quot;&gt;integral el&amp;iacute;ptica incompleta del primer tipo&lt;/a&gt; de &lt;code&gt;k&lt;/code&gt; y &lt;code&gt;&amp;phi;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18c3b8c68fe18231bc4683a4dab18461556c8a6e" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_second_kind&quot;&gt;incomplete elliptic integral of the second kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_second_kind&quot;&gt;integral el&amp;iacute;ptica incompleta del segundo tipo&lt;/a&gt; de &lt;code&gt;k&lt;/code&gt; y &lt;code&gt;&amp;phi;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2a10c9a8d077e7cf3be02757334df49842de441" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_third_kind&quot;&gt;incomplete elliptic integral of the third kind&lt;/a&gt; of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;&amp;nu;&lt;/code&gt;, and &lt;code&gt;&amp;phi;&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Elliptic_integral#Incomplete_elliptic_integral_of_the_third_kind&quot;&gt;integral el&amp;iacute;ptica incompleta del tercer tipo&lt;/a&gt; de &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;&amp;phi;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a057675fa979fcdd978ffe3a864ce85d4f81ad27" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_integral&quot;&gt;exponential integral&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Exponential_integral&quot;&gt;integral exponencial&lt;/a&gt; de &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="194521a0cc3e924de1e24b00830776378f111bf6" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials&quot;&gt;associated Laguerre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Calcula los &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials#Generalized_Laguerre_polynomials&quot;&gt;polinomios&lt;/a&gt; de Laguerre asociados del grado &lt;code&gt;n&lt;/code&gt; , orden &lt;code&gt;m&lt;/code&gt; y argumento &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="447c8a8a3695dfb2c0135ecd809d50a81ac60799" translate="yes" xml:space="preserve">
          <source>1) Computes the &lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_zeta_function&quot;&gt;Riemann zeta function&lt;/a&gt; of &lt;code&gt;arg&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la &lt;a href=&quot;https://en.wikipedia.org/wiki/Riemann_zeta_function&quot;&gt;funci&amp;oacute;n zeta de Riemann&lt;/a&gt; de &lt;code&gt;arg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec4c5063d8c1e5217253c6566900149f02eb3ff3" translate="yes" xml:space="preserve">
          <source>1) Computes the inverse tangent of each pair of corresponding values from &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la tangente inversa de cada par de valores correspondientes de &lt;code&gt;y&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f69a96b516d331be6b80e58bbf178ccead673fa" translate="yes" xml:space="preserve">
          <source>1) Computes the non-associated &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials&quot;&gt;Laguerre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Calcula los &lt;a href=&quot;https://en.wikipedia.org/wiki/Laguerre_polynomials&quot;&gt;polinomios&lt;/a&gt; de Laguerre no asociados del grado &lt;code&gt;n&lt;/code&gt; y argumento &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96823949bd54a22f8ca1311f8a8c38cf707e34c9" translate="yes" xml:space="preserve">
          <source>1) Computes the spherical associated Legendre function of degree &lt;code&gt;l&lt;/code&gt;, order &lt;code&gt;m&lt;/code&gt;, and polar angle &lt;code&gt;&amp;theta;&lt;/code&gt;.</source>
          <target state="translated">1) Calcula la funci&amp;oacute;n de Legendre esf&amp;eacute;rica asociada de grado &lt;code&gt;l&lt;/code&gt; , orden &lt;code&gt;m&lt;/code&gt; y &amp;aacute;ngulo polar &lt;code&gt;&amp;theta;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="494b5451cb229192203200646404e640730476f1" translate="yes" xml:space="preserve">
          <source>1) Computes the unassociated &lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;Legendre polynomials&lt;/a&gt; of the degree &lt;code&gt;n&lt;/code&gt; and argument &lt;code&gt;x&lt;/code&gt;</source>
          <target state="translated">1) Calcula los &lt;a href=&quot;https://en.wikipedia.org/wiki/Legendre_polynomials&quot;&gt;polinomios&lt;/a&gt; de Legendre no asociados del grado &lt;code&gt;n&lt;/code&gt; y argumento &lt;code&gt;x&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="021f4354ef970a1b656513a9b0be260507748eec" translate="yes" xml:space="preserve">
          <source>1) Computes the values of each element in the numeric array &lt;code&gt;base&lt;/code&gt; raised to the power specified by the corresponding element from the numeric array &lt;code&gt;exp&lt;/code&gt;.</source>
          <target state="translated">1) Calcula los valores de cada elemento en la &lt;code&gt;base&lt;/code&gt; de la matriz num&amp;eacute;rica elevada a la potencia especificada por el elemento correspondiente de la matriz num&amp;eacute;rica &lt;code&gt;exp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="58d25c5a734cad90917e4f1983b210515311a450" translate="yes" xml:space="preserve">
          <source>1) Const reference to the value stored in the shared state. Accessing the value through this reference is undefined after the shared state has been destroyed.</source>
          <target state="translated">1)Referencia constante al valor almacenado en el estado compartido.El acceso al valor a través de esta referencia no está definido después de que el estado compartido haya sido destruido.</target>
        </trans-unit>
        <trans-unit id="1fda2d3df21980fc0c991439c0b017a5cbfcceaa" translate="yes" xml:space="preserve">
          <source>1) Constant</source>
          <target state="translated">1)Constante</target>
        </trans-unit>
        <trans-unit id="883376fb1cd5c259eb6c95ea63e4001892914fb5" translate="yes" xml:space="preserve">
          <source>1) Constant.</source>
          <target state="translated">1)Constante.</target>
        </trans-unit>
        <trans-unit id="8348152efcbbea63fdeddd6840b070be4fb7a774" translate="yes" xml:space="preserve">
          <source>1) Constructs &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage starting at &lt;code&gt;first&lt;/code&gt; by &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) Construye &lt;code&gt;n&lt;/code&gt; objetos de tipo &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; en el almacenamiento no inicializado comenzando &lt;code&gt;first&lt;/code&gt; por &lt;a href=&quot;../language/default_initialization&quot;&gt;inicializaci&amp;oacute;n predeterminada&lt;/a&gt; , como si fuera</target>
        </trans-unit>
        <trans-unit id="a76414f38c38467178589672432e927144d5fca1" translate="yes" xml:space="preserve">
          <source>1) Constructs &lt;code&gt;n&lt;/code&gt; objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage starting at &lt;code&gt;first&lt;/code&gt; by &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) Construye &lt;code&gt;n&lt;/code&gt; objetos de tipo &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; en el almacenamiento no inicializado comenzando &lt;code&gt;first&lt;/code&gt; por &lt;a href=&quot;../language/value_initialization&quot;&gt;la inicializaci&amp;oacute;n del valor&lt;/a&gt; , como si por</target>
        </trans-unit>
        <trans-unit id="8cfad2bd0fe265d0360e216522ed743e93e164f6" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;polymorphic_allocator&lt;/code&gt; using the return value of &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; as the underlying memory resource.</source>
          <target state="translated">1) Construye un &lt;code&gt;polymorphic_allocator&lt;/code&gt; utilizando el valor de retorno de &lt;code&gt;&lt;a href=&quot;../get_default_resource&quot;&gt;std::pmr::get_default_resource&lt;/a&gt;()&lt;/code&gt; como recurso de memoria subyacente.</target>
        </trans-unit>
        <trans-unit id="caf585f0b2cbecc991027b2c5d5ade0ff9fa6a44" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;shared_lock&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">1) Construye un &lt;code&gt;shared_lock&lt;/code&gt; sin mutex asociado.</target>
        </trans-unit>
        <trans-unit id="c1691406fb44b80bf86d25e8199ea7826da306af" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::basic_filebuf&lt;/code&gt; object, initializing the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;. The created &lt;code&gt;basic_filebuf&lt;/code&gt; is not associated with a file, and &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) Construye un objeto &lt;code&gt;std::basic_filebuf&lt;/code&gt; , inicializando la clase base llamando al constructor predeterminado de &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; . El &lt;code&gt;basic_filebuf&lt;/code&gt; creado no est&amp;aacute; asociado con un archivo, y &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ed2e91b75fa0fbaf5c3602ace32ee3a481e1def" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::default_delete&lt;/code&gt; object.</source>
          <target state="translated">1) Construye un objeto &lt;code&gt;std::default_delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d62c4ae5cb1598e1b293081929462849a710f111" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::packaged_task&lt;/code&gt; object with no task and no shared state.</source>
          <target state="translated">1) Construye un objeto &lt;code&gt;std::packaged_task&lt;/code&gt; sin tarea y sin estado compartido.</target>
        </trans-unit>
        <trans-unit id="28c93deb18867bda8fc7f9df6c0fa46001aabb5a" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::strstreambuf&lt;/code&gt; object: initializes the base class by calling the default constructor of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt;, initializes the buffer state to &quot;dynamic&quot; (the buffer will be allocated as needed), initializes allocated size to the provided &lt;code&gt;alsize&lt;/code&gt;, initializes the allocation and the deallocation functions to null (will use &lt;code&gt;new[]&lt;/code&gt; and &lt;code&gt;delete[]&lt;/code&gt;)</source>
          <target state="translated">1) Construye un &lt;code&gt;std::strstreambuf&lt;/code&gt; objeto: inicializa la clase base llamando al constructor predeterminado de &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::streambuf&lt;/a&gt;&lt;/code&gt; , inicializa el estado del buffer de &quot;din&amp;aacute;mico&quot; (el tamp&amp;oacute;n se asignar&amp;aacute; seg&amp;uacute;n sea necesario), inicializa asignado tama&amp;ntilde;o a la proporcionada &lt;code&gt;alsize&lt;/code&gt; , inicializa las funciones de asignaci&amp;oacute;n y desasignaci&amp;oacute;n como nulas (usar&amp;aacute; &lt;code&gt;new[]&lt;/code&gt; y &lt;code&gt;delete[]&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="64cc8935216e3aea1780a77626ea547c25b59b13" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;std::unique_ptr&lt;/code&gt; that owns nothing. Value-initializes the stored pointer and the stored deleter. Requires that &lt;code&gt;Deleter&lt;/code&gt; is &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and that construction does not throw an exception.</source>
          <target state="translated">1) Construye un &lt;code&gt;std::unique_ptr&lt;/code&gt; que no posee nada. El valor inicializa el puntero almacenado y el borrador almacenado. Requiere que &lt;code&gt;Deleter&lt;/code&gt; sea &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; y que la construcci&amp;oacute;n no arroje una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2d37caf20ed678ee45772f6932c0c59569e653b3" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;unique_lock&lt;/code&gt; with no associated mutex.</source>
          <target state="translated">1) Construye un &lt;code&gt;unique_lock&lt;/code&gt; sin mutex asociado.</target>
        </trans-unit>
        <trans-unit id="b90797f613a746c0c6afab39848b6f01ca99d6fc" translate="yes" xml:space="preserve">
          <source>1) Constructs a &lt;code&gt;weekday_indexed&lt;/code&gt; from &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt;. The result represents the &lt;code&gt;index&lt;/code&gt;-th weekday in some yet-to-be-specified month. If &lt;code&gt;index&lt;/code&gt; is not in the range [1, 5] or if &lt;code&gt;!ok()&lt;/code&gt; the values held in the result is unspecified.</source>
          <target state="translated">1) Construye un &lt;code&gt;weekday_indexed&lt;/code&gt; de la semana indexado de &lt;code&gt;*this&lt;/code&gt; e &lt;code&gt;index&lt;/code&gt; . El resultado representa el &lt;code&gt;index&lt;/code&gt; -th d&amp;iacute;a de la semana en alg&amp;uacute;n mes a&amp;uacute;n por especificar. Si el &lt;code&gt;index&lt;/code&gt; no est&amp;aacute; en el rango [1, 5] o si &lt;code&gt;!ok()&lt;/code&gt; los valores contenidos en el resultado no est&amp;aacute;n especificados.</target>
        </trans-unit>
        <trans-unit id="a877e234ee1a9651490a92e199612268aa6c085f" translate="yes" xml:space="preserve">
          <source>1) Constructs a distribution object with</source>
          <target state="translated">1)Construye un objeto de distribución con</target>
        </trans-unit>
        <trans-unit id="5839abe97e388fd0beeb46fbe0cbbe23df700f9c" translate="yes" xml:space="preserve">
          <source>1) Constructs a distribution object with n = 1, &amp;rho;0 = 1, b0 = 0, and b1 = 1.</source>
          <target state="translated">1) Construye un objeto de distribuci&amp;oacute;n con n = 1, &amp;rho;0 = 1, b0 = 0 y b1 = 1.</target>
        </trans-unit>
        <trans-unit id="5c36468c5ae16e3151bf49dbb6037065bdee5887" translate="yes" xml:space="preserve">
          <source>1) Constructs a non-array type &lt;code&gt;T&lt;/code&gt;. The arguments &lt;code&gt;args&lt;/code&gt; are passed to the constructor of &lt;code&gt;T&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is not an array type. The function is equivalent to:</source>
          <target state="translated">1) Construye un tipo &lt;code&gt;T&lt;/code&gt; sin matriz . Los argumentos &lt;code&gt;args&lt;/code&gt; se pasan al constructor de la &lt;code&gt;T&lt;/code&gt; . Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;T&lt;/code&gt; no es un tipo de matriz. La funci&amp;oacute;n es equivalente a:</target>
        </trans-unit>
        <trans-unit id="b5bbbb231a62824534ca087741ebf1ecc513e1ae" translate="yes" xml:space="preserve">
          <source>1) Constructs a value at the location the iterator points to from &lt;code&gt;el&lt;/code&gt;.</source>
          <target state="translated">1) Construye un valor en la ubicaci&amp;oacute;n a la que apunta el iterador desde &lt;code&gt;el&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1e6b4ba149ed3478a1436d89169e5bb7c611e15" translate="yes" xml:space="preserve">
          <source>1) Constructs an &lt;code&gt;atomic_ref&lt;/code&gt; object referencing the object &lt;code&gt;obj&lt;/code&gt;. The behavior is undefined if &lt;code&gt;obj&lt;/code&gt; is not aligned to &lt;a href=&quot;required_alignment&quot;&gt;&lt;code&gt;required_alignment&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1) Construye un objeto &lt;code&gt;atomic_ref&lt;/code&gt; que hace referencia al objeto &lt;code&gt;obj&lt;/code&gt; . El comportamiento no est&amp;aacute; definido si &lt;code&gt;obj&lt;/code&gt; no est&amp;aacute; alineado con &lt;a href=&quot;required_alignment&quot;&gt; &lt;code&gt;required_alignment&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3f46d867616b349884c0eaec36a04a2b5e2f106e" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty container.</source>
          <target state="translated">1)Construye un contenedor vacío.</target>
        </trans-unit>
        <trans-unit id="bb6630efd81f0800437bcdd0637108688772c997" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty object.</source>
          <target state="translated">1)Construye un objeto vacío.</target>
        </trans-unit>
        <trans-unit id="4aba85a0be5aa34c1a435f0e6a4e3db1b5c1bb67" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty path.</source>
          <target state="translated">1)Construye un camino vacío.</target>
        </trans-unit>
        <trans-unit id="92b1b20a2cb45b6fe0dfa5cf07ed62cbeefa5879" translate="yes" xml:space="preserve">
          <source>1) Constructs an empty span whose &lt;code&gt;data() == nullptr&lt;/code&gt; and &lt;code&gt;size() == 0&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;extent == 0 || extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Construye un espacio vac&amp;iacute;o cuyos &lt;code&gt;data() == nullptr&lt;/code&gt; y &lt;code&gt;size() == 0&lt;/code&gt; . Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si la &lt;code&gt;extent == 0 || extent == &lt;a href=&quot;dynamic_extent&quot;&gt;std::dynamic_extent&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c2ed7e86ad1634668a4421e8843d4216d314452" translate="yes" xml:space="preserve">
          <source>1) Constructs an end-of-stream iterator.</source>
          <target state="translated">1)Construye un iterador de fin de carrera.</target>
        </trans-unit>
        <trans-unit id="6a91b7a4528438ec1c732b76f2082be352aaa60b" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;T&lt;/code&gt; and wraps it in a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt; as the parameter list for the constructor of &lt;code&gt;T&lt;/code&gt;. The object is constructed as if by the expression &lt;code&gt;::new (pv) T(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;, where &lt;code&gt;pv&lt;/code&gt; is an internal &lt;code&gt;void*&lt;/code&gt; pointer to storage suitable to hold an object of type &lt;code&gt;T&lt;/code&gt;. The storage is typically larger than &lt;code&gt;sizeof(T)&lt;/code&gt; in order to use one allocation for both the control block of the shared pointer and the &lt;code&gt;T&lt;/code&gt; object. The &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor called by this function enables &lt;code&gt;shared_from_this&lt;/code&gt; with a pointer to the newly constructed object of type &lt;code&gt;T&lt;/code&gt;. This overload only participates in overload resolution if T is not an array type</source>
          <target state="translated">1) Construye un objeto de tipo &lt;code&gt;T&lt;/code&gt; y lo envuelve en un &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; usando &lt;code&gt;args&lt;/code&gt; como la lista de par&amp;aacute;metros para el constructor de &lt;code&gt;T&lt;/code&gt; . El objeto se construye como si fuera por la expresi&amp;oacute;n &lt;code&gt;::new (pv) T(&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; , donde &lt;code&gt;pv&lt;/code&gt; es un puntero &lt;code&gt;void*&lt;/code&gt; interno al almacenamiento adecuado para contener un objeto de tipo &lt;code&gt;T&lt;/code&gt; . El almacenamiento es t&amp;iacute;picamente mayor que &lt;code&gt;sizeof(T)&lt;/code&gt; para usar una asignaci&amp;oacute;n tanto para el bloque de control del puntero compartido como para el objeto &lt;code&gt;T&lt;/code&gt; . El constructor &lt;code&gt;std::shared_ptr&lt;/code&gt; llamado por esta funci&amp;oacute;n habilita &lt;code&gt;shared_from_this&lt;/code&gt; con un puntero al objeto de nueva construcci&amp;oacute;n de tipo &lt;code&gt;T&lt;/code&gt; . Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si T no es un tipo de matriz</target>
        </trans-unit>
        <trans-unit id="c65fce56c4a3fe00bfc3974bed79655a9cad1369" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;T&lt;/code&gt; and wraps it in a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; using &lt;code&gt;args&lt;/code&gt; as the parameter list for the constructor of &lt;code&gt;T&lt;/code&gt;. The object is constructed as if by the expression &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a, pv, v)&lt;/code&gt;, where &lt;code&gt;pv&lt;/code&gt; is an internal &lt;code&gt;void*&lt;/code&gt; pointer to storage suitable to hold an object of type &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;a&lt;/code&gt; is a copy of the allocator rebound to &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;. The storage is typically larger than &lt;code&gt;sizeof(T)&lt;/code&gt; in order to use one allocation for both the control block of the shared pointer and the &lt;code&gt;T&lt;/code&gt; object. The &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor called by this function enables &lt;code&gt;shared_from_this&lt;/code&gt; with a pointer to the newly constructed object of type &lt;code&gt;T&lt;/code&gt;. All memory allocation is done using a copy of &lt;code&gt;alloc&lt;/code&gt;, which must satisfy the &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; requirements. This overload only participates in overload resolution if T is not an array type</source>
          <target state="translated">1) Construye un objeto de tipo &lt;code&gt;T&lt;/code&gt; y lo envuelve en un &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; usando &lt;code&gt;args&lt;/code&gt; como la lista de par&amp;aacute;metros para el constructor de &lt;code&gt;T&lt;/code&gt; . El objeto se construye como si fuera por la expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;A2&amp;gt;::construct(a, pv, v)&lt;/code&gt; , donde &lt;code&gt;pv&lt;/code&gt; es un puntero interno &lt;code&gt;void*&lt;/code&gt; al almacenamiento adecuado para contener un objeto de tipo &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;a&lt;/code&gt; es una copia del rebote del asignador a &lt;code&gt;&lt;a href=&quot;../../types/remove_cv&quot;&gt;std::remove_cv_t&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; . El almacenamiento suele ser mayor que &lt;code&gt;sizeof(T)&lt;/code&gt; para utilizar una asignaci&amp;oacute;n tanto para el bloque de control del puntero compartido como para el &lt;code&gt;T&lt;/code&gt; objeto. El &lt;code&gt;std::shared_ptr&lt;/code&gt; constructor llamado por esta funci&amp;oacute;n permite &lt;code&gt;shared_from_this&lt;/code&gt; con un puntero al objeto de nueva construcci&amp;oacute;n, de tipo &lt;code&gt;T&lt;/code&gt; . Toda la asignaci&amp;oacute;n de memoria se realiza utilizando una copia de &lt;code&gt;alloc&lt;/code&gt; , que debe cumplir con los requisitos del &lt;a href=&quot;../../named_req/allocator&quot;&gt;asignador&lt;/a&gt; . Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si T no es un tipo de matriz</target>
        </trans-unit>
        <trans-unit id="d78eaa4f8c9d96c9388558353abf67888821bd40" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;std::condition_variable&lt;/code&gt;.</source>
          <target state="translated">1) Construye un objeto de tipo &lt;code&gt;std::condition_variable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c33554f7a405b880b69fcd197b5b45d0faf555d7" translate="yes" xml:space="preserve">
          <source>1) Constructs an object of type &lt;code&gt;std::condition_variable_any&lt;/code&gt;.</source>
          <target state="translated">1) Construye un objeto de tipo &lt;code&gt;std::condition_variable_any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dca4893623f5a9eb91426447332e43a629e5e08" translate="yes" xml:space="preserve">
          <source>1) Constructs an object that</source>
          <target state="translated">1)Construye un objeto que</target>
        </trans-unit>
        <trans-unit id="a42c5463387778d35ce09fb74ca7c06a1d5d3fe5" translate="yes" xml:space="preserve">
          <source>1) Constructs empty container. Sets &lt;code&gt;max_load_factor()&lt;/code&gt; to 1.0. For the default constructor, the number of buckets is implementation-defined.</source>
          <target state="translated">1) Construye contenedor vac&amp;iacute;o. Establece &lt;code&gt;max_load_factor()&lt;/code&gt; en 1.0. Para el constructor predeterminado, el n&amp;uacute;mero de dep&amp;oacute;sitos est&amp;aacute; definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cc74e3008936c370fbc2e91fcb346c72690c77ec" translate="yes" xml:space="preserve">
          <source>1) Constructs error code with default value. Equivalent to &lt;code&gt;error_code(0, &lt;a href=&quot;../system_category&quot;&gt;std::system_category&lt;/a&gt;())&lt;/code&gt;.</source>
          <target state="translated">1) Construye el c&amp;oacute;digo de error con el valor predeterminado. Equivalente a &lt;code&gt;error_code(0, &lt;a href=&quot;../system_category&quot;&gt;std::system_category&lt;/a&gt;())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f925a3f60c069a032e3937c5003b55a8c2dfe979" translate="yes" xml:space="preserve">
          <source>1) Constructs objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage designated by the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;a href=&quot;../language/default_initialization&quot;&gt;default-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) Construye objetos de tipo &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; en el almacenamiento no inicializado designado por el rango &lt;code&gt;[first, last)&lt;/code&gt; por &lt;a href=&quot;../language/default_initialization&quot;&gt;inicializaci&amp;oacute;n predeterminada&lt;/a&gt; , como si fuera</target>
        </trans-unit>
        <trans-unit id="5ca8d62a3455adf4d9e43d7b921708a6d8a9a285" translate="yes" xml:space="preserve">
          <source>1) Constructs objects of type &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; in the uninitialized storage designated by the range &lt;code&gt;[first, last)&lt;/code&gt; by &lt;a href=&quot;../language/value_initialization&quot;&gt;value-initialization&lt;/a&gt;, as if by</source>
          <target state="translated">1) Construye objetos de tipo &lt;code&gt;typename iterator_traits&amp;lt;ForwardIt&amp;gt;::value_type&lt;/code&gt; en el almacenamiento no inicializado designado por el rango &lt;code&gt;[first, last)&lt;/code&gt; por &lt;a href=&quot;../language/value_initialization&quot;&gt;valor-initialization&lt;/a&gt; , como si por</target>
        </trans-unit>
        <trans-unit id="c7e73e079cc70c58b19eccb9290637293ccbae99" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;auto_ptr&lt;/code&gt; with pointer &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">1) Construye el &lt;code&gt;auto_ptr&lt;/code&gt; con el puntero &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0164e8149e0956c863ac9c36b9359f6da1d2d078" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_istream&lt;/code&gt; object, assigning initial values to the base class by calling &lt;code&gt;basic_ios::init(sb)&lt;/code&gt;. The value of &lt;code&gt;gcount()&lt;/code&gt; is initialized to zero.</source>
          <target state="translated">1) Construye el objeto &lt;code&gt;basic_istream&lt;/code&gt; , asignando valores iniciales a la clase base llamando a &lt;code&gt;basic_ios::init(sb)&lt;/code&gt; . El valor de &lt;code&gt;gcount()&lt;/code&gt; se inicializa a cero.</target>
        </trans-unit>
        <trans-unit id="9f59a9d9a66d857f281383b9ee9838b4c7e8b9e9" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_ostream&lt;/code&gt; object, assigning initial values to the base class by calling &lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;basic_ios::init(sb)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Construye el objeto &lt;code&gt;basic_ostream&lt;/code&gt; , asignando valores iniciales a la clase base llamando a &lt;code&gt;&lt;a href=&quot;../basic_ios/init&quot;&gt;basic_ios::init(sb)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e770895769dd6c60169d7f4420f35a940b3c3d4d" translate="yes" xml:space="preserve">
          <source>1) Constructs the &lt;code&gt;basic_streambuf&lt;/code&gt; object, initializes the six pointer members (&lt;code&gt;eback()&lt;/code&gt;, &lt;code&gt;gptr()&lt;/code&gt;, &lt;code&gt;egptr()&lt;/code&gt;, &lt;code&gt;pbase()&lt;/code&gt;, &lt;code&gt;pptr()&lt;/code&gt;, and &lt;code&gt;epptr()&lt;/code&gt;) to null pointer values, and the locale member to &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt;, a copy of the global C++ locale at the time of construction.</source>
          <target state="translated">1) Construye el objeto &lt;code&gt;basic_streambuf&lt;/code&gt; , inicializa los seis miembros de puntero ( &lt;code&gt;eback()&lt;/code&gt; , &lt;code&gt;gptr()&lt;/code&gt; , &lt;code&gt;egptr()&lt;/code&gt; , &lt;code&gt;pbase()&lt;/code&gt; , &lt;code&gt;pptr()&lt;/code&gt; y &lt;code&gt;epptr()&lt;/code&gt; ) a valores de puntero nulos, y el miembro de localizaci&amp;oacute;n a &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;()&lt;/code&gt; , una copia de la configuraci&amp;oacute;n regional global de C ++ en el momento de la construcci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5a712e507b705a86029303f1b2e6b91abd34eca3" translate="yes" xml:space="preserve">
          <source>1) Constructs the complex number from real and imaginary parts.</source>
          <target state="translated">1)Construye el número complejo a partir de partes reales e imaginarias.</target>
        </trans-unit>
        <trans-unit id="4d3565cc629e222a14a77967cd93c38e99b2c25e" translate="yes" xml:space="preserve">
          <source>1) Constructs the end iterator.</source>
          <target state="translated">1)Construye el iterador final.</target>
        </trans-unit>
        <trans-unit id="36c43a3b623f36dd562263833f62942dcde59be1" translate="yes" xml:space="preserve">
          <source>1) Constructs the end-of-stream iterator, value-initializes the stored value. This constructor is constexpr if the initializer in the definition &lt;code&gt;auto x = T();&lt;/code&gt; is a constant initializer.</source>
          <target state="translated">1) Construye el iterador de fin de flujo, el valor inicializa el valor almacenado. Este constructor es constexpr si el inicializador en la definici&amp;oacute;n &lt;code&gt;auto x = T();&lt;/code&gt; Es un inicializador constante.</target>
        </trans-unit>
        <trans-unit id="567317c97bb9e808725c51c31daff371c53a7183" translate="yes" xml:space="preserve">
          <source>1) Constructs the iterator with &lt;code&gt;stream&lt;/code&gt; as the associated stream and &lt;code&gt;delim&lt;/code&gt; as the delimiter.</source>
          <target state="translated">1) Construye el iterador con &lt;code&gt;stream&lt;/code&gt; como flujo asociado y &lt;code&gt;delim&lt;/code&gt; itado como delimitador.</target>
        </trans-unit>
        <trans-unit id="21e8282094e94dff47b05cfa55b86fa929f80bfb" translate="yes" xml:space="preserve">
          <source>1) Constructs the iterator with the private &lt;code&gt;streambuf_type*&lt;/code&gt; member set to &lt;code&gt;buffer&lt;/code&gt; and the failed() bit set to &lt;code&gt;false&lt;/code&gt;. The behavior is undefined if &lt;code&gt;buffer&lt;/code&gt; is a null pointer.</source>
          <target state="translated">1) Construye el iterador con el miembro privado &lt;code&gt;streambuf_type*&lt;/code&gt; establecido en &lt;code&gt;buffer&lt;/code&gt; y el bit fallido () establecido en &lt;code&gt;false&lt;/code&gt; . El comportamiento no est&amp;aacute; definido si el &lt;code&gt;buffer&lt;/code&gt; es un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="c0e385bee1b61c9f84d4023fcbdea59f912b0207" translate="yes" xml:space="preserve">
          <source>1) Constructs the mutex. The mutex is in unlocked state after the call.</source>
          <target state="translated">1)Construye el mutex.El mutex está en estado desbloqueado después de la llamada.</target>
        </trans-unit>
        <trans-unit id="6facaef49db759622faeb9fa50ba66a91993a2b8" translate="yes" xml:space="preserve">
          <source>1) Constructs the mutex. The mutex is in unlocked state after the constructor completes.</source>
          <target state="translated">1)Construye el mutex.El mutex está en estado desbloqueado después de que el constructor lo termine.</target>
        </trans-unit>
        <trans-unit id="29377ade75ac8ee862d1d21eb062d5bb53a5931b" translate="yes" xml:space="preserve">
          <source>1) Constructs with error code &lt;code&gt;ec&lt;/code&gt;</source>
          <target state="translated">1) Construye con el c&amp;oacute;digo de error &lt;code&gt;ec&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0535a299ea56e25c15331c583b9b9f5ad995759c" translate="yes" xml:space="preserve">
          <source>1) Conversion that involves pointer to bool or pointer-to-member to bool is worse than the one that doesn't</source>
          <target state="translated">1)La conversión que involucra puntero a bool o puntero a miembro a bool es peor que la que no lo hace.</target>
        </trans-unit>
        <trans-unit id="e16d54f0bf7a4de50ea66eef76a20a090e2f4413" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;byte&lt;/code&gt; as if it was a string of length &lt;code&gt;1&lt;/code&gt; to wide_string.</source>
          <target state="translated">1) Convierte el &lt;code&gt;byte&lt;/code&gt; como si fuera una cadena de longitud &lt;code&gt;1&lt;/code&gt; en wide_string.</target>
        </trans-unit>
        <trans-unit id="197a10e3da9ede6e2bf81aba04bc89f7b2c98603" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;wchar&lt;/code&gt; as if it was a string of length &lt;code&gt;1&lt;/code&gt;, to &lt;code&gt;byte_string&lt;/code&gt;.</source>
          <target state="translated">1) Convierte &lt;code&gt;wchar&lt;/code&gt; como si fuera una cadena de longitud &lt;code&gt;1&lt;/code&gt; , en &lt;code&gt;byte_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce60559adca1ecbc763b846b0ebcd3ea0bcd2729" translate="yes" xml:space="preserve">
          <source>1) Converts &lt;code&gt;x&lt;/code&gt; to &lt;code&gt;T&amp;amp;&lt;/code&gt; as if by &lt;code&gt;T&amp;amp; t = &lt;a href=&quot;../../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(x);&lt;/code&gt;, then stores a reference to &lt;code&gt;t&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;typename &lt;a href=&quot;../../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;U&amp;gt;::type&lt;/code&gt; is not the same type as &lt;code&gt;reference_wrapper&lt;/code&gt; and the expression &lt;code&gt;FUN(&lt;a href=&quot;../../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; is well-formed, where &lt;code&gt;FUN&lt;/code&gt; names the set of imaginary functions</source>
          <target state="translated">1) Convierte &lt;code&gt;x&lt;/code&gt; a &lt;code&gt;T&amp;amp;&lt;/code&gt; como si por &lt;code&gt;T&amp;amp; t = &lt;a href=&quot;../../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(x);&lt;/code&gt; , luego almacena una referencia a &lt;code&gt;t&lt;/code&gt; . Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;typename &lt;a href=&quot;../../../types/decay&quot;&gt;std::decay&lt;/a&gt;&amp;lt;U&amp;gt;::type&lt;/code&gt; no es el mismo tipo que &lt;code&gt;reference_wrapper&lt;/code&gt; y la expresi&amp;oacute;n &lt;code&gt;FUN(&lt;a href=&quot;../../declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; est&amp;aacute; bien formada, donde &lt;code&gt;FUN&lt;/code&gt; nombra el conjunto de funciones imaginarias</target>
        </trans-unit>
        <trans-unit id="3b2e425231980e3b26025193db6c0158ff8d1aa6" translate="yes" xml:space="preserve">
          <source>1) Converts a signed decimal integer to a string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%d&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">1) Convierte un entero decimal con signo en una cadena con el mismo contenido que lo que producir&amp;iacute;a &lt;code&gt;&lt;a href=&quot;../../io/c/fprintf&quot;&gt;std::sprintf&lt;/a&gt;(buf, &quot;%d&quot;, value)&lt;/code&gt; para un &lt;code&gt;buf&lt;/code&gt; suficientemente grande .</target>
        </trans-unit>
        <trans-unit id="8e981b67a7ad4cb8a3d3ec53bfb06c19e2cd41df" translate="yes" xml:space="preserve">
          <source>1) Converts a signed decimal integer to a wide string with the same content as what &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%d&quot;, value)&lt;/code&gt; would produce for sufficiently large &lt;code&gt;buf&lt;/code&gt;.</source>
          <target state="translated">1) Convierte un entero decimal con signo en una cadena ancha con el mismo contenido que lo que &lt;code&gt;&lt;a href=&quot;../../io/c/fwprintf&quot;&gt;std::swprintf&lt;/a&gt;(buf, sz, L&quot;%d&quot;, value)&lt;/code&gt; para un &lt;code&gt;buf&lt;/code&gt; suficientemente grande .</target>
        </trans-unit>
        <trans-unit id="4dc8e4275413329fa1e66540999bd4062579b6f2" translate="yes" xml:space="preserve">
          <source>1) Converts the &lt;code&gt;file_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;sys_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">1) Convierte el &lt;code&gt;file_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; en un &lt;code&gt;sys_time&lt;/code&gt; que representa el mismo punto en el tiempo.</target>
        </trans-unit>
        <trans-unit id="bbc6867b0f47d015a04ea763b2e464a464fd6f94" translate="yes" xml:space="preserve">
          <source>1) Converts the &lt;code&gt;file_time&lt;/code&gt;&lt;code&gt;t&lt;/code&gt; to a &lt;code&gt;utc_time&lt;/code&gt; representing the same point in time.</source>
          <target state="translated">1) Convierte el &lt;code&gt;file_time&lt;/code&gt; &lt;code&gt;t&lt;/code&gt; en un &lt;code&gt;utc_time&lt;/code&gt; que representa el mismo punto en el tiempo.</target>
        </trans-unit>
        <trans-unit id="076c6e693f308ce0f6a0c89dfaa4b7efdd201143" translate="yes" xml:space="preserve">
          <source>1) Converts the two durations to their common type and creates a duration whose tick count is the sum of the tick counts after conversion.</source>
          <target state="translated">1)Convierte las dos duraciones a su tipo común y crea una duración cuyo recuento de garrapatas es la suma de los recuentos de garrapatas después de la conversión.</target>
        </trans-unit>
        <trans-unit id="888ab527c89c913804d1c2c29b389f2611f52687" translate="yes" xml:space="preserve">
          <source>1) Copies &lt;code&gt;count&lt;/code&gt; elements from a range beginning at &lt;code&gt;first&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) Copias &lt;code&gt;count&lt;/code&gt; elementos de un comienzo de gama en &lt;code&gt;first&lt;/code&gt; a un &amp;aacute;rea de memoria no inicializada a partir de las &lt;code&gt;d_first&lt;/code&gt; como por</target>
        </trans-unit>
        <trans-unit id="a5b971875873e04ebbd8f3dd90705985a75d4ec9" translate="yes" xml:space="preserve">
          <source>1) Copies all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; starting from first and proceeding to last - 1. The behavior is undefined if &lt;code&gt;d_first&lt;/code&gt; is within the range &lt;code&gt;[first, last)&lt;/code&gt;. In this case, &lt;code&gt;&lt;a href=&quot;copy_backward&quot;&gt;std::copy_backward&lt;/a&gt;&lt;/code&gt; may be used instead.</source>
          <target state="translated">1) Copia todos los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; comenzando desde el primero y pasando al &amp;uacute;ltimo - 1. El comportamiento no est&amp;aacute; definido si &lt;code&gt;d_first&lt;/code&gt; est&amp;aacute; dentro del rango &lt;code&gt;[first, last)&lt;/code&gt; . En este caso, &lt;code&gt;&lt;a href=&quot;copy_backward&quot;&gt;std::copy_backward&lt;/a&gt;&lt;/code&gt; puede usarse en su lugar.</target>
        </trans-unit>
        <trans-unit id="06ea4d57b4c85fc6e7bcfe101f3b3fdc533f62f9" translate="yes" xml:space="preserve">
          <source>1) Copies characters in the range &lt;code&gt;[first,last)&lt;/code&gt; to &lt;code&gt;out&lt;/code&gt;, replacing any sequences that match &lt;code&gt;re&lt;/code&gt; with characters formatted by &lt;code&gt;fmt&lt;/code&gt;. In other words:</source>
          <target state="translated">1) copias caracteres en el rango &lt;code&gt;[first,last)&lt;/code&gt; a &lt;code&gt;out&lt;/code&gt; , en sustituci&amp;oacute;n de cualquiera de las secuencias que partido &lt;code&gt;re&lt;/code&gt; con caracteres formateada por &lt;code&gt;fmt&lt;/code&gt; . En otras palabras:</target>
        </trans-unit>
        <trans-unit id="3c0e21f1d72032ced3cf99d25a163352df8fb16d" translate="yes" xml:space="preserve">
          <source>1) Copies elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) Copia elementos del rango &lt;code&gt;[first, last)&lt;/code&gt; a un &amp;aacute;rea de memoria no inicializada que comienza en &lt;code&gt;d_first&lt;/code&gt; como si fuera</target>
        </trans-unit>
        <trans-unit id="eaa8b895fbfe22af946e0d1f21d2e21b2ccbf6f4" translate="yes" xml:space="preserve">
          <source>1) Copies exactly &lt;code&gt;count&lt;/code&gt; values from the range beginning at &lt;code&gt;first&lt;/code&gt; to the range beginning at &lt;code&gt;result&lt;/code&gt;. Formally, for each non-negative integer &lt;code&gt;i &amp;lt; n&lt;/code&gt;, performs &lt;code&gt;*(result + i) = *(first + i)&lt;/code&gt;. Overlap of ranges is not permitted.</source>
          <target state="translated">1) Copia exactamente los valores de &lt;code&gt;count&lt;/code&gt; del rango que comienza en &lt;code&gt;first&lt;/code&gt; al rango que comienza en el &lt;code&gt;result&lt;/code&gt; ado . Formalmente, para cada entero no negativo &lt;code&gt;i &amp;lt; n&lt;/code&gt; , realiza &lt;code&gt;*(result + i) = *(first + i)&lt;/code&gt; . La superposici&amp;oacute;n de rangos no est&amp;aacute; permitida.</target>
        </trans-unit>
        <trans-unit id="2428bbef7516a0c37d09fb2808331b76c9c46ca3" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to another range beginning at &lt;code&gt;d_first&lt;/code&gt; in such a way that the elements in the new range are in reverse order.</source>
          <target state="translated">1) Copia los elementos del rango &lt;code&gt;[first, last)&lt;/code&gt; a otro rango que comienza en &lt;code&gt;d_first&lt;/code&gt; de tal manera que los elementos en el nuevo rango est&amp;eacute;n en orden inverso.</target>
        </trans-unit>
        <trans-unit id="4614ab1a6d2346fd0652f2db85a8f495164eebe2" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to two different ranges depending on the value returned by the predicate &lt;code&gt;p&lt;/code&gt;. The elements that satisfy the predicate &lt;code&gt;p&lt;/code&gt; are copied to the range beginning at &lt;code&gt;d_first_true&lt;/code&gt;. The rest of the elements are copied to the range beginning at &lt;code&gt;d_first_false&lt;/code&gt;.</source>
          <target state="translated">1) Copia los elementos del rango &lt;code&gt;[first, last)&lt;/code&gt; en dos rangos diferentes dependiendo del valor devuelto por el predicado &lt;code&gt;p&lt;/code&gt; . Los elementos que satisfacen el predicado &lt;code&gt;p&lt;/code&gt; se copian en el rango que comienza en &lt;code&gt;d_first_true&lt;/code&gt; . El resto de los elementos se copian en el rango que comienza en &lt;code&gt;d_first_false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98b63d2d9267bc9998d8406ce508196f6fbe30f0" translate="yes" xml:space="preserve">
          <source>1) Copies the elements from the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range beginning at &lt;code&gt;d_first&lt;/code&gt; in such a way, that the element &lt;code&gt;n_first&lt;/code&gt; becomes the first element of the new range and &lt;code&gt;n_first - 1&lt;/code&gt; becomes the last element.</source>
          <target state="translated">1) Copia los elementos del rango &lt;code&gt;[first, last)&lt;/code&gt; , a otro rango que comienza en &lt;code&gt;d_first&lt;/code&gt; de tal manera que el elemento &lt;code&gt;n_first&lt;/code&gt; se convierte en el primer elemento del nuevo rango y &lt;code&gt;n_first - 1&lt;/code&gt; convierte en el &amp;uacute;ltimo elemento.</target>
        </trans-unit>
        <trans-unit id="84fa46dde26717bac9ce3f7378e2314898b8e7d1" translate="yes" xml:space="preserve">
          <source>1) Copies the given &lt;code&gt;value&lt;/code&gt; to an uninitialized memory area, defined by the range &lt;code&gt;[first, last)&lt;/code&gt; as if by</source>
          <target state="translated">1) Copia el &lt;code&gt;value&lt;/code&gt; dado a un &amp;aacute;rea de memoria no inicializada, definida por el rango &lt;code&gt;[first, last)&lt;/code&gt; como si fuera</target>
        </trans-unit>
        <trans-unit id="3b6ae258a56e6dc4788e6367a261c4cc04b85921" translate="yes" xml:space="preserve">
          <source>1) Copies the given value &lt;code&gt;value&lt;/code&gt; to the first &lt;code&gt;count&lt;/code&gt; elements in an uninitialized memory area beginning at &lt;code&gt;first&lt;/code&gt; as if by</source>
          <target state="translated">1) Copia el valor del &lt;code&gt;value&lt;/code&gt; dado a los primeros elementos de &lt;code&gt;count&lt;/code&gt; en un &amp;aacute;rea de memoria no inicializada comenzando al &lt;code&gt;first&lt;/code&gt; como si fuera</target>
        </trans-unit>
        <trans-unit id="09509cf45826977c55e1dec4baf1527dc8caefbb" translate="yes" xml:space="preserve">
          <source>1) Copy assignment is not allowed.</source>
          <target state="translated">1)No se permite la asignación de copias.</target>
        </trans-unit>
        <trans-unit id="3a5410a123be4ffd9084e19a34d5ec5f619c3034" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator is deleted, &lt;code&gt;std::packaged_task&lt;/code&gt; is move-only.</source>
          <target state="translated">1) Se elimina el operador de asignaci&amp;oacute;n de copias, &lt;code&gt;std::packaged_task&lt;/code&gt; es solo de movimiento.</target>
        </trans-unit>
        <trans-unit id="2aca2d494628bc0ffa5751c1c324f784c030e885" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns each element of &lt;code&gt;other&lt;/code&gt; to the corresponding element of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) Operador de asignaci&amp;oacute;n de copia. Asigna cada elemento de &lt;code&gt;other&lt;/code&gt; al elemento correspondiente de &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cc354b87930ded2400ee0d9fd474ddaa0df3e93" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1) Operador de asignaci&amp;oacute;n de copia. Asigna el contenido de &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="192e116d8a3105a5b39d34793a6599ce2a2b2376" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Assigns the contents of &lt;code&gt;other&lt;/code&gt;. Equivalent to &lt;code&gt;assign(other);&lt;/code&gt;.</source>
          <target state="translated">1) Operador de asignaci&amp;oacute;n de copia. Asigna el contenido de &lt;code&gt;other&lt;/code&gt; . Equivalente a &lt;code&gt;assign(other);&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc11fa7946da37481c60d78d0a9d3a526f8a12a0" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Each element of &lt;code&gt;*this&lt;/code&gt; is assigned the value of the corresponding element of &lt;code&gt;other&lt;/code&gt;. If the length of &lt;code&gt;other&lt;/code&gt; does not equal the length of &lt;code&gt;*this&lt;/code&gt;,  the behavior is undefined(until C++11) first resizes as if by &lt;code&gt;resize(other.size())&lt;/code&gt;(since C++11).</source>
          <target state="translated">1) Operador de asignaci&amp;oacute;n de copia. A cada elemento de &lt;code&gt;*this&lt;/code&gt; se le asigna el valor del elemento correspondiente de &lt;code&gt;other&lt;/code&gt; . Si la longitud de &lt;code&gt;other&lt;/code&gt; no es igual a la longitud de &lt;code&gt;*this&lt;/code&gt; , el comportamiento es indefinido (hasta que C ++ 11) primero cambia de tama&amp;ntilde;o como si fuera &lt;code&gt;resize(other.size())&lt;/code&gt; (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="36cd900ec1105ec865ef3f158da0f2320e8c8dbc" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;c = other.c; comp = other.comp;&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">1) Operador de asignaci&amp;oacute;n de copia. Reemplaza los contenidos con una copia de los contenidos de &lt;code&gt;other&lt;/code&gt; . Efectivamente llama a &lt;code&gt;c = other.c; comp = other.comp;&lt;/code&gt; . (declarado impl&amp;iacute;citamente)</target>
        </trans-unit>
        <trans-unit id="a351a0527d89498a7bcb02cb3b6924c0e3fbd9ec" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;. Effectively calls &lt;code&gt;c = other.c;&lt;/code&gt;. (implicitly declared)</source>
          <target state="translated">1) Operador de asignaci&amp;oacute;n de copia. Reemplaza los contenidos con una copia de los contenidos de &lt;code&gt;other&lt;/code&gt; . Efectivamente llama a &lt;code&gt;c = other.c;&lt;/code&gt; . (declarado impl&amp;iacute;citamente)</target>
        </trans-unit>
        <trans-unit id="0ad06eaa3c6a3a682c837daad2aa45d6956113f6" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of &lt;code&gt;other&lt;/code&gt;.If &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the target allocator is replaced by a copy of the source allocator. If the target and the source allocators do not compare equal, the target (&lt;code&gt;*this&lt;/code&gt;) allocator is used to deallocate the memory, then &lt;code&gt;other&lt;/code&gt;'s allocator is used to allocate it before copying the elements.(since C++11).</source>
          <target state="translated">1) Operador de asignaci&amp;oacute;n de copia. Reemplaza el contenido con una copia del contenido de &lt;code&gt;other&lt;/code&gt; .Si &lt;code&gt;&lt;a href=&quot;../../memory/allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&amp;lt;allocator_type&amp;gt;::propagate_on_container_copy_assignment::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el asignador de destino se reemplaza por una copia del asignador de origen. Si el objetivo y los asignadores de origen no se comparan iguales, el objetivo ( &lt;code&gt;*this&lt;/code&gt; ) asignador se utiliza para desasignar la memoria, y luego &lt;code&gt;other&lt;/code&gt; asignador 's se utiliza para asignarlo antes de copiar los elementos. (Puesto que C ++ 11).</target>
        </trans-unit>
        <trans-unit id="1e0dbe7fed5c788b8dad718a8b915f89fb6eb4b1" translate="yes" xml:space="preserve">
          <source>1) Copy assignment operator. Replaces the contents with a copy of the contents of other.</source>
          <target state="translated">1)Copia el operador de asignación.Sustituye el contenido por una copia del contenido de otro.</target>
        </trans-unit>
        <trans-unit id="7ee786d01693b06ebeb3b6d27fc4eca9ecd9d102" translate="yes" xml:space="preserve">
          <source>1) Creates an object of the given type &lt;code&gt;T&lt;/code&gt; by means of &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator construction&lt;/a&gt; at the uninitialized memory location indicated by p, using OUTERMOST as the allocator. After adjustment for uses-allocator convention expected by T's constructor, calls &lt;code&gt;OUTERMOST_ALLOC_TRAITS(*this)::construct&lt;/code&gt;.</source>
          <target state="translated">1) Crea un objeto del tipo &lt;code&gt;T&lt;/code&gt; dado por medio de la &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;construcci&amp;oacute;n del asignador&lt;/a&gt; de usos en la ubicaci&amp;oacute;n de memoria no inicializada indicada por p, usando OUTERMOST como el asignador. Despu&amp;eacute;s del ajuste para la convenci&amp;oacute;n de usos-asignador esperada por el constructor de T, llama a &lt;code&gt;OUTERMOST_ALLOC_TRAITS(*this)::construct&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2a543f321b7366feb622ab638584f7e34068656" translate="yes" xml:space="preserve">
          <source>1) Creates an object of the given type &lt;code&gt;U&lt;/code&gt; by means of &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;uses-allocator construction&lt;/a&gt; at the uninitialized memory location indicated by p, using &lt;code&gt;*this&lt;/code&gt; as the allocator. This overload only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;.(until C++20)</source>
          <target state="translated">1) Crea un objeto del tipo &lt;code&gt;U&lt;/code&gt; dado por medio de la &lt;a href=&quot;../uses_allocator#Uses-allocator_construction&quot;&gt;construcci&amp;oacute;n del asignador&lt;/a&gt; de usos en la ubicaci&amp;oacute;n de memoria no inicializada indicada por p, usando &lt;code&gt;*this&lt;/code&gt; como el asignador. Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;U&lt;/code&gt; no es una especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; . (Hasta C ++ 20)</target>
        </trans-unit>
        <trans-unit id="a9a98b74dec90269333d869db789c5323e20c4d2" translate="yes" xml:space="preserve">
          <source>1) Creates an optional object from &lt;code&gt;value&lt;/code&gt;. Effectively calls &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value))&lt;/code&gt;</source>
          <target state="translated">1) Crea un objeto opcional a partir del &lt;code&gt;value&lt;/code&gt; . Efectivamente llama a &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;T&amp;gt;&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;T&amp;gt;(value))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c480710a43a80e8adcfecc3be2f3cd25cb1baa89" translate="yes" xml:space="preserve">
          <source>1) Creates and returns a &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; object containing a copy of this &lt;code&gt;std::basic_stringbuf&lt;/code&gt;'s underlying character sequence. For input-only streams, the returned string contains the characters from the range &lt;code&gt;[eback(), egptr())&lt;/code&gt;. For input/output or output-only streams, contains the characters from &lt;code&gt;pbase()&lt;/code&gt; to the last character in the sequence regardless of &lt;code&gt;egptr()&lt;/code&gt; and &lt;code&gt;epptr()&lt;/code&gt;.</source>
          <target state="translated">1) Crea y devuelve un objeto &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; que contiene una copia de esta secuencia de caracteres subyacente de &lt;code&gt;std::basic_stringbuf&lt;/code&gt; . Para secuencias de solo entrada, la cadena devuelta contiene los caracteres del rango &lt;code&gt;[eback(), egptr())&lt;/code&gt; . Para flujos de entrada / salida o solo de salida, contiene los caracteres desde &lt;code&gt;pbase()&lt;/code&gt; hasta el &amp;uacute;ltimo car&amp;aacute;cter de la secuencia, independientemente de &lt;code&gt;egptr()&lt;/code&gt; y &lt;code&gt;epptr()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a5389ceb0bc0b5a3365c91e4e5a33417369a0e1f" translate="yes" xml:space="preserve">
          <source>1) Creates new thread object which does not represent a thread.</source>
          <target state="translated">1)Crea un nuevo objeto de hilo que no representa un hilo.</target>
        </trans-unit>
        <trans-unit id="0327a6fbad3860b481ce60cfaf07be7bf277056c" translate="yes" xml:space="preserve">
          <source>1) Creates the directory &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt;&lt;code&gt;mkdir()&lt;/code&gt;&lt;/a&gt; with a second argument of &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; (the parent directory must already exist). If the function fails because &lt;code&gt;p&lt;/code&gt; resolves to an existing directory, no error is reported. Otherwise on failure an error is reported.</source>
          <target state="translated">1) Crea el directorio &lt;code&gt;p&lt;/code&gt; como si fuera POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/mkdir.html&quot;&gt; &lt;code&gt;mkdir()&lt;/code&gt; &lt;/a&gt; con un segundo argumento de &lt;code&gt;static_cast&amp;lt;int&amp;gt;(&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms::all&lt;/a&gt;)&lt;/code&gt; (el directorio padre ya debe existir). Si la funci&amp;oacute;n falla porque &lt;code&gt;p&lt;/code&gt; se resuelve en un directorio existente, no se informa ning&amp;uacute;n error. De lo contrario, en caso de falla, se informa un error.</target>
        </trans-unit>
        <trans-unit id="bdf75898238d98a307ea5bb83b21e825fa5f14e6" translate="yes" xml:space="preserve">
          <source>1) Decimal integer literal (base 10, the first digit is the most significant)</source>
          <target state="translated">1)Literal entero decimal (base 10,el primer dígito es el más significativo)</target>
        </trans-unit>
        <trans-unit id="2c073db79516e7eb32cc3d9bb547356532b4dc4d" translate="yes" xml:space="preserve">
          <source>1) Declaration of a default constructor inside of class definition.</source>
          <target state="translated">1)Declaración de un constructor por defecto dentro de la definición de clase.</target>
        </trans-unit>
        <trans-unit id="b4e1003653c1efe0f901decca5b2245ba63c2f97" translate="yes" xml:space="preserve">
          <source>1) Declares a named (formal) parameter. For the meanings of decl-specifier-seq and declarator, see &lt;a href=&quot;declarations&quot;&gt;declarations&lt;/a&gt;.</source>
          <target state="translated">1) Declara un par&amp;aacute;metro con nombre (formal). Para los significados de decl-specifier-seq y declarator, ver &lt;a href=&quot;declarations&quot;&gt;declaraciones&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c4a1c3ae36aa2a523075a60794a76350d1cbb46" translate="yes" xml:space="preserve">
          <source>1) Declares a static data member.</source>
          <target state="translated">1)Declara un miembro de datos estáticos.</target>
        </trans-unit>
        <trans-unit id="aef76cc087fec5259881aa2a31282705f7c15ad1" translate="yes" xml:space="preserve">
          <source>1) Declares a user-defined conversion function that participates in all &lt;a href=&quot;implicit_cast&quot;&gt;implicit&lt;/a&gt; and &lt;a href=&quot;explicit_cast&quot;&gt;explicit conversions&lt;/a&gt;</source>
          <target state="translated">1) Declara una funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario que participa en todas &lt;a href=&quot;explicit_cast&quot;&gt;las conversiones &lt;/a&gt;&lt;a href=&quot;implicit_cast&quot;&gt;impl&amp;iacute;citas&lt;/a&gt; y expl&amp;iacute;citas</target>
        </trans-unit>
        <trans-unit id="f9bbb455cc0049834ffda69e633f84b7ffdce2f6" translate="yes" xml:space="preserve">
          <source>1) Declares an unscoped enumeration type whose underlying type is not fixed (in this case, the underlying type is an implementation-defined integral type that can represent all enumerator values; this type is not larger than &lt;code&gt;int&lt;/code&gt; unless the value of an enumerator cannot fit in an &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;unsigned int&lt;/code&gt;. If the enumerator-list is empty, the underlying type is as if the enumeration had a single enumerator with value 0).</source>
          <target state="translated">1) Declara un tipo de enumeraci&amp;oacute;n sin &amp;aacute;mbito cuyo tipo subyacente no es fijo (en este caso, el tipo subyacente es un tipo integral definido por la implementaci&amp;oacute;n que puede representar todos los valores del enumerador; este tipo no es mayor que &lt;code&gt;int&lt;/code&gt; a menos que el valor de un enumerador no pueda ajustarse en un &lt;code&gt;int&lt;/code&gt; o &lt;code&gt;unsigned int&lt;/code&gt; . Si la lista de enumeradores est&amp;aacute; vac&amp;iacute;a, el tipo subyacente es como si la enumeraci&amp;oacute;n tuviera un &amp;uacute;nico enumerador con valor 0).</target>
        </trans-unit>
        <trans-unit id="aad5551fd8cb89e8bb0fe35f15a0c5a90ee8d2c9" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves both the &lt;code&gt;std::chrono::weekday&lt;/code&gt; and the index value uninitialized.</source>
          <target state="translated">1) El constructor predeterminado deja tanto el &lt;code&gt;std::chrono::weekday&lt;/code&gt; la semana como el valor del &amp;iacute;ndice sin inicializar.</target>
        </trans-unit>
        <trans-unit id="2428761890c8eee7869837b591a34b4aeb8dae13" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the date uninitialized.</source>
          <target state="translated">1)El constructor por defecto deja la fecha sin inicializar.</target>
        </trans-unit>
        <trans-unit id="499e023d2657c02b2972ab6ce587b2b5cf8946cd" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the day value uninitialized.</source>
          <target state="translated">1)El constructor por defecto deja el valor del día sin inicializar.</target>
        </trans-unit>
        <trans-unit id="d7eaca31c34a6ae5693ef338f73e6bcd8c29ffb4" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the fields uninitialized.</source>
          <target state="translated">1)El constructor por defecto deja los campos sin inicializar.</target>
        </trans-unit>
        <trans-unit id="078562fd7069664d06229783df9c7e3002067686" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the month value uninitialized.</source>
          <target state="translated">1)El constructor por defecto deja el valor del mes sin inicializar.</target>
        </trans-unit>
        <trans-unit id="c36a47fb197929eeaca91e2ccaae79725f495a3f" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the object uninitialized.</source>
          <target state="translated">1)El constructor por defecto deja el objeto sin inicializar.</target>
        </trans-unit>
        <trans-unit id="f177bc21211b9f9814da5723e9d7b52c483ab492" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the stored month and day values uninitialized.</source>
          <target state="translated">1)El constructor por defecto deja los valores almacenados de mes y día sin inicializar.</target>
        </trans-unit>
        <trans-unit id="2b51b3017e5534f01a4fcc3714ba6f3fcca53ace" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the weekday value uninitialized.</source>
          <target state="translated">1)El constructor por defecto deja el valor del día de la semana sin inicializar.</target>
        </trans-unit>
        <trans-unit id="0e624fa6115013ca80f6e91997dffec7202273f9" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the year and month uninitialized.</source>
          <target state="translated">1)El constructor por defecto deja el año y el mes sin inicializar.</target>
        </trans-unit>
        <trans-unit id="131de4c9bed3f450ed7010d48d5a3fdb80330c32" translate="yes" xml:space="preserve">
          <source>1) Default constructor leaves the year value uninitialized.</source>
          <target state="translated">1)El constructor por defecto deja el valor del año sin inicializar.</target>
        </trans-unit>
        <trans-unit id="9115058f2c43fa98792950ebe40f71f59fbd9aa0" translate="yes" xml:space="preserve">
          <source>1) Default constructor that calls (4) with &lt;code&gt;&lt;a href=&quot;../file_type&quot;&gt;std::filesystem::file_type::none&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Constructor predeterminado que llama (4) con &lt;code&gt;&lt;a href=&quot;../file_type&quot;&gt;std::filesystem::file_type::none&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9d0e85becce06778b271a974bf41a26b72cc575" translate="yes" xml:space="preserve">
          <source>1) Default constructor, creates a &lt;code&gt;time_point&lt;/code&gt; representing the &lt;code&gt;Clock&lt;/code&gt;'s epoch (i.e., &lt;code&gt;&lt;a href=&quot;time_since_epoch&quot;&gt;time_since_epoch()&lt;/a&gt;&lt;/code&gt; is zero).</source>
          <target state="translated">1) El constructor predeterminado, crea un &lt;code&gt;time_point&lt;/code&gt; representa la &amp;eacute;poca del &lt;code&gt;Clock&lt;/code&gt; (es decir, &lt;code&gt;&lt;a href=&quot;time_since_epoch&quot;&gt;time_since_epoch()&lt;/a&gt;&lt;/code&gt; es cero).</target>
        </trans-unit>
        <trans-unit id="ca62ce9ba5ae98ed6cfeefae6805879eef5662f6" translate="yes" xml:space="preserve">
          <source>1) Default constructor.</source>
          <target state="translated">1)Constructor predeterminado.</target>
        </trans-unit>
        <trans-unit id="4672d91b62baf7495b356cbf3fd2d4ab7185bb97" translate="yes" xml:space="preserve">
          <source>1) Default constructor. &lt;a href=&quot;../../language/value_initialization&quot;&gt;Value-initializes&lt;/a&gt; all elements.</source>
          <target state="translated">1) Constructor predeterminado. &lt;a href=&quot;../../language/value_initialization&quot;&gt;El valor inicializa&lt;/a&gt; todos los elementos.</target>
        </trans-unit>
        <trans-unit id="2e8a32fa473b151fe2837e9a637eec271c2f495b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. &lt;a href=&quot;what&quot;&gt;&lt;code&gt;what()&lt;/code&gt;&lt;/a&gt; returns an implementation-defined string.</source>
          <target state="translated">1) Constructor predeterminado. &lt;a href=&quot;what&quot;&gt; &lt;code&gt;what()&lt;/code&gt; &lt;/a&gt; devuelve una cadena definida por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c75332d6c29abfeb6ab9132695635439c25e48b8" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a &lt;code&gt;std::future&lt;/code&gt; with no shared state. After construction, &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;valid()&lt;/code&gt;&lt;/a&gt;&lt;code&gt;== false&lt;/code&gt;.</source>
          <target state="translated">1) Constructor predeterminado. Construye un &lt;code&gt;std::future&lt;/code&gt; sin estado compartido. Despu&amp;eacute;s de la construcci&amp;oacute;n, &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;valid()&lt;/code&gt; &lt;/a&gt; &lt;code&gt;== false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="79261dde24b2758d36f9430c665e3f176df44f39" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a bitset with all bits set to zero.</source>
          <target state="translated">1)Constructor predeterminado.Construye un conjunto de bits con todos los bits puestos a cero.</target>
        </trans-unit>
        <trans-unit id="011ecb3fe17914dffa88456a32eaa298e263e47b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a copy of the global C++ locale, which is the locale most recently used as the argument to &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; or a copy of &lt;code&gt;&lt;a href=&quot;classic&quot;&gt;std::locale::classic&lt;/a&gt;&lt;/code&gt; if no call to &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; has been made.</source>
          <target state="translated">1) Constructor predeterminado. Construye una copia de la configuraci&amp;oacute;n regional global de C ++, que es la configuraci&amp;oacute;n regional utilizada m&amp;aacute;s recientemente como argumento para &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; o una copia de &lt;code&gt;&lt;a href=&quot;classic&quot;&gt;std::locale::classic&lt;/a&gt;&lt;/code&gt; si no se llama a &lt;code&gt;&lt;a href=&quot;global&quot;&gt;std::locale::global&lt;/a&gt;&lt;/code&gt; has hecho.</target>
        </trans-unit>
        <trans-unit id="895580b59835cf3ea8b8e9ef9fcc3a2446be6649" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs a variant holding the &lt;a href=&quot;../../language/value_initialization&quot;&gt;value-initialized&lt;/a&gt; value of the first alternative (&lt;a href=&quot;index&quot;&gt;&lt;code&gt;index()&lt;/code&gt;&lt;/a&gt; is zero). This constructor is &lt;code&gt;constexpr&lt;/code&gt; if and only if the value initialization of the alternative type T_0 would satisfy the requirements for a &lt;a href=&quot;../../language/constexpr&quot;&gt;constexpr function&lt;/a&gt;. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;T_0&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1) Constructor predeterminado. Construye una variante que contiene el &lt;a href=&quot;../../language/value_initialization&quot;&gt;valor inicializado de&lt;/a&gt; valor de la primera alternativa ( &lt;a href=&quot;index&quot;&gt; &lt;code&gt;index()&lt;/code&gt; &lt;/a&gt; es cero). Este constructor es &lt;code&gt;constexpr&lt;/code&gt; si y solo si la inicializaci&amp;oacute;n del valor del tipo alternativo T_0 satisfar&amp;iacute;a los requisitos para una &lt;a href=&quot;../../language/constexpr&quot;&gt;funci&amp;oacute;n constexpr&lt;/a&gt; . Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;T_0&amp;gt;&lt;/code&gt; es verdadero.</target>
        </trans-unit>
        <trans-unit id="9d0e5fa5fa920ac3791488de3b572932835b95ee" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty &lt;code&gt;basic_string_view&lt;/code&gt;. After construction, &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;nullptr&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is equal to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">1) Constructor predeterminado. Construye una &lt;code&gt;basic_string_view&lt;/code&gt; vac&amp;iacute;a . Despu&amp;eacute;s de la construcci&amp;oacute;n, &lt;code&gt;&lt;a href=&quot;data&quot;&gt;data()&lt;/a&gt;&lt;/code&gt; es igual a &lt;code&gt;nullptr&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; es igual a &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eacc35685d23a4fecd10da59ea5f06868759d796" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty container. If no allocator is supplied, allocator is obtained from a default-constructed instance.</source>
          <target state="translated">1)Constructor predeterminado.Construye un contenedor vacío.Si no se suministra un asignador,se obtiene de un constructor por defecto.</target>
        </trans-unit>
        <trans-unit id="6c17b4644d6ac209e7f22c17144138b18c5931e9" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty numeric array.</source>
          <target state="translated">1)Constructor predeterminado.Construye una matriz numérica vacía.</target>
        </trans-unit>
        <trans-unit id="de0ff732be5a241f66c48250f820f0547487440b" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty regular expression which will match nothing.</source>
          <target state="translated">1)Constructor predeterminado.Construye una expresión regular vacía que no coincidirá con nada.</target>
        </trans-unit>
        <trans-unit id="e669d70f06155beb00ecca03586e5c258a586219" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an empty shared future, that doesn't refer to a shared state, that is &lt;code&gt;valid() == false&lt;/code&gt;.</source>
          <target state="translated">1) Constructor predeterminado. Construye un futuro compartido vac&amp;iacute;o, que no se refiere a un estado compartido, que es &lt;code&gt;valid() == false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7565190dee6671c76d3a56a2e2e2a2350105a5f5" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an end iterator.</source>
          <target state="translated">1)Constructor predeterminado.Construye un iterador final.</target>
        </trans-unit>
        <trans-unit id="cb5ed3cd804429aa2c7dde21da7ca9ead64884cb" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs an end-of-sequence iterator.</source>
          <target state="translated">1)Constructor predeterminado.Construye un iterador de fin de secuencia.</target>
        </trans-unit>
        <trans-unit id="9cd879bc1abea042190566e8fd2e0be2513b8de1" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs empty &lt;code&gt;weak_ptr&lt;/code&gt;.</source>
          <target state="translated">1) Constructor predeterminado. Construye empty &lt;code&gt;weak_ptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f5913ec53e778795e8ead732e87ecf9cfcfc151" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs empty string (zero size and unspecified capacity). If no allocator is supplied, allocator is obtained from a default-constructed instance.</source>
          <target state="translated">1)Constructor predeterminado.Construye una cadena vacía (tamaño cero y capacidad no especificada).Si no se suministra un asignador,se obtiene de una instancia construida por defecto.</target>
        </trans-unit>
        <trans-unit id="fea889f6b10c364b364bead59870fc1ead08d127" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs new underlying string device with the default open mode</source>
          <target state="translated">1)Constructor predeterminado.Construye un nuevo dispositivo de cadena subyacente con el modo abierto por defecto</target>
        </trans-unit>
        <trans-unit id="47dfb990d09b6cf7741d11d703850522bdd37ac1" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the distribution with a single weight p={1}. This distribution will always generate &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1) Constructor predeterminado. Construye la distribuci&amp;oacute;n con un solo peso p = {1}. Esta distribuci&amp;oacute;n generar&amp;aacute; siempre &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e80f107318c31b0c58e6aeef75360f44ffd05c03" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the end-of-sequence iterator.</source>
          <target state="translated">1)Constructor predeterminado.Construye el iterador de fin de secuencia.</target>
        </trans-unit>
        <trans-unit id="5bf185507087fc694124074f527682377e4e4b06" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Constructs the promise with an empty shared state.</source>
          <target state="translated">1)Constructor predeterminado.Construye la promesa con un estado compartido vacío.</target>
        </trans-unit>
        <trans-unit id="25239fa19574ad09c0768600521365122e69a28f" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Equivalent to &lt;code&gt;gslice(0, &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(), &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;())&lt;/code&gt;. This constructor exists only to allow construction of arrays of slices.</source>
          <target state="translated">1) Constructor predeterminado. Equivalente a &lt;code&gt;gslice(0, &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;(), &lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&amp;gt;())&lt;/code&gt; . Este constructor existe solo para permitir la construcci&amp;oacute;n de matrices de cortes.</target>
        </trans-unit>
        <trans-unit id="25b86c4ec98dd08e9433550d3d731d786fa40f88" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Equivalent to &lt;code&gt;slice(0, 0, 0)&lt;/code&gt;. This constructor exists only to allow construction of arrays of slices.</source>
          <target state="translated">1) Constructor predeterminado. Equivalente a &lt;code&gt;slice(0, 0, 0)&lt;/code&gt; . Este constructor existe solo para permitir la construcci&amp;oacute;n de matrices de cortes.</target>
        </trans-unit>
        <trans-unit id="0f2c9964918fbbbec4b2a2f80259c25e38ce89a5" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Initializes the error condition with generic category and error code &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1) Constructor predeterminado. Inicializa la condici&amp;oacute;n de error con categor&amp;iacute;a gen&amp;eacute;rica y c&amp;oacute;digo de error &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a16bc65a9c0bb02a38efb33e034e628db8375633" translate="yes" xml:space="preserve">
          <source>1) Default constructor. It is implementation-defined whether the sequence pointers (&lt;code&gt;eback()&lt;/code&gt;, &lt;code&gt;gptr()&lt;/code&gt;, &lt;code&gt;egptr()&lt;/code&gt;, &lt;code&gt;pbase()&lt;/code&gt;, &lt;code&gt;pptr()&lt;/code&gt;, &lt;code&gt;epptr()&lt;/code&gt;) are initialized to null pointers.</source>
          <target state="translated">1) Constructor predeterminado. Est&amp;aacute; definido por la implementaci&amp;oacute;n si los punteros de secuencia ( &lt;code&gt;eback()&lt;/code&gt; , &lt;code&gt;gptr()&lt;/code&gt; , &lt;code&gt;egptr()&lt;/code&gt; , &lt;code&gt;pbase()&lt;/code&gt; , &lt;code&gt;pptr()&lt;/code&gt; , &lt;code&gt;epptr()&lt;/code&gt; ) se inicializan en punteros nulos.</target>
        </trans-unit>
        <trans-unit id="18cc22e95dd49ea3310825efa9be211fee3b3c2f" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Seeds the engine with &lt;code&gt;default_seed&lt;/code&gt;.</source>
          <target state="translated">1) Constructor predeterminado. Siembra el motor con &lt;code&gt;default_seed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a1f3b78577783b96afca946ecfdb044a2e2fe03" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Stores an exception object obtained by calling &lt;code&gt;&lt;a href=&quot;../current_exception&quot;&gt;std::current_exception&lt;/a&gt;()&lt;/code&gt; within the new &lt;code&gt;nested_exception&lt;/code&gt; object.</source>
          <target state="translated">1) Constructor predeterminado. Almacena un objeto de excepci&amp;oacute;n obtenido llamando a &lt;code&gt;&lt;a href=&quot;../current_exception&quot;&gt;std::current_exception&lt;/a&gt;()&lt;/code&gt; dentro de la nueva &lt;code&gt;nested_exception&lt;/code&gt; objeto .</target>
        </trans-unit>
        <trans-unit id="8a32db41a403e2f63a4fd28475b603a4ec46df42" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The internal state is not initialized. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init()&lt;/a&gt;&lt;/code&gt; must be called before the first use of the object or before destructor, otherwise the behavior is undefined.</source>
          <target state="translated">1) Constructor predeterminado. El estado interno no est&amp;aacute; inicializado. &lt;code&gt;&lt;a href=&quot;init&quot;&gt;init()&lt;/a&gt;&lt;/code&gt; debe llamar a antes del primer uso del objeto o antes del destructor; de lo contrario, el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="55062aaea6619514669480e39506ff7c999ff520" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The underlying engine is also default-constructed.</source>
          <target state="translated">1)Constructor predeterminado.El motor subyacente también está construido por defecto.</target>
        </trans-unit>
        <trans-unit id="15f4029d373e079f41db83cdd93169d4f5785dcf" translate="yes" xml:space="preserve">
          <source>1) Default constructor. The underlying iterator is value-initialized. Operations on the resulting iterator have defined behavior if and only if the corresponding operations on a value-initialized &lt;code&gt;Iterator&lt;/code&gt; also have defined behavior.</source>
          <target state="translated">1) Constructor predeterminado. El iterador subyacente tiene valor inicializado. Las operaciones en el iterador resultante tienen un comportamiento definido si y solo si las operaciones correspondientes en un &lt;code&gt;Iterator&lt;/code&gt; valor inicializado tambi&amp;eacute;n tienen un comportamiento definido.</target>
        </trans-unit>
        <trans-unit id="2a9d616bbf3734e2be9b10dbac57548362a533dd" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes both elements of the pair, &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;second&lt;/code&gt;.</source>
          <target state="translated">1) Constructor predeterminado. El valor inicializa ambos elementos del par, &lt;code&gt;first&lt;/code&gt; y &lt;code&gt;second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d50a8b3aca03c89f83a8e00c8035cce2b2f943dc" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes the comparator and the underlying container.</source>
          <target state="translated">1)Constructor predeterminado.El valor inicializa el comparador y el contenedor subyacente.</target>
        </trans-unit>
        <trans-unit id="d57453057acaf238aba5d7c9f55019284642f9be" translate="yes" xml:space="preserve">
          <source>1) Default constructor. Value-initializes the container.</source>
          <target state="translated">1)Constructor predeterminado.Inicializa el valor del contenedor.</target>
        </trans-unit>
        <trans-unit id="85aa7b5f36dda27d22e0568ece5d170840dd6df4" translate="yes" xml:space="preserve">
          <source>1) Default constructor: constructs a stream that is not associated with a file: default-constructs the &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; and constructs the base with the pointer to this default-constructed &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; member.</source>
          <target state="translated">1) Constructor predeterminado: construye una secuencia que no est&amp;aacute; asociada con un archivo: default-construye &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; y construye la base con el puntero a este &lt;code&gt;&lt;a href=&quot;../basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; construido por defecto miembro .</target>
        </trans-unit>
        <trans-unit id="3cab7b4fb28e5286d6fa395d1c88c741664448fe" translate="yes" xml:space="preserve">
          <source>1) Default constructor: value-initializes the &lt;code&gt;OuterAlloc&lt;/code&gt; base class and the inner allocator member object, if used by the implementation.</source>
          <target state="translated">1) Constructor predeterminado: valor-inicializa el &lt;code&gt;OuterAlloc&lt;/code&gt; clase base y el objeto miembro del asignador interno, si es utilizado por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f147745323c3c84fec33aec7c8557ca0d3395b0a" translate="yes" xml:space="preserve">
          <source>1) Default constructs a new &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; object with an implementation-defined &lt;code&gt;token&lt;/code&gt;.</source>
          <target state="translated">1) Predeterminado construye un nuevo objeto &lt;code&gt;&lt;a href=&quot;../random_device&quot;&gt;std::random_device&lt;/a&gt;&lt;/code&gt; con un &lt;code&gt;token&lt;/code&gt; definido por la implementaci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="3d254d4e4e041dda90a59631d7b2960792e803ef" translate="yes" xml:space="preserve">
          <source>1) Default-constructor. Constructs a match result with no established result state (&lt;code&gt;ready() != true&lt;/code&gt;).</source>
          <target state="translated">1) Constructor por defecto. Construye un resultado de coincidencia sin un estado de resultado establecido ( &lt;code&gt;ready() != true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1af4fb69cdbe20bca957ea5aab4e348af2793199" translate="yes" xml:space="preserve">
          <source>1) Default-constructs the underlying &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;, which creates a dynamically growing buffer, and initializes the base class with the address of the strstreambuf member.</source>
          <target state="translated">1) Construye por defecto el &lt;code&gt;&lt;a href=&quot;../strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; subyacente , que crea un b&amp;uacute;fer de crecimiento din&amp;aacute;mico e inicializa la clase base con la direcci&amp;oacute;n del miembro strstreambuf.</target>
        </trans-unit>
        <trans-unit id="7d13af42ec3f2ddb8462a572d1b26587eccb3d92" translate="yes" xml:space="preserve">
          <source>1) Default-initializes &lt;code&gt;base_&lt;/code&gt; and &lt;code&gt;pred_&lt;/code&gt;</source>
          <target state="translated">1) Inicializa por defecto &lt;code&gt;base_&lt;/code&gt; y &lt;code&gt;pred_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1ac5a4d8f549ae70b68112a4ef17cd868cd57e69" translate="yes" xml:space="preserve">
          <source>1) Default-initializes &lt;code&gt;value_&lt;/code&gt; and &lt;code&gt;bound_&lt;/code&gt;</source>
          <target state="translated">1) Predeterminado inicializa &lt;code&gt;value_&lt;/code&gt; y &lt;code&gt;bound_&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1dbaabdc4ff6b70020a151bf2e9abc440948c50" translate="yes" xml:space="preserve">
          <source>1) Defaulted copy assignment operator. Copy-assigns both the stored time point and the stored time zone pointer. &lt;code&gt;zoned_time&lt;/code&gt; has no move assignment operator; a move is a copy.</source>
          <target state="translated">1) Operador de asignaci&amp;oacute;n de copia predeterminado. Copiar asigna tanto el punto de tiempo almacenado como el puntero de zona horaria almacenado. &lt;code&gt;zoned_time&lt;/code&gt; no tiene operador de asignaci&amp;oacute;n de movimiento; Un movimiento es una copia.</target>
        </trans-unit>
        <trans-unit id="78b7cc430f5922607ee43272f394fa79b6ed0bac" translate="yes" xml:space="preserve">
          <source>1) Define a non-member swap in the enclosing namespace, which may forward to a member swap if access to non-public data members is required</source>
          <target state="translated">1)Definir un intercambio de no miembros en el espacio de nombres adjunto,que puede remitirse a un intercambio de miembros si se requiere el acceso a datos no públicos de los miembros</target>
        </trans-unit>
        <trans-unit id="a7de1a6f8b3cc0594b28dcfd6a8f7980d955fbbc" translate="yes" xml:space="preserve">
          <source>1) Defines a</source>
          <target state="translated">1)Define un</target>
        </trans-unit>
        <trans-unit id="c6408478c098043618abdb9b577727df78dd08ab" translate="yes" xml:space="preserve">
          <source>1) Definition of an enumeration type.</source>
          <target state="translated">1)Definición de un tipo de enumeración.</target>
        </trans-unit>
        <trans-unit id="ebbd2ad38e5fa6237bba264cce1284f0bd1cec2c" translate="yes" xml:space="preserve">
          <source>1) Denormalization loss: the delivered result differs from what would have been computed were exponent range unbounded.</source>
          <target state="translated">1)Pérdida de desnormalización:el resultado entregado difiere de lo que se habría calculado si el rango de exponentes no tuviera límites.</target>
        </trans-unit>
        <trans-unit id="4a1bd34fda9394675a66721b9472df8d48990386" translate="yes" xml:space="preserve">
          <source>1) Designates a function or several functions as friends of this class</source>
          <target state="translated">1)Designa una función o varias funciones como amigos de esta clase</target>
        </trans-unit>
        <trans-unit id="cda85d78ffc7280c614df8e23678c3c173935a15" translate="yes" xml:space="preserve">
          <source>1) Destroys one non-array object created by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;</source>
          <target state="translated">1) Destruye un objeto sin matriz creado por una &lt;a href=&quot;new&quot;&gt;nueva expresi&amp;oacute;n&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2cba7eb8d44c15125cdc52986458ca13f73ba7d1" translate="yes" xml:space="preserve">
          <source>1) Destroys the &lt;code&gt;n&lt;/code&gt; objects in the range starting at &lt;code&gt;first&lt;/code&gt;, as if by</source>
          <target state="translated">1) Destruye los &lt;code&gt;n&lt;/code&gt; objetos en el rango comenzando al &lt;code&gt;first&lt;/code&gt; , como si por</target>
        </trans-unit>
        <trans-unit id="f998857faa7d72f442a5b64bb7bd57852afbb2f4" translate="yes" xml:space="preserve">
          <source>1) Destroys the iterator, including the cached value.</source>
          <target state="translated">1)Destruye el iterador,incluyendo el valor almacenado.</target>
        </trans-unit>
        <trans-unit id="a3f6de15f76b6e6f118c50c482f5797660572e61" translate="yes" xml:space="preserve">
          <source>1) Destroys the objects in the range &lt;code&gt;[first, last)&lt;/code&gt;, as if by</source>
          <target state="translated">1) Destruye los objetos en el rango &lt;code&gt;[first, last)&lt;/code&gt; , como si por</target>
        </trans-unit>
        <trans-unit id="8e3aa580452b25d9999027f1b3cb229e40ec1851" translate="yes" xml:space="preserve">
          <source>1) Detects if the current thread has a live exception object, that is, an exception has been thrown or rethrown and not yet entered a matching catch clause, &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt;. In other words, &lt;code&gt;std::uncaught_exception&lt;/code&gt; detects if &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;stack unwinding&lt;/a&gt; is currently in progress.</source>
          <target state="translated">1) Detecta si el hilo actual tiene un objeto de excepci&amp;oacute;n en vivo, es decir, se ha lanzado o vuelto a lanzar una excepci&amp;oacute;n y a&amp;uacute;n no se ha ingresado una cl&amp;aacute;usula catch coincidente, &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; . En otras palabras, &lt;code&gt;std::uncaught_exception&lt;/code&gt; detecta si el &lt;a href=&quot;../../language/throw#Stack_unwinding&quot;&gt;desbobinado de la pila&lt;/a&gt; est&amp;aacute; actualmente en progreso.</target>
        </trans-unit>
        <trans-unit id="df7a3ba6b3fba13efda3c048c64afee201d66f99" translate="yes" xml:space="preserve">
          <source>1) Determines if the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt; is implemented lock-free, as if by calling &lt;code&gt;obj-&amp;gt;is_lock_free()&lt;/code&gt;. In any given program execution, the result of the lock-free query is the same for all pointers of the same type.</source>
          <target state="translated">1) Determina si el objeto at&amp;oacute;mico al que apunta &lt;code&gt;obj&lt;/code&gt; se implementa sin bloqueo, como si se llamara &lt;code&gt;obj-&amp;gt;is_lock_free()&lt;/code&gt; . En cualquier ejecuci&amp;oacute;n de programa, el resultado de la consulta sin bloqueo es el mismo para todos los punteros del mismo tipo.</target>
        </trans-unit>
        <trans-unit id="91e01796abcfa6eddc0b11eb63b158b9aba3771c" translate="yes" xml:space="preserve">
          <source>1) Determines if there is a match between the regular expression &lt;code&gt;e&lt;/code&gt; and the entire target character sequence &lt;code&gt;[first,last)&lt;/code&gt;, taking into account the effect of &lt;code&gt;flags&lt;/code&gt;. When determining if there is a match, only potential matches that match the entire character sequence are considered. Match results are returned in &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1) Determina si hay una coincidencia entre la expresi&amp;oacute;n regular &lt;code&gt;e&lt;/code&gt; y la secuencia completa de caracteres objetivo &lt;code&gt;[first,last)&lt;/code&gt; , teniendo en cuenta el efecto de las &lt;code&gt;flags&lt;/code&gt; . Al determinar si hay una coincidencia, solo se consideran las coincidencias potenciales que coinciden con la secuencia de caracteres completa. Los resultados del partido se devuelven en &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b58fdc599cf255bac2ae50522ea05922284c1bea" translate="yes" xml:space="preserve">
          <source>1) Determines the type and attributes of the filesystem object identified by &lt;code&gt;p&lt;/code&gt; as if by POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed to their targets). In the following description, &lt;code&gt;prms&lt;/code&gt; is the result of &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt;, where &lt;code&gt;m&lt;/code&gt; is obtained as if by taking &lt;code&gt;st_mode&lt;/code&gt; from the POSIX &lt;code&gt;struct stat&lt;/code&gt; and converting it to the type &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Determina el tipo y los atributos del objeto del sistema de archivos identificado por &lt;code&gt;p&lt;/code&gt; como si fuera una &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;estad&amp;iacute;stica&lt;/a&gt; POSIX (los enlaces simb&amp;oacute;licos se siguen a sus objetivos). En la siguiente descripci&amp;oacute;n, &lt;code&gt;prms&lt;/code&gt; es el resultado de &lt;code&gt;(m &amp;amp; perms::mask)&lt;/code&gt; , donde &lt;code&gt;m&lt;/code&gt; se obtiene como si se toma &lt;code&gt;st_mode&lt;/code&gt; de la &lt;code&gt;struct stat&lt;/code&gt; POSIX y se convierte al tipo &lt;code&gt;&lt;a href=&quot;perms&quot;&gt;std::filesystem::perms&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a44ae052e348f0eb5abeb579d93acfea11ea715" translate="yes" xml:space="preserve">
          <source>1) Determines whether &lt;code&gt;Fn&lt;/code&gt; can be invoked with the arguments &lt;code&gt;ArgTypes...&lt;/code&gt;. Formally, determines whether &lt;code&gt;INVOKE(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; is well formed when treated as an unevaluated operand, where &lt;code&gt;INVOKE&lt;/code&gt; is the operation defined in &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt;.</source>
          <target state="translated">1) Determina si &lt;code&gt;Fn&lt;/code&gt; se puede invocar con los argumentos &lt;code&gt;ArgTypes...&lt;/code&gt; . Formalmente, determina si &lt;code&gt;INVOKE(declval&amp;lt;Fn&amp;gt;(), declval&amp;lt;ArgTypes&amp;gt;()...)&lt;/code&gt; est&amp;aacute; bien formado cuando se trata como un operando no evaluado, donde &lt;code&gt;INVOKE&lt;/code&gt; es la operaci&amp;oacute;n definida en &lt;a href=&quot;../named_req/callable&quot;&gt;Callable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ca298188df78ab4f447d54b4bad5cd57815e3fe1" translate="yes" xml:space="preserve">
          <source>1) Determines whether atomic access to the shared pointer pointed-to by &lt;code&gt;p&lt;/code&gt; is lock-free.</source>
          <target state="translated">1) Determina si el acceso at&amp;oacute;mico al puntero compartido al que apunta &lt;code&gt;p&lt;/code&gt; est&amp;aacute; libre de bloqueos.</target>
        </trans-unit>
        <trans-unit id="65005f1a4f1673e794ca8fd566db8cadc1934b30" translate="yes" xml:space="preserve">
          <source>1) Does not throw</source>
          <target state="translated">1)No tira</target>
        </trans-unit>
        <trans-unit id="fab8fda7614e477a6f71346517837d8a3e567c5f" translate="yes" xml:space="preserve">
          <source>1) Each element is assigned value obtained by applying the corresponding operator to the previous value of the element and corresponding element from &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">1) A cada elemento se le asigna el valor obtenido al aplicar el operador correspondiente al valor anterior del elemento y el elemento correspondiente de &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a8ff4bbb77a97d615fec33736a3f814af766ce7" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1) Llama efectivamente &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;mem_fun_ref_t&quot;&gt;std::const_mem_fun_ref_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31e828b09b6dcd4b69af6c0189e9702fd814cda6" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1) Llama efectivamente &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;mem_fun_t&quot;&gt;std::const_mem_fun_t&lt;/a&gt;&amp;lt;S,T&amp;gt;(f)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46acfc8106489874b0a683e5cfada60e0e48401e" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;&lt;a href=&quot;pointer_to_unary_function&quot;&gt;std::pointer_to_unary_function&lt;/a&gt;&amp;lt;Arg,Result&amp;gt;(f)&lt;/code&gt;.</source>
          <target state="translated">1) Efectivamente llama a &lt;code&gt;&lt;a href=&quot;pointer_to_unary_function&quot;&gt;std::pointer_to_unary_function&lt;/a&gt;&amp;lt;Arg,Result&amp;gt;(f)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7400b67aeeb319d2c89e9f0544cebe1005e1706" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;c.push_back(value); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;</source>
          <target state="translated">1) Llama efectivamente a &lt;code&gt;c.push_back(value); &lt;a href=&quot;../../algorithm/push_heap&quot;&gt;std::push_heap&lt;/a&gt;(c.begin(), c.end(), comp);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d470e4c140bedbd34a1126e97e4400dc788fa04" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;c.push_back(value)&lt;/code&gt;</source>
          <target state="translated">1) Llama efectivamente a &lt;code&gt;c.push_back(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="011d1f5ba60bd9d74dea06b316bbfe4e137bcdaa" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;f(read_symlink(from), to)&lt;/code&gt; where &lt;code&gt;f&lt;/code&gt; is &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_symlink&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;create_symlink&quot;&gt;&lt;code&gt;create_directory_symlink&lt;/code&gt;&lt;/a&gt; depending on whether &lt;code&gt;from&lt;/code&gt; resolves to a file or directory.</source>
          <target state="translated">1) llama Efectivamente &lt;code&gt;f(read_symlink(from), to)&lt;/code&gt; , donde &lt;code&gt;f&lt;/code&gt; es &lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_symlink&lt;/code&gt; &lt;/a&gt; o &lt;a href=&quot;create_symlink&quot;&gt; &lt;code&gt;create_directory_symlink&lt;/code&gt; &lt;/a&gt; dependiendo de si &lt;code&gt;from&lt;/code&gt; resuelve en un archivo o directorio.</target>
        </trans-unit>
        <trans-unit id="e2c0e9b14b9519968975e29f74ca4f737cc3b463" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;m.lock()&lt;/code&gt;. The behavior is undefined if &lt;code&gt;m&lt;/code&gt; is not a recursive mutex and the current thread already owns &lt;code&gt;m&lt;/code&gt;.</source>
          <target state="translated">1) Efectivamente llama a &lt;code&gt;m.lock()&lt;/code&gt; . El comportamiento no est&amp;aacute; definido si &lt;code&gt;m&lt;/code&gt; no es un mutex recursivo y el hilo actual ya posee &lt;code&gt;m&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fbed931d739878efe2242dc69e3c3ec188c93c6" translate="yes" xml:space="preserve">
          <source>1) Effectively calls &lt;code&gt;reset(r.release())&lt;/code&gt;.</source>
          <target state="translated">1) Efectivamente llama a &lt;code&gt;reset(r.release())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="588791ac3459488ee09ba487973c4664a54285ba" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator&amp;lt;&lt;/code&gt; and the ranges must be sorted with respect to the same.</source>
          <target state="translated">1) Los elementos se comparan utilizando el &lt;code&gt;operator&amp;lt;&lt;/code&gt; y los rangos deben ordenarse con respecto al mismo.</target>
        </trans-unit>
        <trans-unit id="8cc3c33d923eee557c7b587363c490e22bf00f05" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator&amp;lt;&lt;/code&gt;.</source>
          <target state="translated">1) Los elementos se comparan usando el &lt;code&gt;operator&amp;lt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d09f5debbd2155a625dbd1f35e701b7e3c2ab3b" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;.</source>
          <target state="translated">1) Los elementos se comparan usando el &lt;code&gt;operator==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc915779f9828f296793ebde353de4de9e382deb" translate="yes" xml:space="preserve">
          <source>1) Elements are compared using &lt;code&gt;operator==&lt;/code&gt;. The behavior is undefined if it is not an &lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;equivalence relation&lt;/a&gt;.</source>
          <target state="translated">1) Los elementos se comparan usando el &lt;code&gt;operator==&lt;/code&gt; . El comportamiento es indefinido si no es una &lt;a href=&quot;https://en.wikipedia.org/wiki/equivalence_relation&quot;&gt;relaci&amp;oacute;n de equivalencia&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="05030b7bb4349fc087ee762a2cc6879e74372695" translate="yes" xml:space="preserve">
          <source>1) Enables the &lt;code&gt;boolalpha&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) Habilita el indicador &lt;code&gt;boolalpha&lt;/code&gt; en la secuencia &lt;code&gt;str&lt;/code&gt; como si llamara a &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::boolalpha&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="96a972a826ee3fcdba20885c2506d308930acc88" translate="yes" xml:space="preserve">
          <source>1) Equality operator for variants:</source>
          <target state="translated">1)Operador de igualdad para las variantes:</target>
        </trans-unit>
        <trans-unit id="82f9550a944d3a8df60f3b265cda2b488c9da5d5" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + d;&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;*this = *this + d;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="41d083e1f8110bfe1557758d4d4695c37d622fdb" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + dy;&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;*this = *this + dy;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ce04fa95ba678e6e255c69e3ebde6576457d731" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;*this = *this + y;&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;*this = *this + y;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1d9406b90ecb5fc7caa6afd7e187ab3217839eea" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;++d_; return *this;&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;++d_; return *this;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f1d88d98b52d4717f7dcfd15653a17e454989f4" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;++rep_; return *this;&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;++rep_; return *this;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9c52d71237ed4fde0f7863911f0865e168009fdf" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_days&lt;/a&gt;(year()/month()/day())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aace9380526b20cb700bec8018bdc6d389438aec" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;Iter tmp = current; return *--tmp;&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;Iter tmp = current; return *--tmp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2aaf37e2ad0a4d3314a70e8a4edea0af77b29fd6" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;bool(*this) ? **this : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</source>
          <target state="translated">1) &amp;iquest;Equivalente a &lt;code&gt;bool(*this) ? **this : static_cast&amp;lt;T&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;U&amp;gt;(default_value))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27ca6cdc924e29f6abac7e6f89eb8af6bc1cf7bd" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;default_error_condition(code) == condition&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;default_error_condition(code) == condition&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaf68a0e9a1753e7c451d7db374905454c1660ab" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;emplace&amp;lt;I&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;, where &lt;code&gt;I&lt;/code&gt; is the zero-based index of &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;. This overload only participates in overload resolution if &lt;code&gt;std::is_constructible_v&amp;lt;T, Args...&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;T&lt;/code&gt; occurs exactly once in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;emplace&amp;lt;I&amp;gt;(&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt; , donde &lt;code&gt;I&lt;/code&gt; es el &amp;iacute;ndice de base cero de &lt;code&gt;T&lt;/code&gt; en &lt;code&gt;Types...&lt;/code&gt; . Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;std::is_constructible_v&amp;lt;T, Args...&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;T&lt;/code&gt; ocurre exactamente una vez en &lt;code&gt;Types...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0c1e7f7def0b0c1e4bc97e06e0f684adad56ecd5" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;exists(s) &amp;amp;&amp;amp; !is_regular_file(s) &amp;amp;&amp;amp; !is_directory(s) &amp;amp;&amp;amp; !is_symlink(s)&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;exists(s) &amp;amp;&amp;amp; !is_regular_file(s) &amp;amp;&amp;amp; !is_directory(s) &amp;amp;&amp;amp; !is_symlink(s)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c543a72231a15ed9a65b4120bd54a699a7d90c" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;lhs.equal(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f78f1b1933f2be104c9b36333cbd8655ec420b2" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;native().c_str()&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;native().c_str()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5960311674c16cc0cc1bf3867e9d05c22ddeb540" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;rep_ += d.count(); return *this;&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;rep_ += d.count(); return *this;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9df00ac4a641d9e8760432c2ae7533cb453b1bce" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</source>
          <target state="translated">1) &amp;iexcl;Equivalente a &lt;code&gt;return !&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(fd, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d36ac7d6e30651e85b700452df731bf1029a32f0" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;return &lt;a href=&quot;../any&quot;&gt;std::any&lt;/a&gt;(&lt;a href=&quot;../in_place&quot;&gt;std::in_place_type&lt;/a&gt;&amp;lt;T&amp;gt;, &lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="47f69e5f8468517d7589e267f72b1dbbba5c3293" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return D(*this);&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;return D(*this);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="783946ea6f8a3464885e40163c1c9564f4ceea63" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;return r.begin();&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;return r.begin();&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3f4fc870674f5fb012dd975ee57837cfeab7d645" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::block&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;s.type() == file_type::block&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b1ed7de20f555f8534e2a84d964c966bd9d5cde" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::character&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;s.type() == file_type::character&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="897ad8584bbbaddb6b9248b6dea56350ebb88d4c" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::directory&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;s.type() == file_type::directory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a63e546b555f8572521590a9d2ea549dc2ae2235" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::fifo&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;s.type() == file_type::fifo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98720eb9c80b5e9a08ada8eb5db1b51aa2e92d32" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::regular&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;s.type() == file_type::regular&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05305515a6902b55a79c88270ce56bc514f70239" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::socket&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;s.type() == file_type::socket&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab8b95a7b2ea4746283ea27160065e146ccff49a" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;s.type() == file_type::symlink&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;s.type() == file_type::symlink&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="179ac5c7fc855225a87152301381a704450b6c4a" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;static_cast&amp;lt;reference&amp;gt;(*base())&lt;/code&gt;;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;static_cast&amp;lt;reference&amp;gt;(*base())&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="538ab1915dd3230391d766df1b4a3748da3f84c1" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;status_known(s) &amp;amp;&amp;amp; s.type() != file_type::not_found&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a &lt;code&gt;status_known(s) &amp;amp;&amp;amp; s.type() != file_type::not_found&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8fb771283367cf610ecf5e023e663a4fe8645b" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;std::move(*base())&lt;/code&gt;;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;std::move(*base())&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="8df252cd519d51da4b9b18b92bb448ad32a642e9" translate="yes" xml:space="preserve">
          <source>1) Equivalent to &lt;code&gt;transform_reduce(first1, last1, first2, init, std::plus&amp;lt;&amp;gt;(), std::multiplies&amp;lt;&amp;gt;());&lt;/code&gt;, effectively parallelized version of the default &lt;code&gt;&lt;a href=&quot;inner_product&quot;&gt;std::inner_product&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) Equivalente a &lt;code&gt;transform_reduce(first1, last1, first2, init, std::plus&amp;lt;&amp;gt;(), std::multiplies&amp;lt;&amp;gt;());&lt;/code&gt; , versi&amp;oacute;n paralela efectiva del est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;inner_product&quot;&gt;std::inner_product&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8a1464ca469f44a3064f6e7b09b363ce619c9a97" translate="yes" xml:space="preserve">
          <source>1) Equivalent to:</source>
          <target state="translated">1)Equivalente a:</target>
        </trans-unit>
        <trans-unit id="f32c1f81db0f32f22596c137532eaf553b842a7b" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return b = b &amp;lt;&amp;lt; shift;&lt;/code&gt; This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1) Equivalente a: &lt;code&gt;return b = b &amp;lt;&amp;lt; shift;&lt;/code&gt; Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; es verdadero.</target>
        </trans-unit>
        <trans-unit id="ce50226b3eed2748aea0ee2f4a0f21490b16d346" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return l = l | r;&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a: &lt;code&gt;return l = l | r;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a824e001a18c6b6d534ce889aabe17e30fbd0108" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;lt;&amp;lt; shift);&lt;/code&gt; This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">1) Equivalente a: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(b) &amp;lt;&amp;lt; shift);&lt;/code&gt; Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; es verdadero.</target>
        </trans-unit>
        <trans-unit id="50ddbf3ee011e6961ef6494bf423ec3c2c018228" translate="yes" xml:space="preserve">
          <source>1) Equivalent to: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) | static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt;.</source>
          <target state="translated">1) Equivalente a: &lt;code&gt;return std::byte(static_cast&amp;lt;unsigned int&amp;gt;(l) | static_cast&amp;lt;unsigned int&amp;gt;(r));&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b33dd7c481fdd2621d129a0b3503bdf96a3c1775" translate="yes" xml:space="preserve">
          <source>1) Erases all elements that compare equal to &lt;code&gt;value&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.erase(std::remove(c.begin(), c.end(), value), c.end());&lt;/code&gt;</source>
          <target state="translated">1) Borra todos los elementos que se comparan igual al &lt;code&gt;value&lt;/code&gt; del contenedor. Equivalente a &lt;code&gt;c.erase(std::remove(c.begin(), c.end(), value), c.end());&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0cb1efcdcc78f435229d9add9af0fde373e753a3" translate="yes" xml:space="preserve">
          <source>1) Erases all elements that compare equal to &lt;code&gt;value&lt;/code&gt; from the container. Equivalent to &lt;code&gt;c.remove_if([&amp;amp;](auto&amp;amp; elem) { return elem == value; });&lt;/code&gt;</source>
          <target state="translated">1) Borra todos los elementos que se comparan igual al &lt;code&gt;value&lt;/code&gt; del contenedor. Equivalente a &lt;code&gt;c.remove_if([&amp;amp;](auto&amp;amp; elem) { return elem == value; });&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1797656c42e6ae99b3e7edb8a97b39fe346fd5bd" translate="yes" xml:space="preserve">
          <source>1) Evaluates the expression, terminates the current function and returns the result of the expression to the caller, after &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; to the function return type. The expression is optional in functions whose return type is (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, and disallowed in constructors and in destructors.</source>
          <target state="translated">1) Eval&amp;uacute;a la expresi&amp;oacute;n, finaliza la funci&amp;oacute;n actual y devuelve el resultado de la expresi&amp;oacute;n al llamante, despu&amp;eacute;s de la &lt;a href=&quot;implicit_cast&quot;&gt;conversi&amp;oacute;n impl&amp;iacute;cita&lt;/a&gt; al tipo de retorno de la funci&amp;oacute;n. La expresi&amp;oacute;n es opcional en funciones cuyo tipo de retorno es (posiblemente calificado por cv) &lt;code&gt;void&lt;/code&gt; y no est&amp;aacute; permitido en constructores y destructores.</target>
        </trans-unit>
        <trans-unit id="4a7dddb18cbda7dbc3e902e0510c2c2998153f38" translate="yes" xml:space="preserve">
          <source>1) Exactly &lt;code&gt;N&lt;/code&gt; applications of the predicate and &lt;code&gt;O(N)&lt;/code&gt; swaps if there is enough extra memory. If memory is insufficient, at most &lt;code&gt;N log N&lt;/code&gt; swaps.</source>
          <target state="translated">1) Exactamente &lt;code&gt;N&lt;/code&gt; aplicaciones del predicado y &lt;code&gt;O(N)&lt;/code&gt; intercambia si hay suficiente memoria adicional. Si la memoria es insuficiente, a lo sumo &lt;code&gt;N log N&lt;/code&gt; intercambia.</target>
        </trans-unit>
        <trans-unit id="d85c974f9fac4ed00ac82960b3a7f736c51ad8ce" translate="yes" xml:space="preserve">
          <source>1) Exactly N applications of the predicate. At most N/2 swaps if &lt;code&gt;ForwardIt&lt;/code&gt; meets the requirements of &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, and at most N swaps otherwise.</source>
          <target state="translated">1) Exactamente N aplicaciones del predicado. A lo sumo N / 2 intercambia si &lt;code&gt;ForwardIt&lt;/code&gt; cumple los requisitos de &lt;a href=&quot;../named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; , y a lo sumo N intercambia de otra manera.</target>
        </trans-unit>
        <trans-unit id="3898a5e907961e19d6f3818b3f6c38e485189ef0" translate="yes" xml:space="preserve">
          <source>1) Exchanges elements between range &lt;code&gt;[first1, last1)&lt;/code&gt; and another range starting at &lt;code&gt;first2&lt;/code&gt;.</source>
          <target state="translated">1) Intercambia elementos entre el rango &lt;code&gt;[first1, last1)&lt;/code&gt; y otro rango que comienza en &lt;code&gt;first2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd67e4d55cd7feca04c7b3f2ebf39800dd11361" translate="yes" xml:space="preserve">
          <source>1) Explicit instantiation definition</source>
          <target state="translated">1)Definición de instanciación explícita</target>
        </trans-unit>
        <trans-unit id="06804e68db44d5febdac7eef45d88e3b0a1f984d" translate="yes" xml:space="preserve">
          <source>1) Explicit instantiation definition (without &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; if every non-default template parameter is explicitly specified)</source>
          <target state="translated">1) Definici&amp;oacute;n de instanciaci&amp;oacute;n expl&amp;iacute;cita (sin &lt;a href=&quot;template_argument_deduction&quot;&gt;deducci&amp;oacute;n de argumento de plantilla&lt;/a&gt; si cada par&amp;aacute;metro de plantilla no predeterminado se especifica expl&amp;iacute;citamente)</target>
        </trans-unit>
        <trans-unit id="e49d0053d14d536a2855f480783e3fc7be7596bc" translate="yes" xml:space="preserve">
          <source>1) Explicitly defaulted copy assignment operator that copy assigns the base class (&lt;code&gt;OuterAlloc&lt;/code&gt;, the outer allocator) and all inner allocators.</source>
          <target state="translated">1) El operador de asignaci&amp;oacute;n de copia predeterminado expl&amp;iacute;citamente que copia asigna la clase base ( &lt;code&gt;OuterAlloc&lt;/code&gt; , el asignador externo) y todos los asignadores internos.</target>
        </trans-unit>
        <trans-unit id="a4749611efc7cb267b48bb41ce78225481d0be01" translate="yes" xml:space="preserve">
          <source>1) Fancy pointer overload: If the expression &lt;code&gt;&lt;a href=&quot;pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&amp;lt;Ptr&amp;gt;::to_address(p)&lt;/code&gt; is well-formed, returns the result of that expression. Otherwise, returns &lt;code&gt;std::to_address(p.operator-&amp;gt;())&lt;/code&gt;.</source>
          <target state="translated">1) Sobrecarga de puntero de fantas&amp;iacute;a: si la expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&amp;lt;Ptr&amp;gt;::to_address(p)&lt;/code&gt; est&amp;aacute; bien formada, devuelve el resultado de esa expresi&amp;oacute;n. De lo contrario, devuelve &lt;code&gt;std::to_address(p.operator-&amp;gt;())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7990d512de136056ee815911efb4602f71ddedef" translate="yes" xml:space="preserve">
          <source>1) File permissions information.</source>
          <target state="translated">1)Información sobre los permisos de archivo.</target>
        </trans-unit>
        <trans-unit id="27c1e10d4c10af58dfddd5cff99066596a87eea5" translate="yes" xml:space="preserve">
          <source>1) File type information.</source>
          <target state="translated">1)Información del tipo de archivo.</target>
        </trans-unit>
        <trans-unit id="f4fc5fa63bf321ae1e98780408b5986c98eb7933" translate="yes" xml:space="preserve">
          <source>1) Finds the first character equal to none of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra el primer car&amp;aacute;cter igual a ninguno de los caracteres en &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e79c22b35aadf16bbb2bbdbbd059e4bce47a02e" translate="yes" xml:space="preserve">
          <source>1) Finds the first character equal to one of the characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra el primer car&amp;aacute;cter igual a uno de los caracteres en &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="442f6a60a472a2e1141c1b6fb37c658af721c0e6" translate="yes" xml:space="preserve">
          <source>1) Finds the first character not equal to any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra el primer car&amp;aacute;cter que no es igual a ninguno de los caracteres de &lt;code&gt;v&lt;/code&gt; en esta vista, comenzando en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51cda46cabb3895bd9df4ec43f3daadbc2f64384" translate="yes" xml:space="preserve">
          <source>1) Finds the first occurence of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra la primera aparici&amp;oacute;n de &lt;code&gt;v&lt;/code&gt; en esta vista, comenzando en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd62aaa68509bd9a4fb9fb278bc9c7d8c255380a" translate="yes" xml:space="preserve">
          <source>1) Finds the first occurence of any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra la primera aparici&amp;oacute;n de cualquiera de los caracteres de &lt;code&gt;v&lt;/code&gt; en esta vista, comenzando en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="991eb68c46670361f174f149c9bbff9453009cbe" translate="yes" xml:space="preserve">
          <source>1) Finds the first substring equal to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra la primera subcadena igual a &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6704dbd43b3ce3882e6b0b77ffcd5282c0cd6ca9" translate="yes" xml:space="preserve">
          <source>1) Finds the last character equal to none of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra el &amp;uacute;ltimo car&amp;aacute;cter igual a ninguno de los caracteres en &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce86bceaea369df79d331c69a11951d70d544899" translate="yes" xml:space="preserve">
          <source>1) Finds the last character equal to one of characters in &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra el &amp;uacute;ltimo car&amp;aacute;cter igual a uno de los caracteres en &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70fd55a6b81aaf507648a0cddd92b8c633cda844" translate="yes" xml:space="preserve">
          <source>1) Finds the last character not equal to any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra el &amp;uacute;ltimo car&amp;aacute;cter que no es igual a ninguno de los caracteres de &lt;code&gt;v&lt;/code&gt; en esta vista, comenzando en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a117a35d4790c36ea6419c73a7d006ccff236b7" translate="yes" xml:space="preserve">
          <source>1) Finds the last occurence of &lt;code&gt;v&lt;/code&gt; in this view, starting at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra la &amp;uacute;ltima ocurrencia de &lt;code&gt;v&lt;/code&gt; en esta vista, comenzando en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="950316330142526c0ea12d1cb0ce500d7d27ceb8" translate="yes" xml:space="preserve">
          <source>1) Finds the last occurence of any of the characters of &lt;code&gt;v&lt;/code&gt; in this view, ending at position &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra la &amp;uacute;ltima aparici&amp;oacute;n de cualquiera de los caracteres de &lt;code&gt;v&lt;/code&gt; en esta vista, terminando en la posici&amp;oacute;n &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc6591ef2b8655c84fe527417b8508f21209a752" translate="yes" xml:space="preserve">
          <source>1) Finds the last substring equal to &lt;code&gt;str&lt;/code&gt;.</source>
          <target state="translated">1) Encuentra la &amp;uacute;ltima subcadena igual a &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfb87cff99851f1a19a7bc551155598781e3afd7" translate="yes" xml:space="preserve">
          <source>1) First calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; to close the associated file, then moves the contents of &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;: the put and get buffers, the associated file, the locale, the openmode, the is_open flag, and any other state. After the move, &lt;code&gt;rhs&lt;/code&gt; is not associated with a file and &lt;code&gt;rhs.is_open() == false&lt;/code&gt;.</source>
          <target state="translated">1) Primero llama a &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; para cerrar el archivo asociado, luego mueve el contenido de &lt;code&gt;rhs&lt;/code&gt; a &lt;code&gt;*this&lt;/code&gt; : los buffers put y get, el archivo asociado, la localizaci&amp;oacute;n, el modo abierto, el indicador is_open y cualquier otro estado. Despu&amp;eacute;s del movimiento, &lt;code&gt;rhs&lt;/code&gt; no est&amp;aacute; asociado con un archivo y &lt;code&gt;rhs.is_open() == false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd18b72a5a285015ba6ec06d12d8ef6d1cba7955" translate="yes" xml:space="preserve">
          <source>1) First converts &lt;code&gt;f&lt;/code&gt; to some temporary value &lt;code&gt;m&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../../locale/ctype_base&quot;&gt;std::ctype_base::mask&lt;/a&gt;&lt;/code&gt; in implementation-defined manner</source>
          <target state="translated">1) Primero convierte &lt;code&gt;f&lt;/code&gt; en alg&amp;uacute;n valor temporal &lt;code&gt;m&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../../locale/ctype_base&quot;&gt;std::ctype_base::mask&lt;/a&gt;&lt;/code&gt; de manera definida por la implementaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="66258cec208a65037d1db76ff3382868c359cbe4" translate="yes" xml:space="preserve">
          <source>1) First, &lt;a href=&quot;copy_initialization&quot;&gt;copy-initializes&lt;/a&gt; the</source>
          <target state="translated">1) Primero, &lt;a href=&quot;copy_initialization&quot;&gt;copia-inicializa&lt;/a&gt; el</target>
        </trans-unit>
        <trans-unit id="cd33253b53a6763ed072481c1c0f67e8204b5635" translate="yes" xml:space="preserve">
          <source>1) First, decl-specifier-seq and the declarator are combined as in any &lt;a href=&quot;declarations&quot;&gt;declaration&lt;/a&gt; to determine the type.</source>
          <target state="translated">1) Primero, decl-specifier-seq y el declarador se combinan como en cualquier &lt;a href=&quot;declarations&quot;&gt;declaraci&amp;oacute;n&lt;/a&gt; para determinar el tipo.</target>
        </trans-unit>
        <trans-unit id="24a19262c4d1f80ce9e0dc9caab9f79a6b0bff5b" translate="yes" xml:space="preserve">
          <source>1) Flips all bits (like &lt;code&gt;&lt;a href=&quot;operator_logic&quot;&gt;operator~&lt;/a&gt;&lt;/code&gt;, but in-place)</source>
          <target state="translated">1) Voltea todos los bits (como el &lt;code&gt;&lt;a href=&quot;operator_logic&quot;&gt;operator~&lt;/a&gt;&lt;/code&gt; , pero en el lugar)</target>
        </trans-unit>
        <trans-unit id="5300a7112838d676f5f66db26a00a4959307ece8" translate="yes" xml:space="preserve">
          <source>1) Floating point value identifying the &amp;alpha; parameter</source>
          <target state="translated">1) Valor de coma flotante que identifica el par&amp;aacute;metro &amp;alpha;</target>
        </trans-unit>
        <trans-unit id="0e6b85b611c8ca2ab85cbbefdb0db71abdb9bd30" translate="yes" xml:space="preserve">
          <source>1) For an object of type X using the class member access operator</source>
          <target state="translated">1)Para un objeto de tipo X utilizando el operador de acceso de miembros de la clase</target>
        </trans-unit>
        <trans-unit id="620d62ba1adcb76635cafe39e1be9ff044838905" translate="yes" xml:space="preserve">
          <source>1) For arguments of fundamental type, the associated set of namespaces and classes is empty</source>
          <target state="translated">1)Para los argumentos de tipo fundamental,el conjunto asociado de espacios de nombres y clases está vacío</target>
        </trans-unit>
        <trans-unit id="0c378136ab43e1fdcea07a911ec40f85b088db94" translate="yes" xml:space="preserve">
          <source>1) For every named variable with static or thread-local &lt;a href=&quot;storage_duration&quot;&gt;storage duration&lt;/a&gt;that is not subject to &lt;a href=&quot;constant_initialization&quot;&gt;constant initialization&lt;/a&gt;(since C++14), before any other initialization.</source>
          <target state="translated">1) Para cada variable nombrada con &lt;a href=&quot;storage_duration&quot;&gt;una duraci&amp;oacute;n de almacenamiento&lt;/a&gt; local est&amp;aacute;tico o de subprocesos que no est&amp;eacute; sujeta a &lt;a href=&quot;constant_initialization&quot;&gt;una inicializaci&amp;oacute;n constante&lt;/a&gt; (desde C ++ 14), antes de cualquier otra inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a2228ff5f261316a14c0c628f07410bc975495de" translate="yes" xml:space="preserve">
          <source>1) For the built-in operator, one of the expressions (either expr1 or expr2) must be a glvalue of type &amp;ldquo;array of T&amp;rdquo; or a prvalue of type &amp;ldquo;pointer to T&amp;rdquo;, while the other expression (expr2 or expr1, respectively) must be a prvalue of unscoped enumeration or integral type. The result of this expression has the type &lt;code&gt;T&lt;/code&gt;</source>
          <target state="translated">1) Para el operador integrado, una de las expresiones (ya sea expr1 o expr2) debe ser un valor gl del tipo &amp;ldquo;matriz de T&amp;rdquo; o un valor prva de tipo &amp;ldquo;puntero a T&amp;rdquo;, mientras que la otra expresi&amp;oacute;n (expr2 o expr1, respectivamente) debe ser un valor de enumeraci&amp;oacute;n sin &amp;aacute;mbito o tipo integral. El resultado de esta expresi&amp;oacute;n tiene el tipo &lt;code&gt;T&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="908b6cc5f8feeba46b723cf8345b6e77ca24c647" translate="yes" xml:space="preserve">
          <source>1) For user-defined integer literals</source>
          <target state="translated">1)Para los literales enteros definidos por el usuario</target>
        </trans-unit>
        <trans-unit id="8f2bdea671ba63209e8908fa5f60f318cc0d7593" translate="yes" xml:space="preserve">
          <source>1) Forms lvalue reference to const type of &lt;code&gt;t&lt;/code&gt;</source>
          <target state="translated">1) Forma lvalue referencia al tipo constante de &lt;code&gt;t&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="10e52e4189c8c4f69c3b43f760a5733f16a0cecd" translate="yes" xml:space="preserve">
          <source>1) Forwards lvalues as either lvalues or as rvalues, depending on T</source>
          <target state="translated">1)Transmite los valores l como valores l o como valores r,dependiendo de T</target>
        </trans-unit>
        <trans-unit id="0aa251b9780dd1a068e6af33ad51fdab09a9b853" translate="yes" xml:space="preserve">
          <source>1) Full declaration.</source>
          <target state="translated">1)Declaración completa.</target>
        </trans-unit>
        <trans-unit id="d52437442bfb9b172705dc9281744b3b9dabeae9" translate="yes" xml:space="preserve">
          <source>1) Given &lt;code&gt;current_ptr&lt;/code&gt;, the pointer that was managed by &lt;code&gt;*this&lt;/code&gt;, performs the following actions, in this order:</source>
          <target state="translated">1) Dado &lt;code&gt;current_ptr&lt;/code&gt; , el puntero gestionado por &lt;code&gt;*this&lt;/code&gt; , realiza las siguientes acciones, en este orden:</target>
        </trans-unit>
        <trans-unit id="c25bb4537de07ca2e9c955609fc621b56b5c86ae" translate="yes" xml:space="preserve">
          <source>1) Half the sum of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. No overflow occurs. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have integer type and the sum is odd, the result is rounded towards &lt;code&gt;a&lt;/code&gt;. If &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; have floating-point type, at most one inexact operation occurs.</source>
          <target state="translated">1) La mitad de la suma de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; . No se produce desbordamiento. Si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; tienen el tipo n&amp;uacute;mero entero y la suma es impar, el resultado se redondea hacia &lt;code&gt;a&lt;/code&gt; . Si &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; tienen el tipo de punto flotante, a lo sumo un funcionamiento inexacto ocurre.</target>
        </trans-unit>
        <trans-unit id="389c5e318417b817814b4e4cfab6dc113e1fc480" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;*this&lt;/code&gt; contains a value before the call, the contained value is destroyed by calling its destructor as if by &lt;code&gt;value().T::~T()&lt;/code&gt;. &lt;code&gt;*this&lt;/code&gt; does not contain a value after this call.</source>
          <target state="translated">1) Si &lt;code&gt;*this&lt;/code&gt; contiene un valor antes de la llamada, el valor contenido se destruye llamando a su destructor como si fuera por &lt;code&gt;value().T::~T()&lt;/code&gt; . &lt;code&gt;*this&lt;/code&gt; no contiene un valor despu&amp;eacute;s de esta llamada.</target>
        </trans-unit>
        <trans-unit id="5c29eb73572b5b54b5bde81bc8cece3cd885b3b2" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt; is not satisfied, the copy assignment operator's body is equivalent to &lt;code&gt;if (other) emplace(*other); else reset(); return *this;&lt;/code&gt;.</source>
          <target state="translated">1) Si &lt;code&gt;&lt;a href=&quot;../concepts/assignable&quot;&gt;Assignable&lt;/a&gt;&amp;lt;T&amp;amp;, const T&amp;amp;&amp;gt;&lt;/code&gt; no est&amp;aacute; satisfecho, el cuerpo del operador de asignaci&amp;oacute;n de copia es equivalente a &lt;code&gt;if (other) emplace(*other); else reset(); return *this;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d43ce007d320a6fcb3a66694c64b2aa6772b3c7" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; stores a copy of the caught exception and if the copy constructor of the exception object caught by &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; throws an exception, the captured exception is an instance of &lt;code&gt;std::bad_exception&lt;/code&gt;.</source>
          <target state="translated">1) Si &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; almacena una copia de la excepci&amp;oacute;n capturada y si el constructor de copia del objeto de excepci&amp;oacute;n capturado por &lt;code&gt;&lt;a href=&quot;current_exception&quot;&gt;std::current_exception&lt;/a&gt;&lt;/code&gt; arroja una excepci&amp;oacute;n, la excepci&amp;oacute;n capturada es una instancia de &lt;code&gt;std::bad_exception&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="871b74ba2e944632eb24642e2095fcaae5540862" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) Si &lt;code&gt;&lt;a href=&quot;is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; ; de lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2558dfd99cfdc502e01a5c094f7431492308ad2e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;P&lt;/code&gt; is a reference type, the deduced &lt;code&gt;A&lt;/code&gt; (i.e., the type referred to by the reference) can be more cv-qualified than the transformed &lt;code&gt;A&lt;/code&gt;:</source>
          <target state="translated">1) Si &lt;code&gt;P&lt;/code&gt; es un tipo de referencia, el &lt;code&gt;A&lt;/code&gt; deducido (es decir, el tipo al que hace referencia la referencia) puede ser m&amp;aacute;s calificado por cv que el &lt;code&gt;A&lt;/code&gt; transformado :</target>
        </trans-unit>
        <trans-unit id="e6b573b161e778f9527a59ca867befe70e44b598" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;P&lt;/code&gt; is not a reference type,</source>
          <target state="translated">1) Si &lt;code&gt;P&lt;/code&gt; no es un tipo de referencia,</target>
        </trans-unit>
        <trans-unit id="6f224d7d59ccb2a0648c9f79474f4f6215450b64" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; for some type &lt;code&gt;U&lt;/code&gt;, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;U&amp;amp;&lt;/code&gt;; otherwise, provides a member typedef &lt;code&gt;type&lt;/code&gt; that names &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) Si &lt;code&gt;T&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;U&amp;gt;&lt;/code&gt; para alg&amp;uacute;n tipo &lt;code&gt;U&lt;/code&gt; , proporciona un miembro typedef &lt;code&gt;type&lt;/code&gt; que nombra &lt;code&gt;U&amp;amp;&lt;/code&gt; ; de lo contrario, proporciona un miembro de typedef &lt;code&gt;type&lt;/code&gt; que los nombres de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="533c4f52ff1cea4318aa8c59d1192a5f19648e8c" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) Si &lt;code&gt;T&lt;/code&gt; es un tipo de referencia, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46015a38f56b223eca9255c907b1367791f0fb7e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is an object or reference type and the variable definition &lt;code&gt;T obj(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...);&lt;/code&gt; is well-formed, provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. In all other cases, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) Si &lt;code&gt;T&lt;/code&gt; es un objeto o tipo de referencia y la definici&amp;oacute;n variable &lt;code&gt;T obj(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;Args&amp;gt;()...);&lt;/code&gt; est&amp;aacute; bien formado, proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . En todos los dem&amp;aacute;s casos, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3b72851ab3519141cf487432144a3f31b79335b" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is an object type or a function type that has no cv- or ref- qualifier, provides a member typedef &lt;code&gt;type&lt;/code&gt; which is &lt;code&gt;T&amp;amp;&lt;/code&gt;. If &lt;code&gt;T&lt;/code&gt; is an rvalue reference to some type &lt;code&gt;U&lt;/code&gt;, then &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;U&amp;amp;&lt;/code&gt;. Otherwise, &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) Si &lt;code&gt;T&lt;/code&gt; es un tipo de objeto o un tipo de funci&amp;oacute;n que no tiene un calificador cv o ref, proporciona un &lt;code&gt;type&lt;/code&gt; miembro tipo def que es &lt;code&gt;T&amp;amp;&lt;/code&gt; . Si &lt;code&gt;T&lt;/code&gt; es una referencia de valor de alg&amp;uacute;n tipo &lt;code&gt;U&lt;/code&gt; , entonces el &lt;code&gt;type&lt;/code&gt; es &lt;code&gt;U&amp;amp;&lt;/code&gt; . De lo contrario, &lt;code&gt;type&lt;/code&gt; es &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84341e9136029ad471cfa5b9061bb952f1306ba2" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;T&lt;/code&gt; is not a referenceable type (i.e., possibly cv-qualified &lt;code&gt;void&lt;/code&gt; or a function type with a</source>
          <target state="translated">1) Si &lt;code&gt;T&lt;/code&gt; no es un tipo referenciable (es decir, posiblemente &lt;code&gt;void&lt;/code&gt; calificado por cv o un tipo de funci&amp;oacute;n con un</target>
        </trans-unit>
        <trans-unit id="55b2f140ddb9e139d3eddb758d445d70f330d38a" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">1) Si &lt;code&gt;bool(lhs) != bool(rhs)&lt;/code&gt; , devuelve &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0a4d89d7c12b3e0fdc5475924278afccc9fcb9a0" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;c==EOF&lt;/code&gt;, does nothing</source>
          <target state="translated">1) Si &lt;code&gt;c==EOF&lt;/code&gt; , no hace nada</target>
        </trans-unit>
        <trans-unit id="48cff9cec5eee4d48df8a56a52bf392dc360ed81" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;e&lt;/code&gt; is a function call expression, and</source>
          <target state="translated">1) Si &lt;code&gt;e&lt;/code&gt; es una expresi&amp;oacute;n de llamada de funci&amp;oacute;n, y</target>
        </trans-unit>
        <trans-unit id="8cb38dc250b911397e4c0873f26f0012d9d8ab6e" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;ok()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, returns a &lt;code&gt;sys_days&lt;/code&gt; that represents the last &lt;code&gt;weekday()&lt;/code&gt; of the &lt;code&gt;year()&lt;/code&gt; and &lt;code&gt;month()&lt;/code&gt;. Otherwise, the returned value is unspecified.</source>
          <target state="translated">1) Si &lt;code&gt;ok()&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , devuelve un &lt;code&gt;sys_days&lt;/code&gt; que representa el &amp;uacute;ltimo &lt;code&gt;weekday()&lt;/code&gt; la semana () del &lt;code&gt;year()&lt;/code&gt; y &lt;code&gt;month()&lt;/code&gt; . De lo contrario, el valor devuelto no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="ae1ac36ae20a2ced74aaccf2496e723144a48341" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;ok()&lt;/code&gt; is true, the return value holds a count of days from the &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; epoch (1970-01-01) to &lt;code&gt;*this&lt;/code&gt;. The result is negative if &lt;code&gt;*this&lt;/code&gt; represent a date prior to it.</source>
          <target state="translated">1) Si &lt;code&gt;ok()&lt;/code&gt; es verdadero, el valor de retorno contiene un recuento de d&amp;iacute;as desde &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::system_clock&lt;/a&gt;&lt;/code&gt; epoch (1970-01-01) hasta &lt;code&gt;*this&lt;/code&gt; . El resultado es negativo si &lt;code&gt;*this&lt;/code&gt; representa una fecha anterior.</target>
        </trans-unit>
        <trans-unit id="775e0551aa7721ab9c56d7c9c8e95ac883de5834" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;p.is_absolute() || (p.has_root_name() &amp;amp;&amp;amp; p.root_name() != root_name())&lt;/code&gt;, then replaces the current path with p as if by &lt;code&gt;operator=(p)&lt;/code&gt; and finishes.</source>
          <target state="translated">1) Si &lt;code&gt;p.is_absolute() || (p.has_root_name() &amp;amp;&amp;amp; p.root_name() != root_name())&lt;/code&gt; , luego reemplaza la ruta actual con p como si fuera &lt;code&gt;operator=(p)&lt;/code&gt; y finaliza.</target>
        </trans-unit>
        <trans-unit id="5df1170b75f3b245eb679518c7086990da875b8a" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;pos == size()&lt;/code&gt;, the behavior is undefined. 2) If &lt;code&gt;pos == size()&lt;/code&gt;, a reference to the character with value &lt;code&gt;CharT()&lt;/code&gt; (the null character) is returned.</source>
          <target state="translated">1) Si &lt;code&gt;pos == size()&lt;/code&gt; , el comportamiento es indefinido. 2) Si &lt;code&gt;pos == size()&lt;/code&gt; , se devuelve una referencia al car&amp;aacute;cter con valor &lt;code&gt;CharT()&lt;/code&gt; (el car&amp;aacute;cter nulo).</target>
        </trans-unit>
        <trans-unit id="23b154b4ece6fb3ebf14c379625abd81a94b12f9" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;root_name().native().compare(p.root_name().native())&lt;/code&gt; is nonzero, returns that value.</source>
          <target state="translated">1) Si &lt;code&gt;root_name().native().compare(p.root_name().native())&lt;/code&gt; no es cero, devuelve ese valor.</target>
        </trans-unit>
        <trans-unit id="8adfe00a74db942dc8cc130967e0f6e088361d3c" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;sizeof...(MutexTypes) == 0&lt;/code&gt;, does nothing. Otherwise, If &lt;code&gt;sizeof...(MutexTypes) == 1&lt;/code&gt;, effectively calls &lt;code&gt;m.lock()&lt;/code&gt;. Otherwise, effectively calls &lt;code&gt;&lt;a href=&quot;../lock&quot;&gt;std::lock&lt;/a&gt;(m...)&lt;/code&gt;. The behavior is undefined if one of &lt;code&gt;MutexTypes&lt;/code&gt; is not a recursive mutex and the current thread already owns the corresponding argument in &lt;code&gt;m...&lt;/code&gt;.</source>
          <target state="translated">1) Si &lt;code&gt;sizeof...(MutexTypes) == 0&lt;/code&gt; , no hace nada. De lo contrario, si &lt;code&gt;sizeof...(MutexTypes) == 1&lt;/code&gt; , efectivamente llama a &lt;code&gt;m.lock()&lt;/code&gt; . De lo contrario, efectivamente llama a &lt;code&gt;&lt;a href=&quot;../lock&quot;&gt;std::lock&lt;/a&gt;(m...)&lt;/code&gt; . El comportamiento no est&amp;aacute; definido si uno de &lt;code&gt;MutexTypes&lt;/code&gt; no es un mutex recursivo y el hilo actual ya posee el argumento correspondiente de &lt;code&gt;m...&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5ce02c5f4f1088b1082aa38dc45c7ca3365e6a7f" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;v&lt;/code&gt; compares less than &lt;code&gt;lo&lt;/code&gt;, returns &lt;code&gt;lo&lt;/code&gt;; otherwise if &lt;code&gt;hi&lt;/code&gt; compares less than &lt;code&gt;v&lt;/code&gt;, returns &lt;code&gt;hi&lt;/code&gt;; otherwise returns &lt;code&gt;v&lt;/code&gt;. Uses &lt;code&gt;operator&amp;lt;&lt;/code&gt; to compare the values.</source>
          <target state="translated">1) Si &lt;code&gt;v&lt;/code&gt; se compara menos que &lt;code&gt;lo&lt;/code&gt; , devuelve &lt;code&gt;lo&lt;/code&gt; ; de lo contrario, si &lt;code&gt;hi&lt;/code&gt; compara menos que &lt;code&gt;v&lt;/code&gt; , devuelve &lt;code&gt;hi&lt;/code&gt; ; de lo contrario devuelve &lt;code&gt;v&lt;/code&gt; . Utiliza el &lt;code&gt;operator&amp;lt;&lt;/code&gt; para comparar los valores.</target>
        </trans-unit>
        <trans-unit id="4d06e0518b8e9559ed2e398da1df96960c59c244" translate="yes" xml:space="preserve">
          <source>1) If &lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok() &amp;amp;&amp;amp; weekday().ok()&lt;/code&gt;:</source>
          <target state="translated">1) Si &lt;code&gt;year().ok() &amp;amp;&amp;amp; month().ok() &amp;amp;&amp;amp; weekday().ok()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="953c7b17bedfe4cec3a6964917bcb6dd438c090c" translate="yes" xml:space="preserve">
          <source>1) If a key equivalent to &lt;code&gt;k&lt;/code&gt; already exists in the container, does nothing. Otherwise, behaves like &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; except that the element is constructed as &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt;</source>
          <target state="translated">1) Si ya existe una clave equivalente a &lt;code&gt;k&lt;/code&gt; en el contenedor, no hace nada. De lo contrario, se comporta como &lt;a href=&quot;emplace&quot;&gt;emplace&lt;/a&gt; a excepci&amp;oacute;n de que el elemento se construye como &lt;code&gt;value_type(std::piecewise_construct, std::forward_as_tuple(k), std::forward_as_tuple(std::forward&amp;lt;Args&amp;gt;(args)...))&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="27c9cac424cf306f64712cae4c73131e4ecf8efa" translate="yes" xml:space="preserve">
          <source>1) If an exception is thrown, &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; is called</source>
          <target state="translated">1) Si se produce una excepci&amp;oacute;n, se llama &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="053707ffbcc5a261ff2e9f6e03a44ce4aa6bea54" translate="yes" xml:space="preserve">
          <source>1) If an imaginary struct containing a member object of type &lt;code&gt;T&lt;/code&gt; has a non-deleted destructor, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. For any other type, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) Si una estructura imaginaria que contiene un objeto miembro de tipo &lt;code&gt;T&lt;/code&gt; tiene un destructor no eliminado, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . Para cualquier otro tipo, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c0a2e0ad065651ccf574c46ce2ec1d6a32e799" translate="yes" xml:space="preserve">
          <source>1) If both operands are null pointer constants, the composite pointer type is &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) Si ambos operandos son constantes de puntero nulo, el tipo de puntero compuesto es &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="001a94641182b36fb39ecd7c6f316dc79e18bf05" translate="yes" xml:space="preserve">
          <source>1) If both pointers to member are null member pointer values, they</source>
          <target state="translated">1)Si ambos punteros a miembro son valores de puntero de miembro nulo,ellos</target>
        </trans-unit>
        <trans-unit id="d696aa7c360446c7c92bbb49a9fa4b905e4ea6af" translate="yes" xml:space="preserve">
          <source>1) If either &lt;code&gt;E2&lt;/code&gt; or &lt;code&gt;E3&lt;/code&gt; has type &lt;code&gt;void&lt;/code&gt;, then one of the following must be true, or the program is ill-formed:</source>
          <target state="translated">1) Si &lt;code&gt;E2&lt;/code&gt; o &lt;code&gt;E3&lt;/code&gt; tienen tipo &lt;code&gt;void&lt;/code&gt; , uno de los siguientes debe ser verdadero o el programa est&amp;aacute; mal formado:</target>
        </trans-unit>
        <trans-unit id="619b57caddc542baf25a7d1c5e7745307a747df0" translate="yes" xml:space="preserve">
          <source>1) If only one specialization matches the template arguments, that specialization is used</source>
          <target state="translated">1)Si sólo una especialización coincide con los argumentos de la plantilla,esa especialización se utiliza</target>
        </trans-unit>
        <trans-unit id="4ae7d33e86f2455f29507118c461d795dd425ce1" translate="yes" xml:space="preserve">
          <source>1) If permitted, &lt;a href=&quot;constant_initialization&quot;&gt;Constant initialization&lt;/a&gt; takes place first (see &lt;a href=&quot;constant_initialization&quot;&gt;Constant initialization&lt;/a&gt; for the list of those situations). In practice, constant initialization is usually performed at compile time, and pre-calculated object representations are stored as part of the program image. If the compiler doesn't do that, it still has to guarantee that this initialization happens before any dynamic initialization.</source>
          <target state="translated">1) Si est&amp;aacute; permitido, la &lt;a href=&quot;constant_initialization&quot;&gt;inicializaci&amp;oacute;n constante&lt;/a&gt; se realiza primero (consulte &lt;a href=&quot;constant_initialization&quot;&gt;Inicializaci&amp;oacute;n constante&lt;/a&gt; para ver la lista de esas situaciones). En la pr&amp;aacute;ctica, la inicializaci&amp;oacute;n constante generalmente se realiza en tiempo de compilaci&amp;oacute;n, y las representaciones de objetos precalculadas se almacenan como parte de la imagen del programa. Si el compilador no hace eso, a&amp;uacute;n debe garantizar que esta inicializaci&amp;oacute;n ocurra antes de cualquier inicializaci&amp;oacute;n din&amp;aacute;mica.</target>
        </trans-unit>
        <trans-unit id="ec76cf635ed5977262cf9ddcc3fb5fe13eaaff7b" translate="yes" xml:space="preserve">
          <source>1) If set to &lt;code&gt;ON&lt;/code&gt;, informs the compiler that the program will access or modify &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt;, which means that optimizations that could subvert flag tests and mode changes (e.g., global common subexpression elimination, code motion, and constant folding) are prohibited. The default value is implementation-defined, usually &lt;code&gt;OFF&lt;/code&gt;.</source>
          <target state="translated">1) Si se establece en &lt;code&gt;ON&lt;/code&gt; , informa al compilador que el programa acceder&amp;aacute; o modificar&amp;aacute; el &lt;a href=&quot;../numeric/fenv&quot;&gt;entorno de punto flotante&lt;/a&gt; , lo que significa que las optimizaciones que podr&amp;iacute;an subvertir las pruebas de bandera y los cambios de modo (por ejemplo, eliminaci&amp;oacute;n de subexpresi&amp;oacute;n com&amp;uacute;n global, movimiento de c&amp;oacute;digo y plegado constante) prohibido. El valor predeterminado est&amp;aacute; definido por la implementaci&amp;oacute;n, generalmente &lt;code&gt;OFF&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f906d81a6d06437984e964c4636da5851fdcf58f" translate="yes" xml:space="preserve">
          <source>1) If the argument is an unparenthesized &lt;a href=&quot;name&quot;&gt;id-expression&lt;/a&gt; naming a &lt;a href=&quot;structured_binding&quot;&gt;structured binding&lt;/a&gt;, then decltype yields the</source>
          <target state="translated">1) Si el argumento es una expresi&amp;oacute;n &lt;a href=&quot;name&quot;&gt;id sin&lt;/a&gt; par&amp;eacute;ntesis nombrando un &lt;a href=&quot;structured_binding&quot;&gt;enlace estructurado&lt;/a&gt; , entonces decltype produce el</target>
        </trans-unit>
        <trans-unit id="826d68e87870ec49b6a7fffcc26f9ce675d5f52a" translate="yes" xml:space="preserve">
          <source>1) If the constructor is for the most-derived class, virtual base classes are initialized in the order in which they appear in depth-first left-to-right traversal of the base class declarations (left-to-right refers to the appearance in base-specifier lists)</source>
          <target state="translated">1)Si el constructor es para la clase más derivada,las clases base virtuales se inicializan en el orden en que aparecen en profundidad -primero de izquierda a derecha de las declaraciones de clase base (de izquierda a derecha se refiere a la aparición en las listas de especificadores de base)</target>
        </trans-unit>
        <trans-unit id="64bc0d09554e2852fae96f29e67b670b931676e8" translate="yes" xml:space="preserve">
          <source>1) If the current output format is 24-hour, converts to 12-hour time. Otherwise no effects.</source>
          <target state="translated">1)Si el formato de salida actual es de 24 horas,se convierte en tiempo de 12 horas.En caso contrario,no hay efectos.</target>
        </trans-unit>
        <trans-unit id="0f38fe0a520fad6c56ed541e8d99a4cb99844d3f" translate="yes" xml:space="preserve">
          <source>1) If the declaration of &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;pf&lt;/code&gt;, or &lt;code&gt;pmf&lt;/code&gt; uses &lt;code&gt;throw()&lt;/code&gt;(deprecated) or &lt;a href=&quot;noexcept&quot;&gt;noexcept&lt;/a&gt;, the set is empty. 2) Otherwise, if the declaration of &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;pf&lt;/code&gt;, or &lt;code&gt;pmf&lt;/code&gt; uses a dynamic exception specification(deprecated), the set consists of the types listed in that specification 3) Otherwise, the set is the set of all types</source>
          <target state="translated">1) Si la declaraci&amp;oacute;n de &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;pf&lt;/code&gt; o &lt;code&gt;pmf&lt;/code&gt; utiliza &lt;code&gt;throw()&lt;/code&gt; (en desuso) o &lt;a href=&quot;noexcept&quot;&gt;no&lt;/a&gt; , el conjunto est&amp;aacute; vac&amp;iacute;o. 2) De lo contrario, si la declaraci&amp;oacute;n de &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;pf&lt;/code&gt; o &lt;code&gt;pmf&lt;/code&gt; usa una especificaci&amp;oacute;n de excepci&amp;oacute;n din&amp;aacute;mica (en desuso), el conjunto consta de los tipos enumerados en esa especificaci&amp;oacute;n 3) De lo contrario, el conjunto es el conjunto de todos los tipos</target>
        </trans-unit>
        <trans-unit id="f9ccd33ddb11cbe7fee8dbccd1e293df7c5318d1" translate="yes" xml:space="preserve">
          <source>1) If the expression &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() = &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;()&lt;/code&gt; is well-formed in unevaluated context, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to either type.</source>
          <target state="translated">1) Si la expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;() = &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;()&lt;/code&gt; est&amp;aacute; bien formada en un contexto no evaluado, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; . &lt;a href=&quot;../language/access&quot;&gt;Las comprobaciones de acceso&lt;/a&gt; se realizan como si se tratara de un contexto no relacionado con ninguno de los tipos.</target>
        </trans-unit>
        <trans-unit id="3daeab1387736a2e7813fdad3d2e852a5f18e577" translate="yes" xml:space="preserve">
          <source>1) If the expressions &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; and &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&lt;/code&gt; are both well-formed in unevaluated context after &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;;&lt;/code&gt; (see &lt;a href=&quot;../named_req/swappable&quot;&gt;Swappable&lt;/a&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. &lt;a href=&quot;../language/access&quot;&gt;Access checks&lt;/a&gt; are performed as if from a context unrelated to either type.</source>
          <target state="translated">1) Si las expresiones &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;())&lt;/code&gt; y &lt;code&gt;swap(&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;U&amp;gt;(), &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;T&amp;gt;())&lt;/code&gt; ambos est&amp;aacute;n bien formados en un contexto no evaluado despu&amp;eacute;s de &lt;code&gt;using &lt;a href=&quot;../algorithm/swap&quot;&gt;std::swap&lt;/a&gt;;&lt;/code&gt; (ver &lt;a href=&quot;../named_req/swappable&quot;&gt;Intercambiable&lt;/a&gt; ), proporciona al miembro un &lt;code&gt;value&lt;/code&gt; constante igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; . &lt;a href=&quot;../language/access&quot;&gt;Las comprobaciones de acceso&lt;/a&gt; se realizan como si se tratara de un contexto no relacionado con ninguno de los tipos.</target>
        </trans-unit>
        <trans-unit id="45059787b4fa742a740d89cbe94d8b03372e1106" translate="yes" xml:space="preserve">
          <source>1) If the imaginary function definition &lt;code&gt;To test() { return &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;(); }&lt;/code&gt; is well-formed, (that is, either &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;()&lt;/code&gt; can be converted to &lt;code&gt;To&lt;/code&gt; using &lt;a href=&quot;../language/implicit_cast&quot;&gt;implicit conversions&lt;/a&gt;, or both &lt;code&gt;From&lt;/code&gt; and &lt;code&gt;To&lt;/code&gt; are possibly cv-qualified &lt;code&gt;void&lt;/code&gt;), provides the member constant &lt;code&gt;value&lt;/code&gt; equal to &lt;code&gt;true&lt;/code&gt;. Otherwise &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;. For the purposes of this check, the use of &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; in the return statement is not considered an &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;odr-use&lt;/a&gt;.</source>
          <target state="translated">1) Si la definici&amp;oacute;n de funci&amp;oacute;n imaginaria &lt;code&gt;To test() { return &lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;(); }&lt;/code&gt; est&amp;aacute; bien formado (es decir, &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&amp;lt;From&amp;gt;()&lt;/code&gt; se puede convertir a &lt;code&gt;To&lt;/code&gt; usando &lt;a href=&quot;../language/implicit_cast&quot;&gt;conversiones impl&amp;iacute;citas&lt;/a&gt; , o &lt;code&gt;From&lt;/code&gt; y &lt;code&gt;To&lt;/code&gt; son posiblemente &lt;code&gt;void&lt;/code&gt; calificados por cv ), proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; . A los fines de esta verificaci&amp;oacute;n, el uso de &lt;code&gt;&lt;a href=&quot;../utility/declval&quot;&gt;std::declval&lt;/a&gt;&lt;/code&gt; en la declaraci&amp;oacute;n de devoluci&amp;oacute;n no se considera un &lt;a href=&quot;../language/definition#ODR-use&quot;&gt;uso de odr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6f0b8672e5f29b8486f7709d207643d87be596d9" translate="yes" xml:space="preserve">
          <source>1) If the input sequence has a read position available (&lt;code&gt;egptr() &amp;gt; gptr()&lt;/code&gt;), returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</source>
          <target state="translated">1) Si la secuencia de entrada tiene una posici&amp;oacute;n de lectura disponible (por &lt;code&gt;egptr() &amp;gt; gptr()&lt;/code&gt; ), devuelve &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c32163286e69234ea02701a99ebdecfd40c8e43" translate="yes" xml:space="preserve">
          <source>1) If the next pointer is null, the operation fails</source>
          <target state="translated">1)Si el siguiente puntero es nulo,la operación falla</target>
        </trans-unit>
        <trans-unit id="91c47dc3e02728253e0cce0bb00f6bc9a4d38d28" translate="yes" xml:space="preserve">
          <source>1) If the operand is an lvalue expression of some object or function type &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;operator&amp;amp;&lt;/code&gt; creates and returns a prvalue of type &lt;code&gt;T*&lt;/code&gt;, with the same cv qualification, that is pointing to the object or function designated by the operand. If the operand has incomplete type, the pointer can be formed, but if that incomplete type happens to be a class that defines its own &lt;code&gt;operator&amp;amp;&lt;/code&gt;, the behavior is undefined(until C++14)it is unspecified whether the built-in or the overload is used(since C++14). For the operands of type with user-defined &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; may be used to obtain the true pointer.</source>
          <target state="translated">1) Si el operando es una expresi&amp;oacute;n lvalue de alg&amp;uacute;n objeto o funci&amp;oacute;n tipo &lt;code&gt;T&lt;/code&gt; , &lt;code&gt;operator&amp;amp;&lt;/code&gt; crea y devuelve un prvalue de tipo &lt;code&gt;T*&lt;/code&gt; , con la misma calificaci&amp;oacute;n de cv, que apunta al objeto o funci&amp;oacute;n designado por el operando. Si el operando tiene un tipo incompleto, el puntero se puede formar, pero si ese tipo incompleto es una clase que define su propio &lt;code&gt;operator&amp;amp;&lt;/code&gt; , el comportamiento es indefinido (hasta C ++ 14) no se especifica si el incorporado o el se usa sobrecarga (desde C ++ 14). Para los operandos de tipo con &lt;code&gt;operator&amp;amp;&lt;/code&gt; definido por el usuario &amp;amp; , &lt;code&gt;&lt;a href=&quot;../memory/addressof&quot;&gt;std::addressof&lt;/a&gt;&lt;/code&gt; puede usarse para obtener el puntero verdadero.</target>
        </trans-unit>
        <trans-unit id="a1256320cbee9651ed515f01789527567a38d98e" translate="yes" xml:space="preserve">
          <source>1) If the path is empty, stop (normal form of an empty path is an empty path)</source>
          <target state="translated">1)Si el camino está vacío,deténgase (la forma normal de un camino vacío es un camino vacío)</target>
        </trans-unit>
        <trans-unit id="582111318ab00f1208e85c21c22bca92315c07e6" translate="yes" xml:space="preserve">
          <source>1) If the pointer to be repositioned is a null pointer and the new offset &lt;code&gt;newoff&lt;/code&gt; would be non-zero, this function fails.</source>
          <target state="translated">1) Si el puntero que se va a reposicionar es un puntero nulo y el nuevo desplazamiento &lt;code&gt;newoff&lt;/code&gt; ser&amp;iacute;a distinto de cero, esta funci&amp;oacute;n falla.</target>
        </trans-unit>
        <trans-unit id="fe93a7c23cff4516602f15cbb778ed98afe55fb4" translate="yes" xml:space="preserve">
          <source>1) If the pointers are both null pointer values, they</source>
          <target state="translated">1)Si los punteros son ambos valores de punteros nulos,ellos</target>
        </trans-unit>
        <trans-unit id="fc198593bd9ec378434428d9afd2c41063e2a0a5" translate="yes" xml:space="preserve">
          <source>1) If the type of expression is exactly new_type or a less cv-qualified version of new_type, the result is the value of expression, with type new_type. (In other words, &lt;code&gt;dynamic_cast&lt;/code&gt; can be used to add constness. An implicit conversion and &lt;code&gt;static_cast&lt;/code&gt; can perform this conversion as well.)</source>
          <target state="translated">1) Si el tipo de expresi&amp;oacute;n es exactamente new_type o una versi&amp;oacute;n menos calificada por cv de new_type, el resultado es el valor de expresi&amp;oacute;n, con el tipo new_type. (En otras palabras, &lt;code&gt;dynamic_cast&lt;/code&gt; se puede usar para agregar constness. Una conversi&amp;oacute;n impl&amp;iacute;cita y &lt;code&gt;static_cast&lt;/code&gt; tambi&amp;eacute;n pueden realizar esta conversi&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="81e1b3a4903489b6c6f5290600d72bbbee763b8f" translate="yes" xml:space="preserve">
          <source>1) If the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; stores the same &lt;code&gt;T*&lt;/code&gt; as &lt;code&gt;expected&lt;/code&gt; and shares ownership with it, or if both underlying and &lt;code&gt;expected&lt;/code&gt; are empty, assigns from &lt;code&gt;desired&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;, and orders memory according to &lt;code&gt;success&lt;/code&gt;, otherwise assigns from the underlying &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;expected&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;, and orders memory according to &lt;code&gt;failure&lt;/code&gt;. The behavior is undefined if &lt;code&gt;failure&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;. On success, the operation is an atomic read-modify-write operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is not accessed after the atomic update. On failure, the operation is an atomic load operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is updated with the existing value read from the atomic object. This update to &lt;code&gt;expected&lt;/code&gt;'s use_count is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.</source>
          <target state="translated">1) Si el &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; subyacente almacena el mismo &lt;code&gt;T*&lt;/code&gt; como se &lt;code&gt;expected&lt;/code&gt; y comparte la propiedad con &amp;eacute;l, o si tanto el subyacente como el &lt;code&gt;expected&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, se asigna de &lt;code&gt;desired&lt;/code&gt; al &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; subyacente , devuelve &lt;code&gt;true&lt;/code&gt; y ordena la memoria seg&amp;uacute;n el &lt;code&gt;success&lt;/code&gt; ; de lo contrario, se asigna desde el &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; subyacente al &lt;code&gt;expected&lt;/code&gt; , devuelve &lt;code&gt;false&lt;/code&gt; y ordena la memoria seg&amp;uacute;n el &lt;code&gt;failure&lt;/code&gt; . El comportamiento es indefinido si la &lt;code&gt;failure&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; . En caso de &amp;eacute;xito, la operaci&amp;oacute;n es una operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura at&amp;oacute;mica en &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;expected&lt;/code&gt; no se accede despu&amp;eacute;s de la actualizaci&amp;oacute;n at&amp;oacute;mica. En caso de fallo, la operaci&amp;oacute;n es una operaci&amp;oacute;n de carga at&amp;oacute;mica en &lt;code&gt;*this&lt;/code&gt; y se &lt;code&gt;expected&lt;/code&gt; se actualice con el valor existente le&amp;iacute;do del objeto at&amp;oacute;mico. Esta actualizaci&amp;oacute;n de &lt;code&gt;expected&lt;/code&gt; use_count 's es parte de esta operaci&amp;oacute;n at&amp;oacute;mica, aunque la escritura en s&amp;iacute; (y cualquier subsiguiente cancelaci&amp;oacute;n de asignaci&amp;oacute;n / destrucci&amp;oacute;n) no est&amp;aacute; obligado a ser.</target>
        </trans-unit>
        <trans-unit id="debd587f8b5b3f706f78c4d8eb91989d3f630fe5" translate="yes" xml:space="preserve">
          <source>1) If the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; stores the same pointer value as &lt;code&gt;expected&lt;/code&gt; and shares ownership with it, or if both underlying and &lt;code&gt;expected&lt;/code&gt; are empty, assigns from &lt;code&gt;desired&lt;/code&gt; to the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;, returns &lt;code&gt;true&lt;/code&gt;, and orders memory according to &lt;code&gt;success&lt;/code&gt;, otherwise assigns from the underlying &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;expected&lt;/code&gt;, returns &lt;code&gt;false&lt;/code&gt;, and orders memory according to &lt;code&gt;failure&lt;/code&gt;. The behavior is undefined if &lt;code&gt;failure&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt;. On success, the operation is an atomic read-modify-write operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is not accessed after the atomic update. On failure, the operation is an atomic load operation on &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;expected&lt;/code&gt; is updated with the existing value read from the atomic object. This update to &lt;code&gt;expected&lt;/code&gt;'s use_count is part of this atomic operation, although the write itself (and any subsequent deallocation/destruction) is not required to be.</source>
          <target state="translated">1) Si el &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; subyacente almacena el mismo valor de puntero que el &lt;code&gt;expected&lt;/code&gt; y comparte con &amp;eacute;l la propiedad, o si tanto el subyacente como el &lt;code&gt;expected&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, se asigna de &lt;code&gt;desired&lt;/code&gt; al &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; subyacente , devuelve &lt;code&gt;true&lt;/code&gt; y ordena la memoria seg&amp;uacute;n el &lt;code&gt;success&lt;/code&gt; ; de lo contrario, se asigna desde el &lt;code&gt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; subyacente al &lt;code&gt;expected&lt;/code&gt; , devuelve &lt;code&gt;false&lt;/code&gt; y ordena la memoria seg&amp;uacute;n el &lt;code&gt;failure&lt;/code&gt; . El comportamiento es indefinido si la &lt;code&gt;failure&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_release&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../atomic/memory_order&quot;&gt;std::memory_order_acq_rel&lt;/a&gt;&lt;/code&gt; . En caso de &amp;eacute;xito, la operaci&amp;oacute;n es una operaci&amp;oacute;n de lectura-modificaci&amp;oacute;n-escritura at&amp;oacute;mica en &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;expected&lt;/code&gt; no se accede despu&amp;eacute;s de la actualizaci&amp;oacute;n at&amp;oacute;mica. En caso de fallo, la operaci&amp;oacute;n es una operaci&amp;oacute;n de carga at&amp;oacute;mica en &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;expected&lt;/code&gt; se actualiza con el valor existente leer desde el objeto at&amp;oacute;mica. Esta actualizaci&amp;oacute;n de la cuenta de uso &lt;code&gt;expected&lt;/code&gt; es parte de esta operaci&amp;oacute;n at&amp;oacute;mica, aunque no se requiere que la escritura misma (y cualquier desasignaci&amp;oacute;n / destrucci&amp;oacute;n posterior) sea.</target>
        </trans-unit>
        <trans-unit id="e34721beb2d7e5dc88963d3e677eec93a6ef94e9" translate="yes" xml:space="preserve">
          <source>1) If there are &lt;code&gt;M&lt;/code&gt; arguments, the candidate function that has exactly &lt;code&gt;M&lt;/code&gt; parameters is viable</source>
          <target state="translated">1) Si hay &lt;code&gt;M&lt;/code&gt; argumentos, la funci&amp;oacute;n candidata que tiene exactamente &lt;code&gt;M&lt;/code&gt; par&amp;aacute;metros es viable</target>
        </trans-unit>
        <trans-unit id="ec64a20a9d24c39e596bf41c76e737d99a86058d" translate="yes" xml:space="preserve">
          <source>1) If there is an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion sequence&lt;/a&gt; from expression to new_type, or if overload resolution for a &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; of an object or reference of type new_type from expression would find at least one viable function, then &lt;code&gt;static_cast&amp;lt;new_type&amp;gt;(expression)&lt;/code&gt; returns the imaginary variable &lt;code&gt;Temp&lt;/code&gt; initialized as if by &lt;code&gt;new_type Temp(expression);&lt;/code&gt;, which may involve &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt;, a call to the &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; of new_type or a call to a &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion operator&lt;/a&gt;. For non-reference new_type, the result object of the static_cast prvalue expression is what's direct-initialized(since C++17)</source>
          <target state="translated">1) Si hay una &lt;a href=&quot;implicit_cast&quot;&gt;secuencia de conversi&amp;oacute;n impl&amp;iacute;cita&lt;/a&gt; de expresi&amp;oacute;n a nuevo_tipo, o si la resoluci&amp;oacute;n de sobrecarga para una &lt;a href=&quot;direct_initialization&quot;&gt;inicializaci&amp;oacute;n directa&lt;/a&gt; de un objeto o referencia de tipo nuevo_tipo de expresi&amp;oacute;n encontrar&amp;iacute;a al menos una funci&amp;oacute;n viable, entonces &lt;code&gt;static_cast&amp;lt;new_type&amp;gt;(expression)&lt;/code&gt; devuelve el variable imaginaria &lt;code&gt;Temp&lt;/code&gt; inicializada como si fuera por &lt;code&gt;new_type Temp(expression);&lt;/code&gt; , que puede implicar &lt;a href=&quot;implicit_cast&quot;&gt;conversiones impl&amp;iacute;citas&lt;/a&gt; , una llamada al &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; de new_type o una llamada a un &lt;a href=&quot;cast_operator&quot;&gt;operador de conversi&amp;oacute;n definido por el usuario&lt;/a&gt; . Para new_type sin referencia, el objeto resultante de la expresi&amp;oacute;n prvalue static_cast es lo que se inicializa directamente (desde C ++ 17)</target>
        </trans-unit>
        <trans-unit id="5e61488d7d7b15353ad536c26150cc3f3d9dfc2a" translate="yes" xml:space="preserve">
          <source>1) If two pointers point to different elements of the same array, or to subobjects within different elements of the same array, the pointer to the element with the higher subscript</source>
          <target state="translated">1)Si dos punteros apuntan a diferentes elementos de la misma matriz,o a subobjetos dentro de diferentes elementos de la misma matriz,el puntero al elemento con el subíndice superior</target>
        </trans-unit>
        <trans-unit id="a1ef97817e3de9be1ea70784e7655c53546a2dc5" translate="yes" xml:space="preserve">
          <source>1) Ignores all elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) Ignora todos los elementos que son iguales al &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e94af7fe131aa943bb89af9451c2c83b03715052" translate="yes" xml:space="preserve">
          <source>1) Implements &lt;code&gt;operator!=&lt;/code&gt; in terms of &lt;code&gt;operator==&lt;/code&gt;.</source>
          <target state="translated">1) Implementa &lt;code&gt;operator!=&lt;/code&gt; En t&amp;eacute;rminos de &lt;code&gt;operator==&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dab585f3da6ef91bb449ba583df62136d68e6d58" translate="yes" xml:space="preserve">
          <source>1) Implicitly declared default constructor.</source>
          <target state="translated">1)Constructora implícitamente declarada en rebeldía.</target>
        </trans-unit>
        <trans-unit id="5c681d4553e954943a32a867bbdf85235d7bbe9b" translate="yes" xml:space="preserve">
          <source>1) In a member function declaration, &lt;code&gt;final&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator, and before the &lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;, if used.</source>
          <target state="translated">1) En una declaraci&amp;oacute;n de funci&amp;oacute;n miembro, &lt;code&gt;final&lt;/code&gt; puede aparecer en virt-specifier-seq inmediatamente despu&amp;eacute;s del declarador, y antes del &lt;a href=&quot;abstract_class&quot;&gt;especificador puro&lt;/a&gt; , si se usa.</target>
        </trans-unit>
        <trans-unit id="e87713d6a39f4e0ea9a3dfa0acccc59bf85daffe" translate="yes" xml:space="preserve">
          <source>1) In a member function declaration, &lt;code&gt;override&lt;/code&gt; may appear in virt-specifier-seq immediately after the declarator, and before the &lt;a href=&quot;abstract_class&quot;&gt;pure-specifier&lt;/a&gt;, if used.</source>
          <target state="translated">1) En una declaraci&amp;oacute;n de funci&amp;oacute;n miembro, la &lt;code&gt;override&lt;/code&gt; puede aparecer en virt-specifier-seq inmediatamente despu&amp;eacute;s del declarador, y antes del &lt;a href=&quot;abstract_class&quot;&gt;especificador puro&lt;/a&gt; , si se usa.</target>
        </trans-unit>
        <trans-unit id="b7f2af54ab23b9453df13b695a120657cdbb78f5" translate="yes" xml:space="preserve">
          <source>1) In the &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt; of the constructor.</source>
          <target state="translated">1) En la &lt;a href=&quot;constructor&quot;&gt;lista&lt;/a&gt; de inicializador de miembros del constructor.</target>
        </trans-unit>
        <trans-unit id="ad85e856c86edd9721a76169fb3382fbd0691a1a" translate="yes" xml:space="preserve">
          <source>1) Index-based non-throwing accessor: If &lt;code&gt;pv&lt;/code&gt; is not a null pointer and &lt;code&gt;pv-&amp;gt;index() == I&lt;/code&gt;, returns a pointer to the value stored in the variant pointed to by &lt;code&gt;pv&lt;/code&gt;. Otherwise, returns a null pointer value. The call is ill-formed if &lt;code&gt;I&lt;/code&gt; is not a valid index in the variant.</source>
          <target state="translated">1) &lt;code&gt;pv-&amp;gt;index() == I&lt;/code&gt; lanzamiento no basado en &amp;iacute;ndice: si &lt;code&gt;pv&lt;/code&gt; no es un puntero nulo y pv-&amp;gt; index () == I , devuelve un puntero al valor almacenado en la variante apuntada por &lt;code&gt;pv&lt;/code&gt; . De lo contrario, devuelve un valor de puntero nulo. La llamada est&amp;aacute; mal formada si &lt;code&gt;I&lt;/code&gt; no es un &amp;iacute;ndice v&amp;aacute;lido en la variante.</target>
        </trans-unit>
        <trans-unit id="9aabcbed245a33739cb3035c8ee0b94c11b43add" translate="yes" xml:space="preserve">
          <source>1) Index-based value accessor: If &lt;code&gt;v.index() == I&lt;/code&gt;, returns a reference to the value stored in &lt;code&gt;v&lt;/code&gt;. Otherwise, throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt;. The call is ill-formed if &lt;code&gt;I&lt;/code&gt; is not a valid index in the variant.</source>
          <target state="translated">1) &lt;code&gt;v.index() == I&lt;/code&gt; valor basado en &amp;iacute;ndice: si v.index () == I , devuelve una referencia al valor almacenado en &lt;code&gt;v&lt;/code&gt; . De lo contrario, arroja &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; . La llamada est&amp;aacute; mal formada si &lt;code&gt;I&lt;/code&gt; no es un &amp;iacute;ndice v&amp;aacute;lido en la variante.</target>
        </trans-unit>
        <trans-unit id="af4fb35a5ec3b4df2a4082311967437cd6c9b5db" translate="yes" xml:space="preserve">
          <source>1) Informs a &lt;code&gt;std::basic_string&lt;/code&gt; object of a planned change in size, so that it can manage the storage allocation appropriately.</source>
          <target state="translated">1) Informa a un objeto &lt;code&gt;std::basic_string&lt;/code&gt; de un cambio de tama&amp;ntilde;o planificado, para que pueda administrar la asignaci&amp;oacute;n de almacenamiento de manera adecuada.</target>
        </trans-unit>
        <trans-unit id="c71413d04de99f2d5426060b5049fea7209088cd" translate="yes" xml:space="preserve">
          <source>1) Initializes &lt;code&gt;r_&lt;/code&gt; with &lt;code&gt;nullptr&lt;/code&gt;. A default-initialized &lt;code&gt;ref_view&lt;/code&gt; references no &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">1) Inicializa &lt;code&gt;r_&lt;/code&gt; con &lt;code&gt;nullptr&lt;/code&gt; . Un &lt;code&gt;ref_view&lt;/code&gt; inicializado por defecto no hace referencia a &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d666e6ac7a857628bc04dc566500208a77dfdfa4" translate="yes" xml:space="preserve">
          <source>1) Initializes the accumulator &lt;code&gt;acc&lt;/code&gt; with the initial value &lt;code&gt;init&lt;/code&gt; and then</source>
          <target state="translated">1) Inicializa el acumulador &lt;code&gt;acc&lt;/code&gt; con el valor inicial &lt;code&gt;init&lt;/code&gt; y luego</target>
        </trans-unit>
        <trans-unit id="390208e5ec0095fd5b6b97b7b3f847fcb7002d96" translate="yes" xml:space="preserve">
          <source>1) Initializes the base or member named by class-or-identifier using &lt;a href=&quot;direct_initialization&quot;&gt;direct initialization&lt;/a&gt; or, if expression-list is empty, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt;</source>
          <target state="translated">1) Inicializa la base o miembro nombrado por clase o identificador utilizando &lt;a href=&quot;direct_initialization&quot;&gt;la inicializaci&amp;oacute;n directa&lt;/a&gt; o, si la lista de expresiones est&amp;aacute; vac&amp;iacute;a, &lt;a href=&quot;value_initialization&quot;&gt;la inicializaci&amp;oacute;n del valor&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0738aa8c98109913fcc387730825b9c7aaa58446" translate="yes" xml:space="preserve">
          <source>1) Initializes the contained value by &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initializing&lt;/a&gt; (but not direct-list-initializing) with &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; as parameters.</source>
          <target state="translated">1) Inicializa el valor contenido &lt;a href=&quot;../../language/direct_initialization&quot;&gt;inicializando directamente&lt;/a&gt; (pero no inicializando lista directa) con &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; como par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="55b3a7a556eb22d3fddafb6be7ce6a255efdaa60" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to default-constructed value</source>
          <target state="translated">1) Inicializa el &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;&lt;/code&gt; subyacente al valor predeterminado construido</target>
        </trans-unit>
        <trans-unit id="56d3077b0b0cef44db878906aa8a6c39943f7a5f" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; to default-constructed value</source>
          <target state="translated">1) Inicializa el &lt;code&gt;weak_ptr&amp;lt;T&amp;gt;&lt;/code&gt; subyacente al valor construido por defecto</target>
        </trans-unit>
        <trans-unit id="4ac80d611dc008ae2fce6aea9e7cf692cd5e7b32" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying pointer to container with &lt;code&gt;nullptr&lt;/code&gt; and value-initializes the underlying iterator.</source>
          <target state="translated">1) Inicializa el puntero subyacente al contenedor con &lt;code&gt;nullptr&lt;/code&gt; y el valor inicializa el iterador subyacente.</target>
        </trans-unit>
        <trans-unit id="e37bfcf43e090a94cd623e83017e50e5bca2fc1a" translate="yes" xml:space="preserve">
          <source>1) Initializes the underlying pointer to container with &lt;code&gt;nullptr&lt;/code&gt;.</source>
          <target state="translated">1) Inicializa el puntero subyacente al contenedor con &lt;code&gt;nullptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcd29c5e81afcd584e544f121d5f47dadd0f4de1" translate="yes" xml:space="preserve">
          <source>1) Initializes with streambuf &lt;code&gt;sb&lt;/code&gt;. The base classes are initialized as &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; and &lt;code&gt;basic_ostream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt;. After the call &lt;code&gt;rdbuf() == sb&lt;/code&gt; and &lt;code&gt;gcount() == 0&lt;/code&gt;.</source>
          <target state="translated">1) Inicializa con streambuf &lt;code&gt;sb&lt;/code&gt; . Las clases base se inicializan como &lt;code&gt;basic_istream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; y &lt;code&gt;basic_ostream&amp;lt;CharT,Traits&amp;gt;(sb)&lt;/code&gt; . Despu&amp;eacute;s de la llamada &lt;code&gt;rdbuf() == sb&lt;/code&gt; y &lt;code&gt;gcount() == 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="597197c59314c93c55128912be74ee54b394e721" translate="yes" xml:space="preserve">
          <source>1) Inserts &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt; at the position &lt;code&gt;index&lt;/code&gt;</source>
          <target state="translated">1) Inserta copias de &lt;code&gt;count&lt;/code&gt; de caracteres &lt;code&gt;ch&lt;/code&gt; en el &lt;code&gt;index&lt;/code&gt; posici&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="2f9e626ebe4226924cf0f29adddd15e2078d9dc6" translate="yes" xml:space="preserve">
          <source>1) Inserts &lt;code&gt;value_type(key, T())&lt;/code&gt; if the key does not exist. This function is equivalent to &lt;code&gt;return insert(&lt;a href=&quot;../../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(key, T())).first-&amp;gt;second;&lt;/code&gt;</source>
          <target state="translated">1) Inserta &lt;code&gt;value_type(key, T())&lt;/code&gt; si la clave no existe. Esta funci&amp;oacute;n es equivalente a &lt;code&gt;return insert(&lt;a href=&quot;../../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(key, T())).first-&amp;gt;second;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1bbcdba0d1f411974c0900c76adfb06fb4ddf41c" translate="yes" xml:space="preserve">
          <source>1) Inserts a &lt;code&gt;value_type&lt;/code&gt; object constructed in-place from &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; if the key does not exist.  This function is equivalent to &lt;code&gt;return this-&amp;gt;try_emplace(key).first-&amp;gt;second;&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1) Inserta un objeto &lt;code&gt;value_type&lt;/code&gt; construido en el lugar a partir de &lt;code&gt;&lt;a href=&quot;../../utility/piecewise_construct&quot;&gt;std::piecewise_construct&lt;/a&gt;, &lt;a href=&quot;../../utility/tuple/forward_as_tuple&quot;&gt;std::forward_as_tuple&lt;/a&gt;(key), &lt;a href=&quot;../../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;()&lt;/code&gt; si la clave no existe. Esta funci&amp;oacute;n es equivalente a &lt;code&gt;return this-&amp;gt;try_emplace(key).first-&amp;gt;second;&lt;/code&gt; . (desde C ++ 17)</target>
        </trans-unit>
        <trans-unit id="1ed499190167ff7f4a4dca5f353727adf6c5d67d" translate="yes" xml:space="preserve">
          <source>1) Integer formatters: &lt;code&gt;value&lt;/code&gt; is converted to a string of digits in the given &lt;code&gt;base&lt;/code&gt; (with no redundant leading zeroes). Digits in the range &lt;code&gt;10..35&lt;/code&gt; (inclusive) are represented as lowercase characters &lt;code&gt;a..z&lt;/code&gt;. If value is less than zero, the representation starts with a minus sign. The library provides overloads for all signed and unsigned integer types and for the type &lt;code&gt;char&lt;/code&gt; as the type of the parameter &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) Formateadores enteros: el &lt;code&gt;value&lt;/code&gt; se convierte en una cadena de d&amp;iacute;gitos en la &lt;code&gt;base&lt;/code&gt; dada (sin ceros iniciales redundantes). Los d&amp;iacute;gitos en el rango de &lt;code&gt;10..35&lt;/code&gt; (inclusive) se representan como caracteres en min&amp;uacute;scula &lt;code&gt;a..z&lt;/code&gt; . Si el valor es menor que cero, la representaci&amp;oacute;n comienza con un signo menos. La biblioteca proporciona sobrecargas para todos los tipos enteros con y sin signo y para el tipo &lt;code&gt;char&lt;/code&gt; como el tipo del &lt;code&gt;value&lt;/code&gt; par&amp;aacute;metro .</target>
        </trans-unit>
        <trans-unit id="2cd742de2bf8d435baa1eb1ba04960df29830e0c" translate="yes" xml:space="preserve">
          <source>1) Integer parsers: Expects the pattern identical to the one used by &lt;code&gt;&lt;a href=&quot;../string/byte/strtol&quot;&gt;std::strtol&lt;/a&gt;&lt;/code&gt; in the default (&quot;C&quot;) locale and the given non-zero numeric base, except that</source>
          <target state="translated">1) Analizadores enteros: espera el patr&amp;oacute;n id&amp;eacute;ntico al utilizado por &lt;code&gt;&lt;a href=&quot;../string/byte/strtol&quot;&gt;std::strtol&lt;/a&gt;&lt;/code&gt; en la configuraci&amp;oacute;n regional predeterminada (&quot;C&quot;) y la base num&amp;eacute;rica no cero dada, excepto que</target>
        </trans-unit>
        <trans-unit id="8a213779ff6418b03ee0523325685afdc5d484b9" translate="yes" xml:space="preserve">
          <source>1) It cannot be used anywhere in the program</source>
          <target state="translated">1)No puede ser usado en ninguna parte del programa</target>
        </trans-unit>
        <trans-unit id="52283fc726cca49a55017924c746b83c68a86057" translate="yes" xml:space="preserve">
          <source>1) It must be declared &lt;code&gt;inline&lt;/code&gt; in every translation unit.</source>
          <target state="translated">1) Debe declararse en &lt;code&gt;inline&lt;/code&gt; en cada unidad de traducci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="93c41523dfecbacf0866640c365002e86309d551" translate="yes" xml:space="preserve">
          <source>1) Iterator to the element following the erased one, or &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; if no such element exists.</source>
          <target state="translated">1) Iterador del elemento que sigue al borrado, o &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; si no existe tal elemento.</target>
        </trans-unit>
        <trans-unit id="db998b65059f221b9947c1e2b84b7328aa9c6731" translate="yes" xml:space="preserve">
          <source>1) Iterator to the first element of the path.</source>
          <target state="translated">1)Iterador del primer elemento del camino.</target>
        </trans-unit>
        <trans-unit id="5f63d6bacd5c75bb3d9c40afba52d76d0aa26b7a" translate="yes" xml:space="preserve">
          <source>1) Linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">1) Lineal en &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bad57cdbf49ee5c9cf8b15794f0ba25ea25faaf6" translate="yes" xml:space="preserve">
          <source>1) Linear in the number of characters compared.</source>
          <target state="translated">1)Lineal en el número de caracteres comparados.</target>
        </trans-unit>
        <trans-unit id="bfbdf175b676848b3b112f3b7622116e7ae24018" translate="yes" xml:space="preserve">
          <source>1) Linear in the size of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1) Lineal en el tama&amp;ntilde;o de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae3d9bc82a6c5df2515038c2bc04f8922fb3612d" translate="yes" xml:space="preserve">
          <source>1) Linear in the size of &lt;code&gt;other&lt;/code&gt;</source>
          <target state="translated">1) Lineal en el tama&amp;ntilde;o de &lt;code&gt;other&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b7138a1f54274e2bc82a87855f742eb60f4fcddc" translate="yes" xml:space="preserve">
          <source>1) Literal operators with this parameter list are the</source>
          <target state="translated">1)Los operadores literales con esta lista de parámetros son los</target>
        </trans-unit>
        <trans-unit id="d4f26c9f8811c2aa27521ffafb650efe7f636432" translate="yes" xml:space="preserve">
          <source>1) Literals (e.g. &lt;code&gt;2&lt;/code&gt; or &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt;)</source>
          <target state="translated">1) Literales (por ejemplo, &lt;code&gt;2&lt;/code&gt; o &lt;code&gt;&quot;Hello, world&quot;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="692f0144de0296503caf6eb540cde981dab090e2" translate="yes" xml:space="preserve">
          <source>1) Logical AND (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;). The value for the empty pack is &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1) L&amp;oacute;gico Y ( &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; ). El valor del paquete vac&amp;iacute;o es &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="be220faf928704a940a2cf9ed4835d69e6844ef4" translate="yes" xml:space="preserve">
          <source>1) Logical NOT</source>
          <target state="translated">1)Lógico NO</target>
        </trans-unit>
        <trans-unit id="dad928c0d3430b473633cea25234a47b689119c3" translate="yes" xml:space="preserve">
          <source>1) Manages a single object (e.g. allocated with &lt;code&gt;new&lt;/code&gt;)</source>
          <target state="translated">1) Administra un solo objeto (por ejemplo, asignado con &lt;code&gt;new&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c2dafa4c13c344cdd5b36d49ab1c8f9cb1618f3e" translate="yes" xml:space="preserve">
          <source>1) May throw &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; equal to &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; if the thread has no privilege to create a condition variable, &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; if a non-memory resource limitation prevents this initialization, or another implementation-defined value.</source>
          <target state="translated">1) Puede arrojar &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; con &lt;code&gt;&lt;a href=&quot;../../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; igual a &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt; si el hilo no tiene privilegio para crear una variable de condici&amp;oacute;n, &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; si una limitaci&amp;oacute;n de recursos sin memoria impide esto inicializaci&amp;oacute;n u otro valor definido por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e0f5008a342755f8d0c7df43b3ab66846dd152a1" translate="yes" xml:space="preserve">
          <source>1) May throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; in case of failure, if &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt;.</source>
          <target state="translated">1) Puede arrojar &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; en caso de falla, si hay &lt;code&gt;exceptions() &amp;amp; failbit != 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fec14884289d124fcea9cdbca0e3487bb3fefeab" translate="yes" xml:space="preserve">
          <source>1) May throw any exception thrown by the value initialization of the first alternative.</source>
          <target state="translated">1)Puede lanzar cualquier excepción lanzada por la inicialización del valor de la primera alternativa.</target>
        </trans-unit>
        <trans-unit id="6d9856c647bd6f18f2c4199f99dda0d7103b839f" translate="yes" xml:space="preserve">
          <source>1) Member declarations of the form</source>
          <target state="translated">1)Declaraciones de los miembros del formulario</target>
        </trans-unit>
        <trans-unit id="f54b805bef5f1481100f7bcad5d8d8c57550f520" translate="yes" xml:space="preserve">
          <source>1) Minimum offset between two objects to avoid false sharing. Guaranteed to be at least &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) Desplazamiento m&amp;iacute;nimo entre dos objetos para evitar el intercambio falso. Garantizado para ser al menos &lt;code&gt;alignof(&lt;a href=&quot;../types/max_align_t&quot;&gt;std::max_align_t&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cc024f12038108f0c21d9b9bb7028dab37fcc8fc" translate="yes" xml:space="preserve">
          <source>1) Modifies the &lt;code&gt;&lt;a href=&quot;timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt; object pointed to by &lt;code&gt;ts&lt;/code&gt; to hold the current calendar time in the time base &lt;code&gt;base&lt;/code&gt;.</source>
          <target state="translated">1) modifica el &lt;code&gt;&lt;a href=&quot;timespec&quot;&gt;std::timespec&lt;/a&gt;&lt;/code&gt; objeto apuntado por &lt;code&gt;ts&lt;/code&gt; para mantener el tiempo de calendario actual en la base de tiempo &lt;code&gt;base&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="019c13e7183a754e9d764c5fd9f436c7e5d5c9dd" translate="yes" xml:space="preserve">
          <source>1) Modifying the character array accessed through the const overload of &lt;code&gt;data&lt;/code&gt; has undefined behavior.</source>
          <target state="translated">1) La modificaci&amp;oacute;n de la matriz de caracteres a la que se accede mediante la sobrecarga constante de &lt;code&gt;data&lt;/code&gt; tiene un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="32267b5e71f7ec1d742dce72b339a8c92ce8f8bc" translate="yes" xml:space="preserve">
          <source>1) Move assignment operator. First, abandons the shared state (as in &lt;code&gt;~promise()&lt;/code&gt;), then assigns the shared state of &lt;code&gt;other&lt;/code&gt; as if by executing &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;(std::move(other)).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1) Mover operador de asignaci&amp;oacute;n. Primero, abandona el estado compartido (como en &lt;code&gt;~promise()&lt;/code&gt; ), luego asigna el estado compartido de &lt;code&gt;other&lt;/code&gt; como si ejecute &lt;code&gt;&lt;a href=&quot;../promise&quot;&gt;std::promise&lt;/a&gt;(std::move(other)).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87be123334c79f86e66db927b0f1e69d4152ff3f" translate="yes" xml:space="preserve">
          <source>1) Move assignment operator: Moves the contents of &lt;code&gt;rhs&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. After the move, &lt;code&gt;*this&lt;/code&gt; has the associated string, the open mode, the locale, and all other state formerly held by &lt;code&gt;rhs&lt;/code&gt;. The six pointers of &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;*this&lt;/code&gt; are guaranteed to be different from the corresponding pointers in the moved-from &lt;code&gt;rhs&lt;/code&gt; unless null.</source>
          <target state="translated">1) Mover operador de asignaci&amp;oacute;n: mueve el contenido de &lt;code&gt;rhs&lt;/code&gt; a &lt;code&gt;*this&lt;/code&gt; . Despu&amp;eacute;s del movimiento, &lt;code&gt;*this&lt;/code&gt; tiene la cadena asociada, el modo abierto, la configuraci&amp;oacute;n regional y todos los dem&amp;aacute;s estados que anteriormente ten&amp;iacute;an &lt;code&gt;rhs&lt;/code&gt; . Los seis punteros de &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;*this&lt;/code&gt; se garantiza que sea diferente de los punteros correspondientes en el pasado, desde &lt;code&gt;rhs&lt;/code&gt; a no ser nula.</target>
        </trans-unit>
        <trans-unit id="7d6353cf0852cf732b2e80b3c54029fc7ed0252d" translate="yes" xml:space="preserve">
          <source>1) Moves &lt;code&gt;count&lt;/code&gt; elements from a range beginning at &lt;code&gt;first&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) Mueve los elementos de &lt;code&gt;count&lt;/code&gt; desde un rango que comienza al &lt;code&gt;first&lt;/code&gt; a un &amp;aacute;rea de memoria no inicializada que comienza en &lt;code&gt;d_first&lt;/code&gt; como si fuera</target>
        </trans-unit>
        <trans-unit id="baeda8b2207e79e0e28d467dccba16a337675b05" translate="yes" xml:space="preserve">
          <source>1) Moves all elements from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted after the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The behavior is undefined if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) Mueve todos los elementos de &lt;code&gt;other&lt;/code&gt; a &lt;code&gt;*this&lt;/code&gt; . Los elementos se insertan despu&amp;eacute;s del elemento se&amp;ntilde;alado por &lt;code&gt;pos&lt;/code&gt; . El &lt;code&gt;other&lt;/code&gt; contenedor se vac&amp;iacute;a despu&amp;eacute;s de la operaci&amp;oacute;n. El comportamiento es indefinido si &lt;code&gt;other&lt;/code&gt; refiere al mismo objeto que &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbee85f489bfd5c711863ceb3ce35d639917da93" translate="yes" xml:space="preserve">
          <source>1) Moves elements from the range &lt;code&gt;[first, last)&lt;/code&gt; to an uninitialized memory area beginning at &lt;code&gt;d_first&lt;/code&gt; as if by</source>
          <target state="translated">1) Mueve elementos del rango &lt;code&gt;[first, last)&lt;/code&gt; a un &amp;aacute;rea de memoria no inicializada que comienza en &lt;code&gt;d_first&lt;/code&gt; como si fuera</target>
        </trans-unit>
        <trans-unit id="a02bfb3935e9c4bd8c50e3ceaa51a1ac20773de1" translate="yes" xml:space="preserve">
          <source>1) Moves the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;, to another range beginning at &lt;code&gt;d_first&lt;/code&gt;, starting from first and proceeding to last - 1. After this operation the elements in the moved-from range will still contain valid values of the appropriate type, but not necessarily the same values as before the move.</source>
          <target state="translated">1) Mueve los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; , a otro rango que comienza en &lt;code&gt;d_first&lt;/code&gt; , comenzando por el primero y pasando al &amp;uacute;ltimo - 1. Despu&amp;eacute;s de esta operaci&amp;oacute;n, los elementos en el rango desde el que se mueve a&amp;uacute;n contendr&amp;aacute;n valores v&amp;aacute;lidos del valor apropiado escriba, pero no necesariamente los mismos valores que antes del movimiento.</target>
        </trans-unit>
        <trans-unit id="3e96eedb6a4729d6cd532f90b4c42d7009c20ae6" translate="yes" xml:space="preserve">
          <source>1) Names declared by the init-statement (if init-statement is a declaration) and names declared by condition (if condition is a declaration) are in the same scope (which is also the scope of statement).</source>
          <target state="translated">1)Los nombres declarados por el init-statement (si el init-statement es una declaración)y los nombres declarados por condición (si la condición es una declaración)están en el mismo ámbito (que es también el ámbito de la declaración).</target>
        </trans-unit>
        <trans-unit id="29f0125e541e7b6cb76f5dbbc2fb2c46cdd5ba5f" translate="yes" xml:space="preserve">
          <source>1) Narrow multibyte string literal. The type of an unprefixed string literal is &lt;code&gt;const char[N]&lt;/code&gt;, where &lt;code&gt;N&lt;/code&gt; is the size of the string in code units of the execution narrow encoding, including the null terminator.</source>
          <target state="translated">1) literal de cadena multibyte estrecha. El tipo de literal de cadena sin prefijar es &lt;code&gt;const char[N]&lt;/code&gt; , donde &lt;code&gt;N&lt;/code&gt; es el tama&amp;ntilde;o de la cadena en unidades de c&amp;oacute;digo de la codificaci&amp;oacute;n estrecha de ejecuci&amp;oacute;n, incluido el terminador nulo.</target>
        </trans-unit>
        <trans-unit id="d4f47d080da433e4df7de35bc1790426bc94e157" translate="yes" xml:space="preserve">
          <source>1) Non-throwing dynamic exception specification</source>
          <target state="translated">1)Especificación de excepción dinámica sin lanzamiento</target>
        </trans-unit>
        <trans-unit id="6a6a9ceef837057cbc352d5ec70b0fd0f2b2c8bd" translate="yes" xml:space="preserve">
          <source>1) Number of elements with key &lt;code&gt;key&lt;/code&gt;, that is either 1 or 0.</source>
          <target state="translated">1) N&amp;uacute;mero de elementos con clave &lt;code&gt;key&lt;/code&gt; , que es 1 o 0.</target>
        </trans-unit>
        <trans-unit id="1564a87a6e67740b705461f9434aea174e148c19" translate="yes" xml:space="preserve">
          <source>1) Number of elements with key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1) N&amp;uacute;mero de elementos con clave &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3517215f133f6ebfae6482995743c32e01ac79c9" translate="yes" xml:space="preserve">
          <source>1) Obtains the actual address of the object or function &lt;code&gt;arg&lt;/code&gt;, even in presence of overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt;</source>
          <target state="translated">1) Obtiene la direcci&amp;oacute;n real del objeto o funci&amp;oacute;n &lt;code&gt;arg&lt;/code&gt; , incluso en presencia de un &lt;code&gt;operator&amp;amp;&lt;/code&gt; sobrecargado &amp;amp;</target>
        </trans-unit>
        <trans-unit id="63c030571149d7aea7d192bb60285199d1752b0e" translate="yes" xml:space="preserve">
          <source>1) Often known as &quot;C-style&quot; or &quot;multi-line&quot; comments.</source>
          <target state="translated">1)A menudo conocidos como comentarios &quot;estilo C&quot; o &quot;multilínea&quot;.</target>
        </trans-unit>
        <trans-unit id="842c5f199cfee8d76155c07d299c1fe9ce02bab8" translate="yes" xml:space="preserve">
          <source>1) Parses the date and time from the input character sequence &lt;code&gt;[beg, end)&lt;/code&gt; according to the format provided in the character sequence &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt;. The format is expected to follow the format described below, although actual processing of each format specifier can be customized by overriding &lt;code&gt;do_get&lt;/code&gt;. The &lt;code&gt;get&lt;/code&gt; function performs the following: First, clears the error bits in &lt;code&gt;err&lt;/code&gt; by executing &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt;. Then enters a loop, which terminates whenever any of the following conditions becomes true (checked in this order):</source>
          <target state="translated">1) Analiza la fecha y la hora desde la secuencia de caracteres de entrada &lt;code&gt;[beg, end)&lt;/code&gt; acuerdo con el formato proporcionado en la secuencia de caracteres &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; . Se espera que el formato siga el formato descrito a continuaci&amp;oacute;n, aunque el procesamiento real de cada especificador de formato se puede personalizar anulando &lt;code&gt;do_get&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;get&lt;/code&gt; realiza lo siguiente: Primero, borra los bits de error en &lt;code&gt;err&lt;/code&gt; ejecutando &lt;code&gt;err = &lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::goodbit&lt;/a&gt;&lt;/code&gt; . Luego ingresa un bucle, que termina cuando alguna de las siguientes condiciones se cumple (marcada en este orden):</target>
        </trans-unit>
        <trans-unit id="4251fa4ac37443b00ba495f01dec70943d49534e" translate="yes" xml:space="preserve">
          <source>1) Performs &lt;code&gt;*this = *this + d;&lt;/code&gt;</source>
          <target state="translated">1) Realiza &lt;code&gt;*this = *this + d;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="06459854688602a24bce5db298f1ff763c820069" translate="yes" xml:space="preserve">
          <source>1) Performs &lt;code&gt;*this = *this + m;&lt;/code&gt;</source>
          <target state="translated">1) Realiza &lt;code&gt;*this = *this + m;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65fb962cbf281356d7871dec0c276ca503ae02f5" translate="yes" xml:space="preserve">
          <source>1) Performs a left rotation on a range of elements.</source>
          <target state="translated">1)Realiza una rotación hacia la izquierda en una serie de elementos.</target>
        </trans-unit>
        <trans-unit id="24157bdc426e8751a205fa626eea64b65972c149" translate="yes" xml:space="preserve">
          <source>1) Performs atomic addition. Equivalent to &lt;code&gt;fetch_add(arg)&lt;/code&gt; + arg.</source>
          <target state="translated">1) Realiza la suma at&amp;oacute;mica. Equivalente a &lt;code&gt;fetch_add(arg)&lt;/code&gt; + arg.</target>
        </trans-unit>
        <trans-unit id="b7b35043c329a05e326ecc4ac09efa80c7ee56f7" translate="yes" xml:space="preserve">
          <source>1) Performs atomic addition. Equivalent to &lt;code&gt;return fetch_add(arg) + arg;&lt;/code&gt;.</source>
          <target state="translated">1) Realiza la suma at&amp;oacute;mica. Equivalente a &lt;code&gt;return fetch_add(arg) + arg;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0419ff58b80e0ea3e34dbe1120d304b2154ccd33" translate="yes" xml:space="preserve">
          <source>1) Performs atomic pre-increment. Equivalent to &lt;code&gt;fetch_add(1)+1&lt;/code&gt;.</source>
          <target state="translated">1) Realiza un pre-incremento at&amp;oacute;mico. Equivalente a &lt;code&gt;fetch_add(1)+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d7cb0da243e1e814c426ca15e77bf948db18b30" translate="yes" xml:space="preserve">
          <source>1) Performs atomic pre-increment. Equivalent to &lt;code&gt;return fetch_add(1) + 1;&lt;/code&gt;.</source>
          <target state="translated">1) Realiza un pre-incremento at&amp;oacute;mico. Equivalente a &lt;code&gt;return fetch_add(1) + 1;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8165604074e09874cc008cd54a9677022761ce36" translate="yes" xml:space="preserve">
          <source>1) Pre-increment. Returns the updated iterator.</source>
          <target state="translated">1)Preincremento.Devuelve el iterador actualizado.</target>
        </trans-unit>
        <trans-unit id="98b2b73f529f9a9c81704e2afa46fe127b827d7f" translate="yes" xml:space="preserve">
          <source>1) Previous associated locale.</source>
          <target state="translated">1)Localidad asociada anterior.</target>
        </trans-unit>
        <trans-unit id="90eaf4a181c70f4e6dd5dad828ce93c49a0f00b7" translate="yes" xml:space="preserve">
          <source>1) Primary template is an empty struct.</source>
          <target state="translated">1)La plantilla primaria es una estructura vacía.</target>
        </trans-unit>
        <trans-unit id="d3b8bab61ba0a04eca35d2c18428e6aaa3ccf10f" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_always_noconv&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_always_noconv&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="baf1382568df4bb859c2f19d25f5fa51f0d6c8b6" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_curr_symbol&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_curr_symbol&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="8803148252b377ffcd4da972f99e35584fa057b1" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_decimal_point&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_decimal_point&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="6f5e8bfa91bd146e3eb1c442796dcc622fd2cb53" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_frac_digits&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_frac_digits&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="cd263bbd005fdfda08890b70706b6c4d80e469da" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_get&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_get&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="2ea4e6b7dcb9f599bddec78e09271c36d3302c0e" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_grouping&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_grouping&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="2f1cefcfa79a30f86558cc5d92aa1f12547b1071" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_in&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_in&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="caad5ee2da96131cd137488a3b8e49826497e05d" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_max_length&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_max_length&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="c42e6d12a6460383165ecd093240a382422e7a50" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_pos_format&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_pos_format&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="bc5bc70d6c3c7d1b63e978e2bb5f510449787adf" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_positive_sign&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_positive_sign&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="6a7fb6649c9c1933430d44d28c9be6af80e73282" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the member function &lt;code&gt;do_thousands_sep&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n miembro p&amp;uacute;blica, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_thousands_sep&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="a05a1a4712a55bd65ed1b7c2d0c6498741ebcfac" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_compare&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_compare&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="50240ff8cfc5297f7dea433cf9aa0e95cbb740bd" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_date_order&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_date_order&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="dc988aac8e2069c8157a164371668baa84732662" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_get&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_get&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="e3956434b335523e445a7f66b881b7d9081d9286" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_get_date()&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_get_date()&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="aa8c3a179dd224f964496fd3cf87120527402883" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_hash&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_hash&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="f5b1e143ebb344d5c93a9cd3e3d5c1234ffeed9a" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_open&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_open&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="c3021e1c4d5e1cb04a9c13b29e49851c5fc32a48" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_put&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_put&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="02f297d72b24e5ec0b50eab50682c4aeb7a9ac16" translate="yes" xml:space="preserve">
          <source>1) Public member function, calls the protected virtual member function &lt;code&gt;do_transform&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_transform&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="8792ca5b24450313548e3eafb8702266f2eb881c" translate="yes" xml:space="preserve">
          <source>1) Reads one character and returns it if available. Otherwise, returns &lt;code&gt;Traits::eof()&lt;/code&gt; and sets &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Lee un car&amp;aacute;cter y lo devuelve si est&amp;aacute; disponible. De lo contrario, devuelve &lt;code&gt;Traits::eof()&lt;/code&gt; y establece &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;failbit&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../ios_base/iostate&quot;&gt;eofbit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b24556d7aac836f48afb6674f5c717012f92f983" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">1) Lee los datos de &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7396d1f8b950a76b6370b58eb711a32d6d49c388" translate="yes" xml:space="preserve">
          <source>1) Reads the data from &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Lee los datos de &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a217932442a1d0a2f62a838e385afc124dbe4bd" translate="yes" xml:space="preserve">
          <source>1) Refers to a &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object representing the type type. If type is a reference type, the result refers to a &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; object representing the referenced type.</source>
          <target state="translated">1) Se refiere a un objeto &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; que representa el tipo de tipo. Si type es un tipo de referencia, el resultado se refiere a un objeto &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; que representa el tipo referenciado.</target>
        </trans-unit>
        <trans-unit id="861842b860dc887a6543ee6224b6ce48a8a61aa1" translate="yes" xml:space="preserve">
          <source>1) Regular function declarator syntax</source>
          <target state="translated">1)Sintaxis declaratoria de la función regular</target>
        </trans-unit>
        <trans-unit id="6cbbb4ec5d9adc038750b690542f0bc0dae8623a" translate="yes" xml:space="preserve">
          <source>1) Releases any shared state and assigns the contents of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the assignment, &lt;code&gt;this-&amp;gt;valid() == other.valid()&lt;/code&gt;.</source>
          <target state="translated">1) Libera cualquier estado compartido y asigna el contenido de &lt;code&gt;other&lt;/code&gt; a &lt;code&gt;*this&lt;/code&gt; . Despu&amp;eacute;s de la asignaci&amp;oacute;n, &lt;code&gt;this-&amp;gt;valid() == other.valid()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="38bb6282680f52e2fda17aa9983f1073eb7c0c47" translate="yes" xml:space="preserve">
          <source>1) Releases any shared state and move-assigns the contents of &lt;code&gt;other&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt;. After the assignment, &lt;code&gt;other.valid() == false&lt;/code&gt; and &lt;a href=&quot;valid&quot;&gt;&lt;code&gt;this-&amp;gt;valid()&lt;/code&gt;&lt;/a&gt; will yield the same value as &lt;code&gt;other.valid()&lt;/code&gt; before the assignment.</source>
          <target state="translated">1) Libera cualquier estado compartido y mueve-asigna el contenido de &lt;code&gt;other&lt;/code&gt; a &lt;code&gt;*this&lt;/code&gt; . Despu&amp;eacute;s de la asignaci&amp;oacute;n, &lt;code&gt;other.valid() == false&lt;/code&gt; y &lt;a href=&quot;valid&quot;&gt; &lt;code&gt;this-&amp;gt;valid()&lt;/code&gt; &lt;/a&gt; arrojar&amp;aacute; el mismo valor que &lt;code&gt;other.valid()&lt;/code&gt; antes de la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b5b667ade567f1b29b3c27fd07f95ac68433c004" translate="yes" xml:space="preserve">
          <source>1) Releases the ownership of the managed object, if any. After the call, &lt;code&gt;*this&lt;/code&gt; manages no object. Equivalent to &lt;code&gt;shared_ptr().swap(*this);&lt;/code&gt;</source>
          <target state="translated">1) Libera la propiedad del objeto gestionado, si lo hay. Despu&amp;eacute;s de la llamada, &lt;code&gt;*this&lt;/code&gt; no gestiona ning&amp;uacute;n objeto. Equivalente a &lt;code&gt;shared_ptr().swap(*this);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="058dae359c875bb8aea961ac9a8c89d60ef65185" translate="yes" xml:space="preserve">
          <source>1) Removes</source>
          <target state="translated">1)Quita</target>
        </trans-unit>
        <trans-unit id="8c4e68b9d2c4305008d048fc061e3772b5809315" translate="yes" xml:space="preserve">
          <source>1) Removes all elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) Elimina todos los elementos que son iguales al &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="869efa782ed2427565d277c2e6014424441dd053" translate="yes" xml:space="preserve">
          <source>1) Removes the element at &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Elimina el elemento en la &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ffec9f7979d764e0359835e77f17747b23d8b2dd" translate="yes" xml:space="preserve">
          <source>1) Removes the element following &lt;code&gt;pos&lt;/code&gt;.</source>
          <target state="translated">1) Elimina el elemento siguiente &lt;code&gt;pos&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17ef257965eb0ab3b49b26ba1ea702b626c6aa3f" translate="yes" xml:space="preserve">
          <source>1) Reorders the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that all elements for which the predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; precede the elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. Relative order of the elements is not preserved.</source>
          <target state="translated">1) Reordena los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; de tal manera que todos los elementos para los cuales el predicado &lt;code&gt;p&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; preceden a los elementos para los cuales el predicado &lt;code&gt;p&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; . El orden relativo de los elementos no se conserva.</target>
        </trans-unit>
        <trans-unit id="adce2245dd094ab71b482b217c791cf528174e3e" translate="yes" xml:space="preserve">
          <source>1) Reorders the elements in the range &lt;code&gt;[first, last)&lt;/code&gt; in such a way that all elements for which the predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; precede the elements for which predicate &lt;code&gt;p&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. Relative order of the elements is preserved.</source>
          <target state="translated">1) Reordena los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; de tal manera que todos los elementos para los cuales el predicado &lt;code&gt;p&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; preceden a los elementos para los cuales el predicado &lt;code&gt;p&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; . Se conserva el orden relativo de los elementos.</target>
        </trans-unit>
        <trans-unit id="2dac5da3d02f4d437123f2a0b9d56eb2e4fd0857" translate="yes" xml:space="preserve">
          <source>1) Replaces all elements that are equal to &lt;code&gt;old_value&lt;/code&gt;.</source>
          <target state="translated">1) Reemplaza todos los elementos que son iguales a &lt;code&gt;old_value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e3318a609e82a644898d7222b1da6b96eacbe12" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents of &lt;code&gt;*this&lt;/code&gt; with a pathname whose both native and generic format representations equal those of &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">1) Reemplaza el contenido de &lt;code&gt;*this&lt;/code&gt; con un nombre de ruta cuyas representaciones en formato nativo y gen&amp;eacute;rico son iguales a las de &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e240befa148e0203cedd59eee5956df5acad945f" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with &lt;code&gt;count&lt;/code&gt; copies of character &lt;code&gt;ch&lt;/code&gt;.</source>
          <target state="translated">1) Reemplaza el contenido con copias de &lt;code&gt;count&lt;/code&gt; de caracteres &lt;code&gt;ch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6b05f959c13293d5a5d5af2a8637f634e41da89" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with &lt;code&gt;count&lt;/code&gt; copies of value &lt;code&gt;value&lt;/code&gt;</source>
          <target state="translated">1) Reemplaza el contenido con copias de &lt;code&gt;count&lt;/code&gt; de &lt;code&gt;value&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29d8d55620552a2c6832d320259ce67308463212" translate="yes" xml:space="preserve">
          <source>1) Replaces the contents with a copy of &lt;code&gt;str&lt;/code&gt;. If &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;str&lt;/code&gt; are the same object, this function has no effect.</source>
          <target state="translated">1) Reemplaza el contenido con una copia de &lt;code&gt;str&lt;/code&gt; . Si &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;str&lt;/code&gt; son el mismo objeto, esta funci&amp;oacute;n no tiene efecto.</target>
        </trans-unit>
        <trans-unit id="270b4bf667b635c284aba5086d9e163a6e0904f5" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;container-&amp;gt;push_back(value)&lt;/code&gt;</source>
          <target state="translated">1) Resultados en &lt;code&gt;container-&amp;gt;push_back(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="40ecaa5e7b5b215ddbaec386d81fbe27a35ad522" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;container-&amp;gt;push_front(value)&lt;/code&gt;</source>
          <target state="translated">1) Resultados en &lt;code&gt;container-&amp;gt;push_front(value)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8712ae4fa015816336c007fe3a9a6dcf1cb77223" translate="yes" xml:space="preserve">
          <source>1) Results in &lt;code&gt;iter = container-&amp;gt;insert(iter, value); ++iter;&lt;/code&gt;</source>
          <target state="translated">1) Resultados en &lt;code&gt;iter = container-&amp;gt;insert(iter, value); ++iter;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65e2795a9414bee5546a758244d76abfed9cefbf" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt;</source>
          <target state="translated">1) Devuelve &lt;code&gt;*lhs.resource() == *rhs.resource()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2502d83ce08382fe677e2911a3d1cccaddcc99f3" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;*this&lt;/code&gt; converted to &lt;a href=&quot;../path&quot;&gt;normal form&lt;/a&gt; in its generic format</source>
          <target state="translated">1) Devuelve &lt;code&gt;*this&lt;/code&gt; convertido a &lt;a href=&quot;../path&quot;&gt;forma normal&lt;/a&gt; en su formato gen&amp;eacute;rico</target>
        </trans-unit>
        <trans-unit id="3a923a689d5fab3840318f3d549827b3318bcbf5" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;iter&lt;/code&gt; unchanged</source>
          <target state="translated">1) Las devoluciones &lt;code&gt;iter&lt;/code&gt; sin cambios</target>
        </trans-unit>
        <trans-unit id="b92bef1e9a732e0b29effd33edcabf38014c435d" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;relative(p, current_path(), ec)&lt;/code&gt;</source>
          <target state="translated">1) Devuelve &lt;code&gt;relative(p, current_path(), ec)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5de64d91bbdbee0c01c0e8e9cb2b99b1df930700" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">1) Devuelve &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a484b37cffb98b770d8354adcf0625dcd7c1759e" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are both end-of-sequence iterators, or if all of the following conditions are true:</source>
          <target state="translated">1) Devuelve &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; son iteradores de final de secuencia, o si todas las siguientes condiciones son verdaderas:</target>
        </trans-unit>
        <trans-unit id="56de7954cc2d00b655ce1ec3c457bb6134e5cbf3" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) Devuelve &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; son iguales, de lo contrario , &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c94da87dbdee081478fa1d7dee357f47bd78ed41" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;lhs&lt;/code&gt; is</source>
          <target state="translated">1) Devuelve &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;lhs&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="7fac7f5450d225457e6b78589c98f2513f4014ce" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if all elements in the range &lt;code&gt;[first, last)&lt;/code&gt; that satisfy the predicate &lt;code&gt;p&lt;/code&gt; appear before all elements that don't. Also returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;[first, last)&lt;/code&gt; is empty.</source>
          <target state="translated">1) Devuelve &lt;code&gt;true&lt;/code&gt; si todos los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt; que satisfacen el predicado &lt;code&gt;p&lt;/code&gt; aparecen antes que todos los elementos que no lo hacen. Tambi&amp;eacute;n devuelve &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;[first, last)&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="2aba12f91ced7a05bef1178e9c4fd5864add3fd6" translate="yes" xml:space="preserve">
          <source>1) Returns &lt;code&gt;true&lt;/code&gt; if lhs is less than rhs, &lt;code&gt;false&lt;/code&gt; otherwise.</source>
          <target state="translated">1) Devuelve &lt;code&gt;true&lt;/code&gt; si lhs es menor que rhs, &lt;code&gt;false&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="8a60b75738d79d6ba929ed47e4bcd56cf5f07f4d" translate="yes" xml:space="preserve">
          <source>1) Returns a &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; containing the result of binary AND on corresponding pairs of bits of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve un conjunto de &lt;code&gt;bitset&amp;lt;N&amp;gt;&lt;/code&gt; contiene el resultado del AND binario en los pares de bits correspondientes de &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e56d712102c4d0fe2dae24e3b57a4a8cfd5aa505" translate="yes" xml:space="preserve">
          <source>1) Returns a copy of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve una copia de &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca096d06281ae150d54482a6cc1e549ce108c224" translate="yes" xml:space="preserve">
          <source>1) Returns a copy of the underlying string as if by calling &lt;code&gt;rdbuf()-&amp;gt;str()&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve una copia de la cadena subyacente como llamando a &lt;code&gt;rdbuf()-&amp;gt;str()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1c616be8d7e9418723ddfcbc3e52606258ec3df" translate="yes" xml:space="preserve">
          <source>1) Returns a null pointer if &lt;code&gt;fail()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, otherwise returns a non-null pointer. This pointer is implicitly convertible to &lt;code&gt;bool&lt;/code&gt; and may be used in boolean contexts.</source>
          <target state="translated">1) Devuelve un puntero nulo si &lt;code&gt;fail()&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; ; de lo contrario, devuelve un puntero no nulo. Este puntero es impl&amp;iacute;citamente convertible a &lt;code&gt;bool&lt;/code&gt; y puede usarse en contextos booleanos.</target>
        </trans-unit>
        <trans-unit id="c2284f1e367243c98935f80fc109c83a94a54f3c" translate="yes" xml:space="preserve">
          <source>1) Returns a numeric array of &lt;code&gt;bool&lt;/code&gt; containing elements each of which is obtained by applying the indicated comparison operator to the corresponding values of &lt;code&gt;lhs&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt;</source>
          <target state="translated">1) Devuelve una matriz num&amp;eacute;rica de elementos que contienen &lt;code&gt;bool&lt;/code&gt; , cada uno de los cuales se obtiene aplicando el operador de comparaci&amp;oacute;n indicado a los valores correspondientes de &lt;code&gt;lhs&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3100a3df15f07b6e5ef0d2e827ee2f7cdbf6175d" translate="yes" xml:space="preserve">
          <source>1) Returns a pointer to the contained value.</source>
          <target state="translated">1)Devuelve un puntero al valor contenido.</target>
        </trans-unit>
        <trans-unit id="0d2c31549336b964b7be2eb179a144f92cc116bc" translate="yes" xml:space="preserve">
          <source>1) Returns a possibly const-qualified iterator to the reverse-beginning of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve un iterador posiblemente calificado const al inicio inverso del contenedor &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a063c1b9ad5e32ce34dcdfd8ca4b82cf3c236ca" translate="yes" xml:space="preserve">
          <source>1) Returns a possibly const-qualified iterator to the reverse-end of the container &lt;code&gt;c&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve un iterador posiblemente calificado const en el reverso del contenedor &lt;code&gt;c&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13631d6a37bc7ed73ea92514ab164c6764fc704e" translate="yes" xml:space="preserve">
          <source>1) Returns a reference to the current &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve una referencia al &lt;code&gt;&lt;a href=&quot;../match_results&quot;&gt;std::match_results&lt;/a&gt;&lt;/code&gt; actual .</target>
        </trans-unit>
        <trans-unit id="f3b6280f71abf114f54373c3e7590153910cd5d6" translate="yes" xml:space="preserve">
          <source>1) Returns a reference to the global &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; singleton. If this is the first access to the database, initialize the database. After the initialization, the database will hold a single initialized &lt;code&gt;std::chrono::tzdb&lt;/code&gt; object. This function is thread-safe: concurrent calls to this function from multiple threads do not introduce a data race.</source>
          <target state="translated">1) Devuelve una referencia al singleton global &lt;code&gt;std::chrono::tzdb_list&lt;/code&gt; Si este es el primer acceso a la base de datos, inicialice la base de datos. Despu&amp;eacute;s de la inicializaci&amp;oacute;n, la base de datos contendr&amp;aacute; un &amp;uacute;nico objeto &lt;code&gt;std::chrono::tzdb&lt;/code&gt; . Esta funci&amp;oacute;n es segura para subprocesos: las llamadas concurrentes a esta funci&amp;oacute;n desde m&amp;uacute;ltiples subprocesos no introducen una carrera de datos.</target>
        </trans-unit>
        <trans-unit id="a81e180b9a39b86ed42f18915e1912a4b70010f8" translate="yes" xml:space="preserve">
          <source>1) Returns an implementation-defined type that holds a reference to &lt;code&gt;*this&lt;/code&gt;. &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; is &lt;a href=&quot;auto_ptr&quot;&gt;convertible&lt;/a&gt; and &lt;a href=&quot;operator=&quot;&gt;assignable&lt;/a&gt; from this template. The implementation is allowed to provide the template with a different name or implement equivalent functionality in other ways.</source>
          <target state="translated">1) Devuelve un tipo definido por la implementaci&amp;oacute;n que contiene una referencia a &lt;code&gt;*this&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;../auto_ptr&quot;&gt;std::auto_ptr&lt;/a&gt;&lt;/code&gt; es &lt;a href=&quot;auto_ptr&quot;&gt;convertible&lt;/a&gt; y &lt;a href=&quot;operator=&quot;&gt;asignable&lt;/a&gt; desde esta plantilla. La implementaci&amp;oacute;n puede proporcionar a la plantilla un nombre diferente o implementar una funcionalidad equivalente de otras maneras.</target>
        </trans-unit>
        <trans-unit id="1ed78a0dd559758ebfb9c2949e5a988bace3ce62" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator pointing to the first element that is</source>
          <target state="translated">1)Devuelve un iterador que apunta al primer elemento que es</target>
        </trans-unit>
        <trans-unit id="6844338cdc96e911c46728c0c867f432dd1a50ec" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first character of the view. Equivalent to &lt;code&gt;sv.begin()&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve un iterador al primer car&amp;aacute;cter de la vista. Equivalente a &lt;code&gt;sv.begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6cd397aaa829398a2797783162cadf8568d17dba" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first element of the path. If the path is empty, the returned iterator is equal to &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve un iterador al primer elemento de la ruta. Si la ruta est&amp;aacute; vac&amp;iacute;a, el iterador devuelto es igual a &lt;code&gt;end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbc84a634be5255d1d6be17b5b6cfff82d9198c3" translate="yes" xml:space="preserve">
          <source>1) Returns an iterator to the first element of the span. Equivalent to &lt;code&gt;s.begin()&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve un iterador al primer elemento del tramo. Equivalente a &lt;code&gt;s.begin()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="964e9b36a5abe52ebf725814fc0423c129fbe227" translate="yes" xml:space="preserve">
          <source>1) Returns current maximum load factor.</source>
          <target state="translated">1)Devuelve el factor de carga máximo actual.</target>
        </trans-unit>
        <trans-unit id="cc6b701735443a9096b6e72058c3c17fa0eb40fd" translate="yes" xml:space="preserve">
          <source>1) Returns exactly &lt;code&gt;c.begin()&lt;/code&gt;, which is typically an iterator to the beginning of the sequence represented by &lt;code&gt;c&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this returns &lt;code&gt;C::iterator&lt;/code&gt; when &lt;code&gt;c&lt;/code&gt; is not const-qualified, and &lt;code&gt;C::const_iterator&lt;/code&gt; otherwise.</source>
          <target state="translated">1) Devuelve exactamente &lt;code&gt;c.begin()&lt;/code&gt; , que generalmente es un iterador al comienzo de la secuencia representada por &lt;code&gt;c&lt;/code&gt; . Si &lt;code&gt;C&lt;/code&gt; es un &lt;a href=&quot;../named_req/container&quot;&gt;Contenedor&lt;/a&gt; est&amp;aacute;ndar , esto devuelve &lt;code&gt;C::iterator&lt;/code&gt; cuando &lt;code&gt;c&lt;/code&gt; no est&amp;aacute; calificado const y &lt;code&gt;C::const_iterator&lt;/code&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="c8e94140f9ef40bf1d36874da1c9ebca27cad214" translate="yes" xml:space="preserve">
          <source>1) Returns exactly &lt;code&gt;c.end()&lt;/code&gt;, which is typically an iterator one past the end of the sequence represented by &lt;code&gt;c&lt;/code&gt;. If &lt;code&gt;C&lt;/code&gt; is a standard &lt;a href=&quot;../named_req/container&quot;&gt;Container&lt;/a&gt;, this returns a &lt;code&gt;C::iterator&lt;/code&gt; when &lt;code&gt;c&lt;/code&gt; is not const-qualified, and a &lt;code&gt;C::const_iterator&lt;/code&gt; otherwise.</source>
          <target state="translated">1) Devuelve exactamente &lt;code&gt;c.end()&lt;/code&gt; , que normalmente es un iterador m&amp;aacute;s all&amp;aacute; del final de la secuencia representada por &lt;code&gt;c&lt;/code&gt; . Si &lt;code&gt;C&lt;/code&gt; es un &lt;a href=&quot;../named_req/container&quot;&gt;Contenedor&lt;/a&gt; est&amp;aacute;ndar , esto devuelve un &lt;code&gt;C::iterator&lt;/code&gt; cuando &lt;code&gt;c&lt;/code&gt; no est&amp;aacute; calificado const y un &lt;code&gt;C::const_iterator&lt;/code&gt; caso contrario.</target>
        </trans-unit>
        <trans-unit id="d2d79bb6bfb415bc4799cd03340ea976f5e1ad4e" translate="yes" xml:space="preserve">
          <source>1) Returns file permissions information.</source>
          <target state="translated">1)Devuelve la información de los permisos de archivo.</target>
        </trans-unit>
        <trans-unit id="ca8cb5bb5515d3f764ff15bb64205d48c54ff968" translate="yes" xml:space="preserve">
          <source>1) Returns file type information.</source>
          <target state="translated">1)Devuelve la información del tipo de archivo.</target>
        </trans-unit>
        <trans-unit id="cbec588b4dae3ad630f2f6af2e54b55a2be244d6" translate="yes" xml:space="preserve">
          <source>1) Returns status of the entry, as if determined by a &lt;a href=&quot;../status&quot;&gt;status&lt;/a&gt; call (symlinks are followed to their targets)</source>
          <target state="translated">1) Devuelve el estado de la entrada, como si fuera determinado por una llamada de &lt;a href=&quot;../status&quot;&gt;estado&lt;/a&gt; (los enlaces simb&amp;oacute;licos se siguen a sus objetivos)</target>
        </trans-unit>
        <trans-unit id="292239ac393513bb2a73e81850757d26b7552c99" translate="yes" xml:space="preserve">
          <source>1) Returns the</source>
          <target state="translated">1)Devuelve el</target>
        </trans-unit>
        <trans-unit id="0fb0365146c39ac72ff8fc5a9c4e8c203a48497d" translate="yes" xml:space="preserve">
          <source>1) Returns the &amp;alpha; distribution parameter. It is also known as the shape parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el par&amp;aacute;metro de distribuci&amp;oacute;n &amp;alpha;. Tambi&amp;eacute;n se conoce como el par&amp;aacute;metro de forma. El valor predeterminado es &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21227b553d58a19b72f0fe801e0f03bd0a1049b3" translate="yes" xml:space="preserve">
          <source>1) Returns the a distribution parameter (location). The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve un par&amp;aacute;metro de distribuci&amp;oacute;n (ubicaci&amp;oacute;n). El valor predeterminado es &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="143347fc7ff8e780591f1e29b03e2d7669e75b6f" translate="yes" xml:space="preserve">
          <source>1) Returns the a parameter. It defines the shape of the distribution. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el par&amp;aacute;metro a. Define la forma de la distribuci&amp;oacute;n. El valor predeterminado es &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2d1f91a5f400fc1fd6adcb1746a21b04fe35b6f" translate="yes" xml:space="preserve">
          <source>1) Returns the associated parameter set.</source>
          <target state="translated">1)Devuelve el conjunto de parámetros asociados.</target>
        </trans-unit>
        <trans-unit id="a15f06fffff72065df3b268612d6a17f5310aa58" translate="yes" xml:space="preserve">
          <source>1) Returns the associated stream buffer. If there is no associated stream buffer, returns a null pointer.</source>
          <target state="translated">1)Devuelve el búfer de flujo asociado.Si no hay un búfer de corriente asociado,devuelve un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="22cd7377868adb410066182a3c8def7ed5f1fa07" translate="yes" xml:space="preserve">
          <source>1) Returns the current field width.</source>
          <target state="translated">1)Devuelve el ancho de campo actual.</target>
        </trans-unit>
        <trans-unit id="f41a7bceca1233658cedea4989b3de36c56d029f" translate="yes" xml:space="preserve">
          <source>1) Returns the current precision.</source>
          <target state="translated">1)Devuelve la precisión actual.</target>
        </trans-unit>
        <trans-unit id="001731be05f0e739b1a39d0921456a3adf786c45" translate="yes" xml:space="preserve">
          <source>1) Returns the current tied stream. If there is no tied stream, a null pointer is returned.</source>
          <target state="translated">1)Devuelve la corriente atada.Si no hay corriente atada,se devuelve un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="5acdce3496544fa0bd7b2c030f8bf1d9c5f72571" translate="yes" xml:space="preserve">
          <source>1) Returns the exception mask.</source>
          <target state="translated">1)Devuelve la máscara de excepción.</target>
        </trans-unit>
        <trans-unit id="1694f8d96fa622b3f17ae9121b869a1b0312a6ef" translate="yes" xml:space="preserve">
          <source>1) Returns the imaginary component of the complex number &lt;code&gt;z&lt;/code&gt;, i.e. &lt;code&gt;z.imag()&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el componente imaginario del n&amp;uacute;mero complejo &lt;code&gt;z&lt;/code&gt; , es decir, &lt;code&gt;z.imag()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49125a8b6077342f10be4d243d2ed33fbfe22de1" translate="yes" xml:space="preserve">
          <source>1) Returns the imaginary part.</source>
          <target state="translated">1)Devuelve la parte imaginaria.</target>
        </trans-unit>
        <trans-unit id="af75cb25c63821285d34593afc3031d58d00ddf9" translate="yes" xml:space="preserve">
          <source>1) Returns the list of boundaries of the intervals.</source>
          <target state="translated">1)Devuelve la lista de los límites de los intervalos.</target>
        </trans-unit>
        <trans-unit id="4c3aa7a255032d162e6721d758482183c8e0d4e5" translate="yes" xml:space="preserve">
          <source>1) Returns the log-mean m distribution parameter. It defines the location of the peak. The default value is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el par&amp;aacute;metro de distribuci&amp;oacute;n m de log-mean. Define la ubicaci&amp;oacute;n del pico. El valor predeterminado es &lt;code&gt;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb15710c8fbb6d1b45fb72076cb13894fb56f750" translate="yes" xml:space="preserve">
          <source>1) Returns the m (the first degree of freedom) distribution parameter. The default value is &lt;code&gt;1.0&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el par&amp;aacute;metro de distribuci&amp;oacute;n m (primer grado de libertad). El valor predeterminado es &lt;code&gt;1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12bbddb8b9d6e0fbda5e7775b18ff17adbbacb80" translate="yes" xml:space="preserve">
          <source>1) Returns the mean &amp;mu; distribution parameter. The mean specifies the location of the peak. The default value is &lt;code&gt;0.0&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el par&amp;aacute;metro de distribuci&amp;oacute;n medio &amp;mu;. La media especifica la ubicaci&amp;oacute;n del pico. El valor predeterminado es &lt;code&gt;0.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47a018754522c2f9b7cd2238570b2ebdebe1376b" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el n&amp;uacute;mero de elementos con la tecla &lt;code&gt;key&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4307f7beb5cbf30b6fd034cf152d44ddfc23058a" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key that compares equal to the specified argument &lt;code&gt;key&lt;/code&gt;, which is either 1 or 0 since this container does not allow duplicates.</source>
          <target state="translated">1) Devuelve el n&amp;uacute;mero de elementos con clave que se compara igual a la &lt;code&gt;key&lt;/code&gt; argumento especificada , que es 1 o 0 ya que este contenedor no permite duplicados.</target>
        </trans-unit>
        <trans-unit id="eb9b09c24f4dd3756959d45d14cfe7322d3d6eb0" translate="yes" xml:space="preserve">
          <source>1) Returns the number of elements with key that compares equal to the specified argument &lt;code&gt;key&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el n&amp;uacute;mero de elementos con clave que se compara igual a la &lt;code&gt;key&lt;/code&gt; argumento especificada .</target>
        </trans-unit>
        <trans-unit id="d0b0dd6464e410f3559cc88a021648404b61cfba" translate="yes" xml:space="preserve">
          <source>1) Returns the object owned by &lt;code&gt;*this&lt;/code&gt;, equivalent to &lt;code&gt;*get()&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el objeto propiedad de &lt;code&gt;*this&lt;/code&gt; , equivalente a &lt;code&gt;*get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efadb8f443ff52a8a06ff3cca490584c99089f22" translate="yes" xml:space="preserve">
          <source>1) Returns the p distribution parameter. It defines the probability of a trial generating &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;0.5&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el par&amp;aacute;metro de distribuci&amp;oacute;n p. Define la probabilidad de que un ensayo genere &lt;code&gt;true&lt;/code&gt; . El valor predeterminado es &lt;code&gt;0.5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06ea4503952409f3d220d8a31ac2c3d9a0b87e8b" translate="yes" xml:space="preserve">
          <source>1) Returns the pointer to the beginning (&quot;base&quot;) of the put area.</source>
          <target state="translated">1)Devuelve el puntero al principio (&quot;base&quot;)de la zona de colocación.</target>
        </trans-unit>
        <trans-unit id="d711b398059e09252c735c5b767a6c4f3b8c2d28" translate="yes" xml:space="preserve">
          <source>1) Returns the pointer to the beginning of the get area.</source>
          <target state="translated">1)Devuelve el puntero al principio del área de obtención.</target>
        </trans-unit>
        <trans-unit id="81b834f0d5a61937ab85cb95196e573fab4dbf45" translate="yes" xml:space="preserve">
          <source>1) Returns the real component of the complex number &lt;code&gt;z&lt;/code&gt;, i.e. &lt;code&gt;z.real()&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve el componente real del n&amp;uacute;mero complejo &lt;code&gt;z&lt;/code&gt; , es decir, &lt;code&gt;z.real()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="088dec1497a550df9243695c3279f03c8fb7947b" translate="yes" xml:space="preserve">
          <source>1) Returns the real part.</source>
          <target state="translated">1)Devuelve la parte real.</target>
        </trans-unit>
        <trans-unit id="8f3e1ba68c1324385714f799b9c29d179d2e6b88" translate="yes" xml:space="preserve">
          <source>1) Returns the squared magnitude of the complex number &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">1) Devuelve la magnitud al cuadrado del n&amp;uacute;mero complejo &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c70906930f9cd42e8f972b6ea9d3588d75bb9758" translate="yes" xml:space="preserve">
          <source>1) Returns the stored &lt;code&gt;std::chrono::month&lt;/code&gt; value.</source>
          <target state="translated">1) Devuelve el valor &lt;code&gt;std::chrono::month&lt;/code&gt; almacenado .</target>
        </trans-unit>
        <trans-unit id="ce5d3c03147c08fafbfcc97025b8268f78f5aaea" translate="yes" xml:space="preserve">
          <source>1) Returns the stored &lt;code&gt;std::chrono::year&lt;/code&gt; value.</source>
          <target state="translated">1) Devuelve el valor &lt;code&gt;std::chrono::year&lt;/code&gt; almacenado .</target>
        </trans-unit>
        <trans-unit id="61dadd5c36bffe5a48255156199fa6c44fd84e1d" translate="yes" xml:space="preserve">
          <source>1) Returns the time of the last modification of &lt;code&gt;p&lt;/code&gt;, determined as if by accessing the member &lt;code&gt;st_mtime&lt;/code&gt; of the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;stat&lt;/a&gt; (symlinks are followed) The non-throwing overload returns &lt;code&gt;file_time_type::min()&lt;/code&gt; on errors.</source>
          <target state="translated">1) Devuelve el tiempo de la &amp;uacute;ltima modificaci&amp;oacute;n de &lt;code&gt;p&lt;/code&gt; , determinado como si accediera al miembro &lt;code&gt;st_mtime&lt;/code&gt; de la &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/stat.html&quot;&gt;estad&amp;iacute;stica&lt;/a&gt; POSIX (se siguen los enlaces simb&amp;oacute;licos) La sobrecarga no &lt;code&gt;file_time_type::min()&lt;/code&gt; devuelve file_time_type :: min () en caso de errores.</target>
        </trans-unit>
        <trans-unit id="aa97c65b799f5efb0b02504a22a02ad70a88e318" translate="yes" xml:space="preserve">
          <source>1) Returns the value of its argument</source>
          <target state="translated">1)Devuelve el valor de su argumento</target>
        </trans-unit>
        <trans-unit id="533e65d4cbce1169e96cd03deb423e1ebed9ef4f" translate="yes" xml:space="preserve">
          <source>1) Returns the value of the file position state</source>
          <target state="translated">1)Devuelve el valor del estado de la posición del archivo</target>
        </trans-unit>
        <trans-unit id="8bd1eba1fbdf89c5698365e7fe91902373d9c621" translate="yes" xml:space="preserve">
          <source>1) Returns true if all of the bits in &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;rhs&lt;/code&gt; are equal.</source>
          <target state="translated">1) Devuelve verdadero si todos los bits en &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;rhs&lt;/code&gt; son iguales.</target>
        </trans-unit>
        <trans-unit id="998c1c493c58a67ce9bb205f050c7dbaf76aed9b" translate="yes" xml:space="preserve">
          <source>1) Reverses the order of the elements in the range &lt;code&gt;[first, last)&lt;/code&gt;</source>
          <target state="translated">1) Invierte el orden de los elementos en el rango &lt;code&gt;[first, last)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8d1ddbebd20349684cf4acb8ec8e6b2d4f4d96e9" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;a href=&quot;iterator_t&quot;&gt;&lt;code&gt;ranges::iterator_t&lt;/code&gt;&lt;/a&gt; when &lt;code&gt;R&lt;/code&gt; models exposition-only concept &lt;a href=&quot;range&quot;&gt;&lt;code&gt;__ForwardingRange&lt;/code&gt;&lt;/a&gt;, otherwise yields &lt;a href=&quot;dangling&quot;&gt;&lt;code&gt;ranges::dangling&lt;/code&gt;&lt;/a&gt; instead.</source>
          <target state="translated">1) Igual que &lt;a href=&quot;iterator_t&quot;&gt; &lt;code&gt;ranges::iterator_t&lt;/code&gt; &lt;/a&gt; cuando &lt;code&gt;R&lt;/code&gt; modela el concepto de solo exposici&amp;oacute;n &lt;a href=&quot;range&quot;&gt; &lt;code&gt;__ForwardingRange&lt;/code&gt; &lt;/a&gt; , de lo contrario produce &lt;a href=&quot;dangling&quot;&gt; &lt;code&gt;ranges::dangling&lt;/code&gt; &lt;/a&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="14f30d52df1968fd80f273b59c9c1e7531df510b" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;a href=&quot;noexcept_spec&quot;&gt;&lt;code&gt;noexcept(true)&lt;/code&gt;&lt;/a&gt;</source>
          <target state="translated">1) Igual que &lt;a href=&quot;noexcept_spec&quot;&gt; &lt;code&gt;noexcept(true)&lt;/code&gt; &lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="4def597a1104c9ab9fae317a750663a62c536d96" translate="yes" xml:space="preserve">
          <source>1) Same as &lt;code&gt;noexcept&lt;/code&gt;&lt;code&gt;(&lt;/code&gt;&lt;code&gt;true&lt;/code&gt;&lt;code&gt;)&lt;/code&gt;</source>
          <target state="translated">1) Igual que &lt;code&gt;noexcept&lt;/code&gt; &lt;code&gt;(&lt;/code&gt; &lt;code&gt;true&lt;/code&gt; &lt;code&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c9b60d20817d9dc8664bdd29847776bc1e84582" translate="yes" xml:space="preserve">
          <source>1) Searches for the file in implementation-defined manner. The intent of this syntax is to search for the files under control of the implementation. Typical implementations search only standard include directories. The standard C++ library and the standard C library are implicitly included in these standard include directories. The standard include directories usually can be controlled by the user through compiler options.</source>
          <target state="translated">1)Busca el archivo de manera definida por la aplicación.La intención de esta sintaxis es buscar los archivos bajo control de la implementación.Las implementaciones típicas buscan sólo en los directorios estándar.La biblioteca estándar de C++y la biblioteca estándar de C están implícitamente incluidas en estos directorios de inclusión estándar.Los directorios include estándar normalmente pueden ser controlados por el usuario a través de las opciones del compilador.</target>
        </trans-unit>
        <trans-unit id="40b026d27109ca4160eaec8af9d9260a322193ab" translate="yes" xml:space="preserve">
          <source>1) Seeds the underlying engine with the default seed value. Effectively calls &lt;code&gt;e.seed()&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the underlying engine.</source>
          <target state="translated">1) Siembra el motor subyacente con el valor de semilla predeterminado. Efectivamente llama a &lt;code&gt;e.seed()&lt;/code&gt; , donde &lt;code&gt;e&lt;/code&gt; es el motor subyacente.</target>
        </trans-unit>
        <trans-unit id="f142d0432d80c80b2801b2b54dcc353009676c5d" translate="yes" xml:space="preserve">
          <source>1) Serializes the internal state of the pseudo-random number engine &lt;code&gt;e&lt;/code&gt; as a sequence of decimal numbers separated by one or more spaces, and inserts it to the stream &lt;code&gt;ost&lt;/code&gt;. The fill character and the formatting flags of the stream are ignored and unaffected.</source>
          <target state="translated">1) Serializa el estado interno del motor de n&amp;uacute;mero pseudoaleatorio &lt;code&gt;e&lt;/code&gt; como una secuencia de n&amp;uacute;meros decimales separados por uno o m&amp;aacute;s espacios, y lo inserta en el flujo &lt;code&gt;ost&lt;/code&gt; . El car&amp;aacute;cter de relleno y los indicadores de formato de la secuencia se ignoran y no se ven afectados.</target>
        </trans-unit>
        <trans-unit id="08f8da6462aba2a7fffaed13b8fbb52f524e794c" translate="yes" xml:space="preserve">
          <source>1) Serializes the internal state of the pseudo-random number engine adaptor as a sequence of decimal numbers separated by one or more spaces, and inserts it to the stream &lt;code&gt;ost&lt;/code&gt;. The fill character and the formatting flags of the stream are ignored and unaffected.</source>
          <target state="translated">1) Serializa el estado interno del adaptador de motor de n&amp;uacute;mero pseudoaleatorio como una secuencia de n&amp;uacute;meros decimales separados por uno o m&amp;aacute;s espacios, y lo inserta en el flujo &lt;code&gt;ost&lt;/code&gt; . El car&amp;aacute;cter de relleno y los indicadores de formato de la secuencia se ignoran y no se ven afectados.</target>
        </trans-unit>
        <trans-unit id="36a998e3dc0e13d7209092f6c20763322ec5b8e6" translate="yes" xml:space="preserve">
          <source>1) Sets &lt;code&gt;loc&lt;/code&gt; as the associated locale. Calls &lt;code&gt;imbue(loc)&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) Establece &lt;code&gt;loc&lt;/code&gt; como el entorno local asociado. Llamadas &lt;code&gt;imbue(loc)&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="ed7ef78eb4d8ac7ad642d4f6b0d28e5671d8ee52" translate="yes" xml:space="preserve">
          <source>1) Sets all bits to &lt;code&gt;false&lt;/code&gt;</source>
          <target state="translated">1) Establece todos los bits en &lt;code&gt;false&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="748a476f9f45c4cb135ddad1e581399045772b64" translate="yes" xml:space="preserve">
          <source>1) Sets all bits to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) Establece todos los bits en &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2021569fa06d5efa69909df75d00a3f4cd2a9408" translate="yes" xml:space="preserve">
          <source>1) Sets the &lt;code&gt;floatfield&lt;/code&gt; of the stream &lt;code&gt;str&lt;/code&gt; to &lt;code&gt;fixed&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) Establece el &lt;code&gt;floatfield&lt;/code&gt; de la corriente &lt;code&gt;str&lt;/code&gt; al &lt;code&gt;fixed&lt;/code&gt; como si llamando &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::fixed&lt;/a&gt;, &lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::floatfield&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50dc184d36fecae99d3273c9a89db78d54bc50c8" translate="yes" xml:space="preserve">
          <source>1) Sets the bits to the result of binary AND on corresponding pairs of bits of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;.</source>
          <target state="translated">1) Establece los bits al resultado del AND binario en los pares de bits correspondientes de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1cd0d7ac969813ee13818267a9de7c1936f1da7" translate="yes" xml:space="preserve">
          <source>1) Sets the formatting flags identified by &lt;code&gt;flags&lt;/code&gt;. Effectively the following operation is performed &lt;code&gt;fl = fl | flags&lt;/code&gt; where &lt;code&gt;fl&lt;/code&gt; defines the state of internal formatting flags.</source>
          <target state="translated">1) Establece las banderas de formato identificadas por &lt;code&gt;flags&lt;/code&gt; . Efectivamente, la siguiente operaci&amp;oacute;n se realiza &lt;code&gt;fl = fl | flags&lt;/code&gt; donde &lt;code&gt;fl&lt;/code&gt; define el estado de las banderas de formato interno.</target>
        </trans-unit>
        <trans-unit id="5a76f71dc224d669d3f23245ebcbc6fe12cf100b" translate="yes" xml:space="preserve">
          <source>1) Shares ownership of the object managed by &lt;code&gt;r&lt;/code&gt;. If &lt;code&gt;r&lt;/code&gt; manages no object, &lt;code&gt;*this&lt;/code&gt; manages no object too. Equivalent to &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt;.</source>
          <target state="translated">1) Comparte la propiedad del objeto gestionado por &lt;code&gt;r&lt;/code&gt; . Si &lt;code&gt;r&lt;/code&gt; no gestiona ning&amp;uacute;n objeto, &lt;code&gt;*this&lt;/code&gt; tampoco gestiona ning&amp;uacute;n objeto. Equivalente a &lt;code&gt;shared_ptr&amp;lt;T&amp;gt;(r).swap(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="33d51240dc329ad03133b83ed63c310835b93f14" translate="yes" xml:space="preserve">
          <source>1) Shifts the elements towards the beginning of the range. If &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt;, there are no effects. Otherwise, for every integer &lt;code&gt;i&lt;/code&gt; in &lt;code&gt;[0, last - first - n)&lt;/code&gt;, moves the element originally at position &lt;code&gt;first + n + i&lt;/code&gt; to position &lt;code&gt;first + i&lt;/code&gt;. The moves are performed in increasing order of &lt;code&gt;i&lt;/code&gt; starting from &lt;code&gt;​0​&lt;/code&gt;.</source>
          <target state="translated">1) Desplaza los elementos hacia el comienzo del rango. Si &lt;code&gt;n &amp;lt;= 0 || n &amp;gt;= last - first&lt;/code&gt; , no hay efectos. De lo contrario, para cada entero &lt;code&gt;i&lt;/code&gt; en &lt;code&gt;[0, last - first - n)&lt;/code&gt; , mueve el elemento originalmente en la posici&amp;oacute;n &lt;code&gt;first + n + i&lt;/code&gt; a la posici&amp;oacute;n &lt;code&gt;first + i&lt;/code&gt; . Los movimientos se llevan a cabo en orden creciente de &lt;code&gt;i&lt;/code&gt; a partir de &lt;code&gt;​0​&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3c379223399d99299e4dd0ec4e8ae7d2df828f1" translate="yes" xml:space="preserve">
          <source>1) Specifies that a constructor  or conversion function(since C++11) is explicit, that is, it cannot be used for &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversions&lt;/a&gt; and &lt;a href=&quot;copy_initialization&quot;&gt;copy-initialization&lt;/a&gt;.</source>
          <target state="translated">1) Especifica que un constructor o una funci&amp;oacute;n de conversi&amp;oacute;n (ya que C ++ 11) es expl&amp;iacute;cito, es decir, no se puede usar para &lt;a href=&quot;implicit_cast&quot;&gt;conversiones impl&amp;iacute;citas&lt;/a&gt; y &lt;a href=&quot;copy_initialization&quot;&gt;copia de inicializaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3fc72a8629768287c31cd486267125fa2a02f24d" translate="yes" xml:space="preserve">
          <source>1) Static or thread-local references, if it is bound to static glvalue, to a temporary object (or its subobject), or to a function, and if every expression (including implicit conversions) in &lt;a href=&quot;reference_initialization&quot;&gt;the initializer&lt;/a&gt; of the reference is a &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt;.</source>
          <target state="translated">1) Referencias est&amp;aacute;ticas o locales de subproceso, si est&amp;aacute; vinculado a un valor gl est&amp;aacute;tico, a un objeto temporal (o su subobjeto), o a una funci&amp;oacute;n, y si cada expresi&amp;oacute;n (incluidas las conversiones impl&amp;iacute;citas) en &lt;a href=&quot;reference_initialization&quot;&gt;el inicializador&lt;/a&gt; de la referencia es una &lt;a href=&quot;constant_expression&quot;&gt;constante la expresi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7bba5893de10ec808038f251574bf599363a4baa" translate="yes" xml:space="preserve">
          <source>1) Steps through the character sequence &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt;, examining the characters. Every character that is not a part of a format sequence is written to the output iterator &lt;code&gt;out&lt;/code&gt; immediately. To identify format sequences, this function narrows the next character &lt;code&gt;c&lt;/code&gt; in &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; as if by &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char_type&amp;gt;(str.getloc()).narrow(c,0)&lt;/code&gt; and if it equals &lt;code&gt;'%'&lt;/code&gt;, the next one or two characters are compared to the list of format sequences recognized by &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; plus any additional implementation-defined formats supported by this locale. For each valid format sequence, a call to &lt;code&gt;do_put(out, str, fill, t, format, modifier)&lt;/code&gt; is made, where &lt;code&gt;format&lt;/code&gt; is the format sequence character, and &lt;code&gt;modifier&lt;/code&gt; is the optional format sequence modifier (&lt;code&gt;'E'&lt;/code&gt; or &lt;code&gt;'O'&lt;/code&gt;). A value of &lt;code&gt;'\0'&lt;/code&gt; is used if the modifier is absent.</source>
          <target state="translated">1) Pasos a trav&amp;eacute;s de la secuencia de caracteres &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; , examinando los caracteres. Todos los caracteres que no forman parte de una secuencia de formato se escriben en el iterador de &lt;code&gt;out&lt;/code&gt; inmediatamente. Para identificar secuencias de formato, esta funci&amp;oacute;n reduce el siguiente car&amp;aacute;cter &lt;code&gt;c&lt;/code&gt; en &lt;code&gt;[fmtbeg, fmtend)&lt;/code&gt; como si fuera &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char_type&amp;gt;(str.getloc()).narrow(c,0)&lt;/code&gt; y si es igual a &lt;code&gt;'%'&lt;/code&gt; , los siguientes uno o dos caracteres se comparan con la lista de secuencias de formato reconocidas por &lt;code&gt;&lt;a href=&quot;../../chrono/c/strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; m&amp;aacute;s cualquier formato adicional definido por la implementaci&amp;oacute;n compatible con esta configuraci&amp;oacute;n regional. Para cada secuencia de formato v&amp;aacute;lida, una llamada a &lt;code&gt;do_put(out, str, fill, t, format, modifier)&lt;/code&gt; se realiza, donde &lt;code&gt;format&lt;/code&gt; es el car&amp;aacute;cter de secuencia de formato y &lt;code&gt;modifier&lt;/code&gt; es el modificador de secuencia de formato opcional ( &lt;code&gt;'E'&lt;/code&gt; u &lt;code&gt;'O'&lt;/code&gt; ). Se utiliza un valor de &lt;code&gt;'\0'&lt;/code&gt; si el modificador est&amp;aacute; ausente.</target>
        </trans-unit>
        <trans-unit id="dbe4d06a8673e9980bbd8a34d0a33460ddce561c" translate="yes" xml:space="preserve">
          <source>1) Swaps the values &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. This overload does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_move_assignable&quot;&gt;std::is_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.(since C++17)</source>
          <target state="translated">1) intercambia los valores de &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; . Esta sobrecarga no participa en la resoluci&amp;oacute;n de sobrecarga a menos que &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../types/is_move_assignable&quot;&gt;std::is_move_assignable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; sea &lt;code&gt;true&lt;/code&gt; (desde C ++ 17)</target>
        </trans-unit>
        <trans-unit id="0e334356b91d7cf3ca8b843c79afa340cb4f3a9d" translate="yes" xml:space="preserve">
          <source>1) Template arguments (if any) are substituted into expression;</source>
          <target state="translated">1)Los argumentos de la plantilla (si los hay)se sustituyen en la expresión;</target>
        </trans-unit>
        <trans-unit id="ce2782af810444b02f25f93a1dd29f5756552166" translate="yes" xml:space="preserve">
          <source>1) The</source>
          <target state="translated">1)El</target>
        </trans-unit>
        <trans-unit id="2bf42c2016441eb61ea13c6e9fa609da95361a52" translate="yes" xml:space="preserve">
          <source>1) The &lt;a href=&quot;../preprocessor&quot;&gt;preprocessor&lt;/a&gt; is executed.</source>
          <target state="translated">1) Se ejecuta el &lt;a href=&quot;../preprocessor&quot;&gt;preprocesador&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65e8aa1cffd8b645e51e443b4510d72178b7b831" translate="yes" xml:space="preserve">
          <source>1) The &lt;a href=&quot;name&quot;&gt;name&lt;/a&gt; that is declared.</source>
          <target state="translated">1) El &lt;a href=&quot;name&quot;&gt;nombre&lt;/a&gt; que se declara.</target>
        </trans-unit>
        <trans-unit id="f433a0c89c7f1e8799b60485288073c016147e00" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; concept specifies the requirements of a &lt;a href=&quot;range&quot;&gt;&lt;code&gt;Range&lt;/code&gt;&lt;/a&gt; type that has constant time copy, move, and assignment operations (e.g. a pair of iterators, or a generator Range that creates its elements on-demand. Notably, the standard library containers are Ranges, but not Views)</source>
          <target state="translated">1) El concepto de &lt;code&gt;&lt;a href=&quot;../range/view&quot;&gt;View&lt;/a&gt;&lt;/code&gt; especifica los requisitos de un tipo de &lt;a href=&quot;range&quot;&gt; &lt;code&gt;Range&lt;/code&gt; &lt;/a&gt; que tiene operaciones de copia, movimiento y asignaci&amp;oacute;n de tiempo constante (por ejemplo, un par de iteradores o un Rango de generador que crea sus elementos a pedido. En particular, los contenedores de biblioteca est&amp;aacute;ndar son Rangos , pero no Vistas)</target>
        </trans-unit>
        <trans-unit id="ec5eeb1c920435edfac9357c193554b45fa0d085" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;Range&lt;/code&gt; concept defines the requirements of a type that allows iteration over its elements by providing an iterator and sentinel that denote the elements of the range.</source>
          <target state="translated">1) El concepto de &lt;code&gt;Range&lt;/code&gt; define los requisitos de un tipo que permite la iteraci&amp;oacute;n sobre sus elementos al proporcionar un iterador y un centinela que denotan los elementos del rango.</target>
        </trans-unit>
        <trans-unit id="5664b3fe1fc216eb8579abb8ca6fc0ab64244ff1" translate="yes" xml:space="preserve">
          <source>1) The &lt;code&gt;auto&lt;/code&gt; specifier was only allowed for objects declared at block scope or in function parameter lists. It indicated automatic storage duration, which is the default for these kinds of declarations. The meaning of this keyword was changed in C++11.</source>
          <target state="translated">1) El especificador &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tico solo se permit&amp;iacute;a para los objetos declarados en el alcance del bloque o en las listas de par&amp;aacute;metros de funciones. Indicaba la duraci&amp;oacute;n del almacenamiento autom&amp;aacute;tico, que es el valor predeterminado para este tipo de declaraciones. El significado de esta palabra clave se modific&amp;oacute; en C ++ 11.</target>
        </trans-unit>
        <trans-unit id="5771f1de4aaeaaa160fa4e631f3e630380eaf437" translate="yes" xml:space="preserve">
          <source>1) The a distribution parameter (location).</source>
          <target state="translated">1)El parámetro de distribución a (ubicación).</target>
        </trans-unit>
        <trans-unit id="a56f4b7e28c5e16ec27cb41041cbe5d377ab7dae" translate="yes" xml:space="preserve">
          <source>1) The alternative name this &lt;code&gt;link&lt;/code&gt; object represents.</source>
          <target state="translated">1) El nombre alternativo que este objeto de &lt;code&gt;link&lt;/code&gt; representa.</target>
        </trans-unit>
        <trans-unit id="13892ed49e94589b6b3b35aa23f26504383e1f3e" translate="yes" xml:space="preserve">
          <source>1) The argument list cannot be identical to the non-specialized argument list (it must specialize something)</source>
          <target state="translated">1)La lista de argumentos no puede ser idéntica a la lista de argumentos no especializada (debe especializar algo)</target>
        </trans-unit>
        <trans-unit id="55233ebd70c2b08df11e491094ea36d0775f225f" translate="yes" xml:space="preserve">
          <source>1) The associated parameter set.</source>
          <target state="translated">1)El conjunto de parámetros asociados.</target>
        </trans-unit>
        <trans-unit id="8cb340ccead28657a0f96c703f2768d7cbbcc0cb" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments or with &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; as the argument)</source>
          <target state="translated">1) La persona que llama solicita que el &amp;aacute;rea de obtenci&amp;oacute;n est&amp;eacute; respaldada por un car&amp;aacute;cter ( &lt;code&gt;pbackfail()&lt;/code&gt; se llama sin argumentos o con &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;EOF&lt;/a&gt;&lt;/code&gt; como argumento)</target>
        </trans-unit>
        <trans-unit id="3b59d07570db328903bdf39c6ee15b2e5874d234" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments or with &lt;code&gt;Traits::eof()&lt;/code&gt; as the argument)</source>
          <target state="translated">1) La persona que llama solicita que el &amp;aacute;rea de obtenci&amp;oacute;n est&amp;eacute; respaldada por un car&amp;aacute;cter ( &lt;code&gt;pbackfail()&lt;/code&gt; se llama sin argumentos o con &lt;code&gt;Traits::eof()&lt;/code&gt; como argumento)</target>
        </trans-unit>
        <trans-unit id="61adb3e6b0b307a7e54bcae25d20d2e0a7936478" translate="yes" xml:space="preserve">
          <source>1) The caller is requesting that the get area is backed up by one character (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments), in which case, this function re-reads the file starting one byte earlier and decrements &lt;a href=&quot;../basic_streambuf/gptr&quot;&gt;&lt;code&gt;basic_streambuf::gptr()&lt;/code&gt;&lt;/a&gt;, e.g. by calling &lt;code&gt;gbump(-1)&lt;/code&gt;.</source>
          <target state="translated">1) La persona que llama solicita que el &amp;aacute;rea de obtenci&amp;oacute;n est&amp;eacute; respaldada por un car&amp;aacute;cter ( se llama a &lt;code&gt;pbackfail()&lt;/code&gt; sin argumentos), en cuyo caso, esta funci&amp;oacute;n vuelve a leer el archivo comenzando un byte antes y disminuye &lt;a href=&quot;../basic_streambuf/gptr&quot;&gt; &lt;code&gt;basic_streambuf::gptr()&lt;/code&gt; &lt;/a&gt; , por ejemplo, llamando a &lt;code&gt;gbump(-1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1ae7223669c573a68efa4c16b06f3ce8570f1d7" translate="yes" xml:space="preserve">
          <source>1) The concept &lt;code&gt;StrictTotallyOrdered&amp;lt;T&amp;gt;&lt;/code&gt; specifies that the comparison operators &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; on &lt;code&gt;T&lt;/code&gt; yield results consistent with a &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;strict total order&lt;/a&gt; on &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) El concepto &lt;code&gt;StrictTotallyOrdered&amp;lt;T&amp;gt;&lt;/code&gt; especifica que los operadores de comparaci&amp;oacute;n &lt;code&gt;==,!=,&amp;lt;,&amp;gt;,&amp;lt;=,&amp;gt;=&lt;/code&gt; En &lt;code&gt;T&lt;/code&gt; resultados de rendimiento consistentes con un &lt;a href=&quot;https://en.wikipedia.org/wiki/Total_order#Strict_total_order&quot;&gt;estricto orden total&lt;/a&gt; en &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="692cf4b8d8f5f53ecfe4d474f1ec25af3dddecf7" translate="yes" xml:space="preserve">
          <source>1) The constructor initializes the member object (of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt;) from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt;. Throws any exception thrown by the constructor selected</source>
          <target state="translated">1) El constructor inicializa el objeto miembro (de tipo &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;F&amp;gt;&lt;/code&gt; ) desde &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;F&amp;gt;(f)&lt;/code&gt; . Lanza cualquier excepci&amp;oacute;n lanzada por el constructor seleccionado</target>
        </trans-unit>
        <trans-unit id="2b56e5f14d5ec78f7a1a9e935292dc9c4e9c4bc1" translate="yes" xml:space="preserve">
          <source>1) The copy assignment operator is protected, and is deleted. Input streams are not CopyAssignable.</source>
          <target state="translated">1)El operador de asignación de copias está protegido,y es eliminado.Los flujos de entrada no son asignables a la copia.</target>
        </trans-unit>
        <trans-unit id="cb957de92fc95959bfc746d86ce3609a64f1a4fd" translate="yes" xml:space="preserve">
          <source>1) The copy assignment operator is protected, and is deleted. Output streams are not CopyAssignable.</source>
          <target state="translated">1)El operador de asignación de copias está protegido,y es eliminado.Los flujos de salida no son asignables a la copia.</target>
        </trans-unit>
        <trans-unit id="e34654c2e919d3a91813ff3288559504fc22e14a" translate="yes" xml:space="preserve">
          <source>1) The copy constructor is deleted: streams are not copyable.</source>
          <target state="translated">1)El constructor de la copia se borra:los flujos no son copiables.</target>
        </trans-unit>
        <trans-unit id="10e7c6895d9ef10be5943bb1587dc03b33198d2f" translate="yes" xml:space="preserve">
          <source>1) The current exception mask.</source>
          <target state="translated">1)La actual máscara de excepción.</target>
        </trans-unit>
        <trans-unit id="3abfb5553c81efc2e23dc953228b75d755237163" translate="yes" xml:space="preserve">
          <source>1) The default constructor creates a &lt;code&gt;std::seed_seq&lt;/code&gt; object with an initial seed sequence of length zero.</source>
          <target state="translated">1) El constructor predeterminado crea un objeto &lt;code&gt;std::seed_seq&lt;/code&gt; con una secuencia inicial de inicializaci&amp;oacute;n de longitud cero.</target>
        </trans-unit>
        <trans-unit id="4e2c38841269bc097ae1c47eda71b3fbdeb21c7e" translate="yes" xml:space="preserve">
          <source>1) The default constructor is defaulted.</source>
          <target state="translated">1)El constructor por defecto está predeterminado.</target>
        </trans-unit>
        <trans-unit id="eaa9c330e0c1827f710a288a9214aaa3553943cf" translate="yes" xml:space="preserve">
          <source>1) The default constructor is trivial: no initialization takes place other than &lt;a href=&quot;../../language/zero_initialization&quot;&gt;zero initialization&lt;/a&gt; of static and thread-local objects. &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt; may be used to complete initialization.</source>
          <target state="translated">1) El constructor predeterminado es trivial: no se realiza ninguna inicializaci&amp;oacute;n que no sea la inicializaci&amp;oacute;n &lt;a href=&quot;../../language/zero_initialization&quot;&gt;cero&lt;/a&gt; de objetos est&amp;aacute;ticos y locales de subprocesos. &lt;code&gt;&lt;a href=&quot;../atomic_init&quot;&gt;std::atomic_init&lt;/a&gt;&lt;/code&gt; puede usarse para completar la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a6475c63291c6da877aa299aa6f4d12b026b2cf4" translate="yes" xml:space="preserve">
          <source>1) The default, equivalent to (2) with &lt;code&gt;copy_options::none&lt;/code&gt; used as &lt;code&gt;options&lt;/code&gt;</source>
          <target state="translated">1) El valor predeterminado, equivalente a (2) con &lt;code&gt;copy_options::none&lt;/code&gt; utilizado como &lt;code&gt;options&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf4124c6a6217a2beb35fda41d126dc7a4ceaa8e" translate="yes" xml:space="preserve">
          <source>1) The destructors of objects with thread local &lt;a href=&quot;../../language/storage_duration&quot;&gt;storage duration&lt;/a&gt; that are associated with the current thread, the destructors of objects with static storage duration, and the functions registered with &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are executed concurrently, while maintaining the following guarantees: a) The last destructor for thread-local objects is &lt;a href=&quot;../../language/eval_order&quot;&gt;sequenced-before&lt;/a&gt; the first destructor for a static object b) If the completion of the constructor or &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;dynamic initialization&lt;/a&gt; for thread-local or static object A was sequenced-before thread-local or static object B, the completion of the destruction of B is sequenced-before the start of the destruction of A c) If the completion of the initialization of a static object A was sequenced-before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F, the call to F during termination is sequenced-before the start of the destruction of A d) If the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F was sequenced-before the completion of initialization of a static object A, the start of the destruction of A is sequenced-before the call to F during termination. e) If a call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F1 was sequenced-before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F2, then the call to F2 during termination is sequenced-before the call to F1</source>
          <target state="translated">1) Los destructores de objetos con &lt;a href=&quot;../../language/storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; local de subprocesos que est&amp;aacute;n asociados con el subproceso actual, los destructores de objetos con duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico y las funciones registradas con &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; se ejecutan simult&amp;aacute;neamente, manteniendo las siguientes garant&amp;iacute;as: a) el &amp;uacute;ltimo destructor para objetos locales de subprocesos se &lt;a href=&quot;../../language/eval_order&quot;&gt;secuencia antes&lt;/a&gt; del primer destructor para un objeto est&amp;aacute;tico b) Si la finalizaci&amp;oacute;n del constructor o &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;la inicializaci&amp;oacute;n din&amp;aacute;mica&lt;/a&gt; para el objeto local o subproceso A se secuenciaron antes del objeto B local o subproceso est&amp;aacute;tico, el la finalizaci&amp;oacute;n de la destrucci&amp;oacute;n de B se secuencia antes del inicio de la destrucci&amp;oacute;n de A c) Si la finalizaci&amp;oacute;n de la inicializaci&amp;oacute;n de un objeto est&amp;aacute;tico A se secuencia antes de la llamada a &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; para alguna funci&amp;oacute;n F, la llamada a F durante la terminaci&amp;oacute;n se secuencia antes del inicio de la destrucci&amp;oacute;n de A d) Si la llamada a &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; para alguna funci&amp;oacute;n F se secuencia antes de completar la inicializaci&amp;oacute;n de un objeto est&amp;aacute;tico A, el inicio de la destrucci&amp;oacute;n de A se secuencia antes de la llamada a F durante la terminaci&amp;oacute;n. e) Si una llamada a &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; para alguna funci&amp;oacute;n F1 fue secuenciada antes de la llamada a &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; para alguna funci&amp;oacute;n F2, entonces la llamada a F2 durante la terminaci&amp;oacute;n se secuencia antes de la llamada a F1</target>
        </trans-unit>
        <trans-unit id="984436ed4409399ee56d2edafaa76fa5827ade9b" translate="yes" xml:space="preserve">
          <source>1) The execution policy type used as a unique type to disambiguate parallel algorithm overloading and require that a parallel algorithm's execution may not be parallelized. The invocations of element access functions in parallel algorithms invoked with this policy (usually specified as &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::seq&lt;/a&gt;&lt;/code&gt;) are indeterminately sequenced in the calling thread.</source>
          <target state="translated">1) El tipo de pol&amp;iacute;tica de ejecuci&amp;oacute;n utilizado como un tipo &amp;uacute;nico para desambiguar la sobrecarga de algoritmos paralelos y requerir que la ejecuci&amp;oacute;n de un algoritmo paralelo no se pueda paralelizar. Las invocaciones de las funciones de acceso a elementos en algoritmos paralelos invocados con esta pol&amp;iacute;tica (generalmente especificada como &lt;code&gt;&lt;a href=&quot;execution_policy_tag&quot;&gt;std::execution::seq&lt;/a&gt;&lt;/code&gt; ) se secuencian indeterminadamente en el hilo de llamada.</target>
        </trans-unit>
        <trans-unit id="e362b206dffda02474ab2c007c80f4e6c881bbd6" translate="yes" xml:space="preserve">
          <source>1) The exponent syntax for a decimal floating-point literal</source>
          <target state="translated">1)La sintaxis del exponente para un literal decimal de punto flotante</target>
        </trans-unit>
        <trans-unit id="64cdf221b5add07010de335de6d59fa388267951" translate="yes" xml:space="preserve">
          <source>1) The file or empty directory identified by the path &lt;code&gt;p&lt;/code&gt; is deleted as if by the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove&lt;/a&gt;. Symlinks are not followed (symlink is removed, not its target)</source>
          <target state="translated">1) El archivo o directorio vac&amp;iacute;o identificado por la ruta &lt;code&gt;p&lt;/code&gt; se elimina como si fuera por POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/remove.html&quot;&gt;remove&lt;/a&gt; . No se siguen los enlaces simb&amp;oacute;licos (se elimina el enlace simb&amp;oacute;lico, no su objetivo)</target>
        </trans-unit>
        <trans-unit id="9be6415eb11ca6d2a6ae2ef6b1a8ebf53b49733f" translate="yes" xml:space="preserve">
          <source>1) The first operand must be an expression of &lt;a href=&quot;incomplete_type&quot;&gt;complete class type&lt;/a&gt;&lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) El primer operando debe ser una expresi&amp;oacute;n de &lt;a href=&quot;incomplete_type&quot;&gt;tipo de clase completa &lt;/a&gt; &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f5ef6f6f7feb816947d23a3ea4f22b9c37b4705" translate="yes" xml:space="preserve">
          <source>1) The format character sequence is defined by the range &lt;code&gt;[fmt_first, fmt_last)&lt;/code&gt;. The resulting character sequence is copied to &lt;code&gt;out&lt;/code&gt;.</source>
          <target state="translated">1) La secuencia de caracteres de formato se define por el rango &lt;code&gt;[fmt_first, fmt_last)&lt;/code&gt; . La secuencia de caracteres resultante se copia a &lt;code&gt;out&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95de870e8f49a93ec939ffd632a40a00558bdce7" translate="yes" xml:space="preserve">
          <source>1) The individual bytes of the source code file are mapped (in implementation-defined manner) to the characters of the</source>
          <target state="translated">1)Los bytes individuales del archivo de código fuente se asignan (de manera definida por la aplicación)a los caracteres del</target>
        </trans-unit>
        <trans-unit id="f69e48ffceb6307d147e62ebd3e15bb7bcf22d41" translate="yes" xml:space="preserve">
          <source>1) The length &lt;code&gt;rlen&lt;/code&gt; of the sequences to compare is the smaller of &lt;code&gt;size()&lt;/code&gt; and &lt;code&gt;v.size()&lt;/code&gt;. The function compares the two views by calling &lt;code&gt;traits::compare(data(), v.data(), rlen)&lt;/code&gt;, and returns a value according to the following table:</source>
          <target state="translated">1) La longitud &lt;code&gt;rlen&lt;/code&gt; de las secuencias a comparar es la m&amp;aacute;s peque&amp;ntilde;a de &lt;code&gt;size()&lt;/code&gt; y &lt;code&gt;v.size()&lt;/code&gt; . La funci&amp;oacute;n compara las dos vistas llamando a &lt;code&gt;traits::compare(data(), v.data(), rlen)&lt;/code&gt; , y devuelve un valor de acuerdo con la siguiente tabla:</target>
        </trans-unit>
        <trans-unit id="4037f7821b91877636d406cbce1bcacb0689bf42" translate="yes" xml:space="preserve">
          <source>1) The lifetime of the object allocated by E1 strictly contains the lifetime of the object allocated by E2, 2) E1 and E2 would invoke the same replaceable global allocation function 3) For a throwing allocation function, exceptions in E1 and E2 would be first caught in the same handler.</source>
          <target state="translated">1)La vida útil del objeto asignado por E1 contiene estrictamente la vida útil del objeto asignado por E2,2)E1 y E2 invocarían la misma función de asignación global reemplazable 3)Para una función de asignación de lanzamientos,las excepciones en E1 y E2 serían primero atrapadas en el mismo manejador.</target>
        </trans-unit>
        <trans-unit id="b5680fbc09a44d73240f35e66072e9eb23f44a63" translate="yes" xml:space="preserve">
          <source>1) The list of boundaries of the intervals.</source>
          <target state="translated">1)La lista de los límites de los intervalos.</target>
        </trans-unit>
        <trans-unit id="b88da70e98e0b2688aca929c023fd479e8e2afd6" translate="yes" xml:space="preserve">
          <source>1) The log-mean m distribution parameter.</source>
          <target state="translated">1)El parámetro de distribución logarítmica m.</target>
        </trans-unit>
        <trans-unit id="58a51494ba725af135bdfe4838b9d7d460044580" translate="yes" xml:space="preserve">
          <source>1) The m (the first degree of freedom) distribution parameter.</source>
          <target state="translated">1)El parámetro de distribución m (el primer grado de libertad).</target>
        </trans-unit>
        <trans-unit id="253b910778e1d968599094f0f2559f6818ab03e8" translate="yes" xml:space="preserve">
          <source>1) The mean &amp;mu; distribution parameter.</source>
          <target state="translated">1) El par&amp;aacute;metro de distribuci&amp;oacute;n media &amp;mu;.</target>
        </trans-unit>
        <trans-unit id="419ac7c350c315de0c2fc313d43dafe994bfe4ae" translate="yes" xml:space="preserve">
          <source>1) The members declared after the specifier have public member access</source>
          <target state="translated">1)Los miembros declarados después de que el especificador tenga acceso público a los miembros</target>
        </trans-unit>
        <trans-unit id="bd8f7818635373bb03d0e69a14d67db0b342bd5c" translate="yes" xml:space="preserve">
          <source>1) The nested-name-specifier (everything to the left of the scope resolution operator &lt;code&gt;::&lt;/code&gt;) of a type that was specified using a &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;qualified-id&lt;/a&gt;:</source>
          <target state="translated">1) El especificador de nombre anidado (todo a la izquierda del operador de resoluci&amp;oacute;n de alcance &lt;code&gt;::&lt;/code&gt; ) de un tipo que se especific&amp;oacute; usando un &lt;a href=&quot;name#Qualified_identifiers&quot;&gt;id calificado&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="c5d2d5ea95e95309310a1f70f09cdbb08741b9eb" translate="yes" xml:space="preserve">
          <source>1) The new element is initialized as a copy of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) El nuevo elemento se inicializa como una copia de &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="805754d1d5d23696faf5387fb9f75302e9f3de82" translate="yes" xml:space="preserve">
          <source>1) The non-specialized &lt;code&gt;default_delete&lt;/code&gt; uses &lt;code&gt;delete&lt;/code&gt; to deallocate memory for a single object.</source>
          <target state="translated">1) &lt;code&gt;default_delete&lt;/code&gt; no especializado utiliza &lt;code&gt;delete&lt;/code&gt; para desasignar memoria para un solo objeto.</target>
        </trans-unit>
        <trans-unit id="078ba3fdb2f0208dd9e2307c39e67cfe68c5c1db" translate="yes" xml:space="preserve">
          <source>1) The non-specialized &lt;code&gt;pointer_traits&lt;/code&gt; declares the following types:</source>
          <target state="translated">1) El &lt;code&gt;pointer_traits&lt;/code&gt; no especializado declara los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="92f8554972361f85396cc946915b450c4ce836c2" translate="yes" xml:space="preserve">
          <source>1) The normal form of the path</source>
          <target state="translated">1)La forma normal del camino</target>
        </trans-unit>
        <trans-unit id="7fcadaf3a1d0805d8241d4dcda9467625d082466" translate="yes" xml:space="preserve">
          <source>1) The operators works on valarrays of the same size and returns a valarray with the same size as the parameters with the operation applied to every elements of the two arguments.</source>
          <target state="translated">1)El operador trabaja en valarrays del mismo tamaño y devuelve un valarray del mismo tamaño que los parámetros con la operación aplicada a cada elemento de los dos argumentos.</target>
        </trans-unit>
        <trans-unit id="2682843d9db3de2fe0979f65226c8ec0ffc4a1ff" translate="yes" xml:space="preserve">
          <source>1) The p distribution parameter.</source>
          <target state="translated">1)El parámetro de distribución p.</target>
        </trans-unit>
        <trans-unit id="52a76b9c4dc5d777618976dffcda053ec848076c" translate="yes" xml:space="preserve">
          <source>1) The pointer to the beginning of the get area.</source>
          <target state="translated">1)El puntero al principio del área de obtención.</target>
        </trans-unit>
        <trans-unit id="2788ad850b2bbb3bcd1e26f30ae2197560170280" translate="yes" xml:space="preserve">
          <source>1) The pointer to the beginning of the put area.</source>
          <target state="translated">1)El puntero al principio de la zona de puesta.</target>
        </trans-unit>
        <trans-unit id="ecd0301c6f2ffe2d0819343a365dcb5dd5fc514c" translate="yes" xml:space="preserve">
          <source>1) The program is ill-formed if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">1) El programa est&amp;aacute; mal formado si &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;T, const U&amp;amp;&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76d0af0682d39a23e608870d902e924d40731f41" translate="yes" xml:space="preserve">
          <source>1) The random number generator is implementation-defined, but the function &lt;code&gt;&lt;a href=&quot;../numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; is often used.</source>
          <target state="translated">1) El generador de n&amp;uacute;meros aleatorios est&amp;aacute; definido por la implementaci&amp;oacute;n, pero a menudo se usa la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../numeric/random/rand&quot;&gt;std::rand&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcb6ec55992b506b45ac666f76eb78e9d99e9237" translate="yes" xml:space="preserve">
          <source>1) The real part.</source>
          <target state="translated">1)La parte real.</target>
        </trans-unit>
        <trans-unit id="04499347610e4d853510728a08aea977c3eea26d" translate="yes" xml:space="preserve">
          <source>1) The result of &lt;code&gt;lhs.equal(rhs)&lt;/code&gt;.</source>
          <target state="translated">1) El resultado de &lt;code&gt;lhs.equal(rhs)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acdfeea6d1916156d222310691b55c364fcf71aa" translate="yes" xml:space="preserve">
          <source>1) The result of dereferencing the stored pointer, i.e., &lt;code&gt;*get()&lt;/code&gt;</source>
          <target state="translated">1) El resultado de desreferenciar el puntero almacenado, es decir, &lt;code&gt;*get()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="85369193a6efe2baa8eac212d4d41eca7c7a29a4" translate="yes" xml:space="preserve">
          <source>1) The return type is deduced from the returned expression as if by &lt;code&gt;decltype&lt;/code&gt;. The call is ill-formed if the invocation above is not a valid expression of the same type and value category, for all combinations of alternative types of all variants.</source>
          <target state="translated">1) El tipo de retorno se deduce de la expresi&amp;oacute;n devuelta como si fuera por tipo de &lt;code&gt;decltype&lt;/code&gt; . La llamada est&amp;aacute; mal formada si la invocaci&amp;oacute;n anterior no es una expresi&amp;oacute;n v&amp;aacute;lida del mismo tipo y categor&amp;iacute;a de valor, para todas las combinaciones de tipos alternativos de todas las variantes.</target>
        </trans-unit>
        <trans-unit id="7a36ba71f6e55e9d3da53e756c59b3b06287b854" translate="yes" xml:space="preserve">
          <source>1) The return type meets the requirements of mutable &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;.</source>
          <target state="translated">1) El tipo de retorno cumple los requisitos de &lt;a href=&quot;../../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; mutable .</target>
        </trans-unit>
        <trans-unit id="6d3e7aa24867d0d8995a957c6318cd61a05292ec" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt;.</source>
          <target state="translated">1) El valor de retorno de &lt;code&gt;seekoff(off, dir, which)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dae9b5cd9ae861b669c70c471b4d08d50f4c940b" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;seekpos(pos, which)&lt;/code&gt;.</source>
          <target state="translated">1) El valor de retorno de &lt;code&gt;seekpos(pos, which)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="898a982d82a90b60748ffe31055974436184caf1" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;setbuf(s, n)&lt;/code&gt;</source>
          <target state="translated">1) El valor de retorno de &lt;code&gt;setbuf(s, n)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1e96b281892b82cedb8d59abb7f447580daa3b5f" translate="yes" xml:space="preserve">
          <source>1) The return value of &lt;code&gt;sync()&lt;/code&gt;.</source>
          <target state="translated">1) El valor de retorno de &lt;code&gt;sync()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ca5f89c229d3f7753b51b3a66ee13e45d0b0f54" translate="yes" xml:space="preserve">
          <source>1) The source file is decomposed into &lt;a href=&quot;../comments&quot;&gt;comments&lt;/a&gt;, sequences of whitespace characters (space, horizontal tab, new-line, vertical tab, and form-feed), and</source>
          <target state="translated">1) El archivo fuente se descompone en &lt;a href=&quot;../comments&quot;&gt;comentarios&lt;/a&gt; , secuencias de caracteres de espacio en blanco (espacio, pesta&amp;ntilde;a horizontal, nueva l&amp;iacute;nea, pesta&amp;ntilde;a vertical y avance de formulario), y</target>
        </trans-unit>
        <trans-unit id="36843ad5bce393e021d99643d395dab108c20cf9" translate="yes" xml:space="preserve">
          <source>1) The sum of the given value and elements in the given range.</source>
          <target state="translated">1)La suma del valor dado y los elementos en el rango dado.</target>
        </trans-unit>
        <trans-unit id="3b61bf4f0d9f6b04457c1b40ba6668a669b49d56" translate="yes" xml:space="preserve">
          <source>1) The time of the last modification of &lt;code&gt;p&lt;/code&gt;</source>
          <target state="translated">1) El tiempo de la &amp;uacute;ltima modificaci&amp;oacute;n de &lt;code&gt;p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="79302ea48e89e5dd8b66c9d489a0b5d0f35c2a34" translate="yes" xml:space="preserve">
          <source>1) The unary operation &lt;code&gt;unary_op&lt;/code&gt; is applied to the range defined by &lt;code&gt;[first1, last1)&lt;/code&gt;.</source>
          <target state="translated">1) La operaci&amp;oacute;n unaria &lt;code&gt;unary_op&lt;/code&gt; se aplica al rango definido por &lt;code&gt;[first1, last1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="367330e87475392565d07397877349fb08e6bda2" translate="yes" xml:space="preserve">
          <source>1) The value &lt;code&gt;v&lt;/code&gt; stored in the shared state, as &lt;code&gt;std::move(v)&lt;/code&gt;.</source>
          <target state="translated">1) El valor &lt;code&gt;v&lt;/code&gt; almacenado en el estado compartido, como &lt;code&gt;std::move(v)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86eb511f8878afb18a55683fb47df9cdcc07ce8f" translate="yes" xml:space="preserve">
          <source>1) The value of A is used as an operand of B, &lt;b&gt;except&lt;/b&gt;</source>
          <target state="translated">1) El valor de A se usa como un operando de B, &lt;b&gt;excepto&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7811702fe1807599a0bc78db6abc9c5bbdecab5f" translate="yes" xml:space="preserve">
          <source>1) The value of the</source>
          <target state="translated">1)El valor de la</target>
        </trans-unit>
        <trans-unit id="411cbaa6e8bdadb2ed80c96fcee27228278863bb" translate="yes" xml:space="preserve">
          <source>1) The value of the a parameter.</source>
          <target state="translated">1)El valor del parámetro a.</target>
        </trans-unit>
        <trans-unit id="ba3ffa0db89ccb1cd6d655154c05da75ee6c8142" translate="yes" xml:space="preserve">
          <source>1) The value of the obtained character.</source>
          <target state="translated">1)El valor del carácter obtenido.</target>
        </trans-unit>
        <trans-unit id="d34b7e1f53cc8550900ee8f2d0ed3e332b4489a8" translate="yes" xml:space="preserve">
          <source>1) The value returned by the selected invocation of the visitor.</source>
          <target state="translated">1)El valor devuelto por la invocación seleccionada del visitante.</target>
        </trans-unit>
        <trans-unit id="12cff07a54521cd958ba1ef6524cdcabff900eb6" translate="yes" xml:space="preserve">
          <source>1) The version of this function in the non-specialized &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; template simply calls &lt;code&gt;Ptr::pointer_to(r)&lt;/code&gt;, and if Ptr does not provide a static member function &lt;code&gt;pointer_to&lt;/code&gt;, instantiation of this function is a compile-time error.</source>
          <target state="translated">1) La versi&amp;oacute;n de esta funci&amp;oacute;n en la plantilla &lt;code&gt;&lt;a href=&quot;../pointer_traits&quot;&gt;std::pointer_traits&lt;/a&gt;&lt;/code&gt; no especializada simplemente llama &lt;code&gt;Ptr::pointer_to(r)&lt;/code&gt; , y si Ptr no proporciona una funci&amp;oacute;n miembro est&amp;aacute;tica &lt;code&gt;pointer_to&lt;/code&gt; , la instanciaci&amp;oacute;n de esta funci&amp;oacute;n es un error en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="77538230530c6dca9afa92eaff1c01d3485f9dd2" translate="yes" xml:space="preserve">
          <source>1) There is no putback position in the get area (&lt;code&gt;pbackfail()&lt;/code&gt; is called with no arguments). In this situation, the purpose of &lt;code&gt;pbackfail()&lt;/code&gt; is to back up the get area by one character, if the associated character sequence allows this (e.g. a file-backed streambuf may reload the buffer from a file, starting one character earlier).</source>
          <target state="translated">1) No hay una posici&amp;oacute;n de devoluci&amp;oacute;n en el &amp;aacute;rea de &lt;code&gt;pbackfail()&lt;/code&gt; se llama a pbackfail () sin argumentos). En esta situaci&amp;oacute;n, el prop&amp;oacute;sito de &lt;code&gt;pbackfail()&lt;/code&gt; es hacer una copia de seguridad del &amp;aacute;rea de obtenci&amp;oacute;n por un car&amp;aacute;cter, si la secuencia de caracteres asociada lo permite (por ejemplo, un streambuf respaldado por un archivo puede volver a cargar el b&amp;uacute;fer desde un archivo, comenzando un car&amp;aacute;cter antes).</target>
        </trans-unit>
        <trans-unit id="082233e2ccf1fae9f66efcf578a3583588a32ecb" translate="yes" xml:space="preserve">
          <source>1) There may be &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;more than one definition&lt;/a&gt; of an inline function or variable(since C++17) in the program as long as each definition appears in a different translation unit and (for non-static inline functions and variables(since C++17)) all definitions are identical. For example, an inline function or an inline variable(since C++17) may be defined in a header file that is #include'd in multiple source files.</source>
          <target state="translated">1) Puede haber &lt;a href=&quot;definition#One_Definition_Rule&quot;&gt;m&amp;aacute;s de una definici&amp;oacute;n&lt;/a&gt; de una funci&amp;oacute;n o variable en l&amp;iacute;nea (desde C ++ 17) en el programa siempre que cada definici&amp;oacute;n aparezca en una unidad de traducci&amp;oacute;n diferente y (para funciones y variables en l&amp;iacute;nea no est&amp;aacute;ticas (desde C + +17)) todas las definiciones son id&amp;eacute;nticas. Por ejemplo, una funci&amp;oacute;n en l&amp;iacute;nea o una variable en l&amp;iacute;nea (desde C ++ 17) puede definirse en un archivo de encabezado que se incluye en varios archivos de origen.</target>
        </trans-unit>
        <trans-unit id="7d6e10081835eca22b9e463651b1d3a90697a7c7" translate="yes" xml:space="preserve">
          <source>1) This &lt;a href=&quot;../../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; to allow deduction from functions.</source>
          <target state="translated">1) Esta &lt;a href=&quot;../../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; para permitir la deducci&amp;oacute;n de funciones.</target>
        </trans-unit>
        <trans-unit id="e77ab4d038ceec4a1c67d2938de66955af3e7eb7" translate="yes" xml:space="preserve">
          <source>1) This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">1) Esta &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; para permitir la deducci&amp;oacute;n de un rango de iterador. Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; y &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4e69d6a2bc178876f9e3235945528240ffcb9250" translate="yes" xml:space="preserve">
          <source>1) This overload only participates in overload resolution if T is not a specialization of std::pair. Returns &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; determined as follows:</source>
          <target state="translated">1) Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si T no es una especializaci&amp;oacute;n de std :: pair. Devuelve &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; determinado de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="5fbbf8a15549659900cafa2f8939bbc4169ae318" translate="yes" xml:space="preserve">
          <source>1) Throws a &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; if the conversion is ambiguous. Throws a &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; if &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time.</source>
          <target state="translated">1) Lanza un &lt;code&gt;std::chrono::ambiguous_local_time&lt;/code&gt; si la conversi&amp;oacute;n es ambigua. Lanza un &lt;code&gt;std::chrono::nonexistent_local_time&lt;/code&gt; si &lt;code&gt;tp&lt;/code&gt; representa un tiempo inexistente.</target>
        </trans-unit>
        <trans-unit id="2906ceaa024eb508139cc21c6337dbb9e099baa0" translate="yes" xml:space="preserve">
          <source>1) Throws an exception if the conversion is ambiguous or if &lt;code&gt;tp&lt;/code&gt; represents a nonexistent time.</source>
          <target state="translated">1) Lanza una excepci&amp;oacute;n si la conversi&amp;oacute;n es ambigua o si &lt;code&gt;tp&lt;/code&gt; representa un tiempo inexistente.</target>
        </trans-unit>
        <trans-unit id="c11d4dcc55409becc8aa818ff21922ca67ab791c" translate="yes" xml:space="preserve">
          <source>1) Throws any exceptions thrown by &lt;code&gt;m.lock()&lt;/code&gt;</source>
          <target state="translated">1) Lanza cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;m.lock()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="843bb0e7d49c747ed1e190035bed5b051758038e" translate="yes" xml:space="preserve">
          <source>1) Throws any exceptions thrown by &lt;code&gt;m.lock()&lt;/code&gt;.</source>
          <target state="translated">1) Lanza cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;m.lock()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ee3b5d9f3ed3870841a5598217596f3a883f2a" translate="yes" xml:space="preserve">
          <source>1) Transfers all elements from &lt;code&gt;other&lt;/code&gt; into &lt;code&gt;*this&lt;/code&gt;. The elements are inserted before the element pointed to by &lt;code&gt;pos&lt;/code&gt;. The container &lt;code&gt;other&lt;/code&gt; becomes empty after the operation. The behavior is undefined if &lt;code&gt;other&lt;/code&gt; refers to the same object as &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">1) Transfiere todos los elementos de &lt;code&gt;other&lt;/code&gt; a &lt;code&gt;*this&lt;/code&gt; . Los elementos se insertan antes del elemento se&amp;ntilde;alado por &lt;code&gt;pos&lt;/code&gt; . El &lt;code&gt;other&lt;/code&gt; contenedor se vac&amp;iacute;a despu&amp;eacute;s de la operaci&amp;oacute;n. El comportamiento es indefinido si &lt;code&gt;other&lt;/code&gt; refiere al mismo objeto que &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6fff766c5a8c7a2f8e138a2e07caea5eb67929f1" translate="yes" xml:space="preserve">
          <source>1) Transfers ownership from &lt;code&gt;r&lt;/code&gt; to &lt;code&gt;*this&lt;/code&gt; as if by calling &lt;code&gt;reset(r.release())&lt;/code&gt; followed by an assignment of &lt;code&gt;&lt;a href=&quot;get_deleter&quot;&gt;get_deleter()&lt;/a&gt;&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;E&amp;gt;(r.get_deleter())&lt;/code&gt;.</source>
          <target state="translated">1) Transfiere la propiedad de &lt;code&gt;r&lt;/code&gt; a &lt;code&gt;*this&lt;/code&gt; como si llamara a &lt;code&gt;reset(r.release())&lt;/code&gt; seguido de una asignaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;get_deleter&quot;&gt;get_deleter()&lt;/a&gt;&lt;/code&gt; desde &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;E&amp;gt;(r.get_deleter())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0d222c1ebe564b2e355ea589fe01bb4acb55570" translate="yes" xml:space="preserve">
          <source>1) Trivial default constructor, initializes &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to unspecified state.</source>
          <target state="translated">1) Constructor trivial predeterminado, inicializa &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; a un estado no especificado.</target>
        </trans-unit>
        <trans-unit id="fae808fef90ab07a5794289ac4c023c5fa8d10a8" translate="yes" xml:space="preserve">
          <source>1) Turns off the &lt;code&gt;skipws&lt;/code&gt; flag on the input stream</source>
          <target state="translated">1) Desactiva la bandera &lt;code&gt;skipws&lt;/code&gt; en la secuencia de entrada</target>
        </trans-unit>
        <trans-unit id="4dfdb643b8926ec8e33691a11829911540004f8c" translate="yes" xml:space="preserve">
          <source>1) Two possibly multilevel pointers to the same type may be converted between each other, regardless of cv-qualifiers at each level.</source>
          <target state="translated">1)Dos posibles punteros multinivel del mismo tipo pueden ser convertidos entre sí,independientemente de los calificadores de cv de cada nivel.</target>
        </trans-unit>
        <trans-unit id="b27ef1c6720ded3dab7eb347fb4e754d45f36dfc" translate="yes" xml:space="preserve">
          <source>1) Typical declaration of a destructor</source>
          <target state="translated">1)Declaración típica de un destructor</target>
        </trans-unit>
        <trans-unit id="c4708cafcd797737afa27ba9753427840fb5b5fb" translate="yes" xml:space="preserve">
          <source>1) Unary right fold (E op ...) becomes (E</source>
          <target state="translated">1)El pliegue derecho unitario (E op ...)se convierte en (E</target>
        </trans-unit>
        <trans-unit id="257eeefa2a69c169c4e78577629e312d119acf41" translate="yes" xml:space="preserve">
          <source>1) Underflow occurs (and &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; may be raised) if a computation produces a result whose absolute value, computed as though both the exponent range and the precision were unbounded, is smaller than &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt;. Such implementation detects tinyness before rounding (e.g. UltraSparc, POWER).</source>
          <target state="translated">1) Se produce un &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/fe_exceptions&quot;&gt;FE_UNDERFLOW&lt;/a&gt;&lt;/code&gt; (y se puede aumentar FE_UNDERFLOW ) si un c&amp;aacute;lculo produce un resultado cuyo valor absoluto, calculado como si tanto el rango del exponente como la precisi&amp;oacute;n fueran ilimitados, es menor que &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min()&lt;/code&gt; . Dicha implementaci&amp;oacute;n detecta la peque&amp;ntilde;ez antes del redondeo (por ejemplo, UltraSparc, POWER).</target>
        </trans-unit>
        <trans-unit id="5cd6d3f996be4c51f3f6895463d6cd072a7b915f" translate="yes" xml:space="preserve">
          <source>1) Unlinks the node that contains the element pointed to by &lt;code&gt;position&lt;/code&gt; and returns a &lt;a href=&quot;../node_handle&quot;&gt;node handle&lt;/a&gt; that owns it</source>
          <target state="translated">1) Desenlaza el nodo que contiene el elemento se&amp;ntilde;alado por &lt;code&gt;position&lt;/code&gt; y devuelve un &lt;a href=&quot;../node_handle&quot;&gt;identificador de nodo&lt;/a&gt; que lo posee</target>
        </trans-unit>
        <trans-unit id="6f8ce56ad604ec015f939e3d33efff5a54fb49aa" translate="yes" xml:space="preserve">
          <source>1) Unspecified (typically same as &lt;code&gt;Ptr::pointer_to&lt;/code&gt;)</source>
          <target state="translated">1) Sin especificar (normalmente igual que &lt;code&gt;Ptr::pointer_to&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="2316f7e9cdbdf01d620f24a734118320daa43c7c" translate="yes" xml:space="preserve">
          <source>1) Used to obtain the iterator type of the type &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">1) Se utiliza para obtener el tipo iterador del tipo &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cb8f5cd2ca3417e49783847dbe0430c7912497b" translate="yes" xml:space="preserve">
          <source>1) Value of the &lt;a href=&quot;../directory_entry&quot;&gt;&lt;code&gt;directory_entry&lt;/code&gt;&lt;/a&gt; referred to by this iterator</source>
          <target state="translated">1) Valor de la entrada de &lt;a href=&quot;../directory_entry&quot;&gt; &lt;code&gt;directory_entry&lt;/code&gt; &lt;/a&gt; referida por este iterador</target>
        </trans-unit>
        <trans-unit id="aba73510e6e868d87c0be08e6f8342096504cd67" translate="yes" xml:space="preserve">
          <source>1) When a named &lt;a href=&quot;reference#Lvalue_references&quot;&gt;lvalue reference&lt;/a&gt; variable is declared with an initializer</source>
          <target state="translated">1) Cuando una variable de &lt;a href=&quot;reference#Lvalue_references&quot;&gt;referencia lvalue&lt;/a&gt; nombrada se declara con un inicializador</target>
        </trans-unit>
        <trans-unit id="d0bcc30ae3863a5e08bd6f03dc42a4e874ce1e74" translate="yes" xml:space="preserve">
          <source>1) When class member declarations and member function type declarations appear in a &lt;code&gt;&quot;C&quot;&lt;/code&gt; language block, their linkage remains &lt;code&gt;&quot;C++&quot;&lt;/code&gt;.</source>
          <target state="translated">1) Cuando las declaraciones de miembro de clase y las declaraciones de tipo de funci&amp;oacute;n de miembro aparecen en un bloque de lenguaje &lt;code&gt;&quot;C&quot;&lt;/code&gt; , su enlace sigue siendo &lt;code&gt;&quot;C++&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b3820fb6503add189fb9d0185eccf94528cea1c0" translate="yes" xml:space="preserve">
          <source>1) When the</source>
          <target state="translated">1)Cuando el</target>
        </trans-unit>
        <trans-unit id="7b36527e4c99ad21a3b5acc56406892e9699bef5" translate="yes" xml:space="preserve">
          <source>1) Whenever backslash appears at the end of a line (immediately followed by the newline character), both backslash and newline are deleted, combining two physical source lines into one logical source line. This is a single-pass operation; a line ending in two backslashes followed by an empty line does not combine three lines into one. If a universal character name (&lt;code&gt;\uXXXX&lt;/code&gt;) is formed in this phase, the behavior is undefined.</source>
          <target state="translated">1) Cada vez que aparece una barra diagonal inversa al final de una l&amp;iacute;nea (seguida inmediatamente por el car&amp;aacute;cter de nueva l&amp;iacute;nea), se eliminan tanto la barra diagonal inversa como la nueva l&amp;iacute;nea, combinando dos l&amp;iacute;neas de origen f&amp;iacute;sicas en una l&amp;iacute;nea de origen l&amp;oacute;gica. Esta es una operaci&amp;oacute;n de un solo paso; una l&amp;iacute;nea que termina en dos barras invertidas seguidas de una l&amp;iacute;nea vac&amp;iacute;a no combina tres l&amp;iacute;neas en una. Si se forma un nombre de car&amp;aacute;cter universal ( &lt;code&gt;\uXXXX&lt;/code&gt; ) en esta fase, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="84212c704512f8a7c5c7f860970eb1e0b2a423f0" translate="yes" xml:space="preserve">
          <source>1) Within the body of any non-static &lt;a href=&quot;member_functions&quot;&gt;member function&lt;/a&gt;, including &lt;a href=&quot;constructor&quot;&gt;member initializer list&lt;/a&gt;</source>
          <target state="translated">1) Dentro del cuerpo de cualquier &lt;a href=&quot;member_functions&quot;&gt;funci&amp;oacute;n miembro&lt;/a&gt; no est&amp;aacute;tica , incluida la &lt;a href=&quot;constructor&quot;&gt;lista de inicializador de miembros&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="575e5597bcb538c0ad9a57aef9059faafb04f903" translate="yes" xml:space="preserve">
          <source>1) Wraps a non-const member function with no parameters.</source>
          <target state="translated">1)Envuelve una función de miembro no-constante sin parámetros.</target>
        </trans-unit>
        <trans-unit id="7d767b3af0e8610ce09659c8206561af10fa3322" translate="yes" xml:space="preserve">
          <source>1) Writes a textual representation of the distribution parameters and internal state to &lt;code&gt;ost&lt;/code&gt; as textual representation. The formatting flags and fill character of &lt;code&gt;ost&lt;/code&gt; are unchanged.</source>
          <target state="translated">1) Escribe una representaci&amp;oacute;n textual de los par&amp;aacute;metros de distribuci&amp;oacute;n y el estado interno para &lt;code&gt;ost&lt;/code&gt; como representaci&amp;oacute;n textual. Las banderas de formato y el car&amp;aacute;cter de relleno de &lt;code&gt;ost&lt;/code&gt; no cambian.</target>
        </trans-unit>
        <trans-unit id="d9c461a040145efb71a7d3ac968e14b99a1e726a" translate="yes" xml:space="preserve">
          <source>1) Writes performed by the same thread that performed A</source>
          <target state="translated">1)Escritos realizados por el mismo hilo que realizó A</target>
        </trans-unit>
        <trans-unit id="0a2b6a35046c21b8b1cdded7e012e4e02b54a352" translate="yes" xml:space="preserve">
          <source>1) Writes the bitset &lt;code&gt;x&lt;/code&gt; to the character stream &lt;code&gt;os&lt;/code&gt; as if by first converting it to a &lt;code&gt;basic_string&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; using &lt;code&gt;&lt;a href=&quot;to_string&quot;&gt;to_string()&lt;/a&gt;&lt;/code&gt;, and then writing it into &lt;code&gt;os&lt;/code&gt; using the &lt;a href=&quot;../../string/basic_string/operator_ltltgtgt&quot;&gt;&lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt;&lt;/a&gt; (which is a &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;FormattedOutputFunction&lt;/a&gt; for strings). The characters to use for ones and zeroes are obtained from the currently-imbued locale by calling &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;(os.getloc()).widen()&lt;/code&gt; with &lt;code&gt;'1'&lt;/code&gt; and &lt;code&gt;'0'&lt;/code&gt; as arguments.</source>
          <target state="translated">1) Escribe el bitset &lt;code&gt;x&lt;/code&gt; en el flujo de caracteres &lt;code&gt;os&lt;/code&gt; como si primero lo convirtiera en una &lt;code&gt;basic_string&amp;lt;CharT,Traits&amp;gt;&lt;/code&gt; usando &lt;code&gt;&lt;a href=&quot;to_string&quot;&gt;to_string()&lt;/a&gt;&lt;/code&gt; , y luego lo escribe en el sistema &lt;code&gt;os&lt;/code&gt; utilizando el &lt;a href=&quot;../../string/basic_string/operator_ltltgtgt&quot;&gt; &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; &lt;/a&gt; (que es una Funci&amp;oacute;n de salida de &lt;a href=&quot;../../named_req/formattedoutputfunction&quot;&gt;formato&lt;/a&gt; para cadenas). Los caracteres a utilizar para unos y ceros se obtienen del entorno local actualmente imbuido llamando a &lt;code&gt;&lt;a href=&quot;../../locale/use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;CharT&amp;gt;(os.getloc()).widen()&lt;/code&gt; con &lt;code&gt;'1'&lt;/code&gt; y &lt;code&gt;'0'&lt;/code&gt; como argumentos</target>
        </trans-unit>
        <trans-unit id="db026f9be530b92309db59bd7e0e007f78c55584" translate="yes" xml:space="preserve">
          <source>1) Writes the results to &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">1) Escribe los resultados en &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;stdout&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ca66f352a8a2c3fbfbb18ec52c430b1d4c5c3b4" translate="yes" xml:space="preserve">
          <source>1) Writes to &lt;code&gt;os&lt;/code&gt; the complex number in the form &lt;code&gt;(real,imaginary)&lt;/code&gt;.</source>
          <target state="translated">1) Escribe a &lt;code&gt;os&lt;/code&gt; el n&amp;uacute;mero complejo en la forma &lt;code&gt;(real,imaginary)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccfe5f32416ac78a6db71cb95900b356b4fac608" translate="yes" xml:space="preserve">
          <source>1) Yields the size in bytes of the &lt;a href=&quot;objects&quot;&gt;object representation&lt;/a&gt; of type.</source>
          <target state="translated">1) Produce el tama&amp;ntilde;o en bytes de la &lt;a href=&quot;objects&quot;&gt;representaci&amp;oacute;n&lt;/a&gt; de tipo de objeto .</target>
        </trans-unit>
        <trans-unit id="bf3ab90f79f6983b5959522a0d973a0239a4ed67" translate="yes" xml:space="preserve">
          <source>1) a copy of the &lt;code&gt;std::chrono::month&lt;/code&gt; object stored in &lt;code&gt;*this&lt;/code&gt;</source>
          <target state="translated">1) una copia del objeto &lt;code&gt;std::chrono::month&lt;/code&gt; almacenado en &lt;code&gt;*this&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f9872d13b34d100347a4789dbcf716915a245364" translate="yes" xml:space="preserve">
          <source>1) a copy of the argument, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(val)&lt;/code&gt;</source>
          <target state="translated">1) una copia del argumento, &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;T&amp;gt;(val)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5641277263a9a2b3de3620beebf734b8386a9a9d" translate="yes" xml:space="preserve">
          <source>1) a copy of the underlying string object.</source>
          <target state="translated">1)una copia del objeto de cuerda subyacente.</target>
        </trans-unit>
        <trans-unit id="5c3bdc31cd27db3964c2112a2726a87812d74790" translate="yes" xml:space="preserve">
          <source>1) a copy of this duration object</source>
          <target state="translated">1)una copia de este objeto de duración</target>
        </trans-unit>
        <trans-unit id="038d7ce390c65cda2b59d3877a61b171fd122d75" translate="yes" xml:space="preserve">
          <source>1) a declaration of a class member</source>
          <target state="translated">1)una declaración de un miembro de la clase</target>
        </trans-unit>
        <trans-unit id="d9e22ca8e57fb001efaf8220898429709ee9f67f" translate="yes" xml:space="preserve">
          <source>1) a variable &lt;code&gt;x&lt;/code&gt; in a</source>
          <target state="translated">1) una variable &lt;code&gt;x&lt;/code&gt; en un</target>
        </trans-unit>
        <trans-unit id="2b6abfcba2f16f34c4b766c8332a1b0e568f8205" translate="yes" xml:space="preserve">
          <source>1) addition</source>
          <target state="translated">1)adición</target>
        </trans-unit>
        <trans-unit id="a2d89e8d3bf7717ac619bee8df3e581c758d7c08" translate="yes" xml:space="preserve">
          <source>1) additional &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;default-inserted&lt;/a&gt; elements are appended</source>
          <target state="translated">1) se agregan elementos adicionales &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;insertados por defecto&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="ac7f27c304fab3327d4825700e7346a78e13d81e" translate="yes" xml:space="preserve">
          <source>1) additional &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;default-inserted&lt;/a&gt; elements are appended 2) additional copies of &lt;code&gt;value&lt;/code&gt; are appended</source>
          <target state="translated">1) adicionales &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;predeterminados insertado&lt;/a&gt; elementos se a&amp;ntilde;aden 2) copias adicionales de &lt;code&gt;value&lt;/code&gt; se anexan</target>
        </trans-unit>
        <trans-unit id="6430a3b1d8a483dd3a81fb0ac4d2a6320ef9e24a" translate="yes" xml:space="preserve">
          <source>1) adds both &lt;code&gt;const&lt;/code&gt; and &lt;code&gt;volatile&lt;/code&gt;.</source>
          <target state="translated">1) agrega tanto &lt;code&gt;const&lt;/code&gt; ante como &lt;code&gt;volatile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d59d7e196d66c2c5698b37c5fed11d45adb3fba0" translate="yes" xml:space="preserve">
          <source>1) amortized constant</source>
          <target state="translated">1)constante amortizada</target>
        </trans-unit>
        <trans-unit id="fec155bd296ef9eab4b5d4cff65799934437e2a4" translate="yes" xml:space="preserve">
          <source>1) an &lt;a href=&quot;../language/throw&quot;&gt;exception is thrown&lt;/a&gt; and not caught (it is implementation-defined whether any stack unwinding is done in this case)</source>
          <target state="translated">1) &lt;a href=&quot;../language/throw&quot;&gt;se lanza&lt;/a&gt; una excepci&amp;oacute;n y no se captura (se define la implementaci&amp;oacute;n si se realiza el desbobinado de la pila en este caso)</target>
        </trans-unit>
        <trans-unit id="0795e639e2d423d045556b10922218964d38d551" translate="yes" xml:space="preserve">
          <source>1) array length is negative.</source>
          <target state="translated">1)la longitud de la matriz es negativa.</target>
        </trans-unit>
        <trans-unit id="b0fb04259e9dabc8e1469a331eb44c9e0e5ae305" translate="yes" xml:space="preserve">
          <source>1) as soon as atomic operations that are not tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; enter the picture, the sequential consistency guarantee for the program is lost 2) in many cases, &lt;code&gt;memory_order_seq_cst&lt;/code&gt; atomic operations are reorderable with respect to other atomic operations performed by the same thread</source>
          <target state="translated">1) tan pronto como las operaciones at&amp;oacute;micas que no est&amp;aacute;n etiquetados &lt;code&gt;memory_order_seq_cst&lt;/code&gt; entran en escena, la garant&amp;iacute;a de la consistencia secuencial para el programa se pierde 2) en muchos casos, &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operaciones at&amp;oacute;micas son reorderable con respecto a otras operaciones at&amp;oacute;micas realizadas por el mismo hilo</target>
        </trans-unit>
        <trans-unit id="2e8ab0d12b743aef878ea9e6130cac353570c696" translate="yes" xml:space="preserve">
          <source>1) as soon as atomic operations that are not tagged &lt;code&gt;memory_order_seq_cst&lt;/code&gt; enter the picture, the sequential consistency is lost 2) the sequentially-consistent fences are only establishing total ordering for the fences themselves, not for the atomic operations in the general case (</source>
          <target state="translated">1) tan pronto como las operaciones at&amp;oacute;micas que no est&amp;aacute;n etiquetadas &lt;code&gt;memory_order_seq_cst&lt;/code&gt; entren en la imagen, la coherencia secuencial se pierde 2) las cercas consistentemente secuenciales solo establecen un orden total para las cercas en s&amp;iacute;, no para las operaciones at&amp;oacute;micas en el caso general (</target>
        </trans-unit>
        <trans-unit id="27196f9d734245d194416b40b601d5214e843c87" translate="yes" xml:space="preserve">
          <source>1) base template</source>
          <target state="translated">1)plantilla base</target>
        </trans-unit>
        <trans-unit id="cb41c99c432b78323d4f377b74a0c397256353fa" translate="yes" xml:space="preserve">
          <source>1) bitwise NOT</source>
          <target state="translated">1)poco a poco NO</target>
        </trans-unit>
        <trans-unit id="f724933955aea428b179d4bd6c5ef4df12c510d5" translate="yes" xml:space="preserve">
          <source>1) buffer state, a bitmask type which can represent any combination of the four values &quot;allocated&quot; (destructor will deallocate), &quot;constant&quot; (output not allowed), &quot;dynamic&quot; (output may reallocate), or &quot;frozen&quot; (deallocation and reallocation are not allowed)</source>
          <target state="translated">1)estado de búfer,un tipo de máscara de bits que puede representar cualquier combinación de los cuatro valores &quot;asignados&quot; (el destructor se deslocalizará),&quot;constante&quot; (no se permite la salida),&quot;dinámico&quot; (la salida puede reasignarse)o &quot;congelado&quot; (no se permite la deslocalización y reasignación)</target>
        </trans-unit>
        <trans-unit id="9bd596e30c7448227178639da643b5d2845998b0" translate="yes" xml:space="preserve">
          <source>1) by the members and friends of &lt;code&gt;Base&lt;/code&gt;</source>
          <target state="translated">1) por los miembros y amigos de &lt;code&gt;Base&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="de134b2dabb1a0cc9228c6962d95367bc50eab97" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">1) llama a &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstod&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c34ba446a37c84b0cf54a590242f4ba5233f98dd" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</source>
          <target state="translated">1) llama a &lt;code&gt;&lt;a href=&quot;../byte/strtof&quot;&gt;std::strtof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../wide/wcstof&quot;&gt;std::wcstof&lt;/a&gt;(str.c_str(), &amp;amp;ptr)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="77e091034262c03ebbe67a594c859ba4cd168524" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">1) llama a &lt;code&gt;&lt;a href=&quot;../byte/strtol&quot;&gt;std::strtol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../wide/wcstol&quot;&gt;std::wcstol&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26e3683b3a1f07d2796ab25306d2631c55c16c20" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</source>
          <target state="translated">1) llama a &lt;code&gt;&lt;a href=&quot;../byte/strtoul&quot;&gt;std::strtoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../wide/wcstoul&quot;&gt;std::wcstoul&lt;/a&gt;(str.c_str(), &amp;amp;ptr, base)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="aaa2f9b040d07d7262ac1b6d9ffdb1abe31c9d94" translate="yes" xml:space="preserve">
          <source>1) calls &lt;code&gt;buf.set_emit_on_sync(true)&lt;/code&gt;</source>
          <target state="translated">1) llama a &lt;code&gt;buf.set_emit_on_sync(true)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c82f9dfecce0de1545c8b1bc95f3a2951730d87a" translate="yes" xml:space="preserve">
          <source>1) comma-separated list of arbitrary expressions and braced-init-lists in parentheses</source>
          <target state="translated">1)lista separada por comas de expresiones arbitrarias y listas entre paréntesis</target>
        </trans-unit>
        <trans-unit id="292744bfc0b144652fe365e89093b1f3f3546203" translate="yes" xml:space="preserve">
          <source>1) conjunctions</source>
          <target state="translated">1)las conjunciones</target>
        </trans-unit>
        <trans-unit id="a27605e813fa2e284a617a94d0b1c02a41db1130" translate="yes" xml:space="preserve">
          <source>1) constant</source>
          <target state="translated">1)constante</target>
        </trans-unit>
        <trans-unit id="04557674944b51204be3247544693f0e0724501f" translate="yes" xml:space="preserve">
          <source>1) constructs an object of type &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt;, &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-non-list-initialized&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt;, as the contained object. This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">1) construye un objeto de tipo &lt;code&gt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&lt;/code&gt; , &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-non-list-initialized&lt;/a&gt; from &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Args&amp;gt;(args)...&lt;/code&gt; , como el objeto contenido. Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;, Args...&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;&lt;a href=&quot;../../types/decay&quot;&gt;std::decay_t&lt;/a&gt;&amp;lt;ValueType&amp;gt;&amp;gt;&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf7299f36a57142311fe5ff018991aec05d1d9b" translate="yes" xml:space="preserve">
          <source>1) counts the elements that are equal to &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">1) cuenta los elementos que son iguales al &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78923f4701cc466ff69a7e4c618b38c216680976" translate="yes" xml:space="preserve">
          <source>1) creates a facet with starting reference count &lt;code&gt;refs&lt;/code&gt;. If &lt;code&gt;refs&lt;/code&gt; is non-zero, the facet will not be deleted when the last locale referencing it goes out of scope. A facet with static or dynamic storage duration should always be constructed with a non-zero &lt;code&gt;refs&lt;/code&gt;.</source>
          <target state="translated">1) crea una faceta con el inicio de cuenta de referencia &lt;code&gt;refs&lt;/code&gt; . Si las &lt;code&gt;refs&lt;/code&gt; no son cero, la faceta no se eliminar&amp;aacute; cuando la &amp;uacute;ltima configuraci&amp;oacute;n regional que hace referencia est&amp;eacute; fuera de alcance. Una faceta con una duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico o din&amp;aacute;mico siempre debe construirse con &lt;code&gt;refs&lt;/code&gt; distintas de cero .</target>
        </trans-unit>
        <trans-unit id="16f7bc88ebe12e9f46129bbcbe37a17442c63648" translate="yes" xml:space="preserve">
          <source>1) current maximum load factor.</source>
          <target state="translated">1)Factor de carga máximo actual.</target>
        </trans-unit>
        <trans-unit id="020d736193c4f224afbc308288813ddd03120330" translate="yes" xml:space="preserve">
          <source>1) declares a scoped enumeration type whose underlying type is &lt;code&gt;int&lt;/code&gt; (the keywords &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt; are exactly equivalent) 2) declares a scoped enumeration type whose underlying type is type3) opaque enum declaration for a scoped enumeration whose underlying type is &lt;code&gt;int&lt;/code&gt;4) opaque enum declaration for a scoped enumeration whose underlying type is type</source>
          <target state="translated">1) declara un tipo de enumeraci&amp;oacute;n con &amp;aacute;mbito cuyo tipo subyacente es &lt;code&gt;int&lt;/code&gt; (las palabras clave &lt;code&gt;class&lt;/code&gt; y &lt;code&gt;struct&lt;/code&gt; son exactamente equivalentes) 2) declara un tipo de enumeraci&amp;oacute;n con &amp;aacute;mbito cuyo tipo subyacente es tipo3) declaraci&amp;oacute;n de enumeraci&amp;oacute;n opaca para una enumeraci&amp;oacute;n con &amp;aacute;mbito cuyo tipo subyacente es &lt;code&gt;int&lt;/code&gt; 4) opaco declaraci&amp;oacute;n de enumeraci&amp;oacute;n para una enumeraci&amp;oacute;n de &amp;aacute;mbito cuyo tipo subyacente es tipo</target>
        </trans-unit>
        <trans-unit id="9a00831c1516deb4278ae9da70bb95962035c0b1" translate="yes" xml:space="preserve">
          <source>1) default constructor: creates an object of type &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; with implementation-specific content.</source>
          <target state="translated">1) constructor predeterminado: crea un objeto de tipo &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::locale::id&lt;/a&gt;&lt;/code&gt; con contenido espec&amp;iacute;fico de implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="dde1237e4c299d5a88703d284c2d9f1b0330d7bc" translate="yes" xml:space="preserve">
          <source>1) destructors of objects with static storage duration are called in reverse order of completion of their constructors or the completion of their &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;dynamic initialization&lt;/a&gt;, and the functions passed to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; are called in reverse order they are registered (last one first). a) any static objects whose initialization was completed before the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F will be destroyed after the call to F during program termination. b) any static objects whose construction began after the call to &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; for some function F will be destroyed before the call to F during program termination (this includes the case where &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; was called from the constructor of the static object)</source>
          <target state="translated">1) los destructores de objetos con una duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico se llaman en orden inverso a la finalizaci&amp;oacute;n de sus constructores o la finalizaci&amp;oacute;n de su &lt;a href=&quot;../../language/initialization#Dynamic_initialization&quot;&gt;inicializaci&amp;oacute;n din&amp;aacute;mica&lt;/a&gt; , y las funciones pasadas a &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; se llaman en orden inverso cuando se registran (el &amp;uacute;ltimo primero). a) cualquier objeto est&amp;aacute;tico cuya inicializaci&amp;oacute;n se complet&amp;oacute; antes de la llamada a &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; para alguna funci&amp;oacute;n F se destruir&amp;aacute; despu&amp;eacute;s de la llamada a F durante la finalizaci&amp;oacute;n del programa. b) cualquier objeto est&amp;aacute;tico cuya construcci&amp;oacute;n comenz&amp;oacute; despu&amp;eacute;s de la llamada a &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; para alguna funci&amp;oacute;n F se destruir&amp;aacute; antes de la llamada a F durante la finalizaci&amp;oacute;n del programa (esto incluye el caso donde se llam&amp;oacute; &lt;code&gt;&lt;a href=&quot;atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; desde el constructor del objeto est&amp;aacute;tico )</target>
        </trans-unit>
        <trans-unit id="dcf7f086d26c92140d5665521d6f972ea28b4075" translate="yes" xml:space="preserve">
          <source>1) elaborated type specifier for a class type</source>
          <target state="translated">1)elaboró el especificador de tipo para un tipo de clase</target>
        </trans-unit>
        <trans-unit id="6160fe4e565fb3d9b2b12c87b05a83e491dcc6e4" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showbase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) habilita el indicador &lt;code&gt;showbase&lt;/code&gt; en la secuencia &lt;code&gt;str&lt;/code&gt; como si llamara a &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showbase&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c9bb54bfcf8d4b0934ee7a2b61ffada58ca8f70" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showpoint&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt;</source>
          <target state="translated">1) permite al &lt;code&gt;showpoint&lt;/code&gt; bandera en la corriente &lt;code&gt;str&lt;/code&gt; como si llamando &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpoint&lt;/a&gt;)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5cbc68830f2af6be690ee57ddb1a020743ee8a1f" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;showpos&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) habilita el indicador &lt;code&gt;showpos&lt;/code&gt; en la secuencia &lt;code&gt;str&lt;/code&gt; como si llamara a &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::showpos&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec4fee75897569d1ba002fd796b242776e66d768" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;skipws&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) habilita el indicador &lt;code&gt;skipws&lt;/code&gt; en la secuencia &lt;code&gt;str&lt;/code&gt; como si llamara a &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::skipws&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e78cc3813053d3dcc3353f63d38c9f3c40480169" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;unitbuf&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) habilita el indicador &lt;code&gt;unitbuf&lt;/code&gt; en la secuencia &lt;code&gt;str&lt;/code&gt; como si llamara a &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::unitbuf&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6c512f457d94c1407d26442e22f6caaa812de6e" translate="yes" xml:space="preserve">
          <source>1) enables the &lt;code&gt;uppercase&lt;/code&gt; flag in the stream &lt;code&gt;str&lt;/code&gt; as if by calling &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt;.</source>
          <target state="translated">1) habilita la bandera en &lt;code&gt;uppercase&lt;/code&gt; en la secuencia &lt;code&gt;str&lt;/code&gt; como si llamara a &lt;code&gt;str.setf(&lt;a href=&quot;../ios_base/fmtflags&quot;&gt;std::ios_base::uppercase&lt;/a&gt;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fca12c96ad1be6c8785cc47ea43d3c81665b28d0" translate="yes" xml:space="preserve">
          <source>1) expression statements;</source>
          <target state="translated">1)declaraciones de expresión;</target>
        </trans-unit>
        <trans-unit id="4f15378fe06eb783737d9e09aa30928eef4d729d" translate="yes" xml:space="preserve">
          <source>1) forms a literal &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; with the real part zero and imaginary part &lt;code&gt;arg&lt;/code&gt;</source>
          <target state="translated">1) forma un &lt;code&gt;&lt;a href=&quot;../complex&quot;&gt;std::complex&lt;/a&gt;&amp;lt;double&amp;gt;&lt;/code&gt; literal con la parte real cero y la parte imaginaria &lt;code&gt;arg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1be539d05656ffe16187d9f074b5f435a3f1a78" translate="yes" xml:space="preserve">
          <source>1) function parameter of a function template declared as rvalue reference to cv-unqualified &lt;a href=&quot;template_parameters&quot;&gt;type template parameter&lt;/a&gt; of that same function template:</source>
          <target state="translated">1) par&amp;aacute;metro de funci&amp;oacute;n de una plantilla de funci&amp;oacute;n declarada como referencia de valor r al &lt;a href=&quot;template_parameters&quot;&gt;par&amp;aacute;metro&lt;/a&gt; de plantilla de tipo cv-no calificado de esa misma plantilla de funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="933951affe5827f2ddb2f2c9addfe63c922b58e8" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;E2&lt;/code&gt; is a &lt;a href=&quot;static&quot;&gt;static data member&lt;/a&gt;:</source>
          <target state="translated">1) si &lt;code&gt;E2&lt;/code&gt; es un &lt;a href=&quot;static&quot;&gt;miembro de datos est&amp;aacute;tico&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f24447a09ca19b04649b1c980278aea007b7651a" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;E2&lt;/code&gt; is a pointer to data member,</source>
          <target state="translated">1) si &lt;code&gt;E2&lt;/code&gt; es un puntero al miembro de datos,</target>
        </trans-unit>
        <trans-unit id="fd8cbf371492e8ec4bdc5da5949d838ae310b0b6" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a class type with at least one user-provided constructor of any kind, the &lt;a href=&quot;default_constructor&quot;&gt;default constructor&lt;/a&gt; is called; 2) if &lt;code&gt;T&lt;/code&gt; is a non-union class type without any user-provided constructors, every non-static data member and base-class component of T is value-initialized;</source>
          <target state="translated">1) si &lt;code&gt;T&lt;/code&gt; es un tipo de clase con al menos un constructor proporcionado por el usuario de cualquier tipo, se llama al &lt;a href=&quot;default_constructor&quot;&gt;constructor predeterminado&lt;/a&gt; ; 2) si &lt;code&gt;T&lt;/code&gt; es un tipo de clase sin uni&amp;oacute;n sin constructores proporcionados por el usuario, cada miembro de datos no est&amp;aacute;tico y componente de clase base de T se inicializa en valores;</target>
        </trans-unit>
        <trans-unit id="cc5cbe2c36375ecb8459cbffdcc5e56194637eb7" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a class type with no default constructor or with a user-provided or deleted default constructor, the object is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt;; 2) if &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor that is neither user-provided nor deleted (that is, it may be a class with an implicitly-defined or defaulted default constructor), the object is &lt;a href=&quot;zero_initialization&quot;&gt;zero-initialized&lt;/a&gt; and then it is &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; if it has a non-trivial default constructor;</source>
          <target state="translated">1) si &lt;code&gt;T&lt;/code&gt; es un tipo de clase sin constructor predeterminado o con un constructor predeterminado proporcionado o eliminado por el usuario, el objeto se &lt;a href=&quot;default_initialization&quot;&gt;inicializa por defecto&lt;/a&gt; ; 2) si &lt;code&gt;T&lt;/code&gt; es un tipo de clase con un constructor predeterminado que no es provisto por el usuario ni eliminado (es decir, puede ser una clase con un constructor predeterminado impl&amp;iacute;citamente definido o predeterminado), el objeto est&amp;aacute; &lt;a href=&quot;zero_initialization&quot;&gt;inicializado en cero&lt;/a&gt; y luego es &lt;a href=&quot;default_initialization&quot;&gt;default-initialized&lt;/a&gt; si tiene un constructor predeterminado no trivial;</target>
        </trans-unit>
        <trans-unit id="2567e503e479ddfa34c6e4c7e7e466e63c7a9083" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes one argument of type &lt;code&gt;A1&lt;/code&gt;, then &lt;code&gt;argument_type&lt;/code&gt; is &lt;code&gt;A1&lt;/code&gt;.</source>
          <target state="translated">1) si &lt;code&gt;T&lt;/code&gt; es una funci&amp;oacute;n o puntero a funci&amp;oacute;n que toma un argumento de tipo &lt;code&gt;A1&lt;/code&gt; , entonces &lt;code&gt;argument_type&lt;/code&gt; es &lt;code&gt;A1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05248e1e5cafa82d974bc4d2920820bbd80169d6" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes two arguments of type s &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt;, then &lt;code&gt;second_argument_type&lt;/code&gt; is &lt;code&gt;A2&lt;/code&gt;.</source>
          <target state="translated">1) si &lt;code&gt;T&lt;/code&gt; es una funci&amp;oacute;n o puntero a funci&amp;oacute;n que toma dos argumentos de tipo s &lt;code&gt;A1&lt;/code&gt; y &lt;code&gt;A2&lt;/code&gt; , &lt;code&gt;second_argument_type&lt;/code&gt; es &lt;code&gt;A2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccfd08717e620a2adb1e880c6d6d8a684f02c9b9" translate="yes" xml:space="preserve">
          <source>1) if &lt;code&gt;T&lt;/code&gt; is a function or pointer to function that takes two arguments of types &lt;code&gt;A1&lt;/code&gt; and &lt;code&gt;A2&lt;/code&gt;, then &lt;code&gt;first_argument_type&lt;/code&gt; is &lt;code&gt;A1&lt;/code&gt;.</source>
          <target state="translated">1) si &lt;code&gt;T&lt;/code&gt; es una funci&amp;oacute;n o un puntero a la funci&amp;oacute;n que toma dos argumentos de los tipos &lt;code&gt;A1&lt;/code&gt; y &lt;code&gt;A2&lt;/code&gt; , &lt;code&gt;first_argument_type&lt;/code&gt; es &lt;code&gt;A1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a431179612485d24bc273e5248075c581ebeb99d" translate="yes" xml:space="preserve">
          <source>1) if A and B are &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, and A</source>
          <target state="translated">1) si A y B son operaciones &lt;code&gt;memory_order_seq_cst&lt;/code&gt; , y A</target>
        </trans-unit>
        <trans-unit id="649d80319d06d238094897a0c7387db3f34a9dba" translate="yes" xml:space="preserve">
          <source>1) initialization of a named variable with a</source>
          <target state="translated">1)la inicialización de una variable nombrada con un</target>
        </trans-unit>
        <trans-unit id="1368a73e49095bf4c57e55786671e41410e57ea6" translate="yes" xml:space="preserve">
          <source>1) initialization with a nonempty parenthesized list of expressions or braced-init-lists(since C++11)</source>
          <target state="translated">1)Inicialización con una lista no vacía de expresiones entre paréntesis o listas de entrada entre paréntesis (desde C++11)</target>
        </trans-unit>
        <trans-unit id="99f4faeed3de5d70f2b4ff261841eff7c00945ba" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;(hrs)&lt;/code&gt;</source>
          <target state="translated">1) literal entero, devuelve exactamente &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::hours&lt;/a&gt;(hrs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b87dde5587a9a2ce938326ff6f293bb389b57a11" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;(us)&lt;/code&gt;</source>
          <target state="translated">1) literal entero, devuelve exactamente &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::microseconds&lt;/a&gt;(us)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73237f5b88515e9f07510adba322ff008703bf77" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;(ms)&lt;/code&gt;</source>
          <target state="translated">1) literal entero, devuelve exactamente &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::milliseconds&lt;/a&gt;(ms)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="75957235d93ab14971c5ead82631c15f8903fa9f" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;(mins)&lt;/code&gt;</source>
          <target state="translated">1) literal entero, devuelve exactamente &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::minutes&lt;/a&gt;(mins)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9a65c38cb3e887f8107e9bb7e034295d9e9ba661" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;(nsec)&lt;/code&gt;</source>
          <target state="translated">1) literal entero, devuelve exactamente &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::nanoseconds&lt;/a&gt;(nsec)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2ff5af48ac230f178ca8f7aae38f7e5b97cd4ae" translate="yes" xml:space="preserve">
          <source>1) integer literal, returns exactly &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(secs)&lt;/code&gt;</source>
          <target state="translated">1) literal entero, devuelve exactamente &lt;code&gt;&lt;a href=&quot;duration&quot;&gt;std::chrono::seconds&lt;/a&gt;(secs)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3c2ec705f86909dc012b45e0a5e5eac830bf7b5e" translate="yes" xml:space="preserve">
          <source>1) it may apply to the parameter declarations of a function or lambda-expressions, in which case it indicates that initialization of the parameter carries dependency into lvalue-to-rvalue conversion of that object.</source>
          <target state="translated">1)puede aplicarse a las declaraciones de parámetros de una función o a las expresiones lambda,en cuyo caso indica que la inicialización del parámetro conlleva una dependencia en la conversión de valor a valor de ese objeto.</target>
        </trans-unit>
        <trans-unit id="f08aa13ffd87bf5b57bd2b5c39f8fe2c531e8de4" translate="yes" xml:space="preserve">
          <source>1) left shift of lhs by rhs bits</source>
          <target state="translated">1)Desplazamiento a la izquierda de lhs por bits de rhs</target>
        </trans-unit>
        <trans-unit id="a0ef1b765d867fe5ee7805c81437d622e4207832" translate="yes" xml:space="preserve">
          <source>1) linear in &lt;code&gt;count&lt;/code&gt;</source>
          <target state="translated">1) lineal en &lt;code&gt;count&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0ff0e7aba3a51ab3e96b766a29da0e2d4e95d71e" translate="yes" xml:space="preserve">
          <source>1) linear in size of &lt;code&gt;str&lt;/code&gt;</source>
          <target state="translated">1) lineal en tama&amp;ntilde;o de &lt;code&gt;str&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9ba4f8c918b38171c581014561921c19d85a056e" translate="yes" xml:space="preserve">
          <source>1) make more memory available</source>
          <target state="translated">1)hacer que haya más memoria disponible</target>
        </trans-unit>
        <trans-unit id="a0c8b5c53f4a3270d0819e3eea46631ace784dc4" translate="yes" xml:space="preserve">
          <source>1) may throw &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if an exception is thrown during output.</source>
          <target state="translated">1) puede lanzar &lt;code&gt;&lt;a href=&quot;../../io/ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; si se produce una excepci&amp;oacute;n durante la salida.</target>
        </trans-unit>
        <trans-unit id="818942971c8d5e6d4f974a900c33b24a7f7a56bb" translate="yes" xml:space="preserve">
          <source>1) may throw, e.g. if &lt;code&gt;pointer&lt;/code&gt; defines a throwing &lt;code&gt;operator*&lt;/code&gt;</source>
          <target state="translated">1) puede lanzar, por ejemplo, si el &lt;code&gt;pointer&lt;/code&gt; define un &lt;code&gt;operator*&lt;/code&gt; lanzamiento *</target>
        </trans-unit>
        <trans-unit id="b746d566df1bafa8f84adef1c6b1bd18579c2ad4" translate="yes" xml:space="preserve">
          <source>1) multiplication</source>
          <target state="translated">1)multiplicación</target>
        </trans-unit>
        <trans-unit id="63b22e6c68841953ed2ca6a9ca96cff9639efe85" translate="yes" xml:space="preserve">
          <source>1) narrow character literal or ordinary character literal, e.g. &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; or &lt;code&gt;'\13'&lt;/code&gt;. Such literal has type &lt;code&gt;char&lt;/code&gt; and the value equal to the representation of c-char in the execution character set. If c-char is not representable as a single byte in the execution character set, the literal has type &lt;code&gt;int&lt;/code&gt; and implementation-defined value</source>
          <target state="translated">1) literal de caracteres estrechos o literal de caracteres ordinarios, por ejemplo, &lt;code&gt;'a'&lt;/code&gt; o &lt;code&gt;'\n'&lt;/code&gt; o &lt;code&gt;'\13'&lt;/code&gt; . Tal literal tiene el tipo &lt;code&gt;char&lt;/code&gt; y el valor igual a la representaci&amp;oacute;n de c-char en el conjunto de caracteres de ejecuci&amp;oacute;n. Si c-char no es representable como un solo byte en el juego de caracteres de ejecuci&amp;oacute;n, el literal tiene el tipo &lt;code&gt;int&lt;/code&gt; y el valor definido por la implementaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="b3526fa909cbee863631df5a0dd6e3dfe3d40b87" translate="yes" xml:space="preserve">
          <source>1) op E</source>
          <target state="translated">1)en E</target>
        </trans-unit>
        <trans-unit id="4adc80c0600353b3a1170e14f5e464ff13775a27" translate="yes" xml:space="preserve">
          <source>1) overloaded operator;</source>
          <target state="translated">1)operador sobrecargado;</target>
        </trans-unit>
        <trans-unit id="5e09baa491e636964ed3becfd3445f8709e44fad" translate="yes" xml:space="preserve">
          <source>1) p made relative against base.</source>
          <target state="translated">1)p hecho relativo contra la base.</target>
        </trans-unit>
        <trans-unit id="f807176049911b041a40e01ee8ab370dcdb89766" translate="yes" xml:space="preserve">
          <source>1) postfix increment (post-increment)</source>
          <target state="translated">1)incremento post-fijo (post-incremento)</target>
        </trans-unit>
        <trans-unit id="2d5856705fcd5ea07c48025861fe3b1f79bc0d2c" translate="yes" xml:space="preserve">
          <source>1) prefix increment (pre-increment)</source>
          <target state="translated">1)incremento del prefijo (pre-incremento)</target>
        </trans-unit>
        <trans-unit id="daa92feecb37a0d054ee8b707dc9aac07a31a3ea" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_encoding&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_encoding&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="5328462b7087b609c543e78bd8d46692bea782df" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_length&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_length&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="53f57d286d6e754d726ea6cccf746a676dfa1638" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_out&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_out&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="e4db4e3900ed888101fc0f5f38719bd3c6326b25" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the member function &lt;code&gt;do_unshift&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n miembro &lt;code&gt;do_unshift&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="36bebe33f8e9dfba4ec0a7482223647307e5d502" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_close&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n miembro virtual protegida &lt;code&gt;do_close&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="087deceeef2229bfa0f69093a5dde5435352bc10" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_monthname&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_get_monthname&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="54d273175a96ff13269f617ec3bfb9a5e807469d" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_time&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_get_time&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="2a24196c23f9b282e50225c8ce404605af1d591e" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_weekday&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_get_weekday&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="c90b5960dcfdbae543519fd42dff106975cf6a49" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_get_year&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_get_year&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="ced48bdf0ef79442409261aece9019fc894855a2" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_scan_is&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_scan_is&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="278c95483ac183d21fe5237adc621b7ef3fd15ff" translate="yes" xml:space="preserve">
          <source>1) public member function, calls the protected virtual member function &lt;code&gt;do_scan_not&lt;/code&gt; of the most derived class.</source>
          <target state="translated">1) funci&amp;oacute;n de miembro p&amp;uacute;blico, llama a la funci&amp;oacute;n de miembro virtual protegida &lt;code&gt;do_scan_not&lt;/code&gt; de la clase m&amp;aacute;s derivada.</target>
        </trans-unit>
        <trans-unit id="a5100d04826728fa57d41699139922616240294d" translate="yes" xml:space="preserve">
          <source>1) regular function body</source>
          <target state="translated">1)Función regular del cuerpo</target>
        </trans-unit>
        <trans-unit id="aeec3a3b882e59daf64402de22ed548e3658687c" translate="yes" xml:space="preserve">
          <source>1) removes the topmost &lt;code&gt;const&lt;/code&gt;, the topmost &lt;code&gt;volatile&lt;/code&gt;, or both, if present.</source>
          <target state="translated">1) elimina la &lt;code&gt;const&lt;/code&gt; ante m&amp;aacute;s alta , la m&amp;aacute;s &lt;code&gt;volatile&lt;/code&gt; o ambas, si est&amp;aacute;n presentes.</target>
        </trans-unit>
        <trans-unit id="1791c7ad104cbda662a1ae0402149dd47873c5da" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">1) devuelve &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;{str, len}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f85b4809a3f0e34d7e0945ed1b8a2c6c86889a9" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::string_view&lt;/a&gt;{str, len}&lt;/code&gt;</source>
          <target state="translated">1) devuelve &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::string_view&lt;/a&gt;{str, len}&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3e1e200684cc13c5bab72f139037d8694e2ed55a" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;c.empty()&lt;/code&gt;</source>
          <target state="translated">1) devuelve &lt;code&gt;c.empty()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="336ac5fcb4da96dfd10ca30f8265c27f9432fe83" translate="yes" xml:space="preserve">
          <source>1) returns &lt;code&gt;static_cast&amp;lt;OuterAlloc&amp;amp;&amp;gt;(*this)&lt;/code&gt;.</source>
          <target state="translated">1) devuelve &lt;code&gt;static_cast&amp;lt;OuterAlloc&amp;amp;&amp;gt;(*this)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b910831624bf6214fa9cc9d794c642134d756feb" translate="yes" xml:space="preserve">
          <source>1) returns current formatting setting.</source>
          <target state="translated">1)devuelve el ajuste de formato actual.</target>
        </trans-unit>
        <trans-unit id="5c6efa04b91565e54da0890082e64bf37e9ce1f7" translate="yes" xml:space="preserve">
          <source>1) returns the current fill character</source>
          <target state="translated">1)devuelve el carácter de relleno actual</target>
        </trans-unit>
        <trans-unit id="d936fcd6af68f91a166aa90e999f1232b7d7c9be" translate="yes" xml:space="preserve">
          <source>1) returns the pointer to the underlying byte stream.</source>
          <target state="translated">1)devuelve el puntero al flujo de bytes subyacente.</target>
        </trans-unit>
        <trans-unit id="2c507b3bfa348dac59725e8ea55ae43c6356c3b0" translate="yes" xml:space="preserve">
          <source>1) same as &lt;code&gt;reduce(first, last, typename &lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;InputIt&amp;gt;::value_type{})&lt;/code&gt;</source>
          <target state="translated">1) igual que &lt;code&gt;reduce(first, last, typename &lt;a href=&quot;../iterator/iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;InputIt&amp;gt;::value_type{})&lt;/code&gt;</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
