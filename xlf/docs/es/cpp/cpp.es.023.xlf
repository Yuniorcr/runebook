<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="e9ad164a9bae7d10fe5fec949515a05485fa2d71" translate="yes" xml:space="preserve">
          <source>The supplied version of the header &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; shall declare at least the functions &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt;(since C++11).</source>
          <target state="translated">La versi&amp;oacute;n suministrada del encabezado &lt;code&gt;&amp;lt;cstdlib&amp;gt;&lt;/code&gt; declarar&amp;aacute; al menos las funciones &lt;code&gt;&lt;a href=&quot;utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/atexit&quot;&gt;std::atexit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;utility/program/at_quick_exit&quot;&gt;std::at_quick_exit&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;utility/program/quick_exit&quot;&gt;std::quick_exit&lt;/a&gt;&lt;/code&gt; (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="5b99d0c2b824af433d36c158441c754d3faf4148" translate="yes" xml:space="preserve">
          <source>The swap functions do not invalidate any of the iterators inside the container, but they do invalidate the iterator marking the end of the swap region.</source>
          <target state="translated">Las funciones de intercambio no invalidan ninguno de los iteradores dentro del contenedor,pero sí invalidan el iterador que marca el final de la región de intercambio.</target>
        </trans-unit>
        <trans-unit id="21c84344f10b85ba83941112b65c0b80df28cba9" translate="yes" xml:space="preserve">
          <source>The synchronization is established only between the threads</source>
          <target state="translated">La sincronización se establece sólo entre los hilos</target>
        </trans-unit>
        <trans-unit id="af5a157ab893f882387e99debe5b0576aec5458b" translate="yes" xml:space="preserve">
          <source>The syntax &lt;code&gt;T object();&lt;/code&gt; does not initialize an object; it declares a function that takes no arguments and returns &lt;code&gt;T&lt;/code&gt;. The way to value-initialize a named variable before C++11 was &lt;code&gt;T object = T();&lt;/code&gt;, which value-initializes a temporary and then copy-initializes the object: most compilers &lt;a href=&quot;copy_elision&quot;&gt;optimize out the copy&lt;/a&gt; in this case.</source>
          <target state="translated">La sintaxis &lt;code&gt;T object();&lt;/code&gt; no inicializa un objeto; se declara una funci&amp;oacute;n que no tiene argumentos y devuelve &lt;code&gt;T&lt;/code&gt; . La forma de inicializar valores de una variable nombrada antes de C ++ 11 era &lt;code&gt;T object = T();&lt;/code&gt; , cuyo valor inicializa un temporal y luego copia-inicializa el objeto: la mayor&amp;iacute;a de los compiladores &lt;a href=&quot;copy_elision&quot;&gt;optimizan la copia&lt;/a&gt; en este caso.</target>
        </trans-unit>
        <trans-unit id="ae224bb840d8d7b9d78b650bc1b03492b672c0b6" translate="yes" xml:space="preserve">
          <source>The syntax forms (3,4) are known as designated initializers: each designator must name a direct non-static data members of T, and all designators used in the expression must appear in the same order as the data members of T.</source>
          <target state="translated">Las formas sintácticas (3,4)se conocen como inicializadores designados:cada designador debe nombrar un miembro de datos no estático directo de T,y todos los designadores utilizados en la expresión deben aparecer en el mismo orden que los miembros de datos de T.</target>
        </trans-unit>
        <trans-unit id="f00bfbaecf20babfadbc5e22b52d48a548c5a848" translate="yes" xml:space="preserve">
          <source>The syntax of</source>
          <target state="translated">La sintaxis de</target>
        </trans-unit>
        <trans-unit id="6f89d606c1975f38aa5544527e8e97e16b6bb96a" translate="yes" xml:space="preserve">
          <source>The syntax of a function-like macro invocation is similar to the syntax of a function call: each instance of the macro name followed by a &lt;code&gt;(&lt;/code&gt; as the next preprocessing token introduces the sequence of tokens that is replaced by the replacement-list. The sequence is terminated by the matching &lt;code&gt;)&lt;/code&gt; token, skipping intervening matched pairs of left and right parentheses.</source>
          <target state="translated">La sintaxis de una invocaci&amp;oacute;n de macro similar a una funci&amp;oacute;n es similar a la sintaxis de una llamada a funci&amp;oacute;n: cada instancia del nombre de macro seguido de a &lt;code&gt;(&lt;/code&gt; como el siguiente token de preprocesamiento introduce la secuencia de tokens que se reemplaza por la lista de reemplazo. La secuencia se termina mediante la coincidencia &lt;code&gt;)&lt;/code&gt; ficha, saltar intervienen pares emparejados de par&amp;eacute;ntesis izquierdo y derecho.</target>
        </trans-unit>
        <trans-unit id="9bcf66af5c16c1977a2766c06868ed208b549d02" translate="yes" xml:space="preserve">
          <source>The syntax of a user-defined deduction guide is the syntax of a function declaration with a trailing return type, except that it uses the name of a class template as the function name:</source>
          <target state="translated">La sintaxis de una guía de deducción definida por el usuario es la sintaxis de una declaración de función con un tipo de retorno posterior,excepto que utiliza el nombre de una plantilla de clase como nombre de la función:</target>
        </trans-unit>
        <trans-unit id="de7f5913c9173da622b172081363583fac269c9b" translate="yes" xml:space="preserve">
          <source>The syntax of an individual capture in captures is.</source>
          <target state="translated">La sintaxis de una captura individual en las capturas es.</target>
        </trans-unit>
        <trans-unit id="702f4bc2e64078809bb1b5388513237231aab2e6" translate="yes" xml:space="preserve">
          <source>The system-supplied locales normally do not collate two strings as equivalent (&lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; does not return &lt;code&gt;​0​&lt;/code&gt;) if &lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt;&lt;code&gt;basic_string::operator==&lt;/code&gt;&lt;/a&gt; returns &lt;code&gt;false&lt;/code&gt;, but a user-installed &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet may provide different collation rules, for example, it may treat strings as equivalent if they have the same Unicode normalized form.</source>
          <target state="translated">Las locales proporcionados por el sistema normalmente no se clasifican dos cadenas como equivalente ( &lt;code&gt;&lt;a href=&quot;compare&quot;&gt;compare()&lt;/a&gt;&lt;/code&gt; no devuelve &lt;code&gt;​0​&lt;/code&gt; ) si &lt;a href=&quot;../../string/basic_string/operator_cmp&quot;&gt; &lt;code&gt;basic_string::operator==&lt;/code&gt; &lt;/a&gt; vuelve &lt;code&gt;false&lt;/code&gt; , sino un instalado por el usuario &lt;code&gt;&lt;a href=&quot;../collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; las facetas pueden proporcionar diferentes reglas de comparaci&amp;oacute;n, por ejemplo, puede tratar cadenas como equivalentes si tienen la misma forma normalizada Unicode.</target>
        </trans-unit>
        <trans-unit id="48237f3ec26215b3606e67c0e6d68687b01822f6" translate="yes" xml:space="preserve">
          <source>The target of the symlink (which may not necessarily exist).</source>
          <target state="translated">El objetivo del enlace simbólico (que puede no existir necesariamente).</target>
        </trans-unit>
        <trans-unit id="676256b3d34d8447f5998ce9c718f12a262b3700" translate="yes" xml:space="preserve">
          <source>The template argument that can be used with a non-type template parameter can be any &lt;a href=&quot;constant_expression&quot;&gt;converted constant expression&lt;/a&gt; of the type of the template parameter.</source>
          <target state="translated">El argumento de plantilla que se puede usar con un par&amp;aacute;metro de plantilla que no sea de tipo puede ser cualquier &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante convertida&lt;/a&gt; del tipo del par&amp;aacute;metro de plantilla.</target>
        </trans-unit>
        <trans-unit id="50cbc99825f7a6c9a124b9687858d33d44b2131c" translate="yes" xml:space="preserve">
          <source>The template can be specialized for user-defined iterators so that the information about the iterator can be retrieved even if the type does not provide the usual typedefs.</source>
          <target state="translated">La plantilla puede especializarse para los iteradores definidos por el usuario,de modo que se pueda recuperar la información sobre el iterador aunque el tipo no proporcione los tipedefs habituales.</target>
        </trans-unit>
        <trans-unit id="557201976e8a00a9ece65cd2feec4760fa0f5cd2" translate="yes" xml:space="preserve">
          <source>The template function &lt;code&gt;async&lt;/code&gt; runs the function &lt;code&gt;f&lt;/code&gt; asynchronously (potentially in a separate thread which may be part of a thread pool) and returns a &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; that will eventually hold the result of that function call.</source>
          <target state="translated">La funci&amp;oacute;n de plantilla &lt;code&gt;async&lt;/code&gt; ejecuta la funci&amp;oacute;n &lt;code&gt;f&lt;/code&gt; de forma asincr&amp;oacute;nica (potencialmente en un subproceso separado que puede ser parte de un grupo de subprocesos) y devuelve un &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; que finalmente contendr&amp;aacute; el resultado de esa llamada de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eff5e7944f6337f3549b2f87230ec73fcb57ba24" translate="yes" xml:space="preserve">
          <source>The template may be specialized for any user-defined &lt;code&gt;T&lt;/code&gt; type: the specialization must satisfy &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">La plantilla puede estar especializada para cualquier tipo &lt;code&gt;T&lt;/code&gt; definido por el usuario : la especializaci&amp;oacute;n debe satisfacer &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; con</target>
        </trans-unit>
        <trans-unit id="57234bb7a67c620ea3f65bd79181da8581f11c93" translate="yes" xml:space="preserve">
          <source>The template parameter &lt;code&gt;TimeZonePtr&lt;/code&gt; allows users to supply their own time zone pointer types and further customize the behavior of &lt;code&gt;zoned_time&lt;/code&gt; via &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt;. Custom time zone types need not support all the operations supported by &lt;code&gt;std::chrono::time_zone&lt;/code&gt;, only those used by the functions actually called on the &lt;code&gt;zoned_time&lt;/code&gt;.</source>
          <target state="translated">El par&amp;aacute;metro de plantilla &lt;code&gt;TimeZonePtr&lt;/code&gt; permite a los usuarios proporcionar sus propios tipos de puntero de zona horaria y personalizar a&amp;uacute;n m&amp;aacute;s el comportamiento de &lt;code&gt;zoned_time&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;std::chrono::zoned_traits&lt;/code&gt; . Los tipos de zonas horarias personalizadas no necesitan admitir todas las operaciones admitidas por &lt;code&gt;std::chrono::time_zone&lt;/code&gt; , solo aquellas utilizadas por las funciones realmente llamadas en &lt;code&gt;zoned_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="976e95956188ddd1cc5dc013bb47e40cd53b4619" translate="yes" xml:space="preserve">
          <source>The template parameter list and the template argument list of a member of a partial specialization must match the parameter list and the argument list of the partial specialization.</source>
          <target state="translated">La lista de parámetros de la plantilla y la lista de argumentos de la plantilla de un miembro de una especialización parcial deben coincidir con la lista de parámetros y la lista de argumentos de la especialización parcial.</target>
        </trans-unit>
        <trans-unit id="35c19ab099f7c63eddf13b79738caebc5d6c5994" translate="yes" xml:space="preserve">
          <source>The template parameter list may be followed by an optional &lt;a href=&quot;constraints#Requires_clauses&quot;&gt;requires-clause&lt;/a&gt; that specifies the &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; on the template arguments.</source>
          <target state="translated">La lista de par&amp;aacute;metros de la plantilla puede ir seguida de una &lt;a href=&quot;constraints#Requires_clauses&quot;&gt;cl&amp;aacute;usula obligatoria&lt;/a&gt; opcional que especifica las &lt;a href=&quot;constraints&quot;&gt;restricciones&lt;/a&gt; en los argumentos de la plantilla.</target>
        </trans-unit>
        <trans-unit id="0e09d82796b1385db8c4e7f7eb0aae7cb58e1066" translate="yes" xml:space="preserve">
          <source>The template parameter lists of template template parameters can have their own default arguments, which are only in effect where the template template parameter itself is in scope:</source>
          <target state="translated">Las listas de parámetros de la plantilla de parámetros de la plantilla pueden tener sus propios argumentos por defecto,que sólo tienen efecto cuando el propio parámetro de la plantilla está en el ámbito de aplicación:</target>
        </trans-unit>
        <trans-unit id="9b6ab43de318de05ac5e805e82ee83900637e335" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the identifiers of threads.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para la clase &lt;code&gt;&lt;a href=&quot;../id&quot;&gt;std::thread::id&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hash de los identificadores de hilos.</target>
        </trans-unit>
        <trans-unit id="1617c98734849159498d6d58c8ee6130545cbbf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5b98ae6aa533d3d486ad6a1f3c3dd5a2a2cc3c3" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="189f220de4b5df21be91fb36e6e09506d95caaf2" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa82fede24ddf383b749f64c40120c7a6b969fc" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e08e96dcabc0ff66b712bd52aab0a0c10bbb4f5" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T, Deleter&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c9f3d1ec6cfcd95caae7ac3bda8cf8e03255245" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../vector&quot;&gt;std::vector&lt;/a&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d968cfa6e1f3e875e46aac917073ba195240e6bb" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; allows users to obtain hashes of objects of type &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos de tipo &lt;code&gt;&lt;a href=&quot;../bitset&quot;&gt;std::bitset&lt;/a&gt;&amp;lt;N&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce7952ddebf3c0d01e620facea4a820fd43fa101" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; class allows users to obtain hashes of the values contained in &lt;code&gt;optional&lt;/code&gt; objects.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para la clase &lt;code&gt;&lt;a href=&quot;../optional&quot;&gt;std::optional&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener valores hash de los valores contenidos en objetos &lt;code&gt;optional&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db5007b65d07bfed77b8824218281a413afda965" translate="yes" xml:space="preserve">
          <source>The template specialization of &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; template allows users to obtain hashes of &lt;code&gt;variant&lt;/code&gt; objects.</source>
          <target state="translated">La especializaci&amp;oacute;n de plantilla de &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para la plantilla &lt;code&gt;&lt;a href=&quot;../variant&quot;&gt;std::variant&lt;/a&gt;&lt;/code&gt; permite a los usuarios obtener hashes de objetos &lt;code&gt;variant&lt;/code&gt; es .</target>
        </trans-unit>
        <trans-unit id="8ddcabf8bbccc8b0c948a37b70ba7a9f9c022693" translate="yes" xml:space="preserve">
          <source>The template specializations of &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; for the various string classes allow users to obtain hashes of strings.</source>
          <target state="translated">Las especializaciones de plantilla de &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; para las diversas clases de cadenas permiten a los usuarios obtener hashes de cadenas.</target>
        </trans-unit>
        <trans-unit id="584921a66a2cf4fe71de6a59a91614782dd86242" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator in the specialization for arrays, &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; behaves the same as in the primary template, except that will only participate in overload resolution if all of the following is true:</source>
          <target state="translated">La versi&amp;oacute;n de plantilla de este operador de asignaci&amp;oacute;n en la especializaci&amp;oacute;n para matrices, &lt;code&gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/code&gt; comporta igual que en la plantilla primaria, excepto que solo participar&amp;aacute; en la resoluci&amp;oacute;n de sobrecarga si se cumple todo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="0ac5be2688655da010f5c804e64763bf5f3459f9" translate="yes" xml:space="preserve">
          <source>The template version of this assignment operator only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not an array type and &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; is implicitly convertible to &lt;code&gt;pointer&lt;/code&gt;and &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;(since C++17).</source>
          <target state="translated">La versi&amp;oacute;n de la plantilla de este operador de asignaci&amp;oacute;n solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;U&lt;/code&gt; no es un tipo de matriz y &lt;code&gt;unique_ptr&amp;lt;U,E&amp;gt;::pointer&lt;/code&gt; es convertible impl&amp;iacute;citamente en &lt;code&gt;pointer&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_assignable&quot;&gt;std::is_assignable&lt;/a&gt;&amp;lt;Deleter&amp;amp;, E&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; ( desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="22030dbd3e1d3908354d7549e8f30d9f71beae72" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; generalizes how sequences of characters are manipulated and stored. String creation, manipulation, and destruction are all handled by a convenient set of class methods and related functions.</source>
          <target state="translated">La clase con plantilla &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; generaliza c&amp;oacute;mo se manipulan y almacenan las secuencias de caracteres. La creaci&amp;oacute;n, manipulaci&amp;oacute;n y destrucci&amp;oacute;n de cadenas se manejan mediante un conjunto conveniente de m&amp;eacute;todos de clase y funciones relacionadas.</target>
        </trans-unit>
        <trans-unit id="ae2a3669d2ccc3c953612c7002da0c5821d0cf01" translate="yes" xml:space="preserve">
          <source>The templated class &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; provides a lightweight object that offers read-only access to a string or a part of a string using an interface similar to the interface of &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La clase con plantilla &lt;code&gt;&lt;a href=&quot;string/basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; proporciona un objeto liviano que ofrece acceso de solo lectura a una cadena o parte de una cadena usando una interfaz similar a la interfaz de &lt;code&gt;&lt;a href=&quot;string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5938eb91acf69026cdeecae1d1a114be0e7c8cbb" translate="yes" xml:space="preserve">
          <source>The temporary object is constructed from the function argument or return value, respectively, and the function's parameter or return object is initialized as if by using the non-deleted trivial constructor to copy the temporary (even if that constructor is inaccessible or would not be selected by overload resolution to perform a copy or move of the object).</source>
          <target state="translated">El objeto temporal se construye a partir del argumento de la función o del valor de retorno,respectivamente,y el parámetro de la función o el objeto de retorno se inicializa como si se utilizara el constructor trivial no eliminado para copiar el temporal (incluso si ese constructor es inaccesible o no se seleccionaría por resolución de sobrecarga para realizar una copia o un desplazamiento del objeto).</target>
        </trans-unit>
        <trans-unit id="d35cf85afe81dba05bfcd30078a13ec4b61a6248" translate="yes" xml:space="preserve">
          <source>The terminating null character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">El car&amp;aacute;cter nulo de terminaci&amp;oacute;n de &lt;code&gt;str&lt;/code&gt; no est&amp;aacute; escrito.</target>
        </trans-unit>
        <trans-unit id="0b502a26934eaa1380b44846902030ef133c5174" translate="yes" xml:space="preserve">
          <source>The terminating null character is considered to be a part of the string and can be found if searching for &lt;code&gt;'\0'&lt;/code&gt;.</source>
          <target state="translated">El car&amp;aacute;cter nulo final se considera parte de la cadena y se puede encontrar si busca &lt;code&gt;'\0'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e942509d6816ccf9d123b1cf1595fd4cb7dbdb4" translate="yes" xml:space="preserve">
          <source>The terminating null wide character from &lt;code&gt;str&lt;/code&gt; is not written.</source>
          <target state="translated">El car&amp;aacute;cter ancho nulo de terminaci&amp;oacute;n de &lt;code&gt;str&lt;/code&gt; no est&amp;aacute; escrito.</target>
        </trans-unit>
        <trans-unit id="f64c2cf450c071f73e284e57290f6f2917e30baf" translate="yes" xml:space="preserve">
          <source>The test &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; in the exposition code above makes sure that &lt;code&gt;weak_this&lt;/code&gt; is not reassigned if it already indicates an owner. This test is required as of C++17.</source>
          <target state="translated">La prueba &lt;code&gt;ptr-&amp;gt;weak_this.expired()&lt;/code&gt; en el c&amp;oacute;digo de exposici&amp;oacute;n anterior se asegura de que &lt;code&gt;weak_this&lt;/code&gt; no se reasigne si ya indica un propietario. Esta prueba se requiere a partir de C ++ 17.</target>
        </trans-unit>
        <trans-unit id="a76ffdb1119a59ee47d50b27acec60df78d37530" translate="yes" xml:space="preserve">
          <source>The textual representation is written with &lt;code&gt;os.fmtflags&lt;/code&gt; set to &lt;code&gt;ios_base::dec&lt;/code&gt;|&lt;code&gt;ios_base::left&lt;/code&gt; and the fill character set to the space character. The textual representation of the engine's internal state is a set of decimal numbers separated by spaces.</source>
          <target state="translated">La representaci&amp;oacute;n textual se escribe con &lt;code&gt;os.fmtflags&lt;/code&gt; establecido en &lt;code&gt;ios_base::dec&lt;/code&gt; | &lt;code&gt;ios_base::left&lt;/code&gt; y el conjunto de caracteres de relleno al espacio. La representaci&amp;oacute;n textual del estado interno del motor es un conjunto de n&amp;uacute;meros decimales separados por espacios.</target>
        </trans-unit>
        <trans-unit id="a79d1b4a44870cfcd4b53d3f95a0c8fcc074b16b" translate="yes" xml:space="preserve">
          <source>The textual representation of &lt;code&gt;A&lt;/code&gt; includes the textual representation of &lt;code&gt;B&lt;/code&gt;</source>
          <target state="translated">La representaci&amp;oacute;n textual de &lt;code&gt;A&lt;/code&gt; incluye la representaci&amp;oacute;n textual de &lt;code&gt;B&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="484f772cf54bb66a16db5954b6b4e3c3d93ea751" translate="yes" xml:space="preserve">
          <source>The thread that intends to modify the variable has to.</source>
          <target state="translated">El hilo que pretende modificar la variable tiene que hacerlo.</target>
        </trans-unit>
        <trans-unit id="e07534c510b6011cf58e1ef843a07565960e50d4" translate="yes" xml:space="preserve">
          <source>The three-way comparison operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador de comparación de tres vías tienen la forma.</target>
        </trans-unit>
        <trans-unit id="ab243e4025d54ef42cc354407fff2484190465e4" translate="yes" xml:space="preserve">
          <source>The throw-expression &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; is not guaranteed to be matched by a pointer catch clause, because the exception object type may be &lt;code&gt;int&lt;/code&gt;, but &lt;code&gt;throw nullptr;&lt;/code&gt; is assuredly matched by any pointer or pointer-to-member catch clause.</source>
          <target state="translated">La expresi&amp;oacute;n de &lt;code&gt;throw &lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;;&lt;/code&gt; no se garantiza que coincida con una cl&amp;aacute;usula catch de puntero, porque el tipo de objeto de excepci&amp;oacute;n puede ser &lt;code&gt;int&lt;/code&gt; , pero &lt;code&gt;throw nullptr;&lt;/code&gt; seguramente coincide con cualquier puntero o cl&amp;aacute;usula catch de puntero a miembro.</target>
        </trans-unit>
        <trans-unit id="7ac8ab79b96ed80e6fe4f38b7019eb38273067c1" translate="yes" xml:space="preserve">
          <source>The throw-expression is classified as &lt;a href=&quot;value_category&quot;&gt;prvalue expression&lt;/a&gt; of type &lt;code&gt;void&lt;/code&gt;. Like any other expression, it may be a sub-expression in another expression, most commonly in the &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;conditional operator&lt;/a&gt;:</source>
          <target state="translated">La expresi&amp;oacute;n de lanzamiento se clasifica como &lt;a href=&quot;value_category&quot;&gt;expresi&amp;oacute;n prvalue&lt;/a&gt; de tipo &lt;code&gt;void&lt;/code&gt; . Como cualquier otra expresi&amp;oacute;n, puede ser una subexpresi&amp;oacute;n en otra expresi&amp;oacute;n, m&amp;aacute;s com&amp;uacute;nmente en el &lt;a href=&quot;operator_other#Conditional_operator&quot;&gt;operador condicional&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="f868d34253cbb949d0014de0f9071a9627d84ee5" translate="yes" xml:space="preserve">
          <source>The throwing overload is additionally specified to throw &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;status(p)&lt;/code&gt; would throw.</source>
          <target state="translated">La sobrecarga de lanzamiento se especifica adicionalmente para lanzar &lt;code&gt;&lt;a href=&quot;filesystem_error&quot;&gt;std::filesystem::filesystem_error&lt;/a&gt;&lt;/code&gt; si se lanza el &lt;code&gt;status(p)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc934bec30518ea798c5b7ac6343fa0fedd9880c" translate="yes" xml:space="preserve">
          <source>The tick period of the clock in seconds.</source>
          <target state="translated">El período de tictac del reloj en segundos.</target>
        </trans-unit>
        <trans-unit id="2af4361db95a4cd97928b9e845816898c3e9820b" translate="yes" xml:space="preserve">
          <source>The tied stream, or a null pointer if there was no tied stream.</source>
          <target state="translated">El arroyo atado,o un puntero nulo si no había un arroyo atado.</target>
        </trans-unit>
        <trans-unit id="a5636311e3a8dbe661c517df9ff905b4bc0cff87" translate="yes" xml:space="preserve">
          <source>The time input manipulator &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; (technically, &lt;a href=&quot;../../locale/time_get/get&quot;&gt;&lt;code&gt;time_get::get&lt;/code&gt;&lt;/a&gt; it calls), if the input cannot be unambiguously parsed as a time value according to the given format string.</source>
          <target state="translated">El manipulador de entrada de tiempo &lt;code&gt;&lt;a href=&quot;../manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; (t&amp;eacute;cnicamente, &lt;a href=&quot;../../locale/time_get/get&quot;&gt; &lt;code&gt;time_get::get&lt;/code&gt; &lt;/a&gt; it llama), si la entrada no puede analizarse sin ambig&amp;uuml;edades como un valor de tiempo de acuerdo con la cadena de formato dada.</target>
        </trans-unit>
        <trans-unit id="9fa1c3ac8a91c2dbb258d7d0b1ca35724a76b047" translate="yes" xml:space="preserve">
          <source>The timeout has expired</source>
          <target state="translated">El tiempo de espera ha expirado</target>
        </trans-unit>
        <trans-unit id="cda93e07e16d4fa1f6f842ae631aef263d983dc5" translate="yes" xml:space="preserve">
          <source>The top-level scope of a translation unit (&quot;file scope&quot; or &quot;global scope&quot;) is also a namespace and is properly called &quot;global namespace scope&quot;. The potential scope of any entity declared in the global namespace scope begins at the declaration and continues to the end of the translation unit.</source>
          <target state="translated">El ámbito de nivel superior de una unidad de traducción (&quot;ámbito de archivo&quot; o &quot;ámbito global&quot;)es también un espacio de nombres y se denomina propiamente &quot;ámbito de espacio de nombres global&quot;.El posible alcance de cualquier entidad declarada en el ámbito del espacio de nombres mundial comienza en la declaración y continúa hasta el final de la unidad de traducción.</target>
        </trans-unit>
        <trans-unit id="f4b95d9b7d4331d266dae2fa32fe8fccb817c35a" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_copy_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; type, must be an lvalue of type &lt;code&gt;T&lt;/code&gt;) and does not check the semantic requirement that the argument expression remains unchanged. It also does not check that &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, which is required of all &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; types.</source>
          <target state="translated">El rasgo &lt;code&gt;std::is_copy_assignable&lt;/code&gt; es menos estricto que &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; porque no verifica el tipo del resultado de la asignaci&amp;oacute;n (que, para un tipo &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , debe ser un valor de tipo &lt;code&gt;T&lt;/code&gt; ) y no verifica el requisito sem&amp;aacute;ntico del argumento la expresi&amp;oacute;n permanece sin cambios. Tampoco verifica que &lt;code&gt;T&lt;/code&gt; satisfaga &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , que se requiere de todos los tipos de &lt;a href=&quot;../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31f748256061c85c5babfc77d3f3bd56ed39666b" translate="yes" xml:space="preserve">
          <source>The trait &lt;code&gt;std::is_move_assignable&lt;/code&gt; is less strict than &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; because it does not check the type of the result of the assignment (which, for a &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; type, must be &lt;code&gt;T&amp;amp;&lt;/code&gt;), nor the semantic requirement that the target's value after the assignment is equivalent to the source's value before the assignment.</source>
          <target state="translated">El rasgo &lt;code&gt;std::is_move_assignable&lt;/code&gt; es menos estricto que &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; porque no verifica el tipo del resultado de la asignaci&amp;oacute;n (que, para un tipo &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , debe ser &lt;code&gt;T&amp;amp;&lt;/code&gt; ), ni el requisito sem&amp;aacute;ntico de que el valor del objetivo despu&amp;eacute;s de la asignaci&amp;oacute;n sea equivalente al valor de la fuente antes de la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c13322dcd5d602786d0d4da2697757a492c38ddc" translate="yes" xml:space="preserve">
          <source>The transformed type is a publicly accessible nested type named &lt;code&gt;type&lt;/code&gt;</source>
          <target state="translated">El tipo transformado es un tipo anidado de acceso p&amp;uacute;blico denominado &lt;code&gt;type&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd0c6a8d80fefbf063a7c6fc4d41e35477e554e0" translate="yes" xml:space="preserve">
          <source>The transition algorithm of the LCG function is x</source>
          <target state="translated">El algoritmo de transición de la función LCG es x</target>
        </trans-unit>
        <trans-unit id="ed030a839d21fbb758c903e3966139f3e58ea684" translate="yes" xml:space="preserve">
          <source>The tuple need not be &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, and instead may be anything that supports &lt;code&gt;std::get&lt;/code&gt; and &lt;code&gt;std::tuple_size&lt;/code&gt;; in particular, &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">La tupla no necesita ser &lt;code&gt;&lt;a href=&quot;tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , y en su lugar puede ser cualquier cosa que admita &lt;code&gt;std::get&lt;/code&gt; y &lt;code&gt;std::tuple_size&lt;/code&gt; ; en particular, se pueden usar &lt;code&gt;&lt;a href=&quot;../container/array&quot;&gt;std::array&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="faab3655bae1576862bf3243d78b803053240daa" translate="yes" xml:space="preserve">
          <source>The tuple-like interpretation is always used if &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; is a complete type, even if that would cause the program to be ill-formed:</source>
          <target state="translated">La interpretaci&amp;oacute;n tipo tupla siempre se usa si &lt;code&gt;&lt;a href=&quot;../utility/tuple/tuple_size&quot;&gt;std::tuple_size&lt;/a&gt;&amp;lt;E&amp;gt;&lt;/code&gt; es un tipo completo, incluso si eso causar&amp;iacute;a que el programa est&amp;eacute; mal formado:</target>
        </trans-unit>
        <trans-unit id="280f7270ad4976a06da0f10d73ed8109ee8c86a2" translate="yes" xml:space="preserve">
          <source>The two overloads are distinct because the types of the parameter &lt;code&gt;func&lt;/code&gt; are distinct (&lt;a href=&quot;../../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">Las dos sobrecargas son distintas porque los tipos del par&amp;aacute;metro &lt;code&gt;func&lt;/code&gt; son distintos (el &lt;a href=&quot;../../language/language_linkage&quot;&gt;enlace de idioma&lt;/a&gt; es parte de su tipo).</target>
        </trans-unit>
        <trans-unit id="ced307005cb72698444581ef51d2ce693acf63e2" translate="yes" xml:space="preserve">
          <source>The two overloads provided by the C++ standard library are distinct because the types of the parameter &lt;code&gt;comp&lt;/code&gt; are distinct (&lt;a href=&quot;../language/language_linkage&quot;&gt;language linkage&lt;/a&gt; is part of its type).</source>
          <target state="translated">Los dos sobrecargas proporcionadas por la biblioteca est&amp;aacute;ndar de C ++ son distintos debido a que los tipos de par&amp;aacute;metro de &lt;code&gt;comp&lt;/code&gt; son distintos ( &lt;a href=&quot;../language/language_linkage&quot;&gt;vinculaci&amp;oacute;n lenguaje&lt;/a&gt; es parte de su tipo).</target>
        </trans-unit>
        <trans-unit id="7e0c402d18cba21bbc3c62ac427b669b87db8687" translate="yes" xml:space="preserve">
          <source>The two-way comparison operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador de comparación bidireccional tienen la forma.</target>
        </trans-unit>
        <trans-unit id="b32340d0d14dfd5d1c51dde23771404f36595788" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">El tipo &lt;code&gt;&lt;a href=&quot;../error/exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3e4f9ee4f9a6dc679b68e252ddbe4d829628a2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;D&lt;/code&gt; satisfies RandomNumberDistribution if.</source>
          <target state="translated">El tipo &lt;code&gt;D&lt;/code&gt; satisface RandomNumberDistribution si.</target>
        </trans-unit>
        <trans-unit id="9d9d3aa5279931f61ae09ea879f4c70a82c6ceaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;G&lt;/code&gt; satisfies UniformRandomBitGenerator if.</source>
          <target state="translated">El tipo &lt;code&gt;G&lt;/code&gt; satisface UniformRandomBitGenerator si.</target>
        </trans-unit>
        <trans-unit id="c21b37c97960f36e90434bac25ddcd2dc1e68569" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="2dca3e5d709f32f44d0ddfe5eab719ca4892184c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="23ab122f56da738cdd552f61aadec9d1cd833ab0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="b6b3d6cdd7d4f3c9acce01cee40f271ece634a18" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="252d2ffb66f7d81557faa1f7f4f4ea09867d93b2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;destructible&quot;&gt;destructible&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="4b8f1bcfc4815dc189422b13e3981c0b3806ab7c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="d7e27b1e0bc61deba4ad72e16345b7759b232775" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="8e98de10f38832410717d032044fe5876aae1620" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="19b959ec118b4fc4e346a0c4b3066583c69eb391" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1e6b1f70b5515f9b7f9ece951c8b0565a4faeae3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies ConstexprIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si ConstexprIterator.</target>
        </trans-unit>
        <trans-unit id="99ec40230a473cc7e644a50a1f568278d332cce3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyBidirectionalIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyBidirectionalIterator.</target>
        </trans-unit>
        <trans-unit id="fb470c2619e1df677c704caef889c4118fc3151e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyContiguousIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyContiguousIterator.</target>
        </trans-unit>
        <trans-unit id="630cbbc2820c720d8b04165d105e0a9744bea443" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyForwardIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyForwardIterator.</target>
        </trans-unit>
        <trans-unit id="0ffbcd885e9525a21db6be67dd85f4aff0c605f1" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyInputIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyInputIterator.</target>
        </trans-unit>
        <trans-unit id="98c67370e8cebdd88c142031ae165afb773d121a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyIterator.</target>
        </trans-unit>
        <trans-unit id="685b9ef2517672d40d4de466c9757d30ae0a366e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies LegacyRandomAccessIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface si LegacyRandomAccessIterator.</target>
        </trans-unit>
        <trans-unit id="c0271171a00bcc035de12ccb951df5f4eb58be30" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;It&lt;/code&gt; satisfies some iterator requirements MeowIterator</source>
          <target state="translated">El tipo &lt;code&gt;It&lt;/code&gt; satisface algunos requisitos iterador MeowIterator</target>
        </trans-unit>
        <trans-unit id="3fa432a57da4f847b5c070a3bfc7c01c5763011a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;ForwardIt&lt;/code&gt; pueda ser desreferenciado y se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3a1ebcc723e658952997b5498f82af157e85e51" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;OutputIt&lt;/code&gt; pueda ser desreferenciado y se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="949b21cde2cc2392d063407c9e220c78be2ec5c8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;CopyInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if &lt;code&gt;T&lt;/code&gt; is &lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;X&lt;/code&gt;, and, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;CopyInsertable&lt;/strong&gt; en el contenedor &lt;code&gt;X&lt;/code&gt; cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; si &lt;code&gt;T&lt;/code&gt; es &lt;a href=&quot;moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; en &lt;code&gt;X&lt;/code&gt; , y, dado.</target>
        </trans-unit>
        <trans-unit id="3d96c921cf6324f16eef56dd97bb17fac1318864" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;DefaultInsertable&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;DefaultInsertable&lt;/strong&gt; en el &lt;a href=&quot;container&quot;&gt;contenedor &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; si, dado.</target>
        </trans-unit>
        <trans-unit id="4a2192b55df7721f52fc4a376a8910667373086e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;EmplaceConstructible&lt;/strong&gt; into the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; (whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt;) from the arguments &lt;code&gt;args&lt;/code&gt; if, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;EmplaceConstructible&lt;/strong&gt; en el &lt;a href=&quot;container&quot;&gt;contenedor &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; (cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; ) de los argumentos &lt;code&gt;args&lt;/code&gt; if, dado.</target>
        </trans-unit>
        <trans-unit id="5237f2595087683918faff0e0fb827167c77ec98" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;Erasable&lt;/strong&gt; from the &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;&lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;borrable&lt;/strong&gt; del &lt;a href=&quot;container&quot;&gt;contenedor &lt;/a&gt; &lt;code&gt;X&lt;/code&gt; cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; si, dado.</target>
        </trans-unit>
        <trans-unit id="7c4f49cd45501a79870e1b3afa64d91ff0308500" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is &lt;strong&gt;MoveInsertable&lt;/strong&gt; into the container &lt;code&gt;X&lt;/code&gt; whose &lt;code&gt;value_type&lt;/code&gt; is identical to &lt;code&gt;T&lt;/code&gt; if, given.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; es &lt;strong&gt;MoveInsertable&lt;/strong&gt; en el contenedor &lt;code&gt;X&lt;/code&gt; cuyo &lt;code&gt;value_type&lt;/code&gt; es id&amp;eacute;ntico a &lt;code&gt;T&lt;/code&gt; si, dado.</target>
        </trans-unit>
        <trans-unit id="0e41120cbb6ece4723895cfa12eeda9a968c6032" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; is not allowed to be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;, even if the size or internal structure of &lt;code&gt;T&lt;/code&gt; is never used, as in &lt;code&gt;&amp;amp;x[0]&lt;/code&gt;.</source>
          <target state="translated">No se permite que el tipo &lt;code&gt;T&lt;/code&gt; sea ​​un &lt;a href=&quot;incomplete_type&quot;&gt;tipo incompleto&lt;/a&gt; , incluso si el tama&amp;ntilde;o o la estructura interna de &lt;code&gt;T&lt;/code&gt; nunca se usa, como en &lt;code&gt;&amp;amp;x[0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94188845ce20ed55f2a876e3342aa84bc7330295" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;a href=&quot;binarypredicate&quot;&gt;BinaryPredicate&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="4d4404ddfa538ff7555e67eecb1dbcc3ff5cdc1a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt; , &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt; y</target>
        </trans-unit>
        <trans-unit id="0db4b9570ecd95be9606704e9f21eff1149143a0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;a href=&quot;moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="6647adc652b8dbbc01016470d35eed7d2fe7e630" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;a href=&quot;moveconstructible&quot;&gt;MoveConstructible&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="4262127f8a223198cec9f54e58d1717c6a50c453" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface &lt;code&gt;&lt;a href=&quot;../types/is_object&quot;&gt;std::is_object&lt;/a&gt;&lt;/code&gt; , y</target>
        </trans-unit>
        <trans-unit id="3f046e47e7505811e9555f3b245d7d20697f7a3e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Callable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface Callable if.</target>
        </trans-unit>
        <trans-unit id="49e6eff2866df130bb7fd318296a16096d51e92f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Compare if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface Compare if.</target>
        </trans-unit>
        <trans-unit id="66ff21aa578ecf4f62632269d8614fbe18a110bb" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyAssignable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface CopyAssignable si.</target>
        </trans-unit>
        <trans-unit id="0ad2a77779033cb383bdf5ceddef00240ba13b76" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies CopyConstructible if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface CopyConstructible si.</target>
        </trans-unit>
        <trans-unit id="2e05ec58d3dab38ca771379d16b2fe5adee88104" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies DefaultConstructible if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface DefaultConstructible if.</target>
        </trans-unit>
        <trans-unit id="cc55fbe4fbf6e0f85ba467734b5b915583f84e1b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Destructible if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface Destructible if.</target>
        </trans-unit>
        <trans-unit id="dfe96628803d13e4d50a5465ce9ed6a67992a048" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies EqualityComparable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface EqualityComparable if.</target>
        </trans-unit>
        <trans-unit id="41ee5c2d1ddb0009a5b5ac10f88ce89d5cc10e9a" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies FunctionObject if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface FunctionObject if.</target>
        </trans-unit>
        <trans-unit id="3ae67a347ab32c589872346530c83699208f4eaa" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies Hash if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface Hash si.</target>
        </trans-unit>
        <trans-unit id="9d2af4bf93a9ceba9a70379149efdadf03a56bc7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies LessThanComparable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface LessThanComparable if.</target>
        </trans-unit>
        <trans-unit id="52a749029f41bfcab44646101c78f08a559bdcdd" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveAssignable if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface MoveAssignable si.</target>
        </trans-unit>
        <trans-unit id="aaf38d3e0ca9bb3163280eb3190656f5f78d0b7e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;T&lt;/code&gt; satisfies MoveConstructible if.</source>
          <target state="translated">El tipo &lt;code&gt;T&lt;/code&gt; satisface MoveConstructible si.</target>
        </trans-unit>
        <trans-unit id="3c095863553c4d9f9528e17b876f6565ea71dc1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;TC::time_point::clock&lt;/code&gt; meets the TrivialClock requirements, recursively.</source>
          <target state="translated">El tipo &lt;code&gt;TC::time_point::clock&lt;/code&gt; cumple los requisitos de TrivialClock, de forma recursiva.</target>
        </trans-unit>
        <trans-unit id="8c5bdf5c0ebdfaea70c628010c98d8c02bdb6a1e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type1&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;ForwardIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a &lt;code&gt;Type1&lt;/code&gt; . El tipo &lt;code&gt;Type2&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;T&lt;/code&gt; pueda convertirse impl&amp;iacute;citamente en &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76589c2d20456a54480cd63abef696cc4671a0d0" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type1&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;T&lt;/code&gt; pueda convertirse impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; . El tipo &lt;code&gt;Type2&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;ForwardIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e15c34b8b5699cfcccd67dddcde261f5330e1e3" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type1&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;T&lt;/code&gt; pueda convertirse impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; . El tipo &lt;code&gt;Type2&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;InputIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a &lt;code&gt;Type2&lt;/code&gt; . El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que a un objeto de tipo &lt;code&gt;T&lt;/code&gt; se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c7c828977f3aee5181d50399292252dea34b2f7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type1&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt;. The type &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type2&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type1&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; pueda convertirse impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; . El tipo &lt;code&gt;Type2&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;InputIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a &lt;code&gt;Type2&lt;/code&gt; . El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que a un objeto de tipo &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="446f611669a83b2fef5ed0fe51541c392716bba5" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;Type&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;InputIt&lt;/code&gt; pueda ser desreferenciado y luego impl&amp;iacute;citamente convertido a &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a83e5bd1fdfaaf9d85e03162ceb874df7fc25ab" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;InputIt&lt;/code&gt; pueda ser desreferenciado y luego impl&amp;iacute;citamente convertido a &lt;code&gt;Type&lt;/code&gt; . El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;OutputIt&lt;/code&gt; pueda ser desreferenciado y se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f2ee2c7e39e16c2fc94f6e2cd419b938a6ba925" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;Type&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type&lt;/code&gt;. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;double&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">El tipo &lt;code&gt;Type&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;double&lt;/code&gt; pueda ser desreferenciado y luego impl&amp;iacute;citamente convertido a &lt;code&gt;Type&lt;/code&gt; . El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que se pueda desreferenciar un objeto de tipo &lt;code&gt;double&lt;/code&gt; y asignarle un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b435ca7efbcb7d3a69a4c425c8166ae1ecf9b3b8" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface el &lt;a href=&quot;container&quot;&gt;contenedor&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="51c4cd0302a38d9ca2d378e53146319f03ed2267" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;container&quot;&gt;Container&lt;/a&gt;, and</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface el &lt;a href=&quot;container&quot;&gt;Contenedor&lt;/a&gt; , y</target>
        </trans-unit>
        <trans-unit id="6607d21d863fd1139823f255f3616f78582f1b99" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface &lt;a href=&quot;iterator&quot;&gt;LegacyIterator&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fd2220d4e7d2be0a6e2436dc20ed5fc81f925717" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies ContiguousContainer if.</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface ContiguousContainer si.</target>
        </trans-unit>
        <trans-unit id="9c59f17268ae0799c6c9ad4a2f510730b7974007" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies LegacyOutputIterator if.</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface LegacyOutputIterator si.</target>
        </trans-unit>
        <trans-unit id="4ce304e60343f172de9a358f8aec0594d119616e" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; satisfies SequenceContainer if.</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; satisface SequenceContainer si.</target>
        </trans-unit>
        <trans-unit id="0b0a4238d5b55da548fec0c52f2f145ef62aca2f" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;X&lt;/code&gt; supports &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;</source>
          <target state="translated">El tipo &lt;code&gt;X&lt;/code&gt; es compatible con &lt;a href=&quot;randomaccessiterator&quot;&gt;LegacyRandomAccessIterators&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9c91c4098ab4ce6057b1eb103c2691ca5d989b78" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; must be exactly</source>
          <target state="translated">El tipo &lt;code&gt;std::iterator_traits&amp;lt;It&amp;gt;::reference&lt;/code&gt; debe ser exactamente</target>
        </trans-unit>
        <trans-unit id="3d90dab02f7f3b6e43e81a90b17cf46259c35fe4" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; is a &lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with a BaseCharacteristic of &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;std::negation&amp;lt;B&amp;gt;&lt;/code&gt; &lt;a href=&quot;../named_req/unarytypetrait&quot;&gt;negation &lt;/a&gt;&amp;lt;B&amp;gt; es un UnaryTypeTrait con una BaseCharacteristic de &lt;code&gt;&lt;a href=&quot;integral_constant&quot;&gt;std::bool_constant&lt;/a&gt;&amp;lt;!bool(B::value)&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83883f03d07c1a12ee9dfb5e67e0fc6f4a49f177" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::partial_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">El tipo &lt;code&gt;std::partial_ordering&lt;/code&gt; tiene cuatro valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo:</target>
        </trans-unit>
        <trans-unit id="baf068b5f9f0a2f3a687379dab87c44a84ac79f2" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamoff&lt;/code&gt; is a signed integral type of sufficient size to represent the maximum possible file size supported by the operating system. Typically, this is a typedef to &lt;code&gt;long long&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;std::streamoff&lt;/code&gt; es un tipo integral con signo de tama&amp;ntilde;o suficiente para representar el tama&amp;ntilde;o m&amp;aacute;ximo posible de archivo admitido por el sistema operativo. Por lo general, este es un typedef a &lt;code&gt;long long&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="081a86b87857472711ceb628824320cbad10918c" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::streamsize&lt;/code&gt; is a signed integral type used to represent the number of characters transferred in an I/O operation or the size of an I/O buffer. It is used as a signed counterpart of &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;, similar to the POSIX type &lt;code&gt;ssize_t&lt;/code&gt;.</source>
          <target state="translated">El tipo &lt;code&gt;std::streamsize&lt;/code&gt; es un tipo integral con signo que se utiliza para representar el n&amp;uacute;mero de caracteres transferidos en una operaci&amp;oacute;n de E / S o el tama&amp;ntilde;o de un b&amp;uacute;fer de E / S. Se utiliza como una contraparte firmada de &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , similar al tipo POSIX &lt;code&gt;ssize_t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35bd4cec907f3b6ac35655e3dc99fe6dc74b2c63" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_equality&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">El tipo &lt;code&gt;std::strong_equality&lt;/code&gt; tiene cuatro valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo:</target>
        </trans-unit>
        <trans-unit id="d1fa9bb7b57f78a76b739de735267fbd796b77b7" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::strong_ordering&lt;/code&gt; has four valid values, implemented as const static data members of its type:</source>
          <target state="translated">El tipo &lt;code&gt;std::strong_ordering&lt;/code&gt; tiene cuatro valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo:</target>
        </trans-unit>
        <trans-unit id="caaff90770bed5d2d4f0c217a33a582a915365ac" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_equality&lt;/code&gt; has only two valid values, implemented as const static data members of its type: &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; and &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt;:</source>
          <target state="translated">El tipo &lt;code&gt;std::weak_equality&lt;/code&gt; tiene solo dos valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo: &lt;code&gt;std::weak_equality::equivalent&lt;/code&gt; y &lt;code&gt;std::weak_equality::nonequivalent&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="5b1a20430a83aa89500e66ebd1c9900c5d380b9b" translate="yes" xml:space="preserve">
          <source>The type &lt;code&gt;std::weak_ordering&lt;/code&gt; has three valid values, implemented as const static data members of its type:</source>
          <target state="translated">El tipo &lt;code&gt;std::weak_ordering&lt;/code&gt; tiene tres valores v&amp;aacute;lidos, implementados como miembros de datos est&amp;aacute;ticos constantes de su tipo:</target>
        </trans-unit>
        <trans-unit id="eea5d0d3527e4ae7b88635106c278af003375133" translate="yes" xml:space="preserve">
          <source>The type T may be an incomplete type.</source>
          <target state="translated">El tipo T puede ser un tipo incompleto.</target>
        </trans-unit>
        <trans-unit id="47e3c39ad9f26d80f148e942aab053b6361ba66e" translate="yes" xml:space="preserve">
          <source>The type allows subnormal values</source>
          <target state="translated">El tipo permite valores subnormales</target>
        </trans-unit>
        <trans-unit id="89d3d7da193a1958b43f17239e6e96abc49dd3f5" translate="yes" xml:space="preserve">
          <source>The type and value category of the conditional expression &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; are determined according to the following rules:</source>
          <target state="translated">El tipo y la categor&amp;iacute;a de valor de la expresi&amp;oacute;n condicional &lt;code&gt;E1 ? E2 : E3&lt;/code&gt; se determinan de acuerdo con las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="b0032656c660ab91cfc9f1912ec36a11287348d7" translate="yes" xml:space="preserve">
          <source>The type deduced by these deduction guides may change in a later standard revision (in particular, this might happen if &lt;code&gt;noexcept&lt;/code&gt; support is added to &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; in a later standard).</source>
          <target state="translated">El tipo deducido por estas gu&amp;iacute;as de deducci&amp;oacute;n puede cambiar en una revisi&amp;oacute;n est&amp;aacute;ndar posterior (en particular, esto podr&amp;iacute;a suceder si &lt;code&gt;noexcept&lt;/code&gt; se agrega compatibilidad con &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; en un est&amp;aacute;ndar posterior).</target>
        </trans-unit>
        <trans-unit id="8dcc1ea760f892b4e6eddb08b2acf9f9c879aeb1" translate="yes" xml:space="preserve">
          <source>The type defined by &lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; can be used to create uninitialized memory blocks suitable to hold the objects of given type, optionally aligned stricter than their natural alignment requirement, for example on a cache or page boundary.</source>
          <target state="translated">El tipo definido por &lt;code&gt;std::aligned_storage&amp;lt;&amp;gt;::type&lt;/code&gt; se puede usar para crear bloques de memoria sin inicializar adecuados para contener los objetos de un tipo dado, opcionalmente m&amp;aacute;s estrictamente alineado que su requisito de alineaci&amp;oacute;n natural, por ejemplo en un cach&amp;eacute; o l&amp;iacute;mite de p&amp;aacute;gina.</target>
        </trans-unit>
        <trans-unit id="015fb8d559015f4868df42502a384ec989660bc6" translate="yes" xml:space="preserve">
          <source>The type does not have to implement &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this type requirement: a &lt;a href=&quot;../language/as_operator&quot;&gt;copy assignment operator&lt;/a&gt; that takes its parameter by value or as a &lt;code&gt;const Type&amp;amp;&lt;/code&gt;, will bind to rvalue argument.</source>
          <target state="translated">El tipo no tiene que implementar el &lt;a href=&quot;../language/move_operator&quot;&gt;operador de asignaci&amp;oacute;n de movimiento&lt;/a&gt; para satisfacer este requisito de tipo: un &lt;a href=&quot;../language/as_operator&quot;&gt;operador de asignaci&amp;oacute;n de copia&lt;/a&gt; que toma su par&amp;aacute;metro por valor o como un &lt;code&gt;const Type&amp;amp;&lt;/code&gt; , se unir&amp;aacute; al argumento rvalue.</target>
        </trans-unit>
        <trans-unit id="4ee6bc4a29e09101e3ca894cf68274fb41416543" translate="yes" xml:space="preserve">
          <source>The type does not have to implement a &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operator&lt;/a&gt; in order to satisfy this trait; see &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; for details.</source>
          <target state="translated">El tipo no tiene que implementar un &lt;a href=&quot;../language/move_operator&quot;&gt;operador de asignaci&amp;oacute;n de movimiento&lt;/a&gt; para satisfacer este rasgo; ver &lt;a href=&quot;../named_req/moveassignable&quot;&gt;MoveAssignable&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="71c7ef3196579896dbcb86da29f6c58aaeef4821" translate="yes" xml:space="preserve">
          <source>The type does not support subnormal values</source>
          <target state="translated">El tipo no soporta valores subnormales</target>
        </trans-unit>
        <trans-unit id="c0aefe5f52f0c91ab7dcca87fc13463e2b84f15b" translate="yes" xml:space="preserve">
          <source>The type mbstate_t is a trivial non-array type that can represent any of the conversion states that can occur in an implementation-defined set of supported multibyte character encoding rules. Zero-initialized value of &lt;code&gt;mbstate_t&lt;/code&gt; represents the initial conversion state, although other values of &lt;code&gt;mbstate_t&lt;/code&gt; may exist that also represent the initial conversion state.</source>
          <target state="translated">El tipo mbstate_t es un tipo trivial sin matriz que puede representar cualquiera de los estados de conversi&amp;oacute;n que pueden ocurrir en un conjunto definido por la implementaci&amp;oacute;n de reglas de codificaci&amp;oacute;n de caracteres multibyte compatibles. El valor de inicializaci&amp;oacute;n cero de &lt;code&gt;mbstate_t&lt;/code&gt; representa el estado de conversi&amp;oacute;n inicial, aunque pueden existir otros valores de &lt;code&gt;mbstate_t&lt;/code&gt; que tambi&amp;eacute;n representen el estado de conversi&amp;oacute;n inicial.</target>
        </trans-unit>
        <trans-unit id="ee6f31452577bc5b29d1b96501ba9c9ead4fd373" translate="yes" xml:space="preserve">
          <source>The type must meet &lt;a href=&quot;clock&quot;&gt;Clock&lt;/a&gt; requirements.</source>
          <target state="translated">El tipo debe cumplir los requisitos del &lt;a href=&quot;clock&quot;&gt;reloj&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="417fa810ac7b429d2e715174963cd48512430822" translate="yes" xml:space="preserve">
          <source>The type must meet all of the following requirements:</source>
          <target state="translated">El tipo debe cumplir todos los requisitos siguientes:</target>
        </trans-unit>
        <trans-unit id="5fe47f690f454a471c8cf3ffe3e0c793213ba10d" translate="yes" xml:space="preserve">
          <source>The type must satisfy the following additional expressions, given two values &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;q&lt;/code&gt; that are of the type, and that &lt;code&gt;np&lt;/code&gt; is a value of &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; type (possibly &lt;code&gt;const&lt;/code&gt; qualified):</source>
          <target state="translated">El tipo debe satisfacer las siguientes expresiones adicionales, dados dos valores &lt;code&gt;p&lt;/code&gt; y &lt;code&gt;q&lt;/code&gt; que son del tipo, y que &lt;code&gt;np&lt;/code&gt; es un valor del tipo &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; (posiblemente &lt;code&gt;const&lt;/code&gt; calificado):</target>
        </trans-unit>
        <trans-unit id="369901cace11f8d9f2b85e35e2783ef729d22cb1" translate="yes" xml:space="preserve">
          <source>The type must work with &amp;lt; operator and the result should have standard semantics.</source>
          <target state="translated">El tipo debe funcionar con &amp;lt;operator y el resultado debe tener una sem&amp;aacute;ntica est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="8ccea44fbb2fd126230d043404a673c987073e90" translate="yes" xml:space="preserve">
          <source>The type must work with == operator and the result should have standard semantics.</source>
          <target state="translated">El tipo debe funcionar con ==operador y el resultado debe tener una semántica estándar.</target>
        </trans-unit>
        <trans-unit id="a401af7b772905929e6c578148662943f7e9b5a8" translate="yes" xml:space="preserve">
          <source>The type need not be &lt;a href=&quot;incomplete_type&quot;&gt;complete&lt;/a&gt; or have an available &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt;, and can be &lt;a href=&quot;abstract_class&quot;&gt;abstract&lt;/a&gt;. This rule doesn't apply to sub-expressions: in &lt;code&gt;decltype(f(g()))&lt;/code&gt;, &lt;code&gt;g()&lt;/code&gt; must have a complete type, but &lt;code&gt;f()&lt;/code&gt; need not.</source>
          <target state="translated">El tipo no necesita estar &lt;a href=&quot;incomplete_type&quot;&gt;completo&lt;/a&gt; o tener un &lt;a href=&quot;destructor&quot;&gt;destructor&lt;/a&gt; disponible , y puede ser &lt;a href=&quot;abstract_class&quot;&gt;abstracto&lt;/a&gt; . Esta regla no se aplica a las &lt;code&gt;decltype(f(g()))&lt;/code&gt; : en decltype (f (g ())) , &lt;code&gt;g()&lt;/code&gt; debe tener un tipo completo, pero &lt;code&gt;f()&lt;/code&gt; no necesita.</target>
        </trans-unit>
        <trans-unit id="c83f8d22479920f797dda997ec4470602b5cb196" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;E&lt;/code&gt; after substitution must be exactly &lt;code&gt;bool&lt;/code&gt;. No conversion is permitted:</source>
          <target state="translated">El tipo de &lt;code&gt;E&lt;/code&gt; despu&amp;eacute;s de la sustituci&amp;oacute;n debe ser exactamente &lt;code&gt;bool&lt;/code&gt; . No se permite la conversi&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="092bcee309aef84863a0a22c05df0ff5cc2306f8" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;N&lt;/code&gt; in the type &lt;code&gt;T[N]&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo de &lt;code&gt;N&lt;/code&gt; en el tipo &lt;code&gt;T[N]&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e00aa691520243fc7bb95963a65a42850ff0ee2d" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;replacement&lt;/code&gt; is &lt;code&gt;std::filesystem::path&lt;/code&gt; even though it is not intended to represent an object on the file system in order to correctly account for the filesystem character encoding.</source>
          <target state="translated">El tipo de &lt;code&gt;replacement&lt;/code&gt; es &lt;code&gt;std::filesystem::path&lt;/code&gt; , aunque no est&amp;aacute; destinado a representar un objeto en el sistema de archivos para tener en cuenta correctamente la codificaci&amp;oacute;n de caracteres del sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="73ef25a9616ca1a936ee4e3bf75aad3a667fbb50" translate="yes" xml:space="preserve">
          <source>The type of &lt;code&gt;this&lt;/code&gt; in a member function of class &lt;code&gt;X&lt;/code&gt; is &lt;code&gt;X*&lt;/code&gt; (pointer to X). If the member function is &lt;a href=&quot;member_functions&quot;&gt;cv-qualified&lt;/a&gt;, the type of &lt;code&gt;this&lt;/code&gt; is &lt;code&gt;cv X*&lt;/code&gt; (pointer to identically cv-qualified X). Since constructors and destructors cannot be cv-qualified, the type of &lt;code&gt;this&lt;/code&gt; in them is always &lt;code&gt;X*&lt;/code&gt;, even when constructing or destroying a const object.</source>
          <target state="translated">El tipo de &lt;code&gt;this&lt;/code&gt; en una funci&amp;oacute;n miembro de la clase &lt;code&gt;X&lt;/code&gt; es &lt;code&gt;X*&lt;/code&gt; (puntero a X). Si la funci&amp;oacute;n miembro est&amp;aacute; &lt;a href=&quot;member_functions&quot;&gt;calificada para cv&lt;/a&gt; , el tipo de &lt;code&gt;this&lt;/code&gt; es &lt;code&gt;cv X*&lt;/code&gt; (puntero a X id&amp;eacute;nticamente calificado para cv). Dado que los constructores y destructores no pueden ser calificados para cv, el tipo de &lt;code&gt;this&lt;/code&gt; en ellos siempre es &lt;code&gt;X*&lt;/code&gt; , incluso cuando se construye o destruye un objeto constante.</target>
        </trans-unit>
        <trans-unit id="4a3330b556852ca71717541f2c81d240e408418f" translate="yes" xml:space="preserve">
          <source>The type of a &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; appearing in an alias template declaration is different between instantiations of that template, even when the lambda expression is not dependent.</source>
          <target state="translated">El tipo de una &lt;a href=&quot;lambda&quot;&gt;expresi&amp;oacute;n lambda que&lt;/a&gt; aparece en una declaraci&amp;oacute;n de plantilla de alias es diferente entre las instancias de esa plantilla, incluso cuando la expresi&amp;oacute;n lambda no es dependiente.</target>
        </trans-unit>
        <trans-unit id="1c03df0e9a6c3883eefceaf776f001998a556f7d" translate="yes" xml:space="preserve">
          <source>The type of a bit field can only be integral or enumeration type.</source>
          <target state="translated">El tipo de campo de bits sólo puede ser de tipo integral o de enumeración.</target>
        </trans-unit>
        <trans-unit id="3e828f47acdf8dd1be944f104aebcd681e249b7b" translate="yes" xml:space="preserve">
          <source>The type of a non-type template parameter may be deduced if it includes a placeholder type (&lt;code&gt;auto&lt;/code&gt;, a placeholder for a deduced class type(since C++20), or &lt;code&gt;decltype(auto)&lt;/code&gt;). The deduction is performed as if by deducing the type of the variable &lt;code&gt;x&lt;/code&gt; in the invented declaration &lt;code&gt;T x = template-argument;&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is the declared type of the template parameter. If the deduced type is not permitted for a non-type template parameter, the program is ill-formed.</source>
          <target state="translated">El tipo de un par&amp;aacute;metro de plantilla sin tipo puede deducirse si incluye un tipo de marcador de posici&amp;oacute;n ( &lt;code&gt;auto&lt;/code&gt; , un marcador de posici&amp;oacute;n para un tipo de clase deducido (desde C ++ 20) o &lt;code&gt;decltype(auto)&lt;/code&gt; ). La deducci&amp;oacute;n se realiza como si deduciendo el tipo de la variable &lt;code&gt;x&lt;/code&gt; en la declaraci&amp;oacute;n inventada &lt;code&gt;T x = template-argument;&lt;/code&gt; , donde &lt;code&gt;T&lt;/code&gt; es el tipo declarado del par&amp;aacute;metro de plantilla. Si el tipo deducido no est&amp;aacute; permitido para un par&amp;aacute;metro de plantilla sin tipo, el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="9f077ca46cbdc83666da091d5f4c5c63b8be8535" translate="yes" xml:space="preserve">
          <source>The type of a pointer to array of unknown bound, or of a type defined by a &lt;code&gt;typedef&lt;/code&gt; declaration to be an array of unknown bound, cannot be completed.</source>
          <target state="translated">El tipo de un puntero a una matriz de enlace desconocido, o de un tipo definido por una declaraci&amp;oacute;n &lt;code&gt;typedef&lt;/code&gt; como una matriz de enlace desconocido, no se puede completar.</target>
        </trans-unit>
        <trans-unit id="e1654f0998b812161591ecd53f879aa981b5cfa6" translate="yes" xml:space="preserve">
          <source>The type of an expression that results from the compile-time analysis of the program is known as the</source>
          <target state="translated">El tipo de expresión que resulta del análisis en tiempo de compilación del programa se conoce como el</target>
        </trans-unit>
        <trans-unit id="dc3ab407bca97dd7b2182e8d6089591cbf78c0f6" translate="yes" xml:space="preserve">
          <source>The type of each data member is the type of the corresponding captured entity, except if the entity has reference type (in that case, references to functions are captured as lvalue references to the referenced functions, and references to objects are captured as copies of the referenced objects).</source>
          <target state="translated">El tipo de cada miembro de los datos es el tipo de la correspondiente entidad capturada,excepto si la entidad tiene un tipo de referencia (en ese caso,las referencias a las funciones se capturan como referencias de valor a las funciones referidas,y las referencias a los objetos se capturan como copias de los objetos referidos).</target>
        </trans-unit>
        <trans-unit id="85801fe2a975f6f74abeb5935ecc5a8cbc8a24c1" translate="yes" xml:space="preserve">
          <source>The type of each function parameter in the parameter list is determined according to the following rules:</source>
          <target state="translated">El tipo de cada parámetro de la función en la lista de parámetros se determina de acuerdo con las siguientes reglas:</target>
        </trans-unit>
        <trans-unit id="14480ff70d6d9671051d3a3bebfef0ffda9aa55c" translate="yes" xml:space="preserve">
          <source>The type of function callbacks that can be registered using &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; to be called on specific events.</source>
          <target state="translated">El tipo de devoluciones de llamada de funci&amp;oacute;n que se pueden registrar utilizando &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; para que se invoque en eventos espec&amp;iacute;ficos.</target>
        </trans-unit>
        <trans-unit id="16e7bff806ed1fa4ab8073e5ade6ccec0c8f929f" translate="yes" xml:space="preserve">
          <source>The type of the</source>
          <target state="translated">El tipo de</target>
        </trans-unit>
        <trans-unit id="b1b79e1851bb8cd4e0abe53b7badea94acb8b63a" translate="yes" xml:space="preserve">
          <source>The type of the elements of the array must be a &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt;, otherwise the behavior is undefined.</source>
          <target state="translated">El tipo de los elementos de la matriz debe ser &lt;a href=&quot;../named_req/trivialtype&quot;&gt;TrivialType&lt;/a&gt; ; de lo contrario, el comportamiento no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="2a440bce9393578dcc59e67d819369eb6fff9dc5" translate="yes" xml:space="preserve">
          <source>The type of the elements.</source>
          <target state="translated">El tipo de los elementos.</target>
        </trans-unit>
        <trans-unit id="39cb107adf449bbc790a8800f9b0f24f9bbe1ba6" translate="yes" xml:space="preserve">
          <source>The type of the function being declared is composed from the</source>
          <target state="translated">El tipo de la función que se declara se compone de la</target>
        </trans-unit>
        <trans-unit id="9bbb6b4e7d477a9cc16a3aa9d6f2075047c3171b" translate="yes" xml:space="preserve">
          <source>The type of the integer literal is the first type in which the value can fit, from the list of types which depends on which numeric base and which integer-suffix was used.</source>
          <target state="translated">El tipo del entero literal es el primer tipo en el que puede caber el valor,de la lista de tipos que depende de la base numérica y del sufijo del entero que se haya utilizado.</target>
        </trans-unit>
        <trans-unit id="68e06d906da63b0e924e6b7c9ec59a39e6b3cb3e" translate="yes" xml:space="preserve">
          <source>The type of the literal</source>
          <target state="translated">El tipo de la literalidad</target>
        </trans-unit>
        <trans-unit id="66d91e0faa820f737700bea3d6d88e6c67abbd4b" translate="yes" xml:space="preserve">
          <source>The type of the stored elements. The behavior is undefined if &lt;code&gt;T&lt;/code&gt; is not the same type as &lt;code&gt;Container::value_type&lt;/code&gt;.(since C++17)</source>
          <target state="translated">El tipo de los elementos almacenados. El comportamiento no est&amp;aacute; definido si &lt;code&gt;T&lt;/code&gt; no es del mismo tipo que &lt;code&gt;Container::value_type&lt;/code&gt; . (Desde C ++ 17)</target>
        </trans-unit>
        <trans-unit id="1cefc4c9c8c79e1f5ffc310e3b76ce47f7f95b53" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;, and its iterators must satisfy the requirements of &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">El tipo de contenedor subyacente que se utilizar&amp;aacute; para almacenar los elementos. El contenedor debe satisfacer los requisitos de &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; y sus iteradores deben cumplir los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; . Adem&amp;aacute;s, debe proporcionar las siguientes funciones con la sem&amp;aacute;ntica habitual:</target>
        </trans-unit>
        <trans-unit id="42baf44de229b353e2dc10d945c14ad4f7f1e2dd" translate="yes" xml:space="preserve">
          <source>The type of the underlying container to use to store the elements. The container must satisfy the requirements of &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt;. Additionally, it must provide the following functions with the usual semantics:</source>
          <target state="translated">El tipo de contenedor subyacente que se utilizar&amp;aacute; para almacenar los elementos. El contenedor debe cumplir los requisitos de &lt;a href=&quot;../named_req/sequencecontainer&quot;&gt;SequenceContainer&lt;/a&gt; . Adem&amp;aacute;s, debe proporcionar las siguientes funciones con la sem&amp;aacute;ntica habitual:</target>
        </trans-unit>
        <trans-unit id="4b1400789f4da2eef8d9f804a8241c3f62471b09" translate="yes" xml:space="preserve">
          <source>The type produced when specializing an alias template is not allowed to directly or indirectly make use of its own type:</source>
          <target state="translated">El tipo producido al especializar una plantilla de alias no puede hacer uso,directa o indirectamente,de su propio tipo:</target>
        </trans-unit>
        <trans-unit id="447849d54c1d67d6b61329201208de7c3155cd27" translate="yes" xml:space="preserve">
          <source>The type representing all floating-point status flags collectively</source>
          <target state="translated">El tipo que representa todas las banderas de estado de punto flotante colectivamente</target>
        </trans-unit>
        <trans-unit id="66cad8bd68a6349c324c8b818f25bd23910481f3" translate="yes" xml:space="preserve">
          <source>The type representing the entire floating-point environment</source>
          <target state="translated">El tipo que representa todo el entorno de punto flotante</target>
        </trans-unit>
        <trans-unit id="e0d3b983420a08441dc26163e85fa14573af6da4" translate="yes" xml:space="preserve">
          <source>The type trait template &lt;code&gt;regex_traits&lt;/code&gt; supplies &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with the set of types and functions necessary to operate on the type &lt;code&gt;CharT&lt;/code&gt;.</source>
          <target state="translated">La plantilla de rasgos de tipo &lt;code&gt;regex_traits&lt;/code&gt; proporciona &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; con el conjunto de tipos y funciones necesarias para operar en el tipo &lt;code&gt;CharT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7ff3701335c6b61f893828424d0d4397e6f94e7" translate="yes" xml:space="preserve">
          <source>The type, value, and value category of the result of the comma expression are exactly the type, value, and value category of the second operand, &lt;code&gt;E2&lt;/code&gt;. If &lt;code&gt;E2&lt;/code&gt; is a temporary expression(since C++17), the result of the expression is that temporary expression(since C++17). If &lt;code&gt;E2&lt;/code&gt; is a bit-field, the result is a bit-field.</source>
          <target state="translated">El tipo, el valor y la categor&amp;iacute;a de valor del resultado de la expresi&amp;oacute;n de coma son exactamente el tipo, el valor y la categor&amp;iacute;a de valor del segundo operando, &lt;code&gt;E2&lt;/code&gt; . Si &lt;code&gt;E2&lt;/code&gt; es una expresi&amp;oacute;n temporal (desde C ++ 17), el resultado de la expresi&amp;oacute;n es esa expresi&amp;oacute;n temporal (desde C ++ 17). Si &lt;code&gt;E2&lt;/code&gt; es un campo de bits, el resultado es un campo de bits.</target>
        </trans-unit>
        <trans-unit id="201b401441e563392e93db134426f0b5823a14fe" translate="yes" xml:space="preserve">
          <source>The type-based overloads (5-12) fail to compile if the types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;U&lt;/code&gt; are the same.</source>
          <target state="translated">Las sobrecargas basadas en tipos (5-12) no se compilan si los tipos &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;U&lt;/code&gt; son iguales.</target>
        </trans-unit>
        <trans-unit id="a8ad5442d02de3fb2204cec5285533422e5d8a60" translate="yes" xml:space="preserve">
          <source>The typedef-names are aliases for existing types, and are not declarations of new types. Typedef cannot be used to change the meaning of an existing type name (including a typedef-name). Once declared, a typedef-name may only be redeclared to refer to the same type again. Typedef names are only in effect in the scope where they are visible: different functions or class declarations may define identically-named types with different meaning.</source>
          <target state="translated">Los nombres mecanografiados son alias de tipos existentes,y no son declaraciones de nuevos tipos.Typedef no puede utilizarse para cambiar el significado de un nombre de tipo existente (incluido un nombre de tipedef).Una vez declarado,un typedef-name sólo puede ser redeclarado para referirse nuevamente al mismo tipo.Los nombres de tipedef sólo tienen efecto en el ámbito en que son visibles:las diferentes funciones o declaraciones de clase pueden definir tipos de nombre idéntico con un significado diferente.</target>
        </trans-unit>
        <trans-unit id="208a0dcd155f30aca58e4747af4e8c084fcc2a94" translate="yes" xml:space="preserve">
          <source>The typeid expression is an &lt;a href=&quot;value_category&quot;&gt;lvalue expression&lt;/a&gt; which refers to an object with &lt;a href=&quot;static&quot;&gt;static storage duration&lt;/a&gt;, of the polymorphic type &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; or of some type derived from it.</source>
          <target state="translated">La expresi&amp;oacute;n typeid es una &lt;a href=&quot;value_category&quot;&gt;expresi&amp;oacute;n lvalue&lt;/a&gt; que se refiere a un objeto con &lt;a href=&quot;static&quot;&gt;una duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico&lt;/a&gt; , del tipo polim&amp;oacute;rfico &lt;code&gt;const &lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; o de alg&amp;uacute;n tipo derivada de ella.</target>
        </trans-unit>
        <trans-unit id="7e208b7b23417d25a7cf6cca148a35ee8446742b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;TC::rep&lt;/code&gt;, &lt;code&gt;TC::duration&lt;/code&gt;, and &lt;code&gt;TC::time_point&lt;/code&gt; satisfy the requirements of &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt;, &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;, &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;, &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt;, and &lt;a href=&quot;numerictype&quot;&gt;NumericType&lt;/a&gt;.</source>
          <target state="translated">Los tipos &lt;code&gt;TC::rep&lt;/code&gt; , &lt;code&gt;TC::duration&lt;/code&gt; y &lt;code&gt;TC::time_point&lt;/code&gt; satisfacen los requisitos de &lt;a href=&quot;equalitycomparable&quot;&gt;EqualityComparable&lt;/a&gt; , &lt;a href=&quot;lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; , &lt;a href=&quot;defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , &lt;a href=&quot;copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; , &lt;a href=&quot;destructible&quot;&gt;Destructible&lt;/a&gt; y &lt;a href=&quot;numerictype&quot;&gt;NumericType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="61760bebb6411fc7a1b89f4a6a4d2b47b837a78f" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;BidirIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que un objeto de tipo &lt;code&gt;BidirIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente en ambos.</target>
        </trans-unit>
        <trans-unit id="10efac4cd9ec3d4ae0fd700440a7ab91e4529fc8" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que un objeto de tipo &lt;code&gt;ForwardIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a ambos.</target>
        </trans-unit>
        <trans-unit id="cfb5cffb02876fdfc335e83f9d620b313612c1b0" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;InputIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que un objeto de tipo &lt;code&gt;InputIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a ambos.</target>
        </trans-unit>
        <trans-unit id="3c179ed315abab6c17ee556701b26c5d282772f2" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;RandomIt&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que un objeto de tipo &lt;code&gt;RandomIt&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente en ambos.</target>
        </trans-unit>
        <trans-unit id="193be796c5e76cc692dcacf4d03a9c74c36dcc11" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;, and an object of type &lt;code&gt;ForwardIt&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que un objeto de tipo &lt;code&gt;T&lt;/code&gt; se pueda convertir impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; , y un objeto de tipo &lt;code&gt;ForwardIt&lt;/code&gt; se pueda desreferenciar y luego se convierta impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4447fe84d3b9ebfd730e495965e02d0c7f2a157" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be implicitly converted to both of them. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que un objeto de tipo &lt;code&gt;T&lt;/code&gt; se pueda convertir impl&amp;iacute;citamente en ambos.</target>
        </trans-unit>
        <trans-unit id="55aca5b917e7d46505eef0c5864d5092e23045de" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que un objeto de tipo &lt;code&gt;forward_list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; pueda ser desreferenciado y luego convertido impl&amp;iacute;citamente a ambos.</target>
        </trans-unit>
        <trans-unit id="c2c308d3a55373567a39aa9cf81fb0182d8c2878" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; can be implicitly converted to both of them. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que un objeto de tipo &lt;code&gt;iterator_traits&amp;lt;InputIt&amp;gt;::value_type&lt;/code&gt; pueda convertirse impl&amp;iacute;citamente en ambos. El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;OutputIt&lt;/code&gt; pueda ser desreferenciado y se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86218894e5a217ad2ba71c5d5b88c13c7c91af26" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that an object of type &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; can be dereferenced and then implicitly converted to both of them. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que un objeto de la &lt;code&gt;list&amp;lt;T,Allocator&amp;gt;::const_iterator&lt;/code&gt; de tipos &amp;lt;T, Allocator&amp;gt; :: const_iterator se pueda desreferenciar y luego convertir impl&amp;iacute;citamente a ambos.</target>
        </trans-unit>
        <trans-unit id="255e7b7cb8a9a07dcebb8ff409c528b78435bb0c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;ForwardIt1&lt;/code&gt; and &lt;code&gt;ForwardIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que los objetos de los tipos &lt;code&gt;ForwardIt1&lt;/code&gt; y &lt;code&gt;ForwardIt2&lt;/code&gt; puedan desreferenciarse y luego convertirse impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="8bf40db03397e57c92c014d425524b6be371768c" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;OutputIt&lt;/code&gt; can be dereferenced and assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que los objetos de los tipos &lt;code&gt;InputIt1&lt;/code&gt; y &lt;code&gt;InputIt2&lt;/code&gt; puedan ser desreferenciados y luego convertidos impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; respectivamente. El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que un objeto de tipo &lt;code&gt;OutputIt&lt;/code&gt; pueda ser desreferenciado y se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea66afd749f321b8a7fbd2dfec0b25993b20d429" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;Type3&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que los objetos de los tipos &lt;code&gt;InputIt1&lt;/code&gt; y &lt;code&gt;InputIt2&lt;/code&gt; puedan ser desreferenciados y luego convertidos impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; respectivamente. El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que a un objeto de tipo &lt;code&gt;Type3&lt;/code&gt; se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="697ca99a8e5d22b550dc1162bfdf3113cb87ca5b" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que los objetos de los tipos &lt;code&gt;InputIt1&lt;/code&gt; y &lt;code&gt;InputIt2&lt;/code&gt; puedan ser desreferenciados y luego convertidos impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="c5097f11a8110609e26afb57ed62da129a5503cf" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;InputIt1&lt;/code&gt; and &lt;code&gt;InputIt2&lt;/code&gt; can be dereferenced and then implicitly converted to both &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt;. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que los objetos de los tipos &lt;code&gt;InputIt1&lt;/code&gt; y &lt;code&gt;InputIt2&lt;/code&gt; puedan desreferenciarse y luego convertirse impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c30caab1908aa629ad3fea15c152763576c8875" translate="yes" xml:space="preserve">
          <source>The types &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; must be such that objects of types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;Type3&lt;/code&gt; can be implicitly converted to &lt;code&gt;Type1&lt;/code&gt; and &lt;code&gt;Type2&lt;/code&gt; respectively. The type &lt;code&gt;Ret&lt;/code&gt; must be such that an object of type &lt;code&gt;T&lt;/code&gt; can be assigned a value of type &lt;code&gt;Ret&lt;/code&gt;. ​</source>
          <target state="translated">Los tipos &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; deben ser tales que los objetos de los tipos &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;Type3&lt;/code&gt; se puedan convertir impl&amp;iacute;citamente en &lt;code&gt;Type1&lt;/code&gt; y &lt;code&gt;Type2&lt;/code&gt; respectivamente. El tipo &lt;code&gt;Ret&lt;/code&gt; debe ser tal que a un objeto de tipo &lt;code&gt;T&lt;/code&gt; se le pueda asignar un valor de tipo &lt;code&gt;Ret&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50e24e2bc41cc279e1a3c9515fef0b78775237a9" translate="yes" xml:space="preserve">
          <source>The types in the parameter pack &lt;code&gt;T&lt;/code&gt; shall each be a complete type, (possibly cv-qualified) &lt;code&gt;void&lt;/code&gt;, or an array of unknown bound. Otherwise, the behavior is undefined.</source>
          <target state="translated">Los tipos en el paquete de par&amp;aacute;metros &lt;code&gt;T&lt;/code&gt; ser&amp;aacute;n cada uno un tipo completo, (posiblemente calificado por cv) &lt;code&gt;void&lt;/code&gt; , o una matriz de l&amp;iacute;mite desconocido. De lo contrario, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="fa81b9c4cb4ce5f942c1234f0bfa8aee24861f94" translate="yes" xml:space="preserve">
          <source>The types of the placeholder objects are &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt;, their default copy/move constructors do not throw exceptions, and for any placeholder &lt;code&gt;_N&lt;/code&gt;, the type &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; is defined and is derived from &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Los tipos de los objetos de marcador de posici&amp;oacute;n son &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; y &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; , sus constructores de copia / movimiento predeterminados no arrojan excepciones, y para cualquier marcador de posici&amp;oacute;n &lt;code&gt;_N&lt;/code&gt; , el tipo &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;decltype(_N)&amp;gt;&lt;/code&gt; est&amp;aacute; definido y se deriva de &lt;code&gt;&lt;a href=&quot;../../types/integral_constant&quot;&gt;std::integral_constant&lt;/a&gt;&amp;lt;int, N&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75478ba3404fb0cfdef1c92955897a42cd9e34cf" translate="yes" xml:space="preserve">
          <source>The types used to determine the order depend on the context:</source>
          <target state="translated">Los tipos utilizados para determinar el orden dependen del contexto:</target>
        </trans-unit>
        <trans-unit id="81e4b2422bd4fd5cd5d02082af7aa37f47bd2430" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;istrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n t&amp;iacute;pica de &lt;code&gt;istrstream&lt;/code&gt; contiene solo un miembro de datos no derivado: un objeto de tipo &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48a376de82dbe48c2684a6707ba9148135410249" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;ostrstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n t&amp;iacute;pica de &lt;code&gt;ostrstream&lt;/code&gt; contiene solo un miembro de datos no derivado: un objeto de tipo &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4926fe384c3bbd6e8ecfe4635962d969889b9270" translate="yes" xml:space="preserve">
          <source>The typical implementation of &lt;code&gt;strstream&lt;/code&gt; holds only one non-derived data member: an object of type &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La implementaci&amp;oacute;n t&amp;iacute;pica de &lt;code&gt;strstream&lt;/code&gt; contiene solo un miembro de datos no derivado: un objeto de tipo &lt;code&gt;&lt;a href=&quot;strstreambuf&quot;&gt;std::strstreambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b6e26a516b34b7af57fc7012be60e25328df076" translate="yes" xml:space="preserve">
          <source>The unary arithmetic operator expressions have the form.</source>
          <target state="translated">Las expresiones del operador aritmético unario tienen la forma.</target>
        </trans-unit>
        <trans-unit id="b22b858c0fd42effe64ef379a02aba7e1e499dac" translate="yes" xml:space="preserve">
          <source>The unary operator &lt;code&gt;co_await&lt;/code&gt; suspends a coroutine and returns control to the caller. Its operand is an expression whose type must either define &lt;code&gt;operator co_await&lt;/code&gt;, or be convertible to such type by means of the current coroutine's &lt;code&gt;Promise::await_transform&lt;/code&gt;.</source>
          <target state="translated">El operador unario &lt;code&gt;co_await&lt;/code&gt; suspende una rutina y devuelve el control a la persona que llama. Su operando es una expresi&amp;oacute;n cuyo tipo debe definir el &lt;code&gt;operator co_await&lt;/code&gt; , o ser convertible a ese tipo por medio de la promesa actual de la rutina &lt;code&gt;Promise::await_transform&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36a5614de76d4b58b628c43d48b3afb8e58937c2" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo de predicado unario debe definir un tipo de miembro, &lt;code&gt;argument_type&lt;/code&gt; , que sea convertible al tipo de par&amp;aacute;metro del predicado. La funci&amp;oacute;n unaria objetos obtenidos a partir &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; , o de otra llamada a &lt;code&gt;&lt;a href=&quot;not1&quot;&gt;std::not1&lt;/a&gt;&lt;/code&gt; tener este tipo definido, al igual que los objetos de funci&amp;oacute;n derivados de &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; desuso .</target>
        </trans-unit>
        <trans-unit id="7c177ac717f26cdcf71092d833a69d98891213b9" translate="yes" xml:space="preserve">
          <source>The unary predicate type must define a member type, &lt;code&gt;argument_type&lt;/code&gt;, that is convertible to the predicate's parameter type. The unary function objects obtained from &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt;, or from another call to &lt;code&gt;std::not1&lt;/code&gt; have this type defined, as are function objects derived from the deprecated &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El tipo de predicado unario debe definir un tipo de miembro, &lt;code&gt;argument_type&lt;/code&gt; , que sea convertible al tipo de par&amp;aacute;metro del predicado. La funci&amp;oacute;n unaria objetos obtenidos a partir &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;negate&quot;&gt;std::negate&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;logical_not&quot;&gt;std::logical_not&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../hash&quot;&gt;std::hash&lt;/a&gt;&lt;/code&gt; , o de otra llamada a &lt;code&gt;std::not1&lt;/code&gt; tener este tipo definido, al igual que los objetos de funci&amp;oacute;n derivados de &lt;code&gt;&lt;a href=&quot;unary_function&quot;&gt;std::unary_function&lt;/a&gt;&lt;/code&gt; desuso .</target>
        </trans-unit>
        <trans-unit id="9a8868abcc7899aa017c841a57e1f892c57cdec6" translate="yes" xml:space="preserve">
          <source>The underlying array is a &lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;temporary&lt;/a&gt; array of type &lt;code&gt;const T[N]&lt;/code&gt;, in which each element is &lt;a href=&quot;../language/copy_initialization&quot;&gt;copy-initialized&lt;/a&gt; (except that narrowing conversions are invalid) from the corresponding element of the original initializer list. The lifetime of the underlying array is the same as any other &lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;temporary object&lt;/a&gt;, except that initializing an initializer_list object from the array extends the lifetime of the array exactly like &lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;binding a reference to a temporary&lt;/a&gt; (with the same exceptions, such as for initializing a non-static class member). The underlying array may be allocated in read-only memory.</source>
          <target state="translated">La matriz subyacente es una matriz &lt;a href=&quot;../language/implicit_cast#Temporary_materialization&quot;&gt;temporal&lt;/a&gt; de tipo &lt;code&gt;const T[N]&lt;/code&gt; , en la que cada elemento se &lt;a href=&quot;../language/copy_initialization&quot;&gt;inicializa por copia&lt;/a&gt; (excepto que las conversiones de estrechamiento no son v&amp;aacute;lidas) del elemento correspondiente de la lista inicializadora original. La vida &amp;uacute;til de la matriz subyacente es la misma que la de cualquier otro &lt;a href=&quot;../language/lifetime#Temporary_object_lifetime&quot;&gt;objeto temporal&lt;/a&gt; , excepto que la inicializaci&amp;oacute;n de un objeto initializer_list de la matriz extiende la vida &amp;uacute;til de la matriz exactamente como &lt;a href=&quot;../language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;vincular una referencia a una temporal&lt;/a&gt; (con las mismas excepciones, como para inicializar un objeto no miembro de clase est&amp;aacute;tica). La matriz subyacente puede asignarse en memoria de solo lectura.</target>
        </trans-unit>
        <trans-unit id="4eb3a7f051a86b23a775a499c1446a22117e43f7" translate="yes" xml:space="preserve">
          <source>The underlying array is not guaranteed to exist after the lifetime of the original initializer list object has ended. The storage for &lt;code&gt;std::initializer_list&lt;/code&gt; is unspecified (i.e. it could be automatic, temporary, or static read-only memory, depending on the situation).</source>
          <target state="translated">No se garantiza que la matriz subyacente exista una vez finalizada la vida &amp;uacute;til del objeto original de la lista de inicializadores. El almacenamiento para &lt;code&gt;std::initializer_list&lt;/code&gt; no est&amp;aacute; especificado (es decir, podr&amp;iacute;a ser memoria de solo lectura autom&amp;aacute;tica, temporal o est&amp;aacute;tica, seg&amp;uacute;n la situaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="7eadf4d50d87bb977c930c01738a9f8d29a30fb0" translate="yes" xml:space="preserve">
          <source>The underlying engine.</source>
          <target state="translated">El motor subyacente.</target>
        </trans-unit>
        <trans-unit id="97e77189c09808726f0123e32d74be4afcdbd112" translate="yes" xml:space="preserve">
          <source>The underlying iterator is assigned the value of the underlying iterator of &lt;code&gt;other&lt;/code&gt;, i.e. &lt;code&gt;other.base()&lt;/code&gt;.</source>
          <target state="translated">Al iterador subyacente se le asigna el valor del iterador subyacente de &lt;code&gt;other&lt;/code&gt; , es decir, &lt;code&gt;other.base()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b646602f4defaa19568e9e4e03c04b49576b8ef7" translate="yes" xml:space="preserve">
          <source>The underlying iterator.</source>
          <target state="translated">El iterador subyacente.</target>
        </trans-unit>
        <trans-unit id="79cf0218a59dc2d4dbf82fe2261c98e6c65758c3" translate="yes" xml:space="preserve">
          <source>The unevaluated operands are considered to be</source>
          <target state="translated">Los operandos no evaluados se consideran</target>
        </trans-unit>
        <trans-unit id="979a12b00a42a8fc276019493ceedcb85eb1918e" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt; if they fails to extract any characters.</source>
          <target state="translated">Las funciones de entrada sin formato &lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt; si no pueden extraer ning&amp;uacute;n car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="abe9991ee5e0486321d659e85ed0325fe1bbb797" translate="yes" xml:space="preserve">
          <source>The unformatted input functions &lt;a href=&quot;../basic_istream/read&quot;&gt;&lt;code&gt;basic_istream::read&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;basic_istream::get&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;../basic_istream/peek&quot;&gt;&lt;code&gt;basic_istream::peek&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;../basic_istream/getline&quot;&gt;&lt;code&gt;basic_istream::getline&lt;/code&gt;&lt;/a&gt;, when reaching the end of the stream.</source>
          <target state="translated">Las funciones de entrada sin formato &lt;a href=&quot;../basic_istream/read&quot;&gt; &lt;code&gt;basic_istream::read&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;basic_istream::get&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;../basic_istream/peek&quot;&gt; &lt;code&gt;basic_istream::peek&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../basic_istream/getline&quot;&gt; &lt;code&gt;basic_istream::getline&lt;/code&gt; &lt;/a&gt; , al llegar al final de la secuencia.</target>
        </trans-unit>
        <trans-unit id="e384fd665d52aa51e3748fff4ef48a28e7937c70" translate="yes" xml:space="preserve">
          <source>The union is only as big as necessary to hold its largest data member. The other data members are allocated in the same bytes as part of that largest member. The details of that allocation are implementation-defined, and it's undefined behavior to read from the member of the union that wasn't most recently written. Many compilers implement, as a non-standard language extension, the ability to read inactive members of a union.</source>
          <target state="translated">El sindicato es sólo tan grande como sea necesario para mantener a su mayor miembro de datos.Los demás miembros de datos se asignan en los mismos bytes como parte de ese miembro más grande.Los detalles de esa asignación están definidos por la implementación,y es un comportamiento indefinido leer del miembro de la unión que no fue escrito más recientemente.Muchos compiladores implementan,como una extensión de lenguaje no estándar,la capacidad de leer a los miembros inactivos de un sindicato.</target>
        </trans-unit>
        <trans-unit id="e952952a6e837db3083d43ddef77a18d33df5f91" translate="yes" xml:space="preserve">
          <source>The unordered associative containers &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; use specializations of the template &lt;code&gt;std::hash&lt;/code&gt; as the default hash function.</source>
          <target state="translated">Los contenedores asociativos desordenados &lt;code&gt;&lt;a href=&quot;../container/unordered_set&quot;&gt;std::unordered_set&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_multiset&quot;&gt;std::unordered_multiset&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_map&quot;&gt;std::unordered_map&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../container/unordered_multimap&quot;&gt;std::unordered_multimap&lt;/a&gt;&lt;/code&gt; utilizan especializaciones de la plantilla &lt;code&gt;std::hash&lt;/code&gt; como la funci&amp;oacute;n hash predeterminada.</target>
        </trans-unit>
        <trans-unit id="fb9ee6c51de186554c2e06f60fe8377ba45da283" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; in which the elements are sorted in ascending order. That is, the last iterator &lt;code&gt;it&lt;/code&gt; for which range &lt;code&gt;[first, it)&lt;/code&gt; is sorted.</source>
          <target state="translated">El l&amp;iacute;mite superior del rango m&amp;aacute;s grande comienza al &lt;code&gt;first&lt;/code&gt; en el que los elementos se ordenan en orden ascendente. Es decir, el &amp;uacute;ltimo iterador &lt;code&gt;it&lt;/code&gt; para los que cubre la &lt;code&gt;[first, it)&lt;/code&gt; est&amp;aacute; ordenada.</target>
        </trans-unit>
        <trans-unit id="153cc2e9c85ca94fbb56ca3af1786c3042753255" translate="yes" xml:space="preserve">
          <source>The upper bound of the largest range beginning at &lt;code&gt;first&lt;/code&gt; which is a</source>
          <target state="translated">El l&amp;iacute;mite superior del rango m&amp;aacute;s grande que comienza al &lt;code&gt;first&lt;/code&gt; que es un</target>
        </trans-unit>
        <trans-unit id="0a7c6b2e95b8914f758d75e392b6d55f793089e4" translate="yes" xml:space="preserve">
          <source>The use of the class key &lt;code&gt;union&lt;/code&gt; results in a &lt;a href=&quot;union&quot;&gt;union definition&lt;/a&gt;, which defines a class that holds only one of its data members at a time.</source>
          <target state="translated">El uso de la &lt;code&gt;union&lt;/code&gt; clave de clase da como resultado una &lt;a href=&quot;union&quot;&gt;definici&amp;oacute;n de uni&amp;oacute;n&lt;/a&gt; , que define una clase que contiene solo uno de sus miembros de datos a la vez.</target>
        </trans-unit>
        <trans-unit id="7c930b3ae6f3ca4c4f3a29eb336a3a8321980de8" translate="yes" xml:space="preserve">
          <source>The user-defined callback function is not allowed to throw exceptions.</source>
          <target state="translated">La función de devolución de llamada definida por el usuario no puede lanzar excepciones.</target>
        </trans-unit>
        <trans-unit id="7440e695d7d2b47e772a3f0ba0922c8f1015cfd1" translate="yes" xml:space="preserve">
          <source>The user-defined conversion functions are considered to be members of the</source>
          <target state="translated">Las funciones de conversión definidas por el usuario se consideran miembros de la</target>
        </trans-unit>
        <trans-unit id="a2449ea9418355b1634632974372ad5423959cfe" translate="yes" xml:space="preserve">
          <source>The using-directive &lt;code&gt;using namespace std;&lt;/code&gt; at any namespace scope introduces every name from the namespace &lt;code&gt;std&lt;/code&gt; into the global namespace (since the global namespace is the nearest namespace that contains both &lt;code&gt;std&lt;/code&gt; and any user-declared namespace), which may lead to undesirable name collisions. This, and other using directives are generally considered bad practice at file scope of a header file.</source>
          <target state="translated">La directiva &lt;code&gt;using namespace std;&lt;/code&gt; en cualquier &amp;aacute;mbito de espacio de nombres, se introducen todos los nombres del espacio de nombres &lt;code&gt;std&lt;/code&gt; en el espacio de nombres global (dado que el espacio de nombres global es el espacio de nombres m&amp;aacute;s cercano que contiene tanto &lt;code&gt;std&lt;/code&gt; como cualquier espacio de nombres declarado por el usuario), lo que puede provocar colisiones de nombres indeseables. Esta y otras directivas de uso generalmente se consideran una mala pr&amp;aacute;ctica en el &amp;aacute;mbito de un archivo de encabezado.</target>
        </trans-unit>
        <trans-unit id="a0a29bcf7f924ca3c9afb16892af9ad80008618f" translate="yes" xml:space="preserve">
          <source>The usual rules for reference-binding to temporaries (including lifetime-extension) apply if a ref-operator is present and the expression is a prvalue. In those cases the hidden variable &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a reference that binds to the temporary variable &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from the prvalue expression, extending its lifetime. As usual, the binding will fail if &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is a non-const lvalue reference:</source>
          <target state="translated">Las reglas habituales para el enlace de referencia a temporarios (incluida la extensi&amp;oacute;n de por vida) se aplican si hay un operador de referencia y la expresi&amp;oacute;n es un valor. En esos casos, la variable oculta &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; es una referencia que se une a la variable temporal &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializada a&lt;/a&gt; partir de la expresi&amp;oacute;n prvalue, extendiendo su vida &amp;uacute;til. Como de costumbre, el enlace fallar&amp;aacute; si &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; es una referencia de valor no constante:</target>
        </trans-unit>
        <trans-unit id="d143db4cb73d031e48783561f534e5977a6951dc" translate="yes" xml:space="preserve">
          <source>The utility functions &lt;code&gt;std::make_obj_using_allocator&lt;/code&gt;, and &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; may be used to explicitly create an object following the above protocol, and &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; can be used to prepare the argument list that matches the flavor of uses-allocator construction expected by the type.</source>
          <target state="translated">Las funciones de utilidad &lt;code&gt;std::make_obj_using_allocator&lt;/code&gt; , y &lt;code&gt;std::uninitialized_construct_using_allocator&lt;/code&gt; se pueden usar para crear expl&amp;iacute;citamente un objeto siguiendo el protocolo anterior, y &lt;code&gt;std::uses_allocator_construction_args&lt;/code&gt; se pueden usar para preparar la lista de argumentos que coincide con el sabor de la construcci&amp;oacute;n de los usos-asignador esperado por el tipo.</target>
        </trans-unit>
        <trans-unit id="fe1efdbf774195a43f57a666949496b9864e4331" translate="yes" xml:space="preserve">
          <source>The valid values (inherited from &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt;) are:</source>
          <target state="translated">Los valores v&amp;aacute;lidos (heredados de &lt;code&gt;&lt;a href=&quot;../time_base&quot;&gt;std::time_base&lt;/a&gt;&lt;/code&gt; ) son:</target>
        </trans-unit>
        <trans-unit id="ea8585806be7732f5b1559533a0afabee4e31468" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;false&lt;/code&gt; (the default) indicates that any flush will be postponed until a call to emit.</source>
          <target state="translated">El valor &lt;code&gt;false&lt;/code&gt; (el valor predeterminado) indica que cualquier descarga se pospondr&amp;aacute; hasta que se emita una llamada.</target>
        </trans-unit>
        <trans-unit id="bec74bfd762b8f94824661d08795516a39875971" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;std::codecvt_base::partial&lt;/code&gt; is used to indicate that either the destination range is too short to receive the results of the conversion or the input is truncated in the middle of an otherwise valid multibyte character.</source>
          <target state="translated">El valor &lt;code&gt;std::codecvt_base::partial&lt;/code&gt; se usa para indicar que el rango de destino es demasiado corto para recibir los resultados de la conversi&amp;oacute;n o que la entrada se trunca en medio de un car&amp;aacute;cter multibyte v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="b59da2ec2014ac9c518b1aadf220e6d3e58b2e01" translate="yes" xml:space="preserve">
          <source>The value &lt;code&gt;true&lt;/code&gt; makes flushes apply immediately.</source>
          <target state="translated">El valor &lt;code&gt;true&lt;/code&gt; hace que los enjuagues se apliquen inmediatamente.</target>
        </trans-unit>
        <trans-unit id="b297662cf0a9d877fef1ea088b887dc762885510" translate="yes" xml:space="preserve">
          <source>The value category of a function call expression is lvalue if the function returns an lvalue reference or an rvalue reference to function, is an xvalue if the function returns an rvalue reference to object, and is a prvalue otherwise. If the function call expression is a prvalue of object type, it must have complete type except when the prvalue is not materialized, such as(since C++17) when used as the operand of &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; (or as the right operand of a &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;built-in comma operator expression&lt;/a&gt; that is the operand of &lt;code&gt;decltype&lt;/code&gt;).</source>
          <target state="translated">La categor&amp;iacute;a de valor de una expresi&amp;oacute;n de llamada de funci&amp;oacute;n es lvalue si la funci&amp;oacute;n devuelve una referencia de lvalue o una referencia de rvalue a function, es un xvalue si la funci&amp;oacute;n devuelve una referencia de rvalue a objeto, y de lo contrario es un prvalue. Si la expresi&amp;oacute;n de llamada de funci&amp;oacute;n es un prvalue de tipo de objeto, debe tener un tipo completo excepto cuando el prvalue no se materializa, como (desde C ++ 17) cuando se usa como el operando de &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; (o como el operando correcto de un objeto &lt;a href=&quot;operator_other#Built-in_comma_operator&quot;&gt;construido) -en la expresi&amp;oacute;n del operador de coma&lt;/a&gt; que es el operando de &lt;code&gt;decltype&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="67e47b55490dd997d102458418a048c6890cf272" translate="yes" xml:space="preserve">
          <source>The value comparison function object.</source>
          <target state="translated">El objeto de la función de comparación de valores.</target>
        </trans-unit>
        <trans-unit id="e3315b1caebdb1fc309be2d0ec78502282dc56fc" translate="yes" xml:space="preserve">
          <source>The value computed by the three-argument version of this function is the distance of the point &lt;code&gt;(x,y,z)&lt;/code&gt; from the origin &lt;code&gt;(0,0,0)&lt;/code&gt;.</source>
          <target state="translated">El valor calculado por la versi&amp;oacute;n de tres argumentos de esta funci&amp;oacute;n es la distancia del punto &lt;code&gt;(x,y,z)&lt;/code&gt; desde el origen &lt;code&gt;(0,0,0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f316342cf5de6fdab5febb1bc73226832477d458" translate="yes" xml:space="preserve">
          <source>The value computed by the two-argument version of this function is the length of the hypotenuse of a right-angled triangle with sides of length &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, or the distance of the point &lt;code&gt;(x,y)&lt;/code&gt; from the origin &lt;code&gt;(0,0)&lt;/code&gt;, or the magnitude of a complex number &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt;.</source>
          <target state="translated">El valor calculado por la versi&amp;oacute;n de dos argumentos de esta funci&amp;oacute;n es la longitud de la hipotenusa de un tri&amp;aacute;ngulo rect&amp;aacute;ngulo con lados de longitud &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; , o la distancia del punto &lt;code&gt;(x,y)&lt;/code&gt; desde el origen &lt;code&gt;(0,0)&lt;/code&gt; , o la magnitud de un n&amp;uacute;mero complejo &lt;code&gt;x+&lt;i&gt;i&lt;/i&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7044fe5027fd6004978c59ea869f2af588568b11" translate="yes" xml:space="preserve">
          <source>The value held previously by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">El valor mantenido anteriormente por el objeto at&amp;oacute;mico al que apunta &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b53ba13c1b7ad772fd50ae6d7f505fae71221a4" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">El valor que precede inmediatamente a los efectos de esta funci&amp;oacute;n en el &lt;a href=&quot;../memory_order#Modification_order&quot;&gt;orden&lt;/a&gt; de modificaci&amp;oacute;n de &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21ba436ae4d60c1b3df6f313a5e847a739f28e04" translate="yes" xml:space="preserve">
          <source>The value immediately preceding the effects of this function in the &lt;a href=&quot;memory_order#Modification_order&quot;&gt;modification order&lt;/a&gt; of &lt;code&gt;*obj&lt;/code&gt;.</source>
          <target state="translated">El valor que precede inmediatamente a los efectos de esta funci&amp;oacute;n en el &lt;a href=&quot;memory_order#Modification_order&quot;&gt;orden&lt;/a&gt; de modificaci&amp;oacute;n de &lt;code&gt;*obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ad12bc074bf532e8969a9847c8c0936a889cc81" translate="yes" xml:space="preserve">
          <source>The value obtained is the number of successes in a sequence of t yes/no experiments, each of which succeeds with probability p.</source>
          <target state="translated">El valor obtenido es el número de éxitos en una secuencia de experimentos t sí/no,cada uno de los cuales tiene éxito con probabilidad p.</target>
        </trans-unit>
        <trans-unit id="33a4fa47add8b297d431d6dce6cb94e9aeac4af7" translate="yes" xml:space="preserve">
          <source>The value obtained is the probability of exactly i occurrences of a random event if the expected,</source>
          <target state="translated">El valor obtenido es la probabilidad de exactamente i ocurrencias de un evento aleatorio si el esperado,</target>
        </trans-unit>
        <trans-unit id="873f84075d8ee3fa467aeba44e733298e1a32864" translate="yes" xml:space="preserve">
          <source>The value obtained is the time/distance until the next random event if random events occur at constant rate &amp;lambda; per unit of time/distance. For example, this distribution describes the time between the clicks of a Geiger counter or the distance between point mutations in a DNA strand.</source>
          <target state="translated">El valor obtenido es el tiempo / distancia hasta el pr&amp;oacute;ximo evento aleatorio si ocurren eventos aleatorios a una tasa constante &amp;lambda; por unidad de tiempo / distancia. Por ejemplo, esta distribuci&amp;oacute;n describe el tiempo entre los clics de un contador Geiger o la distancia entre mutaciones puntuales en una cadena de ADN.</target>
        </trans-unit>
        <trans-unit id="baf914d043e381313277e30f951edd923276b030" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; is the number of base-10 digits that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change, that is, any number with this many significant decimal digits can be converted to a value of type &lt;code&gt;T&lt;/code&gt; and back to decimal form, without change due to rounding or overflow. For base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; types, it is the value of &lt;a href=&quot;digits&quot;&gt;digits&lt;/a&gt; (&lt;code&gt;digits-1&lt;/code&gt; for floating-point types) multiplied by log</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits10&lt;/code&gt; es el n&amp;uacute;mero de d&amp;iacute;gitos de base 10 que puede representar el tipo &lt;code&gt;T&lt;/code&gt; sin cambios, es decir, cualquier n&amp;uacute;mero con tantos d&amp;iacute;gitos decimales significativos se puede convertir a un valor de escriba &lt;code&gt;T&lt;/code&gt; y vuelva a la forma decimal, sin cambios debido al redondeo o desbordamiento. Para los tipos de base- &lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; , es el valor de los &lt;a href=&quot;digits&quot;&gt;d&amp;iacute;gitos&lt;/a&gt; ( &lt;code&gt;digits-1&lt;/code&gt; para los tipos de coma flotante) multiplicado por log</target>
        </trans-unit>
        <trans-unit id="c32d6df5f25bd1c67469d66fa412b07db9fb23e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; is the number of digits in base-&lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; that can be represented by the type &lt;code&gt;T&lt;/code&gt; without change. For integer types, this is the number of bits not counting the sign bit and the padding bits (if any). For floating-point types, this is the number of digits in the mantissa.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::digits&lt;/code&gt; es el n&amp;uacute;mero de d&amp;iacute;gitos en base- &lt;a href=&quot;radix&quot;&gt;radix&lt;/a&gt; que puede ser representado por el tipo &lt;code&gt;T&lt;/code&gt; sin cambio. Para los tipos enteros, este es el n&amp;uacute;mero de bits que no cuentan el bit de signo y los bits de relleno (si los hay). Para los tipos de punto flotante, este es el n&amp;uacute;mero de d&amp;iacute;gitos en la mantisa.</target>
        </trans-unit>
        <trans-unit id="0efce6844d5328b9d552d5e22fa416002bf69dda" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; identifies the floating-point types that support &lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;subnormal values&lt;/a&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm&lt;/code&gt; identifica los tipos de punto flotante que admiten &lt;a href=&quot;https://en.wikipedia.org/wiki/Denormal_number&quot;&gt;valores subnormales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="818565d8873864260ed4bd3755ec119254a0a789" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that detect loss of precision when creating a subnormal number as denormalization loss rather than as inexact result (see below).</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_denorm_loss&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos de coma flotante &lt;code&gt;T&lt;/code&gt; que detectan la p&amp;eacute;rdida de precisi&amp;oacute;n al crear un n&amp;uacute;mero subnormal como p&amp;eacute;rdida de desnormalizaci&amp;oacute;n en lugar de como resultado inexacto (ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="49fe53c8f4920123566acbcd270a4d7a6cb8ff5d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the positive infinity as a distinct special value. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos &lt;code&gt;T&lt;/code&gt; capaces de representar el infinito positivo como un valor especial distinto. Esta constante es significativa para todos los tipos de punto flotante y se garantiza que sea &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72efab69a379a3baec3c747ef72e6384302c8f11" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Quiet &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos &lt;code&gt;T&lt;/code&gt; capaces de representar el valor especial &quot;Quiet &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt; &quot;. Esta constante es significativa para todos los tipos de punto flotante y se garantiza que sea &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="13d78c72e37aa6610d8da4c27392455c38353258" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all types &lt;code&gt;T&lt;/code&gt; capable of representing the special value &quot;Signaling &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;Not-A-Number&lt;/a&gt;&quot;. This constant is meaningful for all floating-point types and is guaranteed to be &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos &lt;code&gt;T&lt;/code&gt; capaces de representar el valor especial &quot;Se&amp;ntilde;alizaci&amp;oacute;n &lt;a href=&quot;https://en.wikipedia.org/wiki/NaN&quot;&gt;no es un n&amp;uacute;mero&lt;/a&gt; &quot;. Esta constante es significativa para todos los tipos de punto flotante y se garantiza que sea &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559 == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f98212fab0bd1fe8a4594e818456712a7e96f5af" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that represent a finite set of values. While all fundamental types are bounded, this constant would be &lt;code&gt;false&lt;/code&gt; in a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; for a library-provided arbitrary precision arithmetic type.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_bounded&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos aritm&amp;eacute;ticos &lt;code&gt;T&lt;/code&gt; que representan un conjunto finito de valores. Si bien todos los tipos fundamentales est&amp;aacute;n acotados, esta constante ser&amp;iacute;a &lt;code&gt;false&lt;/code&gt; en una especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; para un tipo aritm&amp;eacute;tico de precisi&amp;oacute;n arbitraria proporcionado por la biblioteca.</target>
        </trans-unit>
        <trans-unit id="a3bc9c048c67471591b1728199b12d7c643bc09a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that use exact representation.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_exact&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos aritm&amp;eacute;ticos &lt;code&gt;T&lt;/code&gt; que usan representaci&amp;oacute;n exacta.</target>
        </trans-unit>
        <trans-unit id="0de1e0807da9a49f5b6ab2b0b1d4bdf3282315d4" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; which fulfill the requirements of IEC 559 (&lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt;) standard. If &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; are also &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos de coma flotante &lt;code&gt;T&lt;/code&gt; que cumplen los requisitos del est&amp;aacute;ndar IEC 559 ( &lt;a href=&quot;https://en.wikipedia.org/wiki/IEEE_754-2008&quot;&gt;IEEE 754&lt;/a&gt; ). Si &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_iec559&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_infinity&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_quiet_NaN&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::has_signaling_NaN&lt;/code&gt; tambi&amp;eacute;n lo son &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5566e2270326a63be00f7caa114991c2e742497" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all integer arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; otherwise. This constant is meaningful for all specializations.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_integer&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos aritm&amp;eacute;ticos de enteros &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; caso contrario. Esta constante es significativa para todas las especializaciones.</target>
        </trans-unit>
        <trans-unit id="658be2ec18bfcdb89b874906fd0e9a2788a963dc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that are possible to (until C++11)handle overflows with modulo arithmetic, that is, if the result of addition, subtraction, multiplication, or division of this type would fall outside the range &lt;code&gt;[min(), max()]&lt;/code&gt;, the value returned by such operation differs from the expected value by a multiple of &lt;code&gt;max()-min()+1&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_modulo&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos aritm&amp;eacute;ticos &lt;code&gt;T&lt;/code&gt; que son posibles (hasta C ++ 11) manejar desbordamientos con m&amp;oacute;dulo aritm&amp;eacute;tico, es decir, si el resultado de la suma, resta, multiplicaci&amp;oacute;n, o la divisi&amp;oacute;n de este tipo estar&amp;iacute;a fuera del rango &lt;code&gt;[min(), max()]&lt;/code&gt; , el valor devuelto por dicha operaci&amp;oacute;n difiere del valor esperado en un m&amp;uacute;ltiplo de &lt;code&gt;max()-min()+1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31c7c70df24e3cc025f30c7660467183acd0bc12" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all signed arithmetic types &lt;code&gt;T&lt;/code&gt; and &lt;code&gt;false&lt;/code&gt; for the unsigned types. This constant is meaningful for all specializations.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_signed&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos aritm&amp;eacute;ticos con signo &lt;code&gt;T&lt;/code&gt; y &lt;code&gt;false&lt;/code&gt; para los tipos sin signo. Esta constante es significativa para todas las especializaciones.</target>
        </trans-unit>
        <trans-unit id="c387cb47b15566bbeed0c9ac97ac7422cc757b9c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T&lt;/code&gt; for which there exists a specialization of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::is_specialized&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los &lt;code&gt;T&lt;/code&gt; para los que existe una especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a6c251458907976d9505f9f19b57f15d678ee8d" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; is the number of base-10 digits that are necessary to uniquely represent all distinct values of the type &lt;code&gt;T&lt;/code&gt;, such as necessary for serialization/deserialization to text. This constant is meaningful for all floating-point types.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_digits10&lt;/code&gt; es el n&amp;uacute;mero de d&amp;iacute;gitos de base 10 que son necesarios para representar de forma exclusiva todos los valores distintos del tipo &lt;code&gt;T&lt;/code&gt; , como los necesarios para la serializaci&amp;oacute;n / deserializaci&amp;oacute;n de texto. Esta constante es significativa para todos los tipos de punto flotante.</target>
        </trans-unit>
        <trans-unit id="95ede15e1ccfe9c08910652785a578f9aff770fc" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent10&lt;/code&gt; es el mayor n&amp;uacute;mero positivo &lt;code&gt;n&lt;/code&gt; tal que 10n</target>
        </trans-unit>
        <trans-unit id="4428910011b11510b83f35d9325633de507bd21f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; is the largest positive number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::max_exponent&lt;/code&gt; es el mayor n&amp;uacute;mero positivo &lt;code&gt;n&lt;/code&gt; tal que rn-1</target>
        </trans-unit>
        <trans-unit id="3a8e50309322655b0b34d76c3ee924a26b2a1631" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that 10n</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent10&lt;/code&gt; es el n&amp;uacute;mero negativo m&amp;aacute;s bajo &lt;code&gt;n&lt;/code&gt; tal que 10n</target>
        </trans-unit>
        <trans-unit id="d7d35efd9d6ad828da236c558d6eb68513df2887" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; is the lowest negative number &lt;code&gt;n&lt;/code&gt; such that rn-1</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::min_exponent&lt;/code&gt; es el n&amp;uacute;mero negativo m&amp;aacute;s bajo &lt;code&gt;n&lt;/code&gt; tal que rn-1</target>
        </trans-unit>
        <trans-unit id="67d3622bd53f05bb8c505d5f1632f3a6e465c7e7" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; is the base of the number system used in the representation of the type. It is 2 for all binary numeric types, but it may be, for example, 10 for IEEE 754 &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;decimal floating-point types&lt;/a&gt; or for third-party &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;binary-coded decimal&lt;/a&gt; integers. This constant is meaningful for all specializations.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::radix&lt;/code&gt; es la base del sistema num&amp;eacute;rico utilizado en la representaci&amp;oacute;n del tipo. Es 2 para todos los tipos num&amp;eacute;ricos binarios, pero puede ser, por ejemplo, 10 para &lt;a href=&quot;https://en.wikipedia.org/wiki/Decimal64_floating-point_format&quot;&gt;los tipos de coma flotante decimal&lt;/a&gt; IEEE 754 o para enteros &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary-coded_decimal&quot;&gt;decimales con c&amp;oacute;digo binario de&lt;/a&gt; terceros . Esta constante es significativa para todas las especializaciones.</target>
        </trans-unit>
        <trans-unit id="ad3e3b6d189c403f77654a78e8b8fce06565fd64" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; identifies the rounding style used by the floating-point type &lt;code&gt;T&lt;/code&gt; whenever a value that is not one of the exactly repesentable values of &lt;code&gt;T&lt;/code&gt; is stored in an object of that type.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::round_style&lt;/code&gt; identifica el estilo de redondeo utilizado por el tipo de coma flotante &lt;code&gt;T&lt;/code&gt; siempre que un valor que no es uno de los valores exactamente repetibles de &lt;code&gt;T&lt;/code&gt; se almacena en un objeto de ese tipo.</target>
        </trans-unit>
        <trans-unit id="929804192ce1c0c75b72779392cd6ef40eb4db5c" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all floating-point types &lt;code&gt;T&lt;/code&gt; that test results of floating-point expressions for underflow before rounding.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::tinyness_before&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos de punto flotante &lt;code&gt;T&lt;/code&gt; que prueban los resultados de las expresiones de punto flotante para el flujo inferior antes del redondeo.</target>
        </trans-unit>
        <trans-unit id="f1ed74039ebf1d42dca61166c833be8f6cd7f491" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all arithmetic types &lt;code&gt;T&lt;/code&gt; that have at least one value that, if used as an argument to an arithmetic operation, will generate a &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;trap&lt;/a&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;../numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;T&amp;gt;::traps&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los tipos aritm&amp;eacute;ticos &lt;code&gt;T&lt;/code&gt; que tienen al menos un valor que, si se usa como argumento para una operaci&amp;oacute;n aritm&amp;eacute;tica, generar&amp;aacute; una &lt;a href=&quot;https://en.wikipedia.org/wiki/Trap_(computing)&quot;&gt;trampa&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7772c8f78a06c27107be30f83bed9d48e68fe602" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(rv)&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">El valor de &lt;code&gt;T(rv)&lt;/code&gt; es equivalente al valor de &lt;code&gt;rv&lt;/code&gt; antes de la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e603736762efe81e0cad9751283ad8e5a1c288ee" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;T(v)&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;T(v)&lt;/code&gt; es equivalente al valor de &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ede44778ad8d0c527731cf4a992de2cbbc6337" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; is a/2b</source>
          <target state="translated">El valor de &lt;code&gt;a &amp;gt;&amp;gt; b&lt;/code&gt; es a / 2b</target>
        </trans-unit>
        <trans-unit id="0e75326e3adb574a4a577f0c6f90eb22555c8d18" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; is the unique value congruent to a * 2b</source>
          <target state="translated">El valor de &lt;code&gt;a &amp;lt;&amp;lt; b&lt;/code&gt; es el valor &amp;uacute;nico congruente con a * 2b</target>
        </trans-unit>
        <trans-unit id="74363b0d87e71eb3303d92bd255f435d2a3c664f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;base&lt;/code&gt; if successful, zero otherwise.</source>
          <target state="translated">El valor de &lt;code&gt;base&lt;/code&gt; si tiene &amp;eacute;xito, cero de lo contrario.</target>
        </trans-unit>
        <trans-unit id="56ee130795a5dbf75897c6a6783296c3ad1b779f" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;errno&lt;/code&gt; is &lt;code&gt;​0​&lt;/code&gt; at program startup, and although library functions are allowed to write positive integers to &lt;code&gt;errno&lt;/code&gt; whether or not an error occurred, library functions never store &lt;code&gt;​0​&lt;/code&gt; in &lt;code&gt;errno&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;errno&lt;/code&gt; es &lt;code&gt;​0​&lt;/code&gt; al inicio del programa, y aunque se permiten funciones de biblioteca para escribir n&amp;uacute;meros enteros positivos a &lt;code&gt;errno&lt;/code&gt; si se produjo o no un error, funciones de biblioteca Nunca almacene &lt;code&gt;​0​&lt;/code&gt; en &lt;code&gt;errno&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da2294d8108c3a6f801f89b03514268af0f31351" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;math_errhandling&lt;/code&gt; indicates the type of error handling that is performed by the floating-point operators and &lt;a href=&quot;../math&quot;&gt;functions&lt;/a&gt;:</source>
          <target state="translated">El valor de &lt;code&gt;math_errhandling&lt;/code&gt; indica el tipo de manejo de errores que realizan los operadores y &lt;a href=&quot;../math&quot;&gt;funciones de&lt;/a&gt; punto flotante :</target>
        </trans-unit>
        <trans-unit id="7588ffd7a3be6d286f7a94c5cb61054a64fe7ac0" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;required_alignment&lt;/code&gt; is the required alignment for an object to be referenced by an atomic reference, which is at least &lt;code&gt;alignof(T)&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;required_alignment&lt;/code&gt; es la alineaci&amp;oacute;n requerida para que un objeto sea referenciado por una referencia at&amp;oacute;mica, que es al menos &lt;code&gt;alignof(T)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a34573176a6c9f015786e0ff510ba4a79a46897b" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;t&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;t&lt;/code&gt; es equivalente al valor de &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="236ee56b867559bead4e59b54a4e12b218879b5a" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;rv&lt;/code&gt; before the initialization.</source>
          <target state="translated">El valor de &lt;code&gt;u&lt;/code&gt; es equivalente al valor de &lt;code&gt;rv&lt;/code&gt; antes de la inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="29aad058a8f1625b999d87663e4e7194ff6bfb72" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;u&lt;/code&gt; is equivalent to the value of &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">El valor de &lt;code&gt;u&lt;/code&gt; es equivalente al valor de &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c88528c3373936092717d4d0ad525f88f8c4c725" translate="yes" xml:space="preserve">
          <source>The value of &lt;code&gt;v&lt;/code&gt; is unchanged.</source>
          <target state="translated">El valor de &lt;code&gt;v&lt;/code&gt; no cambia.</target>
        </trans-unit>
        <trans-unit id="1e00c73d0ffbf3ea2f54f0b446263ab8f6d39011" translate="yes" xml:space="preserve">
          <source>The value of the &lt;code&gt;std::contract_violation&lt;/code&gt; argument passed to the violation handler is otherwise implementation-defined.</source>
          <target state="translated">El valor del argumento &lt;code&gt;std::contract_violation&lt;/code&gt; pasado al controlador de violaci&amp;oacute;n est&amp;aacute; definido de otra manera en la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="50fc3e65512141062b28f772c21ab1b1ae455710" translate="yes" xml:space="preserve">
          <source>The value of the atomic variable before the call.</source>
          <target state="translated">El valor de la variable atómica antes de la llamada.</target>
        </trans-unit>
        <trans-unit id="a3e86cc39cfa2d8064dc4c87f48911c38b5823b0" translate="yes" xml:space="preserve">
          <source>The value of the character pointed to by the</source>
          <target state="translated">El valor del personaje señalado por el</target>
        </trans-unit>
        <trans-unit id="a2c309bf2bbc046c6f48e885d2ea4de4c5bf6803" translate="yes" xml:space="preserve">
          <source>The value of the character that was pointed to by the</source>
          <target state="translated">El valor del personaje que fue señalado por el</target>
        </trans-unit>
        <trans-unit id="1d70250e3d2b884af86af7d39be631bda55177ff" translate="yes" xml:space="preserve">
          <source>The value of the character that was read and consumed in case of success, or &lt;code&gt;Traits::eof()&lt;/code&gt; in case of failure.</source>
          <target state="translated">El valor del car&amp;aacute;cter que se ley&amp;oacute; y se consumi&amp;oacute; en caso de &amp;eacute;xito, o &lt;code&gt;Traits::eof()&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="8f39527ddfa65bb2b87383657aeac9ba9fbcb938" translate="yes" xml:space="preserve">
          <source>The value of the device entropy, or zero if not applicable.</source>
          <target state="translated">El valor de la entropía del dispositivo,o cero si no es aplicable.</target>
        </trans-unit>
        <trans-unit id="9650465fffa6e1c6a542896eedb2d7c139c42b4e" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::ilogb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::ilogb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">El valor del exponente devuelto por &lt;code&gt;std::ilogb&lt;/code&gt; es siempre 1 menor que el exponente devuelto por &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; debido a los diferentes requisitos de normalizaci&amp;oacute;n: para el exponente &lt;code&gt;e&lt;/code&gt; devuelto por &lt;code&gt;std::ilogb&lt;/code&gt; , | arg * re</target>
        </trans-unit>
        <trans-unit id="296087b3564287e313cec1b7f024f1690f7740f9" translate="yes" xml:space="preserve">
          <source>The value of the exponent returned by &lt;code&gt;std::logb&lt;/code&gt; is always 1 less than the exponent retuned by &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; because of the different normalization requirements: for the exponent &lt;code&gt;e&lt;/code&gt; returned by &lt;code&gt;std::logb&lt;/code&gt;, |arg*r-e</source>
          <target state="translated">El valor del exponente devuelto por &lt;code&gt;std::logb&lt;/code&gt; es siempre 1 menor que el exponente reajustado por &lt;code&gt;&lt;a href=&quot;frexp&quot;&gt;std::frexp&lt;/a&gt;&lt;/code&gt; debido a los diferentes requisitos de normalizaci&amp;oacute;n: para el exponente &lt;code&gt;e&lt;/code&gt; devuelto por &lt;code&gt;std::logb&lt;/code&gt; , | arg * re</target>
        </trans-unit>
        <trans-unit id="1875dc13670139d279ca0c0bbdce2d158a5cdbab" translate="yes" xml:space="preserve">
          <source>The value of the next character. If the input sequence has been exhausted, &lt;code&gt;Traits::eof()&lt;/code&gt; is returned.</source>
          <target state="translated">El valor del siguiente personaje. Si la secuencia de entrada se ha agotado, se &lt;code&gt;Traits::eof()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="753fa9ec46bd8acaa1bc2b9508919ca2004c1c39" translate="yes" xml:space="preserve">
          <source>The value of the parameter is passed to the object at the construction time and stored within the object. Whenever the function object is invoked though &lt;code&gt;operator()&lt;/code&gt;, the stored value is passed as one of the arguments, the other argument is passed as an argument of &lt;code&gt;operator()&lt;/code&gt;. The resulting function object is an unary function.</source>
          <target state="translated">El valor del par&amp;aacute;metro se pasa al objeto en el momento de la construcci&amp;oacute;n y se almacena dentro del objeto. Siempre que se invoque el objeto de funci&amp;oacute;n a trav&amp;eacute;s de &lt;code&gt;operator()&lt;/code&gt; , el valor almacenado se pasa como uno de los argumentos, el otro argumento se pasa como argumento de &lt;code&gt;operator()&lt;/code&gt; . El objeto de funci&amp;oacute;n resultante es una funci&amp;oacute;n unaria.</target>
        </trans-unit>
        <trans-unit id="fba7a209e09ccfdda21dc54ae2df8a504208cb4c" translate="yes" xml:space="preserve">
          <source>The value of the referenced object before the call.</source>
          <target state="translated">El valor del objeto referido antes de la llamada.</target>
        </trans-unit>
        <trans-unit id="579ea98c704ce031e4e668b7afec012ffc8fd162" translate="yes" xml:space="preserve">
          <source>The value of the referenced object, immediately preceding the effects of this function.</source>
          <target state="translated">El valor del objeto referido,inmediatamente anterior a los efectos de esta función.</target>
        </trans-unit>
        <trans-unit id="7e259073fe670a628dfb34370ab4b87683b659c4" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with both the macro &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt;, where defined, with the member function &lt;code&gt;is_lock_free&lt;/code&gt; and non-member function &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El valor de esta constante es consistente tanto con la macro &lt;code&gt;ATOMIC_xxx_LOCK_FREE&lt;/code&gt; , donde est&amp;aacute; definida, con la funci&amp;oacute;n miembro &lt;code&gt;is_lock_free&lt;/code&gt; y la funci&amp;oacute;n no miembro &lt;code&gt;&lt;a href=&quot;../atomic_is_lock_free&quot;&gt;std::atomic_is_lock_free&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50845a026f496d39a63c3b0808c04361d0c8d58a" translate="yes" xml:space="preserve">
          <source>The value of this constant is consistent with the result of member function &lt;code&gt;is_lock_free&lt;/code&gt;.</source>
          <target state="translated">El valor de esta constante es consistente con el resultado de la funci&amp;oacute;n miembro &lt;code&gt;is_lock_free&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3403e199b11ef7fa0931fa58eddb8861252d4576" translate="yes" xml:space="preserve">
          <source>The value of type &lt;code&gt;char_type&lt;/code&gt; to use as the decimal separator. The standard specializations of &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;'.'&lt;/code&gt; and &lt;code&gt;L'.'&lt;/code&gt;.</source>
          <target state="translated">El valor de tipo &lt;code&gt;char_type&lt;/code&gt; para usar como separador decimal. Las especializaciones est&amp;aacute;ndar de &lt;code&gt;std::numpunct&lt;/code&gt; return &lt;code&gt;'.'&lt;/code&gt; y &lt;code&gt;L'.'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d17479026d3ea907d688db9d63f82d0f2b54dabe" translate="yes" xml:space="preserve">
          <source>The value or reference, if any, returned by the above call to &lt;code&gt;Container::emplace_back&lt;/code&gt;.</source>
          <target state="translated">El valor o referencia, si existe, devuelto por la llamada anterior a &lt;code&gt;Container::emplace_back&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c811b075e6e49eb2c35eb490d71ce4d51653f77f" translate="yes" xml:space="preserve">
          <source>The value previously held by the flag pointed to by &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">El valor previamente mantenido por la bandera se&amp;ntilde;alada por &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e567269120efb53b09110c26a8c4b9df966cef5" translate="yes" xml:space="preserve">
          <source>The value represented by the digit &lt;code&gt;c&lt;/code&gt; in base &lt;code&gt;I&lt;/code&gt; if the character &lt;code&gt;c&lt;/code&gt; is a valid digit in base &lt;code&gt;I&lt;/code&gt;</source>
          <target state="translated">El valor representado por el d&amp;iacute;gito &lt;code&gt;c&lt;/code&gt; en la base &lt;code&gt;I&lt;/code&gt; si el car&amp;aacute;cter &lt;code&gt;c&lt;/code&gt; es un d&amp;iacute;gito v&amp;aacute;lido en la base &lt;code&gt;I&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6f109c11a81bea0070c0d68dbb9891509f2180fe" translate="yes" xml:space="preserve">
          <source>The value represents the number of failures in a series of independent yes/no trials (each succeeds with probability p), before exactly k successes occur.</source>
          <target state="translated">El valor representa el número de fracasos en una serie de ensayos independientes de sí/no (cada uno de ellos tiene éxito con una probabilidad p),antes de que se produzcan exactamente k éxitos.</target>
        </trans-unit>
        <trans-unit id="8e434c235337a8e747f5dea3bd883fac3c017159" translate="yes" xml:space="preserve">
          <source>The value represents the number of yes/no trials (each succeeding with probability p) which are necessary to obtain a single success.</source>
          <target state="translated">El valor representa el número de ensayos de sí/no (cada uno de ellos con probabilidad p)que son necesarios para obtener un único éxito.</target>
        </trans-unit>
        <trans-unit id="bf46f4d3ca59d9f0505163079a8aeb0e0dc873f3" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;clock()&lt;/code&gt; may wrap around on some implementations. For example, on a machine with 32-bit &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt;, it wraps after 2147 seconds or 36 minutes.</source>
          <target state="translated">El valor devuelto por &lt;code&gt;clock()&lt;/code&gt; puede ajustarse en algunas implementaciones. Por ejemplo, en una m&amp;aacute;quina con &lt;code&gt;&lt;a href=&quot;clock_t&quot;&gt;std::clock_t&lt;/a&gt;&lt;/code&gt; 32 bits , se ajusta despu&amp;eacute;s de 2147 segundos o 36 minutos.</target>
        </trans-unit>
        <trans-unit id="ad4cdd680a12e6dfddb5ab5b51fcd6bb72586940" translate="yes" xml:space="preserve">
          <source>The value returned by &lt;code&gt;f&lt;/code&gt;.</source>
          <target state="translated">El valor devuelto por &lt;code&gt;f&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f06ccf9b4233e6226d4ee4962b6bec1aa785187" translate="yes" xml:space="preserve">
          <source>The value returned by the called function.</source>
          <target state="translated">El valor devuelto por la función llamada.</target>
        </trans-unit>
        <trans-unit id="601b8abd8b6436ee946fa9803b76f69133a0a540" translate="yes" xml:space="preserve">
          <source>The value returned by this conversion function is a pointer to a function with C++ &lt;a href=&quot;language_linkage&quot;&gt;language linkage&lt;/a&gt; that, when invoked, has the same effect as invoking the closure object's function call operator directly.</source>
          <target state="translated">El valor devuelto por esta funci&amp;oacute;n de conversi&amp;oacute;n es un puntero a una funci&amp;oacute;n con &lt;a href=&quot;language_linkage&quot;&gt;enlace de lenguaje&lt;/a&gt; C ++ que, cuando se invoca, tiene el mismo efecto que invocar directamente al operador de llamada de funci&amp;oacute;n del objeto de cierre.</target>
        </trans-unit>
        <trans-unit id="fdd035144b0ab851484c1c365e56cbd1dcc1b54a" translate="yes" xml:space="preserve">
          <source>The value returned shall be independent of the case of the characters in the sequence.</source>
          <target state="translated">El valor devuelto será independiente del caso de los personajes de la secuencia.</target>
        </trans-unit>
        <trans-unit id="b7fb32b3c03551e69bd2a36e0056ba4535fa1910" translate="yes" xml:space="preserve">
          <source>The value that is held by the atomic object pointed to by &lt;code&gt;obj&lt;/code&gt;.</source>
          <target state="translated">El valor que posee el objeto at&amp;oacute;mico al que apunta &lt;code&gt;obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="833d5a34e8e09458e1d01611adfdc9d19f4256ea" translate="yes" xml:space="preserve">
          <source>The value that results from assigning or initializing a signed bit field with a value out of range, or from incrementing a signed bit field past its range.</source>
          <target state="translated">El valor que resulta de asignar o inicializar un campo de bits con signo con un valor fuera de rango,o de incrementar un campo de bits con signo más allá de su rango.</target>
        </trans-unit>
        <trans-unit id="da945c5370b89f1c8352311f12a54ddba345a51b" translate="yes" xml:space="preserve">
          <source>The value type of &lt;code&gt;RandomIt1&lt;/code&gt; must be &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt;, &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; and &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt;.</source>
          <target state="translated">El tipo de valor de &lt;code&gt;RandomIt1&lt;/code&gt; debe ser &lt;a href=&quot;../../named_req/defaultconstructible&quot;&gt;DefaultConstructible&lt;/a&gt; , &lt;a href=&quot;../../named_req/copyconstructible&quot;&gt;CopyConstructible&lt;/a&gt; y &lt;a href=&quot;../../named_req/copyassignable&quot;&gt;CopyAssignable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cf2f9d6307fbcb0677baa700e9f0dbc912c45998" translate="yes" xml:space="preserve">
          <source>The value zero (for integral, floating-point, and unscoped enumeration) and the null pointer and the null pointer-to-member values become &lt;code&gt;false&lt;/code&gt;. All other values become &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">El valor cero (para enumeraci&amp;oacute;n integral, de punto flotante y sin &amp;aacute;mbito) y el puntero nulo y los valores de puntero nulo a miembro se vuelven &lt;code&gt;false&lt;/code&gt; . Todos los dem&amp;aacute;s valores se vuelven &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ba8effa4c27f0ba732998c45f3421c98781d70d" translate="yes" xml:space="preserve">
          <source>The values in the returned struct may differ from those supplied to the constructor in the following ways:</source>
          <target state="translated">Los valores de la estructura devuelta pueden diferir de los suministrados al constructor de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="7a76aed414f920671ac2d5636063f80c02930b91" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sep_by_space&lt;/code&gt;, &lt;code&gt;n_sep_by_space&lt;/code&gt;, &lt;code&gt;int_p_sep_by_space&lt;/code&gt;, &lt;code&gt;int_n_sep_by_space&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">Los valores de &lt;code&gt;p_sep_by_space&lt;/code&gt; , &lt;code&gt;n_sep_by_space&lt;/code&gt; , &lt;code&gt;int_p_sep_by_space&lt;/code&gt; , &lt;code&gt;int_n_sep_by_space&lt;/code&gt; se interpretan de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="77672f917a9b339a086c2698e191450e19cf6727" translate="yes" xml:space="preserve">
          <source>The values of &lt;code&gt;p_sign_posn&lt;/code&gt;, &lt;code&gt;n_sign_posn&lt;/code&gt;, &lt;code&gt;int_p_sign_posn&lt;/code&gt;, &lt;code&gt;int_n_sign_posn&lt;/code&gt; are interpreted as follows:</source>
          <target state="translated">Los valores de &lt;code&gt;p_sign_posn&lt;/code&gt; , &lt;code&gt;n_sign_posn&lt;/code&gt; , &lt;code&gt;int_p_sign_posn&lt;/code&gt; , &lt;code&gt;int_n_sign_posn&lt;/code&gt; se interpretan de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="33abc0ae5b48791fecb22e74c9f73d03bb18aa24" translate="yes" xml:space="preserve">
          <source>The values of the member typedefs are as follows.</source>
          <target state="translated">Los valores de los miembros tipificados son los siguientes.</target>
        </trans-unit>
        <trans-unit id="e9fe6d1f76a572b29a8d3484a98866cb41ec603b" translate="yes" xml:space="preserve">
          <source>The values of these macros (except for &lt;code&gt;__FILE__&lt;/code&gt; and &lt;code&gt;__LINE__&lt;/code&gt;) remain constant throughout the translation unit. Attempts to redefine or undefine these macros result in undefined behavior.</source>
          <target state="translated">Los valores de estas macros (excepto &lt;code&gt;__FILE__&lt;/code&gt; y &lt;code&gt;__LINE__&lt;/code&gt; ) permanecen constantes en toda la unidad de traducci&amp;oacute;n. Los intentos de redefinir o indefinir estas macros resultan en un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="98bfbbcd22ae41d5573869cfcb9522362b10fb4c" translate="yes" xml:space="preserve">
          <source>The version of this function provided in the standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; does the following:</source>
          <target state="translated">La versi&amp;oacute;n de esta funci&amp;oacute;n proporcionada en las especializaciones de biblioteca est&amp;aacute;ndar de &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; hace lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a622961aafca050ec72f078b30740b239e4cfd26" translate="yes" xml:space="preserve">
          <source>The versions (1-4) are implicitly declared in each translation unit even if the &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; header is not included. Versions (1-8) are</source>
          <target state="translated">Las versiones (1-4) se declaran impl&amp;iacute;citamente en cada unidad de traducci&amp;oacute;n, incluso si el encabezado &lt;code&gt;&amp;lt;new&amp;gt;&lt;/code&gt; no est&amp;aacute; incluido. Las versiones (1-8) son</target>
        </trans-unit>
        <trans-unit id="b0b7d7c2aa828b9a641d26b6867ec8872ed88500" translate="yes" xml:space="preserve">
          <source>The weak forms ((1) and (3)) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*obj != *expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">Las formas d&amp;eacute;biles ((1) y (3)) de las funciones pueden fallar falsamente, es decir, actuar como si &lt;code&gt;*obj != *expected&lt;/code&gt; incluso si son iguales. Cuando una comparaci&amp;oacute;n e intercambio est&amp;aacute; en un bucle, la versi&amp;oacute;n d&amp;eacute;bil producir&amp;aacute; un mejor rendimiento en algunas plataformas.</target>
        </trans-unit>
        <trans-unit id="053ece5439dd03785d396cff64f13b7779aae0c4" translate="yes" xml:space="preserve">
          <source>The weak forms (1-2) of the functions are allowed to fail spuriously, that is, act as if &lt;code&gt;*this != expected&lt;/code&gt; even if they are equal. When a compare-and-exchange is in a loop, the weak version will yield better performance on some platforms.</source>
          <target state="translated">Las formas d&amp;eacute;biles (1-2) de las funciones pueden fallar falsamente, es decir, actuar como si &lt;code&gt;*this != expected&lt;/code&gt; incluso si son iguales. Cuando una comparaci&amp;oacute;n e intercambio est&amp;aacute; en un bucle, la versi&amp;oacute;n d&amp;eacute;bil producir&amp;aacute; un mejor rendimiento en algunas plataformas.</target>
        </trans-unit>
        <trans-unit id="61282ad563d58ac6dca223420c82a6fda52cb8a1" translate="yes" xml:space="preserve">
          <source>The weakest alignment (the smallest alignment requirement) is the alignment of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;signed char&lt;/code&gt;, and &lt;code&gt;unsigned char&lt;/code&gt;, which equals 1; the largest</source>
          <target state="translated">La alineaci&amp;oacute;n m&amp;aacute;s d&amp;eacute;bil (el requisito de alineaci&amp;oacute;n m&amp;aacute;s peque&amp;ntilde;o) es la alineaci&amp;oacute;n de &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;signed char&lt;/code&gt; &lt;code&gt;unsigned char&lt;/code&gt; y char sin signo , que es igual a 1; El m&amp;aacute;s largo</target>
        </trans-unit>
        <trans-unit id="6636ab7a40ed20b3758bf9d6aa3f53a69dfb3fd6" translate="yes" xml:space="preserve">
          <source>The weekday value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">El valor del d&amp;iacute;a de la semana almacenado en &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="147c41b97d63a5ff943a4dff64e656850433bca6" translate="yes" xml:space="preserve">
          <source>The whitespace skipping is performed by the constructor of &lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt;, which reads and discards the characters classified as whitespace by the &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; facet of the stream's imbued locale.</source>
          <target state="translated">El saltador de espacios en blanco lo realiza el constructor de &lt;code&gt;&lt;a href=&quot;../basic_istream/sentry&quot;&gt;std::basic_istream::sentry&lt;/a&gt;&lt;/code&gt; , que lee y descarta los caracteres clasificados como espacios en blanco por la faceta &lt;code&gt;&lt;a href=&quot;../../locale/ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; de la localizaci&amp;oacute;n imbuida de la secuencia.</target>
        </trans-unit>
        <trans-unit id="28861a2e9cac8a64e7e6c9de02d8f4ad1d432f65" translate="yes" xml:space="preserve">
          <source>The width property of the stream will be reset to zero (meaning &quot;unspecified&quot;) if any of the following functions are called:</source>
          <target state="translated">La propiedad de anchura de la corriente se restablecerá a cero (lo que significa &quot;sin especificar&quot;)si se llama a cualquiera de las siguientes funciones:</target>
        </trans-unit>
        <trans-unit id="75482b7330efd238856a66fa9534aa457b8aac86" translate="yes" xml:space="preserve">
          <source>The written character, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; on success.</source>
          <target state="translated">El car&amp;aacute;cter escrito, convertido a &lt;code&gt;int_type&lt;/code&gt; con &lt;code&gt;Traits::to_int_type(ch)&lt;/code&gt; en caso de &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="1270ca56a41a6e7f02e1f97ce0b715f2fb7199a2" translate="yes" xml:space="preserve">
          <source>The year value stored in &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">El valor del a&amp;ntilde;o almacenado en &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d323f4076e0841438d41510cd53cbcfb9286a841" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;replacement&lt;/code&gt; is appended as if by &lt;code&gt;operator+=(replacement)&lt;/code&gt;.</source>
          <target state="translated">Entonces &lt;code&gt;replacement&lt;/code&gt; se anexa como por &lt;code&gt;operator+=(replacement)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="373a08cad37838d1afc67f2d26d81125cf6dd627" translate="yes" xml:space="preserve">
          <source>Then &lt;code&gt;std::launder(p)&lt;/code&gt; returns a value of type &lt;code&gt;T*&lt;/code&gt; that points to the object &lt;code&gt;X&lt;/code&gt;. Otherwise, the behavior is undefined.</source>
          <target state="translated">Entonces &lt;code&gt;std::launder(p)&lt;/code&gt; devuelve un valor de tipo &lt;code&gt;T*&lt;/code&gt; que apunta al objeto &lt;code&gt;X&lt;/code&gt; . De lo contrario, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="a8cef55836d6512dfe4dc252602d2fb2a942c56d" translate="yes" xml:space="preserve">
          <source>Then converts the argument &lt;code&gt;dir&lt;/code&gt; to a value &lt;code&gt;whence&lt;/code&gt; of type &lt;code&gt;int&lt;/code&gt; as follows:</source>
          <target state="translated">A continuaci&amp;oacute;n, convierte el argumento &lt;code&gt;dir&lt;/code&gt; a un valor &lt;code&gt;whence&lt;/code&gt; de tipo &lt;code&gt;int&lt;/code&gt; como sigue:</target>
        </trans-unit>
        <trans-unit id="d114c31b8c85d68931469ea5e0153732743033d0" translate="yes" xml:space="preserve">
          <source>Then for the expression &lt;code&gt;w1 == w2&lt;/code&gt; and &lt;code&gt;w1 != w2&lt;/code&gt; either or both objects may be replaced by an</source>
          <target state="translated">Entonces, para la expresi&amp;oacute;n &lt;code&gt;w1 == w2&lt;/code&gt; y &lt;code&gt;w1 != w2&lt;/code&gt; uno o ambos objetos pueden ser reemplazados por un</target>
        </trans-unit>
        <trans-unit id="5664e9f77aa6963c92dfdd8b0b7e6f96d1c31677" translate="yes" xml:space="preserve">
          <source>Then performs move-assignment by moving all contents from &lt;code&gt;other&lt;/code&gt;, including the temporary storage, the wrapped stream pointer, policy, and all other state (such as the mutex pointer). After move, &lt;code&gt;other&lt;/code&gt; is not associated with a stream, and &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt;. The put area member pointers of the base class &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;other&lt;/code&gt; are guaranteed to be null. Destroying a moved-from &lt;code&gt;other&lt;/code&gt; will not produce any output.</source>
          <target state="translated">Luego realiza la asignaci&amp;oacute;n de movimiento moviendo todo el contenido de &lt;code&gt;other&lt;/code&gt; , incluido el almacenamiento temporal, el puntero de flujo envuelto, la pol&amp;iacute;tica y todos los dem&amp;aacute;s estados (como el puntero mutex). Despu&amp;eacute;s del movimiento, &lt;code&gt;other&lt;/code&gt; no est&amp;aacute; asociado con una secuencia, y &lt;code&gt;other.get_wrapped()==nullptr&lt;/code&gt; . Se garantiza que los punteros de miembros del &amp;aacute;rea de &lt;code&gt;&lt;a href=&quot;../basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; de la clase base std :: basic_streambuf de &lt;code&gt;other&lt;/code&gt; son nulos. Destruir un movido desde &lt;code&gt;other&lt;/code&gt; no producir&amp;aacute; ning&amp;uacute;n resultado.</target>
        </trans-unit>
        <trans-unit id="688a34f8e387e542a111a325ed5ac02b72fbb6e9" translate="yes" xml:space="preserve">
          <source>Then repositions the file pointer, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Luego reposiciona el puntero del archivo, como si llamara &lt;code&gt;&lt;a href=&quot;../c/fsetpos&quot;&gt;std::fsetpos()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c6cd6761eff74a4e8721e60e098e84a0745d88f" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;str&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">Luego almacena cada car&amp;aacute;cter de la secuencia resultante (el contenido de &lt;code&gt;str&lt;/code&gt; plus padding) en el flujo de salida &lt;code&gt;os&lt;/code&gt; como si llamara a &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; , donde &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89dd54897998475390b292a027e7346fd0e80fba" translate="yes" xml:space="preserve">
          <source>Then stores each character from the resulting sequence (the contents of &lt;code&gt;v&lt;/code&gt; plus padding) to the output stream &lt;code&gt;os&lt;/code&gt; as if by calling &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt;, where &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt;.</source>
          <target state="translated">Luego almacena cada car&amp;aacute;cter de la secuencia resultante (el contenido de &lt;code&gt;v&lt;/code&gt; plus padding) en la secuencia de salida &lt;code&gt;os&lt;/code&gt; como si llamara a &lt;code&gt;os.rdbuf()-&amp;gt;sputn(seq, n)&lt;/code&gt; , donde &lt;code&gt;n=&lt;a href=&quot;../../algorithm/max&quot;&gt;std::max&lt;/a&gt;(os.width(), str.size())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b71560ffb9f745af8a0de8c02270fff34828d1a4" translate="yes" xml:space="preserve">
          <source>Then template-1 is more specialized than template-2. If the conditions above are true after switching template order, than template-2 is more specialized than template-1. Otherwise, neither template is more specialized than the other. In case of a tie, if one function template has a trailing parameter pack and the other does not, the one with the omitted parameter is considered to be more specialized than the one with the empty parameter pack.</source>
          <target state="translated">Entonces la plantilla 1 es más especializada que la plantilla 2.Si las condiciones anteriores son ciertas después de cambiar el orden de las plantillas,entonces la plantilla-2 es más especializada que la plantilla-1.De lo contrario,ninguna de las plantillas es más especializada que la otra.En caso de empate,si una plantilla de función tiene un paquete de parámetros de seguimiento y la otra no,la que tiene el parámetro omitido se considera más especializada que la que tiene el paquete de parámetros vacío.</target>
        </trans-unit>
        <trans-unit id="d3271caf912e95526fbf0f4e50e8dacc62c22392" translate="yes" xml:space="preserve">
          <source>Then the function behaves as &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt;. After constructing and checking the sentry object, if any &lt;code&gt;ios_base::iostate&lt;/code&gt; flags are set, the function sets &lt;code&gt;failbit&lt;/code&gt; and returns. Otherwise, calls &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt;.</source>
          <target state="translated">Entonces la funci&amp;oacute;n se comporta como &lt;a href=&quot;../../named_req/unformattedinputfunction&quot;&gt;UnformattedInputFunction&lt;/a&gt; . Despu&amp;eacute;s de construir y verificar el objeto centinela, si se establecen indicadores &lt;code&gt;ios_base::iostate&lt;/code&gt; , la funci&amp;oacute;n establece el &lt;code&gt;failbit&lt;/code&gt; y regresa. De lo contrario, llama a &lt;code&gt;rdbuf()-&amp;gt;sungetc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36f34a067b6d5809ad8db68785a0d829422e3317" translate="yes" xml:space="preserve">
          <source>Then this function in the class &lt;code&gt;Derived&lt;/code&gt; is also</source>
          <target state="translated">Entonces esta funci&amp;oacute;n en la clase &lt;code&gt;Derived&lt;/code&gt; tambi&amp;eacute;n es</target>
        </trans-unit>
        <trans-unit id="7f48f8e860002b0a6fca10b3b58cdef248ff8167" translate="yes" xml:space="preserve">
          <source>Then, &lt;code&gt;awaiter.await_ready()&lt;/code&gt; is called (this is a short-cut to avoid the cost of suspension if it's known that the result is ready or can be completed synchronously). If its result, contextually-converted to bool is &lt;code&gt;false&lt;/code&gt; then.</source>
          <target state="translated">Luego, se llama a &lt;code&gt;awaiter.await_ready()&lt;/code&gt; (este es un atajo para evitar el costo de la suspensi&amp;oacute;n si se sabe que el resultado est&amp;aacute; listo o se puede completar sincr&amp;oacute;nicamente). Si su resultado, convertido contextualmente a bool es &lt;code&gt;false&lt;/code&gt; entonces.</target>
        </trans-unit>
        <trans-unit id="8f56bc35fde57e5d45735f7118718bf8634008b7" translate="yes" xml:space="preserve">
          <source>Then, a dot character is appended to the generic-format view of the pathname, if &lt;code&gt;replacement&lt;/code&gt; is not empty or does not begin with a dot character.</source>
          <target state="translated">Luego, se agrega un car&amp;aacute;cter de punto a la vista de formato gen&amp;eacute;rico del nombre de ruta, si el &lt;code&gt;replacement&lt;/code&gt; no est&amp;aacute; vac&amp;iacute;o o no comienza con un car&amp;aacute;cter de punto.</target>
        </trans-unit>
        <trans-unit id="7a8ce560ef479ac7bd437cfaae9fee813911dce4" translate="yes" xml:space="preserve">
          <source>Then, closes the file as if by calling &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt;, regardless of whether any of the preceding calls succeeded or failed.</source>
          <target state="translated">Luego, cierra el archivo como si llamara a &lt;code&gt;&lt;a href=&quot;../c/fclose&quot;&gt;std::fclose()&lt;/a&gt;&lt;/code&gt; , independientemente de si alguna de las llamadas anteriores tuvo &amp;eacute;xito o fall&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="bb70360ec88c4bb9dac2644a98645695f52f42d5" translate="yes" xml:space="preserve">
          <source>Then, for the expressions &lt;code&gt;p1 == p2&lt;/code&gt;, &lt;code&gt;p1 != p2&lt;/code&gt;, &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt;&lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt;, &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt;, &lt;code&gt;p1 - p2&lt;/code&gt;} either or both objects may be replaced by an</source>
          <target state="translated">Entonces, para las expresiones &lt;code&gt;p1 == p2&lt;/code&gt; , &lt;code&gt;p1 != p2&lt;/code&gt; , &lt;code&gt;p1 &amp;lt; p2&lt;/code&gt; &lt;code&gt;p1 &amp;lt;= p2&lt;/code&gt; , &lt;code&gt;p1 &amp;gt;= p2&lt;/code&gt; , &lt;code&gt;p1 &amp;gt; p2&lt;/code&gt; , &lt;code&gt;p1 - p2&lt;/code&gt; } cualquiera o ambos objetos pueden ser reemplazados por un</target>
        </trans-unit>
        <trans-unit id="03792c753032d7cb9233d55af244f2b35fa6ba5a" translate="yes" xml:space="preserve">
          <source>Then, if &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt;, adds &lt;code&gt;out.width()-seq.size()&lt;/code&gt; copies of the fill character &lt;code&gt;out.fill()&lt;/code&gt; either at the end of the sequence (if &lt;code&gt;ios_base::left&lt;/code&gt; is set in &lt;code&gt;out.flags()&lt;/code&gt;) or at the beginning of the sequence (in all other cases).</source>
          <target state="translated">Luego, si &lt;code&gt;seq.size() &amp;lt; out.width()&lt;/code&gt; , agrega &lt;code&gt;out.width()-seq.size()&lt;/code&gt; copias del car&amp;aacute;cter de relleno &lt;code&gt;out.fill()&lt;/code&gt; al final de la secuencia (si &lt;code&gt;ios_base::left&lt;/code&gt; se establece en &lt;code&gt;out.flags()&lt;/code&gt; ) o al comienzo de la secuencia (en todos los dem&amp;aacute;s casos).</target>
        </trans-unit>
        <trans-unit id="9b66cf1ae7e463d5761dc0c8e4b85c87a42f6ae4" translate="yes" xml:space="preserve">
          <source>Then, if the character encoding is fixed-width (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returns some positive number &lt;code&gt;width&lt;/code&gt;, moves the file pointer as if by &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt;.</source>
          <target state="translated">Luego, si la codificaci&amp;oacute;n de caracteres es de ancho fijo ( &lt;code&gt;codecvt::encoding()&lt;/code&gt; devuelve un &lt;code&gt;width&lt;/code&gt; n&amp;uacute;mero positivo , mueve el puntero del archivo como si fuera &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, width*off, whence)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1588837f0abae43644f6a59f2a7e9d05829935b3" translate="yes" xml:space="preserve">
          <source>Then, if the current emit-on-sync policy is &lt;code&gt;true&lt;/code&gt;, makes a call to &lt;a href=&quot;emit&quot;&gt;&lt;code&gt;emit()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Entonces, si la pol&amp;iacute;tica actual de emisi&amp;oacute;n en sincronizaci&amp;oacute;n es &lt;code&gt;true&lt;/code&gt; , realiza una llamada a &lt;a href=&quot;emit&quot;&gt; &lt;code&gt;emit()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e328ed3f5e3fe95a687636b98322058fa4cd84c4" translate="yes" xml:space="preserve">
          <source>Then, move-assigns the wrapped &lt;code&gt;std::basic_syncbuf&lt;/code&gt; from the corresponding member of &lt;code&gt;other&lt;/code&gt; (after this move-assignment, &lt;code&gt;other.get_wrapped()&lt;/code&gt; returns a null pointer and destruction of &lt;code&gt;other&lt;/code&gt; produces no output) and &lt;a href=&quot;../basic_ostream/operator=&quot;&gt;move-assigns&lt;/a&gt; the base &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; (this swaps all stream state variables except for &lt;code&gt;rdbuf&lt;/code&gt; between &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;).</source>
          <target state="translated">Luego, move-asigna el &lt;code&gt;std::basic_syncbuf&lt;/code&gt; envuelto desde el miembro correspondiente de &lt;code&gt;other&lt;/code&gt; (despu&amp;eacute;s de esta asignaci&amp;oacute;n de movimiento, &lt;code&gt;other.get_wrapped()&lt;/code&gt; devuelve un puntero nulo y la destrucci&amp;oacute;n de &lt;code&gt;other&lt;/code&gt; no produce salida) y &lt;a href=&quot;../basic_ostream/operator=&quot;&gt;move-asigna&lt;/a&gt; el &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; (esto intercambia todas las variables de estado de flujo, excepto &lt;code&gt;rdbuf&lt;/code&gt; entre &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cac51d51872e9519bbc0bc669f0606d196b2f4a3" translate="yes" xml:space="preserve">
          <source>Then, the awaiter object is obtained, as follows:</source>
          <target state="translated">Entonces,se obtiene el objeto que espera,de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="6b9e0d6ed6f7b1751b629f6e3ddc80ecb32c6693" translate="yes" xml:space="preserve">
          <source>Then, whether &lt;code&gt;to&lt;/code&gt; already existed or was just created, iterates over the files contained in &lt;code&gt;from&lt;/code&gt; as if by &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; and for each directory entry, recursively calls &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt;, where</source>
          <target state="translated">Luego, ya sea &lt;code&gt;to&lt;/code&gt; ya existi&amp;oacute; o que acaba de crearse, itera sobre los archivos contenidos &lt;code&gt;from&lt;/code&gt; como si fuera por &lt;code&gt;for (const &lt;a href=&quot;directory_entry&quot;&gt;std::filesystem::directory_entry&lt;/a&gt;&amp;amp; x : &lt;a href=&quot;directory_iterator&quot;&gt;std::filesystem::directory_iterator&lt;/a&gt;(from))&lt;/code&gt; y para cada entrada de directorio , llama recursivamente a &lt;code&gt;copy(x.path(), to/x.path().filename(), options | in-recursive-copy)&lt;/code&gt; , donde</target>
        </trans-unit>
        <trans-unit id="e9125d469bb8f6aff93d3721871c0958a43dafdd" translate="yes" xml:space="preserve">
          <source>Then, x1 and x2 are</source>
          <target state="translated">Entonces,x1 y x2 son</target>
        </trans-unit>
        <trans-unit id="c5bb0afc7219a935f5a73b87436c78d57282e9f3" translate="yes" xml:space="preserve">
          <source>Then.</source>
          <target state="translated">Then.</target>
        </trans-unit>
        <trans-unit id="dcb618e3bc4e6760e6d24a1d8c4732cdb2523ec0" translate="yes" xml:space="preserve">
          <source>Theoretical maximum allocation size.</source>
          <target state="translated">Tamaño máximo teórico de la asignación.</target>
        </trans-unit>
        <trans-unit id="7dcca98b4934dc33e5546547c327611fcc667809" translate="yes" xml:space="preserve">
          <source>There are alternative spellings for several operators and other tokens that use non-ISO646 characters. In all respects of the language, each alternative token behaves exactly the same as its primary token, except for its spelling (the &lt;a href=&quot;../preprocessor/replace&quot;&gt;stringification operator&lt;/a&gt; can make the spelling visible). The two-letter alternative tokens are sometimes called &quot;digraphs&quot;</source>
          <target state="translated">Hay ortograf&amp;iacute;as alternativas para varios operadores y otros tokens que usan caracteres que no son ISO646. En todos los aspectos del lenguaje, cada token alternativo se comporta exactamente igual que su token primario, excepto por su ortograf&amp;iacute;a (el &lt;a href=&quot;../preprocessor/replace&quot;&gt;operador de stringificaci&amp;oacute;n&lt;/a&gt; puede hacer que la ortograf&amp;iacute;a sea visible). Las fichas alternativas de dos letras a veces se llaman &quot;d&amp;iacute;grafos&quot;</target>
        </trans-unit>
        <trans-unit id="8e6f3eaebb9a3927bc985adcb62df7d15d191025" translate="yes" xml:space="preserve">
          <source>There are compiler extensions that may be used to generate C++ exceptions automatically whenever a floating-point exception is raised:</source>
          <target state="translated">Existen extensiones del compilador que pueden utilizarse para generar automáticamente excepciones de C++siempre que se plantee una excepción de punto flotante:</target>
        </trans-unit>
        <trans-unit id="3f225f0e74f08c0d0f2caf0e296a39e971ff8239" translate="yes" xml:space="preserve">
          <source>There are five available return types:</source>
          <target state="translated">Hay cinco tipos de devolución disponibles:</target>
        </trans-unit>
        <trans-unit id="c8b561cc0eef33e481077a8d77db9eb795dcf585" translate="yes" xml:space="preserve">
          <source>There are five(until C++17)six(since C++17) kinds of iterators: &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt;, &lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt;, &lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt;, &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt;, and &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;(since C++17).</source>
          <target state="translated">Hay cinco (hasta C ++ 17) seis (desde C ++ 17) tipos de iteradores: &lt;a href=&quot;named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;a href=&quot;named_req/outputiterator&quot;&gt;LegacyOutputIterator&lt;/a&gt; , &lt;a href=&quot;named_req/forwarditerator&quot;&gt;LegacyForwardIterator&lt;/a&gt; , &lt;a href=&quot;named_req/bidirectionaliterator&quot;&gt;LegacyBidirectionalIterator&lt;/a&gt; , &lt;a href=&quot;named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; y &lt;a href=&quot;named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="9778100d7798733f17cf489450cafd2088023fa7" translate="yes" xml:space="preserve">
          <source>There are many different NaN values with different sign bits and payloads, see &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Hay muchos valores NaN diferentes con diferentes bits de signo y cargas &amp;uacute;tiles, consulte &lt;code&gt;&lt;a href=&quot;nan.2&quot;&gt;std::nan&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits/quiet_nan&quot;&gt;std::numeric_limits::quiet_NaN&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e03334de5cfa0b9f96707c08d7bef755bc11a3c" translate="yes" xml:space="preserve">
          <source>There are many different NaN values, differentiated by their payloads and their sign bits. The contents of the payload and the sign bit of the NaN generated by the macro &lt;code&gt;NAN&lt;/code&gt; are implementation-defined.</source>
          <target state="translated">Hay muchos valores diferentes de NaN, diferenciados por sus cargas &amp;uacute;tiles y sus bits de signo. El contenido de la carga &amp;uacute;til y el bit de signo del NaN generado por la macro &lt;code&gt;NAN&lt;/code&gt; est&amp;aacute;n definidos por la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a956cc8cb0205c1b4676cee813cb10d9f4679af6" translate="yes" xml:space="preserve">
          <source>There are many types for which equality makes sense, but not less-than ordering: a common example are the complex numbers, or any pair of numbers in general:</source>
          <target state="translated">Hay muchos tipos para los que la igualdad tiene sentido,pero no menos que el orden:un ejemplo común son los números complejos,o cualquier par de números en general:</target>
        </trans-unit>
        <trans-unit id="694fc92221739aa50089385fa6fdb3ce4ff4a1f6" translate="yes" xml:space="preserve">
          <source>There are no &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt; for bit fields: &lt;code&gt;int b : 1 = 0;&lt;/code&gt; and &lt;code&gt;int b : 1 {0}&lt;/code&gt; are ill-formed.</source>
          <target state="translated">No hay &lt;a href=&quot;data_members#Member_initialization&quot;&gt;inicializadores de miembros predeterminados&lt;/a&gt; para los campos de bits: &lt;code&gt;int b : 1 = 0;&lt;/code&gt; e &lt;code&gt;int b : 1 {0}&lt;/code&gt; est&amp;aacute;n mal formados.</target>
        </trans-unit>
        <trans-unit id="db2de29aa1d33752b78c0dd7d6ec96850ff5a7be" translate="yes" xml:space="preserve">
          <source>There are no arrays of references or arrays of functions.</source>
          <target state="translated">No hay conjuntos de referencias o conjuntos de funciones.</target>
        </trans-unit>
        <trans-unit id="37439af54c020a64a12e9c758da796ee25c34c35" translate="yes" xml:space="preserve">
          <source>There are no bit field &lt;a href=&quot;value_category&quot;&gt;prvalues&lt;/a&gt;: lvalue-to-rvalue conversion always produces an object of the underlying type of the bit field.</source>
          <target state="translated">No hay &lt;a href=&quot;value_category&quot;&gt;valores de&lt;/a&gt; campo de bits : la conversi&amp;oacute;n de valor de valor a valor siempre produce un objeto del tipo subyacente del campo de bits.</target>
        </trans-unit>
        <trans-unit id="f39ab94881006d285c7e811db2e42c17ba7a7d98" translate="yes" xml:space="preserve">
          <source>There are no guarantees as to the quality of the random sequence produced. In the past, some implementations of &lt;code&gt;rand()&lt;/code&gt; have had serious shortcomings in the randomness, distribution and period of the sequence produced (in one well-known example, the low-order bit simply alternated between &lt;code&gt;1&lt;/code&gt; and &lt;code&gt;0&lt;/code&gt; between calls).</source>
          <target state="translated">No hay garant&amp;iacute;as en cuanto a la calidad de la secuencia aleatoria producida. En el pasado, algunas implementaciones de &lt;code&gt;rand()&lt;/code&gt; han tenido serias deficiencias en la aleatoriedad, distribuci&amp;oacute;n y per&amp;iacute;odo de la secuencia producida (en un ejemplo bien conocido, el bit de bajo orden simplemente alternaba entre &lt;code&gt;1&lt;/code&gt; y &lt;code&gt;0&lt;/code&gt; entre llamadas).</target>
        </trans-unit>
        <trans-unit id="991d3d81eb996d06aa3347bc77bacaef91a6483e" translate="yes" xml:space="preserve">
          <source>There are no negative integer literals. Expressions such as &lt;code&gt;-1&lt;/code&gt; apply the &lt;a href=&quot;operator_arithmetic&quot;&gt;unary minus operator&lt;/a&gt; to the value represented by the literal, which may involve implicit type conversions.</source>
          <target state="translated">No hay literales enteros negativos. Expresiones como &lt;code&gt;-1&lt;/code&gt; aplican el &lt;a href=&quot;operator_arithmetic&quot;&gt;operador menos unario&lt;/a&gt; al valor representado por el literal, que puede implicar conversiones de tipo impl&amp;iacute;cito.</target>
        </trans-unit>
        <trans-unit id="bcb7f46103fbd100a4f9cb6ff99abb2c28199213" translate="yes" xml:space="preserve">
          <source>There are no optional references; a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with a reference type. Alternatively, an &lt;code&gt;optional&lt;/code&gt; of a &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; may be used to hold a reference. In addition, a program is ill-formed if it instantiates an &lt;code&gt;optional&lt;/code&gt; with the tag types &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">No hay referencias opcionales; un programa est&amp;aacute; mal formado si crea una instancia &lt;code&gt;optional&lt;/code&gt; con un tipo de referencia. Alternativamente, se puede usar un &lt;code&gt;optional&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;functional/reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&lt;/code&gt; de tipo &lt;code&gt;T&lt;/code&gt; para contener una referencia. Adem&amp;aacute;s, un programa est&amp;aacute; mal formado si crea una instancia &lt;code&gt;optional&lt;/code&gt; con los tipos de etiqueta &lt;code&gt;&lt;a href=&quot;optional/nullopt_t&quot;&gt;std::nullopt_t&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;in_place&quot;&gt;std::in_place_t&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8419f6809e1cf19b6fb3b6a22f4638d4c5849b20" translate="yes" xml:space="preserve">
          <source>There are no overload for pointers to non-static member, pointers to volatile, or function pointers (other than the ones with signatures accepted by the (10-12) overloads). Attempting to output such objects invokes implicit conversion to &lt;code&gt;bool&lt;/code&gt;, and, for any non-null pointer value, the value &lt;code&gt;1&lt;/code&gt; is printed (unless &lt;code&gt;boolalpha&lt;/code&gt; was set, in which case &lt;code&gt;true&lt;/code&gt; is printed).</source>
          <target state="translated">No hay sobrecarga para punteros a miembros no est&amp;aacute;ticos, punteros a vol&amp;aacute;tiles o punteros de funci&amp;oacute;n (que no sean los que tienen firmas aceptadas por las sobrecargas (10-12)). Intentar generar dichos objetos invoca la conversi&amp;oacute;n impl&amp;iacute;cita a &lt;code&gt;bool&lt;/code&gt; y, para cualquier valor de puntero no nulo, se imprime el valor &lt;code&gt;1&lt;/code&gt; (a menos que se &lt;code&gt;boolalpha&lt;/code&gt; establecido boolalpha , en cuyo caso se imprime &lt;code&gt;true&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3e3662fa8ed3550ea700d26fee022c4ac95bb7d6" translate="yes" xml:space="preserve">
          <source>There are no pointers to &lt;a href=&quot;reference&quot;&gt;references&lt;/a&gt; and there are no pointers to &lt;a href=&quot;bit_field&quot;&gt;bit fields&lt;/a&gt;. Typically, mentions of &quot;pointers&quot; without elaboration do not include pointers to (non-static) members.</source>
          <target state="translated">No hay punteros a las &lt;a href=&quot;reference&quot;&gt;referencias&lt;/a&gt; y no hay punteros a &lt;a href=&quot;bit_field&quot;&gt;los campos de bits&lt;/a&gt; . T&amp;iacute;picamente, las menciones de &quot;punteros&quot; sin elaboraci&amp;oacute;n no incluyen punteros a miembros (no est&amp;aacute;ticos).</target>
        </trans-unit>
        <trans-unit id="337c29a8a2b7567bb32c86a4abf4bf2501e7a2ab" translate="yes" xml:space="preserve">
          <source>There are no references to &lt;code&gt;void&lt;/code&gt; and no references to references.</source>
          <target state="translated">No hay referencias al &lt;code&gt;void&lt;/code&gt; ni referencias a referencias.</target>
        </trans-unit>
        <trans-unit id="1deb84f794c63103b9555294bae8bd9107563871" translate="yes" xml:space="preserve">
          <source>There are no standard complexity guarantees, typical implementations behave similar to &lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;.</source>
          <target state="translated">No hay garant&amp;iacute;as de complejidad est&amp;aacute;ndar, las implementaciones t&amp;iacute;picas se comportan de manera similar a &lt;a href=&quot;../../container/vector/insert&quot;&gt;std :: vector :: insert&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ef11a32cf3433c799eb8a56e867da73440715a2" translate="yes" xml:space="preserve">
          <source>There are non-member function template equivalents for all member functions of &lt;code&gt;std::atomic&lt;/code&gt;. Those non-member functions may be additionally overloaded for types that are not specializations of &lt;code&gt;std::atomic&lt;/code&gt;, but are able to guarantee atomicity. The only such type in the standard library is &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Hay equivalentes de plantilla de funci&amp;oacute;n no miembro para todas las funciones miembro de &lt;code&gt;std::atomic&lt;/code&gt; . Esas funciones que no son miembros pueden sobrecargarse adicionalmente para tipos que no son especializaciones de &lt;code&gt;std::atomic&lt;/code&gt; , pero que pueden garantizar la atomicidad. El &amp;uacute;nico tipo de este tipo en la biblioteca est&amp;aacute;ndar es &lt;code&gt;&lt;a href=&quot;../memory/shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e79772c53f1ce2b7a68f39acb9950fc2f71b6e0" translate="yes" xml:space="preserve">
          <source>There are special rules for unqualified name lookup for class members when virtual inheritance is involved (sometimes referred to as the rules of dominance), see &lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;unqualified_lookup#Member_function_definition&lt;/a&gt;.</source>
          <target state="translated">Existen reglas especiales para la b&amp;uacute;squeda de nombres no calificados para los miembros de la clase cuando se trata de una herencia virtual (a veces referida como las reglas de dominaci&amp;oacute;n), vea &lt;a href=&quot;unqualified_lookup#Member_function_definition&quot;&gt;unqualified_lookup # Member_function_definition&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9a402f4ecfc55e94136a1e80cc1d6a5286b19956" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section, refer to individual member function pages for more detail.</source>
          <target state="translated">Todavía hay algunas inexactitudes en esta sección,refiérase a las páginas de funciones de cada miembro para más detalles.</target>
        </trans-unit>
        <trans-unit id="941295990d20765c0666a8c77b5e2c06086eb3fc" translate="yes" xml:space="preserve">
          <source>There are still a few inaccuracies in this section. Refer to individual member function pages for more detail.</source>
          <target state="translated">Todavía hay algunas inexactitudes en esta sección.Consulte las páginas de funciones de cada miembro para obtener más detalles.</target>
        </trans-unit>
        <trans-unit id="fbc45885aff604aaea2abb7208dd0c18b8bc3d95" translate="yes" xml:space="preserve">
          <source>There are three conventions of passing an allocator &lt;code&gt;alloc&lt;/code&gt; to a constructor of some type &lt;code&gt;T&lt;/code&gt;:</source>
          <target state="translated">Hay tres convenciones de pasar una &lt;code&gt;alloc&lt;/code&gt; asignador a un constructor de alg&amp;uacute;n tipo &lt;code&gt;T&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="eb2f200b57b0d8a9c6686c50668bd2b80b8b6b29" translate="yes" xml:space="preserve">
          <source>There are three types of constraints:</source>
          <target state="translated">Hay tres tipos de restricciones:</target>
        </trans-unit>
        <trans-unit id="0f09bbf4176190877beb129c86ae3e9c8e358d71" translate="yes" xml:space="preserve">
          <source>There are three types of null-terminated strings:</source>
          <target state="translated">Hay tres tipos de cuerdas con terminación nula:</target>
        </trans-unit>
        <trans-unit id="7c2a33396de83eb35e9628e69e71f05f450481e2" translate="yes" xml:space="preserve">
          <source>There are two distinct kinds of enumerations:</source>
          <target state="translated">Hay dos tipos distintos de enumeraciones:</target>
        </trans-unit>
        <trans-unit id="6f669e5024934effcd4278fb23f0f95ad252bc52" translate="yes" xml:space="preserve">
          <source>There are two exceptions from that:</source>
          <target state="translated">Hay dos excepciones a eso:</target>
        </trans-unit>
        <trans-unit id="36231641abbbc5cce8b62cf3185cc936bfddd00e" translate="yes" xml:space="preserve">
          <source>There are two kinds of implementations defined by the C++ standard:</source>
          <target state="translated">Hay dos tipos de implementaciones definidas por el estándar C++:</target>
        </trans-unit>
        <trans-unit id="e504119c92fe73e0c1cae5141f8e4e4cd1909108" translate="yes" xml:space="preserve">
          <source>There are two versions of &lt;code&gt;std::unique_ptr&lt;/code&gt;:</source>
          <target state="translated">Hay dos versiones de &lt;code&gt;std::unique_ptr&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="31bf78ac4643c55ed74c0dfba62be6194d38f599" translate="yes" xml:space="preserve">
          <source>There can be more than one definition in a program, as long as each definition appears in a different translation unit, of each of the following: class type, enumeration type, inline function with external linkage inline variable with external linkage(since C++17), class template, non-static function template, static data member of a class template, member function of a class template, partial template specialization, &lt;a href=&quot;constraints&quot;&gt;concept&lt;/a&gt;,(since C++20) as long as all of the following is true:</source>
          <target state="translated">Puede haber m&amp;aacute;s de una definici&amp;oacute;n en un programa, siempre que cada definici&amp;oacute;n aparezca en una unidad de traducci&amp;oacute;n diferente, de cada uno de los siguientes: tipo de clase, tipo de enumeraci&amp;oacute;n, funci&amp;oacute;n en l&amp;iacute;nea con enlace externo variable en l&amp;iacute;nea con enlace externo (desde C ++ 17), plantilla de clase, plantilla de funci&amp;oacute;n no est&amp;aacute;tica, miembro de datos est&amp;aacute;ticos de una plantilla de clase, funci&amp;oacute;n miembro de una plantilla de clase, especializaci&amp;oacute;n parcial de plantilla, &lt;a href=&quot;constraints&quot;&gt;concepto&lt;/a&gt; , (desde C ++ 20) siempre que se cumpla todo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="3787f2ae99932166a7dcbb82d18d8948ed35d334" translate="yes" xml:space="preserve">
          <source>There exists an atomic object M,</source>
          <target state="translated">Existe un objeto atómico M,</target>
        </trans-unit>
        <trans-unit id="79c74ac70167e62133877fbfab7ff339ffa4b43b" translate="yes" xml:space="preserve">
          <source>There exists an atomic read Y (with any memory order) in thread B</source>
          <target state="translated">Existe una lectura atómica Y (con cualquier orden de memoria)en el hilo B</target>
        </trans-unit>
        <trans-unit id="7b325c9ba4bba31055eea3a7f3839a38f5af398a" translate="yes" xml:space="preserve">
          <source>There exists an atomic write X (with any memory order) that modifies M in thread A</source>
          <target state="translated">Existe una escritura atómica X (con cualquier orden de memoria)que modifica M en el hilo A</target>
        </trans-unit>
        <trans-unit id="b5311041dd1561f12757a5b111f905e8cf9ceb71" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple &lt;code&gt;%n&lt;/code&gt; results in the same variable or, as an edge case, printing a string modified by an earlier &lt;code&gt;%n&lt;/code&gt; within the same call.</source>
          <target state="translated">Hay un &lt;a href=&quot;../../language/eval_order&quot;&gt;punto de secuencia&lt;/a&gt; despu&amp;eacute;s de la acci&amp;oacute;n de cada especificador de conversi&amp;oacute;n; esto permite almacenar m&amp;uacute;ltiples resultados &lt;code&gt;%n&lt;/code&gt; en la misma variable o, como caso l&amp;iacute;mite, imprimir una cadena modificada por un &lt;code&gt;%n&lt;/code&gt; anterior dentro de la misma llamada.</target>
        </trans-unit>
        <trans-unit id="3baee1a6a7acc4dbecfba1cab14149a6beefecea" translate="yes" xml:space="preserve">
          <source>There is a &lt;a href=&quot;../../language/eval_order&quot;&gt;sequence point&lt;/a&gt; after the action of each conversion specifier; this permits storing multiple fields in the same &quot;sink&quot; variable.</source>
          <target state="translated">Hay un &lt;a href=&quot;../../language/eval_order&quot;&gt;punto de secuencia&lt;/a&gt; despu&amp;eacute;s de la acci&amp;oacute;n de cada especificador de conversi&amp;oacute;n; esto permite almacenar m&amp;uacute;ltiples campos en la misma variable &quot;sumidero&quot;.</target>
        </trans-unit>
        <trans-unit id="ab3c5acf0d5e4ba77cc962cd2ce83a7c967eb424" translate="yes" xml:space="preserve">
          <source>There is a non-standard function named &lt;code&gt;gamma&lt;/code&gt; in various implementations, but its definition is inconsistent. For example, glibc and 4.2BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;lgamma&lt;/code&gt;, but 4.4BSD version of &lt;code&gt;gamma&lt;/code&gt; executes &lt;code&gt;tgamma&lt;/code&gt;.</source>
          <target state="translated">Hay una funci&amp;oacute;n no est&amp;aacute;ndar llamada &lt;code&gt;gamma&lt;/code&gt; en varias implementaciones, pero su definici&amp;oacute;n es inconsistente. Por ejemplo, la versi&amp;oacute;n glibc y 4.2BSD de &lt;code&gt;gamma&lt;/code&gt; ejecuta &lt;code&gt;lgamma&lt;/code&gt; , pero la versi&amp;oacute;n 4.4BSD de &lt;code&gt;gamma&lt;/code&gt; ejecuta &lt;code&gt;tgamma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9f50508274427b995c9b808fe7d2253e68aed64" translate="yes" xml:space="preserve">
          <source>There is a single total order S on all &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operations, including fences, that satisfies the following constraints:</source>
          <target state="translated">Hay un &amp;uacute;nico orden total S en todas &lt;code&gt;memory_order_seq_cst&lt;/code&gt; operaciones memory_order_seq_cst , incluidas las cercas, que satisface las siguientes restricciones:</target>
        </trans-unit>
        <trans-unit id="d4002dc28152d428b1e9f887a2afb18cb864b3ff" translate="yes" xml:space="preserve">
          <source>There is a special case for a zero-length array (&lt;code&gt;N == 0&lt;/code&gt;). In that case, &lt;code&gt;array.begin() == array.end()&lt;/code&gt;, which is some unique value. The effect of calling &lt;code&gt;front()&lt;/code&gt; or &lt;code&gt;back()&lt;/code&gt; on a zero-sized array is undefined.</source>
          <target state="translated">Hay un caso especial para una matriz de longitud cero ( &lt;code&gt;N == 0&lt;/code&gt; ). En ese caso, &lt;code&gt;array.begin() == array.end()&lt;/code&gt; , que es un valor &amp;uacute;nico. El efecto de llamar a &lt;code&gt;front()&lt;/code&gt; o &lt;code&gt;back()&lt;/code&gt; en una matriz de tama&amp;ntilde;o cero no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="4c58212f0810e755496085c2333304612a8c9ba1" translate="yes" xml:space="preserve">
          <source>There is an &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from lvalues and rvalues of array type to rvalues of pointer type: it constructs a pointer to the first element of an array. This conversion is used whenever arrays appear in context where arrays are not expected, but pointers are:</source>
          <target state="translated">Hay una &lt;a href=&quot;implicit_cast&quot;&gt;conversi&amp;oacute;n impl&amp;iacute;cita&lt;/a&gt; de valores y valores de tipo de matriz a valores de tipo de puntero: construye un puntero al primer elemento de una matriz. Esta conversi&amp;oacute;n se usa cuando las matrices aparecen en contexto donde no se esperan matrices, pero los punteros son:</target>
        </trans-unit>
        <trans-unit id="adb96efa8dd15697ca7b238b3ac30f5bc2029721" translate="yes" xml:space="preserve">
          <source>There is no &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt; from pointer type because it is impossible to distinguish a pointer obtained from array and non-array forms of &lt;code&gt;new&lt;/code&gt;.</source>
          <target state="translated">No hay &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deducci&amp;oacute;n de argumento de plantilla de clase&lt;/a&gt; del tipo de puntero porque es imposible distinguir un puntero obtenido de formas &lt;code&gt;new&lt;/code&gt; y sin matriz .</target>
        </trans-unit>
        <trans-unit id="b717a5566f4d275ca27affef23f0b5a37db23c45" translate="yes" xml:space="preserve">
          <source>There is no alternative spelling (such as &lt;code&gt;eq&lt;/code&gt;) for the equality operator &lt;code&gt;==&lt;/code&gt; because the character &lt;code&gt;=&lt;/code&gt; was present in all supported charsets.</source>
          <target state="translated">No hay una ortograf&amp;iacute;a alternativa (como &lt;code&gt;eq&lt;/code&gt; ) para el operador de igualdad &lt;code&gt;==&lt;/code&gt; porque el car&amp;aacute;cter &lt;code&gt;=&lt;/code&gt; estaba presente en todos los conjuntos de caracteres admitidos.</target>
        </trans-unit>
        <trans-unit id="6359bb2da55b35e94c9ad0b9d3423bdf850ab557" translate="yes" xml:space="preserve">
          <source>There is no guarantee that the same &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; instance will be referred to by all evaluations of the typeid expression on the same type, although &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; of those type_info objects would be identical, as would be their &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">No hay garant&amp;iacute;a de que todas las evaluaciones de la expresi&amp;oacute;n typeid en el mismo tipo hagan referencia a la misma instancia &lt;code&gt;&lt;a href=&quot;../types/type_info&quot;&gt;std::type_info&lt;/a&gt;&lt;/code&gt; , aunque &lt;code&gt;&lt;a href=&quot;../types/type_info/hash_code&quot;&gt;std::type_info::hash_code&lt;/a&gt;&lt;/code&gt; de esos objetos type_info ser&amp;iacute;a id&amp;eacute;ntico, como ser&amp;iacute;a su &lt;code&gt;&lt;a href=&quot;../types/type_index&quot;&gt;std::type_index&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46c70b420b1fd4cd4eb814c6e21ea48fec268ba0" translate="yes" xml:space="preserve">
          <source>There is no move constructor: moving from an object derived from &lt;code&gt;shared_from_this&lt;/code&gt; does not transfer its shared identity.</source>
          <target state="translated">No hay constructor de movimiento: moverse de un objeto derivado de &lt;code&gt;shared_from_this&lt;/code&gt; no transfiere su identidad compartida.</target>
        </trans-unit>
        <trans-unit id="c081f6007cfe842825dd149d42264efa0313278f" translate="yes" xml:space="preserve">
          <source>There is no non-member function equivalent of this static member constant because non-member functions take pointers to atomic types, and therefore aren't as useful in &lt;a href=&quot;../../language/constant_expression&quot;&gt;constant expressions&lt;/a&gt;.</source>
          <target state="translated">No hay una funci&amp;oacute;n no miembro equivalente de esta constante miembro est&amp;aacute;tica porque las funciones no miembro llevan punteros a tipos at&amp;oacute;micos y, por lo tanto, no son tan &amp;uacute;tiles en &lt;a href=&quot;../../language/constant_expression&quot;&gt;expresiones constantes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b70d83494235e850b17f2e48a3299bb098ff2e94" translate="yes" xml:space="preserve">
          <source>There is no portable way to define primary sort key in terms of &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; since the conversion from the collation key returned by &lt;code&gt;std::collate::transform()&lt;/code&gt; to the primary equivalence key is locale-specific, and if the user replaces the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet, that conversion is no longer known to the standard library's &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt;. Standard library specializations of &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; return an empty string unless the &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet of the currently-imbued locale was not replaced by the user, and still matches the system-supplied &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; facet), in which case &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; is executed and the sort key it produces is converted to the expected primary sort key using a locale-specific conversion.</source>
          <target state="translated">No hay una forma port&amp;aacute;til de definir la clave de ordenaci&amp;oacute;n primaria en t&amp;eacute;rminos de &lt;code&gt;&lt;a href=&quot;../../locale/locale&quot;&gt;std::locale&lt;/a&gt;&lt;/code&gt; ya que la conversi&amp;oacute;n de la clave de clasificaci&amp;oacute;n devuelta por &lt;code&gt;std::collate::transform()&lt;/code&gt; a la clave de equivalencia primaria es espec&amp;iacute;fica de la localidad, y si el usuario reemplaza la faceta &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; , esa conversi&amp;oacute;n ya no es conocida por la biblioteca est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; . Especializaciones de la biblioteca est&amp;aacute;ndar de &lt;code&gt;&lt;a href=&quot;../regex_traits&quot;&gt;std::regex_traits&lt;/a&gt;&lt;/code&gt; devuelven una cadena vac&amp;iacute;a a menos que el &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; las facetas de la configuraci&amp;oacute;n regional imbuido actualmente no fue reemplazado por el usuario, y todav&amp;iacute;a coincide con el proporcionado por el sistema &lt;code&gt;&lt;a href=&quot;../../locale/collate&quot;&gt;std::collate&lt;/a&gt;&lt;/code&gt; faceta), en cuyo caso &lt;code&gt;&lt;a href=&quot;../../locale/collate_byname&quot;&gt;std::collate_byname&lt;/a&gt;&amp;lt;charT&amp;gt;::transform(first, last)&lt;/code&gt; se ejecuta y la clave de clasificaci&amp;oacute;n que produce se convierte en la clave de clasificaci&amp;oacute;n primaria esperada mediante una conversi&amp;oacute;n espec&amp;iacute;fica de la localidad.</target>
        </trans-unit>
        <trans-unit id="3f7acf604b21fa7efd6ebb9fae0bd32cd0e76516" translate="yes" xml:space="preserve">
          <source>There is no separate tag for &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt;.</source>
          <target state="translated">No hay una etiqueta separada para &lt;a href=&quot;../named_req/contiguousiterator&quot;&gt;LegacyContiguousIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cb42e4a03c1413932f97ef53ea3df59cf6f0618f" translate="yes" xml:space="preserve">
          <source>There is no specialization for C strings. &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; produces a hash of the value of the pointer (the memory address), it does not examine the contents of any character array.</source>
          <target state="translated">No hay especializaci&amp;oacute;n para las cadenas C. &lt;code&gt;std::hash&amp;lt;const char*&amp;gt;&lt;/code&gt; produce un hash del valor del puntero (la direcci&amp;oacute;n de memoria), no examina el contenido de ninguna matriz de caracteres.</target>
        </trans-unit>
        <trans-unit id="932b5b0c5bba8ae4965a8c49c5fcc30eedb86b32" translate="yes" xml:space="preserve">
          <source>There is no standard-compliant way for the user to construct a &lt;code&gt;future_error&lt;/code&gt; prior to C++17. C++11 and C++14 depict an exposition-only public constructor taking a &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;, and some implementations provide such a constructor.</source>
          <target state="translated">No hay una forma compatible con el est&amp;aacute;ndar para que el usuario construya un &lt;code&gt;future_error&lt;/code&gt; antes de C ++ 17. C ++ 11 y C ++ 14 representan un constructor p&amp;uacute;blico de solo exposici&amp;oacute;n que toma un &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; , y algunas implementaciones proporcionan dicho constructor.</target>
        </trans-unit>
        <trans-unit id="1a76b382fdb365f1f430efc3fd3ffef21f74d56b" translate="yes" xml:space="preserve">
          <source>There is no way to explicitly specify template arguments to &lt;a href=&quot;operators&quot;&gt;overloaded operators&lt;/a&gt;, &lt;a href=&quot;cast_operator&quot;&gt;conversion functions&lt;/a&gt;, and constructors, because they are called without the use of the function name.</source>
          <target state="translated">No hay forma de especificar expl&amp;iacute;citamente argumentos de plantilla para &lt;a href=&quot;operators&quot;&gt;operadores sobrecargados&lt;/a&gt; , &lt;a href=&quot;cast_operator&quot;&gt;funciones de conversi&amp;oacute;n&lt;/a&gt; y constructores, porque se los llama sin el uso del nombre de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cfe1eeb34c7bedb3e0ea6d678c0bd6012a61623b" translate="yes" xml:space="preserve">
          <source>There is one exception: an erasure which deletes the last element of a &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Hay una excepci&amp;oacute;n: una eliminaci&amp;oacute;n que elimina el &amp;uacute;ltimo elemento de un &lt;code&gt;&lt;a href=&quot;container/deque&quot;&gt;std::deque&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="341db5eb1053e74392cf71602cdbdbaadad998bb" translate="yes" xml:space="preserve">
          <source>There is partial ordering of cv-qualifiers by the order of increasing restrictions. The type can be said</source>
          <target state="translated">Hay un ordenamiento parcial de los calificadores de CV por el orden de las restricciones crecientes.El tipo puede decirse</target>
        </trans-unit>
        <trans-unit id="89bd5d5858a6e7136749a6ba025c5ec9f6ed276d" translate="yes" xml:space="preserve">
          <source>There's no way to access the time zone pointer when &lt;code&gt;TimeZonePtr&lt;/code&gt; is a move-only type.</source>
          <target state="translated">No hay forma de acceder al puntero de zona horaria cuando &lt;code&gt;TimeZonePtr&lt;/code&gt; es un tipo de solo movimiento.</target>
        </trans-unit>
        <trans-unit id="e85687808f760523e3241d93ae510041ac781f16" translate="yes" xml:space="preserve">
          <source>Therefore, private members can be transferred to implementation as-is, and push_back can forward to an implementation that does not use T in the interface either:</source>
          <target state="translated">Por lo tanto,los miembros privados pueden ser transferidos a la implementación tal cual,y push_back puede avanzar a una implementación que tampoco utilice T en la interfaz:</target>
        </trans-unit>
        <trans-unit id="99d6d9ce6d1c6685dc210a906c540e2a567fe084" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_map to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para unordered_map para permitir la deducci&amp;oacute;n de un rango de iterador (sobrecargas (1,3-5)) y &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (sobrecargas (2,6-8)). Estas sobrecargas solo participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , ni &lt;code&gt;Hash&lt;/code&gt; ni &lt;code&gt;Pred&lt;/code&gt; satisfacen &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , y &lt;code&gt;Hash&lt;/code&gt; no es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="d838aa17089c69886e8a6da521887bdae3d66e6e" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; are provided for unordered_multimap to allow deduction from an iterator range (overloads (1,3-5)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,6-8)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para unorped_multimap para permitir la deducci&amp;oacute;n de un rango de iterador (sobrecargas (1,3-5)) y &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (sobrecargas (2,6-8)). Estas sobrecargas solo participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , ni &lt;code&gt;Hash&lt;/code&gt; ni &lt;code&gt;Pred&lt;/code&gt; satisfacen &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , y &lt;code&gt;Hash&lt;/code&gt; no es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="71a2bff7b98f49c9c4e24066b486d0981c520060" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; to allow deduction from underlying container type (overloads (1,3)) and from an iterator range (overload (2)) This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;code&gt;Allocator&lt;/code&gt;, &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (3), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para &lt;code&gt;&lt;a href=&quot;../priority_queue&quot;&gt;std::priority_queue&lt;/a&gt;&lt;/code&gt; para permitir la deducci&amp;oacute;n del tipo de contenedor subyacente (sobrecargas (1,3)) y de un rango de iterador (sobrecarga (2)) Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , &lt;code&gt;Comp&lt;/code&gt; no satisface &lt;code&gt;Allocator&lt;/code&gt; , &lt;code&gt;Container&lt;/code&gt; no satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; y, para sobrecarga (3), si &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Alloc&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e10d57340ef11936ebd04620951a44a41b981f3" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; para tener en cuenta los casos l&amp;iacute;mite que no se detectaron en las gu&amp;iacute;as de deducci&amp;oacute;n impl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="12b353145b514386eb3d03070811d07e0bad084c" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; to account for the edge cases missed by the implicit deduction guides, in particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para que &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; en cuenta los casos extremos que las gu&amp;iacute;as de deducci&amp;oacute;n impl&amp;iacute;cita omiten, en particular, los argumentos no copiables y la conversi&amp;oacute;n de matriz a puntero.</target>
        </trans-unit>
        <trans-unit id="0d7729eb7a1438721d7721c8ec45ca17c31eb830" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for multiset to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para m&amp;uacute;ltiples conjuntos para permitir la deducci&amp;oacute;n de un rango de iterador (sobrecargas (1,3)) y &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (sobrecargas (2,4)). Estas sobrecargas solo participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; y &lt;code&gt;Comp&lt;/code&gt; no satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70a6bdbef179c3a4732cac088b62e8b6f4ff8948" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for queue to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para la cola para permitir la deducci&amp;oacute;n del tipo de contenedor subyacente. Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , y &lt;code&gt;Container&lt;/code&gt; no satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; y, para sobrecarga (2), si &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5d564ca21e1c30be4928dd9500b875ed1d963057" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for set to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para permitir la deducci&amp;oacute;n de un rango de iterador (sobrecargas (1,3)) y &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (sobrecargas (2,4)). Estas sobrecargas solo participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; y &lt;code&gt;Comp&lt;/code&gt; no satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="13ef785aba459afe56d345cd56062fe469f5d0da" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for stack to allow deduction from underlying container type. This overload only participates in overload resolution if &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Container&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; and, for overload (2), if &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para la pila para permitir la deducci&amp;oacute;n del tipo de contenedor subyacente. Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , y &lt;code&gt;Container&lt;/code&gt; no satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; y, para sobrecarga (2), si &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator_v&lt;/a&gt;&amp;lt;Container, Allocator&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dafdd32c659086dffb3edda268826ae9c158e33" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_multiset to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para unordeted_multiset para permitir la deducci&amp;oacute;n de un rango de iterador (sobrecargas (1,3,4)) y &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (sobrecargas (2,5.6)). Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , ni &lt;code&gt;Hash&lt;/code&gt; ni &lt;code&gt;Pred&lt;/code&gt; satisfacen &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , &lt;code&gt;Hash&lt;/code&gt; no es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="9bb6043ae0763bf108698a03aeb652cc5820df07" translate="yes" xml:space="preserve">
          <source>These &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guides&lt;/a&gt; are provided for unordered_set to allow deduction from an iterator range (overloads (1,3,4)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,5.6)). This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, neither &lt;code&gt;Hash&lt;/code&gt; nor &lt;code&gt;Pred&lt;/code&gt; satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, &lt;code&gt;Hash&lt;/code&gt; is not an integral type.</source>
          <target state="translated">Estas &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;as de deducci&amp;oacute;n&lt;/a&gt; se proporcionan para unordered_set para permitir la deducci&amp;oacute;n de un rango de iterador (sobrecargas (1,3,4)) y &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (sobrecargas (2,5.6)). Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , ni &lt;code&gt;Hash&lt;/code&gt; ni &lt;code&gt;Pred&lt;/code&gt; satisfacen &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; , &lt;code&gt;Hash&lt;/code&gt; no es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="998a40ef4627e5e01e4248114651ccad38e51377" translate="yes" xml:space="preserve">
          <source>These &lt;code&gt;operator/&lt;/code&gt; overloads provide a conventional syntax for the creation of Gregorian calendar dates.</source>
          <target state="translated">Estos &lt;code&gt;operator/&lt;/code&gt; sobrecargas proporcionan una sintaxis convencional para la creaci&amp;oacute;n de fechas del calendario gregoriano.</target>
        </trans-unit>
        <trans-unit id="74e2c10444921183c350121d5ff7c2b2d260e16b" translate="yes" xml:space="preserve">
          <source>These algorithms cannot be used with associative containers such as &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; because ForwardIt does not dereference to a MoveAssignable type (the keys in these containers are not modifiable).</source>
          <target state="translated">Estos algoritmos no se pueden usar con contenedores asociativos como &lt;code&gt;&lt;a href=&quot;../container/set&quot;&gt;std::set&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; porque ForwardIt no hace referencia a un tipo MoveAssignable (las claves en estos contenedores no son modificables).</target>
        </trans-unit>
        <trans-unit id="dc6f538fd8e7e831a029d42e6c3295c5ce6547d3" translate="yes" xml:space="preserve">
          <source>These are the directives defined by the standard. The standard does not define behavior for other directives: they might be ignored, have some useful meaning, or cause a compile-time error. Even if otherwise ignored, they are removed from the source code when the preprocessor is done. A common non-standard extension is the directive &lt;code&gt;#warning&lt;/code&gt; which emits a user-defined message during compilation.</source>
          <target state="translated">Estas son las directivas definidas por la norma. El est&amp;aacute;ndar no define el comportamiento de otras directivas: pueden ignorarse, tener alg&amp;uacute;n significado &amp;uacute;til o causar un error en tiempo de compilaci&amp;oacute;n. Incluso si se ignora de otro modo, se eliminan del c&amp;oacute;digo fuente cuando se termina el preprocesador. Una extensi&amp;oacute;n no est&amp;aacute;ndar com&amp;uacute;n es la directiva &lt;code&gt;#warning&lt;/code&gt; que emite un mensaje definido por el usuario durante la compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ec4ebc2b939ff4d66f10267f6f032b0dd31634b9" translate="yes" xml:space="preserve">
          <source>These are type categories defined by the core language. They are included here as named requirements only for consistency.</source>
          <target state="translated">Estas son categorías de tipos definidas por el lenguaje central.Se incluyen aquí como requisitos nombrados sólo por coherencia.</target>
        </trans-unit>
        <trans-unit id="41f69a0ad4c5384189f3c5f07ef1de6088dafb43" translate="yes" xml:space="preserve">
          <source>These attributes may be applied to labels and statements (other than declaration-statements). They may not be simultaneously applied to the same label or statement.</source>
          <target state="translated">Estos atributos pueden aplicarse a las etiquetas y declaraciones (distintas de las declaraciones).No pueden aplicarse simultáneamente a la misma etiqueta o declaración.</target>
        </trans-unit>
        <trans-unit id="f1b3468a96579cdd8f43ddee81097dc1e729403b" translate="yes" xml:space="preserve">
          <source>These bullets describe situations that cannot arise in C++ and therefore are omitted from the discussion above. In C, aggregate copy and assignment access the aggregate object as a whole. But in C++ such actions are always performed through a member function call, which accesses the individual subobjects rather than the entire object (or, in the case of unions, copies the object representation, i.e., via &lt;code&gt;unsigned char&lt;/code&gt;). See &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;core issue 2051&lt;/a&gt;.</source>
          <target state="translated">Estas vi&amp;ntilde;etas describen situaciones que no pueden surgir en C ++ y, por lo tanto, se omiten de la discusi&amp;oacute;n anterior. En C, la copia agregada y la asignaci&amp;oacute;n acceden al objeto agregado como un todo. Pero en C ++ tales acciones siempre se realizan a trav&amp;eacute;s de una llamada a la funci&amp;oacute;n miembro, que accede a los subobjetos individuales en lugar de a todo el objeto (o, en el caso de las uniones, copia la representaci&amp;oacute;n del objeto, es decir, a trav&amp;eacute;s de caracteres &lt;code&gt;unsigned char&lt;/code&gt; ). Ver &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#2051&quot;&gt;problema central 2051&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2e85ea89bf8851056faa66c86c8a89f763163c" translate="yes" xml:space="preserve">
          <source>These classes encapsulate a regular expression and the results of matching a regular expression within a target sequence of characters.</source>
          <target state="translated">Estas clases encapsulan una expresión regular y los resultados de la coincidencia de una expresión regular dentro de una secuencia de caracteres objetivo.</target>
        </trans-unit>
        <trans-unit id="5187a740adf841afb17f5f37d5efc0eafaa7fbe7" translate="yes" xml:space="preserve">
          <source>These constants are duplicated from &lt;code&gt;std::regex_constants&lt;/code&gt;:</source>
          <target state="translated">Estas constantes est&amp;aacute;n duplicadas de &lt;code&gt;std::regex_constants&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="19ba3734849d9efa52a071b6c74031883732795a" translate="yes" xml:space="preserve">
          <source>These constants provide a portable way to access the L1 data cache line size.</source>
          <target state="translated">Estas constantes proporcionan una forma portátil de acceder al tamaño de la línea de caché de datos L1.</target>
        </trans-unit>
        <trans-unit id="5aeef84fd68b04dfd62540295b4e58ffbc1ad7c5" translate="yes" xml:space="preserve">
          <source>These constructors additionally do not participate in overload resolution if the expression &lt;code&gt;d(ptr)&lt;/code&gt; is not well-formed, or if &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, estos constructores no participan en la resoluci&amp;oacute;n de sobrecarga si la expresi&amp;oacute;n &lt;code&gt;d(ptr)&lt;/code&gt; no est&amp;aacute; bien formada o si &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cd12e66c1b571e2605eacf313edfc5ca3855042" translate="yes" xml:space="preserve">
          <source>These constructors are typically called by the constructors of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Estos constructores generalmente son llamados por los constructores de &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ee89583b6197fe5f3d8e0eab3b74e26c4d4069c" translate="yes" xml:space="preserve">
          <source>These conversions are purely lexical. They do not check that the paths exist, do not follow symlinks, and do not access the filesystem at all. For symlink-following counterparts of &lt;code&gt;lexically_relative&lt;/code&gt; and &lt;code&gt;lexically_proximate&lt;/code&gt;, see &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;relative&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../relative&quot;&gt;&lt;code&gt;proximate&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Estas conversiones son puramente l&amp;eacute;xicas. No verifican que existan las rutas, no siguen enlaces simb&amp;oacute;licos y no acceden en absoluto al sistema de archivos. Para las contrapartes de enlace simb&amp;oacute;lico de &lt;code&gt;lexically_relative&lt;/code&gt; y &lt;code&gt;lexically_proximate&lt;/code&gt; , vea &lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;relative&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../relative&quot;&gt; &lt;code&gt;proximate&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3b066eecc1428c4afc05b8473b0ce8b6682781dc" translate="yes" xml:space="preserve">
          <source>These conversions model the type conversion applied to all function arguments when passed by value.</source>
          <target state="translated">Estas conversiones modelan el tipo de conversión que se aplica a todos los argumentos de las funciones cuando se pasan por valor.</target>
        </trans-unit>
        <trans-unit id="1f828b6e7c5612d3683245cf9a5d3fa76a3dbee3" translate="yes" xml:space="preserve">
          <source>These fictional constructors are public members of the hypothetical class type. They are explicit if the guide was formed from an explicit constructor. If overload resolution fails, the program is ill-formed. Otherwise, the return type of the selected &lt;code&gt;F&lt;/code&gt; template specialization becomes the deduced class template specialization.</source>
          <target state="translated">Estos constructores ficticios son miembros p&amp;uacute;blicos del tipo de clase hipot&amp;eacute;tica. Son expl&amp;iacute;citos si la gu&amp;iacute;a se form&amp;oacute; a partir de un constructor expl&amp;iacute;cito. Si la resoluci&amp;oacute;n de sobrecarga falla, el programa est&amp;aacute; mal formado. De lo contrario, el tipo de retorno de la especializaci&amp;oacute;n de plantilla &lt;code&gt;F&lt;/code&gt; seleccionada se convierte en la especializaci&amp;oacute;n de plantilla de clase deducida.</target>
        </trans-unit>
        <trans-unit id="9e1185e2ec5ad6dc826827fc0bc8b26aeb766d26" translate="yes" xml:space="preserve">
          <source>These function templates are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">Estas plantillas de funci&amp;oacute;n no son visibles para la &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; ordinaria &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;no calificada&lt;/a&gt; o calificada , y solo se pueden encontrar mediante la &lt;a href=&quot;../../language/adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; cuando &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; es una clase asociada de los argumentos. Esto evita las conversiones no deseadas en presencia de un &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="043baecb502250e4140c666b26e06dd43b796356" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_sys&lt;/code&gt; and &lt;code&gt;from_sys&lt;/code&gt;.</source>
          <target state="translated">Estas plantillas de funciones son opcionales: una implementaci&amp;oacute;n puede optar por proporcionar &lt;code&gt;to_sys&lt;/code&gt; y &lt;code&gt;from_sys&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7805c9adadba15da9ce1789282d1fdeae7db0ab" translate="yes" xml:space="preserve">
          <source>These function templates are optional: an implementation may choose to instead provide &lt;code&gt;to_utc&lt;/code&gt; and &lt;code&gt;from_utc&lt;/code&gt;.</source>
          <target state="translated">Estas plantillas de funciones son opcionales: una implementaci&amp;oacute;n puede optar por proporcionar &lt;code&gt;to_utc&lt;/code&gt; y &lt;code&gt;from_utc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7487a9c951b04abd0ea64aae0657bd6c80e75211" translate="yes" xml:space="preserve">
          <source>These function templates behave as if they.</source>
          <target state="translated">Estas plantillas de funciones se comportan como si...</target>
        </trans-unit>
        <trans-unit id="419d5c3b82807fda6edd67b01bc6da49f1a27023" translate="yes" xml:space="preserve">
          <source>These functions are defined in terms of member functions of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Estas funciones se definen en t&amp;eacute;rminos de funciones miembro de &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="706bfb2aebd27a90d3a3878dfe394992ff31ffb1" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt; , and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">Estas funciones no son visibles para la &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; ordinaria &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;no calificada&lt;/a&gt; o calificada , y solo se pueden encontrar mediante la &lt;a href=&quot;../../language/adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; cuando &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; es una clase asociada de los argumentos. Esto evita las conversiones no deseadas en presencia de un &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f3e6ab375e463f1612d61a87d214ea836c037d5" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">Estas funciones no son visibles para la &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; ordinaria &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;no calificada&lt;/a&gt; o calificada , y solo se pueden encontrar mediante la &lt;a href=&quot;../../language/adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; cuando &lt;code&gt;std::basic_string_view&amp;lt;CharT, Traits&amp;gt;&lt;/code&gt; es una clase asociada de los argumentos.</target>
        </trans-unit>
        <trans-unit id="71d3bc1bc9cc67bb93448628acb0478629973b75" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">Estas funciones no son visibles para la &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; ordinaria &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;no calificada&lt;/a&gt; o calificada , y solo se pueden encontrar mediante la &lt;a href=&quot;../../language/adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; cuando &lt;code&gt;std::span&amp;lt;T, Extent&amp;gt;&lt;/code&gt; es una clase asociada de los argumentos.</target>
        </trans-unit>
        <trans-unit id="9cafa0c4c816e506567effd571a10a76ae52acd3" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">Estas funciones no son visibles para la &lt;a href=&quot;../language/qualified_lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; ordinaria &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;no calificada&lt;/a&gt; o calificada , y solo se pueden encontrar mediante la &lt;a href=&quot;../language/adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; cuando &lt;code&gt;std::ranges::empty_view&amp;lt;T&amp;gt;&lt;/code&gt; es una clase asociada de los argumentos.</target>
        </trans-unit>
        <trans-unit id="13ae74af435260e5a8fc58a9b3b8f8b649c48761" translate="yes" xml:space="preserve">
          <source>These functions are not visible to ordinary &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; is an associated class of the arguments.</source>
          <target state="translated">Estas funciones no son visibles para la &lt;a href=&quot;../language/qualified_lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; ordinaria &lt;a href=&quot;../language/unqualified_lookup&quot;&gt;no calificada&lt;/a&gt; o calificada , y solo se pueden encontrar mediante la &lt;a href=&quot;../language/adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; cuando &lt;code&gt;std::ranges::ref_view&amp;lt;R&amp;gt;&lt;/code&gt; es una clase asociada de los argumentos.</target>
        </trans-unit>
        <trans-unit id="96489aaabbabce3adba15d3840295fb8191f8911" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;span&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">Estas funciones se proporcionan para hacer que los valores de &lt;code&gt;span&lt;/code&gt; funcionen con &lt;code&gt;std::ranges::begin&lt;/code&gt; y &lt;code&gt;std::ranges::end&lt;/code&gt; Range :: end , que rechazan los argumentos rvalue de forma predeterminada para evitar que el iterador cuelgue.</target>
        </trans-unit>
        <trans-unit id="5f45f69461ef9381b69148d33ccefcd3eafb9116" translate="yes" xml:space="preserve">
          <source>These functions are provided to make &lt;code&gt;string_view&lt;/code&gt; rvalues work with &lt;code&gt;std::ranges::begin&lt;/code&gt; and &lt;code&gt;std::ranges::end&lt;/code&gt;, which reject rvalue arguments by default in order to prevent dangling iterator.</source>
          <target state="translated">Estas funciones se proporcionan para hacer que los &lt;code&gt;string_view&lt;/code&gt; funcionen con &lt;code&gt;std::ranges::begin&lt;/code&gt; Range :: begin y &lt;code&gt;std::ranges::end&lt;/code&gt; Range :: end , que rechazan los argumentos rvalue de forma predeterminada para evitar que el iterador cuelgue.</target>
        </trans-unit>
        <trans-unit id="be2ae68f22369098426dd815dea838deb2f9b140" translate="yes" xml:space="preserve">
          <source>These functions are typically implemented using mutexes, stored in a global hash table where the pointer value is used as the key.</source>
          <target state="translated">Estas funciones se implementan típicamente usando mutexes,almacenados en una tabla hash global en la que el valor del puntero se usa como clave.</target>
        </trans-unit>
        <trans-unit id="326f105b45787866cfe222f982d0d9e27243f9ff" translate="yes" xml:space="preserve">
          <source>These functions are used to apply the regular expression encapsulated in a regex to a target sequence of characters.</source>
          <target state="translated">Estas funciones se utilizan para aplicar la expresión regular encapsulada en una regex a una secuencia de caracteres objetivo.</target>
        </trans-unit>
        <trans-unit id="7585335f42669921d2b1bf3e543316f127948a1e" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid or if there is a size mismatch. Specifically:</source>
          <target state="translated">Estas funciones no participan en la resolución de sobrecargas (o,para el operador de asignación de copias,se define como borrado)si alguna operación de asignación requerida es inválida o si hay un desajuste de tamaño.En concreto:</target>
        </trans-unit>
        <trans-unit id="d30d68da83412d7ae98ce606334319e3d70b73d8" translate="yes" xml:space="preserve">
          <source>These functions do not participate in overload resolution (or, for the copy assignment operator, is defined as deleted) if any required assignment operation is invalid. Specifically:</source>
          <target state="translated">Estas funciones no participan en la resolución de sobrecargas (o,para el operador de asignación de copias,se define como borrado)si alguna operación de asignación requerida es inválida.En concreto:</target>
        </trans-unit>
        <trans-unit id="cafe750e84a77bd66ed9b0e48c90443f0b94fd28" translate="yes" xml:space="preserve">
          <source>These functions do not throw exceptions.</source>
          <target state="translated">Estas funciones no hacen excepciones.</target>
        </trans-unit>
        <trans-unit id="6ee20f7717337989ef84b3eb0d3af4c0f3efbcb1" translate="yes" xml:space="preserve">
          <source>These functions effectively yield an approximation of the meaning of the argument path &lt;code&gt;p&lt;/code&gt; in an environment where &lt;code&gt;*this&lt;/code&gt; is the starting directory.</source>
          <target state="translated">Estas funciones efectivamente producen una aproximaci&amp;oacute;n del significado de la ruta de argumento &lt;code&gt;p&lt;/code&gt; en un entorno donde &lt;code&gt;*this&lt;/code&gt; es el directorio de inicio.</target>
        </trans-unit>
        <trans-unit id="b7da2559e16d851f64895f9b8ce4e64008d143d3" translate="yes" xml:space="preserve">
          <source>These functions provide access to the program-wide time zone database.</source>
          <target state="translated">Estas funciones proporcionan acceso a la base de datos de zonas horarias de todo el programa.</target>
        </trans-unit>
        <trans-unit id="e5ab52d07da85043f4b5804364445cb1d17fd3ed" translate="yes" xml:space="preserve">
          <source>These functions take a result of 3-way comparison and convert it to the result of one of the six relational operators.</source>
          <target state="translated">Estas funciones toman el resultado de la comparación de 3 vías y lo convierten en el resultado de uno de los seis operadores relacionales.</target>
        </trans-unit>
        <trans-unit id="09dc533f744ccd968da17e107b1a623a70147eb2" translate="yes" xml:space="preserve">
          <source>These functions were deprecated in favor of the specializations of the &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; template: &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Estas funciones quedaron en desuso en favor de las especializaciones de la plantilla &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; : &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&amp;lt;&lt;a href=&quot;../weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e8ebef2701474b9ea6a2624b079221ae9fed097b" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; classes: If S is one of the standard basic_string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">Estos hashes son iguales a los hash de las clases &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; correspondientes : si S es uno de los tipos est&amp;aacute;ndar de basic_string, SV es el tipo de vista de cadena correspondiente y s es un objeto de tipo S, entonces &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04c0518ba136c51c78f2d27b7888f66813a53b9f" translate="yes" xml:space="preserve">
          <source>These hashes equal the hashes of corresponding &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; classes: If S is one of these string types, SV is the corresponding string view type, and s is an object of type S, then &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt;.</source>
          <target state="translated">Estos hashes son iguales a los hash de las clases &lt;code&gt;&lt;a href=&quot;../basic_string_view&quot;&gt;std::basic_string_view&lt;/a&gt;&lt;/code&gt; correspondientes : si S es uno de estos tipos de cadena, SV es el tipo de vista de cadena correspondiente y s es un objeto de tipo S, entonces &lt;code&gt;&lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;S&amp;gt;()(s) == &lt;a href=&quot;../../utility/hash&quot;&gt;std::hash&lt;/a&gt;&amp;lt;SV&amp;gt;()(SV(s))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="378bbcb4a72a73dada77e96ee58fc0765cdcf81d" translate="yes" xml:space="preserve">
          <source>These headers are allowed to also declare the same names in the &lt;code&gt;std&lt;/code&gt; namespace, and the corresponding &lt;code&gt;cxxx&lt;/code&gt; headers are allowed to also declare the same names in the global namespace: including &amp;lt;cstdlib&amp;gt; definitely provides &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; and may also provide &lt;code&gt;::malloc&lt;/code&gt;. Including &amp;lt;stdlib.h&amp;gt; definitely provides &lt;code&gt;::malloc&lt;/code&gt; and may also provide &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;. This applies even to functions and function overloads that are not part of C standard library.</source>
          <target state="translated">Estos encabezados tambi&amp;eacute;n pueden declarar los mismos nombres en el &lt;code&gt;std&lt;/code&gt; nombres &lt;code&gt;cxxx&lt;/code&gt; , y los encabezados cxxx correspondientes tambi&amp;eacute;n pueden declarar los mismos nombres en el espacio de nombres global: incluyendo &amp;lt;cstdlib&amp;gt; definitivamente proporciona &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; y tambi&amp;eacute;n puede proporcionar &lt;code&gt;::malloc&lt;/code&gt; . Incluyendo &amp;lt;stdlib.h&amp;gt; definitivamente proporciona &lt;code&gt;::malloc&lt;/code&gt; y tambi&amp;eacute;n puede proporcionar &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; . Esto se aplica incluso a funciones y sobrecargas de funciones que no forman parte de la biblioteca est&amp;aacute;ndar de C.</target>
        </trans-unit>
        <trans-unit id="9c301ca8ee91cc2dc03b93b934d87b55d872e6ac" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Se requiere que estos tipos de miembros que se obtenga heredando de &lt;code&gt;&lt;a href=&quot;../iterator/iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;../iterator/iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="269f91543a7d747d3318687896f196744a919ccf" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Se requiere que estos tipos de miembro de obtenerse heredando de &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt; &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::iterator_category&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::value_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::difference_type&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::pointer&lt;br/&gt; , &lt;a href=&quot;iterator_traits&quot;&gt;std::iterator_traits&lt;/a&gt;&amp;lt;Iter&amp;gt;::reference&lt;br/&gt; &amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b52b486a05c84f8a4581d34abd369500f9977646" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Estos tipos de miembros deben obtenerse heredando de &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, CharT, Traits::off_type, /* unspecified, usually CharT* */, CharT&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a01f1d5ca0fbf0d6be5d6ec44fedf3a57f36c70d" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Es necesario obtener estos tipos de miembros heredando de &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::input_iterator_tag&lt;/a&gt;, T, Distance, const T*, const T&amp;amp;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae3da083cb674670645135b104ff6e1e31af7384" translate="yes" xml:space="preserve">
          <source>These member types are required to be obtained by inheriting from &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Se requiere que estos tipos de miembros que se obtenga heredando de &lt;code&gt;&lt;a href=&quot;iterator&quot;&gt;std::iterator&lt;/a&gt;&amp;lt;&lt;a href=&quot;iterator_tags&quot;&gt;std::output_iterator_tag&lt;/a&gt;, void, void, void, void&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6dd91df6ca3cc382c9fe0e450bbf5c087b01c8bc" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">Estas funciones que no son miembros permiten el uso de &lt;code&gt;directory_iterator&lt;/code&gt; con rangos basados ​​en bucles.</target>
        </trans-unit>
        <trans-unit id="d44ff77d7541183f5d7e43423582626b5049a546" translate="yes" xml:space="preserve">
          <source>These non-member functions enable the use of &lt;code&gt;recursive_directory_iterator&lt;/code&gt;s with range-based for loops.</source>
          <target state="translated">Estas funciones que no son miembros permiten el uso de &lt;code&gt;recursive_directory_iterator&lt;/code&gt; s con loops basados ​​en rangos.</target>
        </trans-unit>
        <trans-unit id="f216125f2ad7bca05acbed754c42e867a1a09cab" translate="yes" xml:space="preserve">
          <source>These non-member functions provide a generic interface for containers, plain arrays, and &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Estas funciones que no son miembros proporcionan una interfaz gen&amp;eacute;rica para contenedores, matrices simples y &lt;code&gt;&lt;a href=&quot;utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6245e0fb4125a31e0f987895270819c57ced919" translate="yes" xml:space="preserve">
          <source>These objects are guaranteed to be initialized during or before the first time an object of type &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; is constructed and are available for use in the constructors and destructors of static objects with &lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;ordered initialization&lt;/a&gt; (as long as &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; is included before the object is defined).</source>
          <target state="translated">Se garantiza que estos objetos se inicializar&amp;aacute;n durante o antes de la primera vez que se construye un objeto de tipo &lt;code&gt;&lt;a href=&quot;ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; y est&amp;aacute;n disponibles para su uso en los constructores y destructores de objetos est&amp;aacute;ticos con &lt;a href=&quot;../language/initialization#Non-local_variables&quot;&gt;inicializaci&amp;oacute;n ordenada&lt;/a&gt; (siempre que &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; sea incluido antes de definir el objeto).</target>
        </trans-unit>
        <trans-unit id="e1ea5b16593fd62c406fa74578d8a51e69297d84" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">Estos operadores se declaran en el espacio de nombres &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; , donde tanto &lt;code&gt;literals&lt;/code&gt; como &lt;code&gt;chrono_literals&lt;/code&gt; son espacios de nombres en l&amp;iacute;nea. Se puede acceder a estos operadores &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; y &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c775ca0f064f8efbb0eebd72489c895fca0cd5d9" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::complex_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;complex_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::complex_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt;.</source>
          <target state="translated">Estos operadores se declaran en el espacio de nombres &lt;code&gt;std::literals::complex_literals&lt;/code&gt; , donde tanto &lt;code&gt;literals&lt;/code&gt; como &lt;code&gt;complex_literals&lt;/code&gt; son espacios de nombres en l&amp;iacute;nea. El acceso a estos operadores se puede obtener &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::complex_literals&lt;/code&gt; y &lt;code&gt;using namespace std::literals::complex_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23ceae8d0ac1ad1f53f34bde5fef4212a07b1d5a" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt;.</source>
          <target state="translated">Estos operadores se declaran en el espacio de nombres &lt;code&gt;std::literals::string_literals&lt;/code&gt; , donde tanto &lt;code&gt;literals&lt;/code&gt; como &lt;code&gt;string_literals&lt;/code&gt; son espacios de nombres en l&amp;iacute;nea. El acceso a estos operadores se puede obtener &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::string_literals&lt;/code&gt; y &lt;code&gt;using namespace std::literals::string_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37f431af515778abb156bc8a341491c98c563acc" translate="yes" xml:space="preserve">
          <source>These operators are declared in the namespace &lt;code&gt;std::literals::string_view_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;string_view_literals&lt;/code&gt; are inline namespaces. Access to these operators can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt;.</source>
          <target state="translated">Estos operadores se declaran en el espacio de nombres &lt;code&gt;std::literals::string_view_literals&lt;/code&gt; , donde tanto &lt;code&gt;literals&lt;/code&gt; como &lt;code&gt;string_view_literals&lt;/code&gt; son espacios de nombres en l&amp;iacute;nea. El acceso a estos operadores se puede obtener &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::string_view_literals&lt;/code&gt; y &lt;code&gt;using namespace std::literals::string_view_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be85bd7cbe4be2517bbbe6791661ad5c07a4cbe3" translate="yes" xml:space="preserve">
          <source>These operators are sometimes implemented as &lt;a href=&quot;friend&quot;&gt;friend functions&lt;/a&gt;.</source>
          <target state="translated">Estos operadores a veces se implementan como &lt;a href=&quot;friend&quot;&gt;funciones de amigo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="71b614f00aac3b3aedb1ef8cf1ee4d989be39411" translate="yes" xml:space="preserve">
          <source>These operators were not &lt;code&gt;constexpr&lt;/code&gt; in C++11, this was corrected in C++14.</source>
          <target state="translated">Estos operadores no fueron &lt;code&gt;constexpr&lt;/code&gt; en C ++ 11, esto se corrigi&amp;oacute; en C ++ 14.</target>
        </trans-unit>
        <trans-unit id="86bd9326b779710e8e7e30da617be0d3ac76c4df" translate="yes" xml:space="preserve">
          <source>These overloads do not participate in overload resolution unless the following conditions are met:</source>
          <target state="translated">Estas sobrecargas no participan en la resolución de la sobrecarga a menos que se cumplan las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="e48cfeb3277137050ec5b9718b8d37fe7f54cb7e" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type.</source>
          <target state="translated">Estas sobrecargas solo participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;Deleter&lt;/code&gt; no es un tipo de puntero.</target>
        </trans-unit>
        <trans-unit id="88f134a2bed08d434e838bcdda34ccb397f8eca8" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if the corresponding &lt;code&gt;from_stream&lt;/code&gt; expression is well-formed.</source>
          <target state="translated">Estas sobrecargas solo participan en la resoluci&amp;oacute;n de sobrecarga si la expresi&amp;oacute;n &lt;code&gt;from_stream&lt;/code&gt; correspondiente est&amp;aacute; bien formada.</target>
        </trans-unit>
        <trans-unit id="a2d116b1f38656e4ef14e8e4c82c85d94f84a468" translate="yes" xml:space="preserve">
          <source>These overloads only participate in overload resolution if.</source>
          <target state="translated">Estas sobrecargas sólo participan en la resolución de la sobrecarga si.</target>
        </trans-unit>
        <trans-unit id="78f7dc8ed866031cd5d45fb8e30c10dc7cab0d38" translate="yes" xml:space="preserve">
          <source>These pair-wise comparisons are applied to all viable functions. If exactly one viable function is better than all others, overload resolution succeeds and this function is called. Otherwise, compilation fails.</source>
          <target state="translated">Estas comparaciones de pares se aplican a todas las funciones viables.Si exactamente una función viable es mejor que todas las demás,la resolución de la sobrecarga tiene éxito y se llama a esta función.De lo contrario,la compilación falla.</target>
        </trans-unit>
        <trans-unit id="87d3e33f926d43ebf3e0bc3d2ed5785d5f7e359f" translate="yes" xml:space="preserve">
          <source>These pointer arithmetic operators allow pointers to satisfy the &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; requirements.</source>
          <target state="translated">Estos operadores aritm&amp;eacute;ticos de puntero permiten que los punteros satisfagan los requisitos de &lt;a href=&quot;../named_req/randomaccessiterator&quot;&gt;LegacyRandomAccessIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="91cc6d32c62a3af187353d24cb8355a046134850" translate="yes" xml:space="preserve">
          <source>These specializations make it possible to use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt;). To use &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; with other character types (for example, &lt;code&gt;char32_t&lt;/code&gt;), a user-provided trait class must be used.</source>
          <target state="translated">Estas especializaciones permiten utilizar &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; (tambi&amp;eacute;n conocido como &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::regex&lt;/a&gt;&lt;/code&gt; ) y &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; (tambi&amp;eacute;n conocido como &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::wregex&lt;/a&gt;&lt;/code&gt; ). Para usar &lt;code&gt;&lt;a href=&quot;basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; con otros tipos de caracteres (por ejemplo, &lt;code&gt;char32_t&lt;/code&gt; ), se debe usar una clase de rasgo proporcionada por el usuario.</target>
        </trans-unit>
        <trans-unit id="8fb1d3f8496237287e2630d9516276eb8186eeef" translate="yes" xml:space="preserve">
          <source>These transformation traits were required</source>
          <target state="translated">Estos rasgos de transformación eran necesarios</target>
        </trans-unit>
        <trans-unit id="25f1f4bdd72a09c080801d8fffb8ec4bf62a753c" translate="yes" xml:space="preserve">
          <source>These two alias templates are used by some &lt;a href=&quot;../algorithm/ranges&quot;&gt;constrained algorithms&lt;/a&gt; to avoid returning potentially dangling iterators or views.</source>
          <target state="translated">Algunos &lt;a href=&quot;../algorithm/ranges&quot;&gt;algoritmos restringidos&lt;/a&gt; utilizan estas dos plantillas de alias para evitar devolver iteradores o vistas potencialmente colgantes.</target>
        </trans-unit>
        <trans-unit id="c7a8b1fbd19de341e5ad49bc78a2acbfda770aec" translate="yes" xml:space="preserve">
          <source>These type transformations honor reference collapse rules:</source>
          <target state="translated">Estas transformaciones de tipo honran las reglas de colapso de referencia:</target>
        </trans-unit>
        <trans-unit id="dbcace5dd757886bde993d55984f6189eef2a5ad" translate="yes" xml:space="preserve">
          <source>These values are constants, and do not reflect the changes to the rounding made by &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt;. The changed values may be obtained from &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Estos valores son constantes y no reflejan los cambios en el redondeo realizados por &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fesetround&lt;/a&gt;&lt;/code&gt; . Los valores modificados se pueden obtener de &lt;code&gt;&lt;a href=&quot;../climits/flt_rounds&quot;&gt;FLT_ROUNDS&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../numeric/fenv/feround&quot;&gt;std::fegetround&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce671f14cf50f53efd465a7781656ad990f4484e" translate="yes" xml:space="preserve">
          <source>They are commonly used as a convenient shortcut for long or deeply-nested namespaces.</source>
          <target state="translated">Se utilizan comúnmente como un atajo conveniente para los espacios de nombres largos o profundamente anidados.</target>
        </trans-unit>
        <trans-unit id="0c8a84aed3ced580611d15354b0869a722fa11d7" translate="yes" xml:space="preserve">
          <source>They are used to specify locking strategies for &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se utilizan para especificar estrategias de bloqueo para &lt;code&gt;&lt;a href=&quot;lock_guard&quot;&gt;std::lock_guard&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;shared_lock&quot;&gt;std::shared_lock&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11cfa3f63f9b9843169a75987765b90b1df36aef" translate="yes" xml:space="preserve">
          <source>They can also be used to implement pass-by-reference semantics in function calls:</source>
          <target state="translated">También se pueden utilizar para implementar la semántica de paso por referencia en las llamadas a funciones:</target>
        </trans-unit>
        <trans-unit id="404264233979032de1c13fb29f764da6094435a2" translate="yes" xml:space="preserve">
          <source>Third version</source>
          <target state="translated">Tercera versión</target>
        </trans-unit>
        <trans-unit id="674677ba31e30e4e6af559bc6fc67687b54c0a70" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; to allow deduction from an iterator range.</source>
          <target state="translated">Esta &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para &lt;code&gt;&lt;a href=&quot;../basic_regex&quot;&gt;std::basic_regex&lt;/a&gt;&lt;/code&gt; para permitir la deducci&amp;oacute;n de un rango de iterador.</target>
        </trans-unit>
        <trans-unit id="4c01d9032d07a333deef547c5311682cb32b0369" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; to allow deduction from array and size (note that deduction from pointer and size is covered by the implicit guides).</source>
          <target state="translated">Esta &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para &lt;code&gt;&lt;a href=&quot;../valarray&quot;&gt;std::valarray&lt;/a&gt;&lt;/code&gt; para permitir la deducci&amp;oacute;n de la matriz y el tama&amp;ntilde;o (tenga en cuenta que la deducci&amp;oacute;n del puntero y el tama&amp;ntilde;o est&amp;aacute; cubierta por las gu&amp;iacute;as impl&amp;iacute;citas).</target>
        </trans-unit>
        <trans-unit id="080faae34fcef190f2de9f444682b5ad95d98c79" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for deque to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Esta &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para permitir la deducci&amp;oacute;n de un rango de iterador. Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; y &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1a6452884a208e722e9625cf9199c504d50511f4" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for forward_list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Esta &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para forward_list para permitir la deducci&amp;oacute;n de un rango de iterador. Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; y &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="491ded200502330a3077bffc8f20aba48e33a32f" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for list to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Esta &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para la lista para permitir la deducci&amp;oacute;n de un rango de iterador. Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; y &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d250c6703a67ce4010a480cdc0512de03c8d6af8" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for map to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Esta &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para el mapa para permitir la deducci&amp;oacute;n de un rango de iterador (sobrecargas (1,3)) y &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (sobrecargas (2,4)). Estas sobrecargas solo participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; y &lt;code&gt;Comp&lt;/code&gt; no satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="472f8efb63db0b27b39e33719d752a5b58fa4ac0" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for multimap to allow deduction from an iterator range (overloads (1,3)) and &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (overloads (2,4)). These overloads only participate in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;, and &lt;code&gt;Comp&lt;/code&gt; does not satisfy &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Esta &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para m&amp;uacute;ltiples mapas para permitir la deducci&amp;oacute;n de un rango de iterador (sobrecargas (1,3)) y &lt;code&gt;&lt;a href=&quot;../../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; (sobrecargas (2,4)). Estas sobrecargas solo participan en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; y &lt;code&gt;Comp&lt;/code&gt; no satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="404371bbe2687bcdbddb8c17f22af8568b34d514" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deduction guide&lt;/a&gt; is provided for vector to allow deduction from an iterator range. This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; and &lt;code&gt;Alloc&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;.</source>
          <target state="translated">Esta &lt;a href=&quot;../../language/deduction_guide&quot;&gt;gu&amp;iacute;a de deducci&amp;oacute;n&lt;/a&gt; se proporciona para el vector para permitir la deducci&amp;oacute;n de un rango de iterador. Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; y &lt;code&gt;Alloc&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9d19a67c2a590fb3edea166f3993c75495030081" translate="yes" xml:space="preserve">
          <source>This &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; is only defined if the capture list of the lambda-expression is empty. It is a public, constexpr,(since C++17) non-virtual, non-explicit, const noexcept(since C++14) member function of the closure object. It is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator of the lambda is an immediate function.(since C++20).</source>
          <target state="translated">Esta &lt;a href=&quot;cast_operator&quot;&gt;funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario&lt;/a&gt; solo se define si la lista de captura de la expresi&amp;oacute;n lambda est&amp;aacute; vac&amp;iacute;a. Es una funci&amp;oacute;n miembro p&amp;uacute;blica, constexpr, (desde C ++ 17) no virtual, no expl&amp;iacute;cita, const noexcept (desde C ++ 14) del objeto de cierre. Es una &lt;a href=&quot;consteval&quot;&gt;funci&amp;oacute;n inmediata&lt;/a&gt; si el operador de llamada de funci&amp;oacute;n de lambda es una funci&amp;oacute;n inmediata (desde C ++ 20).</target>
        </trans-unit>
        <trans-unit id="9dd4d9a7e5470c751564a0b43d9bb48488ca73ae" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. For control over formatting, use &lt;code&gt;std::chrono::format&lt;/code&gt;.</source>
          <target state="translated">Este &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; est&amp;aacute; destinado principalmente para el uso de depuraci&amp;oacute;n. Para controlar el formateo, use &lt;code&gt;std::chrono::format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdeeb8bd8306a58bb3de2426d5fca261070137d1" translate="yes" xml:space="preserve">
          <source>This &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; is primarily intended for debugging use. When used with non-default stream flags, the output may be surprising:</source>
          <target state="translated">Este &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; est&amp;aacute; destinado principalmente para el uso de depuraci&amp;oacute;n. Cuando se usa con indicadores de flujo no predeterminados, la salida puede ser sorprendente:</target>
        </trans-unit>
        <trans-unit id="45d5bafe4e82677bb34e8489531cf8b9395463b2" translate="yes" xml:space="preserve">
          <source>This algorithm is a more general form of &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt;, which can be expressed in terms of &lt;code&gt;std::partition_point&lt;/code&gt; with the predicate &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt;.</source>
          <target state="translated">Este algoritmo es una forma m&amp;aacute;s general de &lt;code&gt;&lt;a href=&quot;lower_bound&quot;&gt;std::lower_bound&lt;/a&gt;&lt;/code&gt; , que puede expresarse en t&amp;eacute;rminos de &lt;code&gt;std::partition_point&lt;/code&gt; con el predicado &lt;code&gt;[&amp;amp;](auto const&amp;amp; e) { return e &amp;lt; value; });&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="823f5a9d51f4a4e6c775e32f3efd9551b4b6ecbf" translate="yes" xml:space="preserve">
          <source>This algorithm is different from &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt;, not only in efficiency, but also in that this algorithm finds the</source>
          <target state="translated">Este algoritmo es diferente de &lt;code&gt;&lt;a href=&quot;../utility/pair/make_pair&quot;&gt;std::make_pair&lt;/a&gt;(&lt;a href=&quot;min_element&quot;&gt;std::min_element&lt;/a&gt;(), &lt;a href=&quot;max_element&quot;&gt;std::max_element&lt;/a&gt;())&lt;/code&gt; , no solo en eficiencia, sino tambi&amp;eacute;n en que este algoritmo encuentra el</target>
        </trans-unit>
        <trans-unit id="25bb18b7071a3878825d2611ae20fefcf112dcd2" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce less.</source>
          <target state="translated">Este algoritmo realiza una tarea similar a la de &lt;code&gt;&lt;a href=&quot;merge&quot;&gt;std::merge&lt;/a&gt;&lt;/code&gt; . Ambos consumen dos rangos de entrada ordenados y producen una salida ordenada con elementos de ambas entradas. La diferencia entre estos dos algoritmos es con el manejo de valores de ambos rangos de entrada que comparan el equivalente (ver notas en &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; ). Si apareciera alg&amp;uacute;n valor equivalente &lt;code&gt;n&lt;/code&gt; veces en el primer rango &lt;code&gt;m&lt;/code&gt; veces en el segundo, &lt;code&gt;std::merge&lt;/code&gt; generar&amp;iacute;a todas las ocurrencias &lt;code&gt;n+m&lt;/code&gt; , mientras que &lt;code&gt;std::set_union&lt;/code&gt; generar&amp;iacute;a &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; . Entonces &lt;code&gt;std::merge&lt;/code&gt; genera exactamente &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; valores std :: distance (first2, last2) y &lt;code&gt;std::set_union&lt;/code&gt; pueden producir menos.</target>
        </trans-unit>
        <trans-unit id="7d29fc2206a5224dabc98e893d9a9b64464432d3" translate="yes" xml:space="preserve">
          <source>This algorithm performs a similar task as &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; does. Both consume two sorted input ranges and produce a sorted output with elements from both inputs. The difference between these two algorithms is with handling values from both input ranges which compare equivalent (see notes on &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt;). If any equivalent values appeared &lt;code&gt;n&lt;/code&gt; times in the first range and &lt;code&gt;m&lt;/code&gt; times in the second, &lt;code&gt;std::merge&lt;/code&gt; would output all &lt;code&gt;n+m&lt;/code&gt; occurrences whereas &lt;code&gt;std::set_union&lt;/code&gt; would output &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; ones only. So &lt;code&gt;std::merge&lt;/code&gt; outputs exactly &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; values and &lt;code&gt;std::set_union&lt;/code&gt; may produce fewer.</source>
          <target state="translated">Este algoritmo realiza una tarea similar a la de &lt;code&gt;&lt;a href=&quot;set_union&quot;&gt;std::set_union&lt;/a&gt;&lt;/code&gt; . Ambos consumen dos rangos de entrada ordenados y producen una salida ordenada con elementos de ambas entradas. La diferencia entre estos dos algoritmos es con el manejo de valores de ambos rangos de entrada que comparan el equivalente (ver notas en &lt;a href=&quot;../named_req/lessthancomparable&quot;&gt;LessThanComparable&lt;/a&gt; ). Si apareciera alg&amp;uacute;n valor equivalente &lt;code&gt;n&lt;/code&gt; veces en el primer rango &lt;code&gt;m&lt;/code&gt; veces en el segundo, &lt;code&gt;std::merge&lt;/code&gt; generar&amp;iacute;a todas las ocurrencias &lt;code&gt;n+m&lt;/code&gt; , mientras que &lt;code&gt;std::set_union&lt;/code&gt; generar&amp;iacute;a &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n, m)&lt;/code&gt; . Entonces &lt;code&gt;std::merge&lt;/code&gt; genera exactamente &lt;code&gt;&lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first1, last1) + &lt;a href=&quot;../iterator/distance&quot;&gt;std::distance&lt;/a&gt;(first2, last2)&lt;/code&gt; valores std :: distance (first2, last2) y &lt;code&gt;std::set_union&lt;/code&gt; pueden producir menos.</target>
        </trans-unit>
        <trans-unit id="67039572a7b1266afd41cb596fd8e9903073b309" translate="yes" xml:space="preserve">
          <source>This allows &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt;, &lt;a href=&quot;move_operator&quot;&gt;move assignment&lt;/a&gt; operators, and other move-aware functions (e.g. &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt;) to be automatically selected when suitable.</source>
          <target state="translated">Esto permite que los &lt;a href=&quot;move_constructor&quot;&gt;constructores de movimiento&lt;/a&gt; , los operadores de &lt;a href=&quot;move_operator&quot;&gt;asignaci&amp;oacute;n de movimiento&lt;/a&gt; y otras funciones conscientes del movimiento (por ejemplo, &lt;code&gt;&lt;a href=&quot;../container/vector/push_back&quot;&gt;std::vector::push_back()&lt;/a&gt;&lt;/code&gt; ) se seleccionen autom&amp;aacute;ticamente cuando sea adecuado.</target>
        </trans-unit>
        <trans-unit id="6b23439395d3de2ec476135a3b042e5160bd72c2" translate="yes" xml:space="preserve">
          <source>This allows objects of small class types, such as &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;std::span&lt;/code&gt;, to be passed to or returned from functions in registers.</source>
          <target state="translated">Esto permite que los objetos de tipos de clase peque&amp;ntilde;os, como &lt;code&gt;&lt;a href=&quot;../numeric/complex&quot;&gt;std::complex&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;std::span&lt;/code&gt; , pasen o regresen de las funciones en los registros.</target>
        </trans-unit>
        <trans-unit id="1ba1397263db3733d0fec3f4eee183f7dd40c32d" translate="yes" xml:space="preserve">
          <source>This also makes it possible to capture by const reference, with &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; or similar.</source>
          <target state="translated">Esto tambi&amp;eacute;n permite capturar por referencia constante, con &lt;code&gt;&amp;amp;cr = &lt;a href=&quot;../utility/as_const&quot;&gt;std::as_const&lt;/a&gt;(x)&lt;/code&gt; o similar.</target>
        </trans-unit>
        <trans-unit id="b270e0b13927c9c7d55e1dcef0f35f6860aa9231" translate="yes" xml:space="preserve">
          <source>This applies even to variants of non-class types:</source>
          <target state="translated">Esto se aplica incluso a las variantes de los tipos que no son de clase:</target>
        </trans-unit>
        <trans-unit id="c7b69ba009614b0512956cea74a4d37944d632b2" translate="yes" xml:space="preserve">
          <source>This applies to the members of the class template: unless the member is used in the program, it is not instantiated, and does not require a definition.</source>
          <target state="translated">Esto se aplica a los miembros de la plantilla de clase:a menos que el miembro se utilice en el programa,no está instanciado,y no requiere una definición.</target>
        </trans-unit>
        <trans-unit id="afda8940351e810bc83ac7a0844c6ee697d190f3" translate="yes" xml:space="preserve">
          <source>This attribute applies to the name of the function being declared in function declarations only. The behavior is undefined if the function with this attribute actually returns.</source>
          <target state="translated">Este atributo se aplica al nombre de la función que se declara en las declaraciones de función solamente.El comportamiento es indefinido si la función con este atributo realmente regresa.</target>
        </trans-unit>
        <trans-unit id="a6310c0c875c2cc4202df04650e9b8684a1ea09d" translate="yes" xml:space="preserve">
          <source>This attribute can appear in the declaration of the following entities:</source>
          <target state="translated">Este atributo puede aparecer en la declaración de las siguientes entidades:</target>
        </trans-unit>
        <trans-unit id="48e9f5d2fd561ba7f787f00554eb0339866d9697" translate="yes" xml:space="preserve">
          <source>This attribute is allowed in declarations of the following names or entities:</source>
          <target state="translated">Este atributo se permite en las declaraciones de los siguientes nombres o entidades:</target>
        </trans-unit>
        <trans-unit id="bc9a88af611a842f4ad52d91eb1d0dc9725b08e4" translate="yes" xml:space="preserve">
          <source>This attribute may appear in two situations:</source>
          <target state="translated">Este atributo puede aparecer en dos situaciones:</target>
        </trans-unit>
        <trans-unit id="492617afde39ac181a5c63ce324178dcbd2c9236" translate="yes" xml:space="preserve">
          <source>This attribute must appear on the first declaration of a function or one of its parameters in any translation unit. If it is not used on the first declaration of a function or one of its parameters in another translation unit, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">Este atributo debe aparecer en la primera declaración de una función o uno de sus parámetros en cualquier unidad de traducción.Si no se utiliza en la primera declaración de una función o de uno de sus parámetros en otra unidad de traducción,el programa está mal formado;no se requiere ningún diagnóstico.</target>
        </trans-unit>
        <trans-unit id="da819209a9e30721dffd50c194d372495640b66c" translate="yes" xml:space="preserve">
          <source>This class defines the type of objects thrown as exceptions to report errors from the regular expressions library.</source>
          <target state="translated">Esta clase define el tipo de objetos lanzados como excepciones para reportar errores de la biblioteca de expresiones regulares.</target>
        </trans-unit>
        <trans-unit id="d05fe9ff7a9efe7a6be4213effba38b5678ca3d8" translate="yes" xml:space="preserve">
          <source>This class is designed for use as key in associative containers, both ordered and unordered.</source>
          <target state="translated">Esta clase está diseñada para ser utilizada como clave en contenedores asociativos,tanto ordenados como no ordenados.</target>
        </trans-unit>
        <trans-unit id="c77922f02193571f4c08570b0423206a1a325b4d" translate="yes" xml:space="preserve">
          <source>This class is used to ensure that the default C++ streams (&lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt;, etc.) are properly initialized and destructed. The class tracks how many instances of it are created and initializes the C++ streams when the first instance is constructed as well as flushes the output streams when the last instance is destructed.</source>
          <target state="translated">Esta clase se utiliza para garantizar que las secuencias predeterminadas de C ++ ( &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; , etc.) se inicialicen y destruyan correctamente. La clase realiza un seguimiento de cu&amp;aacute;ntas instancias se crean e inicializa las secuencias de C ++ cuando se construye la primera instancia, as&amp;iacute; como vac&amp;iacute;a las secuencias de salida cuando se destruye la &amp;uacute;ltima instancia.</target>
        </trans-unit>
        <trans-unit id="4782fa86482a6f5000533d5566f5443e1b31c285" translate="yes" xml:space="preserve">
          <source>This class template is the preferred comparison predicate when building associative containers with &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; as keys, that is,</source>
          <target state="translated">Esta plantilla de clase es el predicado de comparaci&amp;oacute;n preferido al crear contenedores asociativos con &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; como claves, es decir,</target>
        </trans-unit>
        <trans-unit id="d4129ee928b19fe777216b3fc0a11eb88a14da35" translate="yes" xml:space="preserve">
          <source>This class template makes the implicit character conversion functionality of &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; available for any &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta plantilla de clase hace que la funcionalidad de conversi&amp;oacute;n de caracteres impl&amp;iacute;cita de &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; est&amp;eacute; disponible para cualquier &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67af0e94f21d7e3028f080552ccfa30f81f3903f" translate="yes" xml:space="preserve">
          <source>This classification allows the following errors to be detected at the point of template definition (rather than instantiation):</source>
          <target state="translated">Esta clasificación permite detectar los siguientes errores en el momento de la definición de la plantilla (en lugar de la instanciación):</target>
        </trans-unit>
        <trans-unit id="58ce9513b35dc96e87c0d70ac154af849efb1443" translate="yes" xml:space="preserve">
          <source>This constructor does not participate in overload resolution if &lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; is the same type as &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este constructor no participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;std::decay_t&amp;lt;Function&amp;gt;&lt;/code&gt; es del mismo tipo que &lt;code&gt;&lt;a href=&quot;../thread&quot;&gt;std::thread&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a905969e8e69e6e88d275ad307f8717581731297" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Este constructor tiene el mismo efecto que &lt;code&gt;deque(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; si &lt;code&gt;InputIt&lt;/code&gt; es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="7a2d779c18396eab1ee0e06cc486a3335e7edd14" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Este constructor tiene el mismo efecto que &lt;code&gt;forward_list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; si &lt;code&gt;InputIt&lt;/code&gt; es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="11411ad8214fe6e6c7202887522fc136fe3e90db" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Este constructor tiene el mismo efecto que &lt;code&gt;list(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; si &lt;code&gt;InputIt&lt;/code&gt; es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="d0215f7826bd287562237b0c5f6bbd13fcaf0661" translate="yes" xml:space="preserve">
          <source>This constructor has the same effect as &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Este constructor tiene el mismo efecto que &lt;code&gt;vector(static_cast&amp;lt;size_type&amp;gt;(first), static_cast&amp;lt;value_type&amp;gt;(last), a)&lt;/code&gt; si &lt;code&gt;InputIt&lt;/code&gt; es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="16d9b8332d1923e6161015fdc9a2cff3bdfaa0b6" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;constexpr&lt;/code&gt; if every operation it performs is &lt;code&gt;constexpr&lt;/code&gt;. For the empty tuple &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt;, it is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">Este constructor es &lt;code&gt;constexpr&lt;/code&gt; si cada operaci&amp;oacute;n que realiza es &lt;code&gt;constexpr&lt;/code&gt; . Para la tupla vac&amp;iacute;a &lt;code&gt;&lt;a href=&quot;../tuple&quot;&gt;std::tuple&lt;/a&gt;&amp;lt;&amp;gt;&lt;/code&gt; , es &lt;code&gt;constexpr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39b96837fbee6ff8b11f2afbe55d19be8b5237f0" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for at least one &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Este constructor es &lt;code&gt;explicit&lt;/code&gt; si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible&lt;/a&gt;&amp;lt;const Ti&amp;amp;, Ti&amp;gt;::value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; para al menos un &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="533bf2fceb953a9339da3a3efe2403151289bf62" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Este constructor es &lt;code&gt;explicit&lt;/code&gt; si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U&amp;amp;&amp;amp;, T&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956eea7f4a03a0995417ca7671e86890da8c691a" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Este constructor es &lt;code&gt;explicit&lt;/code&gt; si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U1&amp;amp;&amp;amp;, first_type&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;U2&amp;amp;&amp;amp;, second_type&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00d14d163d5ca5d7a526cb55477d4d3d44718aa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Este constructor es &lt;code&gt;explicit&lt;/code&gt; si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U&amp;amp;, T&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="703819705f083463e0d7af074684609042e9b532" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Este constructor es &lt;code&gt;explicit&lt;/code&gt; si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U1&amp;amp;, first_type&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const U2&amp;amp;, second_type&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b2d388bc3de25d32e823ab3902c5cb2c7f0bb128" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Este constructor es &lt;code&gt;explicit&lt;/code&gt; si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const first_type&amp;amp;, first_type&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../types/is_convertible&quot;&gt;std::is_convertible_v&lt;/a&gt;&amp;lt;const second_type&amp;amp;, second_type&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7c083a7d9073cd96386cc41c8aa08c4631002fa1" translate="yes" xml:space="preserve">
          <source>This constructor is &lt;code&gt;explicit&lt;/code&gt; if and only if either &lt;code&gt;first_type&lt;/code&gt; or &lt;code&gt;second_type&lt;/code&gt; is not implicitly default-constructible.</source>
          <target state="translated">Este constructor es &lt;code&gt;explicit&lt;/code&gt; si y solo si &lt;code&gt;first_type&lt;/code&gt; o &lt;code&gt;second_type&lt;/code&gt; no es impl&amp;iacute;citamente construible por defecto.</target>
        </trans-unit>
        <trans-unit id="9e3f4b55350fb3f6d920bcec2b1f50c5260e2934" translate="yes" xml:space="preserve">
          <source>This constructor is ill-formed if &lt;code&gt;Deleter&lt;/code&gt; is of pointer or reference type.</source>
          <target state="translated">Este constructor est&amp;aacute; mal formado si &lt;code&gt;Deleter&lt;/code&gt; es de tipo puntero o de referencia.</target>
        </trans-unit>
        <trans-unit id="8f4ffe9c6a9e19f1b0de1f70aa1c6912c5d13790" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Este constructor solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6429d3c8a00cca9524476fd5e7bc85b284721fa1" translate="yes" xml:space="preserve">
          <source>This constructor only participates in overload resolution if all of the following is true:</source>
          <target state="translated">Este constructor sólo participa en la resolución de la sobrecarga si todo lo siguiente es cierto:</target>
        </trans-unit>
        <trans-unit id="5189004f2798523a38b087278bd624f438a82960" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Este constructor participa en la resoluci&amp;oacute;n de sobrecarga si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, U1&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, U2&amp;amp;&amp;amp;&amp;gt;&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4726fe3e137ecc9cfdc444c3524298098da680a8" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Este constructor participa en la resoluci&amp;oacute;n de sobrecarga si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;first_type, const U1&amp;amp;&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible_v&lt;/a&gt;&amp;lt;second_type, const U2&amp;amp;&amp;gt;&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b97d7fbb9211117804e8e5c015e20e35239347ae" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Este constructor participa en la resoluci&amp;oacute;n de sobrecarga si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efe7ac6a6eaa86bb5c97cb1a9afabf3305f77bd2" translate="yes" xml:space="preserve">
          <source>This constructor participates in overload resolution if and only if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Este constructor participa en la resoluci&amp;oacute;n de sobrecarga si y solo si &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;first_type&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9636e46cd99b7aa6a5346c674ec8170c547d2f3" translate="yes" xml:space="preserve">
          <source>This container is an aggregate type with the same semantics as a struct holding a &lt;a href=&quot;../language/array&quot;&gt;C-style array&lt;/a&gt;&lt;code&gt;T[N]&lt;/code&gt; as its only non-static data member. Unlike a C-style array, it doesn't decay to &lt;code&gt;T*&lt;/code&gt; automatically. As an aggregate type, it can be initialized with &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;aggregate-initialization&lt;/a&gt; given at most &lt;code&gt;N&lt;/code&gt; initializers that are convertible to &lt;code&gt;T&lt;/code&gt;: &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt;.</source>
          <target state="translated">Este contenedor es un tipo agregado con la misma sem&amp;aacute;ntica que una estructura que contiene una &lt;a href=&quot;../language/array&quot;&gt;matriz de estilo C &lt;/a&gt; &lt;code&gt;T[N]&lt;/code&gt; como su &amp;uacute;nico miembro de datos no est&amp;aacute;tico. A diferencia de una matriz de estilo C, no decae a &lt;code&gt;T*&lt;/code&gt; autom&amp;aacute;ticamente. Como tipo agregado, se puede inicializar con una inicializaci&amp;oacute;n &lt;a href=&quot;../language/aggregate_initialization&quot;&gt;agregada&lt;/a&gt; dada en la mayor&amp;iacute;a de los &lt;code&gt;N&lt;/code&gt; inicializadores que son convertibles a &lt;code&gt;T&lt;/code&gt; : &lt;code&gt;std::array&amp;lt;int, 3&amp;gt; a = {1,2,3};&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bf0aa51a2fd1da025ddbd712b50083980038a0d" translate="yes" xml:space="preserve">
          <source>This conversion models the act of reading a value from a memory location into a CPU register.</source>
          <target state="translated">Esta conversión modela el acto de leer un valor de una ubicación de memoria en un registro de la CPU.</target>
        </trans-unit>
        <trans-unit id="486e8ea678d2260d566d72fdb476e2364e350e4a" translate="yes" xml:space="preserve">
          <source>This declaration may declare &lt;a href=&quot;static&quot;&gt;static&lt;/a&gt; and non-static &lt;a href=&quot;data_members&quot;&gt;data members&lt;/a&gt; and &lt;a href=&quot;member_functions&quot;&gt;member functions&lt;/a&gt;, member &lt;a href=&quot;typedef&quot;&gt;typedefs&lt;/a&gt;, member &lt;a href=&quot;enum&quot;&gt;enumerations&lt;/a&gt;, and &lt;a href=&quot;nested_classes&quot;&gt;nested classes&lt;/a&gt;. It may also be a &lt;a href=&quot;friend&quot;&gt;friend declaration&lt;/a&gt;.</source>
          <target state="translated">Esta declaraci&amp;oacute;n puede declarar &lt;a href=&quot;data_members&quot;&gt;miembros&lt;/a&gt; y &lt;a href=&quot;member_functions&quot;&gt;funciones de&lt;/a&gt; miembro &lt;a href=&quot;static&quot;&gt;est&amp;aacute;ticos&lt;/a&gt; y no est&amp;aacute;ticos , &lt;a href=&quot;typedef&quot;&gt;definiciones de tipo de&lt;/a&gt; miembro , &lt;a href=&quot;enum&quot;&gt;enumeraciones de&lt;/a&gt; miembros y &lt;a href=&quot;nested_classes&quot;&gt;clases anidadas&lt;/a&gt; . Tambi&amp;eacute;n puede ser una &lt;a href=&quot;friend&quot;&gt;declaraci&amp;oacute;n de amigo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="790f40ee47446044b6d23c3286797ccea1e6e155" translate="yes" xml:space="preserve">
          <source>This declaration must declare a constructor, destructor, or user-defined type &lt;a href=&quot;cast_operator&quot;&gt;conversion function&lt;/a&gt;. It can only be used as part of a &lt;a href=&quot;templates&quot;&gt;template declaration&lt;/a&gt;, &lt;a href=&quot;template_specialization&quot;&gt;explicit specialization&lt;/a&gt;, or explicit instantiation.</source>
          <target state="translated">Esta declaraci&amp;oacute;n debe declarar un constructor, destructor o &lt;a href=&quot;cast_operator&quot;&gt;funci&amp;oacute;n de conversi&amp;oacute;n de&lt;/a&gt; tipo definida por el usuario . Solo se puede usar como parte de una &lt;a href=&quot;templates&quot;&gt;declaraci&amp;oacute;n de plantilla&lt;/a&gt; , &lt;a href=&quot;template_specialization&quot;&gt;especializaci&amp;oacute;n&lt;/a&gt; expl&amp;iacute;cita o instanciaci&amp;oacute;n expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="b21c4afc7d9f44a231494182ce929f3873dbd60e" translate="yes" xml:space="preserve">
          <source>This definition is treated as a definition of a namespace with unique name and a</source>
          <target state="translated">Esta definición se trata como una definición de un espacio de nombres con un nombre único y un</target>
        </trans-unit>
        <trans-unit id="f5d805f6f41052ad913a678cd3a3f6f56d5cd6ca" translate="yes" xml:space="preserve">
          <source>This destruction is empty: the members of this &lt;code&gt;basic_streambuf&lt;/code&gt; (the pointers and the locale) are destructed in accordance with the usual object destruction sequence after this destructor returns. However, since it is declared public virtual, it allows the objects that are derived from &lt;code&gt;std::basic_streambuf&lt;/code&gt; to be deleted through a pointer to base class.</source>
          <target state="translated">Esta destrucci&amp;oacute;n est&amp;aacute; vac&amp;iacute;a: los miembros de este &lt;code&gt;basic_streambuf&lt;/code&gt; (los punteros y el entorno local) se destruyen de acuerdo con la secuencia de destrucci&amp;oacute;n de objetos habitual despu&amp;eacute;s de que este destructor regrese. Sin embargo, dado que se declara p&amp;uacute;blico virtual, permite que los objetos derivados de &lt;code&gt;std::basic_streambuf&lt;/code&gt; se eliminen a trav&amp;eacute;s de un puntero a la clase base.</target>
        </trans-unit>
        <trans-unit id="566d630222759bb1a22c3aebcb32a3363161c684" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying stream buffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the stream buffers.</source>
          <target state="translated">Este destructor no realiza ninguna operaci&amp;oacute;n en el b&amp;uacute;fer de flujo subyacente ( &lt;code&gt;rdbuf()&lt;/code&gt; ): los destructores de los flujos derivados como &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; son responsables de llamar a los destructores de los b&amp;uacute;feres de flujo.</target>
        </trans-unit>
        <trans-unit id="131f49f893678b58d7f7539c38777963fe7160b1" translate="yes" xml:space="preserve">
          <source>This destructor does not perform any operation on the underlying streambuffer (&lt;code&gt;rdbuf()&lt;/code&gt;): the destructors of the derived input streams such as &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; are responsible for calling the destructors of the streambuffers.</source>
          <target state="translated">Este destructor no realiza ninguna operaci&amp;oacute;n en el streambuffer subyacente ( &lt;code&gt;rdbuf()&lt;/code&gt; ): los destructores de los flujos de entrada derivados como &lt;code&gt;&lt;a href=&quot;../basic_ifstream&quot;&gt;std::basic_ifstream&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; son responsables de llamar a los destructores de los streambuffers.</target>
        </trans-unit>
        <trans-unit id="1b99959c6ca09f07071faff9ad3d0e8aafb11452" translate="yes" xml:space="preserve">
          <source>This destructor is &lt;code&gt;virtual&lt;/code&gt; because the base class destructor, &lt;a href=&quot;../ios_base/~ios_base&quot;&gt;&lt;code&gt;ios_base::~ios_base&lt;/code&gt;&lt;/a&gt; is virtual.</source>
          <target state="translated">Este destructor es &lt;code&gt;virtual&lt;/code&gt; porque el destructor de la clase base, &lt;a href=&quot;../ios_base/~ios_base&quot;&gt; &lt;code&gt;ios_base::~ios_base&lt;/code&gt; &lt;/a&gt; es virtual.</target>
        </trans-unit>
        <trans-unit id="e7593a44c2d3c23ae4a80ac5cc6624863832641b" translate="yes" xml:space="preserve">
          <source>This destructor is trivial if &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">Este destructor es trivial si &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible_v&lt;/a&gt;&amp;lt;T_i&amp;gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todos los &lt;code&gt;T_i&lt;/code&gt; en &lt;code&gt;Types...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6df8c5501bb72be0811f778d216bdc599b74a410" translate="yes" xml:space="preserve">
          <source>This destructor is typically called by the destructor of &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este destructor generalmente es llamado por el destructor de &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb5e9bde864785c69be529012ab31825d767db62" translate="yes" xml:space="preserve">
          <source>This directive is used by some automatic code generation tools which produce C++ source files from a file written in another language. In that case, &lt;code&gt;#line&lt;/code&gt; directives may be inserted in the generated C++ file referencing line numbers and the file name of the original (human-editable) source file.</source>
          <target state="translated">Esta directiva es utilizada por algunas herramientas de generaci&amp;oacute;n autom&amp;aacute;tica de c&amp;oacute;digo que producen archivos fuente C ++ a partir de un archivo escrito en otro idioma. En ese caso, se pueden insertar directivas &lt;code&gt;#line&lt;/code&gt; en el archivo C ++ generado que hace referencia a los n&amp;uacute;meros de l&amp;iacute;nea y al nombre del archivo fuente original (editable por humanos).</target>
        </trans-unit>
        <trans-unit id="2160c0fc9b1d6f99749583e4a431b1db823b687a" translate="yes" xml:space="preserve">
          <source>This element acts as a placeholder; attempting to access it results in undefined behavior.</source>
          <target state="translated">Este elemento actúa como un marcador de posición;intentar acceder a él resulta en un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="e1d92326ee038395416fb47c3929e52bba4b4b4a" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply monetary formatting rules of another language without changing the rest of the locale.</source>
          <target state="translated">Este ejemplo demuestra cómo aplicar las reglas de formato monetario de otro idioma sin cambiar el resto de la localidad.</target>
        </trans-unit>
        <trans-unit id="699b77b3a2b284060799465bf0aef3eb6c604dfb" translate="yes" xml:space="preserve">
          <source>This example demonistrates how to apply numeric punctuation rules of another language without changing the rest of the locale.</source>
          <target state="translated">Este ejemplo demuestra cómo aplicar las reglas de puntuación numérica de otro idioma sin cambiar el resto de la localidad.</target>
        </trans-unit>
        <trans-unit id="03a8f1b5ffb01757d8be09e129dc569a5400d2fc" translate="yes" xml:space="preserve">
          <source>This example demonstrates a situation where sequential ordering is necessary. Any other ordering may trigger the assert because it would be possible for the threads &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;d&lt;/code&gt; to observe changes to the atomics &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; in opposite order.</source>
          <target state="translated">Este ejemplo demuestra una situaci&amp;oacute;n en la que es necesario un orden secuencial. Cualquier otro pedido puede desencadenar la aserci&amp;oacute;n, ya que ser&amp;iacute;a posible para los hilos de &lt;code&gt;c&lt;/code&gt; y &lt;code&gt;d&lt;/code&gt; para observar cambios en las at&amp;oacute;mica &lt;code&gt;x&lt;/code&gt; y &lt;code&gt;y&lt;/code&gt; en orden opuesto.</target>
        </trans-unit>
        <trans-unit id="6c12e1f3885c29be2bfca0cfe53639bf6159022e" translate="yes" xml:space="preserve">
          <source>This example demonstrates dependency-ordered synchronization for pointer-mediated publication: the integer data is not related to the pointer to string by a data-dependency relationship, thus its value is undefined in the consumer.</source>
          <target state="translated">Este ejemplo demuestra la sincronización ordenada por dependencia para la publicación mediada por puntero:los datos enteros no están relacionados con el puntero a cadena por una relación de dependencia de datos,por lo que su valor no está definido en el consumidor.</target>
        </trans-unit>
        <trans-unit id="6b01d954af477e04c266f80ede6e5280ccdc0a60" translate="yes" xml:space="preserve">
          <source>This example demonstrates perfect forwarding of the parameter(s) to the argument of the constructor of class &lt;code&gt;T&lt;/code&gt;. Also, perfect forwarding of parameter packs is demonstrated.</source>
          <target state="translated">Este ejemplo demuestra perfecta remisi&amp;oacute;n de los par&amp;aacute;metros (s) al argumento del constructor de la clase &lt;code&gt;T&lt;/code&gt; . Adem&amp;aacute;s, se demuestra el reenv&amp;iacute;o perfecto de paquetes de par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="41d2d00ba30c148282801448fd5c841e57daf05e" translate="yes" xml:space="preserve">
          <source>This example demonstrates reading a GB18030-encoded file using the codecvt facet from a GB18030-aware locale.</source>
          <target state="translated">Este ejemplo demuestra la lectura de un archivo codificado en GB18030 usando la faceta de codecvt de una locale consciente de GB18030.</target>
        </trans-unit>
        <trans-unit id="4d303a5fae16ce79fa6d0c697ce2d0fc19b5301e" translate="yes" xml:space="preserve">
          <source>This example demonstrates the Euler's identity ei&amp;pi;</source>
          <target state="translated">Este ejemplo demuestra la identidad de Euler ei&amp;pi;</target>
        </trans-unit>
        <trans-unit id="076b866beacb08cccde9a7cbeb026a03c41cdec2" translate="yes" xml:space="preserve">
          <source>This example demonstrates the difference between clock() time and real time.</source>
          <target state="translated">Este ejemplo demuestra la diferencia entre el tiempo del reloj()y el tiempo real.</target>
        </trans-unit>
        <trans-unit id="ec322c19fb258d9310f125341429ba2dbaa4630e" translate="yes" xml:space="preserve">
          <source>This example displays information about the execution time of a function call:</source>
          <target state="translated">Este ejemplo muestra información sobre el tiempo de ejecución de una llamada a la función:</target>
        </trans-unit>
        <trans-unit id="b6a1d0dea16b8362b800d36d34e475e44374f92b" translate="yes" xml:space="preserve">
          <source>This example measures the execution time of a function.</source>
          <target state="translated">Este ejemplo mide el tiempo de ejecución de una función.</target>
        </trans-unit>
        <trans-unit id="f9f8065b3b5128d3a408cb9f21a45bf456306b8f" translate="yes" xml:space="preserve">
          <source>This example prints current time using the &quot;C&quot; locale with the time_put facet replaced by various time_put_byname facets.</source>
          <target state="translated">Este ejemplo imprime la hora actual utilizando la localidad &quot;C&quot; con la faceta time_put sustituida por varias facetas time_put_byname.</target>
        </trans-unit>
        <trans-unit id="4b380662a79a86a43a8e6ddbc4fae89b7137cd02" translate="yes" xml:space="preserve">
          <source>This example shows a 10 seconds block.</source>
          <target state="translated">Este ejemplo muestra un bloque de 10 segundos.</target>
        </trans-unit>
        <trans-unit id="68e2616f4fe4dbb587d170dace9a4de7c97af570" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;lock&lt;/code&gt; and &lt;code&gt;unlock&lt;/code&gt; can be used to protect shared data.</source>
          <target state="translated">Este ejemplo muestra c&amp;oacute;mo &lt;code&gt;lock&lt;/code&gt; y &lt;code&gt;unlock&lt;/code&gt; se pueden usar para proteger los datos compartidos.</target>
        </trans-unit>
        <trans-unit id="b265f51b6f5d54fac0a395f6360e177b329bb440" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">Este ejemplo muestra c&amp;oacute;mo la &lt;code&gt;promise&amp;lt;int&amp;gt;&lt;/code&gt; puede usarse como se&amp;ntilde;ales entre hilos.</target>
        </trans-unit>
        <trans-unit id="7e9ee0c7c7b464f5720460296151cb05bd7054a5" translate="yes" xml:space="preserve">
          <source>This example shows how &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; can be used as signals between threads.</source>
          <target state="translated">Este ejemplo muestra c&amp;oacute;mo la &lt;code&gt;promise&amp;lt;void&amp;gt;&lt;/code&gt; puede usarse como se&amp;ntilde;ales entre hilos.</target>
        </trans-unit>
        <trans-unit id="9cc1e77d4a4ec9dcaa9ce1202b289473c0fe3f32" translate="yes" xml:space="preserve">
          <source>This example shows how a &lt;code&gt;mutex&lt;/code&gt; can be used to protect a &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; shared between two threads.</source>
          <target state="translated">Este ejemplo muestra c&amp;oacute;mo se puede usar un &lt;code&gt;mutex&lt;/code&gt; para proteger un &lt;code&gt;&lt;a href=&quot;../container/map&quot;&gt;std::map&lt;/a&gt;&lt;/code&gt; compartido entre dos hilos.</target>
        </trans-unit>
        <trans-unit id="648fa6a16a6dcfeed9894c57ffbd6224f1ffea42" translate="yes" xml:space="preserve">
          <source>This example shows how to define several custom duration types and convert between types:</source>
          <target state="translated">Este ejemplo muestra cómo definir varios tipos de duración personalizados y convertir entre tipos:</target>
        </trans-unit>
        <trans-unit id="0af6770609a4caa5cf880a836ce6717cfed6d527" translate="yes" xml:space="preserve">
          <source>This example shows how to pass a lambda to a generic algorithm and how objects resulting from a lambda declaration can be stored in &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; objects.</source>
          <target state="translated">Este ejemplo muestra c&amp;oacute;mo pasar una lambda a un algoritmo gen&amp;eacute;rico y c&amp;oacute;mo los objetos resultantes de una declaraci&amp;oacute;n lambda pueden almacenarse en objetos &lt;code&gt;&lt;a href=&quot;../utility/functional/function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccfdcc1737a5e9e6732e2a5414a8ae4ca8c5cc92" translate="yes" xml:space="preserve">
          <source>This example shows how to use a namespace to create a class that already has been named in the &lt;code&gt;std&lt;/code&gt; namespace.</source>
          <target state="translated">Este ejemplo muestra c&amp;oacute;mo usar un espacio de nombres para crear una clase que ya ha sido nombrada en el &lt;code&gt;std&lt;/code&gt; nombres est&amp;aacute;ndar .</target>
        </trans-unit>
        <trans-unit id="4812778eaab911430b4291ca314167dcaef2c221" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; families of functions.</source>
          <target state="translated">Esta excepci&amp;oacute;n es lanzada por &lt;code&gt;&lt;a href=&quot;../../utility/bitset/bitset&quot;&gt;std::bitset::bitset&lt;/a&gt;&lt;/code&gt; y las familias de funciones &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stol&quot;&gt;std::stoi&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../string/basic_string/stof&quot;&gt;std::stof&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6233e2c685f108dd3cbe5ebed91c5d014b2b2b2" translate="yes" xml:space="preserve">
          <source>This exception is thrown by &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; and functions that call it (such as the constructors of &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; that takes a &lt;code&gt;std::chrono::local_time&lt;/code&gt;).</source>
          <target state="translated">Esta excepci&amp;oacute;n es lanzada por &lt;code&gt;std::chrono::time_zone::to_sys&lt;/code&gt; y las funciones que lo llaman (como los constructores de &lt;code&gt;std::chrono::zoned_time&lt;/code&gt; que toma un &lt;code&gt;std::chrono::local_time&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d06332298cae245fc7de591665ed289988d734a8" translate="yes" xml:space="preserve">
          <source>This exception is thrown by member functions of &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta excepci&amp;oacute;n es lanzada por las funciones miembro de &lt;code&gt;&lt;a href=&quot;../../string/basic_string&quot;&gt;std::basic_string&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../container/vector/reserve&quot;&gt;std::vector::reserve&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61d73663b9152dc36fe73750ad1a87fd639e49c2" translate="yes" xml:space="preserve">
          <source>This feature is used in template metaprogramming.</source>
          <target state="translated">Esta característica se utiliza en la metaprogramación de plantillas.</target>
        </trans-unit>
        <trans-unit id="ebe57327a03912c16a8791570ac9fd18d3a3f421" translate="yes" xml:space="preserve">
          <source>This form automatically provides &lt;a href=&quot;exceptions&quot;&gt;strong exception guarantee&lt;/a&gt;, but prohibits resource reuse.</source>
          <target state="translated">Este formulario proporciona autom&amp;aacute;ticamente una &lt;a href=&quot;exceptions&quot;&gt;fuerte garant&amp;iacute;a de excepci&amp;oacute;n&lt;/a&gt; , pero proh&amp;iacute;be la reutilizaci&amp;oacute;n de recursos.</target>
        </trans-unit>
        <trans-unit id="a5c081dc7229ad13536ca7204c599487bcfa19aa" translate="yes" xml:space="preserve">
          <source>This function (for double argument) behaves as if (except for the freedom to not raise &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt;) implemented by the following code:</source>
          <target state="translated">Esta funci&amp;oacute;n (para doble argumento) se comporta como si (excepto la libertad de no aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; ) implementada por el siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="6a68eec804ec3c10883600f6bcfaeb90b1f9c1d6" translate="yes" xml:space="preserve">
          <source>This function and the related types are deprecated as of C++11 in favor of the more general &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from plain functions.</source>
          <target state="translated">Esta funci&amp;oacute;n y los tipos relacionados est&amp;aacute;n en desuso a partir de C ++ 11 a favor de las &lt;code&gt;&lt;a href=&quot;function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; m&amp;aacute;s generales std :: function y &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; , que crean objetos de funci&amp;oacute;n compatibles con adaptadores invocables a partir de funciones simples.</target>
        </trans-unit>
        <trans-unit id="8855f9b9dc1d262207716dd8128c053ea2ad8bb0" translate="yes" xml:space="preserve">
          <source>This function and the related types were deprecated in C++11 and removed in C++17 in favor of the more general &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;, both of which create callable adapter-compatible function objects from member functions.</source>
          <target state="translated">Esta funci&amp;oacute;n y los tipos relacionados se desaprobaron en C ++ 11 y se eliminaron en C ++ 17 en favor de los &lt;code&gt;&lt;a href=&quot;mem_fn&quot;&gt;std::mem_fn&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; m&amp;aacute;s generales , que crean objetos de funci&amp;oacute;n compatibles con adaptadores invocables a partir de funciones miembro.</target>
        </trans-unit>
        <trans-unit id="9d11c6f40fc460580b4545f369d83a5f3011308f" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer equal in size to the sequence to be sorted. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">Esta función intenta asignar un búfer temporal de tamaño igual al de la secuencia a clasificar.Si la asignación falla,se elige el algoritmo menos eficiente.</target>
        </trans-unit>
        <trans-unit id="0dc2280353aa9f39b639bbe5806d955bd65f2c7d" translate="yes" xml:space="preserve">
          <source>This function attempts to allocate a temporary buffer. If the allocation fails, the less efficient algorithm is chosen.</source>
          <target state="translated">Esta función intenta asignar un búfer temporal.Si la asignación falla,se elige el algoritmo menos eficiente.</target>
        </trans-unit>
        <trans-unit id="56dabe59df1e13c9e7227a371ae542e03583d74a" translate="yes" xml:space="preserve">
          <source>This function behaves as if implemented as follows:</source>
          <target state="translated">Esta función se comporta como si estuviera implementada de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="e024c278b12913b9314d8bc74236e17366fbdd60" translate="yes" xml:space="preserve">
          <source>This function behaves as if it reads the characters sequentially and stops as soon as a matching character is found: if the array pointed to by &lt;code&gt;ptr&lt;/code&gt; is smaller than &lt;code&gt;count&lt;/code&gt;, but the match is found within the array, the behavior is well-defined.</source>
          <target state="translated">Esta funci&amp;oacute;n se comporta como si leyera los caracteres secuencialmente y se detiene tan pronto como se encuentre un car&amp;aacute;cter coincidente: si la matriz a la que apunta &lt;code&gt;ptr&lt;/code&gt; es menor que la &lt;code&gt;count&lt;/code&gt; , pero la coincidencia se encuentra dentro de la matriz, el comportamiento est&amp;aacute; bien definido.</target>
        </trans-unit>
        <trans-unit id="70a20794d71c34f9a147e7b2e7b15ccb7dd382d5" translate="yes" xml:space="preserve">
          <source>This function can be used when implementing &lt;a href=&quot;../language/move_operator&quot;&gt;move assignment operators&lt;/a&gt; and &lt;a href=&quot;../language/move_constructor&quot;&gt;move constructors&lt;/a&gt;:</source>
          <target state="translated">Esta funci&amp;oacute;n se puede utilizar al implementar &lt;a href=&quot;../language/move_operator&quot;&gt;operadores de asignaci&amp;oacute;n de &lt;/a&gt;&lt;a href=&quot;../language/move_constructor&quot;&gt;movimiento&lt;/a&gt; y constructores de movimiento :</target>
        </trans-unit>
        <trans-unit id="074233c87f0a8381f8c33e772677b1882b2b89cc" translate="yes" xml:space="preserve">
          <source>This function can make a write position available if the stringbuf is open for output (&lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt;): in this case, it reallocates (or initially allocates) the buffer big enough to hold the entire current buffer plus at least one more character. If the stringbuf is also open for input (&lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt;), then &lt;code&gt;overflow&lt;/code&gt; also increases the size of the get area by moving &lt;code&gt;egptr()&lt;/code&gt; to point just past the new write position.</source>
          <target state="translated">Esta funci&amp;oacute;n puede hacer que una posici&amp;oacute;n de escritura est&amp;eacute; disponible si el stringbuf est&amp;aacute; abierto para la salida ( &lt;code&gt;mode &amp;amp; ios_base::out) != 0&lt;/code&gt; ): en este caso, reasigna (o asigna inicialmente) el buffer lo suficientemente grande como para contener todo el buffer actual m&amp;aacute;s Al menos un personaje m&amp;aacute;s. Si el stringbuf tambi&amp;eacute;n est&amp;aacute; abierto para entrada ( &lt;code&gt;(mode &amp;amp; ios_base::in) != 0&lt;/code&gt; ), el &lt;code&gt;overflow&lt;/code&gt; tambi&amp;eacute;n aumenta el tama&amp;ntilde;o del &amp;aacute;rea de &lt;code&gt;egptr()&lt;/code&gt; moviendo egptr () para apuntar justo m&amp;aacute;s all&amp;aacute; de la nueva posici&amp;oacute;n de escritura.</target>
        </trans-unit>
        <trans-unit id="80dad3848a318d7ecb43c15430bc70acc0b353eb" translate="yes" xml:space="preserve">
          <source>This function detects the sign bit of zeroes, infinities, and NaNs. Along with &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt;, std::signbit is one of the only two portable ways to examine the sign of a NaN.</source>
          <target state="translated">Esta funci&amp;oacute;n detecta el bit de signo de ceros, infinitos y NaN. Junto con &lt;code&gt;&lt;a href=&quot;copysign&quot;&gt;std::copysign&lt;/a&gt;&lt;/code&gt; , std :: signbit es una de las dos &amp;uacute;nicas formas port&amp;aacute;tiles de examinar el signo de un NaN.</target>
        </trans-unit>
        <trans-unit id="8e1aa01daec415e7f5af69e6b0d04848557bd2e6" translate="yes" xml:space="preserve">
          <source>This function does not call constructors or initialize memory in any way. There are no ready-to-use smart pointers that could guarantee that the matching deallocation function is called. The preferred method of memory allocation in C++ is using RAII-ready functions &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt;, container constructors, etc, and, in low-level library code, &lt;a href=&quot;../../language/new&quot;&gt;new-expression&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no llama a los constructores ni inicializa la memoria de ninguna manera. No hay punteros inteligentes listos para usar que puedan garantizar que se llame a la funci&amp;oacute;n de desasignaci&amp;oacute;n correspondiente. El m&amp;eacute;todo preferido de asignaci&amp;oacute;n de memoria en C ++ es usar funciones listas para RAII &lt;code&gt;&lt;a href=&quot;../unique_ptr/make_unique&quot;&gt;std::make_unique&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../shared_ptr/make_shared&quot;&gt;std::make_shared&lt;/a&gt;&lt;/code&gt; , constructores de contenedores, etc. y, en c&amp;oacute;digo de biblioteca de bajo nivel, &lt;a href=&quot;../../language/new&quot;&gt;nueva expresi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d4587b2ca7a4f0c1305b825fddf8669b0a594052" translate="yes" xml:space="preserve">
          <source>This function does not commit any changes to the filesystem.</source>
          <target state="translated">Esta función no confirma ningún cambio en el sistema de archivos.</target>
        </trans-unit>
        <trans-unit id="9a9157bc8e19134921e346295ad23635f0edc637" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; is true.</source>
          <target state="translated">Esta funci&amp;oacute;n no participa en la resoluci&amp;oacute;n de sobrecarga a menos que &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;D&amp;gt;::value&lt;/code&gt; sea ​​verdadero.</target>
        </trans-unit>
        <trans-unit id="34f86c4c962be5f53b674478758ba7b4aac25784" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; is true for all i from 0 to &lt;code&gt;sizeof...(Types)&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no participa en la resoluci&amp;oacute;n de sobrecarga a menos que &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;Ti&amp;gt;&lt;/code&gt; sea ​​verdadero para todo i de 0 a &lt;code&gt;sizeof...(Types)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="430ec4ee0ab3ae68ef199618d00c231487c566a4" translate="yes" xml:space="preserve">
          <source>This function does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no participa en la resoluci&amp;oacute;n de sobrecarga a menos que &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;first_type&amp;gt; &amp;amp;&amp;amp; &lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;second_type&amp;gt;&lt;/code&gt; sea &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="93f49364b5d0b6ce3643e79ff41e9aa02af91573" translate="yes" xml:space="preserve">
          <source>This function exploits the signature compatibility between hinted insert for associative containers (such as &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt;) and positional insert for sequential containers (such as &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n explota la compatibilidad de firma entre inserci&amp;oacute;n insinuada para contenedores asociativos (como &lt;code&gt;&lt;a href=&quot;../../container/set/insert&quot;&gt;std::set::insert&lt;/a&gt;&lt;/code&gt; ) e inserci&amp;oacute;n posicional para contenedores secuenciales (como &lt;code&gt;&lt;a href=&quot;../../container/vector/insert&quot;&gt;std::vector::insert&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="77f1becd52cdb4bb82d9005b4cfb7fd4243343b4" translate="yes" xml:space="preserve">
          <source>This function has no effect. Memory used by a &lt;code&gt;monotonic_buffer_resource&lt;/code&gt;, as its name indicates, increases monotonically until the resource is destroyed.</source>
          <target state="translated">Esta funci&amp;oacute;n no tiene efecto. La memoria utilizada por un &lt;code&gt;monotonic_buffer_resource&lt;/code&gt; , como su nombre lo indica, aumenta monot&amp;oacute;nicamente hasta que se destruye el recurso.</target>
        </trans-unit>
        <trans-unit id="003c7fca2e592f4d453e6d2795ce41a60cc8ae9a" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currenly exclusively locked by any other thread.</source>
          <target state="translated">Se permite que esta funci&amp;oacute;n falle falsamente y devuelva &lt;code&gt;false&lt;/code&gt; incluso si el mutex no est&amp;aacute; bloqueado exclusivamente por ning&amp;uacute;n otro subproceso.</target>
        </trans-unit>
        <trans-unit id="4aff8f3ce667147891a0800fe1ffe344229b2457" translate="yes" xml:space="preserve">
          <source>This function is allowed to fail spuriously and return &lt;code&gt;false&lt;/code&gt; even if the mutex is not currently locked by any other thread.</source>
          <target state="translated">Se permite que esta funci&amp;oacute;n falle falsamente y devuelva &lt;code&gt;false&lt;/code&gt; incluso si el mutex no est&amp;aacute; bloqueado actualmente por ning&amp;uacute;n otro hilo.</target>
        </trans-unit>
        <trans-unit id="581170c63a0c34f4d8ef486e52f25f659195a185" translate="yes" xml:space="preserve">
          <source>This function is an &lt;a href=&quot;consteval&quot;&gt;immediate function&lt;/a&gt; if the function call operator (or specialization, for generic lambdas) is an immediate function.</source>
          <target state="translated">Esta funci&amp;oacute;n es una &lt;a href=&quot;consteval&quot;&gt;funci&amp;oacute;n inmediata&lt;/a&gt; si el operador de llamada de funci&amp;oacute;n (o especializaci&amp;oacute;n, para lambdas gen&amp;eacute;ricas) es una funci&amp;oacute;n inmediata.</target>
        </trans-unit>
        <trans-unit id="7d1b9d31c1cd20909db730ecb0adb4933d6936b7" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; (or another &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; that was given a &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; as the allocator to use).</source>
          <target state="translated">Esta funci&amp;oacute;n es llamada (a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; ) por cualquier objeto compatible con el asignador, como &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::pmr::vector&lt;/a&gt;&lt;/code&gt; (u otro &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; que recibi&amp;oacute; un &lt;code&gt;std::std::polymorphic_allocator&lt;/code&gt; como el asignador para usar )</target>
        </trans-unit>
        <trans-unit id="f22521ea8de0d211401620c2c0ceeebcc98c2413" translate="yes" xml:space="preserve">
          <source>This function is called (through &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt;) by any allocator-aware object, such as &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt;, that was given a &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; as the allocator to use. Since &lt;code&gt;inner_allocator&lt;/code&gt; is itself an instance of &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, this function will also be called when the allocator-aware objects constructed through this function start constructing their own members.</source>
          <target state="translated">Esta funci&amp;oacute;n es llamada (a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../allocator_traits&quot;&gt;std::allocator_traits&lt;/a&gt;&lt;/code&gt; ) por cualquier objeto compatible con el asignador, como &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; , que recibi&amp;oacute; un &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; como el asignador para usar. Dado que &lt;code&gt;inner_allocator&lt;/code&gt; es en s&amp;iacute; una instancia de &lt;code&gt;&lt;a href=&quot;../scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; , esta funci&amp;oacute;n tambi&amp;eacute;n se llamar&amp;aacute; cuando los objetos conscientes del asignador construidos a trav&amp;eacute;s de esta funci&amp;oacute;n comiencen a construir sus propios miembros.</target>
        </trans-unit>
        <trans-unit id="1604a10d0bd65894de0fdd375bd44a25850704e0" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">Esta funci&amp;oacute;n se llama autom&amp;aacute;ticamente cuando se intercambian objetos &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::fstream&lt;/a&gt;&lt;/code&gt; , rara vez es necesario llamarla directamente.</target>
        </trans-unit>
        <trans-unit id="0e78d40edd5ecace775e3b468b3346c7031f470e" translate="yes" xml:space="preserve">
          <source>This function is called automatically when swapping &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; objects, it is rarely necessary to call it directly.</source>
          <target state="translated">Esta funci&amp;oacute;n se llama autom&amp;aacute;ticamente cuando se intercambian objetos &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::stringstream&lt;/a&gt;&lt;/code&gt; , rara vez es necesario llamarla directamente.</target>
        </trans-unit>
        <trans-unit id="c4734f8a6748c0cb4415534ce967c7c8880cdda2" translate="yes" xml:space="preserve">
          <source>This function is called by &lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; and in other situations when finalizing a state-dependent multibyte character sequence.</source>
          <target state="translated">&lt;code&gt;std::basic_filebuf::close()&lt;/code&gt; llama a esta funci&amp;oacute;n y en otras situaciones al finalizar una secuencia de caracteres multibyte dependiente del estado.</target>
        </trans-unit>
        <trans-unit id="32de367add154511d8a09e86e9af636ea74ff7b5" translate="yes" xml:space="preserve">
          <source>This function is called by the constructor of &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; when given an &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; argument.</source>
          <target state="translated">El constructor de &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; llama a esta funci&amp;oacute;n cuando se le da un argumento &lt;code&gt;&lt;a href=&quot;../future_errc&quot;&gt;std::future_errc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbcb817100be7c6ebcd72951487118723a0a15af" translate="yes" xml:space="preserve">
          <source>This function is called by the copy constructors of all standard library containers. It allows the allocator used by the constructor's argument to become aware that the container is being copied and modify state if necessary.</source>
          <target state="translated">Esta función es llamada por los constructores de copias de todos los contenedores de la biblioteca estándar.Permite que el asignador utilizado por el argumento del constructor se dé cuenta de que el contenedor se está copiando y modifique su estado si es necesario.</target>
        </trans-unit>
        <trans-unit id="bfb34e88abba67d43669caa31797e35aed808cba" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_fstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">Esta función es llamada por el destructor de basic_fstream cuando el objeto de la corriente se sale del ámbito de aplicación y no suele ser invocada directamente.</target>
        </trans-unit>
        <trans-unit id="9586654e6d5f24f563ef041033abacd3e6aaef3e" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ifstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">Esta función es llamada por el destructor de basic_ifstream cuando el objeto de la corriente se sale de su alcance y no suele ser invocada directamente.</target>
        </trans-unit>
        <trans-unit id="0b0b9fa6d17fdf350f225d78773a873a4f6a210f" translate="yes" xml:space="preserve">
          <source>This function is called by the destructor of basic_ofstream when the stream object goes out of scope and is not usually invoked directly.</source>
          <target state="translated">Esta función es llamada por el destructor de basic_ofstream cuando el objeto de la corriente se sale de su alcance y no suele ser invocada directamente.</target>
        </trans-unit>
        <trans-unit id="ae182d564b01a9cc3f1cbb5dd2383b385c515a22" translate="yes" xml:space="preserve">
          <source>This function is constexpr if the function call operator (or specialization, for generic lambdas) is constexpr.</source>
          <target state="translated">Esta función es constexpr si la función operador de llamada (o especialización,para los lambdas genéricos)es constexpr.</target>
        </trans-unit>
        <trans-unit id="6cb839c1449d28abb8b1ad7d5627544f12403184" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiple times to obtain successive tokens from the same string.</source>
          <target state="translated">Esta función está diseñada para ser llamada varias veces para obtener fichas sucesivas de la misma cadena.</target>
        </trans-unit>
        <trans-unit id="db0f3821e4deee5da8554e13cdcbbb92c017d0a9" translate="yes" xml:space="preserve">
          <source>This function is designed to be called multiples times to obtain successive tokens from the same string.</source>
          <target state="translated">Esta función está diseñada para ser llamada varias veces para obtener fichas sucesivas de la misma cadena.</target>
        </trans-unit>
        <trans-unit id="776743886aba3fc5ea926a51a096528c0531353d" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a &lt;a href=&quot;../../language/string_literal&quot;&gt;string literal&lt;/a&gt; cannot be used as the first argument of &lt;code&gt;strtok&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n es destructiva: escribe los caracteres &lt;code&gt;'\0'&lt;/code&gt; en los elementos de la cadena &lt;code&gt;str&lt;/code&gt; . En particular, un &lt;a href=&quot;../../language/string_literal&quot;&gt;literal de cadena&lt;/a&gt; no se puede usar como primer argumento de &lt;code&gt;strtok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aaae01573deddc58b640a93ca69e57c3af20acb3" translate="yes" xml:space="preserve">
          <source>This function is destructive: it writes the &lt;code&gt;L'\0'&lt;/code&gt; characters in the elements of the string &lt;code&gt;str&lt;/code&gt;. In particular, a wide string literal cannot be used as the first argument of &lt;code&gt;std::wcstok&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n es destructiva: escribe los caracteres &lt;code&gt;L'\0'&lt;/code&gt; en los elementos de la cadena &lt;code&gt;str&lt;/code&gt; . En particular, un literal de cadena ancha no se puede utilizar como primer argumento de &lt;code&gt;std::wcstok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae117e98847c242edb80799fb082fc22f8c51c75" translate="yes" xml:space="preserve">
          <source>This function is different from a typical &lt;code&gt;overflow()&lt;/code&gt; which moves the contents of the buffer to the associated character sequence because for a &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt;, the buffer and the associated sequence are one and the same.</source>
          <target state="translated">Esta funci&amp;oacute;n es diferente de un &lt;code&gt;overflow()&lt;/code&gt; t&amp;iacute;pico () que mueve el contenido del b&amp;uacute;fer a la secuencia de caracteres asociada porque para un &lt;code&gt;&lt;a href=&quot;../basic_stringbuf&quot;&gt;std::basic_stringbuf&lt;/a&gt;&lt;/code&gt; , el b&amp;uacute;fer y la secuencia asociada son uno y el mismo.</target>
        </trans-unit>
        <trans-unit id="bf7eaed7da997c4b5d39d94135b3ff5c00bc6632" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; for some hidden object &lt;code&gt;internal&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt;, except that the expression &lt;code&gt;ps&lt;/code&gt; is evaluated only once.</source>
          <target state="translated">Esta funci&amp;oacute;n es equivalente a la llamada &lt;code&gt;&lt;a href=&quot;mbrtowc&quot;&gt;std::mbrtowc&lt;/a&gt;(nullptr, s, n, ps?ps:&amp;amp;internal)&lt;/code&gt; para alg&amp;uacute;n objeto oculto &lt;code&gt;internal&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; , excepto que la expresi&amp;oacute;n &lt;code&gt;ps&lt;/code&gt; se eval&amp;uacute;a solo una vez.</target>
        </trans-unit>
        <trans-unit id="9101f15eeb95d6b33b0fdb8d4808ce7c08cccbd4" translate="yes" xml:space="preserve">
          <source>This function is equivalent to the call &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt;, except that conversion state of &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; is unaffected.</source>
          <target state="translated">Esta funci&amp;oacute;n es equivalente a la llamada &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;((wchar_t*)0, s, n)&lt;/code&gt; , excepto que el estado de conversi&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;mbtowc&quot;&gt;std::mbtowc&lt;/a&gt;&lt;/code&gt; no se ve afectado.</target>
        </trans-unit>
        <trans-unit id="1963bc98196193cc320458fc455ddd3e328dde8a" translate="yes" xml:space="preserve">
          <source>This function is infrequently used directly by application code. Instead, one of the non-member comparison operators are used.</source>
          <target state="translated">Esta función se utiliza con poca frecuencia directamente por el código de aplicación.En su lugar,se utiliza uno de los operadores de comparación no miembros.</target>
        </trans-unit>
        <trans-unit id="403f2759a06c2803350631fa5d221bae46fd2b6b" translate="yes" xml:space="preserve">
          <source>This function is inherently racy if the managed object is shared among threads. In particular, a false result may become stale before it can be used. A true result is reliable.</source>
          <target state="translated">Esta función es intrínsecamente picante si el objeto administrado se comparte entre hilos.En particular,un resultado falso puede volverse rancio antes de que pueda ser utilizado.Un resultado verdadero es fiable.</target>
        </trans-unit>
        <trans-unit id="452207e6d60059763d001256a30bc736ba869131" translate="yes" xml:space="preserve">
          <source>This function is intended to replace &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt;. Unlike std::bind, it does not support arbitrary argument rearrangement and has no special treatment for nested bind-expressions. On the other hand, it pays attention to the value category of the call wrapper object and propagates exception specification of the underlying call operator.</source>
          <target state="translated">Esta funci&amp;oacute;n est&amp;aacute; destinada a reemplazar &lt;code&gt;&lt;a href=&quot;bind&quot;&gt;std::bind&lt;/a&gt;&lt;/code&gt; . A diferencia de std :: bind, no admite la reorganizaci&amp;oacute;n de argumentos arbitrarios y no tiene un tratamiento especial para las expresiones de enlace anidadas. Por otro lado, presta atenci&amp;oacute;n a la categor&amp;iacute;a de valor del objeto contenedor de llamadas y propaga la especificaci&amp;oacute;n de excepci&amp;oacute;n del operador de llamada subyacente.</target>
        </trans-unit>
        <trans-unit id="bc919d55a6f87a71a7f9eff45b45a6e0e62a8ce5" translate="yes" xml:space="preserve">
          <source>This function is not expected to be called directly: it is called through &lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt;&lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">No se espera que esta funci&amp;oacute;n se llame directamente: se llama a trav&amp;eacute;s de &lt;a href=&quot;../basic_osyncstream/get_wrapped&quot;&gt; &lt;code&gt;std::basic_osyncstream::get_wrapped&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="57e7dd85f600e213ae40f7d97225e1e1697e505f" translate="yes" xml:space="preserve">
          <source>This function is not fully implemented in some standard libraries. For example, &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc++&lt;/a&gt; always returns zero even though the device is non-deterministic. In comparison, Microsoft Visual C++ implementation always returns 32, and &lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt; returns 10.</source>
          <target state="translated">Esta funci&amp;oacute;n no est&amp;aacute; completamente implementada en algunas bibliotecas est&amp;aacute;ndar. Por ejemplo, &lt;a href=&quot;https://github.com/llvm-mirror/libcxx/blob/master/src/random.cpp#L174&quot;&gt;LLVM libc ++&lt;/a&gt; siempre devuelve cero aunque el dispositivo no sea determinista. En comparaci&amp;oacute;n, la implementaci&amp;oacute;n de Microsoft Visual C ++ siempre devuelve 32, y &lt;a href=&quot;https://github.com/boostorg/random/blob/master/src/random_device.cpp#L242&quot;&gt;boost.random&lt;/a&gt; devuelve 10.</target>
        </trans-unit>
        <trans-unit id="bf2280640237c525c2d62eefb26aff9f2856c11f" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it copies: nulls as well as invalid characters are copied too.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional y no presta atenci&amp;oacute;n a los valores de los objetos &lt;code&gt;wchar_t&lt;/code&gt; que copia: tambi&amp;eacute;n se copian los caracteres nulos y no v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="67fe14d7992c12e6d5c157b600ec2cde52ad0774" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it examines: nulls as well as invalid wide characters are compared too.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional y no presta atenci&amp;oacute;n a los valores de los objetos &lt;code&gt;wchar_t&lt;/code&gt; que examina: los caracteres nulos y los caracteres anchos no v&amp;aacute;lidos tambi&amp;eacute;n se comparan.</target>
        </trans-unit>
        <trans-unit id="9c3cb718222d314cabd06a082b4892a3a4ab3e26" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive and pays no attention to the values of the &lt;code&gt;wchar_t&lt;/code&gt; objects it writes: nulls as well as invalid wide characters are written too.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional y no presta atenci&amp;oacute;n a los valores de los objetos &lt;code&gt;wchar_t&lt;/code&gt; que escribe: tambi&amp;eacute;n se escriben los caracteres nulos y los caracteres anchos no v&amp;aacute;lidos.</target>
        </trans-unit>
        <trans-unit id="cc19c16caa38c36df06e04a2db5301e73e2f5836" translate="yes" xml:space="preserve">
          <source>This function is not locale-sensitive, unlike &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, and the order may not be meaningful when characters from different Unicode blocks are used together or when the order of code units does not match collation order.</source>
          <target state="translated">Esta funci&amp;oacute;n no es sensible a la configuraci&amp;oacute;n regional, a diferencia de &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; , y el orden puede no ser significativo cuando los caracteres de diferentes bloques Unicode se usan juntos o cuando el orden de las unidades de c&amp;oacute;digo no coincide con el orden de clasificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="743f719e1c7876947aef41d3da4d327b2152c1ab" translate="yes" xml:space="preserve">
          <source>This function is not overloaded for the types &lt;code&gt;signed char&lt;/code&gt; or &lt;code&gt;unsigned char&lt;/code&gt;, unlike the formatted &lt;a href=&quot;operator_ltlt2&quot;&gt;operator&amp;lt;&amp;lt;&lt;/a&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n no est&amp;aacute; sobrecargada para los tipos &lt;code&gt;signed char&lt;/code&gt; &lt;code&gt;unsigned char&lt;/code&gt; o sin signo , a diferencia del &lt;a href=&quot;operator_ltlt2&quot;&gt;operador&lt;/a&gt; formateado &amp;lt;&amp;lt;</target>
        </trans-unit>
        <trans-unit id="d3b72d4451a67b0f8e9ff04bab97998d9cac5a6e" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then +0 is returned.</source>
          <target state="translated">No se requiere que esta función sea sensible al signo de cero,aunque algunas implementaciones refuerzan adicionalmente que si un argumento es +0 y el otro es -0,entonces se devuelve +0.</target>
        </trans-unit>
        <trans-unit id="1e7653f07d484a2f1a2819f2a881f15b3743184c" translate="yes" xml:space="preserve">
          <source>This function is not required to be sensitive to the sign of zero, although some implementations additionally enforce that if one argument is +0 and the other is -0, then -0 is returned.</source>
          <target state="translated">No se requiere que esta función sea sensible al signo de cero,aunque algunas implementaciones refuerzan adicionalmente que si un argumento es +0 y el otro es -0,entonces se devuelve -0.</target>
        </trans-unit>
        <trans-unit id="63ff1f7a80d3a2498f6c2c57080a31e1fe86d34e" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="translated">No es necesario que esta funci&amp;oacute;n sea segura para subprocesos. Otra llamada a getenv, as&amp;iacute; como una llamada a las funciones POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv ()&lt;/a&gt; , &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv ()&lt;/a&gt; y &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv ()&lt;/a&gt; pueden invalidar el puntero devuelto por una llamada previa o modificar la cadena obtenida de una llamada previa.</target>
        </trans-unit>
        <trans-unit id="681d635b8b9b9b5848473256fcd251c20f009b9c" translate="yes" xml:space="preserve">
          <source>This function is not required to be thread-safe. Another call to getenv, as well as a call to the POSIX functions &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; may invalidate the pointer returned by a previous call or modify the string obtained from a previous call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f78d178d130886a2b5afb503f15940c3ad73bbf9" translate="yes" xml:space="preserve">
          <source>This function is not subject to any errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no est&amp;aacute; sujeta a ning&amp;uacute;n error especificado en &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2abffafc50a2795cbfb3627bf5fb2f042437061" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the error conditions specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no est&amp;aacute; sujeta a ninguna de las condiciones de error especificadas en &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e653a40d5b5f3d4ecc32e287a36ac0f0a3489976" translate="yes" xml:space="preserve">
          <source>This function is not subject to any of the errors specified in &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n no est&amp;aacute; sujeta a ninguno de los errores especificados en &lt;code&gt;&lt;a href=&quot;math_errhandling&quot;&gt;math_errhandling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da22a8cee5382549c532104db50c4ef68f7574e4" translate="yes" xml:space="preserve">
          <source>This function is not visible to ordinary &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;unqualified&lt;/a&gt; or &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;qualified lookup&lt;/a&gt;, and can only be found by &lt;a href=&quot;../../language/adl&quot;&gt;argument-dependent lookup&lt;/a&gt; when &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; is an associated class of the arguments. This prevents undesirable conversions in the presence of a &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n no es visible para la &lt;a href=&quot;../../language/qualified_lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; ordinaria &lt;a href=&quot;../../language/unqualified_lookup&quot;&gt;no calificada&lt;/a&gt; o calificada , y solo se puede encontrar mediante la &lt;a href=&quot;../../language/adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; cuando &lt;code&gt;&lt;a href=&quot;../path&quot;&gt;std::filesystem::path&lt;/a&gt;&lt;/code&gt; es una clase asociada de los argumentos. Esto evita las conversiones no deseadas en presencia de un &lt;code&gt;using namespace std::filesystem;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="356a2955e71eb2ff664ad638e29c0c881711ba2c" translate="yes" xml:space="preserve">
          <source>This function is optional, it may return &lt;code&gt;no_order&lt;/code&gt; in every case.</source>
          <target state="translated">Esta funci&amp;oacute;n es opcional, puede devolver &lt;code&gt;no_order&lt;/code&gt; en todos los casos.</target>
        </trans-unit>
        <trans-unit id="ffa5bc6979d4d788a32f52d1a8c3d6238bb88fba" translate="yes" xml:space="preserve">
          <source>This function is optional. If not implemented, this function returns &lt;code&gt;​0​&lt;/code&gt; (since the base class version &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; gets called).</source>
          <target state="translated">Esta funci&amp;oacute;n es opcional. Si no se han aplicado, esta funci&amp;oacute;n devuelve &lt;code&gt;​0​&lt;/code&gt; (ya que la versi&amp;oacute;n de la clase base &lt;code&gt;std::basic_streambuf::showmanyc&lt;/code&gt; es llamado).</target>
        </trans-unit>
        <trans-unit id="94f083987e438e8f45398655d60ea441662342f7" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_filebuf&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n est&amp;aacute; protegida virtual, solo se puede llamar a trav&amp;eacute;s de &lt;code&gt;pubsetbuf()&lt;/code&gt; o desde funciones miembro de una clase definida por el usuario derivada de &lt;code&gt;std::basic_filebuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e90def3890bd5c122a703d2eae4d728a21e862ac" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::basic_stringbuf&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n est&amp;aacute; protegida virtual, solo se puede llamar a trav&amp;eacute;s de &lt;code&gt;pubsetbuf()&lt;/code&gt; o desde funciones miembro de una clase definida por el usuario derivada de &lt;code&gt;std::basic_stringbuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7f492276aa00c278aeca31b34dc935f13689be2" translate="yes" xml:space="preserve">
          <source>This function is protected virtual, it may only be called through &lt;code&gt;pubsetbuf()&lt;/code&gt; or from member functions of a user-defined class derived from &lt;code&gt;std::strstreambuf&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n est&amp;aacute; protegida virtual, solo se puede llamar a trav&amp;eacute;s de &lt;code&gt;pubsetbuf()&lt;/code&gt; o desde funciones miembro de una clase definida por el usuario derivada de &lt;code&gt;std::strstreambuf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="503edf2bb2eb0295ac5dcd3fad68fe3498303d2a" translate="yes" xml:space="preserve">
          <source>This function is provided for compatibility with C. If the compatibility is not required, &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; may be initialized through their non-default constructors.</source>
          <target state="translated">Esta funci&amp;oacute;n se proporciona para compatibilidad con C. Si no se requiere la compatibilidad, &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; se puede inicializar a trav&amp;eacute;s de sus constructores no predeterminados.</target>
        </trans-unit>
        <trans-unit id="0233eac438664696f470dcb4a6305de8bdfaa672" translate="yes" xml:space="preserve">
          <source>This function is thread-safe (calling it from multiple threads does not introduce a data race) as long as no other function modifies the host environment. In particular, the POSIX functions &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; would introduce a data race if called without synchronization.</source>
          <target state="translated">Esta funci&amp;oacute;n es segura para subprocesos (llamarla desde m&amp;uacute;ltiples subprocesos no introduce una carrera de datos) siempre que ninguna otra funci&amp;oacute;n modifique el entorno del host. En particular, las funciones POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv ()&lt;/a&gt; , &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv ()&lt;/a&gt; y &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv ()&lt;/a&gt; introducir&amp;iacute;an una carrera de datos si se llamara sin sincronizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c77ec9cdb8ff1e7489c1293af187dff2039fb586" translate="yes" xml:space="preserve">
          <source>This function is thread-safe (calling it from multiple threads does not introduce a data race) as long as no other function modifies the host environment. In particular, the POSIX functions &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html&quot;&gt;setenv()&lt;/a&gt;, &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/unsetenv.html&quot;&gt;unsetenv()&lt;/a&gt;, and &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html&quot;&gt;putenv()&lt;/a&gt; would introduce a data race if called without synchronization.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a752e45b1c1e76a0bf7ba715c5f6c403c0eed278" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n es segura para subprocesos. Cada llamada a &lt;code&gt;std::pmr::set_default_resource&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a166d5bd1c79123ccec86898cc471f7c6a1e389e" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_new_handler&lt;/code&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n es segura para subprocesos. Cada llamada a &lt;code&gt;std::set_new_handler&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="0f8d53be444102a8285b0653a05c85e675ae55c4" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_terminate&lt;/code&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n es segura para subprocesos. Cada llamada a &lt;code&gt;std::set_terminate&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2c7aea13c02b97924864411502ae4053e055e059" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Every call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n es segura para subprocesos. Cada llamada a &lt;code&gt;std::set_unexpected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d270b8becf9b193ce734289e056a679cfdfc26" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n es segura para subprocesos. Llamada anterior a &lt;code&gt;&lt;a href=&quot;set_default_resource&quot;&gt;std::pmr::set_default_resource&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b1ab230cef40ffc4e792b092936b1dc96c9a5607" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Previous call to &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n es segura para subprocesos. Llamada anterior a &lt;code&gt;&lt;a href=&quot;set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="419521c15e45c9bfd4ee0de0dfa28aaf76875995" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n es segura para subprocesos. Llamada previa a &lt;code&gt;&lt;a href=&quot;set_terminate&quot;&gt;std::set_terminate&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="991dd801c88141cd8662fd187f9759911775d74d" translate="yes" xml:space="preserve">
          <source>This function is thread-safe. Prior call to &lt;code&gt;std::set_unexpected&lt;/code&gt;</source>
          <target state="translated">Esta funci&amp;oacute;n es segura para subprocesos. Llamada previa a &lt;code&gt;std::set_unexpected&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b2b7ba4b79851f8176eac8ec16e5a1575927b2d7" translate="yes" xml:space="preserve">
          <source>This function is thread-safe; concurrent access by multiple threads does not result in a data race.(since C++14).</source>
          <target state="translated">Esta función es segura para los hilos;el acceso simultáneo por múltiples hilos no resulta en una carrera de datos (desde C++14).</target>
        </trans-unit>
        <trans-unit id="6c9ad1a43ed57cf75b0c052d412e9c8c3e821c79" translate="yes" xml:space="preserve">
          <source>This function is typically accessed through &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt;.</source>
          <target state="translated">Normalmente se accede a esta funci&amp;oacute;n a trav&amp;eacute;s de &lt;code&gt;std::basic_stringstream::str()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8638be2f7c43a80edc7dee020c03393b731e9858" translate="yes" xml:space="preserve">
          <source>This function is typically called by &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n normalmente es llamada por &lt;code&gt;&lt;a href=&quot;../basic_fstream/is_open&quot;&gt;std::basic_fstream::is_open()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db17dd608d932664bed4bd45648d18848b7cdb88" translate="yes" xml:space="preserve">
          <source>This function is typically called through the &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; interface.</source>
          <target state="translated">Esta funci&amp;oacute;n generalmente se llama a trav&amp;eacute;s de la interfaz &lt;code&gt;&lt;a href=&quot;../strstream&quot;&gt;std::strstream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b70e23981de2eddfb5cf1b279f2272ffbaab4c5" translate="yes" xml:space="preserve">
          <source>This function is used by the standard library containers when inserting, copying, or moving elements.</source>
          <target state="translated">Esta función es utilizada por los contenedores estándar de la biblioteca al insertar,copiar o mover elementos.</target>
        </trans-unit>
        <trans-unit id="1c6ccf8ad1ccab32debfac40525ef074436c2ec6" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same string or set of strings, because it is more efficient to use &lt;code&gt;std::strxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n se utiliza cuando se realizan m&amp;uacute;ltiples comparaciones dependientes de la configuraci&amp;oacute;n regional utilizando la misma cadena o conjunto de cadenas, porque es m&amp;aacute;s eficiente usar &lt;code&gt;std::strxfrm&lt;/code&gt; para transformar todas las cadenas solo una vez, y posteriormente comparar las cadenas transformadas con &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca9d1d936d9fcef21052e9b31a8d09c354e45148" translate="yes" xml:space="preserve">
          <source>This function is used when making multiple locale-dependent comparisons using the same wide string or set of wide strings, because it is more efficient to use &lt;code&gt;std::wcsxfrm&lt;/code&gt; to transform all the strings just once, and subsequently compare the transformed wide strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n se utiliza cuando se realizan m&amp;uacute;ltiples comparaciones dependientes de la configuraci&amp;oacute;n regional utilizando la misma cadena ancha o conjunto de cadenas anchas, porque es m&amp;aacute;s eficiente usar &lt;code&gt;std::wcsxfrm&lt;/code&gt; para transformar todas las cadenas una sola vez y, posteriormente, comparar las cadenas anchas transformadas con &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5926d0f12bf7b7909e57150c062279d2ee706942" translate="yes" xml:space="preserve">
          <source>This function is useful in generic programming, since it uses &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt; as fallbacks when &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; is not available.</source>
          <target state="translated">Esta funci&amp;oacute;n es &amp;uacute;til en la programaci&amp;oacute;n gen&amp;eacute;rica, ya que utiliza &lt;code&gt;&amp;lt;&lt;/code&gt; y &lt;code&gt;==&lt;/code&gt; como retrocesos cuando &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; no est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="be58b3707f3fcdf36615b4d19faec6a6dc05f29c" translate="yes" xml:space="preserve">
          <source>This function is useful when implementing periodic functions with the period exactly representable as a floating-point value: when calculating sin(&amp;pi;x) for a very large &lt;code&gt;x&lt;/code&gt;, calling &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; directly may result in a large error, but if the function argument is first reduced with &lt;code&gt;std::remquo&lt;/code&gt;, the low-order bits of the quotient may be used to determine the sign and the octant of the result within the period, while the remainder may be used to calculate the value with high precision.</source>
          <target state="translated">Esta funci&amp;oacute;n es &amp;uacute;til cuando se implementan funciones peri&amp;oacute;dicas con el per&amp;iacute;odo exactamente representable como un valor de punto flotante: al calcular sin (&amp;pi;x) para una &lt;code&gt;x&lt;/code&gt; muy grande , llamar a &lt;code&gt;&lt;a href=&quot;sin&quot;&gt;std::sin&lt;/a&gt;&lt;/code&gt; directamente puede resultar en un gran error, pero si el argumento de la funci&amp;oacute;n primero se reduce con &lt;code&gt;std::remquo&lt;/code&gt; , los bits de bajo orden del cociente se pueden usar para determinar el signo y el octante del resultado dentro del per&amp;iacute;odo, mientras que el resto se puede usar para calcular el valor con alta precisi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9314ee2e726c67b60305538d50add991082d26bc" translate="yes" xml:space="preserve">
          <source>This function is usually case-insensitive.</source>
          <target state="translated">Esta función suele ser insensible a las mayúsculas y minúsculas.</target>
        </trans-unit>
        <trans-unit id="6c9ee1f3188431817a670ceef41258274cd55d11" translate="yes" xml:space="preserve">
          <source>This function may be used as an alternative to &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt;. The trade-offs are:</source>
          <target state="translated">Esta funci&amp;oacute;n puede usarse como una alternativa a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;(new T(args...))&lt;/code&gt; . Las compensaciones son:</target>
        </trans-unit>
        <trans-unit id="0255ee7edd077c96e23883d7db760fc3da2e3d71" translate="yes" xml:space="preserve">
          <source>This function may be used e.g. in the implementation of &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; to use bulk character copy instead of calling &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; if it is known that the locale imbued in the &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; does not perform any conversions.</source>
          <target state="translated">Esta funci&amp;oacute;n se puede usar, por ejemplo, en la implementaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/underflow&quot;&gt;std::basic_filebuf::underflow&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../io/basic_streambuf/overflow&quot;&gt;std::basic_filebuf::overflow&lt;/a&gt;&lt;/code&gt; para usar la copia de caracteres en masa en lugar de llamar a &lt;code&gt;&lt;a href=&quot;in&quot;&gt;std::codecvt::in&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;out&quot;&gt;std::codecvt::out&lt;/a&gt;&lt;/code&gt; si Se sabe que la configuraci&amp;oacute;n regional imbuida en &lt;code&gt;&lt;a href=&quot;../../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; no realiza ninguna conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="332c6aa9bcea925b9a927e3ad7173bbcf6a2f86d" translate="yes" xml:space="preserve">
          <source>This function may be used in the beginning of a subroutine that must hide the floating-point exceptions it may raise from the caller. If only some exceptions must be suppressed, while others must be reported, the non-stop mode is usually ended with a call to &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; after clearing the unwanted exceptions.</source>
          <target state="translated">Esta funci&amp;oacute;n puede usarse al comienzo de una subrutina que debe ocultar las excepciones de punto flotante que puede generar la persona que llama. Si solo se deben suprimir algunas excepciones, mientras que se deben informar otras, el modo sin interrupci&amp;oacute;n generalmente finaliza con una llamada a &lt;code&gt;&lt;a href=&quot;feupdateenv&quot;&gt;std::feupdateenv&lt;/a&gt;&lt;/code&gt; despu&amp;eacute;s de borrar las excepciones no deseadas.</target>
        </trans-unit>
        <trans-unit id="653f6e88a7890bf08216060f0a91617ba728c746" translate="yes" xml:space="preserve">
          <source>This function may be used to end the non-stop mode established by an earlier call to &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n se puede usar para finalizar el modo continuo establecido por una llamada anterior a &lt;code&gt;&lt;a href=&quot;feholdexcept&quot;&gt;std::feholdexcept&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23b1aaf9597250b14a85a5f063ebcaa36211aeee" translate="yes" xml:space="preserve">
          <source>This function may be used to output object representations, i.e. binary output.</source>
          <target state="translated">Esta función puede utilizarse para dar salida a las representaciones de los objetos,es decir,a la salida binaria.</target>
        </trans-unit>
        <trans-unit id="856950bcb4c9f3dcc5895c41de9e090f268e6ccd" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;sleep_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">Esta funci&amp;oacute;n puede bloquear por m&amp;aacute;s tiempo que &lt;code&gt;sleep_duration&lt;/code&gt; debido a retrasos en la programaci&amp;oacute;n o contenci&amp;oacute;n de recursos.</target>
        </trans-unit>
        <trans-unit id="6c2d0b323f5f9df1da55d663b9642600ad42960c" translate="yes" xml:space="preserve">
          <source>This function may block for longer than &lt;code&gt;timeout_duration&lt;/code&gt; due to scheduling or resource contention delays.</source>
          <target state="translated">Esta funci&amp;oacute;n puede bloquear por m&amp;aacute;s tiempo que &lt;code&gt;timeout_duration&lt;/code&gt; debido a retrasos en la programaci&amp;oacute;n o contenci&amp;oacute;n de recursos.</target>
        </trans-unit>
        <trans-unit id="88aa144342c719b2d0cf02f7ae6cd001dc8b8b1c" translate="yes" xml:space="preserve">
          <source>This function may implement selection sampling or reservoir sampling.</source>
          <target state="translated">Esta función puede poner en práctica el muestreo de selección o el muestreo de yacimientos.</target>
        </trans-unit>
        <trans-unit id="f6b6f1463d12ffb2bc42127132a8ac643fc238fe" translate="yes" xml:space="preserve">
          <source>This function may not be thread-safe.</source>
          <target state="translated">Esta función puede no ser segura para los hilos.</target>
        </trans-unit>
        <trans-unit id="a4a88b9d5b7b6f8931799bf82d9c71dd06343e4a" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n solo se puede usar despu&amp;eacute;s de que la &lt;code&gt;stream&lt;/code&gt; se haya asociado con un archivo abierto, pero antes de cualquier otra operaci&amp;oacute;n (que no sea una llamada fallida a &lt;code&gt;&lt;a href=&quot;setbuf&quot;&gt;std::setbuf&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="19731f6b76843a49446fd5784cfb942c7dfca160" translate="yes" xml:space="preserve">
          <source>This function may only be used after &lt;code&gt;stream&lt;/code&gt; has been associated with an open file, but before any other operation (other than a failed call to &lt;code&gt;std::setbuf&lt;/code&gt;/&lt;code&gt;std::setvbuf&lt;/code&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n solo se puede usar despu&amp;eacute;s de que la &lt;code&gt;stream&lt;/code&gt; se haya asociado con un archivo abierto, pero antes de cualquier otra operaci&amp;oacute;n (que no sea una llamada fallida a &lt;code&gt;std::setbuf&lt;/code&gt; / &lt;code&gt;std::setvbuf&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="717983186dc4c6865ae3eed7bfe5f5461be1682a" translate="yes" xml:space="preserve">
          <source>This function moves the &lt;code&gt;src&lt;/code&gt; pointer to the end of the converted multibyte string. This doesn't happen if &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n mueve el puntero &lt;code&gt;src&lt;/code&gt; al final de la cadena multibyte convertida. Esto no sucede si &lt;code&gt;dst==&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53568c58dccc50911b4df0d8fe32be0fd89e385d" translate="yes" xml:space="preserve">
          <source>This function never modifies the file, only the get area of the in-memory buffer.</source>
          <target state="translated">Esta función nunca modifica el archivo,sólo el área de obtención del buffer en memoria.</target>
        </trans-unit>
        <trans-unit id="a3149df38d014eb7ad815af8ec580ac7ae565936" translate="yes" xml:space="preserve">
          <source>This function object provides owner-based (as opposed to value-based) mixed-type ordering of both &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt;. The order is such that two smart pointers compare equivalent only if they are both empty or if they share ownership, even if the values of the raw pointers obtained by &lt;code&gt;get()&lt;/code&gt; are different (e.g. because they point at different subobjects within the same object).</source>
          <target state="translated">Este objeto de funci&amp;oacute;n proporciona una ordenaci&amp;oacute;n de tipo mixto basada en el propietario (en oposici&amp;oacute;n a la basada en el valor) de &lt;code&gt;&lt;a href=&quot;weak_ptr&quot;&gt;std::weak_ptr&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&lt;/code&gt; . El orden es tal que dos punteros inteligentes comparan el equivalente solo si ambos est&amp;aacute;n vac&amp;iacute;os o si comparten la propiedad, incluso si los valores de los punteros brutos obtenidos por &lt;code&gt;get()&lt;/code&gt; son diferentes (por ejemplo, porque apuntan a diferentes subobjetos dentro del mismo objeto) .</target>
        </trans-unit>
        <trans-unit id="501340bd50fbe27100db1419cc8b73a966d53dac" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as reported by the most recent I/O operation, it does not examine the associated data source. For example, if the most recent I/O was a &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt;, which returned the last byte of a file, &lt;code&gt;std::feof&lt;/code&gt; returns zero. The next &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; fails and changes the stream state to</source>
          <target state="translated">Esta funci&amp;oacute;n solo informa el estado del flujo seg&amp;uacute;n lo informado por la operaci&amp;oacute;n de E / S m&amp;aacute;s reciente, no examina la fuente de datos asociada. Por ejemplo, si la E / S m&amp;aacute;s reciente fue un &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; , que devolvi&amp;oacute; el &amp;uacute;ltimo byte de un archivo, &lt;code&gt;std::feof&lt;/code&gt; devuelve cero. El siguiente &lt;code&gt;&lt;a href=&quot;fgetc&quot;&gt;std::fgetc&lt;/a&gt;&lt;/code&gt; falla y cambia el estado del flujo a</target>
        </trans-unit>
        <trans-unit id="7ad9af23b2df5c7bd59daf117807cb419335155c" translate="yes" xml:space="preserve">
          <source>This function only reports the stream state as set by the most recent I/O operation; it does not examine the associated data source. For example, if the most recent I/O was a &lt;a href=&quot;../basic_istream/get&quot;&gt;&lt;code&gt;get()&lt;/code&gt;&lt;/a&gt; which returned the last byte of a file, &lt;code&gt;eof()&lt;/code&gt; returns &lt;code&gt;false&lt;/code&gt;. The next &lt;code&gt;get()&lt;/code&gt; fails to read anything and sets the &lt;code&gt;eofbit&lt;/code&gt;. Only then does &lt;code&gt;eof()&lt;/code&gt; return &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n solo informa el estado del flujo establecido por la operaci&amp;oacute;n de E / S m&amp;aacute;s reciente; no examina la fuente de datos asociada. Por ejemplo, si la E / S m&amp;aacute;s reciente fue un &lt;a href=&quot;../basic_istream/get&quot;&gt; &lt;code&gt;get()&lt;/code&gt; &lt;/a&gt; que devolvi&amp;oacute; el &amp;uacute;ltimo byte de un archivo, &lt;code&gt;eof()&lt;/code&gt; devuelve &lt;code&gt;false&lt;/code&gt; . El siguiente &lt;code&gt;get()&lt;/code&gt; no puede leer nada y establece el &lt;code&gt;eofbit&lt;/code&gt; . Solo entonces &lt;code&gt;eof()&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="982c99a7d72d510dc31dfb3379380b9b994f3b5b" translate="yes" xml:space="preserve">
          <source>This function reads &lt;a href=&quot;../../language/objects&quot;&gt;object representations&lt;/a&gt;, not the object values, and is typically only meaningful for trivially-copyable objects with no padding. For example, &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; will not compare their contents, and &lt;code&gt;memcmp()&lt;/code&gt; between two objects of type &lt;code&gt;struct{char c; int n;}&lt;/code&gt; will compare the padding bytes whose values may differ when the values of &lt;code&gt;c&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; are the same.</source>
          <target state="translated">Esta funci&amp;oacute;n lee &lt;a href=&quot;../../language/objects&quot;&gt;representaciones de objetos&lt;/a&gt; , no los valores de los objetos, y normalmente solo tiene sentido para los objetos copiables trivialmente sin relleno. Por ejemplo, &lt;code&gt;memcmp()&lt;/code&gt; entre dos objetos de tipo &lt;code&gt;&lt;a href=&quot;../basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; no comparar&amp;aacute; su contenido, y &lt;code&gt;memcmp()&lt;/code&gt; entre dos objetos de tipo &lt;code&gt;struct{char c; int n;}&lt;/code&gt; comparar&amp;aacute; los bytes de relleno cuyos valores pueden diferir cuando los valores de &lt;code&gt;c&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; son los mismos.</target>
        </trans-unit>
        <trans-unit id="3b2572fd11a91d196e72bf228b8fdec17f7a295e" translate="yes" xml:space="preserve">
          <source>This function returns &lt;code&gt;true&lt;/code&gt; immediately after construction or an increment. Recursion can be disabled via &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve &lt;code&gt;true&lt;/code&gt; inmediatamente despu&amp;eacute;s de la construcci&amp;oacute;n o un incremento. La recursi&amp;oacute;n se puede deshabilitar a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;disable_recursion_pending&quot;&gt;disable_recursion_pending()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36528001254a3bd82486f8ac96e239eda107e919" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. In addition, it modifies the static &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object which may be shared with &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt;. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve un puntero a datos est&amp;aacute;ticos y no es seguro para subprocesos. Adem&amp;aacute;s, modifica el objeto est&amp;aacute;tico &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; que se puede compartir con &lt;code&gt;&lt;a href=&quot;gmtime&quot;&gt;std::gmtime&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;localtime&quot;&gt;std::localtime&lt;/a&gt;&lt;/code&gt; . POSIX marca esta funci&amp;oacute;n como obsoleta y recomienda &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="b1f290d85406220b6b3adbcd72ba71618d9d4c4a" translate="yes" xml:space="preserve">
          <source>This function returns a pointer to static data and is not thread-safe. POSIX marks this function obsolete and recommends &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Esta funci&amp;oacute;n devuelve un puntero a datos est&amp;aacute;ticos y no es seguro para subprocesos. POSIX marca esta funci&amp;oacute;n como obsoleta y recomienda &lt;code&gt;&lt;a href=&quot;strftime&quot;&gt;std::strftime&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="2c08549c92d5f75cd55b61fde267f92bfcf2bd81" translate="yes" xml:space="preserve">
          <source>This function template does not participate in overload resolution unless &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Esta plantilla de funci&amp;oacute;n no participa en la resoluci&amp;oacute;n de sobrecarga a menos que &lt;code&gt;&lt;a href=&quot;../../types/is_move_constructible&quot;&gt;std::is_move_constructible_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable_v&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; sean ambas &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e017cba1b1d7f0a849984253cc947eb2d5f913c0" translate="yes" xml:space="preserve">
          <source>This function template is &lt;code&gt;constexpr&lt;/code&gt; if and only if each of &lt;code&gt;To&lt;/code&gt;, &lt;code&gt;From&lt;/code&gt; and the types of all subobjects of &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt;:</source>
          <target state="translated">Esta plantilla de funci&amp;oacute;n es &lt;code&gt;constexpr&lt;/code&gt; si y solo si cada uno de &lt;code&gt;To&lt;/code&gt; , &lt;code&gt;From&lt;/code&gt; y los tipos de todos los subobjetos de &lt;code&gt;To&lt;/code&gt; y &lt;code&gt;From&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d23f50db250e473fa7ba998015f5ef4335528d35" translate="yes" xml:space="preserve">
          <source>This function was deprecated in C++17 and removed in C++20 because &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; is only an approximation in multithreaded environment (see Notes in &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n fue desaprobada en C ++ 17 y eliminada en C ++ 20 porque &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; es solo una aproximaci&amp;oacute;n en un entorno multiproceso (ver Notas en &lt;code&gt;&lt;a href=&quot;use_count&quot;&gt;use_count&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c95a6c84f8a7a3d63141f96f96d764fc5141f797" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;, and having to call &lt;code&gt;allocate&lt;/code&gt;, &lt;code&gt;construct&lt;/code&gt;, and &lt;code&gt;deallocate&lt;/code&gt; individually.</source>
          <target state="translated">Esta funci&amp;oacute;n se introdujo para su uso con el asignador completamente especializado &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; , pero puede ser &amp;uacute;til en cualquier especializaci&amp;oacute;n como m&amp;eacute;todo abreviado para evitar tener que volver a vincular desde &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; a &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; , y tener que llamar a &lt;code&gt;allocate&lt;/code&gt; , &lt;code&gt;construct&lt;/code&gt; y &lt;code&gt;deallocate&lt;/code&gt; individualmente.</target>
        </trans-unit>
        <trans-unit id="cdecbddba7a122a33bb2e1a5f3720fe34c7dff59" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization as a shortcut to avoid having to rebind from &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; to &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n se introdujo para su uso con el asignador completamente especializado &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; , pero puede ser &amp;uacute;til en cualquier especializaci&amp;oacute;n como m&amp;eacute;todo abreviado para evitar tener que volver a vincular desde &lt;code&gt;std::polymorphic_allocator&amp;lt;T&amp;gt;&lt;/code&gt; a &lt;code&gt;std::polymorphic_allocator&amp;lt;U&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ae120608bb11c2db86fc6eaad00ab05ea738813" translate="yes" xml:space="preserve">
          <source>This function was introduced for use with the fully-specialized allocator &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt;, but it may be useful in any specialization.</source>
          <target state="translated">Esta funci&amp;oacute;n se introdujo para su uso con el asignador completamente especializado &lt;code&gt;std::polymorphic_allocator&amp;lt;&amp;gt;&lt;/code&gt; , pero puede ser &amp;uacute;til en cualquier especializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="afc3c5ff95ee968755d1d67223367b55662ab586" translate="yes" xml:space="preserve">
          <source>This function's analog for byte strings is &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt;, not &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El an&amp;aacute;logo de esta funci&amp;oacute;n para cadenas de bytes es &lt;code&gt;&lt;a href=&quot;../byte/strncpy&quot;&gt;std::strncpy&lt;/a&gt;&lt;/code&gt; , no &lt;code&gt;&lt;a href=&quot;../byte/strcpy&quot;&gt;std::strcpy&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2cb86dd21cb66b4b0098463876ae7c777232781" translate="yes" xml:space="preserve">
          <source>This function, if defined, is the inverse of &lt;code&gt;pointer_to&lt;/code&gt;, and exists as the customization point to be called by &lt;a href=&quot;../to_address&quot;&gt;&lt;code&gt;std::to_address&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Esta funci&amp;oacute;n, si est&amp;aacute; definida, es la inversa de &lt;code&gt;pointer_to&lt;/code&gt; , y existe como el punto de personalizaci&amp;oacute;n que debe llamar &lt;a href=&quot;../to_address&quot;&gt; &lt;code&gt;std::to_address&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2345f7fbcd183e468d0ac0a235350d0b6c2895ee" translate="yes" xml:space="preserve">
          <source>This functions invalidates all pointers and references to elements in the array.</source>
          <target state="translated">Esta función invalida todos los indicadores y referencias a los elementos de la matriz.</target>
        </trans-unit>
        <trans-unit id="5e4969b70b796f9ee282c9f3e8a0064ce14f7b5c" translate="yes" xml:space="preserve">
          <source>This header contains forward declarations for the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado contiene declaraciones directas para la biblioteca de &lt;a href=&quot;../io&quot;&gt;entrada / salida&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a9faf08967a6670c687da4edbcf69fb38e394a6f" translate="yes" xml:space="preserve">
          <source>This header is for &lt;a href=&quot;../string/byte&quot;&gt;C-style null-terminated byte strings&lt;/a&gt;.</source>
          <target state="translated">Esta cabecera es para &lt;a href=&quot;../string/byte&quot;&gt;cadenas de bytes de terminaci&amp;oacute;n nula estilo C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15d0710db508b245029a9ef7a8057846c8c18ceb" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../algorithm&quot;&gt;algorithm&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../algorithm&quot;&gt;algoritmos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58c127bf99321a87db0770e187db96005473b488" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../atomic&quot;&gt;atomic operations&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../atomic&quot;&gt;operaciones at&amp;oacute;micas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e7de3a818aa933f4120df06f08cef712f022314a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono&quot;&gt;date and time&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../chrono&quot;&gt;fecha y hora&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7df038a6142795810cf58cc3edc5892a6604ef81" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../chrono/c&quot;&gt;C-style date and time&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../chrono/c&quot;&gt;fecha y hora de estilo C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fc145a04217e02f635144bea666233647838e7fd" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../concepts&quot;&gt;concepts&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../concepts&quot;&gt;conceptos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="920e039f9619877e9581d36218e4eb4ba48fec2f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;container&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../container&quot;&gt;contenedores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="acbb3dd4e1d46d22f68d17b978a7136be93e2436" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../container&quot;&gt;containers&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../container&quot;&gt;contenedores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6b732c1d1cd4791f71bccf52bcce002f80d4d61f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../error&quot;&gt;error handling&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../error&quot;&gt;manejo de errores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d135ae9415d668b3740baa8d1c6202b3114e61db" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../filesystem&quot;&gt;filesystem support&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../filesystem&quot;&gt;soporte&lt;/a&gt; del sistema de archivos .</target>
        </trans-unit>
        <trans-unit id="a2b0a9ff42b16169188356ee975f844196e0ec79" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/Output&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../io&quot;&gt;entrada / salida&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b25ea2a66813773c5a403aa1ec3e976f8574b721" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;Input/output&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../io&quot;&gt;entrada / salida&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0686693c4046ba7c301b43bc07e6f7bdc8f026ab" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io&quot;&gt;input/output&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../io&quot;&gt;entrada / salida&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5dc95614835592456bfaab6702f6224650e49b18" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/c&quot;&gt;C-style input/output&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../io/c&quot;&gt;entrada / salida de estilo C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="741ade6dc30c88b9370c305e6f3e63644225b886" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../io/manip&quot;&gt;Input/output manipulators&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../io/manip&quot;&gt;manipuladores de entrada / salida&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7cb909214b55ea54c4a3636e2ff95e66a61c1e7b" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../iterator&quot;&gt;iterator&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca &lt;a href=&quot;../iterator&quot;&gt;iteradora&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="09eabf0e3af531f8459c8a3e9d34d078049d494f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;Localization&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../locale&quot;&gt;localizaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e0027a344c3001e03b17fff554e048e844e18b05" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../locale&quot;&gt;localization&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../locale&quot;&gt;localizaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1909ccb2df983190ad8b340b81a78cddcac0bc66" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library, in particular provides &lt;a href=&quot;../memory/new&quot;&gt;low level memory management&lt;/a&gt; features.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../memory&quot;&gt;administraci&amp;oacute;n de memoria din&amp;aacute;mica&lt;/a&gt; , en particular proporciona funciones de &lt;a href=&quot;../memory/new&quot;&gt;administraci&amp;oacute;n de memoria de bajo nivel&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="923f654a5fb3f2b4a9e337168f6734bf9fb2d4f9" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../memory&quot;&gt;dynamic memory management&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../memory&quot;&gt;administraci&amp;oacute;n de memoria din&amp;aacute;mica&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dbf3371c4bdf5d7b9e212f0bbd00a12907e1875c" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric&quot;&gt;numeric&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca &lt;a href=&quot;../numeric&quot;&gt;num&amp;eacute;rica&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="83d799881dc970620d81655aaa5b6c445cc22101" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/fenv&quot;&gt;floating-point environment&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../numeric/fenv&quot;&gt;entorno de punto flotante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5ec3ff74347947b9a2d2ce7512f774f5d52354a7" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/random&quot;&gt;pseudo-random number generation&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../numeric/random&quot;&gt;generaci&amp;oacute;n de n&amp;uacute;meros pseudoaleatorios&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="732e0c7c47f9d69b203e65c610a0bfd158dff524" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../numeric/ratio&quot;&gt;compile-time rational arithmetic&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca &lt;a href=&quot;../numeric/ratio&quot;&gt;aritm&amp;eacute;tica racional en tiempo de compilaci&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c1ad47862381ddb91c08db8090600c5d4bf4e4dc" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../ranges&quot;&gt;ranges&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../ranges&quot;&gt;rangos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d97fc3d50637471b41b3efb43e5a6b0e3a2b4a01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../regex&quot;&gt;regular expressions&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../regex&quot;&gt;expresiones regulares&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a2342c5c0987e5fec030e1218936937ec44df653" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string&quot;&gt;strings&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../string&quot;&gt;cadenas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="92a5be8272a47414f0e0bdc904667ee202af3267" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/byte&quot;&gt;null-terminated byte strings&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../string/byte&quot;&gt;cadenas de bytes terminada en nulo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="15b12e7c5f34f001bead642c260ad11a6ffaa39d" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/multibyte&quot;&gt;null-terminated multibyte strings&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../string/multibyte&quot;&gt;cadenas multibyte terminadas en nulo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2c42908621e154cf0ec843b46350efa2d0035aee" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../string/wide&quot;&gt;C-style null-terminated wide strings&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../string/wide&quot;&gt;cadenas anchas terminadas en nulo de estilo C.&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="1fa75679068a99053300a010d141f6d8edb54561" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../thread&quot;&gt;thread support&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../thread&quot;&gt;soporte de hilos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="5d0c64faa54ec66b25a58a11c78064009bdd8b01" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, in particular it's part of the &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">Esta cabecera es parte del &lt;a href=&quot;../types&quot;&gt;soporte de tipo&lt;/a&gt; biblioteca, en particular, que es parte de la &lt;a href=&quot;../types/climits&quot;&gt;interfaz de l&amp;iacute;mites num&amp;eacute;ricos C&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="65d3f063deae384355d6746093849a4b449165a4" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library, providing &lt;a href=&quot;../types/integer&quot;&gt;fixed width integer types&lt;/a&gt; and part of &lt;a href=&quot;../types/climits&quot;&gt;C numeric limits interface&lt;/a&gt;.</source>
          <target state="translated">Esta cabecera es parte del &lt;a href=&quot;../types&quot;&gt;soporte de tipo&lt;/a&gt; biblioteca, proporcionando &lt;a href=&quot;../types/integer&quot;&gt;tipos enteros de ancho fijo&lt;/a&gt; y parte de &lt;a href=&quot;../types/climits&quot;&gt;C interfaz l&amp;iacute;mites num&amp;eacute;ricos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="436886a411e9e8d5ffe11352a732faef34f88757" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;type support&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../types&quot;&gt;soporte de tipos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7edf0c9c8e7cef800a48133a201ddbc070132a48" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../types&quot;&gt;types support&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../types&quot;&gt;soporte de tipos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="58facb47ff5cf9d880e42e8852e016436ed3f78a" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;general utility&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../utility&quot;&gt;utilidades generales&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="31843b16c0e12afb62de520dcdac5733f6cee8c2" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility&quot;&gt;utility&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../utility&quot;&gt;utilidades&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b3ee827480d7d8d279e03c27c6ed6cca87cad739" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility#Language_support&quot;&gt;language support&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../utility#Language_support&quot;&gt;soporte de idiomas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a4ff4d258bc17960105e2ea2601ffd3a5889df5f" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/functional&quot;&gt;function objects&lt;/a&gt; library and provides the standard &lt;a href=&quot;../utility/hash&quot;&gt;hash function&lt;/a&gt;.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../utility/functional&quot;&gt;objetos de funci&amp;oacute;n&lt;/a&gt; y proporciona la &lt;a href=&quot;../utility/hash&quot;&gt;funci&amp;oacute;n hash&lt;/a&gt; est&amp;aacute;ndar .</target>
        </trans-unit>
        <trans-unit id="9ac972c91cec61981b8a812ec6acfd57ff806586" translate="yes" xml:space="preserve">
          <source>This header is part of the &lt;a href=&quot;../utility/program&quot;&gt;program support&lt;/a&gt; library.</source>
          <target state="translated">Este encabezado es parte de la biblioteca de &lt;a href=&quot;../utility/program&quot;&gt;soporte&lt;/a&gt; del programa .</target>
        </trans-unit>
        <trans-unit id="e22299e67c4b7f2d10a4eb976dbfff224a6c2122" translate="yes" xml:space="preserve">
          <source>This header is part of the null-terminated &lt;a href=&quot;../string/wide&quot;&gt;wide&lt;/a&gt; and &lt;a href=&quot;../string/multibyte&quot;&gt;multibyte&lt;/a&gt; strings libraries. It also provides some &lt;a href=&quot;../io/c&quot;&gt;C-style I/O&lt;/a&gt; functions and conversion from &lt;a href=&quot;../chrono/c&quot;&gt;C-style Date&lt;/a&gt;.</source>
          <target state="translated">Este encabezado es parte de las bibliotecas de cadenas &lt;a href=&quot;../string/wide&quot;&gt;anchas&lt;/a&gt; y &lt;a href=&quot;../string/multibyte&quot;&gt;multibyte&lt;/a&gt; terminadas en nulo . Tambi&amp;eacute;n proporciona algunas &lt;a href=&quot;../io/c&quot;&gt;i o de estilo C /&lt;/a&gt; funciones y conversi&amp;oacute;n de &lt;a href=&quot;../chrono/c&quot;&gt;estilo C Fecha&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d0be451883776fa4f5f243412345fc9b51386469" translate="yes" xml:space="preserve">
          <source>This header provides miscellaneous utilities. Symbols defined here are used by several library components.</source>
          <target state="translated">Este encabezado proporciona diversas utilidades.Los símbolos definidos aquí son utilizados por varios componentes de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="3d8521103b2fed33ffe104b06e729876d4b7f2c8" translate="yes" xml:space="preserve">
          <source>This header provides support for &lt;a href=&quot;../utility/variadic&quot;&gt;C-style variadic functions&lt;/a&gt;.</source>
          <target state="translated">Esta cabecera proporciona soporte para &lt;a href=&quot;../utility/variadic&quot;&gt;de estilo C funciones variadic&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1f5444765226ce0bdb5af9dadf8c355721e6f565" translate="yes" xml:space="preserve">
          <source>This header supplies implementation-dependent information about the standard library (such as implementation-specific library version macros).</source>
          <target state="translated">Este encabezado proporciona información dependiente de la implementación acerca de la biblioteca estándar (como las macros de versiones de biblioteca específicas de la implementación).</target>
        </trans-unit>
        <trans-unit id="e3d2a98c9481a36d1f279d320f5b70a26a7e3330" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;assert.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a392d9aa2ebe01e48b3d01961d845f5d0588e04" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;complex.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21d14ed988bc023e0af2e53864603e6cda2885be" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;ctype.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68c78f91644f281b447ad60cdbb1634c09a9119a" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;errno.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02e483f5fd629df3b87fff596e49a80d8b8c0425" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;fenv.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6e03bbb8695dbcceecc16e98c0e964b5fefd852" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;float.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d59783125b891e429043f2f2d5f576fd72a06c1c" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;inttypes.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02fccbdf35494b28df2accdc8d41b5a89580c3c0" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;iso646.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db14ba2bad874c7dde2374ac32527f2c381efc33" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;limits.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="53af078bd74b84f0423e1e9211b917adea77b920" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;locale.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fc6197b328bad98f05fff68010e58025c14a9b1" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;math.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98d8ce7d2ea217c30464e6a8895e55e50e6eb6dd" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;setjmp.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4db152ded5e9f8b82696d238d20533a05044bdc8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;signal.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dbf2ebc0d4f0372f0d23dcfc1ff48e2cc5e172fa" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;stdalign.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="552c8fb5c454bd957020620ff32c98f913c6ec6f" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;stdarg.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1fc778831b537c9627fb3177ad740d51c764464" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;stdbool.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea55cad81c5a499ab61c2f336f793e79c2cde22b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;stddef.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c4e4679e2a1edfcea3588f047e41db14f9335c2e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;stdint.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b100c9fc2e0568f0798665b7418667c38edba953" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;stdio.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9724180e3c20c4e3ccde319664bad3907db8ef2" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;stdlib.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d57c16a998701ee531191c284ccfc0598fb9ad8" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;string.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aeb4dad38844729f6a773adfa6b26a2500e3724e" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;tgmath.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78466c124900e096d16d9eac15396f90464c889b" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;time.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bc1e66e0693def74a913c9f83e9fd4b6579b986" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;uchar.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2e4ff735f64305108a77807fb191c4cc62d9e14" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;wchar.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16d7a74374a4accebff96ae1f6f2de097d3b0cae" translate="yes" xml:space="preserve">
          <source>This header was originally in the C standard library as &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Este encabezado estaba originalmente en la biblioteca est&amp;aacute;ndar de C como &lt;code&gt;&amp;lt;wctype.h&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aedb64fc9e75ef3b36a2ef43e03fc20db3e03e5b" translate="yes" xml:space="preserve">
          <source>This holds for every objects &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; that are not aliases of one another.</source>
          <target state="translated">Esto es v&amp;aacute;lido para todos los objetos &lt;code&gt;a&lt;/code&gt; y &lt;code&gt;b&lt;/code&gt; que no son alias entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="05ebbbf417474068cc1404af21d2b363f30ea1c1" translate="yes" xml:space="preserve">
          <source>This implies that the class has no &lt;a href=&quot;../language/virtual&quot;&gt;virtual functions&lt;/a&gt; or &lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;virtual base classes&lt;/a&gt;.</source>
          <target state="translated">Esto implica que la clase no tiene &lt;a href=&quot;../language/virtual&quot;&gt;funciones &lt;/a&gt;&lt;a href=&quot;../language/derived_class#Virtual_base_classes&quot;&gt;virtuales&lt;/a&gt; o clases base virtuales .</target>
        </trans-unit>
        <trans-unit id="2f0ae52b3b410d1e9be7d3f883c6f57fc4873c3a" translate="yes" xml:space="preserve">
          <source>This includes &lt;a href=&quot;type-id&quot;&gt;integral types&lt;/a&gt;, &lt;a href=&quot;pointer&quot;&gt;pointer types&lt;/a&gt;, &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;pointer to member type&lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, as well as enumeration types with no custom &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; overload, but excludes floating-point types.</source>
          <target state="translated">Esto incluye &lt;a href=&quot;type-id&quot;&gt;tipos integrales&lt;/a&gt; , &lt;a href=&quot;pointer&quot;&gt;los tipos de puntero&lt;/a&gt; , &lt;a href=&quot;pointer#Pointers_to_members&quot;&gt;puntero al tipo de miembro&lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , as&amp;iacute; como los tipos de enumeraci&amp;oacute;n sin encargo &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; sobrecarga, pero excluye los tipos de coma flotante.</target>
        </trans-unit>
        <trans-unit id="d9b2e0a6f64a6667926bbe46e5290f95959e8907" translate="yes" xml:space="preserve">
          <source>This information is provided via specializations of the &lt;code&gt;numeric_limits&lt;/code&gt; template. The standard library makes available specializations for all arithmetic types:</source>
          <target state="translated">Esta informaci&amp;oacute;n se proporciona a trav&amp;eacute;s de especializaciones de la plantilla &lt;code&gt;numeric_limits&lt;/code&gt; . La biblioteca est&amp;aacute;ndar pone a disposici&amp;oacute;n especializaciones para todos los tipos aritm&amp;eacute;ticos:</target>
        </trans-unit>
        <trans-unit id="30fa8f162edae84e00655c850b76032946d786f6" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;bidirectionalrange&quot;&gt;&lt;code&gt;BidirectionalRange&lt;/code&gt;&lt;/a&gt;, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;V&lt;/code&gt; models &lt;a href=&quot;forwardrange&quot;&gt;&lt;code&gt;ForwardRange&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">Este es un &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; &lt;/a&gt; si &lt;code&gt;V&lt;/code&gt; modela &lt;a href=&quot;bidirectionalrange&quot;&gt; &lt;code&gt;BidirectionalRange&lt;/code&gt; &lt;/a&gt; , un &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; &lt;/a&gt; si &lt;code&gt;V&lt;/code&gt; modela &lt;a href=&quot;forwardrange&quot;&gt; &lt;code&gt;ForwardRange&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; de lo&lt;/a&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="8b29d4dc98b35c7b6aae2a923e6c330c4c737570" translate="yes" xml:space="preserve">
          <source>This is a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;RandomAccessIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Advanceable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;BidirectionalIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models _Decrementable, a &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;ForwardIterator&lt;/code&gt;&lt;/a&gt; if &lt;code&gt;W&lt;/code&gt; models &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;Incrementable&lt;/code&gt;&lt;/a&gt;, and &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt;&lt;code&gt;InputIterator&lt;/code&gt;&lt;/a&gt; otherwise.</source>
          <target state="translated">Este es un &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/RandomAccessIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;RandomAccessIterator&lt;/code&gt; &lt;/a&gt; si &lt;code&gt;W&lt;/code&gt; modela _Avanceable, un &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/BidirectionalIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;BidirectionalIterator&lt;/code&gt; &lt;/a&gt; si &lt;code&gt;W&lt;/code&gt; modela _Decrementable, un &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/ForwardIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;ForwardIterator&lt;/code&gt; &lt;/a&gt; si &lt;code&gt;W&lt;/code&gt; modela &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/Incrementable&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;Incrementable&lt;/code&gt; &lt;/a&gt; , y &lt;a href=&quot;https://en.cppreference.com/mwiki/index.php?title=cpp/iterator/InputIterator&amp;amp;action=edit&amp;amp;redlink=1&quot;&gt; &lt;code&gt;InputIterator&lt;/code&gt; de lo&lt;/a&gt; contrario.</target>
        </trans-unit>
        <trans-unit id="ab311fc847c477a15d5b1d9860db2b6b4cc68c90" translate="yes" xml:space="preserve">
          <source>This is a copy of the the private mutable &lt;code&gt;weak_ptr&lt;/code&gt; member that is part of &lt;code&gt;enable_shared_from_this&lt;/code&gt;.</source>
          <target state="translated">Esta es una copia del miembro privado mutable &lt;code&gt;weak_ptr&lt;/code&gt; que forma parte de &lt;code&gt;enable_shared_from_this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c2a70dd0a39c1457e77f347c24e87c6d5cad7cb" translate="yes" xml:space="preserve">
          <source>This is a list of reserved keywords in C++. Since they are used by the language, these keywords are not available for re-definition or overloading.</source>
          <target state="translated">Esta es una lista de palabras clave reservadas en C++.Dado que son utilizadas por el lenguaje,estas palabras clave no están disponibles para redefinirlas o sobrecargarlas.</target>
        </trans-unit>
        <trans-unit id="317fe1d241fce7e8d40b91008c64f80e35d56f6c" translate="yes" xml:space="preserve">
          <source>This is a low-level data structure; typical conversions from &lt;code&gt;local_time&lt;/code&gt; to &lt;code&gt;sys_time&lt;/code&gt; will use it implicitly rather than explicitly.</source>
          <target state="translated">Esta es una estructura de datos de bajo nivel; Las conversiones t&amp;iacute;picas de &lt;code&gt;local_time&lt;/code&gt; a &lt;code&gt;sys_time&lt;/code&gt; lo usar&amp;aacute;n impl&amp;iacute;citamente en lugar de expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="06fb932be30caede5a481a8189299e404a6d4974" translate="yes" xml:space="preserve">
          <source>This is a reference of the core C++ language constructs.</source>
          <target state="translated">Esta es una referencia del núcleo de las construcciones del lenguaje C++.</target>
        </trans-unit>
        <trans-unit id="e31b548ee1fbca7fa6d3494affb746a0a1a2457c" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the largest value representable by the type &lt;code&gt;std::size_t&lt;/code&gt;, used as the return type of &lt;code&gt;index()&lt;/code&gt; when &lt;code&gt;valueless_by_exception()&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Este es un valor especial igual al valor m&amp;aacute;s grande representable por el tipo &lt;code&gt;std::size_t&lt;/code&gt; , usado como el tipo de retorno de &lt;code&gt;index()&lt;/code&gt; cuando &lt;code&gt;valueless_by_exception()&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a39c0c855473751858895d7068c8ca7b082d5f62" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of string indicator by the functions that expect a string index or as the error indicator by the functions that return a string index.</source>
          <target state="translated">Este es un valor especial igual al valor m&amp;aacute;ximo representable por el tipo &lt;code&gt;size_type&lt;/code&gt; . El significado exacto depende del contexto, pero generalmente se usa como indicador de final de cadena por las funciones que esperan un &amp;iacute;ndice de cadena o como indicador de error por las funciones que devuelven un &amp;iacute;ndice de cadena.</target>
        </trans-unit>
        <trans-unit id="8ef208e1bc26501dbfeecb667b7796cbd9eef4a6" translate="yes" xml:space="preserve">
          <source>This is a special value equal to the maximum value representable by the type &lt;code&gt;size_type&lt;/code&gt;. The exact meaning depends on context, but it is generally used either as end of view indicator by the functions that expect a view index or as the error indicator by the functions that return a view index.</source>
          <target state="translated">Este es un valor especial igual al valor m&amp;aacute;ximo representable por el tipo &lt;code&gt;size_type&lt;/code&gt; . El significado exacto depende del contexto, pero generalmente se usa como indicador de fin de vista por las funciones que esperan un &amp;iacute;ndice de vista o como indicador de error por las funciones que devuelven un &amp;iacute;ndice de vista.</target>
        </trans-unit>
        <trans-unit id="2d9f89f3207c56d0f6ab075de354388d63d28553" translate="yes" xml:space="preserve">
          <source>This is a specialized allocator-aware container. It can only be default created, obtained from &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt;, or modified by &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt;. Because &lt;code&gt;std::match_results&lt;/code&gt; holds &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;es, each of which is a pair of iterators into the original character sequence that was matched, it's undefined behavior to examine &lt;code&gt;std::match_results&lt;/code&gt; if the original character sequence was destroyed or iterators to it were invalidated for other reasons.</source>
          <target state="translated">Este es un contenedor especializado para el asignador. Solo puede crearse por defecto, obtenerse de &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; o modificarse por &lt;code&gt;&lt;a href=&quot;regex_search&quot;&gt;std::regex_search&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;regex_match&quot;&gt;std::regex_match&lt;/a&gt;&lt;/code&gt; . Debido a que &lt;code&gt;std::match_results&lt;/code&gt; contiene &lt;code&gt;&lt;a href=&quot;sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; es, cada uno de los cuales es un par de iteradores en la secuencia de caracteres original que coincide, es un comportamiento indefinido examinar &lt;code&gt;std::match_results&lt;/code&gt; si la secuencia de caracteres original fue destruida o si los iteradores fueron invalidado por otras razones.</target>
        </trans-unit>
        <trans-unit id="dcbd4929cfc88985415e596c60e165a57a093570" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S, puede ser llamada con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::fixed&lt;/code&gt; para cualquier &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; o con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::scientific&lt;/code&gt; para cualquier &lt;code&gt;in&lt;/code&gt; de escriba &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="937bf19df4c0af79385dda35f013197f369e8f37" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S, puede ser llamada con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::noskipws&lt;/code&gt; para cualquier &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; o con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::noskipws&lt;/code&gt; para cualquier &lt;code&gt;in&lt;/code&gt; de escriba &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b42315a6cd8a7f333df8749952b733651d2fec90" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S, puede ser llamada con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::showbase&lt;/code&gt; para cualquier &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; o con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::showbase&lt;/code&gt; para cualquier &lt;code&gt;in&lt;/code&gt; de escriba &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70463fd9c90aded7947bc0ce3158695492cf938d" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S, puede ser llamada con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::showpoint&lt;/code&gt; para cualquier &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; o con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::showpoint&lt;/code&gt; para cualquier &lt;code&gt;in&lt;/code&gt; de escriba &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf76b611f62f218dd5340fb19c1a0b0493038e0e" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S, se puede &lt;code&gt;out &amp;lt;&amp;lt; std::showpos&lt;/code&gt; con una expresi&amp;oacute;n como out &amp;lt;&amp;lt; std :: showpos para cualquier tipo &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; o con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::showpos&lt;/code&gt; para cualquiera &lt;code&gt;in&lt;/code&gt; de escriba &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b963cb12fe265e17a4ede1e827c0c6875636dad" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S, se puede &lt;code&gt;out &amp;lt;&amp;lt; std::unitbuf&lt;/code&gt; con una expresi&amp;oacute;n como out &amp;lt;&amp;lt; std :: unitbuf para cualquier tipo &lt;code&gt;out&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; o con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::unitbuf&lt;/code&gt; para cualquiera &lt;code&gt;in&lt;/code&gt; de escriba &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0de5a017268c93f9adb1760286b7389369587a" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S, puede ser llamada con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::uppercase&lt;/code&gt; para cualquier &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; o con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::uppercase&lt;/code&gt; para cualquier &lt;code&gt;in&lt;/code&gt; de escriba &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="daf2205ff27f5d190edd20850443509692eb70e0" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S. Se le puede llamar con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::hex&lt;/code&gt; para cualquier &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; o con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::hex&lt;/code&gt; para cualquier &lt;code&gt;in&lt;/code&gt; tipo &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9f3502e7e7df95e12c9da2ae171edd9ba6a04db" translate="yes" xml:space="preserve">
          <source>This is an I/O manipulator. It may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; or with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S. Se le puede llamar con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::left&lt;/code&gt; para cualquier &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; o con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::left&lt;/code&gt; para cualquier &lt;code&gt;in&lt;/code&gt; tipo &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c0b02e3721ebe7f5ac3c4b5ffc6c0f2d28f4fc9" translate="yes" xml:space="preserve">
          <source>This is an N:M conversion facet, and cannot be used with &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (which only permits 1:N conversions, such as UTF-32/UTF-8, between the internal and the external encodings). This facet can be used with &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta es una faceta de conversi&amp;oacute;n N: M, y no se puede usar con &lt;code&gt;&lt;a href=&quot;../io/basic_filebuf&quot;&gt;std::basic_filebuf&lt;/a&gt;&lt;/code&gt; (que solo permite conversiones 1: N, como UTF-32 / UTF-8, entre las codificaciones internas y externas). Esta faceta se puede usar con &lt;code&gt;&lt;a href=&quot;wstring_convert&quot;&gt;std::wstring_convert&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f532dd6dda7ce4e7fef9024ca6a90c38fdddd97" translate="yes" xml:space="preserve">
          <source>This is an input-only I/O manipulator, it may be called with an expression such as &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; for any &lt;code&gt;in&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de s&amp;oacute;lo entrada I / O, que puede ser llamado con una expresi&amp;oacute;n como &lt;code&gt;in &amp;gt;&amp;gt; std::ws&lt;/code&gt; para cualquier &lt;code&gt;in&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e42acc2eabf231ad6ab330a8662f12700cd267a5" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S solo de salida, se puede &lt;code&gt;out &amp;lt;&amp;lt; std::emit_on_flush&lt;/code&gt; con una expresi&amp;oacute;n como out &amp;lt;&amp;lt; std :: emit_on_flush para cualquier tipo &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60e12fb0d661bde8d9b081c1cd879d866b874d0f" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S de solo salida, se puede llamar con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::endl&lt;/code&gt; para cualquier tipo &lt;code&gt;out&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="651708b37cd7ae8cdbb511a6453c7ac66edb7063" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S de solo salida, se puede &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::ends&lt;/code&gt; para cualquier tipo &lt;code&gt;out&lt;/code&gt; de std :: basic_ostream .</target>
        </trans-unit>
        <trans-unit id="cb0b93b12bb860d769cac7587fe1bddc043d0e17" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S de solo salida, se puede &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; con una expresi&amp;oacute;n como &lt;code&gt;out &amp;lt;&amp;lt; std::flush&lt;/code&gt; para cualquier tipo &lt;code&gt;out&lt;/code&gt; de std :: basic_ostream .</target>
        </trans-unit>
        <trans-unit id="297f17cae564feba63e3617363eb17ca7ff29374" translate="yes" xml:space="preserve">
          <source>This is an output-only I/O manipulator, it may be called with an expression such as &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; for any &lt;code&gt;out&lt;/code&gt; of type &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este es un manipulador de E / S solo de salida, se puede &lt;code&gt;out &amp;lt;&amp;lt; std::flush_emit&lt;/code&gt; con una expresi&amp;oacute;n como out &amp;lt;&amp;lt; std :: flush_emit para cualquier tipo &lt;code&gt;out&lt;/code&gt; de tipo &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="042aa022f3538e0380d9238f1617babc4f91044d" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Esto se hace llamando a &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; y &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6d1a687deef64a2de24aab2940536db537dc7c30" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Esto se hace llamando a &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; y &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8519863f445ff4dc4073c63885010fc835c9d17f" translate="yes" xml:space="preserve">
          <source>This is done by calling &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Esto se hace llamando a &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; y &lt;code&gt;rdbuf()-&amp;gt;swap(other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="36ff5f6b7bbdd8db83afcceb063e1cc859a416c7" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Esto se hace llamando a &lt;code&gt;basic_iostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; y &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82ad146be2cb4f18f794320cb99236e3f0e5a7de" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Esto se hace llamando a &lt;code&gt;basic_istream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; y &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="786b3029313db82a7b7425ea04d749d77cb88554" translate="yes" xml:space="preserve">
          <source>This is done by calling&lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt;.</source>
          <target state="translated">Esto se hace llamando a &lt;code&gt;basic_ostream&amp;lt;CharT, Traits&amp;gt;::swap(other)&lt;/code&gt; y &lt;code&gt;rdbuf()-&amp;gt;swap(*other.rdbuf())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd8409ce8140988c0f9cd5273c17f072a8e1133" translate="yes" xml:space="preserve">
          <source>This is no longer allowed in C++17. Instead the array form &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; should be used.</source>
          <target state="translated">Esto ya no est&amp;aacute; permitido en C ++ 17. En su lugar, se debe usar la forma de matriz &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="873c5086291117573f8d6d6edce6a8a27dcea191" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from (i.e. returned by &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt;) until the first time &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Este es el caso solo para futuros que no se construyeron o movieron por defecto (es decir, devueltos por &lt;code&gt;&lt;a href=&quot;../promise/get_future&quot;&gt;std::promise::get_future()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../packaged_task/get_future&quot;&gt;std::packaged_task::get_future()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../async&quot;&gt;std::async()&lt;/a&gt;&lt;/code&gt; ) hasta el primero Se llama a time &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;share&quot;&gt;share()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cf0f969d26a72355354c117d383b2d725eed3830" translate="yes" xml:space="preserve">
          <source>This is the case only for futures that were not default-constructed or moved from. Unlike &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;std::shared_future&lt;/code&gt;'s shared state is not invalidated when &lt;code&gt;get()&lt;/code&gt; is called.</source>
          <target state="translated">Este es el caso solo para futuros que no se construyeron por defecto ni se movieron. A diferencia de &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; , el estado compartido de &lt;code&gt;std::shared_future&lt;/code&gt; no se invalida cuando se llama a &lt;code&gt;get()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="654479f728093b995df666411bdb28aa8834e6ea" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;../language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">Esta es la clase devuelta por el operador &lt;a href=&quot;../language/typeid&quot;&gt;typeid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a54fb420dbec256007f5b5fe39b66f1e973e225c" translate="yes" xml:space="preserve">
          <source>This is the class returned by the &lt;a href=&quot;language/typeid&quot;&gt; typeid&lt;/a&gt; operator.</source>
          <target state="translated">Esta es la clase devuelta por el operador &lt;a href=&quot;language/typeid&quot;&gt;typeid&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b68e57b066a7bc6709ae7f2c462030b2b3f61772" translate="yes" xml:space="preserve">
          <source>This is the continuous counterpart of &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta es la contrapartida continua de &lt;code&gt;&lt;a href=&quot;geometric_distribution&quot;&gt;std::geometric_distribution&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4bd023e111f5d2be5d722aa1cd31d0bb87464c42" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with an empty initializer.</source>
          <target state="translated">Es la inicialización que se realiza cuando se construye una variable con un inicializador vacío.</target>
        </trans-unit>
        <trans-unit id="e592a74f67ac1f9613e037ec54f2110302e91afd" translate="yes" xml:space="preserve">
          <source>This is the initialization performed when a variable is constructed with no initializer.</source>
          <target state="translated">Es la inicialización que se realiza cuando se construye una variable sin inicializador.</target>
        </trans-unit>
        <trans-unit id="df01ca6b36b691a562048440349e8dc25830ccb7" translate="yes" xml:space="preserve">
          <source>This is the iterator returned by member functions &lt;code&gt;rbegin()&lt;/code&gt; and &lt;code&gt;rend()&lt;/code&gt; of the standard library containers.</source>
          <target state="translated">Este es el iterador devuelto por las funciones miembro &lt;code&gt;rbegin()&lt;/code&gt; y &lt;code&gt;rend()&lt;/code&gt; de los contenedores de biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="f5ad9a77cced8620a8dd7901ec2fb07df1c2718e" translate="yes" xml:space="preserve">
          <source>This is the only publicly accessible and defined constructor.</source>
          <target state="translated">Este es el único constructor públicamente accesible y definido.</target>
        </trans-unit>
        <trans-unit id="678d1fe5005da438d1e76e438f6b694064724ab0" translate="yes" xml:space="preserve">
          <source>This is the only way to initialize &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; to a definite value: the value held after any other initialization is unspecified.</source>
          <target state="translated">Esta es la &amp;uacute;nica forma de inicializar &lt;code&gt;&lt;a href=&quot;atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; a un valor definido: el valor retenido despu&amp;eacute;s de cualquier otra inicializaci&amp;oacute;n no est&amp;aacute; especificado.</target>
        </trans-unit>
        <trans-unit id="812af2a36c3f95774b9b7221df53591bbffef4a8" translate="yes" xml:space="preserve">
          <source>This is typically possible for the characters from the ASCII character set, since most multibyte encodings (such as UTF-8) use single bytes to encode those characters.</source>
          <target state="translated">Esto es típicamente posible para los caracteres del conjunto de caracteres ASCII,ya que la mayoría de las codificaciones multibyte (como UTF-8)utilizan bytes individuales para codificar esos caracteres.</target>
        </trans-unit>
        <trans-unit id="4d2e82e79a4c00e49cbeb6cd456e401a3f7c67b6" translate="yes" xml:space="preserve">
          <source>This is used to capture move-only types with a capture such as &lt;code&gt;x = std::move(x)&lt;/code&gt;.</source>
          <target state="translated">Esto se usa para capturar tipos de solo movimiento con una captura como &lt;code&gt;x = std::move(x)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d03b82ce1e09a94b53a9663441cf142803eed2e" translate="yes" xml:space="preserve">
          <source>This is used, for example, by &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt;, which may have to allocate new storage and then move or copy elements from old storage to new storage. If an exception occurs during this operation, &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; undoes everything it did to this point, which is only possible if &lt;code&gt;std::move_if_noexcept&lt;/code&gt; was used to decide whether to use move construction or copy construction. (unless copy constructor is not available, in which case move constructor is used either way and the strong exception guarantee may be waived).</source>
          <target state="translated">Esto lo usa, por ejemplo, &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; , que puede tener que asignar un nuevo almacenamiento y luego mover o copiar elementos del almacenamiento anterior al nuevo. Si se produce una excepci&amp;oacute;n durante esta operaci&amp;oacute;n, &lt;code&gt;&lt;a href=&quot;../container/vector/resize&quot;&gt;std::vector::resize&lt;/a&gt;&lt;/code&gt; deshace todo lo que hizo hasta este punto, lo cual solo es posible si se us&amp;oacute; &lt;code&gt;std::move_if_noexcept&lt;/code&gt; para decidir si usar la construcci&amp;oacute;n de movimiento o copiar la construcci&amp;oacute;n. (a menos que el constructor de copia no est&amp;eacute; disponible, en cuyo caso el constructor de movimiento se usa de cualquier manera y se puede renunciar a la garant&amp;iacute;a de excepci&amp;oacute;n fuerte).</target>
        </trans-unit>
        <trans-unit id="65497cbcaeca38825fa3feca97f3678010e28f07" translate="yes" xml:space="preserve">
          <source>This lookup with the reversed arguments order makes it possible to write just one &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; to generate all comparisons between &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;const char*&lt;/code&gt;, both ways. See &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt; for more detail.</source>
          <target state="translated">Esta b&amp;uacute;squeda con el orden de argumentos invertidos hace posible escribir un solo &lt;code&gt;operatror&amp;lt;=&amp;gt;(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;, const char*)&lt;/code&gt; para generar todas las comparaciones entre &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;const char*&lt;/code&gt; , en ambos sentidos. Consulte las &lt;a href=&quot;default_comparisons&quot;&gt;comparaciones predeterminadas&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="7c00bd2988f8e6fd1c69153710829dd41df339f1" translate="yes" xml:space="preserve">
          <source>This macro is primarily provided for compatibility with C; it behaves the same as the constructor of &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta macro se proporciona principalmente para compatibilidad con C; se comporta igual que el constructor de &lt;code&gt;&lt;a href=&quot;atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="69dae22caf55af4023255754b9c726f9f5527dad" translate="yes" xml:space="preserve">
          <source>This makes it possible to introduce new integer types (e.g. SafeInt) that enjoy the same existing calling conventions as their underlying integer types, even on ABIs that penalize passing/returning structures by value.</source>
          <target state="translated">Esto permite introducir nuevos tipos de números enteros (por ejemplo,SafeInt)que gozan de las mismas convenciones de llamada existentes que sus tipos de números enteros subyacentes,incluso en las ABI que penalizan las estructuras de paso/devolución por valor.</target>
        </trans-unit>
        <trans-unit id="1fced9487368a0914863ecd65a116e588baecbc7" translate="yes" xml:space="preserve">
          <source>This makes it possible to move out of an object in scope that is no longer needed:</source>
          <target state="translated">Esto permite salir de un objeto de alcance que ya no es necesario:</target>
        </trans-unit>
        <trans-unit id="9c4ec0eda49a5a6eec06bfb350abc5e50dec706c" translate="yes" xml:space="preserve">
          <source>This manipulator is typically used with &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt;, when the associated output buffer needs to be null-terminated to be processed as a C string.</source>
          <target state="translated">Este manipulador generalmente se usa con &lt;code&gt;&lt;a href=&quot;../ostrstream&quot;&gt;std::ostrstream&lt;/a&gt;&lt;/code&gt; , cuando el b&amp;uacute;fer de salida asociado debe terminarse en nulo para procesarse como una cadena C.</target>
        </trans-unit>
        <trans-unit id="0d033cddb2872a1515d402a6be03415f6aa84c5a" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce a line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O. In most other usual interactive I/O scenarios, &lt;code&gt;std::endl&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;. Use of &lt;code&gt;std::endl&lt;/code&gt; in place of &lt;code&gt;'\n'&lt;/code&gt;, encouraged by some sources, may significantly degrade output performance.</source>
          <target state="translated">Este manipulador se puede usar para producir una l&amp;iacute;nea de salida de inmediato, por ejemplo, cuando se muestra la salida de un proceso de larga ejecuci&amp;oacute;n, la actividad de registro de varios subprocesos o la actividad de registro de un programa que puede bloquearse inesperadamente. Tambi&amp;eacute;n es necesario un &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; expl&amp;iacute;cito de std :: cout antes de una llamada a &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; , si el proceso generado realiza alguna E / S de pantalla. En la mayor&amp;iacute;a de los dem&amp;aacute;s escenarios de E / S interactivos habituales, &lt;code&gt;std::endl&lt;/code&gt; es redundante cuando se usa con &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; porque cualquier entrada de &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , salida a &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; o terminaci&amp;oacute;n del programa fuerza una llamada a &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; . Uso de &lt;code&gt;std::endl&lt;/code&gt; en lugar de &lt;code&gt;'\n'&lt;/code&gt; , alentado por algunas fuentes, puede degradar significativamente el rendimiento de salida.</target>
        </trans-unit>
        <trans-unit id="c4f2d1bbb43a26f1c14fa7b3e243baca9ad4d3dc" translate="yes" xml:space="preserve">
          <source>This manipulator may be used to produce an incomplete line of output immediately, e.g. when displaying output from a long-running process, logging activity of multiple threads or logging activity of a program that may crash unexpectedly. An explicit flush of &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; is also necessary before a call to &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt;, if the spawned process performs any screen I/O (a common example is &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; on Windows). In most other usual interactive I/O scenarios, &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; is redundant when used with &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; because any input from &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt;, output to &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt;, or program termination forces a call to &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt;.</source>
          <target state="translated">Este manipulador se puede usar para producir una l&amp;iacute;nea de salida incompleta de inmediato, por ejemplo, cuando se muestra la salida de un proceso de larga ejecuci&amp;oacute;n, la actividad de registro de m&amp;uacute;ltiples subprocesos o la actividad de registro de un programa que puede bloquearse inesperadamente. Tambi&amp;eacute;n es necesario un &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; expl&amp;iacute;cito de std :: cout antes de una llamada a &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;&lt;/code&gt; , si el proceso generado realiza alguna E / S de pantalla (un ejemplo com&amp;uacute;n es &lt;code&gt;&lt;a href=&quot;../../utility/program/system&quot;&gt;std::system&lt;/a&gt;(&quot;pause&quot;)&lt;/code&gt; en Windows). En la mayor&amp;iacute;a de los dem&amp;aacute;s escenarios de E / S interactivos habituales, &lt;code&gt;&lt;a href=&quot;endl&quot;&gt;std::endl&lt;/a&gt;&lt;/code&gt; es redundante cuando se usa con &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; porque cualquier entrada de &lt;code&gt;&lt;a href=&quot;../cin&quot;&gt;std::cin&lt;/a&gt;&lt;/code&gt; , salida a &lt;code&gt;&lt;a href=&quot;../cerr&quot;&gt;std::cerr&lt;/a&gt;&lt;/code&gt; o terminaci&amp;oacute;n del programa fuerza una llamada a &lt;code&gt;&lt;a href=&quot;../cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8bc45ac3ed46d59a0178ef3c27e45979eabda25" translate="yes" xml:space="preserve">
          <source>This may be used to avoid unnecessary &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; fences when the dependency chain leaves function scope (and the function does not have the &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; attribute).</source>
          <target state="translated">Esto puede usarse para evitar vallas innecesarias &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order_acquire&lt;/a&gt;&lt;/code&gt; cuando la cadena de dependencia deja el alcance de la funci&amp;oacute;n (y la funci&amp;oacute;n no tiene el atributo &lt;code&gt;[[&lt;a href=&quot;../language/attributes/carries_dependency&quot;&gt;carries_dependency&lt;/a&gt;]]&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="56eb878738bcafe0dda45a9b25b2771a66434232" translate="yes" xml:space="preserve">
          <source>This may happen if the pointer is assigned to:</source>
          <target state="translated">Esto puede suceder si se asigna el puntero:</target>
        </trans-unit>
        <trans-unit id="263227da37307b0a3267455a4c633b69bc493839" translate="yes" xml:space="preserve">
          <source>This means that &lt;code&gt;match[i].position()&lt;/code&gt; gives the offset from the beginning of the target sequence, which is often not the same as the offset from the sequence passed in the call to &lt;code&gt;regex_search&lt;/code&gt;.</source>
          <target state="translated">Esto significa que &lt;code&gt;match[i].position()&lt;/code&gt; proporciona el desplazamiento desde el comienzo de la secuencia de destino, que a menudo no es lo mismo que el desplazamiento desde la secuencia pasada en la llamada a &lt;code&gt;regex_search&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2cdccbba38d49dbd4067105548f38475359bb552" translate="yes" xml:space="preserve">
          <source>This means that in a conforming implementation, including this header has no effect.</source>
          <target state="translated">Esto significa que en una implementación conforme,incluyendo este encabezado no tiene ningún efecto.</target>
        </trans-unit>
        <trans-unit id="558bc6404fe9a7280ef6a558ff20ea8606c413a8" translate="yes" xml:space="preserve">
          <source>This means that there are no aliases in the elements and this property can be used to perform some kinds of optimization.</source>
          <target state="translated">Esto significa que no hay alias en los elementos y esta propiedad puede ser utilizada para realizar algunos tipos de optimización.</target>
        </trans-unit>
        <trans-unit id="81b15552e359daa797fa96a9d36a5f3772826f69" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression.</source>
          <target state="translated">Este mecanismo permite utilizar operadores de plantilla,ya que no hay sintaxis para especificar los argumentos de la plantilla para un operador más que reescribiéndola como una expresión de llamada a la función.</target>
        </trans-unit>
        <trans-unit id="baabe2e811ea477176a6b1ba57aacf61a6c0bf94" translate="yes" xml:space="preserve">
          <source>This mechanism makes it possible to use template operators, since there is no syntax to specify template arguments for an operator other than by re-writing it as a function call expression:</source>
          <target state="translated">Este mecanismo permite utilizar operadores de plantilla,ya que no hay sintaxis para especificar los argumentos de la plantilla para un operador más que reescribiéndola como una expresión de llamada a la función:</target>
        </trans-unit>
        <trans-unit id="631b5699cc80fd8b4a70a5399e59151e856f7a18" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; once the associated stream buffer is known. Until this function is called, every member function (including the destructor) of the default-constructed &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; invokes undefined behavior. Note that &lt;code&gt;basic_ios&lt;/code&gt; is a virtual base class, and therefore its constructor is not called by the constructors of those directly derived classes, which is why two-stage initialization is necessary.</source>
          <target state="translated">Esta funci&amp;oacute;n miembro est&amp;aacute; protegida: es &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; por los constructores de las clases de flujo derivadas std :: basic_istream y &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; una vez que se conoce el b&amp;uacute;fer de flujo asociado. Hasta que se llame a esta funci&amp;oacute;n, cada funci&amp;oacute;n miembro (incluido el destructor) del &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; construido por defecto invoca un comportamiento indefinido. Tenga en cuenta que &lt;code&gt;basic_ios&lt;/code&gt; es una clase base virtual y, por lo tanto, su constructor no es llamado por los constructores de esas clases directamente derivadas, por lo que es necesaria la inicializaci&amp;oacute;n en dos etapas.</target>
        </trans-unit>
        <trans-unit id="9ff0b24c8b1bcff91c847b5b05e80e90bc1f2ed8" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the move constructors of the derived streams such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, as the final step after constructing the base class and after moving the stream buffer: only the most derived stream class knows how to correctly move the stream buffer, but &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; needs to be made aware of the stream's new location so that its public member functions can access it.</source>
          <target state="translated">Esta funci&amp;oacute;n miembro est&amp;aacute; protegida: es llamada por los constructores de movimiento de las secuencias derivadas, como &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; , como el paso final despu&amp;eacute;s de construir la clase base y despu&amp;eacute;s de mover el b&amp;uacute;fer de secuencia: solo la secuencia m&amp;aacute;s derivada La clase sabe c&amp;oacute;mo mover correctamente el b&amp;uacute;fer de la secuencia, pero &lt;code&gt;&lt;a href=&quot;../basic_ios&quot;&gt;std::basic_ios&lt;/a&gt;&lt;/code&gt; necesita conocer la nueva ubicaci&amp;oacute;n de la secuencia para que sus funciones miembro p&amp;uacute;blicas puedan acceder a ella.</target>
        </trans-unit>
        <trans-unit id="9c3c6a60b1284f57464c304d4f49e3141a9265a5" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the protected move constructors of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt;, which, in turn, are called by the public move constructors of the further derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly move the associated streambuffer.</source>
          <target state="translated">Esta funci&amp;oacute;n miembro est&amp;aacute; protegida: es llamada por los constructores de movimiento protegidos de las clases de flujo derivadas &lt;code&gt;&lt;a href=&quot;../basic_ostream&quot;&gt;std::basic_ostream&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../basic_istream&quot;&gt;std::basic_istream&lt;/a&gt;&lt;/code&gt; , que, a su vez, son llamados por los constructores de movimiento p&amp;uacute;blico de las clases de flujo derivadas adicionales como &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; , que sabe c&amp;oacute;mo mover correctamente el streambuffer asociado.</target>
        </trans-unit>
        <trans-unit id="6018aedea85c8af7152a8d08f9289d2de94a185f" translate="yes" xml:space="preserve">
          <source>This member function is protected: it is called by the swap member functions of the derived stream classes &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated stream buffers.</source>
          <target state="translated">Esta funci&amp;oacute;n miembro est&amp;aacute; protegida: es llamada por las funciones miembro de intercambio de las clases de flujo derivadas &lt;code&gt;&lt;a href=&quot;../basic_stringstream&quot;&gt;std::basic_stringstream&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../basic_fstream&quot;&gt;std::basic_fstream&lt;/a&gt;&lt;/code&gt; , que saben c&amp;oacute;mo intercambiar correctamente los buffers de flujo asociados.</target>
        </trans-unit>
        <trans-unit id="194eca0c3ce225b7c17b35f16086bbd18ea24522" translate="yes" xml:space="preserve">
          <source>This metafunction is a convenient way to leverage &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; to conditionally remove functions from &lt;a href=&quot;../language/overload_resolution&quot;&gt;overload resolution&lt;/a&gt; based on type traits and to provide separate function overloads and specializations for different type traits. &lt;code&gt;std::enable_if&lt;/code&gt; can be used as an additional function argument (not applicable to operator overloads), as a return type (not applicable to constructors and destructors), or as a class template or function template parameter.</source>
          <target state="translated">Esta metafunci&amp;oacute;n es una manera conveniente de aprovechar &lt;a href=&quot;../language/sfinae&quot;&gt;SFINAE&lt;/a&gt; para eliminar condicionalmente las funciones de la &lt;a href=&quot;../language/overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga en&lt;/a&gt; funci&amp;oacute;n de los rasgos de tipo y proporcionar sobrecargas de funciones y especializaciones separadas para diferentes rasgos de tipo. &lt;code&gt;std::enable_if&lt;/code&gt; puede usarse como un argumento de funci&amp;oacute;n adicional (no aplicable a sobrecargas de operadores), como un tipo de retorno (no aplicable a constructores y destructores), o como una plantilla de clase o par&amp;aacute;metro de plantilla de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a1422282434c61f7b9a780c953c50b153fde9dfb" translate="yes" xml:space="preserve">
          <source>This metafunction is used in template metaprogramming to detect ill-formed types in SFINAE context:</source>
          <target state="translated">Esta metafunción se utiliza en la metaprogramación de plantillas para detectar tipos mal formados en el contexto del SFINAE:</target>
        </trans-unit>
        <trans-unit id="1a68dc4a214d5a2f0c86986f5fcbb662600bbbaa" translate="yes" xml:space="preserve">
          <source>This only applies if the arithmetic is two's complement which is only required for the &lt;a href=&quot;../types/integer&quot;&gt;exact-width integer types&lt;/a&gt;. Note, however, that at the moment all platforms with a C++ compiler use two's complement arithmetic</source>
          <target state="translated">Esto solo se aplica si la aritm&amp;eacute;tica es un complemento de dos, que solo se requiere para los &lt;a href=&quot;../types/integer&quot;&gt;tipos enteros de ancho exacto&lt;/a&gt; . Sin embargo, tenga en cuenta que, en este momento, todas las plataformas con un compilador de C ++ usan aritm&amp;eacute;tica complementaria de dos</target>
        </trans-unit>
        <trans-unit id="28bba53040cc59e4ebfb5e6b23947d5f3e555523" translate="yes" xml:space="preserve">
          <source>This operation</source>
          <target state="translated">Esta operación</target>
        </trans-unit>
        <trans-unit id="ee376cb133ce3fa6134bf19377f3a3fc9a03d186" translate="yes" xml:space="preserve">
          <source>This operation is commonly implemented in hardware as &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;fused multiply-add&lt;/a&gt; CPU instruction. If supported by hardware, the appropriate &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; macros are expected to be defined, but many implementations make use of the CPU instruction even when the macros are not defined.</source>
          <target state="translated">Esta operaci&amp;oacute;n se implementa com&amp;uacute;nmente en el hardware como instrucciones de CPU de &lt;a href=&quot;https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation&quot;&gt;m&amp;uacute;ltiples agregados fusionados&lt;/a&gt; . Si es compatible con el hardware, se espera que se definan las macros &lt;code&gt;FP_FAST_FMA*&lt;/code&gt; apropiadas , pero muchas implementaciones utilizan la instrucci&amp;oacute;n de la CPU incluso cuando las macros no est&amp;aacute;n definidas.</target>
        </trans-unit>
        <trans-unit id="677f69ad7dd084269c9619b79f0d75fdd900458e" translate="yes" xml:space="preserve">
          <source>This operation is stable: for equivalent elements in the two lists, the elements from &lt;code&gt;*this&lt;/code&gt; shall always precede the elements from &lt;code&gt;other&lt;/code&gt;, and the order of equivalent elements of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; does not change.</source>
          <target state="translated">Esta operaci&amp;oacute;n es estable: para elementos equivalentes en las dos listas, los elementos de &lt;code&gt;*this&lt;/code&gt; siempre preceder&amp;aacute;n a los elementos de &lt;code&gt;other&lt;/code&gt; , y el orden de elementos equivalentes de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; no cambia.</target>
        </trans-unit>
        <trans-unit id="e1a54e7ed923b5cbda29b41bb3cef5210c3e3c16" translate="yes" xml:space="preserve">
          <source>This operator does not check whether the optional contains a value! You can do so manually by using &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; or simply &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt;. Alternatively, if checked access is needed, &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; may be used.</source>
          <target state="translated">&amp;iexcl;Este operador no verifica si el opcional contiene un valor! Puede hacerlo manualmente utilizando &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;has_value()&lt;/a&gt;&lt;/code&gt; o simplemente el &lt;code&gt;&lt;a href=&quot;operator_bool&quot;&gt;operator bool()&lt;/a&gt;&lt;/code&gt; . Alternativamente, si se necesita acceso verificado, se puede usar &lt;code&gt;&lt;a href=&quot;value&quot;&gt;value()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;value_or&quot;&gt;value_or()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76837e505361cd0d1e62fe926fca10a41668aadc" translate="yes" xml:space="preserve">
          <source>This operator is declared in the namespace &lt;code&gt;std::literals::chrono_literals&lt;/code&gt;, where both &lt;code&gt;literals&lt;/code&gt; and &lt;code&gt;chrono_literals&lt;/code&gt; are inline namespaces. Access to this operator can be gained with &lt;code&gt;using namespace std::literals&lt;/code&gt;, &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt;, and &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt;.</source>
          <target state="translated">Este operador se declara en el espacio de nombres &lt;code&gt;std::literals::chrono_literals&lt;/code&gt; , donde tanto &lt;code&gt;literals&lt;/code&gt; como &lt;code&gt;chrono_literals&lt;/code&gt; son espacios de nombres en l&amp;iacute;nea. El acceso a este operador se puede obtener &lt;code&gt;using namespace std::literals&lt;/code&gt; , &lt;code&gt;using namespace std::chrono_literals&lt;/code&gt; y &lt;code&gt;using namespace std::literals::chrono_literals&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c90a4015c270f47b35bf150eaa6f8ff8b7041fe0" translate="yes" xml:space="preserve">
          <source>This operator makes it possible to use streams and functions that return references to streams as loop conditions, resulting in the idiomatic C++ input loops such as &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; or &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt;. Such loops execute the loop's body only if the input operation succeeded.</source>
          <target state="translated">Este operador hace posible el uso de secuencias y funciones que devuelven referencias a secuencias como condiciones de bucle, lo que resulta en bucles de entrada idiom&amp;aacute;ticos de C ++ como &lt;code&gt;while(stream &amp;gt;&amp;gt; value) {...}&lt;/code&gt; o &lt;code&gt;while(getline(stream, string)){...}&lt;/code&gt; . Dichos bucles ejecutan el cuerpo del bucle solo si la operaci&amp;oacute;n de entrada tuvo &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="70eb80993771f43d98c8f63a162d2abf81c3b412" translate="yes" xml:space="preserve">
          <source>This order determines the order in which constraints are instantiated when checking for satisfaction.</source>
          <target state="translated">Este orden determina el orden en el que se instancian las restricciones al comprobar la satisfacción.</target>
        </trans-unit>
        <trans-unit id="ebf5e8fbc6ec56b576aeb159cdeac4bba0a41f70" translate="yes" xml:space="preserve">
          <source>This ordering is used to make shared and weak pointers usable as keys in associative containers, typically through &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Este orden se utiliza para hacer que los punteros compartidos y d&amp;eacute;biles se puedan usar como claves en contenedores asociativos, generalmente a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../owner_less&quot;&gt;std::owner_less&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1a82251ba96a19d119ca9bfa58e9f2f497a9f62" translate="yes" xml:space="preserve">
          <source>This overload does not subtract the parsed offset (if any) from the parsed timestamp, unlike the &lt;code&gt;from_stream&lt;/code&gt; overloads for the &lt;code&gt;time_point&lt;/code&gt; of other clocks.</source>
          <target state="translated">Esta sobrecarga no resta el desplazamiento analizado (si lo hay) de la marca de tiempo analizada, a diferencia de las sobrecargas de &lt;code&gt;from_stream&lt;/code&gt; para el &lt;code&gt;time_point&lt;/code&gt; de tiempo de otros relojes.</target>
        </trans-unit>
        <trans-unit id="4bf7c4e2eb5387c99cb1a1ffeb6f0e5e88754a17" translate="yes" xml:space="preserve">
          <source>This overload doesn't participate in overload resolution if &lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; is not</source>
          <target state="translated">Esta sobrecarga no participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;std::unique_ptr&amp;lt;Y, Deleter&amp;gt;::pointer&lt;/code&gt; no es</target>
        </trans-unit>
        <trans-unit id="bc6f7584722885d728d6854cb8736855f9270a48" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (1) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Esta sobrecarga tiene el mismo efecto que la sobrecarga (1) si &lt;code&gt;InputIt&lt;/code&gt; es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="1fa4602d949f8f6973ff6fea1f4b9e68fc722e4c" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (3) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Esta sobrecarga tiene el mismo efecto que la sobrecarga (3) si &lt;code&gt;InputIt&lt;/code&gt; es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="7a8485de9a7d7bca2cd829541418ca26242baca3" translate="yes" xml:space="preserve">
          <source>This overload has the same effect as overload (6) if &lt;code&gt;InputIt&lt;/code&gt; is an integral type.</source>
          <target state="translated">Esta sobrecarga tiene el mismo efecto que la sobrecarga (6) si &lt;code&gt;InputIt&lt;/code&gt; es un tipo integral.</target>
        </trans-unit>
        <trans-unit id="70e5d40a020e1e29942bf932764b7fdcf68a80bf" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rbegin&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga es necesaria porque &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; no tiene una funci&amp;oacute;n miembro &lt;code&gt;rbegin&lt;/code&gt; . No se necesita sobrecarga para &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::crbegin&lt;/a&gt;&lt;/code&gt; porque se implementa en t&amp;eacute;rminos de &lt;code&gt;&lt;a href=&quot;../../iterator/rbegin&quot;&gt;std::rbegin&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ade89453e12ddb644d64137481026bf6616fd814" translate="yes" xml:space="preserve">
          <source>This overload is necessary because &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; does not have a member function &lt;code&gt;rend&lt;/code&gt;. No overload is needed for &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; because it is implemented in terms of &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga es necesaria porque &lt;code&gt;&lt;a href=&quot;../initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&lt;/code&gt; no tiene una funci&amp;oacute;n miembro &lt;code&gt;rend&lt;/code&gt; . No se necesita sobrecarga para &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::crend&lt;/a&gt;&lt;/code&gt; porque se implementa en t&amp;eacute;rminos de &lt;code&gt;&lt;a href=&quot;../../iterator/rend&quot;&gt;std::rend&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83116be95b91d59c09d4b41fc31292dca9c27808" translate="yes" xml:space="preserve">
          <source>This overload makes it possible to forward a result of an expression (such as function call), which may be rvalue or lvalue, as the original value category of a forwarding reference argument.</source>
          <target state="translated">Esta sobrecarga permite reenviar un resultado de una expresión (como la llamada a una función),que puede ser rvalor o lvalor,como la categoría de valor original de un argumento de referencia de reenvío.</target>
        </trans-unit>
        <trans-unit id="814368a4e79aa44fdd2b8a96b22ebf135a87ef17" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious awakenings while waiting for a specific condition to become true.  Note that &lt;code&gt;lock&lt;/code&gt; must be acquired before entering this method, and it is reacquired after &lt;code&gt;wait(lock)&lt;/code&gt; exits, which means that &lt;code&gt;lock&lt;/code&gt; can be used to guard access to &lt;code&gt;pred()&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga se puede usar para ignorar los despertares espurios mientras se espera que se cumpla una condici&amp;oacute;n espec&amp;iacute;fica. Tenga en cuenta que el &lt;code&gt;lock&lt;/code&gt; debe adquirirse antes de ingresar a este m&amp;eacute;todo, y se vuelve a adquirir despu&amp;eacute;s de las salidas de &lt;code&gt;wait(lock)&lt;/code&gt; , lo que significa que el &lt;code&gt;lock&lt;/code&gt; se puede utilizar para proteger el acceso a &lt;code&gt;pred()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a8eb3282f5afae84e29833c36cc610e1de569a0" translate="yes" xml:space="preserve">
          <source>This overload may be used to ignore spurious wakeups.</source>
          <target state="translated">Esta sobrecarga puede utilizarse para ignorar los despertares espurios.</target>
        </trans-unit>
        <trans-unit id="7c7c9be7921bc5aca3e14ee52c3bb2b260dbf024" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if</source>
          <target state="translated">Esta sobrecarga sólo participa en la resolución de la sobrecarga si</target>
        </trans-unit>
        <trans-unit id="337c9fa9042558efca853cc7d8b71cfcdf68fa7c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; and &lt;code&gt;Deleter&lt;/code&gt; is not a pointer type. The program is ill-formed if this constructor is selected by &lt;a href=&quot;../../language/deduction_guide&quot;&gt;class template argument deduction&lt;/a&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Deleter&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; y &lt;code&gt;Deleter&lt;/code&gt; no es un tipo de puntero. El programa est&amp;aacute; mal formado si este constructor se selecciona por &lt;a href=&quot;../../language/deduction_guide&quot;&gt;deducci&amp;oacute;n de argumento de plantilla de clase&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bdb1577a846fa638ef9c34146d7b837c8cfaff57" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;../../types/is_default_constructible&quot;&gt;std::is_default_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todo &lt;code&gt;i&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a2aee11b4d79b3a5270ceef56a825350cf5c37c2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Compare&amp;gt;::value&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2c027e2ce963431b11c8b99a81bfd995a2cc23b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;Container&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687473bac79368096aa9ed3ccf13fad71a9af81b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; is true.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;&lt;a href=&quot;is_integral&quot;&gt;std::is_integral_v&lt;/a&gt;&amp;lt;IntegerType&amp;gt;&lt;/code&gt; es verdadero.</target>
        </trans-unit>
        <trans-unit id="1224a3aab62459562f6b5317091c0ef8684c06e6" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (3).</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; califica como &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , para evitar la ambig&amp;uuml;edad con la sobrecarga (3).</target>
        </trans-unit>
        <trans-unit id="4a089419777f0efe565129e644b4712117969f47" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; qualifies as an &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; califica como &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a09d792b815aa7158d605c39a17d568db1e73837" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;, to avoid ambiguity with the overload (2).</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; , para evitar la ambig&amp;uuml;edad con la sobrecarga (2).</target>
        </trans-unit>
        <trans-unit id="f321cae2fd6e4fe1eb7c60fdcbc221e29351732f" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;InputIt&lt;/code&gt; satisfies &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;InputIt&lt;/code&gt; satisface &lt;a href=&quot;../../named_req/inputiterator&quot;&gt;LegacyInputIterator&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="84fbda8e9476b834f4eff0a23e019d728cbe538b" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;N == 0&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;N == 0&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_swappable&lt;/a&gt;&amp;lt;T&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5843b6cae5eeb5b966317747e078206da1c4f50c" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;T&lt;/code&gt; is an unsigned integer type (that is, &lt;code&gt;unsigned char&lt;/code&gt;, &lt;code&gt;unsigned short&lt;/code&gt;, &lt;code&gt;unsigned int&lt;/code&gt;, &lt;code&gt;unsigned long&lt;/code&gt;, &lt;code&gt;unsigned long long&lt;/code&gt;, or an extended unsigned integer type).</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;T&lt;/code&gt; es un tipo entero sin signo (es decir, &lt;code&gt;unsigned char&lt;/code&gt; , &lt;code&gt;unsigned short&lt;/code&gt; , &lt;code&gt;unsigned int&lt;/code&gt; , &lt;code&gt;unsigned long&lt;/code&gt; , &lt;code&gt;unsigned long long&lt;/code&gt; o un tipo entero extendido sin signo).</target>
        </trans-unit>
        <trans-unit id="c6e60dbde6c8fbc3507ef1d94ecfd0c08c022a59" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;U&lt;/code&gt; is not a specialization of &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;U&lt;/code&gt; no es una especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../utility/pair&quot;&gt;std::pair&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29384bbe452ccd42b0340a2c398a159c418dc484" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; and &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; are both true for all &lt;code&gt;T_i&lt;/code&gt; in &lt;code&gt;Types...&lt;/code&gt;</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;is_move_constructible_v&amp;lt;T_i&amp;gt;&lt;/code&gt; y &lt;code&gt;is_swappable_v&amp;lt;T_i&amp;gt;&lt;/code&gt; son verdaderas para todos los &lt;code&gt;T_i&lt;/code&gt; en los &lt;code&gt;Types...&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dc0ee950915984baafe9981e2de7fbbd58afb03e" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; is a valid expression.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;os &amp;lt;&amp;lt; p.get()&lt;/code&gt; es una expresi&amp;oacute;n v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="213ea4feb3d364f895c517e5bb074dd31d585156" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; and both &lt;code&gt;To&lt;/code&gt; and &lt;code&gt;From&lt;/code&gt; are &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; types.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;sizeof(To) == sizeof(From)&lt;/code&gt; y &lt;code&gt;To&lt;/code&gt; y &lt;code&gt;From&lt;/code&gt; son tipos &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;trivialmente cobrables&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="114c800d36b0c72a9adfc7fc9888fa4bbb2bb7e2" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_copy_constructible&quot;&gt;std::is_copy_constructible&lt;/a&gt;&amp;lt;Ti&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; para todo &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="47f721ed5d5ad88fd42fa2395ca7086485e17473" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0, U1&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, U2&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f1425caf63dd41a44a75daddc54c5b669d9e819" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; are both &lt;code&gt;true&lt;/code&gt;</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;sizeof...(Types) == 2&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T0,const U1&amp;amp;&amp;gt;::value&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;T1, const U2&amp;amp;&amp;gt;::value&lt;/code&gt; son ambos &lt;code&gt;true&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="db813f0c83ff1627df30808c046963cca19b044a" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; and &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; for all &lt;code&gt;i&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;sizeof...(Types) == sizeof...(UTypes)&lt;/code&gt; y &lt;code&gt;sizeof...(Types) &amp;gt;= 1&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../types/is_constructible&quot;&gt;std::is_constructible&lt;/a&gt;&amp;lt;Ti, Ui&amp;amp;&amp;amp;&amp;gt;::value&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; por todo lo &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfc7e8a0241026e6c0b8875fd31fd121edcd01be" translate="yes" xml:space="preserve">
          <source>This overload only participates in overload resolution if &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt;.</source>
          <target state="translated">Esta sobrecarga solo participa en la resoluci&amp;oacute;n de sobrecarga si &lt;code&gt;std::chrono::treat_as_floating_point_v&amp;lt;typename Duration::rep&amp;gt;&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; y &lt;code&gt;Duration(1) &amp;lt; &lt;a href=&quot;../duration&quot;&gt;std::chrono::days&lt;/a&gt;(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bea87dfd18560dbaabd48c593a450285fb991964" translate="yes" xml:space="preserve">
          <source>This page describes the core language feature adopted for C++20. For named type requirements used in the specification of the standard library, see &lt;a href=&quot;../named_req&quot;&gt;named requirements&lt;/a&gt;. For the Concepts TS version of this feature, see &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;here&lt;/a&gt;.</source>
          <target state="translated">Esta p&amp;aacute;gina describe la caracter&amp;iacute;stica principal del lenguaje adoptada para C ++ 20. Para conocer los requisitos de tipo con nombre utilizados en la especificaci&amp;oacute;n de la biblioteca est&amp;aacute;ndar, consulte los &lt;a href=&quot;../named_req&quot;&gt;requisitos con nombre&lt;/a&gt; . Para la versi&amp;oacute;n Concepts TS de esta funci&amp;oacute;n, consulte &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/constraints&quot;&gt;aqu&amp;iacute;&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="88455b072941af9e8a59177f52c213a26676d97c" translate="yes" xml:space="preserve">
          <source>This partial code fragment illustrates how &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; can be used to avoid accessing data that depends on thread locals while those thread locals are in the process of being destructed:</source>
          <target state="translated">Este fragmento de c&amp;oacute;digo parcial ilustra c&amp;oacute;mo se puede utilizar &lt;code&gt;notify_all_at_thread_exit&lt;/code&gt; para evitar el acceso a los datos que dependen de los subprocesos locales mientras esos locales de subprocesos est&amp;aacute;n en proceso de ser destruidos:</target>
        </trans-unit>
        <trans-unit id="7c5fecf341fbcf23eb1c8bab2cc52b3d4ac7b65d" translate="yes" xml:space="preserve">
          <source>This problem may be worked around using init-statement:</source>
          <target state="translated">Este problema puede resolverse con el uso de init-statement:</target>
        </trans-unit>
        <trans-unit id="6fb590b83ec483a8b56a2365c3f69fb2ed4d882e" translate="yes" xml:space="preserve">
          <source>This process is called</source>
          <target state="translated">Este proceso se llama</target>
        </trans-unit>
        <trans-unit id="a7c693f3363fc29f57e0a818f5fcc2fa68ec620d" translate="yes" xml:space="preserve">
          <source>This program determines the longest substring that is simultaneously found at the very beginning of the given string and at the very end of it, in reverse order (possibly overlapping).</source>
          <target state="translated">Este programa determina la subcadena más larga que se encuentra simultáneamente al principio de la cadena dada y al final de la misma,en orden inverso (posiblemente superpuesta).</target>
        </trans-unit>
        <trans-unit id="eafef78a966daecd6d7bcd73bf31b0e1e5ad496e" translate="yes" xml:space="preserve">
          <source>This program simulates throwing 6-sided dice.</source>
          <target state="translated">Este programa simula el lanzamiento de dados de 6 caras.</target>
        </trans-unit>
        <trans-unit id="2ea85151fe97fd5e5b0aa44d16e405ebe318a32c" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt;&lt;code&gt;basic_streambuf::sungetc&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt;&lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt;&lt;/a&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;).</source>
          <target state="translated">Esta funci&amp;oacute;n virtual protegida es llamada por las funciones p&amp;uacute;blicas &lt;a href=&quot;../basic_streambuf/sungetc&quot;&gt; &lt;code&gt;basic_streambuf::sungetc&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../basic_streambuf/sputbackc&quot;&gt; &lt;code&gt;basic_streambuf::sputbackc&lt;/code&gt; &lt;/a&gt; (que, a su vez, son llamadas por &lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="996fa56c79f2b555734e9e9593669a195ee9fc8b" translate="yes" xml:space="preserve">
          <source>This protected virtual function is called by the public functions &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; (which, in turn, are called by &lt;a href=&quot;../basic_istream/unget&quot;&gt;&lt;code&gt;basic_istream::unget&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;../basic_istream/putback&quot;&gt;&lt;code&gt;basic_istream::putback&lt;/code&gt;&lt;/a&gt;) when either:</source>
          <target state="translated">Esta funci&amp;oacute;n virtual protegida es llamada por las funciones p&amp;uacute;blicas &lt;code&gt;&lt;a href=&quot;sungetc&quot;&gt;sungetc()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;sputbackc&quot;&gt;sputbackc()&lt;/a&gt;&lt;/code&gt; (que, a su vez, son llamadas por &lt;a href=&quot;../basic_istream/unget&quot;&gt; &lt;code&gt;basic_istream::unget&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;../basic_istream/putback&quot;&gt; &lt;code&gt;basic_istream::putback&lt;/code&gt; &lt;/a&gt; ) cuando:</target>
        </trans-unit>
        <trans-unit id="01f04b9a6bf8f295e5a70f9d8714851ba0b2aba1" translate="yes" xml:space="preserve">
          <source>This regenerates the hash table.</source>
          <target state="translated">Esto regenera la tabla de hachís.</target>
        </trans-unit>
        <trans-unit id="2062b86cfcefc181f616f82dcb480679b9c947da" translate="yes" xml:space="preserve">
          <source>This rule also appears in the C++ Core Guidelines as &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20: If you can avoid defining default operations, do&lt;/a&gt;.</source>
          <target state="translated">Esta regla tambi&amp;eacute;n aparece en las Pautas principales de C ++ como &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rc-zero&quot;&gt;C.20: si puede evitar definir operaciones predeterminadas, h&amp;aacute;galo&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4ac284d6084ae4faac12c7c88cba2efd5c565f23" translate="yes" xml:space="preserve">
          <source>This rule applies during overload resolution of function templates: When &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;substituting&lt;/a&gt; the explicitly specified or &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced type&lt;/a&gt; for the template parameter fails, the specialization is discarded from the &lt;a href=&quot;overload_resolution&quot;&gt;overload set&lt;/a&gt; instead of causing a compile error.</source>
          <target state="translated">Esta regla se aplica durante la resoluci&amp;oacute;n de sobrecarga de las plantillas de funci&amp;oacute;n: cuando falla la &lt;a href=&quot;function_template#Template_argument_substitution&quot;&gt;sustituci&amp;oacute;n&lt;/a&gt; del &lt;a href=&quot;template_argument_deduction&quot;&gt;tipo&lt;/a&gt; de plantilla expl&amp;iacute;citamente especificado o deducido por el par&amp;aacute;metro de plantilla, la especializaci&amp;oacute;n se descarta del &lt;a href=&quot;overload_resolution&quot;&gt;conjunto de sobrecarga en&lt;/a&gt; lugar de causar un error de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d7cbe3e2801d332154dbf0acb579c831d5324d92" translate="yes" xml:space="preserve">
          <source>This rule enables type-based alias analysis, in which a compiler assumes that the value read through a glvalue of one type is not modified by a write to a glvalue of a different type (subject to the exceptions noted above).</source>
          <target state="translated">Esta regla permite el análisis de alias basado en tipos,en el que un compilador supone que el valor leído a través de un glvalue de un tipo no se modifica por una escritura a un glvalue de un tipo diferente (con las excepciones señaladas anteriormente).</target>
        </trans-unit>
        <trans-unit id="0ed01ea49dcd8fc7a8834c7e1f6f57d09b9ceaaf" translate="yes" xml:space="preserve">
          <source>This section provides definitions for the specific terminology and the concepts used when describing the C++ programming language.</source>
          <target state="translated">En esta sección se ofrecen definiciones de la terminología específica y de los conceptos utilizados al describir el lenguaje de programación C++.</target>
        </trans-unit>
        <trans-unit id="28ad28e60d5a5cc2b8a106dc95cfe732a7105f9e" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that all objects of type &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; support</source>
          <target state="translated">Esta especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informa a otros componentes de la biblioteca que todos los objetos de tipo &lt;code&gt;&lt;a href=&quot;../function&quot;&gt;std::function&lt;/a&gt;&lt;/code&gt; compatibles con la funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="8c6b990eab9edf93292f6979537f3edb00a094bd" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; informs other library components that values of type &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; are enumerations that hold error codes, which makes them implicitly convertible and assignable to objects of type &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Esta especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../error/error_code/is_error_code_enum&quot;&gt;std::is_error_code_enum&lt;/a&gt;&lt;/code&gt; informa a otros componentes de la biblioteca que los valores de tipo &lt;code&gt;&lt;a href=&quot;../io_errc&quot;&gt;std::io_errc&lt;/a&gt;&lt;/code&gt; son enumeraciones que contienen c&amp;oacute;digos de error, lo que los hace impl&amp;iacute;citamente convertibles y asignables a objetos de tipo &lt;code&gt;&lt;a href=&quot;../../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdc8c9de3fc6d0e6ce5408d37d8e773fda6b9547" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informs other library components that tuples support</source>
          <target state="translated">Esta especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../memory/uses_allocator&quot;&gt;std::uses_allocator&lt;/a&gt;&lt;/code&gt; informa a otros componentes de la biblioteca que admiten las tuplas.</target>
        </trans-unit>
        <trans-unit id="038a0d1d441b9b41c30e5117e6ae3ac1df058c8d" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt;, which uses virtual functions, this specialization uses table lookup to classify characters (which is generally faster).</source>
          <target state="translated">Esta especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; encapsula las caracter&amp;iacute;sticas de clasificaci&amp;oacute;n de caracteres para el tipo &lt;code&gt;char&lt;/code&gt; . A diferencia de &lt;code&gt;&lt;a href=&quot;ctype&quot;&gt;std::ctype&lt;/a&gt;&lt;/code&gt; , que utiliza funciones virtuales, esta especializaci&amp;oacute;n utiliza la b&amp;uacute;squeda de tablas para clasificar los caracteres (que generalmente es m&amp;aacute;s r&amp;aacute;pido).</target>
        </trans-unit>
        <trans-unit id="fe9803ffee86bd599903f2123e0bb2aa07aae79a" translate="yes" xml:space="preserve">
          <source>This specialization of &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; encapsulates character classification features for type &lt;code&gt;char&lt;/code&gt;. Like its base class &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; and unlike general-purpose &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt;, table lookup is used to classify characters.</source>
          <target state="translated">Esta especializaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; encapsula las caracter&amp;iacute;sticas de clasificaci&amp;oacute;n de caracteres para el tipo &lt;code&gt;char&lt;/code&gt; . Al igual que su clase base &lt;code&gt;std::ctype&amp;lt;char&amp;gt;&lt;/code&gt; y a diferencia de &lt;code&gt;&lt;a href=&quot;ctype_byname&quot;&gt;std::ctype_byname&lt;/a&gt;&lt;/code&gt; prop&amp;oacute;sito general , la b&amp;uacute;squeda de tablas se utiliza para clasificar los caracteres.</target>
        </trans-unit>
        <trans-unit id="3ddf81e9b15f2fdf0bb22d822a3952f3ead8b84b" translate="yes" xml:space="preserve">
          <source>This specification may appear only on lambda-declarator or on a function declarator that is the top-level(until C++17) declarator of a function, variable, or non-static data member, whose type is a function type, a pointer to function type, a reference to function type, a pointer to member function type. It may appear on the declarator of a parameter or on the declarator of a return type.</source>
          <target state="translated">Esta especificación puede aparecer sólo en el lambda-declarador o en un declarador de función que es el declarador de nivel superior (hasta C++17)de una función,variable o miembro de datos no estático,cuyo tipo es un tipo de función,un puntero al tipo de función,una referencia al tipo de función,un puntero al tipo de función miembro.Puede aparecer en el declarador de un parámetro o en el declarador de un tipo de retorno.</target>
        </trans-unit>
        <trans-unit id="95164148c00adc35d63c91ae48d3bfe549e3eabc" translate="yes" xml:space="preserve">
          <source>This swap function is protected: it is called by the swap member functions of the derived stream classes such as &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt;, which know how to correctly swap the associated streambuffers.</source>
          <target state="translated">Esta funci&amp;oacute;n de intercambio est&amp;aacute; protegida: se llama mediante las funciones de miembro de intercambio de las clases de flujo derivadas, como &lt;code&gt;&lt;a href=&quot;../basic_ofstream&quot;&gt;std::basic_ofstream&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../basic_istringstream&quot;&gt;std::basic_istringstream&lt;/a&gt;&lt;/code&gt; , que saben c&amp;oacute;mo intercambiar correctamente los streambuffers asociados.</target>
        </trans-unit>
        <trans-unit id="203ee242898fb95403122a811df27a6f5e11668f" translate="yes" xml:space="preserve">
          <source>This syntax for variadic arguments was introduced in 1983 C++ without the comma before the ellipsis. When C89 adopted function prototypes from C++, it replaced the syntax with one requiring the comma. For compatibility, C++98 accepts both C++-style &lt;code&gt;f(int n...)&lt;/code&gt; and C-style &lt;code&gt;f(int n, ...)&lt;/code&gt;.</source>
          <target state="translated">Esta sintaxis para argumentos variados se introdujo en 1983 en C ++ sin la coma antes de los puntos suspensivos. Cuando C89 adopt&amp;oacute; prototipos de funciones de C ++, reemplaz&amp;oacute; la sintaxis con una que requiera la coma. Por compatibilidad, C ++ 98 acepta tanto el estilo C ++ &lt;code&gt;f(int n...)&lt;/code&gt; como el estilo C &lt;code&gt;f(int n, ...)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90ab5c64e037f5bd0606d3f5a893f7a9a8254324" translate="yes" xml:space="preserve">
          <source>This technical specification is supported by GCC as of version 6.1 (requires &lt;code&gt;-fgnu-tm&lt;/code&gt; to enable). An older variant of this specification was &lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;supported in GCC&lt;/a&gt; as of 4.7.</source>
          <target state="translated">Esta especificaci&amp;oacute;n t&amp;eacute;cnica es compatible con GCC a partir de la versi&amp;oacute;n 6.1 (requiere &lt;code&gt;-fgnu-tm&lt;/code&gt; para habilitar). Una variante anterior de esta especificaci&amp;oacute;n fue &lt;a href=&quot;http://www-users.cs.umn.edu/~boutcher/stm/&quot;&gt;compatible con GCC a&lt;/a&gt; partir de 4.7.</target>
        </trans-unit>
        <trans-unit id="419df6ad5807d184b62cd3a9400a351c6d85612c" translate="yes" xml:space="preserve">
          <source>This technique is used to construct C++ library interfaces with stable ABI and to reduce compile-time dependencies.</source>
          <target state="translated">Esta técnica se utiliza para construir interfaces de biblioteca C++con ABI estable y para reducir las dependencias del tiempo de compilación.</target>
        </trans-unit>
        <trans-unit id="a685713d9d750fdc943f666575768010c6772551" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type &lt;code&gt;T&lt;/code&gt; to implement &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; with</source>
          <target state="translated">Esta plantilla puede estar especializada para un tipo &lt;code&gt;T&lt;/code&gt; definido por el usuario para implementar &lt;a href=&quot;../../named_req/unarytypetrait&quot;&gt;UnaryTypeTrait&lt;/a&gt; con</target>
        </trans-unit>
        <trans-unit id="25830dd69fe1f966afb7508601b149f9651d15fd" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">Esta plantilla puede estar especializada para un tipo definido por el usuario para indicar que el tipo es elegible para conversiones autom&amp;aacute;ticas &lt;code&gt;&lt;a href=&quot;../error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="921636ccd7ae628df6b1d450ba1978e54fd38c56" translate="yes" xml:space="preserve">
          <source>This template may be specialized for a user-defined type to indicate that the type is eligible for &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; automatic conversions.</source>
          <target state="translated">Esta plantilla puede estar especializada para un tipo definido por el usuario para indicar que el tipo es elegible para conversiones autom&amp;aacute;ticas &lt;code&gt;&lt;a href=&quot;../error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8d9894e4d5b931e86a98ac460a720072feb42c9" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the assignment expression: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual assignment may not compile even if &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Este rasgo no verifica nada fuera del contexto inmediato de la expresi&amp;oacute;n de asignaci&amp;oacute;n: si el uso de &lt;code&gt;T&lt;/code&gt; o &lt;code&gt;U&lt;/code&gt; desencadenar&amp;iacute;a especializaciones de plantilla, generaci&amp;oacute;n de funciones miembro especiales definidas impl&amp;iacute;citamente, etc., y esas tienen errores, la asignaci&amp;oacute;n real puede no compilarse incluso si &lt;code&gt;std::is_assignable&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compila y eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb8840cec417013032e8555b42ffbfcba15618b0" translate="yes" xml:space="preserve">
          <source>This trait does not check anything outside the immediate context of the swap expressions: if the use of &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;U&lt;/code&gt; would trigger template specializations, generation of implicitly-defined special member functions etc, and those have errors, the actual swap may not compile even if &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compiles and evaluates to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Este rasgo no verifica nada fuera del contexto inmediato de las expresiones de intercambio: si el uso de &lt;code&gt;T&lt;/code&gt; o &lt;code&gt;U&lt;/code&gt; desencadenar&amp;iacute;a especializaciones de plantilla, generaci&amp;oacute;n de funciones miembro especiales definidas impl&amp;iacute;citamente, etc., y esas tienen errores, el intercambio real puede no compilarse incluso si &lt;code&gt;std::is_swappable_with&amp;lt;T,U&amp;gt;::value&lt;/code&gt; compila y eval&amp;uacute;a como &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="98c54288dcf9d77d236eeecd6daa6884dc0b5970" translate="yes" xml:space="preserve">
          <source>This trait was introduced to make it possible to determine whether a type can be correctly hashed by hashing its object representation as a byte array.</source>
          <target state="translated">Este rasgo se introdujo para poder determinar si un tipo puede ser correctamente triturado al triturar su representación de objeto como una matriz de bytes.</target>
        </trans-unit>
        <trans-unit id="aea90bedb8f6381211ab3408991531636fb5ffc1" translate="yes" xml:space="preserve">
          <source>This type can be specialized if the representation &lt;code&gt;Rep&lt;/code&gt; requires a specific implementation to return these duration objects.</source>
          <target state="translated">Este tipo puede especializarse si el Representante de &lt;code&gt;Rep&lt;/code&gt; requiere una implementaci&amp;oacute;n espec&amp;iacute;fica para devolver estos objetos de duraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0087c0a1dcbf0b0f0625fe12349f4e248d5e9491" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;copy&quot;&gt;&lt;code&gt;copy()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;copy_file&quot;&gt;&lt;code&gt;copy_file()&lt;/code&gt;&lt;/a&gt; function.</source>
          <target state="translated">Este tipo representa las opciones disponibles que controlan el comportamiento de la funci&amp;oacute;n &lt;a href=&quot;copy&quot;&gt; &lt;code&gt;copy()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;copy_file&quot;&gt; &lt;code&gt;copy_file()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e417e5db45320da2073da483bb3a5847a750f26" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the &lt;a href=&quot;directory_iterator&quot;&gt;&lt;code&gt;directory_iterator&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_directory_iterator&quot;&gt;&lt;code&gt;recursive_directory_iterator&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este tipo representa las opciones disponibles que controlan el comportamiento del &lt;a href=&quot;directory_iterator&quot;&gt; &lt;code&gt;directory_iterator&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;recursive_directory_iterator&quot;&gt; &lt;code&gt;recursive_directory_iterator&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ed15c087ab4da8efef6f8cef5da62d8cc51d1d4d" translate="yes" xml:space="preserve">
          <source>This type represents available options that control the behavior of the function &lt;a href=&quot;permissions&quot;&gt;&lt;code&gt;permissions()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Este tipo representa las opciones disponibles que controlan el comportamiento de los &lt;a href=&quot;permissions&quot;&gt; &lt;code&gt;permissions()&lt;/code&gt; &lt;/a&gt; de la funci&amp;oacute;n () .</target>
        </trans-unit>
        <trans-unit id="19b6990a7534cc1c45af33110b91b0350924b0e8" translate="yes" xml:space="preserve">
          <source>This type represents file access permissions. &lt;code&gt;perms&lt;/code&gt; satisfies the requirements of &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (which means the bitwise operators &lt;code&gt;operator&amp;amp;&lt;/code&gt;, &lt;code&gt;operator|&lt;/code&gt;, &lt;code&gt;operator^&lt;/code&gt;, &lt;code&gt;operator~&lt;/code&gt;, &lt;code&gt;operator&amp;amp;=&lt;/code&gt;, &lt;code&gt;operator|=&lt;/code&gt;, and &lt;code&gt;operator^=&lt;/code&gt; are defined for this type).</source>
          <target state="translated">Este tipo representa los permisos de acceso a archivos. &lt;code&gt;perms&lt;/code&gt; satisface los requisitos de &lt;a href=&quot;../named_req/bitmasktype&quot;&gt;BitmaskType&lt;/a&gt; (lo que significa que los operadores bit a bit operador &lt;code&gt;operator&amp;amp;&lt;/code&gt; , &lt;code&gt;operator|&lt;/code&gt; , &lt;code&gt;operator^&lt;/code&gt; , &lt;code&gt;operator~&lt;/code&gt; , &lt;code&gt;operator&amp;amp;=&lt;/code&gt; , &lt;code&gt;operator|=&lt;/code&gt; y &lt;code&gt;operator^=&lt;/code&gt; est&amp;aacute;n definidos para este tipo).</target>
        </trans-unit>
        <trans-unit id="157a64e0ec4c85a12b01b53324ef0dcdfb157238" translate="yes" xml:space="preserve">
          <source>This type requirement is deprecated in the C++ standard. All of its uses have been replaced by the more refined type requirements, such as &lt;a href=&quot;trivialtype&quot;&gt;TrivialType&lt;/a&gt;.</source>
          <target state="translated">Este requisito de tipo est&amp;aacute; en desuso en el est&amp;aacute;ndar C ++. Todos sus usos han sido reemplazados por los requisitos de tipo m&amp;aacute;s refinados, como &lt;a href=&quot;trivialtype&quot;&gt;TrivialType&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="23b4cbf67168a660a04e5a36fcd5bf13a48ffa59" translate="yes" xml:space="preserve">
          <source>This type trait is used by &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt;. It may also be used by custom allocators or wrapper types to determine whether the object or member being constructed is itself capable of using an allocator (e.g. is a container), in which case an allocator should be passed to its constructor.</source>
          <target state="translated">Este rasgo de tipo es utilizado por &lt;code&gt;&lt;a href=&quot;../utility/tuple&quot;&gt;std::tuple&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;scoped_allocator_adaptor&quot;&gt;std::scoped_allocator_adaptor&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;polymorphic_allocator&quot;&gt;std::pmr::polymorphic_allocator&lt;/a&gt;&lt;/code&gt; . Tambi&amp;eacute;n puede ser utilizado por asignadores personalizados o tipos de envoltura para determinar si el objeto o miembro que se est&amp;aacute; construyendo es capaz de usar un asignador (por ejemplo, un contenedor), en cuyo caso se debe pasar un asignador a su constructor.</target>
        </trans-unit>
        <trans-unit id="99d2afd28d674bc31d956763a004b7cd9b730d51" translate="yes" xml:space="preserve">
          <source>This type trait may be specialized for user-provided types that may be used as iterators. The standard library provides two partial specializations for pointer types T*, which makes it possible to use all iterator-based algorithms with raw pointers.</source>
          <target state="translated">Este rasgo de tipo puede estar especializado para los tipos proporcionados por el usuario que pueden utilizarse como iteradores.La biblioteca estándar proporciona dos especializaciones parciales para los tipos de puntero T*,lo que permite utilizar todos los algoritmos basados en iteradores con punteros sin procesar.</target>
        </trans-unit>
        <trans-unit id="c5c25f5c1d60bf97a090f5b80fe5a2c0ab183ce7" translate="yes" xml:space="preserve">
          <source>This type trait predates the &lt;a href=&quot;../language/alignof&quot;&gt;alignof keyword&lt;/a&gt;, which can be used to obtain the same value with less verbosity.</source>
          <target state="translated">Este rasgo de tipo es anterior a la &lt;a href=&quot;../language/alignof&quot;&gt;palabra clave alignof&lt;/a&gt; , que se puede usar para obtener el mismo valor con menos verbosidad.</target>
        </trans-unit>
        <trans-unit id="e0410ce23d7ebcff7e3be952fdf86650da4cb323" translate="yes" xml:space="preserve">
          <source>This value typically reflects the theoretical limit on the size of the container, at most &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt;. At runtime, the size of the container may be limited to a value smaller than &lt;code&gt;max_size()&lt;/code&gt; by the amount of RAM available.</source>
          <target state="translated">Este valor generalmente refleja el l&amp;iacute;mite te&amp;oacute;rico sobre el tama&amp;ntilde;o del contenedor, como m&amp;aacute;ximo &lt;code&gt;std::numeric_limits&amp;lt;difference_type&amp;gt;::max()&lt;/code&gt; . En tiempo de ejecuci&amp;oacute;n, el tama&amp;ntilde;o del contenedor puede estar limitado a un valor menor que &lt;code&gt;max_size()&lt;/code&gt; por la cantidad de RAM disponible.</target>
        </trans-unit>
        <trans-unit id="277c3ad089ba0f3cf12d3db7126822c9d80a4896" translate="yes" xml:space="preserve">
          <source>This variable has block scope and static storage duration:</source>
          <target state="translated">Esta variable tiene un alcance de bloque y una duración de almacenamiento estático:</target>
        </trans-unit>
        <trans-unit id="fae180c729e28c3be7b371f92b90451d0013d47d" translate="yes" xml:space="preserve">
          <source>Those data members that correspond to captures without initializers are &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; when the lambda-expression is evaluated. Those that correspond to captures with initializers are initialized as the initializer requires (could be copy- or direct-initialization). If an array is captured, array elements are direct-initialized in increasing index order. The order in which the data members are initialized is the order in which they are declared (which is unspecified).</source>
          <target state="translated">Los miembros de datos que corresponden a capturas sin inicializadores se inicializan &lt;a href=&quot;direct_initialization&quot;&gt;directamente&lt;/a&gt; cuando se eval&amp;uacute;a la expresi&amp;oacute;n lambda. Los que corresponden a capturas con inicializadores se inicializan seg&amp;uacute;n lo requiera el inicializador (podr&amp;iacute;a ser una copia o inicializaci&amp;oacute;n directa). Si se captura una matriz, los elementos de la matriz se inicializan directamente en orden de &amp;iacute;ndice creciente. El orden en que se inicializan los miembros de datos es el orden en que se declaran (que no se especifica).</target>
        </trans-unit>
        <trans-unit id="f4a567a9b52d0caa922bc0235781e01fdf5d4c89" translate="yes" xml:space="preserve">
          <source>Thousands separator and decimal point characters are inserted as required by &lt;code&gt;mp.grouping()&lt;/code&gt;, &lt;code&gt;mp.frac_digits()&lt;/code&gt;, &lt;code&gt;mp.decimal_point()&lt;/code&gt;, and &lt;code&gt;mp.thousands_sep()&lt;/code&gt;, and the resulting string is placed in the output sequence where &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; appears in the formatting pattern.</source>
          <target state="translated">Se insertan miles de caracteres separadores y decimales seg&amp;uacute;n lo requerido por &lt;code&gt;mp.grouping()&lt;/code&gt; , &lt;code&gt;mp.frac_digits()&lt;/code&gt; , &lt;code&gt;mp.decimal_point()&lt;/code&gt; y &lt;code&gt;mp.thousands_sep()&lt;/code&gt; , y la cadena resultante se coloca en la secuencia de salida donde &lt;code&gt;&lt;a href=&quot;../money_base&quot;&gt;value&lt;/a&gt;&lt;/code&gt; aparece el valor en El patr&amp;oacute;n de formato.</target>
        </trans-unit>
        <trans-unit id="d0cef5deb223649da3c92e68bafacf5c8ccd785e" translate="yes" xml:space="preserve">
          <source>Thread safety</source>
          <target state="translated">Seguridad de los hilos</target>
        </trans-unit>
        <trans-unit id="604ac3e54d45a1053374b3b32afdb7b25fbf1ed4" translate="yes" xml:space="preserve">
          <source>Thread support</source>
          <target state="translated">Soporte del hilo</target>
        </trans-unit>
        <trans-unit id="e2d8ff11421f3eaf1af17a9be19957f5569bce89" translate="yes" xml:space="preserve">
          <source>Thread support library</source>
          <target state="translated">Biblioteca de apoyo a los hilos</target>
        </trans-unit>
        <trans-unit id="bb12e8aaaecc434fd51e448fe7669bced1bdd107" translate="yes" xml:space="preserve">
          <source>Threads</source>
          <target state="translated">Threads</target>
        </trans-unit>
        <trans-unit id="e7a80c12335015336479b7097a8b8db3ed660872" translate="yes" xml:space="preserve">
          <source>Threads and data races</source>
          <target state="translated">Hilos y carreras de datos</target>
        </trans-unit>
        <trans-unit id="c1492359cb9886c9909e1a4316a9b1847c65e9e9" translate="yes" xml:space="preserve">
          <source>Threads begin execution immediately upon construction of the associated thread object (pending any OS scheduling delays), starting at the top-level function provided as a &lt;a href=&quot;thread/thread&quot;&gt;constructor argument&lt;/a&gt;. The return value of the top-level function is ignored and if it terminates by throwing an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. The top-level function may communicate its return value or an exception to the caller via &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; or by modifying shared variables (which may require synchronization, see &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Los subprocesos comienzan a ejecutarse inmediatamente despu&amp;eacute;s de la construcci&amp;oacute;n del objeto de subproceso asociado (a la espera de cualquier retraso en la programaci&amp;oacute;n del sistema operativo), comenzando en la funci&amp;oacute;n de nivel superior proporcionada como &lt;a href=&quot;thread/thread&quot;&gt;argumento de constructor&lt;/a&gt; . El valor de retorno de la funci&amp;oacute;n de nivel superior se ignora y si termina lanzando una excepci&amp;oacute;n, se llama a &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . La funci&amp;oacute;n de nivel superior puede comunicar su valor de retorno o una excepci&amp;oacute;n a la persona que llama a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;promise&quot;&gt;std::promise&lt;/a&gt;&lt;/code&gt; o modificando variables compartidas (que pueden requerir sincronizaci&amp;oacute;n, vea &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;std::mutex&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../atomic/atomic&quot;&gt;std::atomic&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f4eb730a2ea2fcff234ce55322a48d3d91657b7e" translate="yes" xml:space="preserve">
          <source>Threads enable programs to execute across several processor cores.</source>
          <target state="translated">Los hilos permiten que los programas se ejecuten en varios núcleos del procesador.</target>
        </trans-unit>
        <trans-unit id="a246e49f5181769dcbe8963551805985ea8e8c89" translate="yes" xml:space="preserve">
          <source>Three conditions where &lt;code&gt;std::bad_array_new_length&lt;/code&gt; should be thrown:</source>
          <target state="translated">Tres condiciones donde &lt;code&gt;std::bad_array_new_length&lt;/code&gt; deber&amp;iacute;an ser lanzadas:</target>
        </trans-unit>
        <trans-unit id="b9e36378830759894e6fe278bd9aa261b8ff8830" translate="yes" xml:space="preserve">
          <source>Three-way comparison</source>
          <target state="translated">Comparación a tres bandas</target>
        </trans-unit>
        <trans-unit id="762d1a20f1e0eccc439b6c76140f77d0e64ffbd4" translate="yes" xml:space="preserve">
          <source>Three-way comparison can be automatically generated for class types, see &lt;a href=&quot;default_comparisons&quot;&gt;default comparisons&lt;/a&gt;.</source>
          <target state="translated">La comparaci&amp;oacute;n de tres v&amp;iacute;as se puede generar autom&amp;aacute;ticamente para los tipos de clase, vea &lt;a href=&quot;default_comparisons&quot;&gt; comparaciones predeterminadas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="89dc893d701abc8f17f1b70a529a23fb35201ff0" translate="yes" xml:space="preserve">
          <source>Throughout the standard library, bitwise shift operators are commonly overloaded with I/O stream (&lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; or one of the classes derived from it) as both the left operand and return type. Such operators are known as</source>
          <target state="translated">En toda la biblioteca est&amp;aacute;ndar, los operadores de desplazamiento a nivel de bit se sobrecargan com&amp;uacute;nmente con el flujo de E / S ( &lt;code&gt;&lt;a href=&quot;../io/ios_base&quot;&gt;std::ios_base&lt;/a&gt;&amp;amp;&lt;/code&gt; o una de las clases derivadas de &amp;eacute;l) como el operando izquierdo y el tipo de retorno. Dichos operadores se conocen como</target>
        </trans-unit>
        <trans-unit id="f13c54f785e2da5ceb32427977752efac6c1f5cc" translate="yes" xml:space="preserve">
          <source>Throw any exception thrown by the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Lanza cualquier excepci&amp;oacute;n lanzada por el &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; instalado actualmente .</target>
        </trans-unit>
        <trans-unit id="0ab6516c23d4a4cf955f60f3139340567e17455c" translate="yes" xml:space="preserve">
          <source>Throwing an exception is used to signal errors from functions, where &quot;errors&quot; are typically limited to only the following&lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt;:</source>
          <target state="translated">Lanzar una excepci&amp;oacute;n se usa para se&amp;ntilde;alar errores de las funciones, donde los &quot;errores&quot; generalmente se limitan a lo siguiente &lt;sup id=&quot;cite_ref-1&quot;&gt;&lt;a href=&quot;exceptions#cite_note-1&quot;&gt;[1] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-2&quot;&gt;&lt;a href=&quot;exceptions#cite_note-2&quot;&gt;[2] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-3&quot;&gt;&lt;a href=&quot;exceptions#cite_note-3&quot;&gt;[3]&lt;/a&gt;&lt;/sup&gt; :</target>
        </trans-unit>
        <trans-unit id="7c890cb1e360c745fea29256ca1365d6a4c1baf1" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt;; may also any exceptions thrown by the call to &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt;.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; si &lt;code&gt;n &amp;gt; SIZE_MAX / sizeof(T)&lt;/code&gt; ; Tambi&amp;eacute;n puede haber excepciones lanzadas por la llamada a &lt;code&gt;resource()-&amp;gt;allocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef7207c238414b15063664465aad815055211c96" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;new_cap&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; si &lt;code&gt;new_cap&lt;/code&gt; es mayor que &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31e238d5140b17c25d7cced51cc7d8f65270714a" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if the length of the constructed string would exceed &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; (for example, if &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; for (2)). Calls to &lt;code&gt;Allocator::allocate&lt;/code&gt; may throw.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; si la longitud de la cadena construida exceder&amp;iacute;a &lt;code&gt;&lt;a href=&quot;max_size&quot;&gt;max_size()&lt;/a&gt;&lt;/code&gt; (por ejemplo, si &lt;code&gt;count &amp;gt; max_size()&lt;/code&gt; para (2)). Se pueden lanzar llamadas a &lt;code&gt;Allocator::allocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5bd5e3a71ffb663ec4af5da4ee91146199c73db9" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt;.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;../../error/out_of_range/out_of_range&quot;&gt;std::out_of_range&lt;/a&gt;&lt;/code&gt; si &lt;code&gt;pos &amp;gt;= size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0988508382bdadbf64519b871fd4199f1f7e88db" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; if no such &lt;code&gt;time_zone&lt;/code&gt; can be found.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;../../error/runtime_error/runtime_error&quot;&gt;std::runtime_error&lt;/a&gt;&lt;/code&gt; si no se puede encontrar dicha zona &lt;code&gt;time_zone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b00d37fc6c817e49da501c1d4283379499ed17c" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; when errors occur, including errors from the underlying operating system that would prevent &lt;code&gt;lock&lt;/code&gt; from meeting its specifications. The mutex is not locked in the case of any exception being thrown.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; cuando se producen errores, incluidos los errores del sistema operativo subyacente que evitar&amp;iacute;an &lt;code&gt;lock&lt;/code&gt; cumpla con sus especificaciones. El mutex no est&amp;aacute; bloqueado en el caso de que se produzca alguna excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="442b654cd69e928843823a7f4be327a06a469dea" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with error condition &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; if the launch policy equals &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; and the implementation is unable to start a new thread (if the policy is &lt;code&gt;async|deferred&lt;/code&gt; or has additional bits set, it will fall back to deferred or the implementation-defined policies in this case), or &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if memory for the internal data structures could not be allocated.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; con condici&amp;oacute;n de error &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::resource_unavailable_try_again&lt;/a&gt;&lt;/code&gt; si la pol&amp;iacute;tica de lanzamiento es igual a &lt;code&gt;&lt;a href=&quot;launch&quot;&gt;std::launch::async&lt;/a&gt;&lt;/code&gt; y la implementaci&amp;oacute;n no puede iniciar un nuevo hilo (si la pol&amp;iacute;tica es &lt;code&gt;async|deferred&lt;/code&gt; o tiene bits adicionales establecidos , recurrir&amp;aacute; a pol&amp;iacute;ticas diferidas o definidas por la implementaci&amp;oacute;n en este caso), o &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si no se puede asignar memoria para las estructuras de datos internas.</target>
        </trans-unit>
        <trans-unit id="7fd45fe2a76b5c26edcf480fd318099061d96452" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; throws.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; si &lt;code&gt;operator&amp;gt;&amp;gt;&lt;/code&gt; u &lt;code&gt;operator&amp;lt;&amp;lt;&lt;/code&gt; lanza.</target>
        </trans-unit>
        <trans-unit id="61e7abab0e5d103b8f9ee327388ae0a478e7343f" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; if allocation fails.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;../new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; si la asignaci&amp;oacute;n falla.</target>
        </trans-unit>
        <trans-unit id="610b978856ae75c3eef4b6f3051d9b89a88b02ba" translate="yes" xml:space="preserve">
          <source>Throws &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; if any variant in &lt;code&gt;vars&lt;/code&gt; is &lt;a href=&quot;valueless_by_exception&quot;&gt;&lt;code&gt;valueless_by_exception&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Lanza &lt;code&gt;&lt;a href=&quot;bad_variant_access&quot;&gt;std::bad_variant_access&lt;/a&gt;&lt;/code&gt; si alguna variante en &lt;code&gt;vars&lt;/code&gt; no tiene &lt;a href=&quot;valueless_by_exception&quot;&gt; &lt;code&gt;valueless_by_exception&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2ccf84cf2370a76be5d96fc6954ac7aa274274a8" translate="yes" xml:space="preserve">
          <source>Throws an exception if storage of the requested size and alignment cannot be obtained.</source>
          <target state="translated">Hace una excepción si no se puede obtener el almacenamiento del tamaño y la alineación solicitados.</target>
        </trans-unit>
        <trans-unit id="78d4655bb8c331d30d35c5dca21382a3023d8907" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exception derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; if a random number could not be generated.</source>
          <target state="translated">Lanza una excepci&amp;oacute;n definida por la implementaci&amp;oacute;n derivada de &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; si no se pudo generar un n&amp;uacute;mero aleatorio.</target>
        </trans-unit>
        <trans-unit id="c71eb890289859862d506be6577481a6155d7187" translate="yes" xml:space="preserve">
          <source>Throws an implementation-defined exceptions derived from &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; on failure.</source>
          <target state="translated">Lanza una excepci&amp;oacute;n definida por la implementaci&amp;oacute;n derivada de &lt;code&gt;&lt;a href=&quot;../../../error/exception&quot;&gt;std::exception&lt;/a&gt;&lt;/code&gt; en caso de falla.</target>
        </trans-unit>
        <trans-unit id="7035dd91c99b009a7736d3114cd02d3205a59146" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by &lt;code&gt;T&lt;/code&gt;'s constructor. If an exception is thrown, the previously contained object (if any) has been destroyed, and &lt;code&gt;*this&lt;/code&gt; does not contain a value.</source>
          <target state="translated">Lanza cualquier excepci&amp;oacute;n lanzada por el constructor de &lt;code&gt;T&lt;/code&gt; .Si se produce una excepci&amp;oacute;n, el objeto previamente contenido (si lo hay) se ha destruido y &lt;code&gt;*this&lt;/code&gt; no contiene un valor.</target>
        </trans-unit>
        <trans-unit id="c4b5347955a68d7b49fb60df96bc4c1fe1be392e" translate="yes" xml:space="preserve">
          <source>Throws any exception thrown by the constructor of &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Lanza cualquier excepci&amp;oacute;n lanzada por el constructor de la &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b00b9bd5afe726c1c402b63375bc4866d56f7c" translate="yes" xml:space="preserve">
          <source>Throws no exceptions, unless the construction of &lt;code&gt;fd&lt;/code&gt; throws.</source>
          <target state="translated">No lanza excepciones, a menos que la construcci&amp;oacute;n de lanzamientos &lt;code&gt;fd&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2e4fed0e085b765b71b25a3a55fd75c68b497a32" translate="yes" xml:space="preserve">
          <source>Throws no exceptions.</source>
          <target state="translated">No hay excepciones.</target>
        </trans-unit>
        <trans-unit id="c77dbbe1f17eaa70afe33271369b7e39a68c956a" translate="yes" xml:space="preserve">
          <source>Throws nothing unless calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource throws.</source>
          <target state="translated">No arroja nada a menos que llame a &lt;code&gt;allocate()&lt;/code&gt; en los recursos de memoria aguas arriba.</target>
        </trans-unit>
        <trans-unit id="3473cebcbcfaf057526db12532a7e05950b9a394" translate="yes" xml:space="preserve">
          <source>Throws nothing.</source>
          <target state="translated">No arroja nada.</target>
        </trans-unit>
        <trans-unit id="d36a7251aa285e37e60059fda10d55905771330c" translate="yes" xml:space="preserve">
          <source>Throws only if an operation on &lt;code&gt;dest&lt;/code&gt; throws.</source>
          <target state="translated">Lanza solo si se lanza una operaci&amp;oacute;n en &lt;code&gt;dest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ec2a611e5f00a6feb428658f1aa68f1b6da7754" translate="yes" xml:space="preserve">
          <source>Throws the previously captured exception object, referred to by the exception pointer &lt;code&gt;p&lt;/code&gt;.</source>
          <target state="translated">Lanza el objeto de excepci&amp;oacute;n capturado anteriormente, al que hace referencia el puntero de excepci&amp;oacute;n &lt;code&gt;p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcec7ea351c0f526e56ea2d8f983f85ec1b9038a" translate="yes" xml:space="preserve">
          <source>Thus, replacing the throwing single object deallocation functions (1,3) is sufficient to handle all deallocations.</source>
          <target state="translated">Por lo tanto,la sustitución de las funciones de deallocation de un solo objeto de lanzamiento (1,3)es suficiente para manejar todas las deallocaciones.</target>
        </trans-unit>
        <trans-unit id="c43feecba43a30ac9fc0c134e6e8cb0382c660f2" translate="yes" xml:space="preserve">
          <source>Time manipulation</source>
          <target state="translated">Manipulación del tiempo</target>
        </trans-unit>
        <trans-unit id="6a48c0a81754a0e5cd402f2b5b7b65e0802b3ae0" translate="yes" xml:space="preserve">
          <source>Time of day</source>
          <target state="translated">La hora del día</target>
        </trans-unit>
        <trans-unit id="848d63dd0e0417a6a6d0653d6feba98b946a8d6e" translate="yes" xml:space="preserve">
          <source>Time point</source>
          <target state="translated">Punto de tiempo</target>
        </trans-unit>
        <trans-unit id="99536a3f0c0c578df6810c5e30a06d3b2da45179" translate="yes" xml:space="preserve">
          <source>Time point (a &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt;)</source>
          <target state="translated">Punto de tiempo (a &lt;code&gt;&lt;a href=&quot;../system_clock&quot;&gt;std::chrono::sys_time&lt;/a&gt;&amp;lt;duration&amp;gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b99a31f7aded92da84e5f21bdba7429ff03b583d" translate="yes" xml:space="preserve">
          <source>Time point family</source>
          <target state="translated">Familia de punto de tiempo</target>
        </trans-unit>
        <trans-unit id="3e17e972e7d70a2b0ea19965e0edbbdd317996ef" translate="yes" xml:space="preserve">
          <source>Time since epoch as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object on success or &lt;code&gt;-1&lt;/code&gt; if &lt;code&gt;time&lt;/code&gt; cannot be represented as a &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; object.</source>
          <target state="translated">Tiempo desde &amp;eacute;poca como un objeto &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; en caso de &amp;eacute;xito o &lt;code&gt;-1&lt;/code&gt; si el &lt;code&gt;time&lt;/code&gt; no se puede representar como &lt;code&gt;&lt;a href=&quot;time_t&quot;&gt;std::time_t&lt;/a&gt;&lt;/code&gt; objeto .</target>
        </trans-unit>
        <trans-unit id="baff479affe7646bf932c42ec983a595bbc4b1cf" translate="yes" xml:space="preserve">
          <source>Time tracking (e.g. &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt;), C-style date and time (e.g. &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Seguimiento de tiempo (por ejemplo, &lt;code&gt;&lt;a href=&quot;chrono/time_point&quot;&gt;std::chrono::time_point&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;chrono/duration&quot;&gt;std::chrono::duration&lt;/a&gt;&lt;/code&gt; ), fecha y hora de estilo C (por ejemplo, &lt;code&gt;&lt;a href=&quot;chrono/c/time&quot;&gt;std::time&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;chrono/c/clock&quot;&gt;std::clock&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="eea79afd832854a3b24153b928ee9c62c7457dbe" translate="yes" xml:space="preserve">
          <source>Time zone</source>
          <target state="translated">Zona horaria</target>
        </trans-unit>
        <trans-unit id="932d3e6f9a587b1ed93ccda36b7118239840479f" translate="yes" xml:space="preserve">
          <source>Time zone pointer (denoted &lt;code&gt;zone&lt;/code&gt;)</source>
          <target state="translated">Puntero de zona horaria ( &lt;code&gt;zone&lt;/code&gt; indicada )</target>
        </trans-unit>
        <trans-unit id="40349a8ed2b426d8558214c08ff878c9b7836d5c" translate="yes" xml:space="preserve">
          <source>TimedLockable</source>
          <target state="translated">TimedLockable</target>
        </trans-unit>
        <trans-unit id="7a1979526d24991a3fdc66189422c80b7c9499d1" translate="yes" xml:space="preserve">
          <source>TimedMutex</source>
          <target state="translated">TimedMutex</target>
        </trans-unit>
        <trans-unit id="3d854366021896ce0345060f9138ad581720da11" translate="yes" xml:space="preserve">
          <source>To access the variadic arguments from the function body, the following library facilities are provided:</source>
          <target state="translated">Para acceder a los argumentos variados del cuerpo de la función,se proporcionan los siguientes servicios de biblioteca:</target>
        </trans-unit>
        <trans-unit id="2c3649f8d8e3f7fb8fa9a2e0b81692c7c0d56f26" translate="yes" xml:space="preserve">
          <source>To avoid data races, once a shared pointer is passed to any of these functions, it cannot be accessed non-atomically. In particular, you cannot dereference such a shared_ptr without first atomically loading it into another shared_ptr object, and then dereferencing through the second object.</source>
          <target state="translated">Para evitar las carreras de datos,una vez que se pasa un puntero compartido a cualquiera de estas funciones,no se puede acceder a él de forma no atómica.En particular,no se puede derivar tal shared_ptr sin primero cargarlo atómicamente en otro objeto shared_ptr,y luego derivarlo a través del segundo objeto.</target>
        </trans-unit>
        <trans-unit id="7c35636471d229cbd245a9382f85e9b6dce24337" translate="yes" xml:space="preserve">
          <source>To avoid these quirks, &lt;code&gt;result_of&lt;/code&gt; is often used with reference types as &lt;code&gt;F&lt;/code&gt; and &lt;code&gt;Args...&lt;/code&gt;. For example:</source>
          <target state="translated">Para evitar estas peculiaridades, &lt;code&gt;result_of&lt;/code&gt; se utiliza a menudo con los tipos de referencia como &lt;code&gt;F&lt;/code&gt; y &lt;code&gt;Args...&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="9af4209978b81d53f6e3f0d4dfaa5d56a5095a25" translate="yes" xml:space="preserve">
          <source>To avoid unnecessary copying of the exception object and object slicing, the best practice for catch clauses is to catch by reference.&lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12]&lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</source>
          <target state="translated">Para evitar la copia innecesaria del objeto de excepci&amp;oacute;n y el corte de objetos, la mejor pr&amp;aacute;ctica para las cl&amp;aacute;usulas catch es capturar por referencia. &lt;sup id=&quot;cite_ref-10&quot;&gt;&lt;a href=&quot;exceptions#cite_note-10&quot;&gt;[10] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-11&quot;&gt;&lt;a href=&quot;exceptions#cite_note-11&quot;&gt;[11] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-12&quot;&gt;&lt;a href=&quot;exceptions#cite_note-12&quot;&gt;[12] &lt;/a&gt;&lt;/sup&gt;&lt;sup id=&quot;cite_ref-13&quot;&gt;&lt;a href=&quot;exceptions#cite_note-13&quot;&gt;[13]&lt;/a&gt;&lt;/sup&gt;</target>
        </trans-unit>
        <trans-unit id="32227a48661c43cebdc36000ab948c6c4f0e7732" translate="yes" xml:space="preserve">
          <source>To be included in the set of viable functions, the candidate function must satisfy the following:</source>
          <target state="translated">Para ser incluida en el conjunto de funciones viables,la función candidata debe satisfacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="1d9269c47d9ba025b6ff347184af6dae00b4781f" translate="yes" xml:space="preserve">
          <source>To call the function,</source>
          <target state="translated">Para llamar a la función,</target>
        </trans-unit>
        <trans-unit id="3e00e2418f0d13b96de319ccb14e33b157fe6ecf" translate="yes" xml:space="preserve">
          <source>To compile a call to a function template, the compiler has to decide between non-template overloads, template overloads, and the specializations of the template overloads.</source>
          <target state="translated">Para compilar una llamada a una plantilla de funciones,el compilador tiene que decidir entre sobrecargas de no plantillas,sobrecargas de plantillas y las especializaciones de las sobrecargas de plantillas.</target>
        </trans-unit>
        <trans-unit id="648fa0a42ad74259537f74f99862470566d205e4" translate="yes" xml:space="preserve">
          <source>To convert a reference or a pointer to a cv-qualified type to a reference or pointer to a</source>
          <target state="translated">Para convertir una referencia o un puntero a un tipo calificado de cv a una referencia o un puntero a un</target>
        </trans-unit>
        <trans-unit id="479a613a1f4b0b411389efeda8d5cbee450b5792" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">Para crear una distribuci&amp;oacute;n en el intervalo cerrado [a, b], &lt;code&gt;&lt;a href=&quot;../../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; puede usarse como el segundo par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="d960d66e52b0039243dd579fef5b5e0189abe40c" translate="yes" xml:space="preserve">
          <source>To create a distribution over the closed interval [a,b], &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; may be used as the second parameter.</source>
          <target state="translated">Para crear una distribuci&amp;oacute;n en el intervalo cerrado [a, b], &lt;code&gt;&lt;a href=&quot;../math/nextafter&quot;&gt;std::nextafter&lt;/a&gt;(b, &lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;RealType&amp;gt;::max())&lt;/code&gt; puede usarse como el segundo par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="99e393ae840d4dfdfd8ab0ea9c4989b21f3b3380" translate="yes" xml:space="preserve">
          <source>To declare a variadic function, an ellipsis is used as the last parameter, e.g. &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt;. See &lt;a href=&quot;../language/variadic_arguments&quot;&gt;Variadic arguments&lt;/a&gt; for additional detail on the syntax, automatic argument conversions and the alternatives.</source>
          <target state="translated">Para declarar una funci&amp;oacute;n variada, se utiliza una elipsis como &amp;uacute;ltimo par&amp;aacute;metro, por ejemplo, &lt;code&gt;int printf(const char* format, ...);&lt;/code&gt; . Ver &lt;a href=&quot;../language/variadic_arguments&quot;&gt;argumentos variables&lt;/a&gt; para obtener detalles adicionales sobre la sintaxis, las conversiones autom&amp;aacute;ticas de argumentos y las alternativas.</target>
        </trans-unit>
        <trans-unit id="22cd3be1d2fb287ce824540ee1391a62cb561144" translate="yes" xml:space="preserve">
          <source>To ensure that the program benefits from the optimizations enabled by &lt;code&gt;assume_aligned&lt;/code&gt;, it is important to access the object via its return value:</source>
          <target state="translated">Para garantizar que el programa se beneficie de las optimizaciones habilitadas por &lt;code&gt;assume_aligned&lt;/code&gt; , es importante acceder al objeto a trav&amp;eacute;s de su valor de retorno:</target>
        </trans-unit>
        <trans-unit id="525fd31bb668048344f8a31de0c1142305eb7415" translate="yes" xml:space="preserve">
          <source>To generate enough entropy, &lt;code&gt;generate_canonical()&lt;/code&gt; will call &lt;code&gt;g()&lt;/code&gt; exactly k times, where \(k = max(1, \lceil \frac{b}{log_2 R} \rceil)\)k = max(1, &amp;lceil; b / log</source>
          <target state="translated">Para generar suficiente entrop&amp;iacute;a, &lt;code&gt;generate_canonical()&lt;/code&gt; llamar&amp;aacute; a &lt;code&gt;g()&lt;/code&gt; exactamente k veces, donde \ (k = max (1, \ lceil \ frac {b} {log_2 R} \ rceil) \) k = max (1, &amp;lceil; b / Iniciar sesi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="2c0e3e28251239ee8bfb2240bdd1fc0f1ed54c3c" translate="yes" xml:space="preserve">
          <source>To grant access to additional functions or classes to protected or private members, a &lt;a href=&quot;friend&quot;&gt;friendship declaration&lt;/a&gt; may be used.</source>
          <target state="translated">Para otorgar acceso a funciones o clases adicionales a miembros protegidos o privados, se puede utilizar una &lt;a href=&quot;friend&quot;&gt;declaraci&amp;oacute;n de amistad&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="878939687f32a6c24537c7a73b290843588b7164" translate="yes" xml:space="preserve">
          <source>To initialize a pointer to null or to assign the null value to an existing pointer, the null pointer literal &lt;code&gt;nullptr&lt;/code&gt;, the null pointer constant &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;, or the &lt;a href=&quot;implicit_cast&quot;&gt;implicit conversion&lt;/a&gt; from the integer value &lt;code&gt;​0​&lt;/code&gt; may be used.</source>
          <target state="translated">Para inicializar un puntero a nulo o asignar el valor nulo a un puntero existente, el puntero nulo literal &lt;code&gt;nullptr&lt;/code&gt; , la constante de puntero nulo &lt;code&gt;&lt;a href=&quot;../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; o la &lt;a href=&quot;implicit_cast&quot;&gt;conversi&amp;oacute;n impl&amp;iacute;cita&lt;/a&gt; del valor entero &lt;code&gt;​0​&lt;/code&gt; pueden ser utilizados.</target>
        </trans-unit>
        <trans-unit id="e3122235602ec384e5e6446cb56e5141efaef34c" translate="yes" xml:space="preserve">
          <source>To iterate over the current directory, construct the iterator as &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; instead of &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt;.</source>
          <target state="translated">Para iterar sobre el directorio actual, construya el iterador como &lt;code&gt;directory_iterator(&quot;.&quot;)&lt;/code&gt; lugar de &lt;code&gt;directory_iterator(&quot;&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="724317f9ed9523d1d5aa4de4bf63c61feb5cf73f" translate="yes" xml:space="preserve">
          <source>To make ADL examine a user-defined namespace, either &lt;code&gt;std::vector&lt;/code&gt; should be replaced by a user-defined class or its element type should be a user-defined class:</source>
          <target state="translated">Para hacer que ADL examine un espacio de nombres definido por el usuario, &lt;code&gt;std::vector&lt;/code&gt; debe ser reemplazado por una clase definida por el usuario o su tipo de elemento debe ser una clase definida por el usuario:</target>
        </trans-unit>
        <trans-unit id="9dacb8ab35ec1963dda5bb3c402d87f89eb9adc7" translate="yes" xml:space="preserve">
          <source>To make strong exception guarantee possible, user-defined move constructors should not throw exceptions. For example, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; relies on &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; to choose between move and copy when the elements need to be relocated.</source>
          <target state="translated">Para hacer posible una fuerte garant&amp;iacute;a de excepci&amp;oacute;n, los constructores de movimiento definidos por el usuario no deben lanzar excepciones. Por ejemplo, &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; basa en &lt;code&gt;&lt;a href=&quot;../utility/move_if_noexcept&quot;&gt;std::move_if_noexcept&lt;/a&gt;&lt;/code&gt; para elegir entre mover y copiar cuando los elementos necesitan ser reubicados.</target>
        </trans-unit>
        <trans-unit id="fbaf135ff4214aca3306677fb2ad01282f0bd0a8" translate="yes" xml:space="preserve">
          <source>To match a template template argument &lt;code&gt;A&lt;/code&gt; to a template template parameter &lt;code&gt;P&lt;/code&gt;, each of the template parameters of &lt;code&gt;A&lt;/code&gt; must match corresponding template parameters of &lt;code&gt;P&lt;/code&gt; exactly(until C++17)&lt;code&gt;P&lt;/code&gt; must be at least as specialized as &lt;code&gt;A&lt;/code&gt;(since C++17). If &lt;code&gt;P&lt;/code&gt;'s parameter list includes a &lt;a href=&quot;parameter_pack&quot;&gt;parameter pack&lt;/a&gt;, zero or more template parameters (or parameter packs) from &lt;code&gt;A&lt;/code&gt;'s template parameter list are matched by it.</source>
          <target state="translated">Para hacer coincidir un argumento de plantilla de plantilla &lt;code&gt;A&lt;/code&gt; con un par&amp;aacute;metro de plantilla de plantilla &lt;code&gt;P&lt;/code&gt; , cada uno de los par&amp;aacute;metros de plantilla de &lt;code&gt;A&lt;/code&gt; debe coincidir exactamente con los par&amp;aacute;metros de plantilla correspondientes de &lt;code&gt;P&lt;/code&gt; (hasta C ++ 17) &lt;code&gt;P&lt;/code&gt; debe ser al menos tan especializado como &lt;code&gt;A&lt;/code&gt; (ya que C ++ 17) Si &lt;code&gt;P&lt;/code&gt; 'lista de par&amp;aacute;metros s incluye un &lt;a href=&quot;parameter_pack&quot;&gt;paquete de par&amp;aacute;metro&lt;/a&gt; , cero o m&amp;aacute;s par&amp;aacute;metros de plantilla (o paquetes de par&amp;aacute;metros) a partir de &lt;code&gt;A&lt;/code&gt; ' lista de par&amp;aacute;metros plantilla s est&amp;aacute;n emparejados por ella.</target>
        </trans-unit>
        <trans-unit id="1653fef798170fad22ce8f246671d9967ebf88bf" translate="yes" xml:space="preserve">
          <source>To provide multidimensional array access semantics, e.g. to implement a 3D array access &lt;code&gt;a[i][j][k] = x;&lt;/code&gt;, operator[] has to return a reference to a 2D plane, which has to have its own operator[] which returns a reference to a 1D row, which has to have operator[] which returns a reference to the element. To avoid this complexity, some libraries opt for overloading &lt;code&gt;operator()&lt;/code&gt; instead, so that 3D access expressions have the Fortran-like syntax &lt;code&gt;a(i, j, k) = x;&lt;/code&gt;</source>
          <target state="translated">Para proporcionar sem&amp;aacute;ntica de acceso a matriz multidimensional, por ejemplo, para implementar un acceso a matriz 3D &lt;code&gt;a[i][j][k] = x;&lt;/code&gt; , el operador [] debe devolver una referencia a un plano 2D, que debe tener su propio operador [] que devuelve una referencia a una fila 1D, que debe tener un operador [] que devuelve una referencia al elemento. Para evitar esta complejidad, algunas bibliotecas optan por sobrecargar el &lt;code&gt;operator()&lt;/code&gt; , de modo que las expresiones de acceso 3D tengan la sintaxis tipo Fortran &lt;code&gt;a(i, j, k) = x;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="106dedcf05132b51eabb9b06f962997250951fc9" translate="yes" xml:space="preserve">
          <source>To refer to a static member &lt;code&gt;m&lt;/code&gt; of class &lt;code&gt;T&lt;/code&gt;, two forms may be used: qualified name &lt;code&gt;T::m&lt;/code&gt; or member access expression &lt;code&gt;E.m&lt;/code&gt; or &lt;code&gt;E-&amp;gt;m&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression that evaluates to &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T*&lt;/code&gt; respectively. When in the same class scope, the qualification is unnecessary:</source>
          <target state="translated">Para referirse a un miembro est&amp;aacute;tico &lt;code&gt;m&lt;/code&gt; de clase &lt;code&gt;T&lt;/code&gt; , se pueden usar dos formas: nombre calificado &lt;code&gt;T::m&lt;/code&gt; &lt;code&gt;E.m&lt;/code&gt; expresi&amp;oacute;n de acceso de miembro Em o &lt;code&gt;E-&amp;gt;m&lt;/code&gt; , donde &lt;code&gt;E&lt;/code&gt; es una expresi&amp;oacute;n que se eval&amp;uacute;a como &lt;code&gt;T&lt;/code&gt; o &lt;code&gt;T*&lt;/code&gt; respectivamente. Cuando est&amp;aacute; en el mismo alcance de clase, la calificaci&amp;oacute;n es innecesaria:</target>
        </trans-unit>
        <trans-unit id="3726bd5210fa66b99d1405f1d23513ff4e9a847a" translate="yes" xml:space="preserve">
          <source>To reopen an existing namespace (formally, to be an</source>
          <target state="translated">Para reabrir un espacio de nombres existente (formalmente,para ser un</target>
        </trans-unit>
        <trans-unit id="6766595568bdee575215126dcd221dc1330e2532" translate="yes" xml:space="preserve">
          <source>To replace the managed object while supplying a new deleter as well, move assignment operator may be used.</source>
          <target state="translated">Para reemplazar el objeto administrado mientras se suministra un nuevo deleter también,se puede utilizar un operador de asignación de movimiento.</target>
        </trans-unit>
        <trans-unit id="f22138cc2032a2d9e0e8461eb5887bb980094c3c" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators&quot;&gt;user-defined operator==&lt;/a&gt;.</source>
          <target state="translated">Para cumplir este requisito, los tipos que no tienen &lt;a href=&quot;../language/operator_comparison&quot;&gt;operadores de comparaci&amp;oacute;n&lt;/a&gt; incorporados deben proporcionar un &lt;a href=&quot;../language/operators&quot;&gt;operador definido por el usuario ==&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="129c710e9009508a2e1a7fdb48457bda967c930d" translate="yes" xml:space="preserve">
          <source>To satisfy this requirement, types that do not have built-in &lt;a href=&quot;../language/operator_comparison&quot;&gt;comparison operators&lt;/a&gt; have to provide a &lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;user-defined operator&amp;lt;&lt;/a&gt;</source>
          <target state="translated">Para satisfacer este requisito, los tipos que no tienen &lt;a href=&quot;../language/operator_comparison&quot;&gt;operadores de comparaci&amp;oacute;n&lt;/a&gt; incorporados deben proporcionar un &lt;a href=&quot;../language/operators#Relational_operators&quot;&gt;operador definido por el usuario &amp;lt;&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="17417ca14266e537b698e5e14276654d4c17a975" translate="yes" xml:space="preserve">
          <source>To satisfy thread safety requirements, the reference counters are typically incremented using an equivalent of &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; (decrementing requires stronger ordering to safely destroy the control block).</source>
          <target state="translated">Para satisfacer los requisitos de seguridad de subprocesos, los contadores de referencia generalmente se incrementan utilizando un equivalente de &lt;code&gt;&lt;a href=&quot;../atomic/atomic/fetch_add&quot;&gt;std::atomic::fetch_add&lt;/a&gt;&lt;/code&gt; con &lt;code&gt;&lt;a href=&quot;../atomic/memory_order&quot;&gt;std::memory_order_relaxed&lt;/a&gt;&lt;/code&gt; (la disminuci&amp;oacute;n requiere un orden m&amp;aacute;s fuerte para destruir con seguridad el bloque de control).</target>
        </trans-unit>
        <trans-unit id="8878bda84316e640272f36cf3fc4a73005bafae8" translate="yes" xml:space="preserve">
          <source>To simplify management of dynamically-allocated objects, the result of a new-expression is often stored in a</source>
          <target state="translated">Para simplificar la gestión de los objetos asignados dinámicamente,el resultado de una nueva expresión suele almacenarse en un</target>
        </trans-unit>
        <trans-unit id="72759510b678f958968f4cb0b51ad3056400cce9" translate="yes" xml:space="preserve">
          <source>To test the last two conditions, compilers may first perform a trial constant evaluation of the initializers. It is not recommended to depend on the result in this case.</source>
          <target state="translated">Para probar las dos últimas condiciones,los compiladores pueden realizar primero una evaluación constante de prueba de los inicializadores.No se recomienda depender del resultado en este caso.</target>
        </trans-unit>
        <trans-unit id="2ef767a66957791708ed92649c40f252de18b675" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; (&lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt; (&lt;/code&gt; arg1, arg2, ... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fd5e6c8eaf332caffe8f6fbe44a90cd7d1b98a0" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; designador &lt;code&gt;=&lt;/code&gt; arg1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; designador &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8524224705b06e86014d7113489a9fa766f785d6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt; {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt; {&lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1fa04374ca1b3d5854920daae3a860b764cf4bc1" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg1, arg2, ...&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt;( &lt;/code&gt; arg1, arg2, ... &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ad21f03c3b6e98547a57e446e234ea4a3bc549c4" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;( &lt;/code&gt;arg&lt;code&gt;);&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt;( &lt;/code&gt; arg &lt;code&gt;);&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="73dc4cf67a69ee8abf0145c5834683df2e89c44e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8be85a4e1d42709d6cc3339f92d0ed646df7afbf" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;= {&lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt;= {&lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="749c4b6dafadee83198511f34995fe4793451e2c" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt; {&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;=&lt;/code&gt;arg1&lt;code&gt;,&lt;/code&gt;&lt;code&gt;.&lt;/code&gt;designator&lt;code&gt;{&lt;/code&gt;arg2&lt;code&gt;} &lt;/code&gt;... &lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt;=&lt;/code&gt; &lt;code&gt; {&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; designador &lt;code&gt;=&lt;/code&gt; arg1 &lt;code&gt;,&lt;/code&gt; &lt;code&gt;.&lt;/code&gt; designador &lt;code&gt;{&lt;/code&gt; arg2 &lt;code&gt;} &lt;/code&gt; ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="66d34b7b6a63046c11e32cb28d0bfdc320edb9c6" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;&lt;code&gt;{&lt;/code&gt;other&lt;code&gt;} &lt;/code&gt;&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt;=&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; otro &lt;code&gt;} &lt;/code&gt; &lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ca0bdecf7ffe3b07ea0bd6237e1e29b32609b1b3" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;=&lt;/code&gt;other&lt;code&gt;;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="709755aaf5485c722f9b0e75a1395ff736803b24" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg1, arg2, ...&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt;{ &lt;/code&gt; arg1, arg2, ... &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="61782cc12972859d36df728c91f3cae207b1187e" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{ &lt;/code&gt;arg&lt;code&gt;};&lt;/code&gt;</source>
          <target state="translated">Objeto &lt;code&gt;{ &lt;/code&gt; arg &lt;code&gt;};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f01015bfa0f56ac60d1e5a7cf450991d276e29b7" translate="yes" xml:space="preserve">
          <source>Tobject&lt;code&gt;{};&lt;/code&gt;</source>
          <target state="translated">Tobject&lt;code&gt;{};&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ddb24f2589165d45d6ccb527543d8886fc657afc" translate="yes" xml:space="preserve">
          <source>Together with identifiers they are known as</source>
          <target state="translated">Junto con los identificadores se conocen como</target>
        </trans-unit>
        <trans-unit id="3eff2f682c2bec3252c55e73a2e17235c924d9ac" translate="yes" xml:space="preserve">
          <source>Toggles each &lt;code&gt;bool&lt;/code&gt; in the vector (replaces with its opposite value).</source>
          <target state="translated">Alterna cada &lt;code&gt;bool&lt;/code&gt; en el vector (reemplaza con su valor opuesto).</target>
        </trans-unit>
        <trans-unit id="f77fbd9a82d243179f6ff219e1e46df3d7caa6d5" translate="yes" xml:space="preserve">
          <source>Too many files open in system</source>
          <target state="translated">Demasiados archivos abiertos en el sistema</target>
        </trans-unit>
        <trans-unit id="2e0d2eef3cc8719301cd02a8aeecb9e956e88cf1" translate="yes" xml:space="preserve">
          <source>Too many levels of symbolic links</source>
          <target state="translated">Demasiados niveles de vínculos simbólicos</target>
        </trans-unit>
        <trans-unit id="4113b4c9ebd053469430304ab17dc16ea1d01df9" translate="yes" xml:space="preserve">
          <source>Too many links</source>
          <target state="translated">Demasiados enlaces</target>
        </trans-unit>
        <trans-unit id="171702bf2e722b21f3bd6c8ccb2927b1ba5f9e5e" translate="yes" xml:space="preserve">
          <source>Total ordering relation opposite to &lt;code&gt;a &amp;lt; b&lt;/code&gt;</source>
          <target state="translated">Relaci&amp;oacute;n de orden total opuesta a &lt;code&gt;a &amp;lt; b&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00914541a4417609db5b497e533746eecb783cd5" translate="yes" xml:space="preserve">
          <source>Total sequential ordering requires a full memory fence CPU instruction on all multi-core systems. This may become a performance bottleneck since it forces the affected memory accesses to propagate to every core.</source>
          <target state="translated">El orden secuencial total requiere una instrucción completa de la CPU de la valla de memoria en todos los sistemas multi-núcleo.Esto puede convertirse en un cuello de botella en el rendimiento,ya que obliga a los accesos de memoria afectados a propagarse a cada núcleo.</target>
        </trans-unit>
        <trans-unit id="dad674e48704a92597b8a13244ba1d8ca29324b7" translate="yes" xml:space="preserve">
          <source>Trade-offs</source>
          <target state="translated">Trade-offs</target>
        </trans-unit>
        <trans-unit id="ef3b5b7a3bf5164b6e6ee23c058ba72528930808" translate="yes" xml:space="preserve">
          <source>Trade-offs / usage notes</source>
          <target state="translated">Intercambios/notas de uso</target>
        </trans-unit>
        <trans-unit id="7cf26da75debf6bbf1e4104795dc48892c4d5484" translate="yes" xml:space="preserve">
          <source>Trailing return type, useful if the return type depends on argument names, such as &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; or is complicated, such as in &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt;</source>
          <target state="translated">Tipo de retorno al final, &amp;uacute;til si el tipo de retorno depende de los nombres de los argumentos, como &lt;code&gt;template &amp;lt;class T, class U&amp;gt; auto add(T t, U u) -&amp;gt; decltype(t + u);&lt;/code&gt; o es complicado, como en &lt;code&gt;auto fpif(int)-&amp;gt;int(*)(int)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d1a616085a1a99a58e14bafaa350abc6783a3160" translate="yes" xml:space="preserve">
          <source>Traits</source>
          <target state="translated">Traits</target>
        </trans-unit>
        <trans-unit id="cd91d96e3393ae0f62bad1c5ed125449050e450f" translate="yes" xml:space="preserve">
          <source>Transaction-safe functions</source>
          <target state="translated">Funciones de seguridad en las transacciones</target>
        </trans-unit>
        <trans-unit id="79ed6ec4dd6c977b5231ac5a3a3185c0bc9188fd" translate="yes" xml:space="preserve">
          <source>Transaction-safe virtual functions</source>
          <target state="translated">Funciones virtuales seguras para las transacciones</target>
        </trans-unit>
        <trans-unit id="28bf6d401ae77b97e36abdf2221c6cfe2e85fc1e" translate="yes" xml:space="preserve">
          <source>Transactional memory</source>
          <target state="translated">La memoria transaccional</target>
        </trans-unit>
        <trans-unit id="76f8221e9e089679019e2f0fa532136f150e6dc7" translate="yes" xml:space="preserve">
          <source>Transactional memory is a concurrency synchronization mechanism that combines groups of statements in transactions, that are.</source>
          <target state="translated">La memoria transaccional es un mecanismo de sincronización de concurrencia que combina grupos de declaraciones en las transacciones,que son.</target>
        </trans-unit>
        <trans-unit id="6b317497e33c505c0091e508e0f819e953607bb9" translate="yes" xml:space="preserve">
          <source>Transfers control to one of the several statements, depending on the value of a condition.</source>
          <target state="translated">Transfiere el control a una de las varias declaraciones,dependiendo del valor de una condición.</target>
        </trans-unit>
        <trans-unit id="3ae0e89e8b68942479d9172eed374b0285eee3cc" translate="yes" xml:space="preserve">
          <source>Transfers control unconditionally.</source>
          <target state="translated">Transfiere el control incondicionalmente.</target>
        </trans-unit>
        <trans-unit id="1f702e1322ae9e879ee08e3f62c5bdb1e12300d8" translate="yes" xml:space="preserve">
          <source>Transfers elements from one list to another.</source>
          <target state="translated">Transfiere elementos de una lista a otra.</target>
        </trans-unit>
        <trans-unit id="3de309422c516a3c7cf8622a78d8e35f6e1be1eb" translate="yes" xml:space="preserve">
          <source>Transfers the shared state of &lt;code&gt;*this&lt;/code&gt;, if any, to a &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; object. Multiple &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; objects may reference the same shared state, which is not possible with &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Transfiere el estado compartido de &lt;code&gt;*this&lt;/code&gt; , si lo hay, a un objeto &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; . Varios objetos &lt;code&gt;&lt;a href=&quot;../shared_future&quot;&gt;std::shared_future&lt;/a&gt;&lt;/code&gt; pueden hacer referencia al mismo estado compartido, que no es posible con &lt;code&gt;&lt;a href=&quot;../future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17a159e3083a2a40c26d036cc1b99d55a3a0d7c4" translate="yes" xml:space="preserve">
          <source>Transform the elements of the output range according to the following algorithm:</source>
          <target state="translated">Transformar los elementos del rango de salida de acuerdo con el siguiente algoritmo:</target>
        </trans-unit>
        <trans-unit id="0d2ad20c7dacbba2fdbdd4ce378e8828c433c3a1" translate="yes" xml:space="preserve">
          <source>TransformationTrait</source>
          <target state="translated">TransformationTrait</target>
        </trans-unit>
        <trans-unit id="7bfde37a73ea6090d21989590088e7aade736914" translate="yes" xml:space="preserve">
          <source>TransformationTraits Redux</source>
          <target state="translated">TransformationTrait Redux</target>
        </trans-unit>
        <trans-unit id="4ce48d092354c3cfaf58f19e47f595e8893390a1" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an exclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;exclusive&quot; means that the i-th input element is not included in the i-th sum.</source>
          <target state="translated">Transforma cada elemento en el rango &lt;code&gt;[first, last)&lt;/code&gt; con &lt;code&gt;unary_op&lt;/code&gt; , luego calcula una operaci&amp;oacute;n exclusiva de suma de prefijo usando &lt;code&gt;binary_op&lt;/code&gt; sobre el rango resultante, con &lt;code&gt;init&lt;/code&gt; como valor inicial, y escribe los resultados en el rango que comienza en &lt;code&gt;d_first&lt;/code&gt; . &quot;exclusivo&quot; significa que el elemento de entrada i-&amp;eacute;simo no est&amp;aacute; incluido en la suma i-&amp;eacute;simo.</target>
        </trans-unit>
        <trans-unit id="76499db2839b046f9ef84418dd0b227738ab59b2" translate="yes" xml:space="preserve">
          <source>Transforms each element in the range &lt;code&gt;[first, last)&lt;/code&gt; with &lt;code&gt;unary_op&lt;/code&gt;, then computes an inclusive prefix sum operation using &lt;code&gt;binary_op&lt;/code&gt; over the resulting range, optionally with &lt;code&gt;init&lt;/code&gt; as the initial value, and writes the results to the range beginning at &lt;code&gt;d_first&lt;/code&gt;. &quot;inclusive&quot; means that the i-th input element is included in the i-th sum.</source>
          <target state="translated">Transforma cada elemento en el rango &lt;code&gt;[first, last)&lt;/code&gt; con &lt;code&gt;unary_op&lt;/code&gt; , luego calcula una operaci&amp;oacute;n de suma de prefijo inclusivo usando &lt;code&gt;binary_op&lt;/code&gt; sobre el rango resultante, opcionalmente con &lt;code&gt;init&lt;/code&gt; como valor inicial, y escribe los resultados en el rango que comienza en &lt;code&gt;d_first&lt;/code&gt; . &quot;inclusivo&quot; significa que el i-&amp;eacute;simo elemento de entrada est&amp;aacute; incluido en la i-&amp;eacute;sima suma.</target>
        </trans-unit>
        <trans-unit id="1c65f6d1ba0f638d5024c5624db7ea27406001c1" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated byte string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">Transforma la cadena de bytes terminada en nulo a la que apunta &lt;code&gt;src&lt;/code&gt; en la forma definida por la implementaci&amp;oacute;n de modo que al comparar dos cadenas transformadas con &lt;code&gt;&lt;a href=&quot;strcmp&quot;&gt;std::strcmp&lt;/a&gt;&lt;/code&gt; obtiene el mismo resultado que al comparar las cadenas originales con &lt;code&gt;&lt;a href=&quot;strcoll&quot;&gt;std::strcoll&lt;/a&gt;&lt;/code&gt; , en el entorno local actual de C.</target>
        </trans-unit>
        <trans-unit id="b23c453442ba4c19cf270e32634b19b7e31b8f29" translate="yes" xml:space="preserve">
          <source>Transforms the null-terminated wide string pointed to by &lt;code&gt;src&lt;/code&gt; into the implementation-defined form such that comparing two transformed strings with &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; gives the same result as comparing the original strings with &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt;, in the current C locale.</source>
          <target state="translated">Transforma la cadena ancha terminada en nulo a la que apunta &lt;code&gt;src&lt;/code&gt; en la forma definida por la implementaci&amp;oacute;n de modo que al comparar dos cadenas transformadas con &lt;code&gt;&lt;a href=&quot;wcscmp&quot;&gt;std::wcscmp&lt;/a&gt;&lt;/code&gt; obtiene el mismo resultado que al comparar las cadenas originales con &lt;code&gt;&lt;a href=&quot;wcscoll&quot;&gt;std::wcscoll&lt;/a&gt;&lt;/code&gt; , en el entorno local actual de C.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
