<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="cpp">
    <body>
      <group id="cpp">
        <trans-unit id="e58f6c458633d11255df6ec72e17d6e0e307082c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex arc tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip unbounded along the imaginary axis and in the interval [&amp;minus;&amp;pi;/2; +&amp;pi;/2] along the real axis.</source>
          <target state="translated">Si no se producen errores, se devuelve un arco tangente complejo de &lt;code&gt;z&lt;/code&gt; , en el rango de una franja ilimitada a lo largo del eje imaginario y en el intervalo [&amp;minus;&amp;pi; / 2; + &amp;pi; / 2] a lo largo del eje real.</target>
        </trans-unit>
        <trans-unit id="50a8713f4c4c617bedaa7a390ea195b3329dac1c" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se producen errores, se devuelve el coseno hiperb&amp;oacute;lico complejo de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8e6619163d1ca9fedc0a2bfd79d4c047fbeb277" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se producen errores, se devuelve un seno hiperb&amp;oacute;lico complejo de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0204a9004641a330efb33cc1c10a2eb5fe8c95c2" translate="yes" xml:space="preserve">
          <source>If no errors occur, complex hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se producen errores, se devuelve la tangente hiperb&amp;oacute;lica compleja de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b37be6aaeb963e74d379aaa690fc0222ec1a8842" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the absolute value (also known as norm, modulus, or magnitude) of &lt;code&gt;z&lt;/code&gt;.</source>
          <target state="translated">Si no se producen errores, devuelve el valor absoluto (tambi&amp;eacute;n conocido como norma, m&amp;oacute;dulo o magnitud) de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f7f248bc9527b22f78b886ecb63cf4c8a2bd9c60" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the fractional part of &lt;code&gt;x&lt;/code&gt; with the same sign as &lt;code&gt;x&lt;/code&gt;. The integral part is put into the value pointed to by &lt;code&gt;iptr&lt;/code&gt;.</source>
          <target state="translated">Si no se producen errores, devuelve la parte fraccionaria de &lt;code&gt;x&lt;/code&gt; con el mismo signo que &lt;code&gt;x&lt;/code&gt; . La parte integral se pone en el valor se&amp;ntilde;alado por &lt;code&gt;iptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcbbfc79f2b5b688deb79fcd4d7c358c461e6459" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the phase angle of &lt;code&gt;z&lt;/code&gt; in the interval [&amp;minus;&amp;pi;; &amp;pi;].</source>
          <target state="translated">Si no se producen errores, devuelve el &amp;aacute;ngulo de fase de &lt;code&gt;z&lt;/code&gt; en el intervalo [&amp;minus;&amp;pi;; &amp;pi;].</target>
        </trans-unit>
        <trans-unit id="af3231d18a9dbafc82193c163f7f7ec4e37b28f7" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the square root of &lt;code&gt;z&lt;/code&gt;, in the range of the right half-plane, including the imaginary axis ([0; +&amp;infin;) along the real axis and (&amp;minus;&amp;infin;; +&amp;infin;) along the imaginary axis.).</source>
          <target state="translated">Si no se producen errores, devuelve la ra&amp;iacute;z cuadrada de &lt;code&gt;z&lt;/code&gt; , en el rango del semiplano derecho, incluido el eje imaginario ([0; + &amp;infin;) a lo largo del eje real y (&amp;minus;&amp;infin;; + &amp;infin;) a lo largo del eje imaginario. )</target>
        </trans-unit>
        <trans-unit id="c2564a63d94a5759bfc1f7f8a35fbdfcf9b9d071" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the first kind of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is j</source>
          <target state="translated">Si no se producen errores, devuelve el valor de la funci&amp;oacute;n esf&amp;eacute;rica de Bessel del primer tipo de &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; , es decir, j</target>
        </trans-unit>
        <trans-unit id="4739e7b0751e1897ecdce821941cd1dfb83af3ac" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical Bessel function of the second kind (spherical Neumann function) of &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is n</source>
          <target state="translated">Si no se producen errores, devuelve el valor de la funci&amp;oacute;n esf&amp;eacute;rica de Bessel del segundo tipo (funci&amp;oacute;n esf&amp;eacute;rica de Neumann) de &lt;code&gt;n&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; , es decir n</target>
        </trans-unit>
        <trans-unit id="63cd03ce841bb8c36f4907b2d91c123b017f259e" translate="yes" xml:space="preserve">
          <source>If no errors occur, returns the value of the spherical associated Legendre function (that is, spherical harmonic with ϕ = 0) of &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt;, and &lt;code&gt;&amp;theta;&lt;/code&gt;, where the spherical harmonic function is defined as Ym</source>
          <target state="translated">Si no se producen errores, devuelve el valor de la funci&amp;oacute;n de Legendre asociada esf&amp;eacute;rica (es decir, arm&amp;oacute;nica esf&amp;eacute;rica con &amp;phi; = 0) de &lt;code&gt;l&lt;/code&gt; , &lt;code&gt;m&lt;/code&gt; , y &lt;code&gt;&amp;theta;&lt;/code&gt; , donde la funci&amp;oacute;n arm&amp;oacute;nica esf&amp;eacute;rica se define como Ym</target>
        </trans-unit>
        <trans-unit id="ee22b5df48ca25af069416a0b6aead9e8cfe0766" translate="yes" xml:space="preserve">
          <source>If no errors occur, square root of &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg), is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve la ra&amp;iacute;z cuadrada de &lt;code&gt;arg&lt;/code&gt; (&amp;radic;arg).</target>
        </trans-unit>
        <trans-unit id="d6cd26c82284031b354355d1565d22e205fe8e3d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc cosine of &lt;code&gt;arg&lt;/code&gt; (arccos(arg)) in the range [0 , &amp;pi;], is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve el arco coseno de &lt;code&gt;arg&lt;/code&gt; (arccos (arg)) en el rango [0, &amp;pi;].</target>
        </trans-unit>
        <trans-unit id="039d32b1f2e5bfee4ca5736c63a4206e5274388e" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc sine of &lt;code&gt;arg&lt;/code&gt; (arcsin(arg)) in the range [-</source>
          <target state="translated">Si no se producen errores, el seno del arco de &lt;code&gt;arg&lt;/code&gt; (arcsin (arg)) en el rango [-</target>
        </trans-unit>
        <trans-unit id="b32613c8b978beac62c696ce2bd93a54bd237edb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;arg&lt;/code&gt; (arctan(arg)) in the range [-</source>
          <target state="translated">Si no se producen errores, la tangente del arco de &lt;code&gt;arg&lt;/code&gt; (arctan (arg)) en el rango [-</target>
        </trans-unit>
        <trans-unit id="c938da3a42fe0590b15c6f8539ff408d3a3b97dd" translate="yes" xml:space="preserve">
          <source>If no errors occur, the arc tangent of &lt;code&gt;y/x&lt;/code&gt; (arctan(</source>
          <target state="translated">Si no se producen errores, la tangente del arco de &lt;code&gt;y/x&lt;/code&gt; (arctan (</target>
        </trans-unit>
        <trans-unit id="9d5986c54dce11e1cd1599414757016de12c5f01" translate="yes" xml:space="preserve">
          <source>If no errors occur, the base-</source>
          <target state="translated">Si no hay errores,la base...</target>
        </trans-unit>
        <trans-unit id="be331ea28ae7c2d7b9acf97860d316fce4b87723" translate="yes" xml:space="preserve">
          <source>If no errors occur, the common (base-</source>
          <target state="translated">Si no se producen errores,el común (base...</target>
        </trans-unit>
        <trans-unit id="135f7aa5f1c2d4f79725bd744a0dd782f41f3bfa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic cosine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip of nonnegative values along the real axis and in the interval [&amp;minus;i&amp;pi;; +i&amp;pi;] along the imaginary axis.</source>
          <target state="translated">Si no se producen errores, se devuelve el arco coseno hiperb&amp;oacute;lico complejo de &lt;code&gt;z&lt;/code&gt; , en el rango de una media tira de valores no negativos a lo largo del eje real y en el intervalo [&amp;minus;i&amp;pi;; + i&amp;pi;] a lo largo del eje imaginario.</target>
        </trans-unit>
        <trans-unit id="05909577ff3329b64c179e57f5f18c51d7427016" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic sine of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">Si no se producen errores, se devuelve el seno complejo hiperb&amp;oacute;lico del arco &lt;code&gt;z&lt;/code&gt; , en el rango de una tira matem&amp;aacute;ticamente ilimitada a lo largo del eje real y en el intervalo [&amp;minus;i&amp;pi; / 2; + i&amp;pi; / 2] a lo largo del eje imaginario.</target>
        </trans-unit>
        <trans-unit id="5e1faa126d0291e9222a13afce04bd8eb0c0cbd7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex arc hyperbolic tangent of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a half-strip mathematically unbounded along the real axis and in the interval [&amp;minus;i&amp;pi;/2; +i&amp;pi;/2] along the imaginary axis.</source>
          <target state="translated">Si no se producen errores, se devuelve la tangente hiperb&amp;oacute;lica de arco complejo de &lt;code&gt;z&lt;/code&gt; , en el rango de una media tira matem&amp;aacute;ticamente ilimitada a lo largo del eje real y en el intervalo [&amp;minus;i&amp;pi; / 2; + i&amp;pi; / 2] a lo largo del eje imaginario.</target>
        </trans-unit>
        <trans-unit id="b951e541cea44c28eafdd9c54b7c32c1392530f6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex cosine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se producen errores, se devuelve el coseno complejo de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0170daad51b40b50ab797fcf5f22cc95ede3feb" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex natural logarithm of &lt;code&gt;z&lt;/code&gt; is returned, in the range of a strip in the interval [&amp;minus;i&amp;pi;, +i&amp;pi;] along the imaginary axis and mathematically unbounded along the real axis.</source>
          <target state="translated">Si no se producen errores, se devuelve el logaritmo natural complejo de &lt;code&gt;z&lt;/code&gt; , en el rango de una tira en el intervalo [&amp;minus;i&amp;pi;, + i&amp;pi;] a lo largo del eje imaginario y matem&amp;aacute;ticamente ilimitado a lo largo del eje real.</target>
        </trans-unit>
        <trans-unit id="e80a11cce80b4f8332e379e29bcd184e31b6ff47" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex power xy</source>
          <target state="translated">Si no se producen errores,el complejo poder xy</target>
        </trans-unit>
        <trans-unit id="c05f2e2cc1ed459bdf96a06ef8dbc33e20915e79" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex sine of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se producen errores, se devuelve el seno complejo de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f171b9589d9359bfb44bdfa881b4ee93ea77d0c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the complex tangent of &lt;code&gt;z&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se producen errores, se devuelve la tangente compleja de &lt;code&gt;z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35bd7abdcb7f0220128fd880299baf801952dc19" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cosine of &lt;code&gt;arg&lt;/code&gt; (cos(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">Si no se producen errores, el coseno de &lt;code&gt;arg&lt;/code&gt; (cos (arg)) en el rango [-1; +1], se devuelve.</target>
        </trans-unit>
        <trans-unit id="ff16f514ad4d462d31d6524ed4ea84f4f6bcb390" translate="yes" xml:space="preserve">
          <source>If no errors occur, the cubic root of &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg), is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve la ra&amp;iacute;z c&amp;uacute;bica de &lt;code&gt;arg&lt;/code&gt; (3&amp;radic;arg).</target>
        </trans-unit>
        <trans-unit id="1e33cd84b874596d38519b6f05a2e60c9accef6b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the floating point value with the magnitude of &lt;code&gt;x&lt;/code&gt; and the sign of &lt;code&gt;y&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se producen errores, se devuelve el valor de coma flotante con la magnitud de &lt;code&gt;x&lt;/code&gt; y el signo de &lt;code&gt;y&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29635dc5075be505f22d8b338419ce3b116238e5" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh(arg), or</source>
          <target state="translated">Si no se producen errores, el coseno hiperb&amp;oacute;lico de &lt;code&gt;arg&lt;/code&gt; (cosh (arg), o</target>
        </trans-unit>
        <trans-unit id="084419061d5d22eb194084f72eb3bc99faee2d80" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh(arg), or</source>
          <target state="translated">Si no se producen errores, el seno hiperb&amp;oacute;lico de &lt;code&gt;arg&lt;/code&gt; (sinh (arg), o</target>
        </trans-unit>
        <trans-unit id="fde1a5cab1da9385208df6463481d983b8d198b8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh(arg), or</source>
          <target state="translated">Si no se producen errores, la tangente hiperb&amp;oacute;lica de &lt;code&gt;arg&lt;/code&gt; (tanh (arg) o</target>
        </trans-unit>
        <trans-unit id="3870fee396c73bbc1aab8cee4f9a85c1179be025" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic cosine of &lt;code&gt;arg&lt;/code&gt; (cosh-1</source>
          <target state="translated">Si no se producen errores, el coseno hiperb&amp;oacute;lico inverso de &lt;code&gt;arg&lt;/code&gt; (cosh-1</target>
        </trans-unit>
        <trans-unit id="c5db26fbae61f4e34cf5287ffaa5a9d47e53259d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic sine of &lt;code&gt;arg&lt;/code&gt; (sinh-1</source>
          <target state="translated">Si no se producen errores, el seno hiperb&amp;oacute;lico inverso de &lt;code&gt;arg&lt;/code&gt; (sinh-1</target>
        </trans-unit>
        <trans-unit id="f93099d7063e1d7a83038ac66c3c5233ba5f6ece" translate="yes" xml:space="preserve">
          <source>If no errors occur, the inverse hyperbolic tangent of &lt;code&gt;arg&lt;/code&gt; (tanh-1</source>
          <target state="translated">Si no se producen errores, la tangente hiperb&amp;oacute;lica inversa de &lt;code&gt;arg&lt;/code&gt; (tanh-1</target>
        </trans-unit>
        <trans-unit id="d4744dace8417a9d2afa9a3795c780e70495855c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the largest integer value not greater than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lfloor;arg&amp;rfloor;, is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve el valor entero m&amp;aacute;s grande que no sea mayor que &lt;code&gt;arg&lt;/code&gt; , que es &amp;lfloor;arg&amp;rfloor;.</target>
        </trans-unit>
        <trans-unit id="3007ffc0d3f619ed4878713babc6bf385e75ed5b" translate="yes" xml:space="preserve">
          <source>If no errors occur, the natural (base-</source>
          <target state="translated">Si no se producen errores,la base natural...</target>
        </trans-unit>
        <trans-unit id="c09a1dd12c5becd1a78d62ef2eba3711b8030fb7" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value not greater in magnitude than &lt;code&gt;arg&lt;/code&gt; (in other words, &lt;code&gt;arg&lt;/code&gt; rounded towards zero) is returned.</source>
          <target state="translated">Si no se producen errores, se devuelve el valor entero m&amp;aacute;s cercano que no tenga una magnitud mayor que &lt;code&gt;arg&lt;/code&gt; (en otras palabras, &lt;code&gt;arg&lt;/code&gt; redondeado hacia cero).</target>
        </trans-unit>
        <trans-unit id="f769b27b09219929833064428bef0734a24648aa" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, according to the &lt;a href=&quot;../fenv/fe_round&quot;&gt;current rounding mode&lt;/a&gt;, is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve el valor entero m&amp;aacute;s cercano a &lt;code&gt;arg&lt;/code&gt; , de acuerdo con el &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo actual&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a0256d4c5a80036d6bc9fdb716345ed55c66ea11" translate="yes" xml:space="preserve">
          <source>If no errors occur, the nearest integer value to &lt;code&gt;arg&lt;/code&gt;, rounding halfway cases away from zero, is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve el valor entero m&amp;aacute;s cercano a &lt;code&gt;arg&lt;/code&gt; , redondeando los casos a mitad de camino desde cero.</target>
        </trans-unit>
        <trans-unit id="2dcc36013b109d5eaf27751a51321acffdd6a03d" translate="yes" xml:space="preserve">
          <source>If no errors occur, the next representable value of &lt;code&gt;from&lt;/code&gt; in the direction of &lt;code&gt;to&lt;/code&gt;. is returned. If &lt;code&gt;from&lt;/code&gt; equals &lt;code&gt;to&lt;/code&gt;, then &lt;code&gt;to&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se producen errores, el siguiente valor representable de &lt;code&gt;from&lt;/code&gt; en la direcci&amp;oacute;n de &lt;code&gt;to&lt;/code&gt; . es regresado. Si &lt;code&gt;from&lt;/code&gt; igual a igual &lt;code&gt;to&lt;/code&gt; , entonces &lt;code&gt;to&lt;/code&gt; se devuelve.</target>
        </trans-unit>
        <trans-unit id="d0a7b391baa86594c7d0448266a28acb2668a4e8" translate="yes" xml:space="preserve">
          <source>If no errors occur, the sine of &lt;code&gt;arg&lt;/code&gt; (sin(arg)) in the range [-1 ; +1], is returned.</source>
          <target state="translated">Si no se producen errores, el seno de &lt;code&gt;arg&lt;/code&gt; (sin (arg)) en el rango [-1; +1], se devuelve.</target>
        </trans-unit>
        <trans-unit id="3fa7223cf61583336068c9d91991b4f9bedf8c7c" translate="yes" xml:space="preserve">
          <source>If no errors occur, the smallest integer value not less than &lt;code&gt;arg&lt;/code&gt;, that is &amp;lceil;arg&amp;rceil;, is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve el valor entero m&amp;aacute;s peque&amp;ntilde;o, no menor que &lt;code&gt;arg&lt;/code&gt; , es decir, &quot; arg&quot; .</target>
        </trans-unit>
        <trans-unit id="941693082c1c679c39e6797e593c1a748bca9744" translate="yes" xml:space="preserve">
          <source>If no errors occur, the tangent of &lt;code&gt;arg&lt;/code&gt; (tan(arg)) is returned.</source>
          <target state="translated">Si no se producen errores, se devuelve la tangente de &lt;code&gt;arg&lt;/code&gt; (tan (arg)).</target>
        </trans-unit>
        <trans-unit id="8e15bc85bb52009c88f5c69e56b9a2471d950454" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed floating-point value.</source>
          <target state="translated">Si no se producen errores, el exponente imparcial de &lt;code&gt;arg&lt;/code&gt; se devuelve como un valor de coma flotante con signo.</target>
        </trans-unit>
        <trans-unit id="026d1df8b0b132c32fe387fe762cb8d1ea884358" translate="yes" xml:space="preserve">
          <source>If no errors occur, the unbiased exponent of &lt;code&gt;arg&lt;/code&gt; is returned as a signed int value.</source>
          <target state="translated">Si no se producen errores, el exponente imparcial de &lt;code&gt;arg&lt;/code&gt; se devuelve como un valor int con signo.</target>
        </trans-unit>
        <trans-unit id="52dc1f3518fb2bced2d18acc2522443fc278caf6" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is \(\mathsf{\Gamma}(arg) = \int_0^\infty t^{arg-1} e^{-t} \mathsf{d}t\)&amp;int;&amp;infin;</source>
          <target state="translated">Si no se producen errores, el valor de la funci&amp;oacute;n gamma de &lt;code&gt;arg&lt;/code&gt; , es decir \ (\ mathsf {\ Gamma} (arg) = \ int_0 ^ \ infty t ^ {arg-1} e ^ {- t} \ mathsf {d } t \) &amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="17f4ff9a3637589c23bfc0b873e96c8630ea5296" translate="yes" xml:space="preserve">
          <source>If no errors occur, the value of the logarithm of the gamma function of &lt;code&gt;arg&lt;/code&gt;, that is log</source>
          <target state="translated">Si no se producen errores, el valor del logaritmo de la funci&amp;oacute;n gamma de &lt;code&gt;arg&lt;/code&gt; , que es log</target>
        </trans-unit>
        <trans-unit id="753b72c485945c6afd5db2fbcdff840651420e76" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the Riemann zeta function of &lt;code&gt;arg&lt;/code&gt;, &amp;zeta;(arg), defined for the entire real axis:</source>
          <target state="translated">Si no se producen errores, valor de la funci&amp;oacute;n zeta de Riemann de &lt;code&gt;arg&lt;/code&gt; , &amp;zeta; (arg), definido para todo el eje real:</target>
        </trans-unit>
        <trans-unit id="6801efcde3e466144a59b2e13c721de60eb9a8db" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \((-1)^m \: \frac{ \mathsf{d} ^ m}{ \mathsf{d}x ^ m} \, \mathsf{L}_{n+m}(x)\)(-1)m</source>
          <target state="translated">Si no se producen errores, el valor del polinomio de Laguerre asociado de &lt;code&gt;x&lt;/code&gt; , es decir \ ((- 1) ^ m \: \ frac {\ mathsf {d} ^ m} {\ mathsf {d} x ^ m} \, \ mathsf {L} _ {n + m} (x) \) (- 1) m</target>
        </trans-unit>
        <trans-unit id="b70f9e16b11c8009277ec11b877f36771c9cba33" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the associated Legendre polynomial \(\mathsf{P}_n^m\)Pm</source>
          <target state="translated">Si no hay errores,el valor del polinomio asociado de Legendre \ ~-Pm</target>
        </trans-unit>
        <trans-unit id="238d4638a6406e5670a8756021c43a9a89528ae6" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the beta function of &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;, that is &amp;int;1</source>
          <target state="translated">Si no se producen errores, el valor de la funci&amp;oacute;n beta de &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;y&lt;/code&gt; , es &amp;int;1</target>
        </trans-unit>
        <trans-unit id="7f29a8300bf4d8be194d411485092bca1cff89a5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complementary error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">Si no se producen errores, valor de la funci&amp;oacute;n de error complementaria de &lt;code&gt;arg&lt;/code&gt; , es decir</target>
        </trans-unit>
        <trans-unit id="df9c117eae172dac4ec6d5b52cce8a077d21f8a8" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_1(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve el valor de la integral el&amp;iacute;ptica completa del primer tipo de &lt;code&gt;k&lt;/code&gt; , es decir, &lt;code&gt;ellint_1(k,&amp;pi;/2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cbeea440564c0733c80ec0f91528453bf57997d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt;, that is &lt;code&gt;ellint_2(k,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve el valor de la integral el&amp;iacute;ptica completa del segundo tipo de &lt;code&gt;k&lt;/code&gt; , es decir, &lt;code&gt;ellint_2(k,&amp;pi;/2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66c1ee451279e40e8fca9ad9ed4b42f5978e872c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the complete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;nu;&lt;/code&gt;, that is &lt;code&gt;std::ellint_3(k,&amp;nu;,&amp;pi;/2)&lt;/code&gt;, is returned.</source>
          <target state="translated">Si no se producen errores , se devuelve el valor de la integral el&amp;iacute;ptica completa del tercer tipo de &lt;code&gt;k&lt;/code&gt; y &lt;code&gt;&amp;nu;&lt;/code&gt; , es decir &lt;code&gt;std::ellint_3(k,&amp;nu;,&amp;pi;/2)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a66e2b26fcc8bbc9cd86fdf7747135c750049f9c" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Bessel function of the first kind of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is J</source>
          <target state="translated">Si no se producen errores, el valor de la funci&amp;oacute;n cil&amp;iacute;ndrica de Bessel del primer tipo de &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; , es J</target>
        </trans-unit>
        <trans-unit id="543182535183bd8bc0773d95ac751d4302a6fe06" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the cylindrical Neumann function (Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is N</source>
          <target state="translated">Si no se producen errores , se devuelve el valor de la funci&amp;oacute;n cil&amp;iacute;ndrica de Neumann (funci&amp;oacute;n de Bessel del segundo tipo) de &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; , que es N</target>
        </trans-unit>
        <trans-unit id="0658bf24f8b1dde223e35183fc409335d58b1a45" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the error function of &lt;code&gt;arg&lt;/code&gt;, that is</source>
          <target state="translated">Si no se producen errores, valor de la funci&amp;oacute;n de error de &lt;code&gt;arg&lt;/code&gt; , es decir</target>
        </trans-unit>
        <trans-unit id="9df1996268d06781fa476369becefdaadd629195" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the exponential integral of &lt;code&gt;arg&lt;/code&gt;, that is -&amp;int;&amp;infin;</source>
          <target state="translated">Si no se producen errores, valor de la integral exponencial de &lt;code&gt;arg&lt;/code&gt; , que es -&amp;int;&amp;infin;</target>
        </trans-unit>
        <trans-unit id="12d4162f2889063b6a7da39429e27d5af98a2241" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the first kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">Si no se producen errores, valor de la integral el&amp;iacute;ptica incompleta del primer tipo de &lt;code&gt;k&lt;/code&gt; y &lt;code&gt;&amp;phi;&lt;/code&gt; , es decir &amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="f2687108220b1e44fef928c06fa5038f1e9ca385" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the second kind of &lt;code&gt;k&lt;/code&gt; and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">Si no se producen errores, valor de la integral el&amp;iacute;ptica incompleta del segundo tipo de &lt;code&gt;k&lt;/code&gt; y &lt;code&gt;&amp;phi;&lt;/code&gt; , es decir &amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="7ebd0beae76ba7f9e7e5a8530d1366439fe50ddc" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the incomplete elliptic integral of the third kind of &lt;code&gt;k&lt;/code&gt;, &lt;code&gt;&amp;nu;&lt;/code&gt;, and &lt;code&gt;&amp;phi;&lt;/code&gt;, that is &amp;int;&amp;phi;</source>
          <target state="translated">Si no se producen errores, valor de la integral el&amp;iacute;ptica incompleta del tercer tipo de &lt;code&gt;k&lt;/code&gt; , &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;&amp;phi;&lt;/code&gt; , es decir, &amp;int;&amp;phi;</target>
        </trans-unit>
        <trans-unit id="47bf302c79b395741bf53556a6be82fa3fd028e9" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the irregular modified cylindrical Bessel function (modified Bessel function of the second kind) of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, is returned, that is K</source>
          <target state="translated">Si no se producen errores , se devuelve el valor de la funci&amp;oacute;n Bessel cil&amp;iacute;ndrica modificada irregular (funci&amp;oacute;n Bessel modificada del segundo tipo) de &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; , es decir K</target>
        </trans-unit>
        <trans-unit id="aea1c8d887f4647bdb33eced1d1223c98eae241d" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the nonassociated Laguerre polynomial of &lt;code&gt;x&lt;/code&gt;, that is</source>
          <target state="translated">Si no se producen errores, el valor del polinomio de Laguerre no asociado de &lt;code&gt;x&lt;/code&gt; , es decir</target>
        </trans-unit>
        <trans-unit id="6f5b17abebff553421278dbae1b01fcc098edc8f" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt; unassociated Legendre polynomial of &lt;code&gt;x&lt;/code&gt;, that is \(\mathsf{P}_n(x) = \frac{1}{2^n n!} \frac{\mathsf{d}^n}{\mathsf{d}x^n} (x^2-1)^n \)</source>
          <target state="translated">Si no se producen errores, el valor del orden &lt;code&gt;n&lt;/code&gt; polinomio Legendre no asociado de &lt;code&gt;x&lt;/code&gt; , es decir \ (\ mathsf {P} _n (x) = \ frac {1} {2 ^ nn!} \ Frac {\ mathsf {d} ^ n} {\ mathsf {d} x ^ n} (x ^ 2-1) ^ n \)</target>
        </trans-unit>
        <trans-unit id="5fe63011566ab90404ecbc2fc30a86fbf404e9b5" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the order-&lt;code&gt;n&lt;/code&gt;Hermite polynomial of &lt;code&gt;x&lt;/code&gt;, that is (-1)n</source>
          <target state="translated">Si no se producen errores, valor del orden &lt;code&gt;n&lt;/code&gt; polinomio de Hermite de &lt;code&gt;x&lt;/code&gt; , es decir (-1) n</target>
        </trans-unit>
        <trans-unit id="521caff23698b2c47666d0e91701aa665925f3de" translate="yes" xml:space="preserve">
          <source>If no errors occur, value of the regular modified cylindrical Bessel function of &lt;code&gt;&amp;nu;&lt;/code&gt; and &lt;code&gt;x&lt;/code&gt;, that is I</source>
          <target state="translated">Si no se producen errores, el valor de la funci&amp;oacute;n Bessel cil&amp;iacute;ndrica modificada regular de &lt;code&gt;&amp;nu;&lt;/code&gt; y &lt;code&gt;x&lt;/code&gt; , es decir I</target>
        </trans-unit>
        <trans-unit id="031ce73d89df4a56cec229b26ace78aed68d756e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown during input, sets the number of extracted characters (gcount) in the input stream.</source>
          <target state="translated">Si no se lanzó ninguna excepción durante la entrada,establece el número de caracteres extraídos (gcount)en el flujo de entrada.</target>
        </trans-unit>
        <trans-unit id="4c799e4f486ea142e7186bf650ea8a5b122a9d32" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns &lt;code&gt;*this&lt;/code&gt;.</source>
          <target state="translated">Si no se produjo ninguna excepci&amp;oacute;n, devuelve &lt;code&gt;*this&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d67368bbb57de9e88e241a4a9a8276ff5bf9165e" translate="yes" xml:space="preserve">
          <source>If no exception was thrown, returns the value specified by the function.</source>
          <target state="translated">Si no se lanzó ninguna excepción,devuelve el valor especificado por la función.</target>
        </trans-unit>
        <trans-unit id="1f75f70449c5d517f16e8db38a32eb7a472a99d1" translate="yes" xml:space="preserve">
          <source>If no initializer is provided, the rules of &lt;a href=&quot;default_initialization&quot;&gt;default initialization&lt;/a&gt; apply.</source>
          <target state="translated">Si no se proporciona ning&amp;uacute;n inicializador, se aplican las reglas de &lt;a href=&quot;default_initialization&quot;&gt;inicializaci&amp;oacute;n predeterminadas&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="51774f7adc99f180db60612981a5526941d80108" translate="yes" xml:space="preserve">
          <source>If no matches are found after all catch-clauses were examined, the exception propagation continues to the containing try-block, as described in &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;. If there are no containing try-blocks left, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is executed (in this case, it is implementation-defined whether any stack unwinding occurs at all: throwing an uncaught exception is permitted to terminate the program without invoking any destructors).</source>
          <target state="translated">Si no se encuentran coincidencias despu&amp;eacute;s de examinar todas las cl&amp;aacute;usulas catch, la propagaci&amp;oacute;n de excepci&amp;oacute;n contin&amp;uacute;a al bloque try que contiene, como se describe en &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt; . Si no quedan bloques de prueba que contengan, se ejecuta &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; (en este caso, se define la implementaci&amp;oacute;n si se produce alg&amp;uacute;n desbobinado de la pila: se permite lanzar una excepci&amp;oacute;n no capturada para terminar el programa sin invocar ning&amp;uacute;n destructor).</target>
        </trans-unit>
        <trans-unit id="85ed69b90bb670ce03358daa2e3280ab8a0acaef" translate="yes" xml:space="preserve">
          <source>If no memory could be allocated, or allocated storage is not enough to store a single element of type &lt;code&gt;T&lt;/code&gt;, the &lt;code&gt;first&lt;/code&gt; element of the result is a null pointer and the &lt;code&gt;second&lt;/code&gt; element is zero.</source>
          <target state="translated">Si no se pudo asignar memoria, o el almacenamiento asignado no es suficiente para almacenar un solo elemento de tipo &lt;code&gt;T&lt;/code&gt; , el &lt;code&gt;first&lt;/code&gt; elemento del resultado es un puntero nulo y el &lt;code&gt;second&lt;/code&gt; elemento es cero.</target>
        </trans-unit>
        <trans-unit id="9d359f89a70fe560ca132223fbd242fa45ae36ac" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt; or &lt;code&gt;last2&lt;/code&gt;, whichever happens first, the pair holds the end iterator and the corresponding iterator from the other range.</source>
          <target state="translated">Si no se encuentran desajustes cuando la comparaci&amp;oacute;n alcanza &lt;code&gt;last1&lt;/code&gt; o &lt;code&gt;last2&lt;/code&gt; , lo que ocurra primero, el par contiene el iterador final y el iterador correspondiente del otro rango.</target>
        </trans-unit>
        <trans-unit id="5a80ff055cfd93f4382626d501c63e2d0233080f" translate="yes" xml:space="preserve">
          <source>If no mismatches are found when the comparison reaches &lt;code&gt;last1&lt;/code&gt;, the pair holds &lt;code&gt;last1&lt;/code&gt; and the corresponding iterator from the second range. The behavior is undefined if the second range is shorter than the first range.</source>
          <target state="translated">Si no se encuentran desajustes cuando la comparaci&amp;oacute;n alcanza &lt;code&gt;last1&lt;/code&gt; , el par contiene &lt;code&gt;last1&lt;/code&gt; y el iterador correspondiente del segundo rango. El comportamiento no est&amp;aacute; definido si el segundo rango es m&amp;aacute;s corto que el primero.</target>
        </trans-unit>
        <trans-unit id="781fedf1bc7025a615d3c4ed7f1b4d2a7b74af04" translate="yes" xml:space="preserve">
          <source>If no preferred functions are found, the non-preferred ones are considered in the next step.</source>
          <target state="translated">Si no se encuentran funciones preferidas,las no preferidas se consideran en el siguiente paso.</target>
        </trans-unit>
        <trans-unit id="212c7248247dc34425f2118c2a6054de49eb5fd9" translate="yes" xml:space="preserve">
          <source>If no such character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and the future calls to &lt;code&gt;strtok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">Si no se encuentra dicho car&amp;aacute;cter, &lt;code&gt;str&lt;/code&gt; solo tiene un token, y las futuras llamadas a &lt;code&gt;strtok&lt;/code&gt; devolver&amp;aacute;n un puntero nulo</target>
        </trans-unit>
        <trans-unit id="e0e3f85b21f0603ccfad7c7630e2e6165f6efad1" translate="yes" xml:space="preserve">
          <source>If no such character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">Si no se encuentra dicho car&amp;aacute;cter, no hay tokens en &lt;code&gt;str&lt;/code&gt; , y la funci&amp;oacute;n devuelve un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="32d0b18e53a062a7ffa1ce497fbf816f66e2daa5" translate="yes" xml:space="preserve">
          <source>If no such elements are found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se encuentran tales elementos, se devuelve el &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ef5b0f78fdffa741da1e2a6130af0d51d257860" translate="yes" xml:space="preserve">
          <source>If no such sequence is found, &lt;code&gt;last&lt;/code&gt; is returned.</source>
          <target state="translated">Si no se encuentra dicha secuencia, se devuelve el &lt;code&gt;last&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95318ca2ad225ff32e9ddd27aadd58f11c7c9bf8" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, &lt;code&gt;str&lt;/code&gt; has only one token, and future calls to &lt;code&gt;std::wcstok&lt;/code&gt; will return a null pointer</source>
          <target state="translated">Si no se encuentra ese car&amp;aacute;cter ancho, &lt;code&gt;str&lt;/code&gt; solo tiene un token y las futuras llamadas a &lt;code&gt;std::wcstok&lt;/code&gt; devolver&amp;aacute;n un puntero nulo</target>
        </trans-unit>
        <trans-unit id="d9fb4aef6036de9d69cd4d033e352d979c405074" translate="yes" xml:space="preserve">
          <source>If no such wide character was found, there are no tokens in &lt;code&gt;str&lt;/code&gt; at all, and the function returns a null pointer.</source>
          <target state="translated">Si no se encuentra dicho car&amp;aacute;cter ancho, no hay tokens en &lt;code&gt;str&lt;/code&gt; , y la funci&amp;oacute;n devuelve un puntero nulo.</target>
        </trans-unit>
        <trans-unit id="40ac478406fa04d277853c0748ded82cd0ccce6d" translate="yes" xml:space="preserve">
          <source>If no user-declared constructors of any kind are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a default constructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="translated">Si no se proporcionan constructores de ning&amp;uacute;n tipo declarados por el usuario para un tipo de clase ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; o &lt;code&gt;union&lt;/code&gt; ), el compilador siempre declarar&amp;aacute; un constructor predeterminado como un miembro &lt;code&gt;inline public&lt;/code&gt; de su clase.</target>
        </trans-unit>
        <trans-unit id="7ad4343e0140e81303cc7ccdcdc20abcd1b3af02" translate="yes" xml:space="preserve">
          <source>If no user-declared destructor is provided for a &lt;a href=&quot;class&quot;&gt;class type&lt;/a&gt; (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a destructor as an &lt;code&gt;inline public&lt;/code&gt; member of its class.</source>
          <target state="translated">Si no se proporciona un destructor declarado por el usuario para un &lt;a href=&quot;class&quot;&gt;tipo de clase&lt;/a&gt; ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; o &lt;code&gt;union&lt;/code&gt; ), el compilador siempre declarar&amp;aacute; un destructor como un miembro &lt;code&gt;inline public&lt;/code&gt; de su clase.</target>
        </trans-unit>
        <trans-unit id="bb4a43dac5ef9eabbbba755dc09ed6605a9c36f6" translate="yes" xml:space="preserve">
          <source>If no user-defined constructors are present and the implicitly-declared default constructor is not trivial, the user may still inhibit the automatic generation of an implicitly-defined default constructor by the compiler with the keyword &lt;code&gt;delete&lt;/code&gt;.</source>
          <target state="translated">Si no hay constructores definidos por el usuario y el constructor predeterminado declarado impl&amp;iacute;citamente no es trivial, el usuario a&amp;uacute;n puede inhibir la generaci&amp;oacute;n autom&amp;aacute;tica de un constructor predeterminado definido impl&amp;iacute;citamente por el compilador con la palabra clave &lt;code&gt;delete&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94c428bc493bfd4bf3cb4c40be6d006d6ae9320b" translate="yes" xml:space="preserve">
          <source>If no user-defined copy assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare one as an inline public member of the class. This implicitly-declared copy assignment operator has the form &lt;code&gt;T&amp;amp; T::operator=(const T&amp;amp;)&lt;/code&gt; if all of the following is true:</source>
          <target state="translated">Si no se proporcionan operadores de asignaci&amp;oacute;n de copia definidos por el usuario para un tipo de clase ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; o &lt;code&gt;union&lt;/code&gt; ), el compilador siempre declarar&amp;aacute; uno como miembro p&amp;uacute;blico en l&amp;iacute;nea de la clase. Este operador de asignaci&amp;oacute;n de copia declarado impl&amp;iacute;citamente tiene la forma &lt;code&gt;T&amp;amp; T::operator=(const T&amp;amp;)&lt;/code&gt; si se cumple todo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="851c19dced47a32ee3f0fdfb9f639786302ce9fb" translate="yes" xml:space="preserve">
          <source>If no user-defined copy constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), the compiler will always declare a copy constructor as a non-&lt;a href=&quot;explicit&quot;&gt;explicit&lt;/a&gt;&lt;code&gt;inline public&lt;/code&gt; member of its class. This implicitly-declared copy constructor has the form &lt;code&gt;T::T(const T&amp;amp;)&lt;/code&gt; if all of the following are true:</source>
          <target state="translated">Si no se proporcionan constructores de copia definidos por el usuario para un tipo de clase ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; o &lt;code&gt;union&lt;/code&gt; ), el compilador siempre declarar&amp;aacute; un constructor de copia como un miembro &lt;code&gt;inline public&lt;/code&gt; no &lt;a href=&quot;explicit&quot;&gt;expl&amp;iacute;cito&lt;/a&gt; de su clase. Este constructor de copia impl&amp;iacute;citamente declarado tiene la forma &lt;code&gt;T::T(const T&amp;amp;)&lt;/code&gt; si se cumple todo lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b4fd8cb3d9cb59c45a27ed26df217a6fe2527317" translate="yes" xml:space="preserve">
          <source>If no user-defined move assignment operators are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="translated">Si no se proporcionan operadores de asignaci&amp;oacute;n de movimiento definidos por el usuario para un tipo de clase ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; o &lt;code&gt;union&lt;/code&gt; ), y todo lo siguiente es cierto:</target>
        </trans-unit>
        <trans-unit id="d13ec6ee9e77a6e3545912f76a282bde870c425b" translate="yes" xml:space="preserve">
          <source>If no user-defined move constructors are provided for a class type (&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;class&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt;), and all of the following is true:</source>
          <target state="translated">Si no se proporcionan constructores de movimiento definidos por el usuario para un tipo de clase ( &lt;code&gt;struct&lt;/code&gt; , &lt;code&gt;class&lt;/code&gt; o &lt;code&gt;union&lt;/code&gt; ), y todo lo siguiente es cierto:</target>
        </trans-unit>
        <trans-unit id="12fccd1db64bc403607d3dd62463e20e8242d5d4" translate="yes" xml:space="preserve">
          <source>If non-default allocators are intended to be supported for the allocation of the implementation object, any of the usual allocator awareness patterns may be utilized, including allocator template parameter defaulting to &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; and constructor argument of type &lt;a href=&quot;../memory/memory_resource&quot;&gt;&lt;code&gt;std::pmr::memory_resource*&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si se pretende que los asignadores no predeterminados sean compatibles con la asignaci&amp;oacute;n del objeto de implementaci&amp;oacute;n, se puede utilizar cualquiera de los patrones habituales de reconocimiento del asignador, incluido el par&amp;aacute;metro de la plantilla del asignador predeterminado en &lt;code&gt;&lt;a href=&quot;../memory/allocator&quot;&gt;std::allocator&lt;/a&gt;&lt;/code&gt; y el argumento del constructor de tipo &lt;a href=&quot;../memory/memory_resource&quot;&gt; &lt;code&gt;std::pmr::memory_resource*&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9e7a52425c4552c258484ec30442892b69acfcad" translate="yes" xml:space="preserve">
          <source>If not empty, destroys the contained object.</source>
          <target state="translated">Si no está vacío,destruye el objeto contenido.</target>
        </trans-unit>
        <trans-unit id="46f7a7c5951af943707abba8135020cebc9f7870" translate="yes" xml:space="preserve">
          <source>If object is a non-bit-field rvalue or a function lvalue, and its type is either &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, equally or less cv-qualified, then the reference is bound to the value of the initializer expression or to its base subobject (after &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializing a temporary&lt;/a&gt; if necessary)(since C++17).</source>
          <target state="translated">Si el objeto es un valor de campo que no es de campo de bits o un valor de funci&amp;oacute;n, y su tipo es &lt;code&gt;T&lt;/code&gt; o derivado de &lt;code&gt;T&lt;/code&gt; , igual o menos calificado por cv, entonces la referencia est&amp;aacute; vinculada al valor de la expresi&amp;oacute;n inicializadora o a su subobjeto base (despu&amp;eacute;s de &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializar un temporal&lt;/a&gt; si es necesario) (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="a3d00b46e93a04f762ceacf129a7d8e708f9cdae" translate="yes" xml:space="preserve">
          <source>If object is an lvalue expression, and its type is &lt;code&gt;T&lt;/code&gt; or derived from &lt;code&gt;T&lt;/code&gt;, and is equally or less cv-qualified, then the reference is bound to the object identified by the lvalue or to its base class subobject.</source>
          <target state="translated">Si el objeto es una expresi&amp;oacute;n de valor de &lt;code&gt;T&lt;/code&gt; , y su tipo es T o derivado de &lt;code&gt;T&lt;/code&gt; , y tiene igual o menos calificaci&amp;oacute;n cv, entonces la referencia est&amp;aacute; vinculada al objeto identificado por el valor de l o su subobjeto de clase base.</target>
        </trans-unit>
        <trans-unit id="aa22f5451003f7660daffd02d5df19ccf7abfc20" translate="yes" xml:space="preserve">
          <source>If one evaluation modifies a memory location, and the other reads or modifies the same memory location, and if at least one of the evaluations is not an atomic operation, the behavior of the program is undefined (the program has a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) unless there exists a</source>
          <target state="translated">Si una evaluaci&amp;oacute;n modifica una ubicaci&amp;oacute;n de memoria, y la otra lee o modifica la misma ubicaci&amp;oacute;n de memoria, y si al menos una de las evaluaciones no es una operaci&amp;oacute;n at&amp;oacute;mica, el comportamiento del programa es indefinido (el programa tiene una &lt;a href=&quot;../language/memory_model&quot;&gt;carrera de datos&lt;/a&gt; ) a menos que haya existe un</target>
        </trans-unit>
        <trans-unit id="e3ee4df0d28305af8190dfed503a69842ecdea1b" translate="yes" xml:space="preserve">
          <source>If one of the operands is of type &lt;code&gt;bool&lt;/code&gt; and the other is not, the program is ill-formed.</source>
          <target state="translated">Si uno de los operandos es de tipo &lt;code&gt;bool&lt;/code&gt; y el otro no, el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="2677ad2fee54206928d1289296944052d7155f2a" translate="yes" xml:space="preserve">
          <source>If one of the strings has an encoding prefix and the other doesn't, the one that doesn't will be considered to have the same encoding prefix as the other.</source>
          <target state="translated">Si una de las cadenas tiene un prefijo de codificación y la otra no,se considerará que la que no lo tiene tiene el mismo prefijo de codificación que la otra.</target>
        </trans-unit>
        <trans-unit id="5394cec101ec494404d07198530eec4ab37c59ad" translate="yes" xml:space="preserve">
          <source>If one of the two arguments is NaN, the value of the other argument is returned</source>
          <target state="translated">Si uno de los dos argumentos es NaN,se devuelve el valor del otro argumento</target>
        </trans-unit>
        <trans-unit id="41700bbfc9368c2b5358e57134ccfd94d1f553f5" translate="yes" xml:space="preserve">
          <source>If one range is a prefix of another, the shorter range is lexicographically</source>
          <target state="translated">Si un rango es un prefijo de otro,el rango más corto es lexicográficamente</target>
        </trans-unit>
        <trans-unit id="dcc36215317b874404f96885cfc95439d29a3922" translate="yes" xml:space="preserve">
          <source>If only one function is left, that function is selected.</source>
          <target state="translated">Si sólo queda una función,se selecciona esa función.</target>
        </trans-unit>
        <trans-unit id="58314a8e7e0dda6a0f7693f28a3be7368beb7517" translate="yes" xml:space="preserve">
          <source>If only one of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; contains a value (let's call this object &lt;code&gt;in&lt;/code&gt; and the other &lt;code&gt;un&lt;/code&gt;), the contained value of &lt;code&gt;un&lt;/code&gt; is &lt;a href=&quot;../../language/direct_initialization&quot;&gt;direct-initialized&lt;/a&gt; from &lt;code&gt;std::move(*in)&lt;/code&gt;, followed by destruction of the contained value of &lt;code&gt;in&lt;/code&gt; as if by &lt;code&gt;in-&amp;gt;T::~T()&lt;/code&gt;. After this call, &lt;code&gt;in&lt;/code&gt; does not contain a value; &lt;code&gt;un&lt;/code&gt; contains a value.</source>
          <target state="translated">Si solo uno de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; contiene un valor (llamemos a este objeto &lt;code&gt;in&lt;/code&gt; y el otro &lt;code&gt;un&lt;/code&gt; ), el valor contenido de &lt;code&gt;un&lt;/code&gt; se &lt;a href=&quot;../../language/direct_initialization&quot;&gt;inicializa directamente&lt;/a&gt; desde &lt;code&gt;std::move(*in)&lt;/code&gt; , seguido de la destrucci&amp;oacute;n del valor contenido de &lt;code&gt;in&lt;/code&gt; como si por &lt;code&gt;in-&amp;gt;T::~T()&lt;/code&gt; . Despu&amp;eacute;s de esta llamada, &lt;code&gt;in&lt;/code&gt; no contiene un valor; &lt;code&gt;un&lt;/code&gt; contiene un valor.</target>
        </trans-unit>
        <trans-unit id="38fac4f8f19905bafe2c9ea62d2092290cb1aaea" translate="yes" xml:space="preserve">
          <source>If only one of the two function templates being compared is a member function , and that function template is a non-static member of some class &lt;code&gt;A&lt;/code&gt;, a new first parameter is inserted into its parameter list, whose type is &lt;code&gt;cv A&amp;amp;&amp;amp;&lt;/code&gt; if the member function template is &amp;amp;&amp;amp;-qualified and &lt;code&gt;cv A&amp;amp;&lt;/code&gt; otherwise (cv is the cv-qualification of the member function template) -- this helps the ordering of operators, which are looked up both as member and as non-member functions:</source>
          <target state="translated">Si solo una de las dos plantillas de funci&amp;oacute;n que se compara es una funci&amp;oacute;n miembro, y esa plantilla de funci&amp;oacute;n es un miembro no est&amp;aacute;tico de alguna clase &lt;code&gt;A&lt;/code&gt; , se inserta un nuevo primer par&amp;aacute;metro en su lista de par&amp;aacute;metros, cuyo tipo es &lt;code&gt;cv A&amp;amp;&amp;amp;&lt;/code&gt; si la funci&amp;oacute;n miembro plantilla es &amp;amp;&amp;amp; - calificada y &lt;code&gt;cv A&amp;amp;&lt;/code&gt; contrario (cv es la calificaci&amp;oacute;n cv de la plantilla de funci&amp;oacute;n miembro) - esto ayuda a ordenar operadores, que se buscan como funciones miembro y no miembro:</target>
        </trans-unit>
        <trans-unit id="ec7712843cd5f938f1aba16750b9a0671c8585bc" translate="yes" xml:space="preserve">
          <source>If other is an rvalue expression, &lt;a href=&quot;move_constructor&quot;&gt;move constructor&lt;/a&gt; will be selected by overload resolution and called during copy-initialization. There is no such term as move-initialization.</source>
          <target state="translated">Si otro es una expresi&amp;oacute;n de valor, &lt;a href=&quot;move_constructor&quot;&gt;el constructor de movimiento&lt;/a&gt; se seleccionar&amp;aacute; por resoluci&amp;oacute;n de sobrecarga y se llamar&amp;aacute; durante la inicializaci&amp;oacute;n de la copia. No existe el t&amp;eacute;rmino movimiento-inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9ddc5ecaabd07bdd4041442caa75864db6c6d691" translate="yes" xml:space="preserve">
          <source>If overflow occurs, the behavior is undefined.</source>
          <target state="translated">Si se produce un desbordamiento,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="750847988fad756b2797b04ab539da8a7a039e9f" translate="yes" xml:space="preserve">
          <source>If overload resolution selects an inherited constructor, it is accessible if it would be accessible when used to construct an object of the corresponding base class: the accessibility of the using-declaration that introduced it is ignored.</source>
          <target state="translated">Si la resolución de sobrecarga selecciona un constructor heredado,es accesible si sería accesible cuando se utilizara para construir un objeto de la clase base correspondiente:se ignora la accesibilidad de la declaración de uso que lo introdujo.</target>
        </trans-unit>
        <trans-unit id="210ca7809f61451a624d2c6beec2bcb2c768f5c6" translate="yes" xml:space="preserve">
          <source>If overload resolution selects one of the inherited constructors when initializing an object of such derived class, then the &lt;code&gt;Base&lt;/code&gt; subobject from which the constructor was inherited is initialized using the inherited constructor, and all other bases and members of &lt;code&gt;Derived&lt;/code&gt; are initialized as if by the defaulted default constructor (default member initializers are used if provided, otherwise default initialization takes place). The entire initialization is treated as a single function call: initialization of the parameters of the inherited constructor is sequenced-before initialization of any base or member of the derived object.</source>
          <target state="translated">Si la resoluci&amp;oacute;n de sobrecarga selecciona uno de los constructores heredados al inicializar un objeto de dicha clase derivada, entonces el subobjeto &lt;code&gt;Base&lt;/code&gt; del que se hereda el constructor se inicializa utilizando el constructor heredado, y todas las dem&amp;aacute;s bases y miembros de &lt;code&gt;Derived&lt;/code&gt; se inicializan como si fueran predeterminados. constructor predeterminado (los inicializadores de miembro predeterminados se usan si se proporcionan, de lo contrario se lleva a cabo la inicializaci&amp;oacute;n predeterminada). La inicializaci&amp;oacute;n completa se trata como una llamada de funci&amp;oacute;n &amp;uacute;nica: la inicializaci&amp;oacute;n de los par&amp;aacute;metros del constructor heredado se secuencia antes de la inicializaci&amp;oacute;n de cualquier base o miembro del objeto derivado.</target>
        </trans-unit>
        <trans-unit id="569b041ed62609471e4536cb80335e9cadb562bd" translate="yes" xml:space="preserve">
          <source>If possible, constructs an object of type &lt;code&gt;T&lt;/code&gt; in allocated uninitialized storage pointed to by &lt;code&gt;p&lt;/code&gt;, by calling.</source>
          <target state="translated">Si es posible, construye un objeto de tipo &lt;code&gt;T&lt;/code&gt; en el almacenamiento no inicializado asignado al que apunta &lt;code&gt;p&lt;/code&gt; , mediante una llamada.</target>
        </trans-unit>
        <trans-unit id="7bd19a7c8b0277a43bb96d2aa204eaa9e1df26a8" translate="yes" xml:space="preserve">
          <source>If possible, obtains the copy-constructed version of the allocator &lt;code&gt;a&lt;/code&gt;, by calling &lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt;. If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;select_on_container_copy_construction()&lt;/code&gt;, then returns &lt;code&gt;a&lt;/code&gt;, unmodified.</source>
          <target state="translated">Si es posible, obtiene la versi&amp;oacute;n copiada del asignador &lt;code&gt;a&lt;/code&gt; , llamando a &lt;code&gt;a.select_on_container_copy_construction()&lt;/code&gt; . Si lo anterior no es posible (por ejemplo, &lt;code&gt;a&lt;/code&gt; no tiene la funci&amp;oacute;n miembro &lt;code&gt;select_on_container_copy_construction()&lt;/code&gt; , a continuaci&amp;oacute;n, devuelve &lt;code&gt;a&lt;/code&gt; , sin modificar.</target>
        </trans-unit>
        <trans-unit id="c2bb51f991f1f844a514dcdb161773a64461aa00" translate="yes" xml:space="preserve">
          <source>If possible, obtains the maximum theoretically possible allocation size from the allocator &lt;code&gt;a&lt;/code&gt;, by calling.</source>
          <target state="translated">Si es posible, obtiene el tama&amp;ntilde;o m&amp;aacute;ximo de asignaci&amp;oacute;n te&amp;oacute;ricamente posible del asignador &lt;code&gt;a&lt;/code&gt; , llamando.</target>
        </trans-unit>
        <trans-unit id="e98d09928ca05eb652c54751fcdfc483c6a1ba29" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;&lt;a href=&quot;hash_function&quot;&gt;hash_function()&lt;/a&gt;&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">Si est&amp;aacute; presente, el par&amp;aacute;metro &lt;code&gt;hash&lt;/code&gt; puede usarse para pasar un valor hash precalculado como una optimizaci&amp;oacute;n. El comportamiento no est&amp;aacute; definido si invocar &lt;code&gt;&lt;a href=&quot;hash_function&quot;&gt;hash_function()&lt;/a&gt;&lt;/code&gt; en la clave pasada no produce el mismo valor que &lt;code&gt;hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b615c53ecc545ad86db4eb50538fd76266abf064" translate="yes" xml:space="preserve">
          <source>If present, the &lt;code&gt;hash&lt;/code&gt; parameter may be used to pass a pre-computed hash value as an optimization. The behavior is undefined if invoking &lt;code&gt;hash_function()&lt;/code&gt; on the key passed do not produce the same value as &lt;code&gt;hash&lt;/code&gt;.</source>
          <target state="translated">Si est&amp;aacute; presente, el par&amp;aacute;metro &lt;code&gt;hash&lt;/code&gt; puede usarse para pasar un valor hash precalculado como una optimizaci&amp;oacute;n. El comportamiento no est&amp;aacute; definido si invocar &lt;code&gt;hash_function()&lt;/code&gt; en la clave pasada no produce el mismo valor que &lt;code&gt;hash&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0ad3998a5ac30264cf943a5c000f09e6f5af44e" translate="yes" xml:space="preserve">
          <source>If prior to the call &lt;code&gt;*this&lt;/code&gt; has an associated mutex and has acquired ownership of it, the mutex is unlocked.</source>
          <target state="translated">Si antes de la llamada &lt;code&gt;*this&lt;/code&gt; tiene un mutex asociado y ha adquirido la propiedad del mismo, el mutex se desbloquea.</target>
        </trans-unit>
        <trans-unit id="5bdd482f92ba03cbf032a677ef80f876bd9e89d4" translate="yes" xml:space="preserve">
          <source>If putback position was available, returns the character that the next pointer is now pointing at, converted to &lt;code&gt;int_type&lt;/code&gt; with &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;. The next single-character input from this streambuf will return this character.</source>
          <target state="translated">Si la posici&amp;oacute;n de devoluci&amp;oacute;n estaba disponible, devuelve el car&amp;aacute;cter al que apunta el siguiente puntero, convertido a &lt;code&gt;int_type&lt;/code&gt; con &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; . La siguiente entrada de un solo car&amp;aacute;cter de este streambuf devolver&amp;aacute; este car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="3eb692c025338041e4eed4f9319cfb04b675d552" translate="yes" xml:space="preserve">
          <source>If putback position was not available, returns what &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; returns, which is &lt;code&gt;Traits::eof()&lt;/code&gt; on failure.</source>
          <target state="translated">Si la posici&amp;oacute;n de devoluci&amp;oacute;n no estaba disponible, devuelve lo que devuelve &lt;code&gt;&lt;a href=&quot;pbackfail&quot;&gt;pbackfail()&lt;/a&gt;&lt;/code&gt; , que es &lt;code&gt;Traits::eof()&lt;/code&gt; en caso de error.</target>
        </trans-unit>
        <trans-unit id="fd77c426f218dbc4996392b11cbf4a9df041bd55" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of a class type &lt;code&gt;C&lt;/code&gt; that has both a member named &lt;code&gt;begin&lt;/code&gt; and a member named &lt;code&gt;end&lt;/code&gt; (regardless of the type or accessibility of such member), then</source>
          <target state="translated">Si range_expression es una expresi&amp;oacute;n de una clase tipo &lt;code&gt;C&lt;/code&gt; que tiene un miembro llamado &lt;code&gt;begin&lt;/code&gt; y un miembro llamado &lt;code&gt;end&lt;/code&gt; (independientemente del tipo o accesibilidad de dicho miembro), entonces</target>
        </trans-unit>
        <trans-unit id="a31a47abbcbe52c11cb5aabb738ee006961c36bf" translate="yes" xml:space="preserve">
          <source>If range_expression is an expression of array type, then</source>
          <target state="translated">Si range_expression es una expresión del tipo de la matriz,entonces</target>
        </trans-unit>
        <trans-unit id="8998880636aec0b41e1f3aa9bb5068fe2d087a45" translate="yes" xml:space="preserve">
          <source>If range_expression returns a temporary, its lifetime is extended until the end of the loop, as indicated by binding to the forwarding reference &lt;b&gt;&lt;code&gt;__range&lt;/code&gt;&lt;/b&gt;, but beware that the lifetime of any temporary within range_expression</source>
          <target state="translated">Si range_expression devuelve un temporal, su vida &amp;uacute;til se extiende hasta el final del bucle, como se indica mediante el enlace a la referencia de reenv&amp;iacute;o &lt;b&gt; &lt;code&gt;__range&lt;/code&gt; &lt;/b&gt; , pero tenga en cuenta que la vida &amp;uacute;til de cualquier temporal dentro de range_expression</target>
        </trans-unit>
        <trans-unit id="831b1dfec868a21157a075677fd82a9bf6d69aa8" translate="yes" xml:space="preserve">
          <source>If rdbuf() is a null pointer, does nothing.</source>
          <target state="translated">Si rdbuf()es un puntero nulo,no hace nada.</target>
        </trans-unit>
        <trans-unit id="1b1e7d795c25e0720f46207c35f854b7bc6a7349" translate="yes" xml:space="preserve">
          <source>If reallocation occurs, all iterators, including the past the end iterator, and all references to the elements are invalidated. If no reallocation takes place, no iterators or references are invalidated.</source>
          <target state="translated">Si se produce una reasignación,se invalidan todos los iteradores,incluido el pasado el iterador final,y todas las referencias a los elementos.Si no se produce ninguna reasignación,no se invalidan los iteradores ni las referencias.</target>
        </trans-unit>
        <trans-unit id="b5722a09effa0795d91444af4d2753abca8a7e18" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;.</source>
          <target state="translated">Si se produce un resplandor debido a la inserci&amp;oacute;n, se invalidan todos los iteradores. De lo contrario, los iteradores no se ven afectados. Las referencias no est&amp;aacute;n invalidadas. La repetici&amp;oacute;n se produce solo si el nuevo n&amp;uacute;mero de elementos es mayor que &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b48960c4455b015acecf76682b1d33d5044e8f1b" translate="yes" xml:space="preserve">
          <source>If rehashing occurs due to the insertion, all iterators are invalidated. Otherwise iterators are not affected. References are not invalidated. Rehashing occurs only if the new number of elements is greater than &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt;. If the insertion is successful, pointers and references to the element obtained while it is held in the node handle are invalidated, and pointers and references obtained to that element before it was extracted become valid.(since C++17).</source>
          <target state="translated">Si se produce un resplandor debido a la inserci&amp;oacute;n, se invalidan todos los iteradores. De lo contrario, los iteradores no se ven afectados. Las referencias no est&amp;aacute;n invalidadas. La repetici&amp;oacute;n se produce solo si el nuevo n&amp;uacute;mero de elementos es mayor que &lt;code&gt;max_load_factor()*bucket_count()&lt;/code&gt; . Si la inserci&amp;oacute;n es exitosa, los punteros y las referencias al elemento obtenido mientras se mantiene en el asa del nodo se invalidan, y los punteros y las referencias obtenidas a ese elemento antes de que se extraiga se vuelven v&amp;aacute;lidos (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="e5803322a669884d371a27e94b8e3347c4a1e0b8" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;P'&amp;gt;&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is a &lt;a href=&quot;list_initialization&quot;&gt;braced-init-list&lt;/a&gt;, then deduction is performed for every element of the initializer list, taking &lt;code&gt;P'&lt;/code&gt; as the parameter and the list element &lt;code&gt;A'&lt;/code&gt; as the argument:</source>
          <target state="translated">Si al eliminar referencias y calificadores cv de &lt;code&gt;P&lt;/code&gt; se obtiene &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;P'&amp;gt;&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; es una &lt;a href=&quot;list_initialization&quot;&gt;lista de inicializaci&amp;oacute;n arriostrada&lt;/a&gt; , se realiza una deducci&amp;oacute;n para cada elemento de la lista de inicializadores, tomando &lt;code&gt;P'&lt;/code&gt; como par&amp;aacute;metro y elemento de lista &lt;code&gt;A'&lt;/code&gt; como argumento:</target>
        </trans-unit>
        <trans-unit id="4023bf4d1f43d575e2d6327b1416c5ed7d9cb751" translate="yes" xml:space="preserve">
          <source>If removing references and cv-qualifiers from &lt;code&gt;P&lt;/code&gt; gives &lt;code&gt;P'&lt;/code&gt;[&lt;code&gt;N&lt;/code&gt;], and &lt;code&gt;A&lt;/code&gt; is a non-empty braced-init-list, then deduction is performed as above, except if &lt;code&gt;N&lt;/code&gt; is a non-type template parameter, it is deduced from the length of the initializer list:</source>
          <target state="translated">Si al eliminar referencias y calificadores cv de &lt;code&gt;P&lt;/code&gt; se obtiene &lt;code&gt;P'&lt;/code&gt; [ &lt;code&gt;N&lt;/code&gt; ], y &lt;code&gt;A&lt;/code&gt; es una lista de inicializaci&amp;oacute;n arriostrada no vac&amp;iacute;a, entonces la deducci&amp;oacute;n se realiza como anteriormente, excepto si &lt;code&gt;N&lt;/code&gt; es un par&amp;aacute;metro de plantilla sin tipo, se deduce de la longitud de la lista de inicializadores:</target>
        </trans-unit>
        <trans-unit id="3e746f9c695cdf56415555b25b2b13ebeeb30b4c" translate="yes" xml:space="preserve">
          <source>If searching for an empty string (&lt;code&gt;str.size()&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, or &lt;code&gt;Traits::length(s)&lt;/code&gt; is zero) returns &lt;code&gt;pos&lt;/code&gt; (the empty string is found immediately) unless &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; (including the case where &lt;code&gt;pos == npos&lt;/code&gt;), in which case returns &lt;code&gt;size()&lt;/code&gt;.</source>
          <target state="translated">Si busca una cadena vac&amp;iacute;a ( &lt;code&gt;str.size()&lt;/code&gt; , &lt;code&gt;count&lt;/code&gt; , o &lt;code&gt;Traits::length(s)&lt;/code&gt; es cero) devuelve &lt;code&gt;pos&lt;/code&gt; (la cadena vac&amp;iacute;a se encuentra inmediatamente) a menos que &lt;code&gt;pos &amp;gt; size()&lt;/code&gt; (incluido el caso donde &lt;code&gt;pos == npos&lt;/code&gt; ), en cuyo caso devuelve &lt;code&gt;size()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8032ef45e981f5ae9ab731c15293224cc1be4894" translate="yes" xml:space="preserve">
          <source>If side-effect A is visible with respect to the value computation B, then the longest contiguous subset of the side-effects to M, in</source>
          <target state="translated">Si el efecto secundario A es visible con respecto al cálculo del valor B,entonces el subconjunto contiguo más largo de los efectos secundarios a M,en</target>
        </trans-unit>
        <trans-unit id="a813fcc7c976b042560912c3cfabd51324dc8cdf" translate="yes" xml:space="preserve">
          <source>If some &lt;a href=&quot;value_category&quot;&gt;glvalue expression&lt;/a&gt; refers to a &lt;a href=&quot;objects&quot;&gt;polymorphic object&lt;/a&gt;, the type of its most derived object is known as the dynamic type.</source>
          <target state="translated">Si alguna &lt;a href=&quot;value_category&quot;&gt;expresi&amp;oacute;n de valor gl se&lt;/a&gt; refiere a un &lt;a href=&quot;objects&quot;&gt;objeto polim&amp;oacute;rfico&lt;/a&gt; , el tipo de su objeto m&amp;aacute;s derivado se conoce como el tipo din&amp;aacute;mico.</target>
        </trans-unit>
        <trans-unit id="eee5be8ef339e31668583c5122cb3ea37abcf9da" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, it will be copied to &lt;code&gt;d_first&lt;/code&gt; exactly &lt;code&gt;std::abs(m-n)&lt;/code&gt; times. If &lt;code&gt;m&amp;gt;n&lt;/code&gt;, then the last &lt;code&gt;m-n&lt;/code&gt; of those elements are copied from &lt;code&gt;[first1,last1)&lt;/code&gt;, otherwise the last &lt;code&gt;n-m&lt;/code&gt; elements are copied from &lt;code&gt;[first2,last2)&lt;/code&gt;. The resulting range cannot overlap with either of the input ranges.</source>
          <target state="translated">Si alg&amp;uacute;n elemento se encuentra &lt;code&gt;m&lt;/code&gt; veces en &lt;code&gt;[first1, last1)&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; veces en &lt;code&gt;[first2, last2)&lt;/code&gt; , que se copiar&amp;aacute; en &lt;code&gt;d_first&lt;/code&gt; exactamente &lt;code&gt;std::abs(m-n)&lt;/code&gt; veces. Si &lt;code&gt;m&amp;gt;n&lt;/code&gt; , entonces los &amp;uacute;ltimos &lt;code&gt;m-n&lt;/code&gt; de esos elementos se copian de &lt;code&gt;[first1,last1)&lt;/code&gt; , de lo contrario, los &amp;uacute;ltimos elementos &lt;code&gt;n-m&lt;/code&gt; se copian de &lt;code&gt;[first2,last2)&lt;/code&gt; . El rango resultante no puede solaparse con ninguno de los rangos de entrada.</target>
        </trans-unit>
        <trans-unit id="caf2cbf83a05e60a4bb97a0592549e75d93ad63b" translate="yes" xml:space="preserve">
          <source>If some element is found &lt;code&gt;m&lt;/code&gt; times in &lt;code&gt;[first1, last1)&lt;/code&gt; and &lt;code&gt;n&lt;/code&gt; times in &lt;code&gt;[first2, last2)&lt;/code&gt;, then all &lt;code&gt;m&lt;/code&gt; elements will be copied from &lt;code&gt;[first1, last1)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, preserving order, and then exactly &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n-m, 0)&lt;/code&gt; elements will be copied from &lt;code&gt;[first2, last2)&lt;/code&gt; to &lt;code&gt;d_first&lt;/code&gt;, also preserving order.</source>
          <target state="translated">Si alg&amp;uacute;n elemento se encuentra &lt;code&gt;m&lt;/code&gt; veces en &lt;code&gt;[first1, last1)&lt;/code&gt; y &lt;code&gt;n&lt;/code&gt; veces en &lt;code&gt;[first2, last2)&lt;/code&gt; , entonces todos los &lt;code&gt;m&lt;/code&gt; elementos se copian de &lt;code&gt;[first1, last1)&lt;/code&gt; a &lt;code&gt;d_first&lt;/code&gt; , preservar el orden, y luego exactamente &lt;code&gt;&lt;a href=&quot;max&quot;&gt;std::max&lt;/a&gt;(n-m, 0)&lt;/code&gt; elementos se copiar&amp;aacute;n de &lt;code&gt;[first2, last2)&lt;/code&gt; a &lt;code&gt;d_first&lt;/code&gt; , conservando tambi&amp;eacute;n el orden.</target>
        </trans-unit>
        <trans-unit id="67873cc8d634e461cb815d4a8417a686c3237eb4" translate="yes" xml:space="preserve">
          <source>If some member function &lt;code&gt;vf&lt;/code&gt; is declared as &lt;code&gt;virtual&lt;/code&gt; in a class &lt;code&gt;Base&lt;/code&gt;, and some class &lt;code&gt;Derived&lt;/code&gt;, which is derived, directly or indirectly, from &lt;code&gt;Base&lt;/code&gt;, has a declaration for member function with the same.</source>
          <target state="translated">Si alguna funci&amp;oacute;n miembro &lt;code&gt;vf&lt;/code&gt; se declara como &lt;code&gt;virtual&lt;/code&gt; en una clase &lt;code&gt;Base&lt;/code&gt; , y alguna clase &lt;code&gt;Derived&lt;/code&gt; , que se deriva, directa o indirectamente, de &lt;code&gt;Base&lt;/code&gt; , tiene una declaraci&amp;oacute;n para la funci&amp;oacute;n miembro con la misma.</target>
        </trans-unit>
        <trans-unit id="e561cbd21051ae04ee69688d91773e4d66564214" translate="yes" xml:space="preserve">
          <source>If some of the arguments that are supplied in the call to &lt;code&gt;g()&lt;/code&gt; are not matched by any placeholders stored in &lt;code&gt;g&lt;/code&gt;, the unused arguments are evaluated and discarded.</source>
          <target state="translated">Si alguno de los argumentos que se proporcionan en la llamada a &lt;code&gt;g()&lt;/code&gt; no coincide con ning&amp;uacute;n marcador de posici&amp;oacute;n almacenado en &lt;code&gt;g&lt;/code&gt; , los argumentos no utilizados se eval&amp;uacute;an y se descartan.</target>
        </trans-unit>
        <trans-unit id="c16f0b9646e0495cf7360c2d57ef97bff686bc4e" translate="yes" xml:space="preserve">
          <source>If some user-declared constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Si algunos constructores declarados por el usuario est&amp;aacute;n presentes, el usuario a&amp;uacute;n puede forzar la generaci&amp;oacute;n autom&amp;aacute;tica de un constructor predeterminado por el compilador que se declarar&amp;iacute;a impl&amp;iacute;citamente de otro modo con la palabra clave &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81f7a3f627cd87e8bf750cf042cc3a980725dec5" translate="yes" xml:space="preserve">
          <source>If some user-defined constructors are present, the user may still force the automatic generation of a default constructor by the compiler that would be implicitly-declared otherwise with the keyword &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Si algunos constructores definidos por el usuario est&amp;aacute;n presentes, el usuario a&amp;uacute;n puede forzar la generaci&amp;oacute;n autom&amp;aacute;tica de un constructor predeterminado por el compilador que se declarar&amp;iacute;a impl&amp;iacute;citamente de otro modo con la palabra clave &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f89b2e39dc991aa70988548f099b5134242e0c1" translate="yes" xml:space="preserve">
          <source>If statement is a single statement (not a compound statement), the scope of variables declared in it is limited to the while loop as if it was a compound statement, in other words,</source>
          <target state="translated">Si la declaración es una declaración simple (no una declaración compuesta),el alcance de las variables declaradas en ella se limita al bucle while como si fuera una declaración compuesta,en otras palabras,</target>
        </trans-unit>
        <trans-unit id="de8e6184779d6e772f3df1e2bc68eaa83374bf85" translate="yes" xml:space="preserve">
          <source>If statement-true is entered by &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; or &lt;code&gt;longjmp&lt;/code&gt;, statement_false is not executed.</source>
          <target state="translated">Si declaraci&amp;oacute;n-verdadero es ingresado por &lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; o &lt;code&gt;longjmp&lt;/code&gt; , no se ejecuta declaraci&amp;oacute;n_falsa.</target>
        </trans-unit>
        <trans-unit id="5e2cbc4d6a00d3a75286c31bf804d8bad59194eb" translate="yes" xml:space="preserve">
          <source>If statement_true or statement_false is not a compound statement, it is treated as if it were:</source>
          <target state="translated">Si statement_true o statement_false no es una declaración compuesta,se trata como si lo fuera:</target>
        </trans-unit>
        <trans-unit id="834b8d6940f6e20e10043e602b81088e525449aa" translate="yes" xml:space="preserve">
          <source>If successful, an integer value corresponding to the contents of &lt;code&gt;str&lt;/code&gt; is returned.</source>
          <target state="translated">Si tiene &amp;eacute;xito, se devuelve un valor entero correspondiente al contenido de &lt;code&gt;str&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25bfeb839d8f5173b50bb285122b4cc54720321c" translate="yes" xml:space="preserve">
          <source>If successful, returns a pointer to the object that controls the opened file stream, with both eof and error bits cleared. The stream is fully buffered unless filename refers to an interactive device.</source>
          <target state="translated">Si tiene éxito,devuelve un puntero al objeto que controla el flujo de archivos abierto,con los bits de eof y de error borrados.El flujo se almacena completamente en el buffer a menos que el nombre del archivo se refiera a un dispositivo interactivo.</target>
        </trans-unit>
        <trans-unit id="5632ad995e8027aefc150ef8436b23c84c4578ae" translate="yes" xml:space="preserve">
          <source>If successful, returns the IEEE floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">Si tiene &amp;eacute;xito, devuelve el resto de coma flotante IEEE de la divisi&amp;oacute;n &lt;code&gt;x/y&lt;/code&gt; como se defini&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="7ba7ac810951fe3d89eb854fd7520e591880a573" translate="yes" xml:space="preserve">
          <source>If successful, returns the absolute value of &lt;code&gt;arg&lt;/code&gt; (&lt;code&gt;|arg|&lt;/code&gt;). The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">Si tiene &amp;eacute;xito, devuelve el valor absoluto de &lt;code&gt;arg&lt;/code&gt; ( &lt;code&gt;|arg|&lt;/code&gt; ). El valor devuelto es exacto y no depende de ning&amp;uacute;n modo de redondeo.</target>
        </trans-unit>
        <trans-unit id="a595b23fd21a8f04c669747846486d0e27d71af0" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined above.</source>
          <target state="translated">Si tiene &amp;eacute;xito, devuelve el resto de coma flotante de la divisi&amp;oacute;n &lt;code&gt;x/y&lt;/code&gt; como se defini&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="03e429269f7181e14b033dacb9e7bf8c7396151a" translate="yes" xml:space="preserve">
          <source>If successful, returns the floating-point remainder of the division &lt;code&gt;x/y&lt;/code&gt; as defined in &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt;, and stores, in &lt;code&gt;*quo&lt;/code&gt;, the sign and at least three of the least significant bits of &lt;code&gt;x/y&lt;/code&gt; (formally, stores a value whose sign is the sign of &lt;code&gt;x/y&lt;/code&gt; and whose magnitude is congruent modulo 2n</source>
          <target state="translated">Si tiene &amp;eacute;xito, devuelve el resto de coma flotante de la divisi&amp;oacute;n &lt;code&gt;x/y&lt;/code&gt; como se define en &lt;code&gt;&lt;a href=&quot;remainder&quot;&gt;std::remainder&lt;/a&gt;&lt;/code&gt; , y almacena, en &lt;code&gt;*quo&lt;/code&gt; , el signo y al menos tres de los bits menos significativos de &lt;code&gt;x/y&lt;/code&gt; (formalmente, almacena un valor cuyo signo es el signo de &lt;code&gt;x/y&lt;/code&gt; y cuya magnitud es m&amp;oacute;dulo congruente 2n</target>
        </trans-unit>
        <trans-unit id="ea98bbdcb76a97fab4ef9d6ca9c32eecbe479081" translate="yes" xml:space="preserve">
          <source>If successful, returns the larger of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">Si tiene éxito,devuelve el mayor de dos valores de punto flotante.El valor devuelto es exacto y no depende de ningún modo de redondeo.</target>
        </trans-unit>
        <trans-unit id="9423b4432f6a645ec2473ed82b459b6686deb60f" translate="yes" xml:space="preserve">
          <source>If successful, returns the positive difference between x and y.</source>
          <target state="translated">Si tiene éxito,devuelve la diferencia positiva entre x e y.</target>
        </trans-unit>
        <trans-unit id="46138f9b406992b59d0f9492f2e64a28cf85480b" translate="yes" xml:space="preserve">
          <source>If successful, returns the smaller of two floating point values. The value returned is exact and does not depend on any rounding modes.</source>
          <target state="translated">Si tiene éxito,devuelve el menor de dos valores de punto flotante.El valor devuelto es exacto y no depende de ningún modo de redondeo.</target>
        </trans-unit>
        <trans-unit id="5ca1e3a726f6c442c2b326f76a16b023bb9441ee" translate="yes" xml:space="preserve">
          <source>If successful, returns the value of &lt;code&gt;(x*y) + z&lt;/code&gt; as if calculated to infinite precision and rounded once to fit the result type (or, alternatively, calculated as a single ternary floating-point operation).</source>
          <target state="translated">Si tiene &amp;eacute;xito, devuelve el valor de &lt;code&gt;(x*y) + z&lt;/code&gt; como si se calculara con precisi&amp;oacute;n infinita y se redondeara una vez para ajustarse al tipo de resultado (o, alternativamente, se calcula como una operaci&amp;oacute;n de punto flotante ternario &amp;uacute;nico).</target>
        </trans-unit>
        <trans-unit id="44139e51119b7719b4d6c2c45a98ecd6bcfaac63" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a cv-unqualified non-reference type to which both &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; are explicitly convertible. Additionally, &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::common_type&amp;lt;T2, T1&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="translated">Si dicha especializaci&amp;oacute;n tiene un &lt;code&gt;type&lt;/code&gt; miembro llamado , debe ser un tipo de miembro p&amp;uacute;blico e inequ&amp;iacute;voco que nombre un tipo de no referencia no calificado cv al que tanto &lt;code&gt;T1&lt;/code&gt; como &lt;code&gt;T2&lt;/code&gt; son expl&amp;iacute;citamente convertibles. Adem&amp;aacute;s, &lt;code&gt;std::common_type&amp;lt;T1, T2&amp;gt;::type&lt;/code&gt; y &lt;code&gt;std::common_type&amp;lt;T2, T1&amp;gt;::type&lt;/code&gt; deben denotar el mismo tipo.</target>
        </trans-unit>
        <trans-unit id="3a37148d1443f4a7f83a98b72097fe4c825195aa" translate="yes" xml:space="preserve">
          <source>If such a specialization has a member named &lt;code&gt;type&lt;/code&gt;, it must be a public and unambiguous member type that names a type to which both &lt;code&gt;TQual&amp;lt;T&amp;gt;&lt;/code&gt; and &lt;code&gt;UQual&amp;lt;U&amp;gt;&lt;/code&gt; are convertible. Additionally, &lt;code&gt;std::basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;::type&lt;/code&gt; and &lt;code&gt;std::basic_common_reference&amp;lt;U, T, UQual, TQual&amp;gt;::type&lt;/code&gt; must denote the same type.</source>
          <target state="translated">Si dicha especializaci&amp;oacute;n tiene un &lt;code&gt;type&lt;/code&gt; miembro llamado , debe ser un tipo de miembro p&amp;uacute;blico y sin ambig&amp;uuml;edades que nombre un tipo al que &lt;code&gt;TQual&amp;lt;T&amp;gt;&lt;/code&gt; y &lt;code&gt;UQual&amp;lt;U&amp;gt;&lt;/code&gt; sean convertibles. Adem&amp;aacute;s, &lt;code&gt;std::basic_common_reference&amp;lt;T, U, TQual, UQual&amp;gt;::type&lt;/code&gt; y &lt;code&gt;std::basic_common_reference&amp;lt;U, T, UQual, TQual&amp;gt;::type&lt;/code&gt; deben denotar el mismo tipo.</target>
        </trans-unit>
        <trans-unit id="a948028c1758b5531024e3fe8732225a9c5cc129" translate="yes" xml:space="preserve">
          <source>If such character was found, is it the</source>
          <target state="translated">Si tal personaje fue encontrado,¿es el</target>
        </trans-unit>
        <trans-unit id="18c5e1768b43942789912ab8899675cb0c8b4274" translate="yes" xml:space="preserve">
          <source>If such character was found, it is</source>
          <target state="translated">Si tal personaje fue encontrado,es</target>
        </trans-unit>
        <trans-unit id="1e5aef218cb47cb6d5be701f51f4abca139d0794" translate="yes" xml:space="preserve">
          <source>If such function has multiple return statements, the deduction is performed for each return statement. All the resulting types must be the same and become the actual return type.</source>
          <target state="translated">Si dicha función tiene múltiples declaraciones de retorno,la deducción se realiza por cada declaración de retorno.Todos los tipos resultantes deben ser iguales y convertirse en el tipo de devolución real.</target>
        </trans-unit>
        <trans-unit id="0ef2cb48d46014bbb2de04ceea1ca8d25cb98355" translate="yes" xml:space="preserve">
          <source>If such function has no return statement, &lt;code&gt;A&lt;/code&gt; is &lt;code&gt;void()&lt;/code&gt; when deducing.</source>
          <target state="translated">Si dicha funci&amp;oacute;n no tiene declaraci&amp;oacute;n de devoluci&amp;oacute;n, &lt;code&gt;A&lt;/code&gt; es &lt;code&gt;void()&lt;/code&gt; al deducir.</target>
        </trans-unit>
        <trans-unit id="781a8af57a4e00c05cd18f270856d6e17bfee700" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is</source>
          <target state="translated">Si se encontró un carácter tan amplio,es</target>
        </trans-unit>
        <trans-unit id="cc7116ca6f31d674f4a72c2589a0d09f652f8823" translate="yes" xml:space="preserve">
          <source>If such wide character was found, it is the</source>
          <target state="translated">Si se encontró un personaje tan amplio,es el</target>
        </trans-unit>
        <trans-unit id="6016d8ecaf1d3d66d2fab0578528efd9598d22d7" translate="yes" xml:space="preserve">
          <source>If that invocation returns normally (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">Si esa invocaci&amp;oacute;n vuelve normalmente (tal llamada a &lt;code&gt;call_once&lt;/code&gt; se conoce como</target>
        </trans-unit>
        <trans-unit id="d62acf7636b44fe974a0dd1f118413c4d750777d" translate="yes" xml:space="preserve">
          <source>If that invocation throws an exception, it is propagated to the caller of &lt;code&gt;call_once&lt;/code&gt;, and the flag is not flipped so that another call will be attempted (such call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">Si esa invocaci&amp;oacute;n arroja una excepci&amp;oacute;n, se propaga al llamante de &lt;code&gt;call_once&lt;/code&gt; , y el indicador no se voltea para que se intente otra llamada (dicha llamada a &lt;code&gt;call_once&lt;/code&gt; se conoce como</target>
        </trans-unit>
        <trans-unit id="80a16c9b65c48e0464ea5d60a9c92f28adf5f633" translate="yes" xml:space="preserve">
          <source>If that portion of the array previously provided storage for another object, the lifetime of that object ends because its storage was reused, however the lifetime of the array itself does not end (its storage is not considered to have been reused).</source>
          <target state="translated">Si esa porción de la matriz proporcionó anteriormente almacenamiento para otro objeto,la vida útil de ese objeto termina porque su almacenamiento fue reutilizado,sin embargo la vida útil de la matriz en sí no termina (no se considera que su almacenamiento haya sido reutilizado).</target>
        </trans-unit>
        <trans-unit id="3d9b7696c9777c3fdef5f5f1690ef14ee23382d9" translate="yes" xml:space="preserve">
          <source>If the</source>
          <target state="translated">Si el</target>
        </trans-unit>
        <trans-unit id="345e55abff70a548ca370acdb8ec63c08545a970" translate="yes" xml:space="preserve">
          <source>If the &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; component of the generic-format path contains a period (&lt;code&gt;.&lt;/code&gt;), and is not one of the special filesystem elements dot or dot-dot, then the</source>
          <target state="translated">Si el componente &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; de la ruta de formato gen&amp;eacute;rico contiene un punto ( &lt;code&gt;.&lt;/code&gt; ) Y no es uno de los elementos especiales del sistema de archivos dot o dot-dot, entonces el</target>
        </trans-unit>
        <trans-unit id="ba0ee99ef431871bed3ba20ad26dd7f7656ca3aa" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object was obtained from &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; or the POSIX &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt;, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="translated">Si el objeto &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; se obtuvo de &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; o el &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt; POSIX , el valor de &lt;code&gt;tm_isdst&lt;/code&gt; es indeterminado y debe establecerse expl&amp;iacute;citamente antes de llamar a &lt;code&gt;mktime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae98e330385c2faeed50f85315fe9af8967b33f7" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;&lt;a href=&quot;tm&quot;&gt;std::tm&lt;/a&gt;&lt;/code&gt; object was obtained from &lt;code&gt;&lt;a href=&quot;../../io/manip/get_time&quot;&gt;std::get_time&lt;/a&gt;&lt;/code&gt; or the POSIX &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/strptime.html&quot;&gt;strptime&lt;/a&gt;, the value of &lt;code&gt;tm_isdst&lt;/code&gt; is indeterminate, and needs to be set explicitly before calling &lt;code&gt;mktime&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78ffd5bdb618a15dacdd93c1f4888f75a24f4a33" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a class-level replacement, it will be used, otherwise global &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; will be used.</source>
          <target state="translated">Si el tipo &lt;code&gt;Promise&lt;/code&gt; define un reemplazo a nivel de clase, se usar&amp;aacute;, de lo contrario se usar&amp;aacute; el &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; global nuevo .</target>
        </trans-unit>
        <trans-unit id="73ae41564f6a1c376265c280e35f0cabc8e5e1b5" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;Promise&lt;/code&gt; type defines a placement form of &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; that takes additional parameters, and they match an argument list where the first argument is the size requested (of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) and the rest are the coroutine function arguments, those arguments will be passed to &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; (this makes it possible to use &lt;a href=&quot;../memory/uses_allocator#Uses-allocator_construction&quot;&gt;leading-allocator-convention&lt;/a&gt; for coroutines).</source>
          <target state="translated">Si el tipo &lt;code&gt;Promise&lt;/code&gt; define una forma de colocaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; que toma par&amp;aacute;metros adicionales, y coinciden con una lista de argumentos donde el primer argumento es el tama&amp;ntilde;o solicitado (de tipo &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ) y el resto son los argumentos de la funci&amp;oacute;n de rutina, esos argumentos ser&amp;aacute;n pasar al &lt;code&gt;&lt;a href=&quot;../memory/new/operator_new&quot;&gt;operator new&lt;/a&gt;&lt;/code&gt; (esto hace posible utilizar &lt;a href=&quot;../memory/uses_allocator#Uses-allocator_construction&quot;&gt;la convenci&amp;oacute;n&lt;/a&gt; de asignador principal para las corutinas).</target>
        </trans-unit>
        <trans-unit id="478337dee1f38e04706d749bfe79388ccef331de" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="translated">Si el &lt;code&gt;directory_iterator&lt;/code&gt; informa un error o avanza m&amp;aacute;s all&amp;aacute; de la &amp;uacute;ltima entrada del directorio, se vuelve igual al iterador construido por defecto, tambi&amp;eacute;n conocido como el iterador final. Dos iteradores finales son siempre iguales, desreferenciar o incrementar el iterador final es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="b8e4d93257a92c723d2b683f90d9e06102fd5b29" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is ambiguous, then &lt;code&gt;result == local_info::ambiguous&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just after the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that starts just before the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;local_time&lt;/code&gt; es ambiguo, entonces &lt;code&gt;result == local_info::ambiguous&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; se completa con &lt;code&gt;std::chrono::sys_info&lt;/code&gt; que termina justo despu&amp;eacute;s de &lt;code&gt;local_time&lt;/code&gt; , y &lt;code&gt;second&lt;/code&gt; se llena con &lt;code&gt;std::chrono::sys_info&lt;/code&gt; que comienza justo antes de la &lt;code&gt;local_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be3a36bf5edab54949d33d3601ee2498da9859cd" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;local_time&lt;/code&gt; is nonexistent, then &lt;code&gt;result == local_info::nonexistent&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that ends just prior to the &lt;code&gt;local_time&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is filled out with the &lt;code&gt;std::chrono::sys_info&lt;/code&gt; that begins just after the &lt;code&gt;local_time&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;local_time&lt;/code&gt; es inexistente, entonces &lt;code&gt;result == local_info::nonexistent&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; se completa con &lt;code&gt;std::chrono::sys_info&lt;/code&gt; que termina justo antes de &lt;code&gt;local_time&lt;/code&gt; , y &lt;code&gt;second&lt;/code&gt; se completa con &lt;code&gt;std::chrono::sys_info&lt;/code&gt; eso comienza justo despu&amp;eacute;s de la &lt;code&gt;local_time&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aba2a61809646633728f0c300cb4a04fd0fdd0e8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;nptr&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;enptr&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;nptr&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;endptr&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;nptr&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o o no tiene la forma esperada, no se realiza ninguna conversi&amp;oacute;n y (si &lt;code&gt;enptr&lt;/code&gt; no es &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ) el valor de &lt;code&gt;nptr&lt;/code&gt; se almacena en el objeto al que apunta &lt;code&gt;endptr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebdf7be468a8d6d0434b13fed187af1e31121791" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;recursive_directory_iterator&lt;/code&gt; reports an error or is advanced past the last directory entry of the top-level directory, it becomes equal to the default-constructed iterator, also known as the end iterator. Two end iterators are always equal, dereferencing or incrementing the end iterator is undefined behavior.</source>
          <target state="translated">Si &lt;code&gt;recursive_directory_iterator&lt;/code&gt; informa un error o se avanza m&amp;aacute;s all&amp;aacute; de la &amp;uacute;ltima entrada del directorio del directorio de nivel superior, se vuelve igual al iterador construido por defecto, tambi&amp;eacute;n conocido como el iterador final. Dos iteradores finales son siempre iguales, desreferenciar o incrementar el iterador final es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="5651c6461cabc5494e66b0b82def60eb3e607dc1" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;std::future&lt;/code&gt; obtained from &lt;code&gt;std::async&lt;/code&gt; is not moved from or bound to a reference, the destructor of the &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; will block at the end of the full expression until the asynchronous operation completes, essentially making code such as the following synchronous:</source>
          <target state="translated">Si el &lt;code&gt;std::future&lt;/code&gt; obtenido de &lt;code&gt;std::async&lt;/code&gt; no se mueve ni se vincula a una referencia, el destructor de &lt;code&gt;&lt;a href=&quot;future&quot;&gt;std::future&lt;/a&gt;&lt;/code&gt; se bloquear&amp;aacute; al final de la expresi&amp;oacute;n completa hasta que se complete la operaci&amp;oacute;n asincr&amp;oacute;nica, esencialmente haciendo c&amp;oacute;digo como lo siguiente sincr&amp;oacute;nico:</target>
        </trans-unit>
        <trans-unit id="f1881ec1b9072afac208ff470251f98ed10178f8" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;str&lt;/code&gt; is empty or does not have the expected form, no conversion is performed, and (if &lt;code&gt;str_end&lt;/code&gt; is not &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt;) the value of &lt;code&gt;str&lt;/code&gt; is stored in the object pointed to by &lt;code&gt;str_end&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;str&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o o no tiene la forma esperada, no se realiza ninguna conversi&amp;oacute;n y (si &lt;code&gt;str_end&lt;/code&gt; no es &lt;code&gt;&lt;a href=&quot;../../types/null&quot;&gt;NULL&lt;/a&gt;&lt;/code&gt; ) el valor de &lt;code&gt;str&lt;/code&gt; se almacena en el objeto al que apunta &lt;code&gt;str_end&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e50fd41c5ef8a59127cf972f021ae16ba8532f47" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in binary mode, the new position is exactly &lt;code&gt;offset&lt;/code&gt; bytes measured from the beginning of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;, from the current file position if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt;, and from the end of the file if &lt;code&gt;origin&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;. Binary streams are not required to support &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt;, in particular if additional null bytes are output.</source>
          <target state="translated">Si la &lt;code&gt;stream&lt;/code&gt; est&amp;aacute; abierta en modo binario, la nueva posici&amp;oacute;n es exactamente el &lt;code&gt;offset&lt;/code&gt; bytes medidos desde el comienzo del archivo si el &lt;code&gt;origin&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; , desde la posici&amp;oacute;n actual del archivo si el &lt;code&gt;origin&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_CUR&lt;/a&gt;&lt;/code&gt; , y desde el final del archivo si el &lt;code&gt;origin&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; . Las secuencias binarias no son necesarias para admitir &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;&lt;/code&gt; , en particular si se generan bytes nulos adicionales.</target>
        </trans-unit>
        <trans-unit id="37a2ed3c9a259690f19d7262a85bdeef29cb181d" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is open in text mode, the only supported values for &lt;code&gt;offset&lt;/code&gt; are zero (which works with any &lt;code&gt;origin&lt;/code&gt;) and a value returned by an earlier call to &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; on a stream associated with the same file (which only works with &lt;code&gt;origin&lt;/code&gt; of &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Si la &lt;code&gt;stream&lt;/code&gt; est&amp;aacute; abierta en modo de texto, los &amp;uacute;nicos valores admitidos para el &lt;code&gt;offset&lt;/code&gt; son cero (que funciona con cualquier &lt;code&gt;origin&lt;/code&gt; ) y un valor devuelto por una llamada anterior a &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; en una secuencia asociada con el mismo archivo (que solo funciona con &lt;code&gt;origin&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;../c&quot;&gt;SEEK_SET&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="892724969fe6221e78fcbe5fd94b682363cb5949" translate="yes" xml:space="preserve">
          <source>If the &lt;code&gt;stream&lt;/code&gt; is wide-oriented, the restrictions of both text and binary streams apply (result of &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; is allowed with SEEK_SET and zero offset is allowed from SEEK_SET and SEEK_CUR, but not SEEK_END).</source>
          <target state="translated">Si la &lt;code&gt;stream&lt;/code&gt; tiene una orientaci&amp;oacute;n amplia, se aplican las restricciones de las secuencias de texto y binarias (el resultado de &lt;code&gt;&lt;a href=&quot;ftell&quot;&gt;std::ftell&lt;/a&gt;&lt;/code&gt; est&amp;aacute; permitido con SEEK_SET y el desplazamiento cero est&amp;aacute; permitido desde SEEK_SET y SEEK_CUR, pero no SEEK_END).</target>
        </trans-unit>
        <trans-unit id="d0b614dfebe10969c88ebb875d7426f7d8ef68bd" translate="yes" xml:space="preserve">
          <source>If the OS uses a</source>
          <target state="translated">Si el sistema operativo utiliza un</target>
        </trans-unit>
        <trans-unit id="78c8e20ea6a30edcc63fb9e62dc035eb0fe67dd3" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;construct()&lt;/code&gt;,), then calls placement-new as.</source>
          <target state="translated">Si lo anterior no es posible (por ejemplo, &lt;code&gt;a&lt;/code&gt; no tiene la funci&amp;oacute;n miembro &lt;code&gt;construct()&lt;/code&gt; ,), luego llama colocaci&amp;oacute;n-nuevo como.</target>
        </trans-unit>
        <trans-unit id="08776426179650f866b4d0470c65442caf416cce" translate="yes" xml:space="preserve">
          <source>If the above is not possible (e.g. &lt;code&gt;a&lt;/code&gt; does not have the member function &lt;code&gt;max_size()&lt;/code&gt;), then returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max()&lt;/code&gt;(until C++17)&lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;(since C++17).</source>
          <target state="translated">Si lo anterior no es posible (por ejemplo, &lt;code&gt;a&lt;/code&gt; no tiene la funci&amp;oacute;n miembro &lt;code&gt;max_size()&lt;/code&gt; ), a continuaci&amp;oacute;n, devuelve &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max()&lt;/code&gt; (hasta C ++ 17) &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt; (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="aac3be73f3bb8e2fda1848ee16dfee9b40b5d6a7" translate="yes" xml:space="preserve">
          <source>If the aggregate initialization uses copy-(until C++14)list-initialization syntax (&lt;code&gt;T a = {args..}&lt;/code&gt;or &lt;code&gt;T a {args..}&lt;/code&gt;(since C++14)), the braces around the nested initializer lists may be elided (omitted), in which case as many initializer clauses as necessary are used to initialize every member or element of the corresponding subaggregate, and the subsequent initializer clauses are used to initialize the following members of the object. However, if the object has a sub-aggregate without any members (an empty struct, or a struct holding only static members), brace elision is not allowed, and an empty nested list &lt;code&gt;{} &lt;/code&gt; must be used.</source>
          <target state="translated">Si la inicializaci&amp;oacute;n agregada usa &lt;code&gt;T a = {args..}&lt;/code&gt; sintaxis de inicializaci&amp;oacute;n de lista de copia (hasta C ++ 14) ( T a = {args ..} o &lt;code&gt;T a {args..}&lt;/code&gt; (desde C ++ 14)), las llaves alrededor del inicializador anidado las listas se pueden omitir (omitir), en cuyo caso se utilizan tantas cl&amp;aacute;usulas de inicializaci&amp;oacute;n como sean necesarias para inicializar cada miembro o elemento del subaggregate correspondiente, y las cl&amp;aacute;usulas de inicializaci&amp;oacute;n posteriores se utilizan para inicializar los siguientes miembros del objeto. Sin embargo, si el objeto tiene un subconjunto sin ning&amp;uacute;n miembro (una estructura vac&amp;iacute;a o una estructura que contenga solo miembros est&amp;aacute;ticos), no se permite la supresi&amp;oacute;n de llaves, y se debe usar una lista anidada vac&amp;iacute;a &lt;code&gt;{} &lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0399c949000296ee9ae66ca9aac394f1a2f1f9c" translate="yes" xml:space="preserve">
          <source>If the aggregate that is initialized with a designated initializer clause has an anonymous union member, the corresponding designated initializer must name one of the members of that anonymous union.</source>
          <target state="translated">Si el agregado que se inicializa con una cláusula de inicialización designada tiene un miembro de la unión anónima,el correspondiente inicializador designado debe nombrar a uno de los miembros de esa unión anónima.</target>
        </trans-unit>
        <trans-unit id="594b9ef516bc13e866ad5205b086e5efba4a2ca2" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">Si el algoritmo no puede asignar memoria, se lanza &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1bbf4fee39cb9b1e1b2e31f5aa92d3790c46ca1d" translate="yes" xml:space="preserve">
          <source>If the algorithm fails to allocate memory, &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; is thrown.</source>
          <target state="translated">Si el algoritmo no puede asignar memoria, se lanza &lt;code&gt;&lt;a href=&quot;new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c2e9382364758d1ba08276bed3a0538d258c6220" translate="yes" xml:space="preserve">
          <source>If the allocation function returns a null pointer, which is possible if the non-throwing overload was selected, e.g. with &lt;code&gt;new(&lt;a href=&quot;../memory/new/nothrow&quot;&gt;std::nothrow&lt;/a&gt;) T;&lt;/code&gt;, then the new-expression returns immediately, it does not attempt to initialize an object or to call a deallocation function. If the standard placement allocation function returns a null pointer, which is possible if the user passes a null pointer as the argument, the behavior is undefined.(since C++17).</source>
          <target state="translated">Si la funci&amp;oacute;n de asignaci&amp;oacute;n devuelve un puntero nulo, lo cual es posible si se seleccion&amp;oacute; la sobrecarga no arrojadiza, por ejemplo, con &lt;code&gt;new(&lt;a href=&quot;../memory/new/nothrow&quot;&gt;std::nothrow&lt;/a&gt;) T;&lt;/code&gt; , la nueva expresi&amp;oacute;n vuelve inmediatamente, no intenta inicializar un objeto o llamar a una funci&amp;oacute;n de desasignaci&amp;oacute;n. Si la funci&amp;oacute;n de asignaci&amp;oacute;n de ubicaci&amp;oacute;n est&amp;aacute;ndar devuelve un puntero nulo, lo cual es posible si el usuario pasa un puntero nulo como argumento, el comportamiento es indefinido (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="a90b4223ec8c5c3e6da2dcd84075a2e4a1b01cc8" translate="yes" xml:space="preserve">
          <source>If the allocator will</source>
          <target state="translated">Si el asignador</target>
        </trans-unit>
        <trans-unit id="61e2b91fec3faec7fc75d4eceab84254e8c8a972" translate="yes" xml:space="preserve">
          <source>If the argument &lt;code&gt;A&lt;/code&gt; of the transformed template-1 can be used to deduce the corresponding parameter &lt;code&gt;P&lt;/code&gt; of template-2, but not vice versa, then this &lt;code&gt;A&lt;/code&gt; is more specialized than &lt;code&gt;P&lt;/code&gt; with regards to the type(s) that are deduced by this P/A pair.</source>
          <target state="translated">Si el argumento &lt;code&gt;A&lt;/code&gt; de la plantilla-1 transformada se puede usar para deducir el par&amp;aacute;metro &lt;code&gt;P&lt;/code&gt; correspondiente de la plantilla-2, pero no al rev&amp;eacute;s, entonces esta &lt;code&gt;A&lt;/code&gt; es m&amp;aacute;s especializada que &lt;code&gt;P&lt;/code&gt; con respecto a los tipos que se deducen por esta P / A par.</target>
        </trans-unit>
        <trans-unit id="2619199639dd0dfe77e10f7ea0d17382af754c82" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, &amp;plusmn;1 is returned</source>
          <target state="translated">Si el argumento es &amp;plusmn; &amp;infin;, se devuelve &amp;plusmn; 1</target>
        </trans-unit>
        <trans-unit id="a9eeedbf12ee3261a62193ec2f7bf409d740fd6e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">Si el argumento es &amp;plusmn; &amp;infin;, se devuelve + &amp;infin;</target>
        </trans-unit>
        <trans-unit id="bc0e32230b86eab8904c3236eac37ff6f8e3e5b9" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">Si el argumento es &amp;plusmn; &amp;infin;, se devuelve + &amp;infin;.</target>
        </trans-unit>
        <trans-unit id="70915638207ef43ec09152008a5ac4da1c3e101e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si el argumento es de &amp;plusmn; 0, &amp;plusmn; &amp;infin; se devuelve y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; se eleva</target>
        </trans-unit>
        <trans-unit id="4bcd3cf56514ebcbadf81a91fe745d514dda05b5" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, &amp;plusmn;0 is returned</source>
          <target state="translated">Si el argumento es &amp;plusmn; 0, se devuelve &amp;plusmn; 0</target>
        </trans-unit>
        <trans-unit id="79c9397babcc1b0c97ddd36d4f6dacccb4dbab7b" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si el argumento es de &amp;plusmn; 0, + &amp;infin; y se devuelve &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; se eleva</target>
        </trans-unit>
        <trans-unit id="97d561db29f01535350a0e816707f41c9ebbceeb" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, +0 is returned</source>
          <target state="translated">Si el argumento es &amp;plusmn; 0, se devuelve +0</target>
        </trans-unit>
        <trans-unit id="6f44ff73ce4a7042130e83bc24af8060e5fe2b98" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned</source>
          <target state="translated">Si el argumento es &amp;plusmn; 0, se devuelve -&amp;infin;</target>
        </trans-unit>
        <trans-unit id="310b79d192c0fa5a1ce6ca3877e2deb499d9d5f3" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Si el argumento es &amp;plusmn; 0, se devuelve -&amp;infin; y se &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e20d184a4efd311faacd5da72518930f348cac5a" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, 1 is returned</source>
          <target state="translated">Si el argumento es &amp;plusmn; 0, se devuelve 1</target>
        </trans-unit>
        <trans-unit id="d3f53d74b0dca3908c99b1e364989b3591808e1e" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned unmodified</source>
          <target state="translated">Si el argumento es &amp;plusmn; 0, se devuelve sin modificar</target>
        </trans-unit>
        <trans-unit id="ccd73690fa7a557641f2fe90d1fb0da76c7573ad" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;0, it is returned, unmodified</source>
          <target state="translated">Si el argumento es &amp;plusmn; 0, se devuelve, sin modificar</target>
        </trans-unit>
        <trans-unit id="666ec3240c22502f1099c8da74484f25ff980d70" translate="yes" xml:space="preserve">
          <source>If the argument is &amp;plusmn;1, a pole error occurs.</source>
          <target state="translated">Si el argumento es &amp;plusmn; 1, se produce un error de polo.</target>
        </trans-unit>
        <trans-unit id="16671d13b546303a8dbbbb41028ae78cbf067eb9" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin; or &amp;plusmn;0, it is returned, unmodified.</source>
          <target state="translated">Si el argumento es + &amp;infin; o &amp;plusmn; 0, se devuelve, sin modificar.</target>
        </trans-unit>
        <trans-unit id="54b0607c64e592ab2e8d7944a7583de099ef78bc" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned</source>
          <target state="translated">Si el argumento es + &amp;infin;, se devuelve + &amp;infin;</target>
        </trans-unit>
        <trans-unit id="aa21d5b0bb57bf219f506cda16da2521284b89b4" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;infin; is returned.</source>
          <target state="translated">Si el argumento es + &amp;infin;, se devuelve + &amp;infin;.</target>
        </trans-unit>
        <trans-unit id="540557a8bd62a5b0f36f5bd102aec659ebb950db" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +&amp;pi;/2 is returned</source>
          <target state="translated">Si el argumento es + &amp;infin;, se devuelve + &amp;pi; / 2</target>
        </trans-unit>
        <trans-unit id="7199243658fb47291089c2b185fa5cf8110be042" translate="yes" xml:space="preserve">
          <source>If the argument is +&amp;infin;, +0 is returned</source>
          <target state="translated">Si el argumento es + &amp;infin;, se devuelve +0</target>
        </trans-unit>
        <trans-unit id="f4be25ee19a8f2e9c79ffae1bfa98e41cff590c7" translate="yes" xml:space="preserve">
          <source>If the argument is +1, the value &lt;code&gt;+0&lt;/code&gt; is returned.</source>
          <target state="translated">Si el argumento es +1, se devuelve el valor &lt;code&gt;+0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09765a27421db439d2ceef1decf36c6c5400ca31" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, +0 is returned</source>
          <target state="translated">Si el argumento es -&amp;infin;, se devuelve +0</target>
        </trans-unit>
        <trans-unit id="ab67da2ac08a598b0aeee9a84a5ea4203889b128" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -&amp;pi;/2 is returned</source>
          <target state="translated">Si el argumento es -&amp;infin;, se devuelve -&amp;pi; / 2</target>
        </trans-unit>
        <trans-unit id="c52a07d7a9cd046aa4f61618e846c887cf3ca1d0" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, -1 is returned</source>
          <target state="translated">Si el argumento es -&amp;infin;, se devuelve -1</target>
        </trans-unit>
        <trans-unit id="3cb7272c20346f5eded435e9a2ce5990a13f544b" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, 2 is returned</source>
          <target state="translated">Si el argumento es -&amp;infin;, se devuelve 2</target>
        </trans-unit>
        <trans-unit id="7b59bb47bb4f9b237288770872fa9592f179ad22" translate="yes" xml:space="preserve">
          <source>If the argument is -&amp;infin;, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si el argumento es -&amp;infin;, se devuelve NaN y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; se eleva</target>
        </trans-unit>
        <trans-unit id="2728e75a63954aabe83e882896db0bf09fd9c3f9" translate="yes" xml:space="preserve">
          <source>If the argument is -1, -&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Si el argumento es -1, se devuelve -&amp;infin; y se &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dad9f0dbcbb32af831ea87c9b1abd3643a5b7b20" translate="yes" xml:space="preserve">
          <source>If the argument is 1, +0 is returned</source>
          <target state="translated">Si el argumento es 1,se devuelve +0</target>
        </trans-unit>
        <trans-unit id="290ee1b584ad39adb2720da091bea3742f568b9f" translate="yes" xml:space="preserve">
          <source>If the argument is 2, +0 is returned</source>
          <target state="translated">Si el argumento es 2,se devuelve +0</target>
        </trans-unit>
        <trans-unit id="9f6074320a813a4e58ce3f8235a3e40354fe9d12" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned</source>
          <target state="translated">Si el argumento es NaN,NaN es devuelto</target>
        </trans-unit>
        <trans-unit id="ccc4c1fc3fbbb948e5c992719dc5c43cdd7d9790" translate="yes" xml:space="preserve">
          <source>If the argument is NaN, NaN is returned and domain error is not reported</source>
          <target state="translated">Si el argumento es NaN,se devuelve NaN y no se informa del error de dominio</target>
        </trans-unit>
        <trans-unit id="663f54eba211611128011b5b2bd091f463b1a1cc" translate="yes" xml:space="preserve">
          <source>If the argument is a designated initializer list, a conversion is only possible if the parameter has an aggregate type that can be initialized from that initializer list according to the rules for &lt;a href=&quot;aggregate_initialization&quot;&gt;aggregate initialization&lt;/a&gt;, in which case the implicit conversion sequence is a user-defined conversion sequence whose second standard conversion sequence is an identity conversion.</source>
          <target state="translated">Si el argumento es una lista de inicializador designada, una conversi&amp;oacute;n solo es posible si el par&amp;aacute;metro tiene un tipo agregado que puede inicializarse desde esa lista de inicializador de acuerdo con las reglas para &lt;a href=&quot;aggregate_initialization&quot;&gt;la inicializaci&amp;oacute;n agregada&lt;/a&gt; , en cuyo caso la secuencia de conversi&amp;oacute;n impl&amp;iacute;cita es una conversi&amp;oacute;n definida por el usuario secuencia cuya segunda secuencia de conversi&amp;oacute;n est&amp;aacute;ndar es una conversi&amp;oacute;n de identidad.</target>
        </trans-unit>
        <trans-unit id="f630be49c2abd923603f430a83802a576f8d8a5b" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, +&amp;infin; is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si el argumento es un entero negativo, + &amp;infin; y se devuelve &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_DIVBYZERO&lt;/a&gt;&lt;/code&gt; se eleva</target>
        </trans-unit>
        <trans-unit id="d3cb5a23f7100fda931d00bdcf1949dd71d061ad" translate="yes" xml:space="preserve">
          <source>If the argument is a negative integer, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si el argumento es un entero negativo, se devuelve NaN y &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; se eleva</target>
        </trans-unit>
        <trans-unit id="20646ae3669e13c85917f45de5026134f970fd91" translate="yes" xml:space="preserve">
          <source>If the argument is less than -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and NaN is returned.</source>
          <target state="translated">Si el argumento es menor que -0, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; se genera y se devuelve NaN.</target>
        </trans-unit>
        <trans-unit id="d60f1479d7ad633bb20dc263baae8366ce50fe47" translate="yes" xml:space="preserve">
          <source>If the argument is less than -1, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Si el argumento es menor que -1, se devuelve NaN y se &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="82e61b5e3d8efb3126389ca46e457ed7c53253b6" translate="yes" xml:space="preserve">
          <source>If the argument is less than 1, a domain error occurs.</source>
          <target state="translated">Si el argumento es menor que 1,se produce un error de dominio.</target>
        </trans-unit>
        <trans-unit id="8ca2273cafe3374e2295b541c384fca2773d84f3" translate="yes" xml:space="preserve">
          <source>If the argument is negative, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Si el argumento es negativo, se devuelve NaN y se &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ce877c1c558f9ec930d2aac72c101f35a2f7812" translate="yes" xml:space="preserve">
          <source>If the argument is not on the interval [-1, +1], a range error occurs.</source>
          <target state="translated">Si el argumento no está en el intervalo [-1,+1],se produce un error de rango.</target>
        </trans-unit>
        <trans-unit id="a3c3924a950cbead03e34404522a3031242c5c81" translate="yes" xml:space="preserve">
          <source>If the arguments are temporaries, &lt;code&gt;forward_as_tuple&lt;/code&gt; does not extend their lifetime; they have to be used before the end of the full expression.</source>
          <target state="translated">Si los argumentos son temporales, &lt;code&gt;forward_as_tuple&lt;/code&gt; no extiende su vida &amp;uacute;til; deben usarse antes del final de la expresi&amp;oacute;n completa.</target>
        </trans-unit>
        <trans-unit id="2199aba2bc9bf0df1d73b9c3777d78213c53216a" translate="yes" xml:space="preserve">
          <source>If the array contains several elements that &lt;code&gt;comp&lt;/code&gt; would indicate as equal to the element searched for, then it is unspecified which element the function will return as the result.</source>
          <target state="translated">Si la matriz contiene varios elementos que &lt;code&gt;comp&lt;/code&gt; indicar&amp;iacute;a que son iguales al elemento buscado, entonces no se especifica qu&amp;eacute; elemento devolver&amp;aacute; la funci&amp;oacute;n como resultado.</target>
        </trans-unit>
        <trans-unit id="f51494a87d2300af12e0330eba96c74b86cb7986" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open() == false&lt;/code&gt;), returns &lt;code&gt;Traits::eof()&lt;/code&gt; before doing anything.</source>
          <target state="translated">Si el archivo asociado no est&amp;aacute; abierto ( &lt;code&gt;is_open() == false&lt;/code&gt; ), devuelve &lt;code&gt;Traits::eof()&lt;/code&gt; antes de hacer algo.</target>
        </trans-unit>
        <trans-unit id="b7bafed16d966c0cf1207175d019010ae108d6c1" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;), fails immediately.</source>
          <target state="translated">Si el archivo asociado no est&amp;aacute; abierto ( &lt;code&gt;is_open()==false&lt;/code&gt; ), falla inmediatamente.</target>
        </trans-unit>
        <trans-unit id="ae52be96052bf801f3b8098ab2013b04fe3a4a04" translate="yes" xml:space="preserve">
          <source>If the associated file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, fails immediately.</source>
          <target state="translated">Si el archivo asociado no est&amp;aacute; abierto ( &lt;code&gt;is_open()==false&lt;/code&gt; , falla inmediatamente.</target>
        </trans-unit>
        <trans-unit id="7cac4bee56cffefb9d5f96aafb66ad2424beb17d" translate="yes" xml:space="preserve">
          <source>If the associated file was already open, returns a null pointer right away.</source>
          <target state="translated">Si el archivo asociado ya estaba abierto,devuelve un puntero nulo de inmediato.</target>
        </trans-unit>
        <trans-unit id="707b71cd5415cf8d8476c290727e5a9c8c18e35f" translate="yes" xml:space="preserve">
          <source>If the associated mutex is already locked by this &lt;code&gt;shared_lock&lt;/code&gt; (that is, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; returns &lt;code&gt;true&lt;/code&gt;), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Si el mutex asociado ya est&amp;aacute; bloqueado por este &lt;code&gt;shared_lock&lt;/code&gt; (es decir, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; devuelve &lt;code&gt;true&lt;/code&gt; ), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; con un c&amp;oacute;digo de error de &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a8b1ad230edb75da7998e440c34314fa12ebb13f" translate="yes" xml:space="preserve">
          <source>If the body of a lambda &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-uses&lt;/a&gt; an entity captured by copy, the member of the closure type is accessed. If it is not odr-using the entity, the access is to the original object:</source>
          <target state="translated">Si el cuerpo de un lambda &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-utiliza&lt;/a&gt; una entidad capturada por copia, se accede al miembro del tipo de cierre. Si no est&amp;aacute; utilizando la entidad odr, el acceso es al objeto original:</target>
        </trans-unit>
        <trans-unit id="efb071bf7d785901c94b7543fe7ce5432fcfa86c" translate="yes" xml:space="preserve">
          <source>If the braced-init-list is empty and &lt;code&gt;T&lt;/code&gt; is a class type with a default constructor, &lt;a href=&quot;value_initialization&quot;&gt;value-initialization&lt;/a&gt; is performed.</source>
          <target state="translated">Si braced-init-list est&amp;aacute; vac&amp;iacute;a y &lt;code&gt;T&lt;/code&gt; es un tipo de clase con un constructor predeterminado, se realiza la &lt;a href=&quot;value_initialization&quot;&gt;inicializaci&amp;oacute;n del valor&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1719a9715867ad8b0bc520fba8f212e17cc25ebe" translate="yes" xml:space="preserve">
          <source>If the buffer uses dynamic allocation, sets the frozen status of the stream to &lt;code&gt;freezefl&lt;/code&gt;.</source>
          <target state="translated">Si el b&amp;uacute;fer usa la asignaci&amp;oacute;n din&amp;aacute;mica, establece el estado congelado de la transmisi&amp;oacute;n en &lt;code&gt;freezefl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1b15e0ac114ac6cf1d11c46237069b5057df384" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;(pos_type)-1&lt;/code&gt;, executes &lt;code&gt;setstate(failbit)&lt;/code&gt;.</source>
          <target state="translated">Si la llamada devuelve &lt;code&gt;(pos_type)-1&lt;/code&gt; , ejecuta &lt;code&gt;setstate(failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d455f5da56a971dee921cba17f2bcf47c19cb43f" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;false&lt;/code&gt;, the iterator sets &lt;code&gt;*this&lt;/code&gt; to the end-of-sequence iterator, the function returns.</source>
          <target state="translated">Si la llamada devuelve &lt;code&gt;false&lt;/code&gt; , el iterador establece &lt;code&gt;*this&lt;/code&gt; en el iterador de fin de secuencia, la funci&amp;oacute;n regresa.</target>
        </trans-unit>
        <trans-unit id="e503214a190894ba07737d97130f4f4e57a0952d" translate="yes" xml:space="preserve">
          <source>If the call returns &lt;code&gt;true&lt;/code&gt;, the function returns.</source>
          <target state="translated">Si la llamada devuelve &lt;code&gt;true&lt;/code&gt; , la funci&amp;oacute;n regresa.</target>
        </trans-unit>
        <trans-unit id="5756be4be986d9060f28be2990144a451f23bebb" translate="yes" xml:space="preserve">
          <source>If the call to &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; returns &lt;code&gt;Traits::eof&lt;/code&gt;, sets the failed() flag to true.</source>
          <target state="translated">Si la llamada a &lt;code&gt;pbuf-&amp;gt;sputc(c)&lt;/code&gt; devuelve &lt;code&gt;Traits::eof&lt;/code&gt; , establece el indicador fallido () en verdadero.</target>
        </trans-unit>
        <trans-unit id="4aae1dcba7a08d934d0a653ad0c0ff27019c75f7" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;&amp;amp;&lt;/code&gt;, subsequent simple captures must not begin with &lt;code&gt;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Si el valor predeterminado de captura es &lt;code&gt;&amp;amp;&lt;/code&gt; , las capturas simples posteriores no deben comenzar con &lt;code&gt;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0277bab17cc429663b1ace6d465fb1f995414d4e" translate="yes" xml:space="preserve">
          <source>If the capture-default is &lt;code&gt;=&lt;/code&gt;, subsequent simple captures must begin with &lt;code&gt;&amp;amp;&lt;/code&gt; or be &lt;code&gt;*this&lt;/code&gt;(since C++17)or &lt;code&gt;this&lt;/code&gt;(since C++20).</source>
          <target state="translated">Si el valor predeterminado de captura es &lt;code&gt;=&lt;/code&gt; , las capturas simples posteriores deben comenzar con &lt;code&gt;&amp;amp;&lt;/code&gt; o ser &lt;code&gt;*this&lt;/code&gt; (desde C ++ 17) o &lt;code&gt;this&lt;/code&gt; (desde C ++ 20).</target>
        </trans-unit>
        <trans-unit id="de84be00a72fc5e9e1aaa148e3a8f5aade0e83e5" translate="yes" xml:space="preserve">
          <source>If the cast is successful, &lt;code&gt;dynamic_cast&lt;/code&gt; returns a value of type &lt;code&gt;new_type&lt;/code&gt;. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a pointer type, it returns a null pointer of that type. If the cast fails and &lt;code&gt;new_type&lt;/code&gt; is a reference type, it throws an exception that matches a handler of type &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la &lt;code&gt;dynamic_cast&lt;/code&gt; es exitosa, dynamic_cast devuelve un valor de tipo &lt;code&gt;new_type&lt;/code&gt; . Si la &lt;code&gt;new_type&lt;/code&gt; falla y new_type es un tipo de puntero, devuelve un puntero nulo de ese tipo. Si la &lt;code&gt;new_type&lt;/code&gt; falla y new_type es un tipo de referencia, arroja una excepci&amp;oacute;n que coincide con un controlador de tipo &lt;code&gt;&lt;a href=&quot;../types/bad_cast&quot;&gt;std::bad_cast&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d0ba473a6711055af0221180f781e98850fbb86" translate="yes" xml:space="preserve">
          <source>If the character matches one of &lt;code&gt;&quot;0123456789abcdefxABCDEFX+-&quot;&lt;/code&gt;, widened to the locale's char_type as if by &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).widen()&lt;/code&gt;, it is converted to the corresponding &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">Si el car&amp;aacute;cter coincide con uno de &lt;code&gt;&quot;0123456789abcdefxABCDEFX+-&quot;&lt;/code&gt; , ampliado al char_type del entorno local como por &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).widen()&lt;/code&gt; , se convierte al correspondiente &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1c4cec9fd9552b11fc88dfc3cdd3888d0078a93" translate="yes" xml:space="preserve">
          <source>If the character matches the decimal point separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).decimal_point())&lt;/code&gt;), it is replaced by &lt;code&gt;'.'&lt;/code&gt;.</source>
          <target state="translated">Si el car&amp;aacute;cter coincide con el separador de punto decimal ( &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).decimal_point())&lt;/code&gt; ), se reemplaza por &lt;code&gt;'.'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4175453721d5f90ed16f3adae9fd0acf7beb27c3" translate="yes" xml:space="preserve">
          <source>If the character matches the thousands separator (&lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt;) and the thousands separation is in use at all &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping().length() != 0&lt;/code&gt;, then if the decimal point &lt;code&gt;'.'&lt;/code&gt; has not yet been accumulated, the position of the character is remembered, but the character is otherwise ignored. If the decimal point has already been accumulated, the character is discarded and Stage 2 terminates.</source>
          <target state="translated">Si el car&amp;aacute;cter coincide con el separador de miles ( &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).thousands_sep()&lt;/code&gt; ) y la separaci&amp;oacute;n de miles est&amp;aacute; en uso en todo &lt;code&gt;&lt;a href=&quot;../use_facet&quot;&gt;std::use_facet&lt;/a&gt;&amp;lt;&lt;a href=&quot;../numpunct&quot;&gt;std::numpunct&lt;/a&gt;&amp;lt;charT&amp;gt;&amp;gt;(str.getloc()).grouping().length() != 0&lt;/code&gt; , entonces si el punto decimal &lt;code&gt;'.'&lt;/code&gt; a&amp;uacute;n no se ha acumulado, se recuerda la posici&amp;oacute;n del personaje, pero de lo contrario se ignora al personaje. Si el punto decimal ya se ha acumulado, el car&amp;aacute;cter se descarta y la Etapa 2 termina.</target>
        </trans-unit>
        <trans-unit id="e6c7076c1a1240513d559610a53ddb63ba3eb6f5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid character class in the currently imbued locale (that is, the string between &lt;code&gt;[:&lt;/code&gt; and &lt;code&gt;:]&lt;/code&gt; in regular expressions), returns the implementation-defined value representing this character class. Otherwise, returns zero.</source>
          <target state="translated">Si la secuencia de caracteres &lt;code&gt;[first, last)&lt;/code&gt; representa el nombre de una clase de caracteres v&amp;aacute;lida en el entorno local actualmente imbuido (es decir, la cadena entre &lt;code&gt;[:&lt;/code&gt; y &lt;code&gt;:]&lt;/code&gt; en expresiones regulares), devuelve el valor definido por la implementaci&amp;oacute;n que representa esta clase de caracteres. De lo contrario, devuelve cero.</target>
        </trans-unit>
        <trans-unit id="a2ef46a67a9512caa78f86cb2680b53275117ae5" translate="yes" xml:space="preserve">
          <source>If the character sequence &lt;code&gt;[first, last)&lt;/code&gt; represents the name of a valid collating element in the currently imbued locale, returns the name of that collating element. Otherwise, returns an empty string.</source>
          <target state="translated">Si la secuencia de caracteres &lt;code&gt;[first, last)&lt;/code&gt; representa el nombre de un elemento de clasificaci&amp;oacute;n v&amp;aacute;lido en el entorno local actualmente imbuido, devuelve el nombre de ese elemento de clasificaci&amp;oacute;n. De lo contrario, devuelve una cadena vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="4fe55081ac62dc0b587a9cbf52fa55cd3bee4000" translate="yes" xml:space="preserve">
          <source>If the closure object's &lt;code&gt;operator()&lt;/code&gt; has a non-throwing exception specification, then the pointer returned by this function has the type pointer to noexcept function.</source>
          <target state="translated">Si el &lt;code&gt;operator()&lt;/code&gt; del objeto de cierre () tiene una especificaci&amp;oacute;n de excepci&amp;oacute;n de no lanzamiento, entonces el puntero devuelto por esta funci&amp;oacute;n tiene el puntero de tipo a la funci&amp;oacute;n noexcept.</target>
        </trans-unit>
        <trans-unit id="745715b691af433f45a6d1bda05f6b64c4819109" translate="yes" xml:space="preserve">
          <source>If the compiler issues warnings on unused entities, that warning is suppressed for any entity declared maybe_unused.</source>
          <target state="translated">Si el compilador emite advertencias sobre entidades no utilizadas,esa advertencia se suprime para cualquier entidad declarada como tal vez_no utilizada.</target>
        </trans-unit>
        <trans-unit id="c8a49a5236b04e3615bd1cc238ec4430854742fb" translate="yes" xml:space="preserve">
          <source>If the condition yields &lt;code&gt;true&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-true is executed.</source>
          <target state="translated">Si la condici&amp;oacute;n produce &lt;code&gt;true&lt;/code&gt; despu&amp;eacute;s de la conversi&amp;oacute;n a &lt;code&gt;bool&lt;/code&gt; , se ejecuta el enunciado verdadero.</target>
        </trans-unit>
        <trans-unit id="229091fed99fdddbb18485bc60172db01d5f6825" translate="yes" xml:space="preserve">
          <source>If the conditions listed above are not met, a valid pointer to the new object may still be obtained by applying the pointer optimization barrier &lt;a href=&quot;../utility/launder&quot;&gt;&lt;code&gt;std::launder&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si no se cumplen las condiciones enumeradas anteriormente, a&amp;uacute;n se puede obtener un puntero v&amp;aacute;lido al nuevo objeto aplicando la barrera de optimizaci&amp;oacute;n de puntero &lt;a href=&quot;../utility/launder&quot;&gt; &lt;code&gt;std::launder&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="2221877dc5bedfe8cd4e7aed36ecca467cec7440" translate="yes" xml:space="preserve">
          <source>If the constructor was inherited from multiple base class subobjects of type B, the program is ill-formed, similar to multiply-inherited non-static member functions:</source>
          <target state="translated">Si el constructor fue heredado de múltiples subobjetos de clase base de tipo B,el programa está mal formado,similar a las funciones de los miembros no estáticos heredados en forma múltiple:</target>
        </trans-unit>
        <trans-unit id="ec7e0506f8686074df12634f2b0dcdc66508f971" translate="yes" xml:space="preserve">
          <source>If the container is empty, the returned iterator will be equal to &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el contenedor est&amp;aacute; vac&amp;iacute;o, el iterador devuelto ser&amp;aacute; igual a &lt;code&gt;&lt;a href=&quot;end&quot;&gt;end()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4be0a9674e89e888ef7897d1c0bff106b4bd693d" translate="yes" xml:space="preserve">
          <source>If the conversion fails with &lt;code&gt;&lt;a href=&quot;../../locale/codecvt_base&quot;&gt;std::codecvt_base::error&lt;/a&gt;&lt;/code&gt;, returns &lt;code&gt;Traits::eof()&lt;/code&gt; without attempting any output.</source>
          <target state="translated">Si la conversi&amp;oacute;n falla con &lt;code&gt;&lt;a href=&quot;../../locale/codecvt_base&quot;&gt;std::codecvt_base::error&lt;/a&gt;&lt;/code&gt; , devuelve &lt;code&gt;Traits::eof()&lt;/code&gt; sin intentar ning&amp;uacute;n resultado.</target>
        </trans-unit>
        <trans-unit id="60a697aa95e320d7d6b93da3ee60c2df0a966a8e" translate="yes" xml:space="preserve">
          <source>If the conversion function fails to convert the entire field, the value &lt;code&gt;​0​&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">Si la funci&amp;oacute;n de conversi&amp;oacute;n no puede convertir todo el campo, el valor &lt;code&gt;​0​&lt;/code&gt; se almacena en &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4027272e7c52f77712bdb3b653471483e93cc10" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a negative value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most negative representable value is stored in &lt;code&gt;v&lt;/code&gt;, or zero for unsigned integer types.(until C++17)</source>
          <target state="translated">Si la funci&amp;oacute;n de conversi&amp;oacute;n da como resultado un valor negativo demasiado grande para caber en el tipo de &lt;code&gt;v&lt;/code&gt; , el valor representable m&amp;aacute;s negativo se almacena en &lt;code&gt;v&lt;/code&gt; , o cero para los tipos enteros sin signo (hasta C ++ 17)</target>
        </trans-unit>
        <trans-unit id="fb166b2ef44fa2af14cb9e58cf13d66806179e94" translate="yes" xml:space="preserve">
          <source>If the conversion function results in a positive value too large to fit in the type of &lt;code&gt;v&lt;/code&gt;, the most positive representable value is stored in &lt;code&gt;v&lt;/code&gt;</source>
          <target state="translated">Si la funci&amp;oacute;n de conversi&amp;oacute;n da como resultado un valor positivo demasiado grande para caber en el tipo de &lt;code&gt;v&lt;/code&gt; , el valor representable m&amp;aacute;s positivo se almacena en &lt;code&gt;v&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d2eaadc84330d90ea23a53f900d957f39efcabf8" translate="yes" xml:space="preserve">
          <source>If the conversion is successful, the &lt;code&gt;time&lt;/code&gt; object is modified. All fields of &lt;code&gt;time&lt;/code&gt; are updated to fit their proper ranges. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; and &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; are recalculated using information available in other fields.</source>
          <target state="translated">Si la conversi&amp;oacute;n es exitosa, el objeto de &lt;code&gt;time&lt;/code&gt; se modifica. Todos los campos de &lt;code&gt;time&lt;/code&gt; se actualizan para ajustarse a sus rangos adecuados. &lt;code&gt;time-&amp;gt;tm_wday&lt;/code&gt; y &lt;code&gt;time-&amp;gt;tm_yday&lt;/code&gt; se recalculan utilizando la informaci&amp;oacute;n disponible en otros campos.</target>
        </trans-unit>
        <trans-unit id="c8c7ea2a20a700c8ab515cd57db8ff2477c02ff7" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Si el valor convertido cae fuera del rango del tipo de retorno correspondiente, se produce un error de rango (estableciendo &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ) y se &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LONG_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MAX&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;LLONG_MIN&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6192b4cbcd6b133ff7698ce09fce768219ba252e" translate="yes" xml:space="preserve">
          <source>If the converted value falls out of range of corresponding return type, a range error occurs (setting &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt;) and &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;​0​&lt;/code&gt; is returned, as appropriate.</source>
          <target state="translated">Si el valor convertido cae fuera del alcance de correspondiente tipo de retorno, se produce un error de rango (ajuste &lt;code&gt;&lt;a href=&quot;../../error/errno&quot;&gt;errno&lt;/a&gt;&lt;/code&gt; a &lt;code&gt;&lt;a href=&quot;../../error/errno_macros&quot;&gt;ERANGE&lt;/a&gt;&lt;/code&gt; ) y &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MAX&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;INTMAX_MIN&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../types/integer&quot;&gt;UINTMAX_MAX&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;​0​&lt;/code&gt; se devuelve, seg&amp;uacute;n sea apropiado.</target>
        </trans-unit>
        <trans-unit id="fa940cdd0f1bc4912d7a80a9acf3e3f2a1974390" translate="yes" xml:space="preserve">
          <source>If the coroutine ends with an uncaught exception, it performs the following:</source>
          <target state="translated">Si la corutina termina con una excepción no capturada,realiza lo siguiente:</target>
        </trans-unit>
        <trans-unit id="12ad0f51863289a6c7c5da2f479d5e058f364975" translate="yes" xml:space="preserve">
          <source>If the coroutine is a non-static member function, such as &lt;code&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const;&lt;/code&gt;, its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="translated">Si la rutina es una funci&amp;oacute;n miembro no est&amp;aacute;tica, como la &lt;code&gt;task&amp;lt;void&amp;gt; my_class::method1(int x) const;&lt;/code&gt; , su tipo &lt;code&gt;Promise&lt;/code&gt; es &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;void&amp;gt;, const my_class&amp;amp;, int&amp;gt;::promise_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7dc7e439c27949bc04c73f28d03c64e858d4848d" translate="yes" xml:space="preserve">
          <source>If the coroutine is defined as &lt;code&gt;task&amp;lt;float&amp;gt; foo(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt; x, bool flag);&lt;/code&gt;, then its &lt;code&gt;Promise&lt;/code&gt; type is &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt;.</source>
          <target state="translated">Si la rutina se define como &lt;code&gt;task&amp;lt;float&amp;gt; foo(&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt; x, bool flag);&lt;/code&gt; , entonces su tipo de &lt;code&gt;Promise&lt;/code&gt; es &lt;code&gt;std::coroutine_traits&amp;lt;task&amp;lt;float&amp;gt;, std::string, bool&amp;gt;::promise_type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8ed628c0c3ef9224600ee8ab10e072d7456f4358" translate="yes" xml:space="preserve">
          <source>If the coroutine was suspended in the co_await expression, and is later resumed, the resume point is immediately before the call to &lt;code&gt;awaiter.await_resume()&lt;/code&gt;.</source>
          <target state="translated">Si la corutina se suspendi&amp;oacute; en la expresi&amp;oacute;n co_await y luego se reanuda, el punto de reanudaci&amp;oacute;n es inmediatamente anterior a la llamada a &lt;code&gt;awaiter.await_resume()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="779db0a2dceed4ce10fd8dad1f3fd5a2aa365ff9" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised.</source>
          <target state="translated">Si el resultado correcto es mayor que &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; o menor que &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , se &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c1e25624b3fd048578a45e9a3c4ec61bc91d80f" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, a domain error or a range error may occur.</source>
          <target state="translated">Si el resultado correcto es mayor que &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; o menor que &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , puede producirse un error de dominio o un error de rango.</target>
        </trans-unit>
        <trans-unit id="df721ce87be91a1d2a0670fee727bda1f6488296" translate="yes" xml:space="preserve">
          <source>If the correct result is greater than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; or smaller than &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt;, the return value is unspecified.</source>
          <target state="translated">Si el resultado correcto es mayor que &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MAX&lt;/a&gt;&lt;/code&gt; o menor que &lt;code&gt;&lt;a href=&quot;../../types/climits&quot;&gt;INT_MIN&lt;/a&gt;&lt;/code&gt; , el valor de retorno no se especifica.</target>
        </trans-unit>
        <trans-unit id="e57a705dd469f19d6863e23a81d83613f10c1c86" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt;, this function rounds to even in halfway cases (like &lt;code&gt;rint&lt;/code&gt;, but unlike &lt;code&gt;round&lt;/code&gt;).</source>
          <target state="translated">Si el modo de redondeo actual es &lt;code&gt;&lt;a href=&quot;../fenv/fe_round&quot;&gt;FE_TONEAREST&lt;/a&gt;&lt;/code&gt; , esta funci&amp;oacute;n se redondea incluso en casos intermedios (como &lt;code&gt;rint&lt;/code&gt; , pero a diferencia de &lt;code&gt;round&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e2333eb5beb6ae4621087ed67aea4b57771b1571" translate="yes" xml:space="preserve">
          <source>If the current rounding mode is...</source>
          <target state="translated">Si el modo de redondeo actual es...</target>
        </trans-unit>
        <trans-unit id="896aca99d0b416d865962f92c6c37d2f798c20b2" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the container is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">Si el tama&amp;ntilde;o actual es mayor que el &lt;code&gt;count&lt;/code&gt; , el contenedor se reduce a sus primeros elementos de &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c6fbeaf9e8910c2d4ff6f11b1e18360cddb4c17" translate="yes" xml:space="preserve">
          <source>If the current size is greater than &lt;code&gt;count&lt;/code&gt;, the string is reduced to its first &lt;code&gt;count&lt;/code&gt; elements.</source>
          <target state="translated">Si el tama&amp;ntilde;o actual es mayor que el &lt;code&gt;count&lt;/code&gt; , la cadena se reduce a sus primeros elementos de &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f352e4005a3a9b34a2f768d15d84aa23ea90cd3" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;,</source>
          <target state="translated">Si el tama&amp;ntilde;o actual es menor que el &lt;code&gt;count&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6f72d059786307ab4c08950a1fc590bdfbacc9a7" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional characters are appended.</source>
          <target state="translated">Si el tama&amp;ntilde;o actual es menor que el &lt;code&gt;count&lt;/code&gt; , se agregan caracteres adicionales.</target>
        </trans-unit>
        <trans-unit id="c289d28a9c0b1ae0f12bb49e019b21510591df99" translate="yes" xml:space="preserve">
          <source>If the current size is less than &lt;code&gt;count&lt;/code&gt;, additional elements are appended and initialized with copies of &lt;code&gt;value&lt;/code&gt;.</source>
          <target state="translated">Si el tama&amp;ntilde;o actual es menor que el &lt;code&gt;count&lt;/code&gt; , se agregan elementos adicionales y se inicializan con copias de &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="442e11214c1977140f19902972be104365029434" translate="yes" xml:space="preserve">
          <source>If the deallocation functions that were found are class-specific, size-unaware class-specific deallocation function (without a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is preferred over size-aware class-specific deallocation function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;)</source>
          <target state="translated">Si las funciones de desasignaci&amp;oacute;n que se encontraron son espec&amp;iacute;ficas de la clase, se prefiere la funci&amp;oacute;n de desasignaci&amp;oacute;n de la clase espec&amp;iacute;fica de tama&amp;ntilde;o (sin un par&amp;aacute;metro de tipo &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; ) sobre la funci&amp;oacute;n de desasignaci&amp;oacute;n de clase espec&amp;iacute;fica de tama&amp;ntilde;o (con un par&amp;aacute;metro de tipo &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="81a5d52aae1f78fba956c41a28dfa8ef8191aab3" translate="yes" xml:space="preserve">
          <source>If the declared return type is &lt;code&gt;auto&lt;/code&gt;, then the actual return type is &lt;a href=&quot;../utility/compare/common_comparison_category&quot;&gt;&lt;code&gt;std::common_comparison_category_t&amp;lt;Ms&amp;gt;&lt;/code&gt;&lt;/a&gt; where Ms is the list (possibly empty) of the types of base and member subobject and member array elements to be compared. This makes it easier to write cases where the return type non-trivially depends on the members, such as:</source>
          <target state="translated">Si el tipo de retorno declarado es &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tico , entonces el tipo de retorno real es &lt;a href=&quot;../utility/compare/common_comparison_category&quot;&gt; &lt;code&gt;std::common_comparison_category_t&amp;lt;Ms&amp;gt;&lt;/code&gt; &lt;/a&gt; donde Ms es la lista (posiblemente vac&amp;iacute;a) de los tipos de subobjetos de elementos b&amp;aacute;sicos y miembros y elementos de matriz de miembros que se van a comparar. Esto facilita la escritura de casos en los que el tipo de retorno no depende trivialmente de los miembros, como:</target>
        </trans-unit>
        <trans-unit id="a11e45a27e5f79c83df818f9c033db03c1a75a8a" translate="yes" xml:space="preserve">
          <source>If the default is specified for a template parameter of a primary class template , primary variable template, (since C++14)or alias template, each subsequent template parameter must have a default argument, except the very last one may be a template parameter pack. In a function template, there are no restrictions on the parameters that follow a default, and a parameter pack may be followed by more type parameters only if they have defaults or can be deduced from the function arguments.</source>
          <target state="translated">Si se especifica el valor por defecto para un parámetro de plantilla de una plantilla de clase primaria,de una plantilla de variable primaria,(desde C++14)o de una plantilla con alias,cada parámetro de plantilla subsiguiente debe tener un argumento por defecto,excepto que el último puede ser un paquete de parámetros de plantilla.En una plantilla de función,no hay restricciones en los parámetros que siguen a un valor por defecto,y un paquete de parámetros puede ir seguido de más parámetros de tipo sólo si tienen valores por defecto o pueden deducirse de los argumentos de la función.</target>
        </trans-unit>
        <trans-unit id="15dd06f6865462c19c491fa71c0e722074bd75af" translate="yes" xml:space="preserve">
          <source>If the definition of any object results in an object of &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt; or &lt;a href=&quot;abstract_class&quot;&gt;abstract class type&lt;/a&gt;, the program is ill-formed.</source>
          <target state="translated">Si la definici&amp;oacute;n de cualquier objeto resulta en un objeto de &lt;a href=&quot;incomplete_type&quot;&gt;tipo incompleto&lt;/a&gt; o de &lt;a href=&quot;abstract_class&quot;&gt;clase abstracta&lt;/a&gt; , el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="6627083d86de96fac39a9639172b8e5cae7776e7" translate="yes" xml:space="preserve">
          <source>If the destination type is &lt;code&gt;bool&lt;/code&gt;, this is a boolean conversion (see below).</source>
          <target state="translated">Si el tipo de destino es &lt;code&gt;bool&lt;/code&gt; , esta es una conversi&amp;oacute;n booleana (ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="bcab72b198f459511f9abd66295e0e372205290d" translate="yes" xml:space="preserve">
          <source>If the destination type is signed, the value does not change if the source integer can be represented in the destination type. Otherwise the result is implementation-defined(until C++20)the unique value of the destination type equal to the source value modulo 2n</source>
          <target state="translated">Si se firma el tipo de destino,el valor no cambia si el entero de la fuente puede representarse en el tipo de destino.En caso contrario,el resultado se define por implementación (hasta C++20)el valor único del tipo de destino igual al valor de origen módulo 2n</target>
        </trans-unit>
        <trans-unit id="926b449ff74682e6ecadc43082826a46200dfffc" translate="yes" xml:space="preserve">
          <source>If the destination type is unsigned, the resulting value is the smallest unsigned value equal to the source value &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt; modulo&lt;/a&gt; 2n</source>
          <target state="translated">Si el tipo de destino no tiene signo, el valor resultante es el valor sin signo m&amp;aacute;s peque&amp;ntilde;o igual al valor de origen &lt;a href=&quot;https://en.wikipedia.org/wiki/Modular_arithmetic&quot;&gt;m&amp;oacute;dulo&lt;/a&gt; 2n</target>
        </trans-unit>
        <trans-unit id="4a5a2a7675f65b9135eddde36e34f905978fe4fb" translate="yes" xml:space="preserve">
          <source>If the directory structure contains cycles, the end iterator may be unreachable.</source>
          <target state="translated">Si la estructura del directorio contiene ciclos,el iterador final puede ser inalcanzable.</target>
        </trans-unit>
        <trans-unit id="3337548ef4310df502c47a0607ce0d45303b5ba5" translate="yes" xml:space="preserve">
          <source>If the elements in the two ranges are equal, returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si los elementos en los dos rangos son iguales, devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1870c25fe91ccb4fdf9e04186e90172ccaa106e8" translate="yes" xml:space="preserve">
          <source>If the else part of the if statement is present and condition yields &lt;code&gt;false&lt;/code&gt; after conversion to &lt;code&gt;bool&lt;/code&gt;, statement-false is executed.</source>
          <target state="translated">Si la parte else de la declaraci&amp;oacute;n if est&amp;aacute; presente y la condici&amp;oacute;n produce &lt;code&gt;false&lt;/code&gt; despu&amp;eacute;s de la conversi&amp;oacute;n a &lt;code&gt;bool&lt;/code&gt; , se ejecuta la declaraci&amp;oacute;n false.</target>
        </trans-unit>
        <trans-unit id="f2f9989909780caf1535a25076ad27e3ad5b20b0" translate="yes" xml:space="preserve">
          <source>If the enclosing class declaration is, in turn, a class template, when a member template is defined outside of the class body, it takes two sets of template parameters: one for the enclosing class, and another one for itself:</source>
          <target state="translated">Si la declaración de clase adjunta es,a su vez,una plantilla de clase,cuando se define una plantilla de miembro fuera del cuerpo de la clase,se necesitan dos conjuntos de parámetros de plantilla:uno para la clase adjunta y otro para sí misma:</target>
        </trans-unit>
        <trans-unit id="fa860288a207ce4de20ba1818eb37f1d240c59f9" translate="yes" xml:space="preserve">
          <source>If the encoding is state-dependent (&lt;code&gt;encoding() == -1&lt;/code&gt;), then more than &lt;code&gt;max_length()&lt;/code&gt; external characters may be consumed to produce one internal character.</source>
          <target state="translated">Si la codificaci&amp;oacute;n depende del estado ( &lt;code&gt;encoding() == -1&lt;/code&gt; ), se pueden consumir m&amp;aacute;s de &lt;code&gt;max_length()&lt;/code&gt; caracteres externos para producir un car&amp;aacute;cter interno.</target>
        </trans-unit>
        <trans-unit id="63c81f2ab01c02567fbf73ffd81b990b4f235586" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid date is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">Si se alcanza el iterador final antes de leer una fecha v&amp;aacute;lida, la funci&amp;oacute;n establece &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; . Si se encuentra un error de an&amp;aacute;lisis, la funci&amp;oacute;n establece &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aae18db76ff682a209b370fc6276ae620d78597" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid month name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">Si se alcanza el iterador final antes de leer un nombre de mes v&amp;aacute;lido, la funci&amp;oacute;n establece &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; . Si se encuentra un error de an&amp;aacute;lisis, la funci&amp;oacute;n establece &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eed2547c74a6a3a462c75d24c54d56132c1d3935" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid value is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">Si se alcanza el iterador final antes de leer un valor v&amp;aacute;lido, la funci&amp;oacute;n establece &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; . Si se encuentra un error de an&amp;aacute;lisis, la funci&amp;oacute;n establece &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9920cfb6a997d965d21f9be654bb51f5b8757867" translate="yes" xml:space="preserve">
          <source>If the end iterator is reached before a valid weekday name is read, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If a parsing error is encountered, the function sets &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;.</source>
          <target state="translated">Si se alcanza el iterador final antes de leer un nombre de d&amp;iacute;a de la semana v&amp;aacute;lido, la funci&amp;oacute;n establece &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; . Si se encuentra un error de an&amp;aacute;lisis, la funci&amp;oacute;n establece &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56f8aef93d36921723ad214ce365f4585fbe9195" translate="yes" xml:space="preserve">
          <source>If the entity named by the (unqualified) identifier is a local entity, and would result in an intervening &lt;a href=&quot;lambda&quot;&gt;lambda expression&lt;/a&gt; capturing it by copy if it were named outside of an unevaluated operand in the declarative region in which the identifier appears, then the type of the expression is the type of a &lt;a href=&quot;operator_member_access&quot;&gt;class member access expression&lt;/a&gt; naming the non-static data member that would be declared for such a capture in the closure object of the innermost such intervening lambda expression.</source>
          <target state="translated">Si la entidad nombrada por el identificador (no calificado) es una entidad local, y dar&amp;iacute;a como resultado una &lt;a href=&quot;lambda&quot;&gt;expresi&amp;oacute;n lambda&lt;/a&gt; intermedia que la capturar&amp;iacute;a por copia si fuera nombrada fuera de un operando no evaluado en la regi&amp;oacute;n declarativa en la que aparece el identificador, entonces el tipo de la expresi&amp;oacute;n es el tipo de una &lt;a href=&quot;operator_member_access&quot;&gt;expresi&amp;oacute;n de acceso de miembro de clase que&lt;/a&gt; nombra al miembro de datos no est&amp;aacute;tico que se declarar&amp;iacute;a para dicha captura en el objeto de cierre de la expresi&amp;oacute;n lambda interpuesta m&amp;aacute;s &amp;iacute;ntima.</target>
        </trans-unit>
        <trans-unit id="dfdabf4aff6dc82f3c877f50307cf3a860280ed1" translate="yes" xml:space="preserve">
          <source>If the entity named is a &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;template parameter object&lt;/a&gt; for a template parameter of type &lt;code&gt;T&lt;/code&gt;, the type of the expression is &lt;code&gt;const T&lt;/code&gt;.</source>
          <target state="translated">Si la entidad con nombre es un &lt;a href=&quot;template_parameters#Non-type_template_parameter&quot;&gt;objeto de par&amp;aacute;metro de plantilla&lt;/a&gt; para un par&amp;aacute;metro de plantilla de tipo &lt;code&gt;T&lt;/code&gt; , el tipo de la expresi&amp;oacute;n es &lt;code&gt;const T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d94c16d2093f565827acd0baa83270e850862eaa" translate="yes" xml:space="preserve">
          <source>If the exception is thrown from a constructor that is invoked by a &lt;a href=&quot;new&quot;&gt;new-expression&lt;/a&gt;, the matching &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;deallocation function&lt;/a&gt; is called, if available.</source>
          <target state="translated">Si la excepci&amp;oacute;n se produce desde un constructor invocado por una &lt;a href=&quot;new&quot;&gt;nueva expresi&amp;oacute;n&lt;/a&gt; , se llama a la &lt;a href=&quot;../memory/new/operator_delete&quot;&gt;funci&amp;oacute;n de desasignaci&amp;oacute;n&lt;/a&gt; correspondiente , si est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="7c77baa68d29932853f92768b1f24a64502a012b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="translated">Si la ejecuci&amp;oacute;n del bucle debe continuar al final del cuerpo del bucle, la &lt;a href=&quot;continue&quot;&gt;instrucci&amp;oacute;n continue&lt;/a&gt; puede usarse como acceso directo.</target>
        </trans-unit>
        <trans-unit id="f8c4f280148d62bcff94e6cfcf459f791d957459" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be continued at the end of the loop body, a &lt;a href=&quot;continue&quot;&gt; continue statement&lt;/a&gt; can be used as shortcut.</source>
          <target state="translated">Si la ejecuci&amp;oacute;n del bucle debe continuar al final del cuerpo del bucle, se puede usar una &lt;a href=&quot;continue&quot;&gt;instrucci&amp;oacute;n de continuaci&amp;oacute;n&lt;/a&gt; como acceso directo.</target>
        </trans-unit>
        <trans-unit id="94e3914e819b4e9c6f38a7c7d3a8f66bfec35d72" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">Si la ejecuci&amp;oacute;n del ciclo necesita ser terminada en alg&amp;uacute;n momento, la &lt;a href=&quot;break&quot;&gt;declaraci&amp;oacute;n de interrupci&amp;oacute;n&lt;/a&gt; puede usarse como declaraci&amp;oacute;n de terminaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2cd72081fe396e16bec08079f951e2582fddd18b" translate="yes" xml:space="preserve">
          <source>If the execution of the loop needs to be terminated at some point, a &lt;a href=&quot;break&quot;&gt; break statement&lt;/a&gt; can be used as terminating statement.</source>
          <target state="translated">Si la ejecuci&amp;oacute;n de las necesidades de bucle a ser terminado en alg&amp;uacute;n momento, una &lt;a href=&quot;break&quot;&gt;sentencia break&lt;/a&gt; se puede utilizar como declaraci&amp;oacute;n de terminaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a63e54974439d0c04ddba7efece25f14eb6ccc71" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, Source&amp;gt;{}(t)&lt;/code&gt; is well-formed, returns the result of that expression.</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;clock_time_conversion&quot;&gt;std::chrono::clock_time_conversion&lt;/a&gt;&amp;lt;Dest, Source&amp;gt;{}(t)&lt;/code&gt; est&amp;aacute; bien formada, devuelve el resultado de esa expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5c56737809ca6e1f51c00db974474519c25494a7" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; has the form &lt;code&gt;PA-&amp;gt;B&lt;/code&gt; or &lt;code&gt;A.B&lt;/code&gt; (where A has class type cv T), then &lt;code&gt;B&lt;/code&gt; is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; as a member function of &lt;code&gt;T&lt;/code&gt;. The function declarations found by that lookup are the candidate functions. The argument list for the purpose of overload resolution has the implied object argument of type cv T.</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;E&lt;/code&gt; tiene la forma &lt;code&gt;PA-&amp;gt;B&lt;/code&gt; o &lt;code&gt;A.B&lt;/code&gt; (en la que A tiene clase tipo cv T), entonces &lt;code&gt;B&lt;/code&gt; es &lt;a href=&quot;lookup&quot;&gt;mirado&lt;/a&gt; como una funci&amp;oacute;n miembro de &lt;code&gt;T&lt;/code&gt; . Las declaraciones de funci&amp;oacute;n encontradas por esa b&amp;uacute;squeda son las funciones candidatas. La lista de argumentos para la resoluci&amp;oacute;n de sobrecarga tiene el argumento de objeto impl&amp;iacute;cito de tipo cv T.</target>
        </trans-unit>
        <trans-unit id="a23e92522ea5793ad90d37f08a288000d14cacdf" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;E&lt;/code&gt; is a &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;primary expression&lt;/a&gt;, the name is &lt;a href=&quot;lookup&quot;&gt;looked up&lt;/a&gt; following normal rules for function calls (which may involve &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt;). The function declarations found by this lookup are (due to the way lookup works) either:</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;E&lt;/code&gt; es una &lt;a href=&quot;expressions#Primary_expressions&quot;&gt;expresi&amp;oacute;n primaria&lt;/a&gt; , el nombre se &lt;a href=&quot;lookup&quot;&gt;busca&lt;/a&gt; siguiendo las reglas normales para las llamadas a funciones (que pueden involucrar &lt;a href=&quot;adl&quot;&gt;ADL&lt;/a&gt; ). Las declaraciones de funci&amp;oacute;n encontradas por esta b&amp;uacute;squeda son (debido a la forma en que funciona la b&amp;uacute;squeda):</target>
        </trans-unit>
        <trans-unit id="69f0efd4d241778b0ab12aa15f7c0cba8b51c323" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::partial_ordering&lt;/code&gt;, returns that result.</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; est&amp;aacute; bien formada y su resultado es convertible a &lt;code&gt;std::partial_ordering&lt;/code&gt; , devuelve ese resultado.</target>
        </trans-unit>
        <trans-unit id="a3ce312862a56044d6ce5fd6d18b3cc810505779" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::strong_equality&lt;/code&gt;, returns that result.</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; est&amp;aacute; bien formada y su resultado es convertible a &lt;code&gt;std::strong_equality&lt;/code&gt; , devuelve ese resultado.</target>
        </trans-unit>
        <trans-unit id="2791850e6413d1fb089fa268221ec13c44284426" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_equality&lt;/code&gt;, returns that result.</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; est&amp;aacute; bien formada y su resultado es convertible a &lt;code&gt;std::weak_equality&lt;/code&gt; , devuelve ese resultado.</target>
        </trans-unit>
        <trans-unit id="6562c1886aa8be17523dc870268a8b013d14d9d0" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed and its result is convertible to &lt;code&gt;std::weak_ordering&lt;/code&gt;, returns that result.</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; est&amp;aacute; bien formada y su resultado es convertible a &lt;code&gt;std::weak_ordering&lt;/code&gt; , devuelve ese resultado.</target>
        </trans-unit>
        <trans-unit id="82d3a34faff20e40c4069465ee795568784e5d84" translate="yes" xml:space="preserve">
          <source>If the expression &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; is well-formed, returns its result</source>
          <target state="translated">Si la expresi&amp;oacute;n &lt;code&gt;a &amp;lt;=&amp;gt; b&lt;/code&gt; est&amp;aacute; bien formada, devuelve su resultado</target>
        </trans-unit>
        <trans-unit id="a8ccf3f902bab3475c2f0d81bd04eb2a781e9731" translate="yes" xml:space="preserve">
          <source>If the expression above is a prvalue, the awaiter object is a temporary &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; from it. Otherwise, if the expression above is an glvalue, the awaiter object is the object to which it refers.</source>
          <target state="translated">Si la expresi&amp;oacute;n anterior es un prvalue, el objeto camarero se &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;materializa&lt;/a&gt; temporalmente a partir de &amp;eacute;l. De lo contrario, si la expresi&amp;oacute;n anterior es un valor gl, el objeto camarero es el objeto al que se refiere.</target>
        </trans-unit>
        <trans-unit id="84b2a486468566117d378873877349b38e54a1e0" translate="yes" xml:space="preserve">
          <source>If the expression evaluates to nonzero value, the controlled code block is included and skipped otherwise.</source>
          <target state="translated">Si la expresión se evalúa a un valor distinto de cero,se incluye el bloque de código controlado y se salta en caso contrario.</target>
        </trans-unit>
        <trans-unit id="f8f246002c66268584002c4ed48b13695ad83d46" translate="yes" xml:space="preserve">
          <source>If the expression is a non-void prvalue (after any lvalue-to-rvalue conversion that might have taken place), &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;temporary materialization&lt;/a&gt; occurs.</source>
          <target state="translated">Si la expresi&amp;oacute;n es un prvalue no nulo (despu&amp;eacute;s de cualquier conversi&amp;oacute;n de lvalue-to-rvalue que podr&amp;iacute;a haber tenido lugar), &lt;a href=&quot;implicit_cast#Temporary_materialization&quot;&gt;se&lt;/a&gt; produce una materializaci&amp;oacute;n temporal .</target>
        </trans-unit>
        <trans-unit id="7329a5c8ff286b9d0a4e59efe0069989f5cd5e91" translate="yes" xml:space="preserve">
          <source>If the expression used as init or as pack has an operator with precedence below cast at the top level, it can be parenthesized:</source>
          <target state="translated">Si la expresión utilizada como init o como pack tiene un operador con precedencia por debajo del lanzamiento en el nivel superior,se puede poner entre paréntesis:</target>
        </trans-unit>
        <trans-unit id="a2b1b61632e47d98b991cfabb43ddaa1fc1c9b3b" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end of file condition, additionally sets the</source>
          <target state="translated">Si el fallo ha sido causado por la condición de fin de archivo,adicionalmente establece el</target>
        </trans-unit>
        <trans-unit id="90c9cca36bdb9f6f7d9748c18430b538e7979538" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by end-of-file condition, additionally sets the</source>
          <target state="translated">Si el fallo ha sido causado por una condición de fin de archivo,adicionalmente establece el</target>
        </trans-unit>
        <trans-unit id="994d9bf8337b9cacbb5385430d81add1cb5bd997" translate="yes" xml:space="preserve">
          <source>If the failure has been caused by some other error, sets the</source>
          <target state="translated">Si el fallo ha sido causado por algún otro error,establece el</target>
        </trans-unit>
        <trans-unit id="40e036169518dee5621368e67a2b9be1ab5fb193" translate="yes" xml:space="preserve">
          <source>If the file is currently open by the current or another process, the behavior of this function is implementation-defined (in particular, POSIX systems unlink the file name, although the file system space is not reclaimed even if this was the last hardlink to the file until the last running process closes the file, Windows does not allow the file to be deleted).</source>
          <target state="translated">Si el archivo está actualmente abierto por el proceso actual o por otro proceso,el comportamiento de esta función está definido por la implementación (en particular,los sistemas POSIX desvinculan el nombre del archivo,aunque el espacio del sistema de archivos no se recupera aunque éste haya sido el último enlace duro del archivo hasta que el último proceso en ejecución cierre el archivo,Windows no permite que el archivo sea eliminado).</target>
        </trans-unit>
        <trans-unit id="f8a3927438032bc9c246a1d6cab93f5a9e333a4a" translate="yes" xml:space="preserve">
          <source>If the file is not open (&lt;code&gt;is_open()==false&lt;/code&gt;, this function returns &lt;code&gt;Traits::eof()&lt;/code&gt; immediately.</source>
          <target state="translated">Si el archivo no est&amp;aacute; abierto ( &lt;code&gt;is_open()==false&lt;/code&gt; , esta funci&amp;oacute;n devuelve &lt;code&gt;Traits::eof()&lt;/code&gt; inmediatamente.</target>
        </trans-unit>
        <trans-unit id="a0aabb532f13e04a1724903ba0225e1eed159600" translate="yes" xml:space="preserve">
          <source>If the file is open for reading, updates the get area if necessary.</source>
          <target state="translated">Si el archivo está abierto para su lectura,actualiza el área de obtención si es necesario.</target>
        </trans-unit>
        <trans-unit id="b7298526d7f2b5594b5589a131851e279edeaa84" translate="yes" xml:space="preserve">
          <source>If the file is open for writing, first writes the put area and any unshift sequences required by the currently imbued locale, using &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el archivo est&amp;aacute; abierto para escritura, primero escribe el &amp;aacute;rea de colocaci&amp;oacute;n y cualquier secuencia de desplazamiento requerida por el entorno local actualmente imbuido, utilizando &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6046f5bcc7e057f2daa45b27fc1473dbcccb2e9" translate="yes" xml:space="preserve">
          <source>If the file size is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::file_size(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::file_size(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">Si el tama&amp;ntilde;o del archivo se almacena en cach&amp;eacute; en esta &lt;code&gt;directory_entry&lt;/code&gt; , devuelve el valor almacenado en cach&amp;eacute;. De lo contrario, devuelve &lt;code&gt;std::filesystem::file_size(path())&lt;/code&gt; o &lt;code&gt;std::filesystem::file_size(path(), ec)&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="fc2139afc05136a3d64cc794796b08e516434f34" translate="yes" xml:space="preserve">
          <source>If the filename is one of the special filesystem components dot or dot-dot, or if it has no periods, the function returns the entire &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si el nombre de archivo es uno de los componentes especiales del sistema de archivos dot o dot-dot, o si no tiene puntos, la funci&amp;oacute;n devuelve el &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; completo () .</target>
        </trans-unit>
        <trans-unit id="06579240cba49b57e27dc71348315d2cf9aab0ac" translate="yes" xml:space="preserve">
          <source>If the final overrider of a &lt;code&gt;transaction_safe_dynamic&lt;/code&gt; function is not declared &lt;code&gt;transaction_safe&lt;/code&gt;, calling it in an atomic block is undefined behavior.</source>
          <target state="translated">Si la anulaci&amp;oacute;n final de una funci&amp;oacute;n &lt;code&gt;transaction_safe_dynamic&lt;/code&gt; no se declara &lt;code&gt;transaction_safe&lt;/code&gt; , llamarla en un bloque at&amp;oacute;mico es un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="7d41e6a07f9e559a56f8b06959d59178f0f1531d" translate="yes" xml:space="preserve">
          <source>If the first character in the filename is a period, that period is ignored (a filename like &quot;.profile&quot; is not treated as an extension).</source>
          <target state="translated">Si el primer carácter del nombre de archivo es un punto,ese punto se ignora (un nombre de archivo como &quot;.profile&quot; no se trata como una extensión).</target>
        </trans-unit>
        <trans-unit id="6020291574132d5834e014d6c7f58d404fb0a67b" translate="yes" xml:space="preserve">
          <source>If the first character of the set is &lt;code&gt;^&lt;/code&gt;, then all characters not in the set are matched. If the set begins with &lt;code&gt;]&lt;/code&gt; or &lt;code&gt;^]&lt;/code&gt; then the &lt;code&gt;]&lt;/code&gt; character is also included into the set. It is implementation-defined whether the character &lt;code&gt;-&lt;/code&gt; in the non-initial position in the scanset may be indicating a range, as in &lt;code&gt;[0-9]&lt;/code&gt;. If width specifier is used, matches only up to</source>
          <target state="translated">Si el primer car&amp;aacute;cter del conjunto es &lt;code&gt;^&lt;/code&gt; , entonces todos los caracteres que no est&amp;aacute;n en el conjunto coinciden. Si el conjunto comienza con &lt;code&gt;]&lt;/code&gt; o &lt;code&gt;^]&lt;/code&gt; , el car&amp;aacute;cter &lt;code&gt;]&lt;/code&gt; tambi&amp;eacute;n se incluye en el conjunto. Se define la implementaci&amp;oacute;n si el car&amp;aacute;cter &lt;code&gt;-&lt;/code&gt; en la posici&amp;oacute;n no inicial en el conjunto de exploraci&amp;oacute;n, puede estar indicando un rango, como en &lt;code&gt;[0-9]&lt;/code&gt; . Si se utiliza el especificador de ancho, coincide solo hasta</target>
        </trans-unit>
        <trans-unit id="87a6fda77086306a8c7bdf456c9e29f296b5945d" translate="yes" xml:space="preserve">
          <source>If the first character of the string returned by &lt;code&gt;mp.positive_sign()&lt;/code&gt; or &lt;code&gt;mp.negative_sign()&lt;/code&gt; is found in the &lt;code&gt;money_base::sign&lt;/code&gt; position of the formatting pattern, it is consumed, and the rest of the characters in that string are expected and consumed after all other components of the monetary value. If both &lt;code&gt;mp.positive_sign()&lt;/code&gt; and &lt;code&gt;mp.negative_sign()&lt;/code&gt; are non-empty, the sign is required and must match the first character of one of these strings. If one of theses strings is empty, the sign is optional (and if it is absent, the sign of the result corresponds to the string that was empty). If both strings are empty, or have the same first character, the result is given the positive sign. If the output parameter is a string (&lt;code&gt;digits&lt;/code&gt;) and the result is negative, the value &lt;code&gt;ct.widen('-')&lt;/code&gt; is stored as the first character of the result.</source>
          <target state="translated">Si el primer car&amp;aacute;cter de la cadena devuelto por &lt;code&gt;mp.positive_sign()&lt;/code&gt; o &lt;code&gt;mp.negative_sign()&lt;/code&gt; se encuentra en la posici&amp;oacute;n &lt;code&gt;money_base::sign&lt;/code&gt; del patr&amp;oacute;n de formato, se consume y se espera el resto de los caracteres en esa cadena y consumido despu&amp;eacute;s de todos los dem&amp;aacute;s componentes del valor monetario. Si tanto &lt;code&gt;mp.positive_sign()&lt;/code&gt; como &lt;code&gt;mp.negative_sign()&lt;/code&gt; no est&amp;aacute;n vac&amp;iacute;os, el signo es obligatorio y debe coincidir con el primer car&amp;aacute;cter de una de estas cadenas. Si una de estas cadenas est&amp;aacute; vac&amp;iacute;a, el signo es opcional (y si est&amp;aacute; ausente, el signo del resultado corresponde a la cadena que estaba vac&amp;iacute;a). Si ambas cadenas est&amp;aacute;n vac&amp;iacute;as o tienen el mismo primer car&amp;aacute;cter, el resultado recibe el signo positivo. Si el par&amp;aacute;metro de salida es una cadena ( &lt;code&gt;digits&lt;/code&gt; ) y el resultado es negativo, el valor &lt;code&gt;ct.widen('-')&lt;/code&gt; se almacena como el primer car&amp;aacute;cter del resultado.</target>
        </trans-unit>
        <trans-unit id="6d83faa70c2aba93e1941e43de6bbfe2385cd57c" translate="yes" xml:space="preserve">
          <source>If the flag has static &lt;a href=&quot;../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this &lt;a href=&quot;../language/initialization#Static_initialization&quot;&gt;initialization is static&lt;/a&gt;.</source>
          <target state="translated">Si el indicador tiene &lt;a href=&quot;../language/storage_duration#Storage_duration&quot;&gt;una duraci&amp;oacute;n de almacenamiento&lt;/a&gt; est&amp;aacute;tico , esta &lt;a href=&quot;../language/initialization#Static_initialization&quot;&gt;inicializaci&amp;oacute;n es est&amp;aacute;tica&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0aca185ec9eaa4817332d6d1708fa168e08a203c" translate="yes" xml:space="preserve">
          <source>If the floating literal begins with the character sequence &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the floating literal is a</source>
          <target state="translated">Si el literal flotante comienza con la secuencia de caracteres &lt;code&gt;0x&lt;/code&gt; o &lt;code&gt;0X&lt;/code&gt; , el literal flotante es un</target>
        </trans-unit>
        <trans-unit id="1fc39f622f213adb1f2c8d85a8aa6d829ea3b127" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null, and the parsed offset will be subtracted from the parsed timestamp before the difference is assigned to &lt;code&gt;tp&lt;/code&gt;.</source>
          <target state="translated">Si se utiliza el especificador de formato &lt;code&gt;%Z&lt;/code&gt; y se analiza correctamente, el valor analizado se asigna a &lt;code&gt;*abbrev&lt;/code&gt; si &lt;code&gt;abbrev&lt;/code&gt; no es nulo. Si el especificador de formato &lt;code&gt;%z&lt;/code&gt; o una variante modificada se utiliza y analiza correctamente, el valor analizado se asigna a &lt;code&gt;*offset&lt;/code&gt; si el &lt;code&gt;offset&lt;/code&gt; no es nulo, y el offset analizado se restar&amp;aacute; de la marca de tiempo analizada antes de que la diferencia se asigne a &lt;code&gt;tp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e503e2359ab45b0919fcc779613a87ba2c630429" translate="yes" xml:space="preserve">
          <source>If the format specifier &lt;code&gt;%Z&lt;/code&gt; is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*abbrev&lt;/code&gt; if &lt;code&gt;abbrev&lt;/code&gt; is not null. If the format specifier &lt;code&gt;%z&lt;/code&gt; or a modified variant is used and successfully parsed, the parsed value is assigned to &lt;code&gt;*offset&lt;/code&gt; if &lt;code&gt;offset&lt;/code&gt; is not null.</source>
          <target state="translated">Si se utiliza el especificador de formato &lt;code&gt;%Z&lt;/code&gt; y se analiza correctamente, el valor analizado se asigna a &lt;code&gt;*abbrev&lt;/code&gt; si &lt;code&gt;abbrev&lt;/code&gt; no es nulo. Si el especificador de formato &lt;code&gt;%z&lt;/code&gt; o una variante modificada se utiliza y analiza correctamente, el valor analizado se asigna a &lt;code&gt;*offset&lt;/code&gt; si el &lt;code&gt;offset&lt;/code&gt; no es nulo.</target>
        </trans-unit>
        <trans-unit id="2ce235bdf9bf338e07e75bb2fe881d619ae23200" translate="yes" xml:space="preserve">
          <source>If the function &lt;code&gt;Derived::f&lt;/code&gt; overrides a function &lt;code&gt;Base::f&lt;/code&gt;, their return types must either be the same or be</source>
          <target state="translated">Si la funci&amp;oacute;n &lt;code&gt;Derived::f&lt;/code&gt; anula una funci&amp;oacute;n &lt;code&gt;Base::f&lt;/code&gt; , sus tipos de retorno deben ser los mismos o ser</target>
        </trans-unit>
        <trans-unit id="857c1e56c78b3e56396b067396f56e801e6dd2c3" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">Si el operador de llamada de funci&amp;oacute;n de la especializaci&amp;oacute;n &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; llama a un operador integrado que compara punteros, produce un orden total estricto incluso si el &lt;code&gt;operator&amp;gt;&lt;/code&gt; integrado &amp;gt; no lo hace. Este estricto orden total es coherente entre las especializaciones &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; y &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; , y tambi&amp;eacute;n es coherente con el orden parcial impuesta por los operadores integrados correspondientes.</target>
        </trans-unit>
        <trans-unit id="efb23e76ae6241c0d68a489477442012c4a6ba54" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;gt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">Si el operador de llamada de funci&amp;oacute;n de la especializaci&amp;oacute;n &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; llama a un operador incorporado que compara punteros, produce un orden total estricto incluso si el &lt;code&gt;operator&amp;gt;=&lt;/code&gt; incorporado &amp;gt; = no lo hace. Este estricto orden total es coherente entre las especializaciones &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; y &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; , y tambi&amp;eacute;n es coherente con el orden parcial impuesta por los operadores integrados correspondientes.</target>
        </trans-unit>
        <trans-unit id="7d4d6d78f770aad39153c1ff4080cd8ea8e3ca96" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">Si el operador de llamada de funci&amp;oacute;n de la especializaci&amp;oacute;n &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; llama a un operador integrado que compara punteros, produce un orden total estricto incluso si el &lt;code&gt;operator&amp;lt;&lt;/code&gt; integrado &amp;lt; no lo hace. Este estricto orden total es coherente entre las especializaciones &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; y &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; , y tambi&amp;eacute;n es coherente con el orden parcial impuesta por los operadores integrados correspondientes.</target>
        </trans-unit>
        <trans-unit id="40559e5060a6bc4c31508f6386e2b42c2555e25e" translate="yes" xml:space="preserve">
          <source>If the function call operator of the specialization &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; calls a built-in operator comparing pointers, it yields a strict total order even if the built-in &lt;code&gt;operator&amp;lt;=&lt;/code&gt; does not. This strict total order is consistent among the specializations &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt;, &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt;, and is also consistent with the partial order imposed by the corresponding built-in operators.</source>
          <target state="translated">Si el operador de llamada de funci&amp;oacute;n de la especializaci&amp;oacute;n &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; llama a un operador incorporado que compara punteros, produce un orden total estricto incluso si el &lt;code&gt;operator&amp;lt;=&lt;/code&gt; incorporado &amp;lt;= no lo hace. Este estricto orden total es coherente entre las especializaciones &lt;code&gt;std::less&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::greater&amp;lt;void&amp;gt;&lt;/code&gt; , &lt;code&gt;std::less_equal&amp;lt;void&amp;gt;&lt;/code&gt; y &lt;code&gt;std::greater_equal&amp;lt;void&amp;gt;&lt;/code&gt; , y tambi&amp;eacute;n es coherente con el orden parcial impuesta por los operadores integrados correspondientes.</target>
        </trans-unit>
        <trans-unit id="6d049b3d36607639d24052288370b34cd4ee531e" translate="yes" xml:space="preserve">
          <source>If the function extracts no characters (e.g. if &lt;code&gt;count &amp;lt; 1&lt;/code&gt;), &lt;code&gt;setstate(failbit)&lt;/code&gt; is executed.</source>
          <target state="translated">Si la funci&amp;oacute;n no extrae caracteres (por ejemplo, si &lt;code&gt;count &amp;lt; 1&lt;/code&gt; ), se &lt;code&gt;setstate(failbit)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f3778a28625a42b16a2c98400bf20b26542a73dd" translate="yes" xml:space="preserve">
          <source>If the function is called when no exception is being handled, an empty &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Si se llama a la funci&amp;oacute;n cuando no se maneja ninguna excepci&amp;oacute;n, se devuelve un &lt;code&gt;&lt;a href=&quot;exception_ptr&quot;&gt;std::exception_ptr&lt;/a&gt;&lt;/code&gt; vac&amp;iacute;o .</target>
        </trans-unit>
        <trans-unit id="251005437285fe4170728bd7ef6498ade0a544a1" translate="yes" xml:space="preserve">
          <source>If the function is overloaded, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; takes place first, and the program is only ill-formed if the deleted function was selected.</source>
          <target state="translated">Si la funci&amp;oacute;n est&amp;aacute; sobrecargada, la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; tiene lugar primero, y el programa solo est&amp;aacute; mal formado si se seleccion&amp;oacute; la funci&amp;oacute;n eliminada.</target>
        </trans-unit>
        <trans-unit id="0813887879f4315c7f626d21875c1875367fd78d" translate="yes" xml:space="preserve">
          <source>If the function name names a function template, then, first, &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; is done, and if it succeeds, it produces a single template specialization which is added to the set of overloads to consider. All functions whose associated &lt;a href=&quot;constraints&quot;&gt;constraints&lt;/a&gt; are not satisfied are dropped from the set.(since C++20) If more than one function from the set matches the target, and at least one function is non-template, the template specializations are eliminated from consideration. For any pair of non-template functions where one is &lt;a href=&quot;constraints&quot;&gt;more constrained&lt;/a&gt; than another, the less constrained function is dropped from the set(since C++20). If all remaining candidates are template specializations, &lt;a href=&quot;partial_specialization&quot;&gt;less specialized&lt;/a&gt; ones are removed if more specialized are available. If more than one candidate remains after the removals, the program is ill-formed.</source>
          <target state="translated">Si el nombre de la funci&amp;oacute;n nombra una plantilla de funci&amp;oacute;n, entonces, primero, se realiza la &lt;a href=&quot;template_argument_deduction&quot;&gt;deducci&amp;oacute;n del argumento de la plantilla&lt;/a&gt; , y si tiene &amp;eacute;xito, produce una especializaci&amp;oacute;n de plantilla &amp;uacute;nica que se agrega al conjunto de sobrecargas a tener en cuenta. Todas las funciones cuyas &lt;a href=&quot;constraints&quot;&gt;restricciones&lt;/a&gt; asociadas no se satisfacen se eliminan del conjunto. (Desde C ++ 20) Si m&amp;aacute;s de una funci&amp;oacute;n del conjunto coincide con el objetivo, y al menos una funci&amp;oacute;n no es plantilla, las especializaciones de plantilla se eliminan de la consideraci&amp;oacute;n . Para cualquier par de funciones no de plantilla donde una est&amp;aacute; &lt;a href=&quot;constraints&quot;&gt;m&amp;aacute;s restringida&lt;/a&gt; que otra, la funci&amp;oacute;n menos restringida se elimina del conjunto (desde C ++ 20). Si todos los candidatos restantes son especializaciones de plantilla,&lt;a href=&quot;partial_specialization&quot;&gt; menos especializados&lt;/a&gt;se eliminan si hay m&amp;aacute;s especializados disponibles. Si queda m&amp;aacute;s de un candidato despu&amp;eacute;s de los retiros, el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="22b71c40978885e6386333f0b2f28d4de5c561ce" translate="yes" xml:space="preserve">
          <source>If the function selected by overload resolution does not exchange the values referenced by &lt;code&gt;t&lt;/code&gt; and &lt;code&gt;u&lt;/code&gt;, the program is ill-formed; no diagnostic required.</source>
          <target state="translated">Si la funci&amp;oacute;n seleccionada por resoluci&amp;oacute;n de sobrecarga no intercambia los valores referenciados por &lt;code&gt;t&lt;/code&gt; y &lt;code&gt;u&lt;/code&gt; , el programa est&amp;aacute; mal formado; No se requiere diagn&amp;oacute;stico.</target>
        </trans-unit>
        <trans-unit id="93d41cd28845eed34b17adb4d10684f1b1c26d1d" translate="yes" xml:space="preserve">
          <source>If the function that called &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; has exited, the behavior is undefined (in other words, only long jumps up the call stack are allowed).</source>
          <target state="translated">Si la funci&amp;oacute;n que llam&amp;oacute; &lt;code&gt;&lt;a href=&quot;setjmp&quot;&gt;setjmp&lt;/a&gt;&lt;/code&gt; ha salido, el comportamiento es indefinido (en otras palabras, solo se permiten saltos largos en la pila de llamadas).</target>
        </trans-unit>
        <trans-unit id="532af6d794823602f1906bb8fd26e75deeabc0c7" translate="yes" xml:space="preserve">
          <source>If the function throws an exception of the type not listed in its exception specification, the function &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is called. The default function calls &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;, but it may be replaced by a user-provided function (via &lt;code&gt;&lt;a href=&quot;../error/exception/set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt;) which may call &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; or throw an exception. If the exception thrown from &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; is accepted by the exception specification, stack unwinding continues as usual. If it isn't, but &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is allowed by the exception specification, &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; is thrown. Otherwise, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Si la funci&amp;oacute;n arroja una excepci&amp;oacute;n del tipo que no figura en su especificaci&amp;oacute;n de excepci&amp;oacute;n, se llama a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; . La funci&amp;oacute;n predeterminada llama a &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; , pero puede ser reemplazada por una funci&amp;oacute;n proporcionada por el usuario (a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;../error/exception/set_unexpected&quot;&gt;std::set_unexpected&lt;/a&gt;&lt;/code&gt; ) que puede llamar a &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; o lanzar una excepci&amp;oacute;n. Si la excepci&amp;oacute;n lanzada desde &lt;code&gt;&lt;a href=&quot;../error/exception/unexpected&quot;&gt;std::unexpected&lt;/a&gt;&lt;/code&gt; es aceptada por la especificaci&amp;oacute;n de excepci&amp;oacute;n, el desbobinado de la pila contin&amp;uacute;a como de costumbre. Si no es as&amp;iacute;, pero &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; est&amp;aacute; permitido por la especificaci&amp;oacute;n de excepci&amp;oacute;n, &lt;code&gt;&lt;a href=&quot;../error/bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; es lanzada. De lo contrario,se llama &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4bb1179760bc730c31b7e350c9e316f8b5d5256" translate="yes" xml:space="preserve">
          <source>If the function-try-block is on a delegating constructor, which called a non-delegating constructor that completed successfully, but then the body of the delegating constructor throws, the destructor of this object will be completed before any catch clauses of the function-try-block are entered.</source>
          <target state="translated">Si el bloque de prueba de la función está en un constructor delegado,el cual llamó a un constructor no delegado que completó con éxito,pero luego el cuerpo del constructor delegado lanza,el destructor de este objeto se completará antes de que se introduzcan las cláusulas de captura del bloque de prueba de la función.</target>
        </trans-unit>
        <trans-unit id="7500ebfb29c88826fb63f492df6d76905a9569c0" translate="yes" xml:space="preserve">
          <source>If the get area is empty, calls &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; to determine the number of bytes available in the associated character sequence. In this case, the value returned is the number of bytes that can be extracted from the buffer while it's guaranteed that &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; would not return &lt;code&gt;Traits::eof&lt;/code&gt;.</source>
          <target state="translated">Si el &amp;aacute;rea de obtenci&amp;oacute;n est&amp;aacute; vac&amp;iacute;a, las llamadas &lt;code&gt;&lt;a href=&quot;showmanyc&quot;&gt;showmanyc()&lt;/a&gt;&lt;/code&gt; para determinar la cantidad de bytes disponibles en la secuencia de caracteres asociada. En este caso, el valor devuelto es el n&amp;uacute;mero de bytes que se pueden extraer del b&amp;uacute;fer mientras se garantiza que &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; no devolver&amp;aacute; &lt;code&gt;Traits::eof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b3eec597fe44d789a14bb34434aa90dd5be188a" translate="yes" xml:space="preserve">
          <source>If the implementation cannot parallelize or vectorize (e.g. due to lack of resources), all standard execution policies can fall back to sequential execution.</source>
          <target state="translated">Si la aplicación no puede establecer un paralelismo o vectorizar (por ejemplo,debido a la falta de recursos),todas las políticas de ejecución estándar pueden recaer en la ejecución secuencial.</target>
        </trans-unit>
        <trans-unit id="1d83c11796c2c1e3f318ffcc89e81bbd5f8b11e8" translate="yes" xml:space="preserve">
          <source>If the implementation does not support floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to a positive value that is guaranteed to overflow a &lt;code&gt;float&lt;/code&gt; at compile time, and the use of this macro generates a compiler warning.</source>
          <target state="translated">Si la implementaci&amp;oacute;n no admite infinitos de punto flotante, la macro &lt;code&gt;INFINITY&lt;/code&gt; se expande a un valor positivo que se garantiza que desbordar&amp;aacute; un &lt;code&gt;float&lt;/code&gt; en el momento de la compilaci&amp;oacute;n, y el uso de esta macro genera una advertencia del compilador.</target>
        </trans-unit>
        <trans-unit id="c2a825970a15face4ff4ecff0110e20adedc7e9c" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires a call to &lt;code&gt;new&lt;/code&gt; and the call fails, the returned pointer will hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la implementaci&amp;oacute;n de esta funci&amp;oacute;n requiere una llamada a &lt;code&gt;new&lt;/code&gt; y la llamada falla, el puntero devuelto contendr&amp;aacute; una referencia a una instancia de &lt;code&gt;&lt;a href=&quot;../memory/new/bad_alloc&quot;&gt;std::bad_alloc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="026f63aebd84e1c965f7e8366d68af982aae2ce8" translate="yes" xml:space="preserve">
          <source>If the implementation of this function requires copying the captured exception object and its copy constructor throws an exception, the returned pointer will hold a reference to the exception thrown. If the copy constructor of the thrown exception object also throws, the returned pointer may hold a reference to an instance of &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; to break the endless loop.</source>
          <target state="translated">Si la implementaci&amp;oacute;n de esta funci&amp;oacute;n requiere copiar el objeto de excepci&amp;oacute;n capturado y su constructor de copia arroja una excepci&amp;oacute;n, el puntero devuelto tendr&amp;aacute; una referencia a la excepci&amp;oacute;n lanzada. Si el constructor de copia del objeto de excepci&amp;oacute;n lanzado tambi&amp;eacute;n se lanza, el puntero devuelto puede contener una referencia a una instancia de &lt;code&gt;&lt;a href=&quot;bad_exception&quot;&gt;std::bad_exception&lt;/a&gt;&lt;/code&gt; para romper el bucle sin fin.</target>
        </trans-unit>
        <trans-unit id="19ffe219703efe6527e00547f4a8cca5d22a9042" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),</source>
          <target state="translated">Si la implementación soporta la aritmética de punto flotante del IEEE (IEC 60559),</target>
        </trans-unit>
        <trans-unit id="288c402c66673ce9a5009971c355fc8223b75acd" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::rint&lt;/code&gt; function:</source>
          <target state="translated">Si la implementaci&amp;oacute;n admite aritm&amp;eacute;tica de coma flotante IEEE (IEC 60559), para la funci&amp;oacute;n &lt;code&gt;std::rint&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0958ac9ba873e345e2bdc636b948c447e2e03547" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559),   For the &lt;code&gt;std::round&lt;/code&gt; function:</source>
          <target state="translated">Si la implementaci&amp;oacute;n admite aritm&amp;eacute;tica de coma flotante IEEE (IEC 60559), para el &lt;code&gt;std::round&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c7685e11635ec992c012cd0e03140bd9ce1479a3" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic (IEC 60559), &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; is required to be non-zero.</source>
          <target state="translated">Si la implementaci&amp;oacute;n admite aritm&amp;eacute;tica de coma flotante IEEE (IEC 60559), se requiere que &lt;code&gt;math_errhandling &amp;amp; MATH_ERREXCEPT&lt;/code&gt; no sea cero.</target>
        </trans-unit>
        <trans-unit id="452d571ea8f52d84cf9e46de2bbbf6be56c3970a" translate="yes" xml:space="preserve">
          <source>If the implementation supports IEEE floating-point arithmetic,</source>
          <target state="translated">Si la implementación apoya la aritmética de punto flotante del IEEE,</target>
        </trans-unit>
        <trans-unit id="7392bc849012f8a7b52172fc01358b19f1c644b0" translate="yes" xml:space="preserve">
          <source>If the implementation supports floating-point infinities, the macro &lt;code&gt;INFINITY&lt;/code&gt; expands to constant expression of type &lt;code&gt;float&lt;/code&gt; which evaluates to positive or unsigned infinity.</source>
          <target state="translated">Si la implementaci&amp;oacute;n admite infinitos de punto flotante, la macro &lt;code&gt;INFINITY&lt;/code&gt; se expande a una expresi&amp;oacute;n constante de tipo &lt;code&gt;float&lt;/code&gt; que se eval&amp;uacute;a como infinito positivo o sin signo.</target>
        </trans-unit>
        <trans-unit id="5ccfe7e9c2a2ea14c1997c4a20a1b44aba2730f7" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy assignment copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the operator performs member-wise copy assignment of the object's bases and non-static members, in their initialization order, using built-in assignment for the scalars and copy assignment operator for class types.</source>
          <target state="translated">Si el operador de asignaci&amp;oacute;n de copia declarado impl&amp;iacute;citamente no se elimina ni es trivial, el compilador lo define (es decir, un cuerpo de funci&amp;oacute;n es generado y compilado) si se &lt;a href=&quot;definition#ODR-use&quot;&gt;usa odr&lt;/a&gt; . Para &lt;code&gt;union&lt;/code&gt; tipos de uni&amp;oacute;n , la asignaci&amp;oacute;n de copia definida impl&amp;iacute;citamente copia la representaci&amp;oacute;n del objeto (como por &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ). Para los tipos de clase no sindicados ( &lt;code&gt;class&lt;/code&gt; y &lt;code&gt;struct&lt;/code&gt; ), el operador realiza una asignaci&amp;oacute;n de copia de las bases del objeto y miembros no est&amp;aacute;ticos, en su orden de inicializaci&amp;oacute;n, utilizando la asignaci&amp;oacute;n integrada para los escalares y el operador de asignaci&amp;oacute;n de copia para los tipos de clase. .</target>
        </trans-unit>
        <trans-unit id="d8ae3f1b05db376bf2d23b1574a42628e3a6ef11" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared copy constructor is not deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined copy constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the constructor performs full member-wise copy of the object's bases and non-static members, in their initialization order, using direct initialization. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated copy constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="translated">Si el constructor de copia declarado impl&amp;iacute;citamente no se elimina, el compilador lo define (es decir, un cuerpo de funci&amp;oacute;n es generado y compilado) si se &lt;a href=&quot;definition#ODR-use&quot;&gt;usa odr&lt;/a&gt; . Para &lt;code&gt;union&lt;/code&gt; tipos de uni&amp;oacute;n , el constructor de copia impl&amp;iacute;citamente definido copia la representaci&amp;oacute;n del objeto (como por &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ). Para los tipos de clase sin uni&amp;oacute;n ( &lt;code&gt;class&lt;/code&gt; y &lt;code&gt;struct&lt;/code&gt; ), el constructor realiza una copia completa de las bases del objeto y los miembros no est&amp;aacute;ticos, en su orden de inicializaci&amp;oacute;n, utilizando la inicializaci&amp;oacute;n directa. Si esto satisface los requisitos de un &lt;a href=&quot;constexpr&quot;&gt;constructor constexpr&lt;/a&gt; , el constructor de la copia generada es &lt;code&gt;constexpr&lt;/code&gt; . (Desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="30e62786983413b04a43c6ccf7b6769db6b9db27" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared default constructor is not defined as deleted, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;, and it has exactly the same effect as a user-defined constructor with empty body and empty initializer list. That is, it calls the default constructors of the bases and of the non-static members of this class. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated constructor is &lt;code&gt;constexpr&lt;/code&gt;.(since C++11).</source>
          <target state="translated">Si el constructor predeterminado declarado impl&amp;iacute;citamente no se define como eliminado, el compilador lo define (es decir, se genera y compila un cuerpo de funci&amp;oacute;n) si se &lt;a href=&quot;definition#ODR-use&quot;&gt;usa odr&lt;/a&gt; , y tiene exactamente el mismo efecto que un constructor definido por el usuario con cuerpo vac&amp;iacute;o y lista de inicializadores vac&amp;iacute;a. Es decir, llama a los constructores predeterminados de las bases y de los miembros no est&amp;aacute;ticos de esta clase. Si esto satisface los requisitos de un &lt;a href=&quot;constexpr&quot;&gt;constructor constexpr&lt;/a&gt; , el constructor generado es &lt;code&gt;constexpr&lt;/code&gt; . (Desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="c350045eebab9392561937d25bdc83283a8bc2b6" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move assignment operator is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;.</source>
          <target state="translated">Si el operador de asignaci&amp;oacute;n de movimiento declarado impl&amp;iacute;citamente no se elimina ni es trivial, el compilador lo define (es decir, un cuerpo de funci&amp;oacute;n es generado y compilado) si &lt;a href=&quot;definition#ODR-use&quot;&gt; usa odr&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ceab06f5631ee2653c87921d9ff9e756382351b1" translate="yes" xml:space="preserve">
          <source>If the implicitly-declared move constructor is neither deleted nor trivial, it is defined (that is, a function body is generated and compiled) by the compiler if &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-used&lt;/a&gt;. For &lt;code&gt;union&lt;/code&gt; types, the implicitly-defined move constructor copies the object representation (as by &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;). For non-union class types (&lt;code&gt;class&lt;/code&gt; and &lt;code&gt;struct&lt;/code&gt;), the move constructor performs full member-wise move of the object's bases and non-static members, in their initialization order, using direct initialization with an &lt;a href=&quot;value_category#xvalue&quot;&gt;xvalue&lt;/a&gt; argument. If this satisfies the requirements of a &lt;a href=&quot;constexpr&quot;&gt;constexpr constructor&lt;/a&gt;, the generated move constructor is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">Si el constructor de movimiento declarado impl&amp;iacute;citamente no se elimina ni es trivial, el compilador lo define (es decir, un cuerpo de funci&amp;oacute;n es generado y compilado) si se &lt;a href=&quot;definition#ODR-use&quot;&gt;usa odr&lt;/a&gt; . Para &lt;code&gt;union&lt;/code&gt; tipos de uni&amp;oacute;n , el constructor de movimiento definido impl&amp;iacute;citamente copia la representaci&amp;oacute;n del objeto (como por &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ). Para los tipos de clase sin uni&amp;oacute;n ( &lt;code&gt;class&lt;/code&gt; y &lt;code&gt;struct&lt;/code&gt; ), el constructor de movimiento realiza un movimiento completo de las bases del objeto y los miembros no est&amp;aacute;ticos, en su orden de inicializaci&amp;oacute;n, utilizando la inicializaci&amp;oacute;n directa con un argumento &lt;a href=&quot;value_category#xvalue&quot;&gt;xvalue&lt;/a&gt; . Si esto satisface los requisitos de un &lt;a href=&quot;constexpr&quot;&gt;constructor constexpr&lt;/a&gt; , el constructor de movimiento generado es &lt;code&gt;constexpr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b006776f232a7b6fc30d9aed9df44514f27ef73" translate="yes" xml:space="preserve">
          <source>If the initialization &lt;a href=&quot;throw&quot;&gt;throws an exception&lt;/a&gt;, the variable is not considered to be initialized, and initialization will be attempted again the next time control passes through the declaration.</source>
          <target state="translated">Si la inicializaci&amp;oacute;n &lt;a href=&quot;throw&quot;&gt; arroja una excepci&amp;oacute;n&lt;/a&gt; , la variable no se considera inicializada y la inicializaci&amp;oacute;n se intentar&amp;aacute; nuevamente la pr&amp;oacute;xima vez que el control pase por la declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="70a7998feab60665e9807c4931559d1fd72d7fb4" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-inline variable(since C++17) is deferred to happen after the first statement of main/thread function, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of any variable with static/thread storage duration defined in the same translation unit as the variable to be initialized. If no variable or function is odr-used from a given translation unit, the non-local variables defined in that translation unit may never be initialized (this models the behavior of an on-demand dynamic library). However, as long as anything from a translation unit is odr-used, all non-local variables whose initialization or destruction has side effects will be initialized even if they are not used in the program.</source>
          <target state="translated">Si se aplaza la inicializaci&amp;oacute;n de una variable no en l&amp;iacute;nea (desde C ++ 17) despu&amp;eacute;s de la primera instrucci&amp;oacute;n de la funci&amp;oacute;n main / thread, ocurre antes del primer &lt;a href=&quot;definition#ODR-use&quot;&gt;uso&lt;/a&gt; de cualquier variable con una duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico / thread definida en misma unidad de traducci&amp;oacute;n que la variable a inicializar. Si no se utiliza odr ninguna variable o funci&amp;oacute;n de una unidad de traducci&amp;oacute;n dada, las variables no locales definidas en esa unidad de traducci&amp;oacute;n pueden nunca inicializarse (esto modela el comportamiento de una biblioteca din&amp;aacute;mica a pedido). Sin embargo, siempre y cuando se use odr-algo de una unidad de traducci&amp;oacute;n, todas las variables no locales cuya inicializaci&amp;oacute;n o destrucci&amp;oacute;n tenga efectos secundarios se inicializar&amp;aacute;n incluso si no se usan en el programa.</target>
        </trans-unit>
        <trans-unit id="3f6bf015004432f99da972ebcadb65c84565ae76" translate="yes" xml:space="preserve">
          <source>If the initialization of a non-local variable with static or thread storage duration exits via an exception, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Si la inicializaci&amp;oacute;n de una variable no local con una duraci&amp;oacute;n de almacenamiento est&amp;aacute;tica o de subprocesos sale a trav&amp;eacute;s de una excepci&amp;oacute;n, &lt;code&gt;&lt;a href=&quot;../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; se llama a std :: terminate .</target>
        </trans-unit>
        <trans-unit id="1b11a1c3896d9b7ae4903a89c0351942d3a51b04" translate="yes" xml:space="preserve">
          <source>If the initialization of an inline variable is deferred, it happens before the first &lt;a href=&quot;definition#ODR-use&quot;&gt;odr-use&lt;/a&gt; of that specific variable.</source>
          <target state="translated">Si se difiere la inicializaci&amp;oacute;n de una variable en l&amp;iacute;nea, ocurre antes del primer &lt;a href=&quot;definition#ODR-use&quot;&gt;uso de odr&lt;/a&gt; de esa variable espec&amp;iacute;fica.</target>
        </trans-unit>
        <trans-unit id="126551b23f54c215a6bae6f1387512974293e25e" translate="yes" xml:space="preserve">
          <source>If the initialization recursively enters the block in which the variable is being initialized, the behavior is undefined.</source>
          <target state="translated">Si la inicialización entra recursivamente en el bloque en el que se está inicializando la variable,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="b698184c8fc9c6ca4e1b58ee7ce5abecef65b881" translate="yes" xml:space="preserve">
          <source>If the initializer (range_expression) is a braced-init-list, __range is deduced to be &lt;code&gt;std::initializer_list&amp;lt;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;</source>
          <target state="translated">Si el inicializador (range_expression) es una lista de inicializaci&amp;oacute;n entre par&amp;eacute;ntesis, se deduce que __range es &lt;code&gt;std::initializer_list&amp;lt;&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="2f9de00dbbb1064006866fc50c910f17dedcc3df" translate="yes" xml:space="preserve">
          <source>If the initializer clause is a nested braced-init-list (which is not an expression), the corresponding array element/class member/public base(since C++17) is &lt;a href=&quot;list_initialization&quot;&gt;list-initialized&lt;/a&gt; from that clause: aggregate initialization is recursive.</source>
          <target state="translated">Si la cl&amp;aacute;usula del inicializador es una lista de inicializaci&amp;oacute;n anidada (que no es una expresi&amp;oacute;n), el elemento de matriz / miembro de clase / base p&amp;uacute;blica correspondiente (desde C ++ 17) se &lt;a href=&quot;list_initialization&quot;&gt;inicializa en lista&lt;/a&gt; en partir de esa cl&amp;aacute;usula: la inicializaci&amp;oacute;n agregada es recursiva.</target>
        </trans-unit>
        <trans-unit id="263c85b919faedf2707a9f0cb930d424e5361608" translate="yes" xml:space="preserve">
          <source>If the initializer clause is an expression, implicit conversions are allowed as per copy-initialization, except, for &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; form, narrowing conversions are prohibited(since C++11).</source>
          <target state="translated">Si la cl&amp;aacute;usula initializer es una expresi&amp;oacute;n, se permiten conversiones impl&amp;iacute;citas seg&amp;uacute;n la inicializaci&amp;oacute;n de copia, excepto para &lt;a href=&quot;list_initialization&quot;&gt;la inicializaci&amp;oacute;n de lista&lt;/a&gt; formulario de , se proh&amp;iacute;ben las conversiones de reducci&amp;oacute;n (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="9e522fac274022ad05f5205f4ec4d76c0dff7b8d" translate="yes" xml:space="preserve">
          <source>If the initializer is a braced-init-list &lt;code&gt;{&lt;/code&gt;arg1, arg2, ...&lt;code&gt;} &lt;/code&gt;, rules of &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt; are followed.</source>
          <target state="translated">Si el inicializador es una lista de inicializaci&amp;oacute;n con llaves &lt;code&gt;{&lt;/code&gt; arg1, arg2, ... &lt;code&gt;} &lt;/code&gt; , se siguen las reglas de &lt;a href=&quot;list_initialization&quot;&gt;inicializaci&amp;oacute;n&lt;/a&gt; de la lista .</target>
        </trans-unit>
        <trans-unit id="17a801942e1f9c93f9b22088a58723039bdb9b3e" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty and &lt;code&gt;T&lt;/code&gt; has a default constructor, phase 1 is skipped.</source>
          <target state="translated">Si la lista de inicializadores est&amp;aacute; vac&amp;iacute;a y &lt;code&gt;T&lt;/code&gt; tiene un constructor predeterminado, se omite la fase 1.</target>
        </trans-unit>
        <trans-unit id="3e6d2d2dc08cc044669732b9dbb39c02db128762" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;a href=&quot;begin&quot;&gt;&lt;code&gt;begin()&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;end()&lt;/code&gt; are unspecified, but will be identical.</source>
          <target state="translated">Si la lista de inicializadores est&amp;aacute; vac&amp;iacute;a, los valores de &lt;a href=&quot;begin&quot;&gt; &lt;code&gt;begin()&lt;/code&gt; &lt;/a&gt; y &lt;code&gt;end()&lt;/code&gt; no est&amp;aacute;n especificados, pero ser&amp;aacute;n id&amp;eacute;nticos.</target>
        </trans-unit>
        <trans-unit id="e4201a6a146ed0efc5a6cfe2c7d212a524559429" translate="yes" xml:space="preserve">
          <source>If the initializer list is empty, the values of &lt;code&gt;begin()&lt;/code&gt; and &lt;a href=&quot;end&quot;&gt;&lt;code&gt;end()&lt;/code&gt;&lt;/a&gt; are unspecified, but will be identical.</source>
          <target state="translated">Si la lista de inicializadores est&amp;aacute; vac&amp;iacute;a, los valores de &lt;code&gt;begin()&lt;/code&gt; y &lt;a href=&quot;end&quot;&gt; &lt;code&gt;end()&lt;/code&gt; &lt;/a&gt; no est&amp;aacute;n especificados, pero ser&amp;aacute;n id&amp;eacute;nticos.</target>
        </trans-unit>
        <trans-unit id="d6346069140ef89aa4a40fbb67316690947509e3" translate="yes" xml:space="preserve">
          <source>If the input has been parsed into preprocessing tokens up to a given character, the next preprocessing token is generally taken to be the longest sequence of characters that could constitute a preprocessing token, even if that would cause subsequent analysis to fail. This is commonly known as</source>
          <target state="translated">Si la entrada se ha analizado en fichas de preprocesamiento hasta un carácter determinado,se considera generalmente que la siguiente ficha de preprocesamiento es la secuencia más larga de caracteres que podría constituir una ficha de preprocesamiento,incluso si ello provocara el fracaso del análisis posterior.Esto se conoce comúnmente como</target>
        </trans-unit>
        <trans-unit id="15db5ceb85ecf11c1bb40aa49fe97037e6943c70" translate="yes" xml:space="preserve">
          <source>If the input iterator &lt;code&gt;beg&lt;/code&gt; becomes equal to &lt;code&gt;end&lt;/code&gt; before the parsing was completed, sets both &lt;code&gt;failbit&lt;/code&gt; and &lt;code&gt;eofbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. If parsing fails for another reason, sets the &lt;code&gt;failbit&lt;/code&gt; in &lt;code&gt;err&lt;/code&gt;. Either way, does not modify the output parameter ((&lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;) on error.</source>
          <target state="translated">Si el iterador de entrada &lt;code&gt;beg&lt;/code&gt; se hace igual a &lt;code&gt;end&lt;/code&gt; antes de terminar el an&amp;aacute;lisis, establece tanto &lt;code&gt;failbit&lt;/code&gt; y &lt;code&gt;eofbit&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; . Si el an&amp;aacute;lisis falla por otro motivo, establece el &lt;code&gt;failbit&lt;/code&gt; en &lt;code&gt;err&lt;/code&gt; . De cualquier manera, no modifica el par&amp;aacute;metro de salida (( &lt;code&gt;units&lt;/code&gt; o &lt;code&gt;digits&lt;/code&gt; ) en caso de error.</target>
        </trans-unit>
        <trans-unit id="32e7c4b65d1f3ec9ebd0ad90287093fbb310dbce" translate="yes" xml:space="preserve">
          <source>If the input sequence has a read position available (&lt;code&gt;gptr() &amp;lt; egptr()&lt;/code&gt;, returns &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt;.</source>
          <target state="translated">Si la secuencia de entrada tiene una posici&amp;oacute;n de lectura disponible ( &lt;code&gt;gptr() &amp;lt; egptr()&lt;/code&gt; , devuelve &lt;code&gt;(unsigned char)(*gptr())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45b2d15e0da710723c3cf60d16eb11250968276f" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="translated">Si la posici&amp;oacute;n de lectura de la secuencia de entrada no est&amp;aacute; disponible, devuelve &lt;code&gt;&lt;a href=&quot;uflow&quot;&gt;uflow()&lt;/a&gt;&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f43632fd3506c566c7659b87242e4ba36c845b6" translate="yes" xml:space="preserve">
          <source>If the input sequence read position is not available, returns &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;. Otherwise returns &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt;.</source>
          <target state="translated">Si la posici&amp;oacute;n de lectura de la secuencia de entrada no est&amp;aacute; disponible, devuelve &lt;code&gt;&lt;a href=&quot;underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;Traits::to_int_type(*gptr())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9116078f703a37d13100bfaf8b9930ee23b4bdb" translate="yes" xml:space="preserve">
          <source>If the insertion failed because the element already exists, returns an iterator to the already existing element with the equivalent key.</source>
          <target state="translated">Si la inserción falló porque el elemento ya existe,devuelve un iterador al elemento ya existente con la clave equivalente.</target>
        </trans-unit>
        <trans-unit id="a9fe612f9ce2e8b253c5cf483a66190457dfe15b" translate="yes" xml:space="preserve">
          <source>If the iterator holds a zero-length match and &lt;code&gt;start == end&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to end-of-sequence iterator and the function returns.</source>
          <target state="translated">Si el iterador tiene una coincidencia de longitud cero y &lt;code&gt;start == end&lt;/code&gt; , &lt;code&gt;*this&lt;/code&gt; se establece en el iterador de fin de secuencia y la funci&amp;oacute;n regresa.</target>
        </trans-unit>
        <trans-unit id="00ebb2aeeb1edae6ae85a26d3e1931e1626d24a9" translate="yes" xml:space="preserve">
          <source>If the lambda definition uses an explicit template parameter list, that template parameter list is used with &lt;code&gt;operator()&lt;/code&gt;. For every parameter in params whose type is specified as &lt;code&gt;auto&lt;/code&gt;, an additional invented template parameter is appended to the end of that template parameter list:</source>
          <target state="translated">Si la definici&amp;oacute;n lambda usa una lista de par&amp;aacute;metros de plantilla expl&amp;iacute;cita, esa lista de par&amp;aacute;metros de plantilla se usa con &lt;code&gt;operator()&lt;/code&gt; . Para cada par&amp;aacute;metro en par&amp;aacute;metros cuyo tipo se especifica como &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tico , se agrega un par&amp;aacute;metro de plantilla inventado adicional al final de esa lista de par&amp;aacute;metros de plantilla:</target>
        </trans-unit>
        <trans-unit id="c2e82d8a32eeab86a4c1f4f5bce0d91e5af9b994" translate="yes" xml:space="preserve">
          <source>If the lambda-expression captures anything by copy (either implicitly with capture clause &lt;code&gt;[=]&lt;/code&gt; or explicitly with a capture that does not include the character &amp;amp;, e.g. &lt;code&gt;[a, b, c]&lt;/code&gt;), the closure type includes unnamed non-static data members, declared in unspecified order, that hold copies of all entities that were so captured.</source>
          <target state="translated">Si la expresi&amp;oacute;n lambda captura algo por copia (ya sea impl&amp;iacute;citamente con la cl&amp;aacute;usula de captura &lt;code&gt;[=]&lt;/code&gt; o expl&amp;iacute;citamente con una captura que no incluye el car&amp;aacute;cter &amp;amp;, por ejemplo, &lt;code&gt;[a, b, c]&lt;/code&gt; ), el tipo de cierre incluye datos no est&amp;aacute;ticos sin nombre miembros, declarados en un orden no especificado, que contienen copias de todas las entidades que fueron capturadas.</target>
        </trans-unit>
        <trans-unit id="fd29e44a99211fd550448d9553f6ae1ad92b1445" translate="yes" xml:space="preserve">
          <source>If the last modification time is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::last_write_time(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::last_write_time(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">Si el tiempo de la &amp;uacute;ltima modificaci&amp;oacute;n se almacena en cach&amp;eacute; en esta &lt;code&gt;directory_entry&lt;/code&gt; , devuelve el valor almacenado en cach&amp;eacute;. De lo contrario, devuelve &lt;code&gt;std::filesystem::last_write_time(path())&lt;/code&gt; o &lt;code&gt;std::filesystem::last_write_time(path(), ec)&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="7b9eab5ed5a441c8e5830c92fe0f6282d0707a87" translate="yes" xml:space="preserve">
          <source>If the left and the right operands identify overlapping objects, the behavior is undefined (unless the overlap is exact and the type is the same).</source>
          <target state="translated">Si los operandos izquierdo y derecho identifican objetos superpuestos,el comportamiento es indefinido (a menos que la superposición sea exacta y el tipo sea el mismo).</target>
        </trans-unit>
        <trans-unit id="fa424ec54e9e85e6bf53212ac1a5db2c477f5b29" translate="yes" xml:space="preserve">
          <source>If the length specifier &lt;code&gt;l&lt;/code&gt; is not used, the conversion specifiers &lt;code&gt;c&lt;/code&gt;, &lt;code&gt;s&lt;/code&gt;, and &lt;code&gt;[&lt;/code&gt; perform wide-to-multibyte character conversion as if by calling &lt;a href=&quot;../../string/multibyte/wcrtomb&quot;&gt;&lt;code&gt;wcrtomb()&lt;/code&gt;&lt;/a&gt; with an &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt;&lt;code&gt;mbstate_t&lt;/code&gt;&lt;/a&gt; object initialized to zero before the first character is converted.</source>
          <target state="translated">Si la longitud especificador &lt;code&gt;l&lt;/code&gt; no se utiliza, la especificadores de conversi&amp;oacute;n &lt;code&gt;c&lt;/code&gt; , &lt;code&gt;s&lt;/code&gt; , y &lt;code&gt;[&lt;/code&gt; realizar la conversi&amp;oacute;n de caracteres ancho a multibyte como si llamando &lt;a href=&quot;../../string/multibyte/wcrtomb&quot;&gt; &lt;code&gt;wcrtomb()&lt;/code&gt; &lt;/a&gt; con un &lt;a href=&quot;../../string/multibyte/mbstate_t&quot;&gt; &lt;code&gt;mbstate_t&lt;/code&gt; &lt;/a&gt; objeto inicializado a cero antes de que se convierte el primer car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="4854bc47bd09d34dbcbd17a9720f9b303f9e3fb1" translate="yes" xml:space="preserve">
          <source>If the literal operator is a template, it must have an empty parameter list and can have only one template parameter, which must be a non-type template parameter pack with element type &lt;code&gt;char&lt;/code&gt; (in which case it is known as a</source>
          <target state="translated">Si el operador literal es una plantilla, debe tener una lista de par&amp;aacute;metros vac&amp;iacute;a y solo puede tener un par&amp;aacute;metro de plantilla, que debe ser un paquete de par&amp;aacute;metros de plantilla sin tipo con elemento tipo &lt;code&gt;char&lt;/code&gt; (en cuyo caso se conoce como</target>
        </trans-unit>
        <trans-unit id="fa1825d8cb36d3fdb7a1cdb0411663647de38a09" translate="yes" xml:space="preserve">
          <source>If the lock is &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; may provide better performance.</source>
          <target state="translated">Si el bloqueo es &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; puede proporcionar un mejor rendimiento.</target>
        </trans-unit>
        <trans-unit id="2072cff7e155c80603cea5b9b2279dd4d08fd38c" translate="yes" xml:space="preserve">
          <source>If the lookup of a member of current instantiation gives a different result between the point of instantiation and the point of definition, the lookup is ambiguous. Note however that when a member name is used, it is not automatically converted to a class member access expression, only explicit member access expressions indicate members of current instantiation:</source>
          <target state="translated">Si la búsqueda de un miembro de la instanciación actual da un resultado diferente entre el punto de instanciación y el punto de definición,la búsqueda es ambigua.Sin embargo,nótese que cuando se utiliza el nombre de un miembro,no se convierte automáticamente en una expresión de acceso a un miembro de la clase,sólo las expresiones explícitas de acceso a un miembro indican los miembros de la instanciación actual:</target>
        </trans-unit>
        <trans-unit id="01f377ce674649640d133ed5cc78ca704a3b02f5" translate="yes" xml:space="preserve">
          <source>If the lookup of the left hand side name comes up with a class/struct or union name, the name on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that class (and so may find a declaration of a member of that class or of its base), with the following exceptions.</source>
          <target state="translated">Si la b&amp;uacute;squeda del nombre del lado izquierdo aparece con un nombre de clase / estructura o uni&amp;oacute;n, el nombre en el lado derecho de &lt;code&gt;::&lt;/code&gt; se busca en el alcance de esa clase (y puede encontrar una declaraci&amp;oacute;n de un miembro de esa clase o de su base), con las siguientes excepciones.</target>
        </trans-unit>
        <trans-unit id="d37b88b9ada3dd332af605d1fd3e5a8cf0eb71e3" translate="yes" xml:space="preserve">
          <source>If the lookup of the left-hand side name comes up with an &lt;a href=&quot;enum&quot;&gt;enumeration&lt;/a&gt; (either scoped or unscoped), the lookup of the right-hand side must result in an enumerator that belongs that enumeration, otherwise the program is ill-formed.</source>
          <target state="translated">Si la b&amp;uacute;squeda del nombre del lado izquierdo aparece con una &lt;a href=&quot;enum&quot;&gt;enumeraci&amp;oacute;n&lt;/a&gt; (ya sea con &amp;aacute;mbito o sin &amp;aacute;mbito), la b&amp;uacute;squeda del lado derecho debe dar como resultado un enumerador que pertenezca a esa enumeraci&amp;oacute;n; de lo contrario, el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="1c84f7f76196e3d1858123032bdb6f7a708a9edc" translate="yes" xml:space="preserve">
          <source>If the main function is defined with a &lt;a href=&quot;function-try-block&quot;&gt;function-try-block&lt;/a&gt;, the exceptions thrown by the destructors of static objects (which are destroyed by the implied &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;) are not caught by it.</source>
          <target state="translated">Si la funci&amp;oacute;n principal se define con un &lt;a href=&quot;function-try-block&quot;&gt;bloque de prueba de funci&amp;oacute;n&lt;/a&gt; , las excepciones lanzadas por los destructores de objetos est&amp;aacute;ticos (que son destruidos por el &lt;code&gt;&lt;a href=&quot;../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; impl&amp;iacute;cito ) no son capturados por &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="3e06f91c09b7d51a80ad502bd1ebea399586e472" translate="yes" xml:space="preserve">
          <source>If the match does not exist:</source>
          <target state="translated">Si el partido no existe:</target>
        </trans-unit>
        <trans-unit id="7e82db05b3b86f89f14289a124a974cfc8812bd1" translate="yes" xml:space="preserve">
          <source>If the match exists:</source>
          <target state="translated">Si el partido existe:</target>
        </trans-unit>
        <trans-unit id="4183569bf1256905bbaf650046e97c16dae9e0cc" translate="yes" xml:space="preserve">
          <source>If the meaning of a</source>
          <target state="translated">Si el significado de un</target>
        </trans-unit>
        <trans-unit id="e85a366ebfca22ae74e5b65314e65c8d7039ce9f" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type, which applies unsigned integer wraparound rules.</source>
          <target state="translated">Si el signo menos era parte de la secuencia de entrada, el valor num&amp;eacute;rico calculado a partir de la secuencia de d&amp;iacute;gitos se niega como si fuera &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unario menos&lt;/a&gt; en el tipo de resultado, que aplica las reglas enteras sin signo.</target>
        </trans-unit>
        <trans-unit id="9ec415c505d275361f5e319da3ba14be0e8e4bd1" translate="yes" xml:space="preserve">
          <source>If the minus sign was part of the input sequence, the numeric value calculated from the sequence of digits is negated as if by &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unary minus&lt;/a&gt; in the result type.</source>
          <target state="translated">Si el signo menos era parte de la secuencia de entrada, el valor num&amp;eacute;rico calculado a partir de la secuencia de d&amp;iacute;gitos se niega como si fuera &lt;a href=&quot;../../language/operator_arithmetic#Unary_arithmetic_operators&quot;&gt;unario menos&lt;/a&gt; en el tipo de resultado.</target>
        </trans-unit>
        <trans-unit id="5755fdc9594791908fc98437469bea77cb6e1fd5" translate="yes" xml:space="preserve">
          <source>If the most recent match was not a zero-length match, the operator sets &lt;code&gt;flags&lt;/code&gt; to &lt;code&gt;flags | regex_constants::match_prev_avail&lt;/code&gt; and invokes the following:</source>
          <target state="translated">Si la coincidencia m&amp;aacute;s reciente no fue una coincidencia de longitud cero, el operador establece las &lt;code&gt;flags&lt;/code&gt; en &lt;code&gt;flags | regex_constants::match_prev_avail&lt;/code&gt; e invoca lo siguiente:</target>
        </trans-unit>
        <trans-unit id="d96faf371e54d959541ad721b9a13b1a3685ad32" translate="yes" xml:space="preserve">
          <source>If the most recently called function, out of &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;seekpos()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt;, was &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, then calls &lt;code&gt;std::codecvt::unshift()&lt;/code&gt;, perhaps multiple times, to determine the unshift sequence according to the imbued locale, and writes that sequence to file with &lt;code&gt;overflow(Traits::eof())&lt;/code&gt;.</source>
          <target state="translated">Si la funci&amp;oacute;n llamada m&amp;aacute;s recientemente, fuera de &lt;code&gt;&lt;a href=&quot;../basic_streambuf/underflow&quot;&gt;underflow()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekpos&quot;&gt;seekpos()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pubseekoff&quot;&gt;seekoff()&lt;/a&gt;&lt;/code&gt; , fue &lt;code&gt;&lt;a href=&quot;../basic_streambuf/overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; , entonces llama a &lt;code&gt;std::codecvt::unshift()&lt;/code&gt; , quiz&amp;aacute;s varias veces, para determinar secuencia de desplazamiento de acuerdo con la configuraci&amp;oacute;n regional imbuida, y escribe esa secuencia en un archivo con &lt;code&gt;overflow(Traits::eof())&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90491130497fa2fc6497b24640b7ae73bc68aa73" translate="yes" xml:space="preserve">
          <source>If the multibyte character encoding is state-dependent (&lt;a href=&quot;../../locale/codecvt/encoding&quot;&gt;&lt;code&gt;codecvt::encoding()&lt;/code&gt;&lt;/a&gt; returned &lt;code&gt;-1&lt;/code&gt;) or variable-length (&lt;code&gt;codecvt::encoding()&lt;/code&gt; returned &lt;code&gt;​0​&lt;/code&gt;) and the offset &lt;code&gt;off&lt;/code&gt; is not &lt;code&gt;​0​&lt;/code&gt;, fails immediately: this function cannot determine the number of bytes that correspond to &lt;code&gt;off&lt;/code&gt; characters.</source>
          <target state="translated">Si la codificaci&amp;oacute;n de caracteres multibyte es dependiente del estado ( &lt;a href=&quot;../../locale/codecvt/encoding&quot;&gt; &lt;code&gt;codecvt::encoding()&lt;/code&gt; &lt;/a&gt; devuelto &lt;code&gt;-1&lt;/code&gt; ) o de longitud variable ( &lt;code&gt;codecvt::encoding()&lt;/code&gt; devuelve &lt;code&gt;​0​&lt;/code&gt; ) y el desplazamiento &lt;code&gt;off&lt;/code&gt; no es &lt;code&gt;​0​&lt;/code&gt; , falla inmediatamente: este La funci&amp;oacute;n no puede determinar el n&amp;uacute;mero de bytes que corresponden a &lt;code&gt;off&lt;/code&gt; caracteres desactivados .</target>
        </trans-unit>
        <trans-unit id="312e4e4f74f5b82f6bd25b87461c9b4fbde989e6" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char16_t sequence (e.g. a surrogate pair in UTF-16), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next call to &lt;code&gt;mbrtoc16&lt;/code&gt; will write out the additional char16_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">Si el car&amp;aacute;cter multibyte en &lt;code&gt;*s&lt;/code&gt; corresponde a una secuencia multi-char16_t (por ejemplo, un par sustituto en UTF-16), luego de la primera llamada a esta funci&amp;oacute;n, &lt;code&gt;*ps&lt;/code&gt; se actualiza de tal manera que la pr&amp;oacute;xima llamada a &lt;code&gt;mbrtoc16&lt;/code&gt; escriba fuera el char16_t adicional, sin considerar &lt;code&gt;*s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bcb6afe2a5acb943ad2fdd6f475921c6ce71ebf8" translate="yes" xml:space="preserve">
          <source>If the multibyte character in &lt;code&gt;*s&lt;/code&gt; corresponds to a multi-char32_t sequence (not possible with UTF-32), then after the first call to this function, &lt;code&gt;*ps&lt;/code&gt; is updated in such a way that the next calls to &lt;code&gt;mbrtoc32&lt;/code&gt; will write out the additional char32_t, without considering &lt;code&gt;*s&lt;/code&gt;.</source>
          <target state="translated">Si el car&amp;aacute;cter multibyte en &lt;code&gt;*s&lt;/code&gt; corresponde a una secuencia multi-char32_t (no es posible con UTF-32), luego de la primera llamada a esta funci&amp;oacute;n, &lt;code&gt;*ps&lt;/code&gt; se actualiza de tal manera que las siguientes llamadas a &lt;code&gt;mbrtoc32&lt;/code&gt; escribir&amp;aacute;n el char32_t adicional, sin considerar &lt;code&gt;*s&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baf70aa7bd1cf40829d0398b1fa87e9dc92941f8" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;std::unique_lock&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Si el mutex ya est&amp;aacute; bloqueado por este &lt;code&gt;std::unique_lock&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; con un c&amp;oacute;digo de error de &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26a0b8cab69da9fd4564dd153dc7e72537daded3" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked by this &lt;code&gt;unique_lock&lt;/code&gt; (in other words, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; is true), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Si el mutex ya est&amp;aacute; bloqueado por este &lt;code&gt;unique_lock&lt;/code&gt; (en otras palabras, &lt;a href=&quot;owns_lock&quot;&gt;owns_lock&lt;/a&gt; es verdadero), &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; con un c&amp;oacute;digo de error de &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="554e21c6a83788b53dc332bdeec20b2bc45e361b" translate="yes" xml:space="preserve">
          <source>If the mutex is already locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Si el mutex ya est&amp;aacute; bloqueado, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; con un c&amp;oacute;digo de error de &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::resource_deadlock_would_occur&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e5f5c7e5fb56183cbccedca22001e62c7b4f9e65" translate="yes" xml:space="preserve">
          <source>If the name appears immediately to the right of the scope resolution operator &lt;code&gt;::&lt;/code&gt; or possibly after &lt;code&gt;::&lt;/code&gt; followed by the disambiguating keyword &lt;code&gt;template&lt;/code&gt;, see.</source>
          <target state="translated">Si el nombre aparece inmediatamente a la derecha del operador de resoluci&amp;oacute;n de alcance &lt;code&gt;::&lt;/code&gt; o posiblemente despu&amp;eacute;s de &lt;code&gt;::&lt;/code&gt; seguido de la &lt;code&gt;template&lt;/code&gt; palabras clave de desambiguaci&amp;oacute;n , vea.</target>
        </trans-unit>
        <trans-unit id="12c49bf8d3ab86a8d2eba4533e6f3ce9e54beb97" translate="yes" xml:space="preserve">
          <source>If the name lookup does not find a previously declared type name, the elaborated-type-specifier is introduced by &lt;code&gt;class&lt;/code&gt;, &lt;code&gt;struct&lt;/code&gt;, or &lt;code&gt;union&lt;/code&gt; (i.e. not by &lt;code&gt;enum&lt;/code&gt;), and class-name is an unqualified identifier, then the elaborated-type-specifier is a class declaration of the class-name.</source>
          <target state="translated">Si la b&amp;uacute;squeda de nombres no encuentra un nombre de tipo previamente declarado, el especificador de tipo elaborado se introduce por &lt;code&gt;class&lt;/code&gt; , &lt;code&gt;struct&lt;/code&gt; o &lt;code&gt;union&lt;/code&gt; (es decir, no por &lt;code&gt;enum&lt;/code&gt; eraci&amp;oacute;n ), y el nombre de clase es un identificador no calificado, entonces el tipo elaborado El especificador es una declaraci&amp;oacute;n de clase del nombre de clase.</target>
        </trans-unit>
        <trans-unit id="680aaf5d39f0524608d21769dd7093d5030e0ccf" translate="yes" xml:space="preserve">
          <source>If the name of the class itself appears as class-or-identifier in the member initializer list, then the list must consist of that one member initializer only; such constructor is known as the</source>
          <target state="translated">Si el nombre de la clase propiamente dicha aparece como clase o identificador en la lista de inicializadores de miembros,entonces la lista debe consistir en ese único inicializador de miembros;dicho constructor se conoce como el</target>
        </trans-unit>
        <trans-unit id="b15648eb5df5f87645e8346a354b1f3da3971a94" translate="yes" xml:space="preserve">
          <source>If the name on the left of &lt;code&gt;::&lt;/code&gt; refers to a namespace or if there is nothing on the left of &lt;code&gt;::&lt;/code&gt; (in which case it refers to the global namespace), the name that appears on the right hand side of &lt;code&gt;::&lt;/code&gt; is looked up in the scope of that namespace, except that.</source>
          <target state="translated">Si el nombre a la izquierda de &lt;code&gt;::&lt;/code&gt; se refiere a un espacio de nombres o si no hay nada a la izquierda de &lt;code&gt;::&lt;/code&gt; (en cuyo caso se refiere al espacio de nombres global), se busca el nombre que aparece en el lado derecho de &lt;code&gt;::&lt;/code&gt; arriba en el alcance de ese espacio de nombres, excepto eso.</target>
        </trans-unit>
        <trans-unit id="351414d67b6211a3be33d9c5a18059ec3fe49dc4" translate="yes" xml:space="preserve">
          <source>If the name refers to a &lt;a href=&quot;typedef&quot;&gt;typedef name&lt;/a&gt;, a &lt;a href=&quot;type_alias&quot;&gt;type alias&lt;/a&gt;, a &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;template type parameter&lt;/a&gt;, or an &lt;a href=&quot;type_alias&quot;&gt;alias template specialization&lt;/a&gt;, the program is ill-formed, otherwise the elaborated type specifier introduces the name into the declaration the same way a &lt;a href=&quot;declarations#Specifiers&quot;&gt;simple type specifier&lt;/a&gt; introduces its type-name.</source>
          <target state="translated">Si el nombre se refiere a un &lt;a href=&quot;typedef&quot;&gt;nombre de typedef&lt;/a&gt; , un &lt;a href=&quot;type_alias&quot;&gt;alias de tipo&lt;/a&gt; , un &lt;a href=&quot;template_parameters#Type_template_parameter&quot;&gt;par&amp;aacute;metro de tipo de plantilla&lt;/a&gt; o una &lt;a href=&quot;type_alias&quot;&gt;especializaci&amp;oacute;n de plantilla de alias&lt;/a&gt; , el programa est&amp;aacute; mal formado; de lo contrario, el especificador de tipo elaborado introduce el nombre en la declaraci&amp;oacute;n de la misma manera que un &lt;a href=&quot;declarations#Specifiers&quot;&gt;especificador de tipo simple&lt;/a&gt; introduce su nombre de tipo</target>
        </trans-unit>
        <trans-unit id="7bf4ac13d848aeaa14204e7424d717fa7118c92d" translate="yes" xml:space="preserve">
          <source>If the names of two parameter packs appear in the same pattern, they are expanded simultaneously, and they must have the same length:</source>
          <target state="translated">Si los nombres de dos paquetes de parámetros aparecen en el mismo patrón,se expanden simultáneamente,y deben tener la misma longitud:</target>
        </trans-unit>
        <trans-unit id="a2b281f14bc994fec6ff8448c81b41b3e5d1e437" translate="yes" xml:space="preserve">
          <source>If the nearest enclosing function declarator is not the declarator of a function definition, its potential scope ends at the end of that function declarator.</source>
          <target state="translated">Si el declarante de la función más cercano no es el declarante de una definición de función,su alcance potencial termina al final de ese declarante de la función.</target>
        </trans-unit>
        <trans-unit id="b5670784086b76d24bb1fae4d2445942134f26af" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the past-the-end iterator is invalidated.</source>
          <target state="translated">Si el nuevo &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; es mayor que la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , todos los iteradores y referencias (incluido el iterador anterior) se invalidan. De lo contrario, solo se invalida el iterador pasado al final.</target>
        </trans-unit>
        <trans-unit id="cf94debed8cd7dc4895c7d2f2f99ed8c3d0eef6f" translate="yes" xml:space="preserve">
          <source>If the new &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; is greater than &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, all iterators and references are invalidated. Otherwise, only the iterators and references before the insertion point remain valid. The past-the-end iterator is also invalidated.</source>
          <target state="translated">Si el nuevo &lt;code&gt;&lt;a href=&quot;size&quot;&gt;size()&lt;/a&gt;&lt;/code&gt; es mayor que la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; , se invalidan todos los iteradores y referencias. De lo contrario, solo los iteradores y las referencias antes del punto de inserci&amp;oacute;n siguen siendo v&amp;aacute;lidos. El iterador pasado al final tambi&amp;eacute;n se invalida.</target>
        </trans-unit>
        <trans-unit id="7ea2ea05865b3c53570d6c768a8336b0fce606d3" translate="yes" xml:space="preserve">
          <source>If the new size is bigger than the old one : all iterators are invalidated</source>
          <target state="translated">Si el nuevo tamaño es más grande que el viejo:todos los iteradores son invalidados</target>
        </trans-unit>
        <trans-unit id="92c6212e4fbc62d508c776cafe31778487d050cd" translate="yes" xml:space="preserve">
          <source>If the new size is smaller than the old one : only erased elements and the past-the-end iterator</source>
          <target state="translated">Si el nuevo tamaño es más pequeño que el antiguo:sólo los elementos borrados y el iterador del pasado...</target>
        </trans-unit>
        <trans-unit id="b4edb10d6256f62d87a1b6332196a1e63e973276" translate="yes" xml:space="preserve">
          <source>If the next character begins a sequence of characters that could be the prefix and initial double quote of a &lt;a href=&quot;string_literal&quot;&gt;raw string literal&lt;/a&gt;, the next preprocessing token shall be a raw string literal. The literal consists of the shortest sequence of characters that matches the raw-string pattern.</source>
          <target state="translated">Si el siguiente car&amp;aacute;cter comienza una secuencia de caracteres que podr&amp;iacute;a ser el prefijo y la comilla doble inicial de un &lt;a href=&quot;string_literal&quot;&gt;literal de cadena sin procesar&lt;/a&gt; , el siguiente token de preprocesamiento ser&amp;aacute; un literal de cadena sin procesar. El literal consiste en la secuencia m&amp;aacute;s corta de caracteres que coincide con el patr&amp;oacute;n de cadena sin formato.</target>
        </trans-unit>
        <trans-unit id="d33bd7b55fb01fe98f2f3acadf5f6a08379b3852" translate="yes" xml:space="preserve">
          <source>If the next pointer for the put area (&lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::streambuf::pptr()&lt;/a&gt;&lt;/code&gt;) is a null pointer, returns zero.</source>
          <target state="translated">Si el siguiente puntero para el &amp;aacute;rea de &lt;code&gt;&lt;a href=&quot;../basic_streambuf/pptr&quot;&gt;std::streambuf::pptr()&lt;/a&gt;&lt;/code&gt; ( std :: streambuf :: pptr () ) es un puntero nulo, devuelve cero.</target>
        </trans-unit>
        <trans-unit id="f2a3a5f033565b87ab609d62fb110b1186e8e3e4" translate="yes" xml:space="preserve">
          <source>If the next pointer is greater than the beginning pointer in a get area, a</source>
          <target state="translated">Si el siguiente puntero es más grande que el puntero inicial en un área de obtención,un</target>
        </trans-unit>
        <trans-unit id="c38cc8ddc7ddabb28e42f0dfb6f798c707698933" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the get area, a</source>
          <target state="translated">Si el siguiente puntero es menor que el puntero final en el área de obtención,un</target>
        </trans-unit>
        <trans-unit id="c4b8d1b94f24bba646631c4092b8de8ae27a04b9" translate="yes" xml:space="preserve">
          <source>If the next pointer is less than the end pointer in the put area, a</source>
          <target state="translated">Si el siguiente puntero es menor que el puntero final en el área de puesta,un</target>
        </trans-unit>
        <trans-unit id="9a69438e54d280f6f9ab5d647f4340372fb34e64" translate="yes" xml:space="preserve">
          <source>If the next three characters are &lt;code&gt;&amp;lt;::&lt;/code&gt; and the subsequent character is neither &lt;code&gt;:&lt;/code&gt; nor &lt;code&gt;&amp;gt;&lt;/code&gt;, the &lt;code&gt;&amp;lt;&lt;/code&gt; is treated as a preprocessing token by itself (and not as the first character of the &lt;a href=&quot;operator_alternative&quot;&gt;alternative token&lt;/a&gt;&lt;code&gt;&amp;lt;:&lt;/code&gt;).</source>
          <target state="translated">Si los siguientes tres caracteres son &lt;code&gt;&amp;lt;::&lt;/code&gt; y el siguiente no es ninguno de los dos &lt;code&gt;:&lt;/code&gt; ni &lt;code&gt;&amp;gt;&lt;/code&gt; , el &lt;code&gt;&amp;lt;&lt;/code&gt; se trata como un token de preprocesamiento por s&amp;iacute; mismo (y no como el primer car&amp;aacute;cter del &lt;a href=&quot;operator_alternative&quot;&gt;token alternativo &lt;/a&gt; &lt;code&gt;&amp;lt;:&lt;/code&gt; :) .</target>
        </trans-unit>
        <trans-unit id="af14e08b4fe197ba9df3e02d9b9e83c72cf7dc83" translate="yes" xml:space="preserve">
          <source>If the number of characters generated for the specified format is less than the value returned by &lt;code&gt;str.width()&lt;/code&gt;, then copies of &lt;code&gt;fill&lt;/code&gt; are inserted to bring the total length of the output sequence to exactly &lt;code&gt;str.width()&lt;/code&gt;, as follows:</source>
          <target state="translated">Si el n&amp;uacute;mero de caracteres generados para el formato especificado es menor que el valor devuelto por &lt;code&gt;str.width()&lt;/code&gt; , se insertan copias de &lt;code&gt;fill&lt;/code&gt; para que la longitud total de la secuencia de salida sea exactamente &lt;code&gt;str.width()&lt;/code&gt; , de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="f0d99c831c2d187591fcd3895e3191880ca06c5c" translate="yes" xml:space="preserve">
          <source>If the number of hard links is cached in this &lt;code&gt;directory_entry&lt;/code&gt;, returns the cached value. Otherwise, returns &lt;code&gt;std::filesystem::hard_link_count(path())&lt;/code&gt; or &lt;code&gt;std::filesystem::hard_link_count(path(), ec)&lt;/code&gt;, respectively.</source>
          <target state="translated">Si el n&amp;uacute;mero de enlaces duros se almacena en cach&amp;eacute; en este &lt;code&gt;directory_entry&lt;/code&gt; , devuelve el valor almacenado en cach&amp;eacute;. De lo contrario, devuelve &lt;code&gt;std::filesystem::hard_link_count(path())&lt;/code&gt; o &lt;code&gt;std::filesystem::hard_link_count(path(), ec)&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="b99a05a29894a68183df39a196889aa25aa975f9" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses exceeds the number of members and bases(since C++17) to initialize, the program is ill-formed.</source>
          <target state="translated">Si el número de cláusulas de inicialización excede el número de miembros y bases (desde C++17)a inicializar,el programa está mal formado.</target>
        </trans-unit>
        <trans-unit id="b81ad8faee1ff23ba51f5fbba00473611ac8e7b6" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members and bases(since C++17) or initializer list is completely empty, the remaining members and bases(since C++17) are initialized by their &lt;a href=&quot;data_members#Member_initialization&quot;&gt;default member initializers&lt;/a&gt;, if provided in the class definition, and otherwise(since C++14) by empty lists, in accordance with the usual &lt;a href=&quot;list_initialization&quot;&gt;list-initialization&lt;/a&gt; rules (which performs value-initialization for non-class types and non-aggregate classes with default constructors, and aggregate initialization for aggregates). If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="translated">Si el n&amp;uacute;mero de cl&amp;aacute;usulas de inicializaci&amp;oacute;n es menor que el n&amp;uacute;mero de miembros y bases (desde C ++ 17) o la lista de inicializadores est&amp;aacute; completamente vac&amp;iacute;a, los miembros y bases restantes (desde C ++ 17) se inicializan por sus &lt;a href=&quot;data_members#Member_initialization&quot;&gt;inicializadores de miembros predeterminados&lt;/a&gt; , si proporcionado en la definici&amp;oacute;n de clase, y de otro modo (desde C ++ 14) mediante listas vac&amp;iacute;as, de acuerdo con las reglas habituales &lt;a href=&quot;list_initialization&quot;&gt;de inicializaci&amp;oacute;n de lista&lt;/a&gt; (que realiza la inicializaci&amp;oacute;n de valor para tipos que no son de clase y clases no agregadas con constructores predeterminados, y agregado inicializaci&amp;oacute;n para agregados). Si un miembro de un tipo de referencia es uno de estos miembros restantes, el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="bb0f41458b43834e51177c5651bbd7795714a125" translate="yes" xml:space="preserve">
          <source>If the number of initializer clauses is less than the number of members or initializer list is completely empty, the remaining members are &lt;a href=&quot;value_initialization&quot;&gt;value-initialized&lt;/a&gt;. If a member of a reference type is one of these remaining members, the program is ill-formed.</source>
          <target state="translated">Si el n&amp;uacute;mero de cl&amp;aacute;usulas de inicializador es menor que el n&amp;uacute;mero de miembros o la lista de inicializadores est&amp;aacute; completamente vac&amp;iacute;a, los miembros restantes se &lt;a href=&quot;value_initialization&quot;&gt;inicializan con valor&lt;/a&gt; . Si un miembro de un tipo de referencia es uno de estos miembros restantes, el programa est&amp;aacute; mal formado.</target>
        </trans-unit>
        <trans-unit id="b0ce7ffb5fd666d693981b8165606cef96184b92" translate="yes" xml:space="preserve">
          <source>If the number of variants is larger than 1, the invocation of the callable object has no complexity requirements.</source>
          <target state="translated">Si el número de variantes es superior a 1,la invocación del objeto llamable no tiene requisitos de complejidad.</target>
        </trans-unit>
        <trans-unit id="30a909a72a6ffc780941652c5f3605de8c85f27e" translate="yes" xml:space="preserve">
          <source>If the object being deleted has incomplete class type at the point of deletion, and the complete class has a non-trivial destructor or a deallocation function, the behavior is undefined.</source>
          <target state="translated">Si el objeto que se está borrando tiene un tipo de clase incompleto en el punto de borrado,y la clase completa tiene un destructor no trivial o una función de deslocalización,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="94419747850ceda4ef56a69f80c16b2a13fb641e" translate="yes" xml:space="preserve">
          <source>If the object contains a value and the type &lt;code&gt;T&lt;/code&gt; is not trivially destructible (see &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible&lt;/a&gt;&lt;/code&gt;), destroys the contained value by calling its destructor, as if by &lt;code&gt;value().T::~T()&lt;/code&gt;.</source>
          <target state="translated">Si el objeto contiene un valor y el tipo &lt;code&gt;T&lt;/code&gt; no es trivialmente destructible (vea &lt;code&gt;&lt;a href=&quot;../../types/is_destructible&quot;&gt;std::is_trivially_destructible&lt;/a&gt;&lt;/code&gt; ), destruye el valor contenido llamando a su destructor, como si fuera &lt;code&gt;value().T::~T()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec70e1f18459a8290a0f4bd35e232554ccfd607b" translate="yes" xml:space="preserve">
          <source>If the object is an array of unknown size, and the supplied brace-enclosed initializer list has &lt;code&gt;n&lt;/code&gt; clauses, the size of the array is &lt;code&gt;n&lt;/code&gt;. (Note that the object in this case cannot be a non-static data member: a member must have complete type.)</source>
          <target state="translated">Si el objeto es una matriz de tama&amp;ntilde;o desconocido, y la lista de inicializadores entre par&amp;eacute;ntesis suministrada tiene &lt;code&gt;n&lt;/code&gt; cl&amp;aacute;usulas, el tama&amp;ntilde;o de la matriz es &lt;code&gt;n&lt;/code&gt; . (Tenga en cuenta que el objeto en este caso no puede ser un miembro de datos no est&amp;aacute;tico: un miembro debe tener un tipo completo).</target>
        </trans-unit>
        <trans-unit id="dc925382d2c313f9d5510edd341c98dae666642c" translate="yes" xml:space="preserve">
          <source>If the object pointed to by &lt;code&gt;ptr&lt;/code&gt; is already owned, the function results in undefined behavior.</source>
          <target state="translated">Si el objeto apuntado por &lt;code&gt;ptr&lt;/code&gt; ya es propiedad, la funci&amp;oacute;n da como resultado un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="6178c7826636249aa31114e15b28fd10b4ae9c38" translate="yes" xml:space="preserve">
          <source>If the object to which the glvalue refers contains an indeterminate value (such as obtained by &lt;a href=&quot;default_initialization&quot;&gt;default initializing&lt;/a&gt; a non-class automatic variable), the behavior is &lt;a href=&quot;ub&quot;&gt;undefined&lt;/a&gt;.</source>
          <target state="translated">Si el objeto al que se refiere el valor gl contiene un valor indeterminado (como el que se obtiene por &lt;a href=&quot;default_initialization&quot;&gt;defecto al inicializar&lt;/a&gt; una variable autom&amp;aacute;tica que no es de clase), el comportamiento es &lt;a href=&quot;ub&quot;&gt;indefinido&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="854c163308d68bcd5f11e6e68fac53ee79ca0fa5" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memcpy&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="translated">Si los objetos son &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potencialmente solapantes&lt;/a&gt; o no &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , el comportamiento de &lt;code&gt;memcpy&lt;/code&gt; no se especifica y &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;puede ser indefinido&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e24e2140fc5eb50908480c6b3a23eb41b37cf132" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memcpy&lt;/code&gt; is not specified and &lt;a href=&quot;https://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43ec58c2abf0222a29b0c8fffc8a48f853af4796" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memmove&lt;/code&gt; is not specified and &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="translated">Si los objetos son &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potencialmente solapantes&lt;/a&gt; o no &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , el comportamiento de &lt;code&gt;memmove&lt;/code&gt; no se especifica y &lt;a href=&quot;http://stackoverflow.com/questions/29777492&quot;&gt;puede ser indefinido&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="547b06003f53e07b23459e9de5e95b459a9ac7c1" translate="yes" xml:space="preserve">
          <source>If the objects are &lt;a href=&quot;../../language/objects#Subobjects&quot;&gt;potentially-overlapping&lt;/a&gt; or not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior of &lt;code&gt;memmove&lt;/code&gt; is not specified and &lt;a href=&quot;https://stackoverflow.com/questions/29777492&quot;&gt;may be undefined&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af231aef821c421dada8c16256fc78ace43c4fd5" translate="yes" xml:space="preserve">
          <source>If the objects are not &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;, the behavior is undefined.</source>
          <target state="translated">Si los objetos no son &lt;a href=&quot;../../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="7439cc88d3247f96faa2170d824e55add0c21fea" translate="yes" xml:space="preserve">
          <source>If the objects overlap, the behavior is undefined.</source>
          <target state="translated">Si los objetos se superponen,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="cfd990fe5c8c1f9320d43b19453f94b1906d5b8d" translate="yes" xml:space="preserve">
          <source>If the old locale's encoding is state-dependent and file is not positioned at the beginning, then the new locale must have the same &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; facet as the one previously imbued.</source>
          <target state="translated">Si la codificaci&amp;oacute;n de la configuraci&amp;oacute;n regional anterior depende del estado y el archivo no est&amp;aacute; posicionado al principio, entonces la configuraci&amp;oacute;n regional nueva debe tener la misma faceta &lt;code&gt;&lt;a href=&quot;../../locale/codecvt&quot;&gt;std::codecvt&lt;/a&gt;&lt;/code&gt; que la previamente imbuida.</target>
        </trans-unit>
        <trans-unit id="7518873ec88dce6433b77a202724dd872b5facce" translate="yes" xml:space="preserve">
          <source>If the old pointer was non-empty, deletes the previously managed object &lt;code&gt;if(old_ptr) get_deleter()(old_ptr)&lt;/code&gt;.</source>
          <target state="translated">Si el puntero anterior no estaba vac&amp;iacute;o, elimina el objeto administrado anteriormente &lt;code&gt;if(old_ptr) get_deleter()(old_ptr)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4dd6552f73dd69bf5933722a03efee57f0b98bea" translate="yes" xml:space="preserve">
          <source>If the open operation succeeds and &lt;code&gt;openmode &amp;amp; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt; != 0&lt;/code&gt; (the &lt;code&gt;ate&lt;/code&gt; bit is set), repositions the file position to the end of file, as if by calling &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;)&lt;/code&gt;, where &lt;code&gt;file&lt;/code&gt; is the pointer returned by calling &lt;code&gt;fopen&lt;/code&gt;. If the repositioning fails, calls &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; and returns a null pointer to indicate failure.</source>
          <target state="translated">Si la operaci&amp;oacute;n de apertura tiene &amp;eacute;xito y &lt;code&gt;openmode &amp;amp; &lt;a href=&quot;../ios_base/openmode&quot;&gt;std::ios_base::ate&lt;/a&gt; != 0&lt;/code&gt; (se establece el bit de &lt;code&gt;ate&lt;/code&gt; ), reposiciona la posici&amp;oacute;n del archivo al final del archivo, como si llamara &lt;code&gt;&lt;a href=&quot;../c/fseek&quot;&gt;std::fseek&lt;/a&gt;(file, 0, &lt;a href=&quot;../c&quot;&gt;SEEK_END&lt;/a&gt;)&lt;/code&gt; , donde &lt;code&gt;file&lt;/code&gt; es el puntero devuelto al llamar a &lt;code&gt;fopen&lt;/code&gt; . Si el reposicionamiento falla, las llamadas &lt;code&gt;&lt;a href=&quot;close&quot;&gt;close()&lt;/a&gt;&lt;/code&gt; y devuelve un puntero nulo para indicar un error.</target>
        </trans-unit>
        <trans-unit id="1df990f7386ff3f2cc16de12a9e72eb727c483f2" translate="yes" xml:space="preserve">
          <source>If the operand is not &lt;code&gt;bool&lt;/code&gt;, it is converted to &lt;code&gt;bool&lt;/code&gt; using &lt;a href=&quot;implicit_cast&quot;&gt;contextual conversion to bool&lt;/a&gt;: it is only well-formed if the declaration &lt;code&gt;bool t(arg)&lt;/code&gt; is well-formed, for some invented temporary &lt;code&gt;t&lt;/code&gt;.</source>
          <target state="translated">Si el operando no es &lt;code&gt;bool&lt;/code&gt; , se convierte en &lt;code&gt;bool&lt;/code&gt; usando la &lt;a href=&quot;implicit_cast&quot;&gt;conversi&amp;oacute;n contextual a bool&lt;/a&gt; : solo est&amp;aacute; bien formado si la declaraci&amp;oacute;n &lt;code&gt;bool t(arg)&lt;/code&gt; est&amp;aacute; bien formada, para algunos &lt;code&gt;t&lt;/code&gt; temporales inventados .</target>
        </trans-unit>
        <trans-unit id="910435839383d33c5dc2d8d4ba19e0ed1ca648ae" translate="yes" xml:space="preserve">
          <source>If the operand is the name of an overloaded function, the address may be taken only if the overload can be resolved due to context. See &lt;a href=&quot;overloaded_address&quot;&gt;Address of an overloaded function&lt;/a&gt; for details.</source>
          <target state="translated">Si el operando es el nombre de una funci&amp;oacute;n sobrecargada, la direcci&amp;oacute;n solo se puede tomar si la sobrecarga se puede resolver debido al contexto. Vea la &lt;a href=&quot;overloaded_address&quot;&gt;direcci&amp;oacute;n de una funci&amp;oacute;n sobrecargada&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="edcca376b9017a314c5ce3c74e8c8cd913ab1436" translate="yes" xml:space="preserve">
          <source>If the operand of the post-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="translated">Si el operando del operador posterior al incremento es de tipo &lt;code&gt;bool&lt;/code&gt; , se establece en &lt;code&gt;true&lt;/code&gt; (en desuso) (hasta C ++ 17).</target>
        </trans-unit>
        <trans-unit id="6058f3bacdd6399a42fe9ae2e370059cb00c4139" translate="yes" xml:space="preserve">
          <source>If the operand of the pre-increment operator is of type &lt;code&gt;bool&lt;/code&gt;, it is set to &lt;code&gt;true&lt;/code&gt;(deprecated).(until C++17).</source>
          <target state="translated">Si el operando del operador previo al incremento es del tipo &lt;code&gt;bool&lt;/code&gt; , se establece en &lt;code&gt;true&lt;/code&gt; (en desuso) (hasta C ++ 17).</target>
        </trans-unit>
        <trans-unit id="6c5fbbf8cf6f23e69c16207aea6b5866059dd114" translate="yes" xml:space="preserve">
          <source>If the operand passed to an arithmetic operator is integral or unscoped enumeration type, then before any other action (but after lvalue-to-rvalue conversion, if applicable), the operand undergoes &lt;a href=&quot;implicit_cast#Integral_promotion&quot;&gt;integral promotion&lt;/a&gt;. If an operand has array or function type, array-to-pointer and function-to-pointer conversions are applied.</source>
          <target state="translated">Si el operando pasado a un operador aritm&amp;eacute;tico es un tipo de enumeraci&amp;oacute;n integral o sin &amp;aacute;mbito, entonces antes de cualquier otra acci&amp;oacute;n (pero despu&amp;eacute;s de la conversi&amp;oacute;n de valor a valor, si corresponde), el operando se somete &lt;a href=&quot;implicit_cast#Integral_promotion&quot;&gt; promoci&amp;oacute;n integral&lt;/a&gt; . Si un operando tiene un tipo de matriz o funci&amp;oacute;n, se aplican las conversiones de matriz a puntero y de funci&amp;oacute;n a puntero.</target>
        </trans-unit>
        <trans-unit id="b2856e7c84ee7bcd9c7d54aff911eeecd1a576e8" translate="yes" xml:space="preserve">
          <source>If the operand to &lt;code&gt;typeid&lt;/code&gt; is a class type or a reference to a class type, then that class type must not be an &lt;a href=&quot;incomplete_type&quot;&gt;incomplete type&lt;/a&gt;.</source>
          <target state="translated">Si el operando a &lt;code&gt;typeid&lt;/code&gt; es un tipo de clase o una referencia a un tipo de clase, entonces ese tipo de clase no debe ser un &lt;a href=&quot;incomplete_type&quot;&gt;tipo incompleto&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a6f60e09ec075130d1f28f4c735c3e62c6710a29" translate="yes" xml:space="preserve">
          <source>If the operands has arithmetic or enumeration type (scoped or unscoped),</source>
          <target state="translated">Si el operando tiene un tipo aritmético o de enumeración (con o sin alcance),</target>
        </trans-unit>
        <trans-unit id="0f10e3bc67559ed7f0001e6e7e37e3c27f4624c6" translate="yes" xml:space="preserve">
          <source>If the operation would result in &lt;code&gt;size() &amp;gt; max_size()&lt;/code&gt;, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la operaci&amp;oacute;n da como resultado &lt;code&gt;size() &amp;gt; max_size()&lt;/code&gt; , arroja &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b217f2aa9381c149a3dabe0b7cf0fe6551f65c06" translate="yes" xml:space="preserve">
          <source>If the options argument was not supplied, returns &lt;code&gt;options::none&lt;/code&gt;.</source>
          <target state="translated">Si no se proporcion&amp;oacute; el argumento de opciones, devuelve &lt;code&gt;options::none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b113388f82173776cc247c5cef46e3268d0b48fb" translate="yes" xml:space="preserve">
          <source>If the orientation of the stream has already been decided (by executing output or by an earlier call to fwide), this function does nothing.</source>
          <target state="translated">Si la orientación del flujo ya se ha decidido (mediante la ejecución de la salida o mediante una llamada anterior a fwide),esta función no hace nada.</target>
        </trans-unit>
        <trans-unit id="1de522a1c1fdc728580e466d8485c9d4aecac535" translate="yes" xml:space="preserve">
          <source>If the original pointer is pointing to a base class subobject within an object of some polymorphic type, &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; may be used to obtain a &lt;code&gt;void*&lt;/code&gt; that is pointing at the complete object of the most derived type.</source>
          <target state="translated">Si el puntero original apunta a un subobjeto de clase base dentro de un objeto de alg&amp;uacute;n tipo polim&amp;oacute;rfico, se puede usar &lt;a href=&quot;dynamic_cast&quot;&gt;dynamic_cast&lt;/a&gt; para obtener un &lt;code&gt;void*&lt;/code&gt; que apunta al objeto completo del tipo m&amp;aacute;s derivado.</target>
        </trans-unit>
        <trans-unit id="990f3e3a0b5d27b439c43881744b60db8d8b4e06" translate="yes" xml:space="preserve">
          <source>If the output could not be generated, sets &lt;code&gt;failbit&lt;/code&gt;, If exceptions on failbit are enabled in this stream's exception mask, throws &lt;a href=&quot;../io/ios_base/failure&quot;&gt;&lt;code&gt;ios_base::failure&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">Si no se pudo generar la salida, establece &lt;code&gt;failbit&lt;/code&gt; , si las excepciones en failbit est&amp;aacute;n habilitadas en la m&amp;aacute;scara de excepci&amp;oacute;n de este flujo, arroja &lt;a href=&quot;../io/ios_base/failure&quot;&gt; &lt;code&gt;ios_base::failure&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="36e1dfece2770bc2927fb6c9f13e3ae6d4aa3615" translate="yes" xml:space="preserve">
          <source>If the output fails for any reason, sets &lt;code&gt;badbit&lt;/code&gt;.</source>
          <target state="translated">Si la salida falla por alg&amp;uacute;n motivo, establece &lt;code&gt;badbit&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b185a676601b8249554276be7b4af45b951241d" translate="yes" xml:space="preserve">
          <source>If the output sequence write position is not available (the buffer is full), then calls &lt;code&gt;overflow(ch)&lt;/code&gt;.</source>
          <target state="translated">Si la posici&amp;oacute;n de escritura de la secuencia de salida no est&amp;aacute; disponible (el b&amp;uacute;fer est&amp;aacute; lleno), entonces se &lt;code&gt;overflow(ch)&lt;/code&gt; llamada (ch) .</target>
        </trans-unit>
        <trans-unit id="0ddd7375e8e8b7ed3f1d22a6f4f461c76fda6d26" translate="yes" xml:space="preserve">
          <source>If the overload resolution selects a built-in candidate, the &lt;a href=&quot;implicit_cast&quot;&gt;user-defined conversion sequence&lt;/a&gt; from an operand of class type is not allowed to have a second standard conversion sequence: the user-defined conversion function must give the expected operand type directly:</source>
          <target state="translated">Si la resoluci&amp;oacute;n de sobrecarga selecciona un candidato incorporado, el &lt;a href=&quot;implicit_cast&quot;&gt; secuencia de conversi&amp;oacute;n definida por usuario&lt;/a&gt; de un operando de tipo de clase no puede tener una segunda secuencia de conversi&amp;oacute;n est&amp;aacute;ndar: la funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario debe proporcionar el tipo de operando esperado directamente:</target>
        </trans-unit>
        <trans-unit id="0339e3bc8e944d80de0d65db76ef29721018ee48" translate="yes" xml:space="preserve">
          <source>If the parameter &lt;code&gt;icase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the character class ignores character case, e.g. the regex &lt;code&gt;[:lower:]&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; generates a call to &lt;code&gt;regex_traits&amp;lt;&amp;gt;::lookup_classname()&lt;/code&gt; with &lt;code&gt;[first, last)&lt;/code&gt; indicating the string &lt;code&gt;&quot;lower&quot;&lt;/code&gt; and &lt;code&gt;icase == true&lt;/code&gt;. This call returns the same bitmask as the call generated by the regex &lt;code&gt;[:alpha:]&lt;/code&gt; with &lt;code&gt;icase == false&lt;/code&gt;.</source>
          <target state="translated">Si el par&amp;aacute;metro &lt;code&gt;icase&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , la clase de caracteres ignora las may&amp;uacute;sculas y min&amp;uacute;sculas, por ejemplo, regex &lt;code&gt;[:lower:]&lt;/code&gt; con &lt;code&gt;&lt;a href=&quot;../syntax_option_type&quot;&gt;std::regex_constants::icase&lt;/a&gt;&lt;/code&gt; genera una llamada a &lt;code&gt;regex_traits&amp;lt;&amp;gt;::lookup_classname()&lt;/code&gt; con &lt;code&gt;[first, last)&lt;/code&gt; indicando el string &lt;code&gt;&quot;lower&quot;&lt;/code&gt; y &lt;code&gt;icase == true&lt;/code&gt; . Esta llamada devuelve la misma m&amp;aacute;scara de bits que la llamada generada por la expresi&amp;oacute;n regular &lt;code&gt;[:alpha:]&lt;/code&gt; con &lt;code&gt;icase == false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71a8649df3ecbbada92cdc80a78f0174dc434084" translate="yes" xml:space="preserve">
          <source>If the parameter of the catch-clause is a reference type, any changes made to it are reflected in the exception object, and can be observed by another handler if the exception is rethrown with &lt;code&gt;throw;&lt;/code&gt;. If the parameter is not a reference, any changes made to it are are local and its lifetime ends when the handler exits.</source>
          <target state="translated">Si el par&amp;aacute;metro de la cl&amp;aacute;usula catch es un tipo de referencia, cualquier cambio realizado se refleja en el objeto de excepci&amp;oacute;n y puede ser observado por otro controlador si la excepci&amp;oacute;n se vuelve a &lt;code&gt;throw;&lt;/code&gt; con throw; . Si el par&amp;aacute;metro no es una referencia, cualquier cambio realizado en &amp;eacute;l es local y su vida &amp;uacute;til finaliza cuando finaliza el controlador.</target>
        </trans-unit>
        <trans-unit id="6dad0498ed0cf6b6b98d4eaaf808c912c3d3152c" translate="yes" xml:space="preserve">
          <source>If the parameter type is &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt;, and there is an non-narrowing implicit conversion from every element of the initializer list to &lt;code&gt;X&lt;/code&gt;, the implicit conversion sequence for the purpose of overload resolution is the worst conversion necessary. If the braced-init-list is empty, the conversion sequence is the identity conversion.</source>
          <target state="translated">Si el tipo de par&amp;aacute;metro es &lt;code&gt;&lt;a href=&quot;../utility/initializer_list&quot;&gt;std::initializer_list&lt;/a&gt;&amp;lt;X&amp;gt;&lt;/code&gt; , y hay una conversi&amp;oacute;n impl&amp;iacute;cita no estrecha de cada elemento de la lista de inicializador a &lt;code&gt;X&lt;/code&gt; , la secuencia de conversi&amp;oacute;n impl&amp;iacute;cita para la resoluci&amp;oacute;n de sobrecarga es la peor conversi&amp;oacute;n necesaria. Si braced-init-list est&amp;aacute; vac&amp;iacute;a, la secuencia de conversi&amp;oacute;n es la conversi&amp;oacute;n de identidad.</target>
        </trans-unit>
        <trans-unit id="18426061d489bcb10c6138a5612f8728895a21a5" translate="yes" xml:space="preserve">
          <source>If the parameter type is some aggregate &lt;code&gt;X&lt;/code&gt; and the initializer list consists of exactly one element of same or derived class (possibly cv-qualified), the implicit conversion sequence is the one required to convert the element to the parameter type.</source>
          <target state="translated">Si el tipo de par&amp;aacute;metro es un agregado &lt;code&gt;X&lt;/code&gt; y la lista de inicializaci&amp;oacute;n consta de exactamente un elemento de la misma clase o derivada (posiblemente calificada por cv), la secuencia de conversi&amp;oacute;n impl&amp;iacute;cita es la necesaria para convertir el elemento al tipo de par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="d845ac35c60a3d6398352b7893d2603e6b328c05" translate="yes" xml:space="preserve">
          <source>If the parent directory is outside directory hierarchy that is iterated on (i.e. &lt;code&gt;depth() == 0&lt;/code&gt;), sets &lt;code&gt;*this&lt;/code&gt; to an end directory iterator.</source>
          <target state="translated">Si el directorio principal est&amp;aacute; fuera de la jerarqu&amp;iacute;a de directorios en la que se repite (es decir, &lt;code&gt;depth() == 0&lt;/code&gt; ), establece &lt;code&gt;*this&lt;/code&gt; en un iterador de directorio final.</target>
        </trans-unit>
        <trans-unit id="8f12e10b26c51070735d7546640510f221a4a717" translate="yes" xml:space="preserve">
          <source>If the parsing succeeds, does not change &lt;code&gt;err&lt;/code&gt;, and stores the result in &lt;code&gt;units&lt;/code&gt; or &lt;code&gt;digits&lt;/code&gt;.</source>
          <target state="translated">Si el an&amp;aacute;lisis tiene &amp;eacute;xito, no cambia &lt;code&gt;err&lt;/code&gt; , y almacena el resultado en &lt;code&gt;units&lt;/code&gt; o &lt;code&gt;digits&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="704ea65740c7ae23e0fe2ae321dd1d4cee11f634" translate="yes" xml:space="preserve">
          <source>If the part of the regular expression that matched is just an &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript#Assertions&quot;&gt;assertion&lt;/a&gt; (&lt;code&gt;^&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\B&lt;/code&gt;), the match stored in the iterator is a zero-length match, that is, &lt;code&gt;match[0].first == match[0].second&lt;/code&gt;.</source>
          <target state="translated">Si la parte de la expresi&amp;oacute;n regular que coincide es solo una &lt;a href=&quot;http://en.cppreference.com/w/cpp/regex/ecmascript#Assertions&quot;&gt;aserci&amp;oacute;n&lt;/a&gt; ( &lt;code&gt;^&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; , &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\B&lt;/code&gt; ), la coincidencia almacenada en el iterador es una coincidencia de longitud cero, es decir, &lt;code&gt;match[0].first == match[0].second&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a2ebed057a709d5166451a5bb4fdfc9d04cff29d" translate="yes" xml:space="preserve">
          <source>If the path &lt;code&gt;p&lt;/code&gt; refers to a symbolic link, returns a new path object which refers to the target of that symbolic link.</source>
          <target state="translated">Si la ruta &lt;code&gt;p&lt;/code&gt; se refiere a un enlace simb&amp;oacute;lico, devuelve un nuevo objeto de ruta que se refiere al objetivo de ese enlace simb&amp;oacute;lico.</target>
        </trans-unit>
        <trans-unit id="a5a2ee3308db767e5626b5d282347713ca3b32db" translate="yes" xml:space="preserve">
          <source>If the pathname is either &lt;code&gt;.&lt;/code&gt; or &lt;code&gt;..&lt;/code&gt;, or if &lt;a href=&quot;filename&quot;&gt;&lt;code&gt;filename()&lt;/code&gt;&lt;/a&gt; does not contain the &lt;code&gt;.&lt;/code&gt; character, then empty path is returned.</source>
          <target state="translated">Si el nombre de ruta es cualquiera &lt;code&gt;.&lt;/code&gt; o &lt;code&gt;..&lt;/code&gt; , o si &lt;a href=&quot;filename&quot;&gt; &lt;code&gt;filename()&lt;/code&gt; &lt;/a&gt; no contiene el &lt;code&gt;.&lt;/code&gt; car&amp;aacute;cter, luego se devuelve la ruta vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="422fd574496432a86171fe46fb0d9e0b579301d4" translate="yes" xml:space="preserve">
          <source>If the pattern ([pat_first, pat_last)) is empty, returns &lt;code&gt;make_pair(first, first)&lt;/code&gt;.</source>
          <target state="translated">Si el patr&amp;oacute;n ([pat_first, pat_last)) est&amp;aacute; vac&amp;iacute;o, devuelve &lt;code&gt;make_pair(first, first)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70f9539cc95e6db66dffafbd8aa72c5758b90e7b" translate="yes" xml:space="preserve">
          <source>If the pattern was matched, but the parsed value is not in the range representable by the type of &lt;code&gt;value&lt;/code&gt;, returns value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;ptr&lt;/code&gt; points at the first character not matching the pattern. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="translated">Si el patr&amp;oacute;n coincide, pero el valor analizado no est&amp;aacute; en el rango representable por el tipo de &lt;code&gt;value&lt;/code&gt; , devuelve el valor de tipo &lt;code&gt;from_chars_result&lt;/code&gt; de modo que &lt;code&gt;ec&lt;/code&gt; es igual a &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::result_out_of_range&lt;/a&gt;&lt;/code&gt; y los puntos &lt;code&gt;ptr&lt;/code&gt; en el primer car&amp;aacute;cter no coinciden con el patr&amp;oacute;n. &lt;code&gt;value&lt;/code&gt; no se modifica.</target>
        </trans-unit>
        <trans-unit id="0a87d6d2f05d467c7b59a0780f341a0df12fb06a" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;auto&lt;/code&gt;or type-constraint&lt;code&gt;auto&lt;/code&gt;(since C++20), the variable type is deduced from the initializer using the rules for &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt; from a function call (see &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;template argument deduction#Other contexts&lt;/a&gt; for details).</source>
          <target state="translated">Si el tipo de marcador de posici&amp;oacute;n especificador es &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tico , o tipo de limitaci&amp;oacute;n &lt;code&gt;auto&lt;/code&gt; m&amp;aacute;tica (desde C ++ 20), el tipo de variable se deduce de la inicializaci&amp;oacute;n utilizando las reglas para la &lt;a href=&quot;template_argument_deduction&quot;&gt;deducci&amp;oacute;n de argumento de plantilla&lt;/a&gt; a partir de una llamada de funci&amp;oacute;n (ver &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;par&amp;aacute;metro de plantilla deducci&amp;oacute;n # Otros contextos&lt;/a&gt; para m&amp;aacute;s detalles) .</target>
        </trans-unit>
        <trans-unit id="2276b641f558192e6893ac9cc30b93561ac6a1e7" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is &lt;code&gt;decltype(auto)&lt;/code&gt;or type-constraint&lt;code&gt;decltype(auto)&lt;/code&gt;(since C++20), the deduced type is &lt;code&gt;decltype(e)&lt;/code&gt;, where &lt;code&gt;e&lt;/code&gt; is the initializer.</source>
          <target state="translated">Si el especificador de tipo de marcador de posici&amp;oacute;n es &lt;code&gt;decltype(auto)&lt;/code&gt; o restricci&amp;oacute;n de tipo &lt;code&gt;decltype(auto)&lt;/code&gt; (desde C ++ 20), el tipo deducido es &lt;code&gt;decltype(e)&lt;/code&gt; , donde &lt;code&gt;e&lt;/code&gt; es el inicializador.</target>
        </trans-unit>
        <trans-unit id="ac0eb770b354dc56dd2f5ee40b48df9887d2f9d4" translate="yes" xml:space="preserve">
          <source>If the placeholder type specifier is used to declare multiple variables, the deduced types must match. For example, the declaration &lt;code&gt;auto i = 0, d = 0.0;&lt;/code&gt; is ill-formed, while the declaration &lt;code&gt;auto i = 0, *p = &amp;amp;i;&lt;/code&gt; is well-formed and the &lt;code&gt;auto&lt;/code&gt; is deduced as &lt;code&gt;int&lt;/code&gt;.</source>
          <target state="translated">Si el especificador de tipo de marcador de posici&amp;oacute;n se utiliza para declarar m&amp;uacute;ltiples variables, los tipos deducidos deben coincidir. Por ejemplo, la declaraci&amp;oacute;n &lt;code&gt;auto i = 0, d = 0.0;&lt;/code&gt; est&amp;aacute; mal formado, mientras que la declaraci&amp;oacute;n &lt;code&gt;auto i = 0, *p = &amp;amp;i;&lt;/code&gt; est&amp;aacute; bien formado y el &lt;code&gt;auto&lt;/code&gt; se deduce como &lt;code&gt;int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05226f11d77b34f54e805ec7153e749dfb3f47a5" translate="yes" xml:space="preserve">
          <source>If the platform uses mixed endian, &lt;code&gt;std::endian::native&lt;/code&gt; does not equal either &lt;code&gt;std::endian::big&lt;/code&gt; nor &lt;code&gt;std::endian::little&lt;/code&gt;</source>
          <target state="translated">Si la plataforma usa endian mixto, &lt;code&gt;std::endian::native&lt;/code&gt; no es igual a &lt;code&gt;std::endian::big&lt;/code&gt; ni &lt;code&gt;std::endian::little&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="12d037e01ff534df66a9b8a862a8773089ded879" translate="yes" xml:space="preserve">
          <source>If the pointer (either &lt;code&gt;gptr&lt;/code&gt; or &lt;code&gt;pptr&lt;/code&gt; or both) is repositioned, it is done as follows:</source>
          <target state="translated">Si el puntero (ya sea &lt;code&gt;gptr&lt;/code&gt; o &lt;code&gt;pptr&lt;/code&gt; o ambos) se reposiciona, se hace de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="28cec222b90e62fa53ecba18ed8db910c7df5ecd" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, and the pointer &lt;code&gt;Q&lt;/code&gt; points at the &lt;code&gt;j&lt;/code&gt;th element of the same array, the expression &lt;code&gt;P-Q&lt;/code&gt; has the value &lt;code&gt;i-j&lt;/code&gt;, if the value fits in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;. Both operands must point to the elements of the same array (or one past the end), otherwise the behavior is undefined. If the result does not fit in &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si el puntero &lt;code&gt;P&lt;/code&gt; puntos para el &lt;code&gt;i&lt;/code&gt; -&amp;eacute;simo elemento de una matriz, y el puntero de &lt;code&gt;Q&lt;/code&gt; puntos en el &lt;code&gt;j&lt;/code&gt; -&amp;eacute;simo elemento de la misma matriz, la expresi&amp;oacute;n &lt;code&gt;P-Q&lt;/code&gt; tiene el valor &lt;code&gt;i-j&lt;/code&gt; , si los ajustes de valor en &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; . Ambos operandos deben apuntar a los elementos de la misma matriz (o uno m&amp;aacute;s all&amp;aacute; del final), de lo contrario el comportamiento es indefinido. Si el resultado no cabe en &lt;code&gt;&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="2c3af6cf6b2fece3bf06d95f3b15704d049a2a68" translate="yes" xml:space="preserve">
          <source>If the pointer &lt;code&gt;P&lt;/code&gt; points to the &lt;code&gt;i&lt;/code&gt;th element of an array, then the expressions &lt;code&gt;P+n&lt;/code&gt;, &lt;code&gt;n+P&lt;/code&gt;, and &lt;code&gt;P-n&lt;/code&gt; are pointers of the same type that point to the &lt;code&gt;i+n&lt;/code&gt;th, &lt;code&gt;i+n&lt;/code&gt;th, and &lt;code&gt;i-n&lt;/code&gt;th element of the same array, respectively. The result of pointer addition may also be a one-past-the-end pointer (that is, pointer &lt;code&gt;P&lt;/code&gt; such that the expression &lt;code&gt;P-1&lt;/code&gt; points to the last element of the array). Any other situations (that is, attempts to generate a pointer that isn't pointing at an element of the same array or one past the end) invoke undefined behavior.</source>
          <target state="translated">Si el puntero &lt;code&gt;P&lt;/code&gt; apunta al &lt;code&gt;i&lt;/code&gt; - &amp;eacute;simo elemento de una matriz, entonces las expresiones &lt;code&gt;P+n&lt;/code&gt; , &lt;code&gt;n+P&lt;/code&gt; y &lt;code&gt;P-n&lt;/code&gt; son punteros del mismo tipo que apuntan a &lt;code&gt;i+n&lt;/code&gt; th, &lt;code&gt;i+n&lt;/code&gt; th, y &lt;code&gt;i-n&lt;/code&gt; th elemento de la misma matriz, respectivamente. El resultado de la adici&amp;oacute;n del puntero tambi&amp;eacute;n puede ser un puntero de un extremo al final (es decir, el puntero &lt;code&gt;P&lt;/code&gt; de modo que la expresi&amp;oacute;n &lt;code&gt;P-1&lt;/code&gt; apunte al &amp;uacute;ltimo elemento de la matriz). Cualquier otra situaci&amp;oacute;n (es decir, intentos de generar un puntero que no est&amp;eacute; apuntando a un elemento de la misma matriz o uno m&amp;aacute;s all&amp;aacute; del final) invoca un comportamiento indefinido.</target>
        </trans-unit>
        <trans-unit id="0ca8d499f0d01575fddc904d502c2ba50ea7a28f" translate="yes" xml:space="preserve">
          <source>If the pointer is advanced and then &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; is called to flush the put area to the associated character sequence, the effect is that extra &lt;code&gt;count&lt;/code&gt; characters with undefined values are output.</source>
          <target state="translated">Si se avanza el puntero y luego se llama a &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; para enjuagar el &amp;aacute;rea de colocaci&amp;oacute;n a la secuencia de caracteres asociada, el efecto es que se &lt;code&gt;count&lt;/code&gt; caracteres de recuento adicionales con valores indefinidos.</target>
        </trans-unit>
        <trans-unit id="e450bd3f7a3a2237b2e10ff661bc465b1471234b" translate="yes" xml:space="preserve">
          <source>If the pointers stored in &lt;code&gt;pword&lt;/code&gt; require management, &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; may be used to install handlers that execute deep copy or deallocation as needed.</source>
          <target state="translated">Si los punteros almacenados en &lt;code&gt;pword&lt;/code&gt; requieren administraci&amp;oacute;n, se puede utilizar &lt;code&gt;&lt;a href=&quot;register_callback&quot;&gt;register_callback()&lt;/a&gt;&lt;/code&gt; para instalar controladores que ejecuten copia profunda o desasignaci&amp;oacute;n seg&amp;uacute;n sea necesario.</target>
        </trans-unit>
        <trans-unit id="16ee378b87cd08352666411c9cd09d7998ae045a" translate="yes" xml:space="preserve">
          <source>If the pool selected for a block of size &lt;code&gt;bytes&lt;/code&gt; is unable to satisfy the request from its internal data structures, calls &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource to obtain memory.</source>
          <target state="translated">Si el grupo seleccionado para un bloque de &lt;code&gt;bytes&lt;/code&gt; de tama&amp;ntilde;o no puede satisfacer la solicitud de sus estructuras de datos internas, las llamadas &lt;code&gt;allocate()&lt;/code&gt; en el recurso de memoria ascendente para obtener memoria.</target>
        </trans-unit>
        <trans-unit id="9eafb34d20e4bdd821ef599345cd0d19bc68a4ab" translate="yes" xml:space="preserve">
          <source>If the precision of the input cannot be exactly represented with seconds, then the format is a decimal floating point number with a fixed format and a precision matching that of the precision of the input (or to a microseconds precision if the conversion to floating point decimal seconds cannot be made within 18 fractional digits). The character for the decimal point is localized according to the locale.</source>
          <target state="translated">Si la precisión de la entrada no puede representarse exactamente con segundos,entonces el formato es un número decimal en coma flotante con un formato fijo y una precisión que coincide con la de la entrada (o con una precisión de microsegundos si la conversión a segundos decimales en coma flotante no puede hacerse dentro de 18 dígitos fraccionarios).El carácter para el punto decimal se localiza según la localidad.</target>
        </trans-unit>
        <trans-unit id="556a0df3f2ed8a7cac546a84886519ac3ebeac8f" translate="yes" xml:space="preserve">
          <source>If the previous stage does not produce a match, all constructors of &lt;code&gt;T&lt;/code&gt; participate in &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;overload resolution&lt;/a&gt; against the set of arguments that consists of the elements of the braced-init-list, with the restriction that only non-narrowing conversions are allowed. If this stage produces an explicit constructor as the best match for a copy-list-initialization, compilation fails (note, in simple copy-initialization, explicit constructors are not considered at all).</source>
          <target state="translated">Si la etapa anterior no produce una coincidencia, todos los constructores de &lt;code&gt;T&lt;/code&gt; participan en la &lt;a href=&quot;overload_resolution#Implicit_conversion_sequence_in_list-initialization&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; contra el conjunto de argumentos que consta de los elementos de la lista de inicializaci&amp;oacute;n arriostrada, con la restricci&amp;oacute;n de que solo se permiten conversiones no limitantes. Si esta etapa produce un constructor expl&amp;iacute;cito como la mejor coincidencia para una inicializaci&amp;oacute;n de lista de copia, la compilaci&amp;oacute;n falla (nota, en la inicializaci&amp;oacute;n de copia simple, los constructores expl&amp;iacute;citos no se consideran en absoluto).</target>
        </trans-unit>
        <trans-unit id="7cc06dc92cb043df323fc3aa474cf3ba56bb3c97" translate="yes" xml:space="preserve">
          <source>If the primary member template is explicitly (fully) specialized for a given (implicit) specialization of the enclosing class template, the partial specializations of the member template are ignored for this specialization of the enclosing class template.</source>
          <target state="translated">Si la plantilla de miembros primaria está explícitamente (completamente)especializada para una especialización dada (implícita)de la plantilla de clase adjunta,se ignoran las especializaciones parciales de la plantilla de miembros para esta especialización de la plantilla de clase adjunta.</target>
        </trans-unit>
        <trans-unit id="adfd306bbffa0b23164cbb3f7616b73a92779a42" translate="yes" xml:space="preserve">
          <source>If the primary template has a exception specification that isn't &lt;code&gt;noexcept(false)&lt;/code&gt;, the explicit specializations must have a compatible exception specification.</source>
          <target state="translated">Si la plantilla primaria tiene una especificaci&amp;oacute;n de excepci&amp;oacute;n que no es ninguna &lt;code&gt;noexcept(false)&lt;/code&gt; , las especializaciones expl&amp;iacute;citas deben tener una especificaci&amp;oacute;n de excepci&amp;oacute;n compatible.</target>
        </trans-unit>
        <trans-unit id="a27f2e5bb1066b5ba8ecb5c6e80fdaaed8988b08" translate="yes" xml:space="preserve">
          <source>If the program closes the file, e.g. by executing &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;std::fclose&lt;/a&gt;&lt;/code&gt;, the file is automatically deleted.</source>
          <target state="translated">Si el programa cierra el archivo, por ejemplo, al ejecutar &lt;code&gt;&lt;a href=&quot;fclose&quot;&gt;std::fclose&lt;/a&gt;&lt;/code&gt; , el archivo se elimina autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="f054e6c94ddb2b1d1ab37e865dadbaa42672443f" translate="yes" xml:space="preserve">
          <source>If the program terminates abnormally, it is implementation-defined if these temporary files are deleted.</source>
          <target state="translated">Si el programa termina de forma anormal,se define la implementación si se eliminan estos archivos temporales.</target>
        </trans-unit>
        <trans-unit id="2165d06ea6d2bb20531c9f3d3cebc5362167aa09" translate="yes" xml:space="preserve">
          <source>If the program terminates normally (by calling &lt;code&gt;&lt;a href=&quot;../../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt;, returning from &lt;code&gt;main&lt;/code&gt;, etc), all files that were opened by calling &lt;code&gt;std::tmpfile&lt;/code&gt; are also automatically deleted.</source>
          <target state="translated">Si el programa finaliza normalmente (llamando a &lt;code&gt;&lt;a href=&quot;../../utility/program/exit&quot;&gt;std::exit&lt;/a&gt;&lt;/code&gt; , volviendo de &lt;code&gt;main&lt;/code&gt; , etc.), todos los archivos que se abrieron llamando a &lt;code&gt;std::tmpfile&lt;/code&gt; tambi&amp;eacute;n se eliminan autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="c4563d58386ce90b83da2edbf6c91576f3250457" translate="yes" xml:space="preserve">
          <source>If the put area becomes full (&lt;code&gt;pptr() == epptr()&lt;/code&gt;), this function may call &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt;, or achieve the effect of calling &lt;code&gt;overflow()&lt;/code&gt; by some other, unspecified, means.</source>
          <target state="translated">Si el &amp;aacute;rea de &lt;code&gt;pptr() == epptr()&lt;/code&gt; se llena ( pptr () == epptr () ), esta funci&amp;oacute;n puede llamar a &lt;code&gt;&lt;a href=&quot;overflow&quot;&gt;overflow()&lt;/a&gt;&lt;/code&gt; , o lograr el efecto de llamar a &lt;code&gt;overflow()&lt;/code&gt; por alg&amp;uacute;n otro medio no especificado.</target>
        </trans-unit>
        <trans-unit id="4470c9cf96cf0b0427223088eda48f753afa8e5d" translate="yes" xml:space="preserve">
          <source>If the range is empty, &lt;code&gt;init&lt;/code&gt; is returned, unmodified.</source>
          <target state="translated">Si el rango est&amp;aacute; vac&amp;iacute;o, se devuelve &lt;code&gt;init&lt;/code&gt; , sin modificar.</target>
        </trans-unit>
        <trans-unit id="0a1fccb7fec68247b6a1b2dd1f263989d79d91a2" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si la relaci&amp;oacute;n &lt;code&gt;R1&lt;/code&gt; es mayor o igual que la relaci&amp;oacute;n &lt;code&gt;R2&lt;/code&gt; , proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a7f289660496e50704c8e12b0a1a4ded1768f65" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is greater than than the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si la relaci&amp;oacute;n &lt;code&gt;R1&lt;/code&gt; es mayor que la relaci&amp;oacute;n &lt;code&gt;R2&lt;/code&gt; , proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="486dc284a8aec5600eb2ce6107311df95fa15c27" translate="yes" xml:space="preserve">
          <source>If the ratio &lt;code&gt;R1&lt;/code&gt; is less than or equal to the ratio &lt;code&gt;R2&lt;/code&gt;, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si la relaci&amp;oacute;n &lt;code&gt;R1&lt;/code&gt; es menor o igual que la relaci&amp;oacute;n &lt;code&gt;R2&lt;/code&gt; , proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c44d3b0dc212e8ac325d4b33e901580daa7a83e" translate="yes" xml:space="preserve">
          <source>If the ratio R1 is less than the ratio R2, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si la relaci&amp;oacute;n R1 es menor que la relaci&amp;oacute;n R2, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="402f8a7cc133b62e154ebba1457929bfddbc3bf0" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si las relaciones R1 y R2 son iguales, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86470dd50c07d87d87cc6afc10ca67f451b58476" translate="yes" xml:space="preserve">
          <source>If the ratios R1 and R2 are not equal, provides the member constant &lt;code&gt;value&lt;/code&gt; equal &lt;code&gt;true&lt;/code&gt;. Otherwise, &lt;code&gt;value&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si las relaciones R1 y R2 no son iguales, proporciona el &lt;code&gt;value&lt;/code&gt; constante del miembro igual a &lt;code&gt;true&lt;/code&gt; . De lo contrario, el &lt;code&gt;value&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ef67dfe973705134074e186274b6c8db214065" translate="yes" xml:space="preserve">
          <source>If the referred-to object was destroyed (e.g. by explicit destructor call), but the storage was not deallocated, a reference to the out-of-lifetime object may be used in limited ways, and may become valid if the object is recreated in the same storage (see &lt;a href=&quot;lifetime#Access_outside_of_lifetime&quot;&gt;Access outside of lifetime&lt;/a&gt; for details).</source>
          <target state="translated">Si el objeto al que se hace referencia se destruy&amp;oacute; (por ejemplo, mediante una llamada expl&amp;iacute;cita al destructor), pero el almacenamiento no se desasign&amp;oacute;, una referencia al objeto fuera de vida se puede usar de formas limitadas, y puede ser v&amp;aacute;lida si el objeto se recrea en el mismo almacenamiento (ver &lt;a href=&quot;lifetime#Access_outside_of_lifetime&quot;&gt;Acceso fuera de la vida &amp;uacute;til&lt;/a&gt; para m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="32e827308169dc81e7dc50577c7dd9c26262ce2a" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a maximum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">Si el representante de &lt;code&gt;rep&lt;/code&gt; resentaci&amp;oacute;n de la duraci&amp;oacute;n requiere alguna otra implementaci&amp;oacute;n para devolver una duraci&amp;oacute;n de longitud m&amp;aacute;xima, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; puede especializarse para devolver el valor deseado.</target>
        </trans-unit>
        <trans-unit id="cf898146c6c3c24b40b13c45caea3516ac8e0db7" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a minimum-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">Si el representante de &lt;code&gt;rep&lt;/code&gt; resentaci&amp;oacute;n de la duraci&amp;oacute;n requiere alguna otra implementaci&amp;oacute;n para devolver una duraci&amp;oacute;n de longitud m&amp;iacute;nima, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; puede especializarse para devolver el valor deseado.</target>
        </trans-unit>
        <trans-unit id="216bb9502dac2c6f6a263c7893d238bdae801fdf" translate="yes" xml:space="preserve">
          <source>If the representation &lt;code&gt;rep&lt;/code&gt; of the duration requires some other implementation to return a zero-length duration, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; can be specialized to return the desired value.</source>
          <target state="translated">Si el representante de &lt;code&gt;rep&lt;/code&gt; resentaci&amp;oacute;n de la duraci&amp;oacute;n requiere alguna otra implementaci&amp;oacute;n para devolver una duraci&amp;oacute;n de longitud cero, &lt;code&gt;&lt;a href=&quot;../duration_values&quot;&gt;std::chrono::duration_values&lt;/a&gt;&lt;/code&gt; puede especializarse para devolver el valor deseado.</target>
        </trans-unit>
        <trans-unit id="79081ea2c3cd338bf77b76285c9d2307dabb3758" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lrint&lt;/code&gt; or &lt;code&gt;std::llrint&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">Si el resultado de &lt;code&gt;std::lrint&lt;/code&gt; o &lt;code&gt;std::llrint&lt;/code&gt; est&amp;aacute; fuera del rango representable por el tipo de retorno, puede producirse un error de dominio o un error de rango.</target>
        </trans-unit>
        <trans-unit id="587dd46cd3feba4cdcd09248f53d64715a053010" translate="yes" xml:space="preserve">
          <source>If the result of &lt;code&gt;std::lround&lt;/code&gt; or &lt;code&gt;std::llround&lt;/code&gt; is outside the range representable by the return type, a domain error or a range error may occur.</source>
          <target state="translated">Si el resultado de &lt;code&gt;std::lround&lt;/code&gt; o &lt;code&gt;std::llround&lt;/code&gt; est&amp;aacute; fuera del rango representable por el tipo de retorno, puede producirse un error de dominio o un error de rango.</target>
        </trans-unit>
        <trans-unit id="f9143780183f7e4a1182584068e608842bda530b" translate="yes" xml:space="preserve">
          <source>If the result of the conversion is unique, then &lt;code&gt;result == local_info::unique&lt;/code&gt;, &lt;code&gt;first&lt;/code&gt; is filled out with the correct &lt;code&gt;std::chrono::sys_info&lt;/code&gt;, and &lt;code&gt;second&lt;/code&gt; is zero-initialized.</source>
          <target state="translated">Si el resultado de la conversi&amp;oacute;n es &amp;uacute;nico, entonces &lt;code&gt;result == local_info::unique&lt;/code&gt; , &lt;code&gt;first&lt;/code&gt; se completa con el &lt;code&gt;std::chrono::sys_info&lt;/code&gt; , y el &lt;code&gt;second&lt;/code&gt; se inicializa a cero.</target>
        </trans-unit>
        <trans-unit id="8eeeae32aeed1e098fc91dd8bd921c86fb200e23" translate="yes" xml:space="preserve">
          <source>If the result of the rounding is outside the range of the return type, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised and an implementation-defined value is returned</source>
          <target state="translated">Si el resultado del redondeo est&amp;aacute; fuera del rango del tipo de retorno, &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; se eleva y se devuelve un valor definido por la implementaci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="40b9661e308f2792d26e6a4e9185df30cab4c8f8" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [-32767, 32767], the actual stored value is unspecified.</source>
          <target state="translated">Si el resultado estuviera fuera del rango [-32767,32767],el valor real almacenado no está especificado.</target>
        </trans-unit>
        <trans-unit id="12704794f475153a5a68233a95befd2418ed3109" translate="yes" xml:space="preserve">
          <source>If the result would be outside the range [0, 255], the actual stored value is unspecified.</source>
          <target state="translated">Si el resultado estuviera fuera del rango [0,255],el valor real almacenado no se especifica.</target>
        </trans-unit>
        <trans-unit id="9b8913f174ebaea61408caa1ef433d1587bd6ffe" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is a function pointer, a pointer to member, or &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_equality&quot;&gt;&lt;code&gt;std::strong_equality&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Si el tipo de puntero resultante es un puntero de funci&amp;oacute;n, un puntero al miembro o &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; devuelve un valor de tipo &lt;a href=&quot;../utility/compare/strong_equality&quot;&gt; &lt;code&gt;std::strong_equality&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="2e78c0f7505a15522acda3776ce4ce10a21d82dd" translate="yes" xml:space="preserve">
          <source>If the resulting pointer type is an object pointer type, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; returns a prvalue of type &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt;&lt;code&gt;strong_ordering&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="translated">Si el tipo de puntero resultante es un tipo de puntero de objeto, &lt;code&gt;p &amp;lt;=&amp;gt; q&lt;/code&gt; devuelve un prvalor de tipo &lt;a href=&quot;../utility/compare/strong_ordering&quot;&gt; &lt;code&gt;strong_ordering&lt;/code&gt; &lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="dbda3e4805d43967af0a89706ef34251ae9306d8" translate="yes" xml:space="preserve">
          <source>If the resulting year value for (1-3) is outside the range [-32767,32767], the actual value stored is unspecified.</source>
          <target state="translated">Si el valor del año resultante para (1-3)está fuera del rango [-32767,32767],el valor real almacenado no está especificado.</target>
        </trans-unit>
        <trans-unit id="d76cd29ea50833e8ec64892b7a35746e9aff8b17" translate="yes" xml:space="preserve">
          <source>If the return statement uses a brace-init-list, deduction is not allowed:</source>
          <target state="translated">Si la declaración de retorno utiliza una lista de llaves,la deducción no está permitida:</target>
        </trans-unit>
        <trans-unit id="fa7a732c5f6541d73e515269ccd1d1ceb3b46448" translate="yes" xml:space="preserve">
          <source>If the return type is &lt;code&gt;decltype(auto)&lt;/code&gt;, the return type is as what would be obtained if the expression used in the return statement were wrapped in &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt;.</source>
          <target state="translated">Si el tipo de retorno es &lt;code&gt;decltype(auto)&lt;/code&gt; , el tipo de retorno es el que se obtendr&amp;iacute;a si la expresi&amp;oacute;n utilizada en la declaraci&amp;oacute;n de retorno se envolviera en &lt;a href=&quot;decltype&quot;&gt;decltype&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d28a3f66a7fff0e2a4e0c4769a914c3fc6299edf" translate="yes" xml:space="preserve">
          <source>If the return type of the function template is a placeholder (&lt;code&gt;auto&lt;/code&gt; or &lt;code&gt;decltype(auto)&lt;/code&gt;), that return type is a non-deduced context and is determined from the instantiation.</source>
          <target state="translated">Si el tipo de retorno de la plantilla de funci&amp;oacute;n es un marcador de posici&amp;oacute;n ( &lt;code&gt;auto&lt;/code&gt; o &lt;code&gt;decltype(auto)&lt;/code&gt; ), ese tipo de retorno es un contexto no deducido y se determina a partir de la instanciaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="55096951d03276844009d4ac6ef2f86a40234649" translate="yes" xml:space="preserve">
          <source>If the returned value is &lt;code&gt;0&lt;/code&gt;, it will have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">Si el valor devuelto es &lt;code&gt;0&lt;/code&gt; , tendr&amp;aacute; el mismo signo que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6acd7cb12ab8e3d0ef11d24ea68011a7873b5dae" translate="yes" xml:space="preserve">
          <source>If the rewrite produces an invalid type, then &lt;code&gt;P&lt;/code&gt; is not at least as specialized as &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Si la reescritura produce un tipo no v&amp;aacute;lido, entonces &lt;code&gt;P&lt;/code&gt; no es al menos tan especializado como &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4014e2bbf13db27364d7162d5b480ce0991f7037" translate="yes" xml:space="preserve">
          <source>If the right hand side of &lt;code&gt;::&lt;/code&gt; names the same class as the left hand side, the name designates the &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; of that class. Such qualified name can only be used in a declaration of a constructor and in the &lt;a href=&quot;using_declaration&quot;&gt;using-declaration&lt;/a&gt; for an &lt;a href=&quot;using_declaration#Inheriting_constructors&quot;&gt;inheriting constructor&lt;/a&gt;. In those lookups where function names are ignored (that is, when looking up a name on the left of &lt;code&gt;::&lt;/code&gt;, when looking up a name in &lt;a href=&quot;elaborated_type_specifier&quot;&gt;elaborated type specifier&lt;/a&gt;, or &lt;a href=&quot;derived_class&quot;&gt;base specifier&lt;/a&gt;), the same syntax resolves to the injected-class-name:</source>
          <target state="translated">Si el lado derecho de &lt;code&gt;::&lt;/code&gt; nombra la misma clase que el lado izquierdo, el nombre designa al &lt;a href=&quot;constructor&quot;&gt;constructor&lt;/a&gt; de esa clase. Dicho nombre calificado solo puede usarse en una declaraci&amp;oacute;n de un constructor y en la &lt;a href=&quot;using_declaration&quot;&gt;declaraci&amp;oacute;n de uso&lt;/a&gt; para un &lt;a href=&quot;using_declaration#Inheriting_constructors&quot;&gt;constructor heredado&lt;/a&gt; . En aquellas b&amp;uacute;squedas en las que se ignoran los nombres de funciones (es decir, al buscar un nombre a la izquierda de &lt;code&gt;::&lt;/code&gt; , al buscar un nombre en &lt;a href=&quot;elaborated_type_specifier&quot;&gt;un especificador de tipo elaborado&lt;/a&gt; o un &lt;a href=&quot;derived_class&quot;&gt;especificador base&lt;/a&gt; ), la misma sintaxis se resuelve en el nombre de clase inyectado :</target>
        </trans-unit>
        <trans-unit id="cf85d17881197f4ecbe7cccfb07809892b92473d" translate="yes" xml:space="preserve">
          <source>If the right operand is a</source>
          <target state="translated">Si el operando correcto es un</target>
        </trans-unit>
        <trans-unit id="3c25a1f1f190f7079576b9f6ac4b83bbb5951e6a" translate="yes" xml:space="preserve">
          <source>If the same function is registered multiple times, it is called multiple times.</source>
          <target state="translated">Si la misma función se registra varias veces,se llama varias veces.</target>
        </trans-unit>
        <trans-unit id="6456596730ba60e84aee4ac147873b048b5c59b5" translate="yes" xml:space="preserve">
          <source>If the second operand is zero, the behavior is undefined, except that if floating-point division is taking place and the type supports IEEE floating-point arithmetic (see &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt;), then:</source>
          <target state="translated">Si el segundo operando es cero, el comportamiento es indefinido, excepto que si se produce una divisi&amp;oacute;n de punto flotante y el tipo admite aritm&amp;eacute;tica de punto flotante IEEE (consulte &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/is_iec559&quot;&gt;std::numeric_limits::is_iec559&lt;/a&gt;&lt;/code&gt; ), entonces:</target>
        </trans-unit>
        <trans-unit id="04f0455691936b497fbaebef44e9588dc509eb29" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no input takes place</source>
          <target state="translated">Si el centinela devuelve &lt;code&gt;false&lt;/code&gt; o el constructor del centinela arroj&amp;oacute; una excepci&amp;oacute;n, no se realiza ninguna entrada</target>
        </trans-unit>
        <trans-unit id="39a91a877963ed9b5a894be3943380a70d626e6f" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception, no output takes place</source>
          <target state="translated">Si el centinela devuelve &lt;code&gt;false&lt;/code&gt; o el constructor del centinela arroj&amp;oacute; una excepci&amp;oacute;n, no se produce ning&amp;uacute;n resultado</target>
        </trans-unit>
        <trans-unit id="bb9f6b8db596d35efa0c018a14df69e7f6bbfaa1" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;false&lt;/code&gt; or sentry's constructor threw an exception:</source>
          <target state="translated">Si el centinela devolvi&amp;oacute; &lt;code&gt;false&lt;/code&gt; o el constructor del centinela lanz&amp;oacute; una excepci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="1a7affbf0e55ba9d44864cd1959e23685822e021" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, attempts to perform the desired output by inserting the characters into the output stream as if by calling &lt;code&gt;rdbuf()-&amp;gt;sputc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;xsputn()&lt;/code&gt;. Additionally, &lt;code&gt;rdbuf()-&amp;gt;overflow()&lt;/code&gt; and &lt;code&gt;rdbuf()-&amp;gt;sync()&lt;/code&gt; may be called, but no other virtual member function of &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el centinela devuelve &lt;code&gt;true&lt;/code&gt; , intenta realizar la salida deseada insertando los caracteres en la secuencia de salida como si llamara &lt;code&gt;rdbuf()-&amp;gt;sputc()&lt;/code&gt; o &lt;code&gt;rdbuf()-&amp;gt;xsputn()&lt;/code&gt; . Adem&amp;aacute;s, se puede &lt;code&gt;rdbuf()-&amp;gt;overflow()&lt;/code&gt; y &lt;code&gt;rdbuf()-&amp;gt;sync()&lt;/code&gt; , pero ninguna otra funci&amp;oacute;n de miembro virtual de &lt;code&gt;&lt;a href=&quot;../io/basic_streambuf&quot;&gt;std::basic_streambuf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d65656ed9a96ce6e5067eef9a37718da9bc64cf6" translate="yes" xml:space="preserve">
          <source>If the sentry returned &lt;code&gt;true&lt;/code&gt;, performs the input as if by calling &lt;code&gt;rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; or &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt;.</source>
          <target state="translated">Si el centinela devuelve &lt;code&gt;true&lt;/code&gt; , realiza la entrada como si llamara a &lt;code&gt;rdbuf()-&amp;gt;sbumpc()&lt;/code&gt; o &lt;code&gt;rdbuf()-&amp;gt;sgetc()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70cc476a7cece12b6a2caeadf0dc66668c3d640a" translate="yes" xml:space="preserve">
          <source>If the set of potential exceptions is the set of all types, the implicit exception specification is &lt;code&gt;noexcept(false)&lt;/code&gt;.</source>
          <target state="translated">Si el conjunto de excepciones potenciales es el conjunto de todos los tipos, la especificaci&amp;oacute;n de excepci&amp;oacute;n impl&amp;iacute;cita es &lt;code&gt;noexcept(false)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2fd5f4d3d66499f24cbe8e9106c8eff484bfafb9" translate="yes" xml:space="preserve">
          <source>If the signal handler is called NOT as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (asynchronous signal), the behavior is undefined if.</source>
          <target state="translated">Si el controlador de se&amp;ntilde;al se llama NOT como resultado de &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (se&amp;ntilde;al as&amp;iacute;ncrona), el comportamiento no est&amp;aacute; definido si.</target>
        </trans-unit>
        <trans-unit id="671f3a813ef40ad3c5384400961c74b31b5b1d3a" translate="yes" xml:space="preserve">
          <source>If the signal handler is called as a result of &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (synchronous signal), the behavior is undefined if the signal handler calls &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se llama al manejador de se&amp;ntilde;al como resultado de &lt;code&gt;&lt;a href=&quot;abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; (se&amp;ntilde;al s&amp;iacute;ncrona), el comportamiento no est&amp;aacute; definido si el manejador de se&amp;ntilde;al llama a &lt;code&gt;&lt;a href=&quot;raise&quot;&gt;std::raise&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6be8eefa6fa1b67c6f58f6b59c61b09644913654" translate="yes" xml:space="preserve">
          <source>If the single-argument overload (17,18) is not provided, but the size-aware overload taking &lt;code&gt;std::size_t&lt;/code&gt; as the second parameter (21,22) is provided, the size-aware form is called for normal deallocation, and the C++ runtime passes the size of the object to be deallocated as the second argument. If both forms are defined, the size-unaware version is called.</source>
          <target state="translated">Si no se proporciona la sobrecarga de argumento &amp;uacute;nico (17,18), pero se proporciona la sobrecarga de tama&amp;ntilde;o que toma &lt;code&gt;std::size_t&lt;/code&gt; como el segundo par&amp;aacute;metro (21,22), se llama a la forma de tama&amp;ntilde;o para la desasignaci&amp;oacute;n normal, y el tiempo de ejecuci&amp;oacute;n de C ++ pasa el tama&amp;ntilde;o del objeto a desasignar como segundo argumento. Si se definen ambos formularios, se llama a la versi&amp;oacute;n que no conoce el tama&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="c2d39c7de53ad27f42a0268ca018c937a1d8ffae" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is known at compile time, &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; may be used, which offers a richer set of member functions. In addition, &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; exists as an alternative to &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Si se conoce el tama&amp;ntilde;o del conjunto de bits en tiempo de compilaci&amp;oacute;n, se puede usar &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; , que ofrece un conjunto m&amp;aacute;s rico de funciones miembro. Adem&amp;aacute;s, &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost :: dynamic_bitset&lt;/a&gt; existe como una alternativa a &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed773f93c49e31ff381db822c35aae7976a70854" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is known at compile time, &lt;code&gt;&lt;a href=&quot;../utility/bitset&quot;&gt;std::bitset&lt;/a&gt;&lt;/code&gt; may be used, which offers a richer set of member functions. In addition, &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; exists as an alternative to &lt;code&gt;std::vector&amp;lt;bool&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3ec4da197f7dc487044d683f9f3f0534aa5677b" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is not known at compile time, &lt;a href=&quot;../container/vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; or &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; may be used.</source>
          <target state="translated">Si no se conoce el tama&amp;ntilde;o del conjunto de bits en tiempo de compilaci&amp;oacute;n, se puede usar &lt;a href=&quot;../container/vector_bool&quot;&gt;std :: vector &amp;lt;bool&amp;gt;&lt;/a&gt; o &lt;a href=&quot;http://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost :: dynamic_bitset&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8dc178e702b3a81eeca77425a15664711aa51357" translate="yes" xml:space="preserve">
          <source>If the size of the bitset is not known at compile time, &lt;a href=&quot;../container/vector_bool&quot;&gt;std::vector&amp;lt;bool&amp;gt;&lt;/a&gt; or &lt;a href=&quot;https://www.boost.org/doc/libs/release/libs/dynamic_bitset/dynamic_bitset.html&quot;&gt;boost::dynamic_bitset&lt;/a&gt; may be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad1cf7f64b041e9b0a91851335d5ade685bd49da" translate="yes" xml:space="preserve">
          <source>If the size requested is larger than what the largest pool can handle, memory is allocated by calling &lt;code&gt;allocate()&lt;/code&gt; on the upstream memory resource.</source>
          <target state="translated">Si el tama&amp;ntilde;o solicitado es mayor que el que puede manejar el grupo m&amp;aacute;s grande, la memoria se asigna llamando a &lt;code&gt;allocate()&lt;/code&gt; en el recurso de memoria ascendente.</target>
        </trans-unit>
        <trans-unit id="b62ea5d0b3c38b6b4f7a4e5580107ff3cf6239e4" translate="yes" xml:space="preserve">
          <source>If the source and destination ranges (that is, &lt;code&gt;[first, last)&lt;/code&gt; and &lt;code&gt;[d_first, d_first+(last-first))&lt;/code&gt; respectively) overlap, the behavior is undefined.</source>
          <target state="translated">Si los rangos de origen y destino (es decir, &lt;code&gt;[first, last)&lt;/code&gt; y &lt;code&gt;[d_first, d_first+(last-first))&lt;/code&gt; respectivamente) se superponen, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="81c139c2b88224c56ebf4f7944ce062c13ebe2bf" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char16_t&lt;/code&gt;, conversion from UTF-16 to native filesystem encoding is used.</source>
          <target state="translated">Si el tipo de car&amp;aacute;cter de origen es &lt;code&gt;char16_t&lt;/code&gt; , se utiliza la conversi&amp;oacute;n de UTF-16 a la codificaci&amp;oacute;n del sistema de archivos nativo.</target>
        </trans-unit>
        <trans-unit id="913c2f0506e7ab797a84a2f6e825328ef3b20217" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char32_t&lt;/code&gt;, conversion from UTF-32 to native filesystem encoding is used.</source>
          <target state="translated">Si el tipo de car&amp;aacute;cter de origen es &lt;code&gt;char32_t&lt;/code&gt; , se utiliza la conversi&amp;oacute;n de UTF-32 a la codificaci&amp;oacute;n del sistema de archivos nativo.</target>
        </trans-unit>
        <trans-unit id="694b72bdebad2e7991d3953383227294208921f6" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char8_t&lt;/code&gt;, conversion from UTF-8 to native filesystem encoding is used.</source>
          <target state="translated">Si el tipo de car&amp;aacute;cter de origen es &lt;code&gt;char8_t&lt;/code&gt; , se utiliza la conversi&amp;oacute;n de UTF-8 a la codificaci&amp;oacute;n del sistema de archivos nativo.</target>
        </trans-unit>
        <trans-unit id="96a70ab7daabf750d23aa93b01ed20ad4c4a1d50" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;char&lt;/code&gt;, the encoding of the source is assumed to be the native narrow encoding (so no conversion takes place on POSIX systems)</source>
          <target state="translated">Si el tipo de car&amp;aacute;cter fuente es &lt;code&gt;char&lt;/code&gt; , se supone que la codificaci&amp;oacute;n de la fuente es la codificaci&amp;oacute;n estrecha nativa (por lo que no se realiza conversi&amp;oacute;n en los sistemas POSIX)</target>
        </trans-unit>
        <trans-unit id="4f00894176b3c2149f96504f78763e6045b2b289" translate="yes" xml:space="preserve">
          <source>If the source character type is &lt;code&gt;wchar_t&lt;/code&gt;, the input is assumed to be the native wide encoding (so no conversion takes places on Windows)</source>
          <target state="translated">Si el tipo de car&amp;aacute;cter fuente es &lt;code&gt;wchar_t&lt;/code&gt; , se supone que la entrada es la codificaci&amp;oacute;n amplia nativa (por lo que no se realiza ninguna conversi&amp;oacute;n en Windows)</target>
        </trans-unit>
        <trans-unit id="c129bdb54be16ce791f2a9877c6536a222b2a628" translate="yes" xml:space="preserve">
          <source>If the source type is &lt;code&gt;bool&lt;/code&gt;, the value &lt;code&gt;false&lt;/code&gt; is converted to zero and the value &lt;code&gt;true&lt;/code&gt; is converted to the value one of the destination type (note that if the destination type is &lt;code&gt;int&lt;/code&gt;, this is an integer promotion, not an integer conversion).</source>
          <target state="translated">Si el tipo de origen es &lt;code&gt;bool&lt;/code&gt; , el valor &lt;code&gt;false&lt;/code&gt; se convierte a cero y el valor &lt;code&gt;true&lt;/code&gt; se convierte al valor uno del tipo de destino (tenga en cuenta que si el tipo de destino es &lt;code&gt;int&lt;/code&gt; , esta es una promoci&amp;oacute;n entera, no una conversi&amp;oacute;n entera).</target>
        </trans-unit>
        <trans-unit id="bab9d6ec8e3d2f1fd684bd9854d45b7e92934c4f" translate="yes" xml:space="preserve">
          <source>If the source value can be represented exactly in the destination type, it does not change.</source>
          <target state="translated">Si el valor de la fuente puede representarse exactamente en el tipo de destino,no cambia.</target>
        </trans-unit>
        <trans-unit id="efb29c4d220f173d5c3f3bd33b9dfc2ebc5dd7b6" translate="yes" xml:space="preserve">
          <source>If the source value is between two representable values of the destination type, the result is one of those two values (it is implementation-defined which one, although if IEEE arithmetic is supported, rounding defaults &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;to nearest&lt;/a&gt;).</source>
          <target state="translated">Si el valor de origen se encuentra entre dos valores representables del tipo de destino, el resultado es uno de esos dos valores (est&amp;aacute; definido por la implementaci&amp;oacute;n cu&amp;aacute;l, aunque si se admite la aritm&amp;eacute;tica IEEE, el redondeo es el valor predeterminado &lt;a href=&quot;../numeric/fenv/fe_round&quot;&gt;m&amp;aacute;s cercano&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="31b86def2b9a34fa38b7b256145666db6c5bf517" translate="yes" xml:space="preserve">
          <source>If the span is empty, the returned iterator will be equal to &lt;code&gt;end()&lt;/code&gt;.</source>
          <target state="translated">Si el intervalo est&amp;aacute; vac&amp;iacute;o, el iterador devuelto ser&amp;aacute; igual a &lt;code&gt;end()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b682c7de7ba329b4fb255e71c3dba81aec002eb" translate="yes" xml:space="preserve">
          <source>If the specified size of the bit field is greater than the size of its type, the value is limited by the type: a &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint8_t&lt;/a&gt; b : 1000;&lt;/code&gt; would still hold values between 0 and 255. the extra bits become unused padding.</source>
          <target state="translated">Si el tama&amp;ntilde;o especificado del campo de bits es mayor que el tama&amp;ntilde;o de su tipo, el valor est&amp;aacute; limitado por el tipo: a &lt;code&gt;&lt;a href=&quot;../types/integer&quot;&gt;std::uint8_t&lt;/a&gt; b : 1000;&lt;/code&gt; a&amp;uacute;n mantendr&amp;iacute;a valores entre 0 y 255. los bits adicionales se convierten en relleno no utilizado.</target>
        </trans-unit>
        <trans-unit id="0cd8d8e47fd2f7d673121bf212de39492d391631" translate="yes" xml:space="preserve">
          <source>If the static type of the object that is being deleted differs from its dynamic type (such as when deleting a &lt;a href=&quot;../../language/objects&quot;&gt;polymorphic&lt;/a&gt; object through a pointer to base), and if the destructor in the static type is virtual, the single object form of delete begins lookup of the deallocation function's name starting from the point of definition of the final overrider of its virtual destructor. Regardless of which deallocation function would be executed at run time, the statically visible version of operator delete must be accessible in order to compile. In other cases, when deleting an array through a pointer to base, or when deleting through pointer to base with non-virtual destructor, the behavior is undefined.</source>
          <target state="translated">Si el tipo est&amp;aacute;tico del objeto que se est&amp;aacute; eliminando difiere de su tipo din&amp;aacute;mico (como cuando se elimina un objeto &lt;a href=&quot;../../language/objects&quot;&gt;polim&amp;oacute;rfico a&lt;/a&gt; trav&amp;eacute;s de un puntero a la base), y si el destructor en el tipo est&amp;aacute;tico es virtual, la forma de eliminaci&amp;oacute;n de un solo objeto comienza a buscar del nombre de la funci&amp;oacute;n de desasignaci&amp;oacute;n a partir del punto de definici&amp;oacute;n de la anulaci&amp;oacute;n final de su destructor virtual. Independientemente de qu&amp;eacute; funci&amp;oacute;n de desasignaci&amp;oacute;n se ejecute en tiempo de ejecuci&amp;oacute;n, la versi&amp;oacute;n est&amp;aacute;ticamente visible de la eliminaci&amp;oacute;n del operador debe ser accesible para poder compilar. En otros casos, al eliminar una matriz a trav&amp;eacute;s de un puntero a la base, o al eliminar a trav&amp;eacute;s del puntero a la base con un destructor no virtual, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="1a0ccecdae65148cf1c548284599ec7fc29e7a26" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; (for example, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; was used in the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg.get()&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;T&amp;amp;&lt;/code&gt;: the stored argument is passed by reference into the invoked function object.</source>
          <target state="translated">Si el argumento almacenado &lt;code&gt;arg&lt;/code&gt; es de tipo &lt;code&gt;&lt;a href=&quot;reference_wrapper&quot;&gt;std::reference_wrapper&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; (por ejemplo, &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::ref&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;ref&quot;&gt;std::cref&lt;/a&gt;&lt;/code&gt; se us&amp;oacute; en la llamada inicial a &lt;code&gt;bind&lt;/code&gt; ), entonces el argumento &lt;code&gt;vn&lt;/code&gt; en el &lt;code&gt;std::invoke&lt;/code&gt; llamada anteriormente es &lt;code&gt;arg.get()&lt;/code&gt; y el tipo &lt;code&gt;Vn&lt;/code&gt; en la misma llamada es &lt;code&gt;T&amp;amp;&lt;/code&gt; : el argumento almacenado se pasa por referencia al objeto de funci&amp;oacute;n invocado.</target>
        </trans-unit>
        <trans-unit id="acee41d0611ce916e2778b1cfd039971f9e77287" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt; for which &lt;code&gt;&lt;a href=&quot;is_bind_expression&quot;&gt;std::is_bind_expression&lt;/a&gt;&amp;lt;T&amp;gt;::value == true&lt;/code&gt; (for example, another &lt;code&gt;bind&lt;/code&gt; expression was passed directly into the initial call to &lt;code&gt;bind&lt;/code&gt;), then &lt;code&gt;bind&lt;/code&gt; performs function composition: instead of passing the function object that the bind subexpression would return, the subexpression is invoked eagerly, and its return value is passed to the outer invokable object. If the bind subexpression has any placeholder arguments, they are shared with the outer bind (picked out of &lt;code&gt;u1, u2, ...&lt;/code&gt;). Specifically, the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;arg(std::forward&amp;lt;Uj&amp;gt;(uj)...)&lt;/code&gt; and the type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;&lt;a href=&quot;../../types/result_of&quot;&gt;std::result_of_t&lt;/a&gt;&amp;lt;T cv &amp;amp;(Uj&amp;amp;&amp;amp;...)&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt; (cv qualification is the same as that of &lt;code&gt;g&lt;/code&gt;).</source>
          <target state="translated">Si el argumento almacenado &lt;code&gt;arg&lt;/code&gt; es de tipo &lt;code&gt;T&lt;/code&gt; para el cual &lt;code&gt;&lt;a href=&quot;is_bind_expression&quot;&gt;std::is_bind_expression&lt;/a&gt;&amp;lt;T&amp;gt;::value == true&lt;/code&gt; (por ejemplo, otra expresi&amp;oacute;n de &lt;code&gt;bind&lt;/code&gt; se pas&amp;oacute; directamente a la llamada inicial al &lt;code&gt;bind&lt;/code&gt; ), entonces &lt;code&gt;bind&lt;/code&gt; realiza la composici&amp;oacute;n de la funci&amp;oacute;n: en lugar de pasando el objeto de funci&amp;oacute;n que devolver&amp;iacute;a la subexpresi&amp;oacute;n de enlace, la subexpresi&amp;oacute;n se invoca ansiosamente y su valor de retorno se pasa al objeto invocable externo. Si la subexpresi&amp;oacute;n de enlace tiene argumentos de marcador de posici&amp;oacute;n, se comparten con el enlace externo (seleccionado de &lt;code&gt;u1, u2, ...&lt;/code&gt; ). Espec&amp;iacute;ficamente, el argumento &lt;code&gt;vn&lt;/code&gt; en la llamada &lt;code&gt;std::invoke&lt;/code&gt; anterior es &lt;code&gt;arg(std::forward&amp;lt;Uj&amp;gt;(uj)...)&lt;/code&gt; y el tipo &lt;code&gt;Vn&lt;/code&gt; en la misma llamada es &lt;code&gt;&lt;a href=&quot;../../types/result_of&quot;&gt;std::result_of_t&lt;/a&gt;&amp;lt;T cv &amp;amp;(Uj&amp;amp;&amp;amp;...)&amp;gt;&amp;amp;&amp;amp;&lt;/code&gt; (la calificaci&amp;oacute;n de cv es la misma que la de &lt;code&gt;g&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="dc4a284d335b2d5c1ce7e8244468b32d33179179" translate="yes" xml:space="preserve">
          <source>If the stored argument &lt;code&gt;arg&lt;/code&gt; is of type &lt;code&gt;T&lt;/code&gt;, for which &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;T&amp;gt;::value != 0&lt;/code&gt; (meaning, a placeholder such as &lt;code&gt;std::placeholders::_1, _2, _3, ...&lt;/code&gt; was used as the argument to the initial call to &lt;code&gt;bind&lt;/code&gt;), then the argument indicated by the placeholder (&lt;code&gt;u1&lt;/code&gt; for &lt;code&gt;_1&lt;/code&gt;, &lt;code&gt;u2&lt;/code&gt; for &lt;code&gt;_2&lt;/code&gt;, etc) is passed to the invokable object: the argument &lt;code&gt;vn&lt;/code&gt; in the &lt;code&gt;std::invoke&lt;/code&gt; call above is &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Uj&amp;gt;(uj)&lt;/code&gt; and the corresponding type &lt;code&gt;Vn&lt;/code&gt; in the same call is &lt;code&gt;Uj&amp;amp;&amp;amp;&lt;/code&gt;.</source>
          <target state="translated">Si el argumento almacenado &lt;code&gt;arg&lt;/code&gt; es de tipo &lt;code&gt;T&lt;/code&gt; , para el cual &lt;code&gt;&lt;a href=&quot;is_placeholder&quot;&gt;std::is_placeholder&lt;/a&gt;&amp;lt;T&amp;gt;::value != 0&lt;/code&gt; (es decir, un marcador de posici&amp;oacute;n como &lt;code&gt;std::placeholders::_1, _2, _3, ...&lt;/code&gt; se utiliz&amp;oacute; como el argumento de la llamada inicial a &lt;code&gt;bind&lt;/code&gt; ), luego el argumento indicado por el marcador de posici&amp;oacute;n ( &lt;code&gt;u1&lt;/code&gt; para &lt;code&gt;_1&lt;/code&gt; , &lt;code&gt;u2&lt;/code&gt; para &lt;code&gt;_2&lt;/code&gt; , etc.) se pasa al objeto invocable: el argumento &lt;code&gt;vn&lt;/code&gt; en la llamada &lt;code&gt;std::invoke&lt;/code&gt; anterior es &lt;code&gt;&lt;a href=&quot;../forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;Uj&amp;gt;(uj)&lt;/code&gt; y el tipo correspondiente &lt;code&gt;Vn&lt;/code&gt; en la misma llamada es &lt;code&gt;Uj&amp;amp;&amp;amp;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5073b898afe983835e7576b31a4b2a5ed1384e70" translate="yes" xml:space="preserve">
          <source>If the stored reference is &lt;a href=&quot;../../named_req/callable&quot;&gt;Callable&lt;/a&gt;, &lt;code&gt;std::reference_wrapper&lt;/code&gt; is callable with the same arguments.</source>
          <target state="translated">Si la referencia almacenada es &lt;a href=&quot;../../named_req/callable&quot;&gt;invocable&lt;/a&gt; , &lt;code&gt;std::reference_wrapper&lt;/code&gt; es invocable con los mismos argumentos.</target>
        </trans-unit>
        <trans-unit id="721f1a0ff5ac2a85a4aec48dc758c5efa06cf129" translate="yes" xml:space="preserve">
          <source>If the stream is open in binary mode, the value obtained by this function is the number of bytes from the beginning of the file.</source>
          <target state="translated">Si la corriente está abierta en modo binario,el valor obtenido por esta función es el número de bytes desde el principio del archivo.</target>
        </trans-unit>
        <trans-unit id="1be01e06d2b7863dcf18bfbfbb7a62e4aff8f3b7" translate="yes" xml:space="preserve">
          <source>If the stream is open in text mode, the value returned by this function is unspecified and is only meaningful as the input to &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si la secuencia est&amp;aacute; abierta en modo de texto, el valor devuelto por esta funci&amp;oacute;n no est&amp;aacute; especificado y solo es significativo como entrada para &lt;code&gt;&lt;a href=&quot;fseek&quot;&gt;std::fseek&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcf9d7178da0219ad2eb8a851abb68eb2713f063" translate="yes" xml:space="preserve">
          <source>If the stream is using a dynamically-allocated array for output, disables (&lt;code&gt;flag == true&lt;/code&gt;) or enables (&lt;code&gt;flag == false&lt;/code&gt;) automatic allocation/deallocation of the buffer. Effectively calls &lt;code&gt;rdbuf()-&amp;gt;freeze(flag)&lt;/code&gt;.</source>
          <target state="translated">Si la secuencia est&amp;aacute; utilizando una matriz asignada din&amp;aacute;micamente para la salida, deshabilita ( &lt;code&gt;flag == true&lt;/code&gt; ) o habilita ( &lt;code&gt;flag == false&lt;/code&gt; ) la asignaci&amp;oacute;n / desasignaci&amp;oacute;n autom&amp;aacute;tica del b&amp;uacute;fer. Efectivamente llama a &lt;code&gt;rdbuf()-&amp;gt;freeze(flag)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3a1404f13d35c564c59b09dcb07b726f75ab0a7" translate="yes" xml:space="preserve">
          <source>If the strictest (largest) &lt;code&gt;alignas&lt;/code&gt; on a declaration is weaker than the alignment it would have without any &lt;code&gt;alignas&lt;/code&gt; specifiers (that is, weaker than its natural alignment or weaker than &lt;code&gt;alignas&lt;/code&gt; on another declaration of the same object or type), the program is ill-formed:</source>
          <target state="translated">Si las &lt;code&gt;alignas&lt;/code&gt; m&amp;aacute;s estrictas (m&amp;aacute;s grandes) en una declaraci&amp;oacute;n son m&amp;aacute;s d&amp;eacute;biles que la alineaci&amp;oacute;n que tendr&amp;iacute;a sin ning&amp;uacute;n especificador de &lt;code&gt;alignas&lt;/code&gt; (es decir, m&amp;aacute;s d&amp;eacute;biles que su alineaci&amp;oacute;n natural o m&amp;aacute;s d&amp;eacute;biles que las &lt;code&gt;alignas&lt;/code&gt; en otra declaraci&amp;oacute;n del mismo objeto o tipo), el programa est&amp;aacute; enfermo -formado:</target>
        </trans-unit>
        <trans-unit id="b376b7c229a7bc07ebacea949f846a78b0d1782c" translate="yes" xml:space="preserve">
          <source>If the strings overlap, the behavior is undefined.</source>
          <target state="translated">Si las cuerdas se superponen,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="7d57980d6c4db7f5a88e476c28a7345cd0ee1e03" translate="yes" xml:space="preserve">
          <source>If the synchronization is turned off, the C++ standard streams are allowed to buffer their I/O independently, which may be considerably faster in some cases.</source>
          <target state="translated">Si se desactiva la sincronización,se permite que los flujos estándar de C++almacenen en memoria intermedia su E/S de forma independiente,lo que puede ser considerablemente más rápido en algunos casos.</target>
        </trans-unit>
        <trans-unit id="9a8cb52b7220965fcee67fc72cd6b2b899d9bdff" translate="yes" xml:space="preserve">
          <source>If the target sequence is uniquely matched, &lt;code&gt;v&lt;/code&gt; is set to the corresponding &lt;code&gt;bool&lt;/code&gt; value. Otherwise &lt;code&gt;false&lt;/code&gt; is stored in &lt;code&gt;v&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;. If unique match could not be found before the input ended (&lt;code&gt;in==end&lt;/code&gt;), &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; is executed.</source>
          <target state="translated">Si la secuencia objetivo coincide de forma exclusiva, &lt;code&gt;v&lt;/code&gt; se establece en el valor &lt;code&gt;bool&lt;/code&gt; correspondiente . De lo contrario, &lt;code&gt;false&lt;/code&gt; se almacena en &lt;code&gt;v&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; se asigna a &lt;code&gt;err&lt;/code&gt; . Si no se pudo encontrar una coincidencia &amp;uacute;nica antes de que finalizara la entrada ( &lt;code&gt;in==end&lt;/code&gt; ), se ejecuta &lt;code&gt;err|=&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::eofbit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1289b6bdc776c1418acfec4d954c523b4601b0f" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt; with its topmost cv-qualifiers removed.</source>
          <target state="translated">Si el tipo &lt;code&gt;T&lt;/code&gt; es un tipo de referencia, proporciona el &lt;code&gt;type&lt;/code&gt; typedef miembro que es el tipo al que hace referencia &lt;code&gt;T&lt;/code&gt; con sus calificadores cv superiores eliminados. De lo contrario, el &lt;code&gt;type&lt;/code&gt; es &lt;code&gt;T&lt;/code&gt; con sus calificadores cv superiores eliminados.</target>
        </trans-unit>
        <trans-unit id="bc4e534b1c21d223bb95673e8d15e125bb5d8892" translate="yes" xml:space="preserve">
          <source>If the type &lt;code&gt;T&lt;/code&gt; is a reference type, provides the member typedef &lt;code&gt;type&lt;/code&gt; which is the type referred to by &lt;code&gt;T&lt;/code&gt;. Otherwise &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;T&lt;/code&gt;.</source>
          <target state="translated">Si el tipo &lt;code&gt;T&lt;/code&gt; es un tipo de referencia, proporciona la typedef miembro de &lt;code&gt;type&lt;/code&gt; que es el tipo a que se refiere por &lt;code&gt;T&lt;/code&gt; . De lo contrario &lt;code&gt;type&lt;/code&gt; es &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="568c9a7735dfb6e7c3f7facf46f864c936b3998f" translate="yes" xml:space="preserve">
          <source>If the type is complete and if, for the delete[] only, the operand is a pointer to a class type with a non-trivial destructor or a (possibly multi-dimensional) array thereof, the global size-aware global function (with a parameter of type &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt;) is selected</source>
          <target state="translated">Si el tipo est&amp;aacute; completo y si, solo para la eliminaci&amp;oacute;n [], el operando es un puntero a un tipo de clase con un destructor no trivial o una matriz (posiblemente multidimensional) del mismo, la funci&amp;oacute;n global de tama&amp;ntilde;o global (con se selecciona un par&amp;aacute;metro de tipo &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="d45b643bd174051aee94549a2f03f3ff00e0a987" translate="yes" xml:space="preserve">
          <source>If the type is reference type, the operator returns the alignment of</source>
          <target state="translated">Si el tipo es de referencia,el operador devuelve la alineación de</target>
        </trans-unit>
        <trans-unit id="e61370f729d3fc61feda284c6f51bb8eac974871" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt;</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;bool&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bb07f1de8954ef59a83dcf953df4f4e9416e15a0" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha!=0&lt;/code&gt;, the following replaces stages 2 and 3:</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;bool&lt;/code&gt; y &lt;code&gt;boolalpha!=0&lt;/code&gt; , lo siguiente reemplaza las etapas 2 y 3:</target>
        </trans-unit>
        <trans-unit id="9a11f0db514f9cdeffd237282d9ed24955a00f05" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and &lt;code&gt;boolalpha==0&lt;/code&gt;, proceeds as if the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long&lt;/code&gt;, except for the value to be stored in &lt;code&gt;v&lt;/code&gt; in stage 3.</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;bool&lt;/code&gt; y &lt;code&gt;boolalpha==0&lt;/code&gt; , procede como si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;long&lt;/code&gt; , excepto para el valor que se almacena en &lt;code&gt;v&lt;/code&gt; en la etapa 3.</target>
        </trans-unit>
        <trans-unit id="5c85042e7deeed4301f664d1dc468bbb3d06b939" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;bool&lt;/code&gt; and boolalpha is not set, then if the value to be stored is &lt;code&gt;​0​&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt; is stored, if the value to be stored is &lt;code&gt;1&lt;/code&gt;, &lt;code&gt;true&lt;/code&gt; is stored, for any other value &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt; and &lt;code&gt;true&lt;/code&gt; is stored.</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;bool&lt;/code&gt; y boolalpha no se establece, entonces, si el valor que se almacena es &lt;code&gt;​0​&lt;/code&gt; , &lt;code&gt;false&lt;/code&gt; se almacena, si el valor a ser almacenado es &lt;code&gt;1&lt;/code&gt; , &lt;code&gt;true&lt;/code&gt; se almacena, para cualquier otro valor &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; se asigna a &lt;code&gt;err&lt;/code&gt; y se almacena &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7476d41e2a67317c3bb5251d97663d77eeb1e42c" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%lg&lt;/code&gt;</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;double&lt;/code&gt; , utilizar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%lg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dfdf59b17079b062cc1b92411ee58243a516a33f" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;float&lt;/code&gt;, will use conversion specifier &lt;code&gt;%g&lt;/code&gt;</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;float&lt;/code&gt; , utilizar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%g&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4567caa0edddb2a88680b490c4e2737935cdcbd5" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, the length modifier &lt;code&gt;L&lt;/code&gt; is added to the conversion specifier.</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;long double&lt;/code&gt; , el modificador de longitud &lt;code&gt;L&lt;/code&gt; se agrega al especificador de conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0474c288e1ccdf560a85090121492766095a9be3" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;long double&lt;/code&gt;, will use conversion specifier &lt;code&gt;%Lg&lt;/code&gt;</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;long double&lt;/code&gt; , utilizar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%Lg&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="00d6a72b02646eead810c617c23ae522ca753e6d" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is &lt;code&gt;void*&lt;/code&gt;, will use conversion specifier &lt;code&gt;%p&lt;/code&gt;</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es &lt;code&gt;void*&lt;/code&gt; , se usar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%p&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="29e503ca84cb15f39173a1562dbbbb2beffa737a" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is a floating-point type, the the first applicable choice of the following is selected:</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es un tipo de punto flotante, se selecciona la primera opci&amp;oacute;n aplicable de las siguientes:</target>
        </trans-unit>
        <trans-unit id="af8313560c731302bab034bb408aa878436ea837" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following five is selected:</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es un tipo entero, se selecciona la primera opci&amp;oacute;n aplicable de las siguientes cinco:</target>
        </trans-unit>
        <trans-unit id="c3a7ea4c84d1d685474ebd89637a92007ea3ea02" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is an integer type, the the first applicable choice of the following is selected:</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; es un tipo entero, se selecciona la primera opci&amp;oacute;n aplicable de lo siguiente:</target>
        </trans-unit>
        <trans-unit id="78f0474ec6b14c626c7efaff5801d926c1f92941" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is signed, will use conversion specifier &lt;code&gt;%d&lt;/code&gt;</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; est&amp;aacute; firmado, utilizar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%d&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="4990261c39b3a34d0f827b213b2a6345d9b18783" translate="yes" xml:space="preserve">
          <source>If the type of &lt;code&gt;v&lt;/code&gt; is unsigned, will use conversion specifier &lt;code&gt;%u&lt;/code&gt;</source>
          <target state="translated">Si el tipo de &lt;code&gt;v&lt;/code&gt; no est&amp;aacute; firmado, utilizar&amp;aacute; el especificador de conversi&amp;oacute;n &lt;code&gt;%u&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="51577fdf94f044af450cebe5474487f90f5669ab" translate="yes" xml:space="preserve">
          <source>If the type of the next argument in &lt;code&gt;ap&lt;/code&gt; (after promotions) is not compatible with &lt;code&gt;T&lt;/code&gt;, the behavior is undefined, unless:</source>
          <target state="translated">Si el tipo del siguiente argumento en &lt;code&gt;ap&lt;/code&gt; (despu&amp;eacute;s de las promociones) no es compatible con &lt;code&gt;T&lt;/code&gt; , el comportamiento no est&amp;aacute; definido, a menos que:</target>
        </trans-unit>
        <trans-unit id="37ea6657641f330790f7fa714b3234e4d4d737e5" translate="yes" xml:space="preserve">
          <source>If the type's alignment requirement exceeds &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt;, alignment-aware deallocation functions (with a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred. For other types, the alignment-unaware deallocation functions (without a parameter of type &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt;) are preferred.</source>
          <target state="translated">Si el requisito de alineaci&amp;oacute;n del tipo excede &lt;code&gt;__STDCPP_DEFAULT_NEW_ALIGNMENT__&lt;/code&gt; , se prefieren las funciones de desasignaci&amp;oacute;n con reconocimiento de alineaci&amp;oacute;n (con un par&amp;aacute;metro de tipo &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; ). Para otros tipos, se prefieren las funciones de desasignaci&amp;oacute;n sin alineaci&amp;oacute;n (sin un par&amp;aacute;metro de tipo &lt;code&gt;&lt;a href=&quot;../memory/new/align_val_t&quot;&gt;std::align_val_t&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9e2d47f6d426a3f84b185a211656e8cd6bd7698e" translate="yes" xml:space="preserve">
          <source>If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; is copied into such an array, and then the resulting content is copied back into &lt;code&gt;obj1&lt;/code&gt;, &lt;code&gt;obj1&lt;/code&gt; will hold its original value. If the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; are copied into &lt;code&gt;obj2&lt;/code&gt;, &lt;code&gt;obj2&lt;/code&gt; will hold &lt;code&gt;obj1&lt;/code&gt;'s value.</source>
          <target state="translated">Si los bytes subyacentes de &lt;code&gt;obj1&lt;/code&gt; se copian en dicha matriz, y luego el contenido resultante se copia de nuevo en &lt;code&gt;obj1&lt;/code&gt; , &lt;code&gt;obj1&lt;/code&gt; mantendr&amp;aacute; su valor original. Si los bytes subyacentes de &lt;code&gt;obj1&lt;/code&gt; se copian en &lt;code&gt;obj2&lt;/code&gt; , &lt;code&gt;obj2&lt;/code&gt; mantendr&amp;aacute; el valor de &lt;code&gt;obj1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c532a0885cdbf73cb10a896503a4564c8a0bf0b" translate="yes" xml:space="preserve">
          <source>If the underlying type is fixed, the result is the same as the &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;converting&lt;/a&gt; the original value first to the underlying type of the enumeration and then to the enumeration type.</source>
          <target state="translated">Si el tipo subyacente es fijo, el resultado es el mismo que &lt;a href=&quot;implicit_cast#Integral_conversions&quot;&gt;convertir&lt;/a&gt; el valor original primero al tipo subyacente de la enumeraci&amp;oacute;n y luego al tipo de enumeraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="53c5be902373ad8ba2b8c3eceeaae48131069091" translate="yes" xml:space="preserve">
          <source>If the underlying type is not fixed, the result is unspecified(until C++17)undefined behavior(since C++17) if the value of expression is out of range (the range is all values possible for the smallest bit field large enough to hold all enumerators of the target enumeration).</source>
          <target state="translated">Si el tipo subyacente no es fijo,el resultado es indeterminado(hasta C++17)comportamiento indefinido(desde C++17)si el valor de la expresión está fuera de rango (el rango es todos los valores posibles para el campo de bits más pequeño lo suficientemente grande como para contener a todos los enumeradores de la enumeración objetivo).</target>
        </trans-unit>
        <trans-unit id="9584e81563cc79a87482512943d106e7c6f35aeb" translate="yes" xml:space="preserve">
          <source>If the user defined function returns when handling &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; or any other implementation-defined signal specifying a computational exception, the behavior is undefined.</source>
          <target state="translated">Si la funci&amp;oacute;n definida por el usuario regresa al manejar &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGFPE&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGILL&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;sig_types&quot;&gt;SIGSEGV&lt;/a&gt;&lt;/code&gt; o cualquier otra se&amp;ntilde;al definida por la implementaci&amp;oacute;n que especifique una excepci&amp;oacute;n computacional, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="758bb6908f51c11c8477acd6f36292722e9b2a25" translate="yes" xml:space="preserve">
          <source>If the user-defined signal handling strategy is not set using &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; yet, it is implementation-defined whether the signal will be ignored or default handler will be invoked.</source>
          <target state="translated">Si la estrategia de manejo de se&amp;ntilde;al definida por el usuario a&amp;uacute;n no se establece usando &lt;code&gt;&lt;a href=&quot;signal&quot;&gt;std::signal()&lt;/a&gt;&lt;/code&gt; , se define la implementaci&amp;oacute;n si la se&amp;ntilde;al ser&amp;aacute; ignorada o si se invocar&amp;aacute; el controlador predeterminado.</target>
        </trans-unit>
        <trans-unit id="ad569346ec44ef60f084b9ce61fd4164c7c32f63" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; (as described above) fails, the following alternatives are additionally considered:</source>
          <target state="translated">Si la deducci&amp;oacute;n habitual de &lt;code&gt;P&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; (como se describe anteriormente) falla, se consideran adicionalmente las siguientes alternativas:</target>
        </trans-unit>
        <trans-unit id="222dded9de677b2df12bcb544421882e3b919712" translate="yes" xml:space="preserve">
          <source>If the usual deduction from &lt;code&gt;P&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; fails, the following alternatives are additionally considered:</source>
          <target state="translated">Si la deducci&amp;oacute;n habitual de &lt;code&gt;P&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; falla, se consideran adicionalmente las siguientes alternativas:</target>
        </trans-unit>
        <trans-unit id="2044c8cb072e19726cdc9c11e14101e5b7aa5788" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;​0​&lt;/code&gt; is added or subtracted from a pointer, the result is the pointer, unchanged. If two pointers point at the same object or are both one past the end of the same array, or both are null pointers, then the result of subtraction is equal to &lt;code&gt;(&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;)0&lt;/code&gt;.</source>
          <target state="translated">Si el valor &lt;code&gt;​0​&lt;/code&gt; se a&amp;ntilde;ade o se resta de un puntero, el resultado es el puntero, sin cambios. Si dos punteros apuntan al mismo objeto o ambos est&amp;aacute;n m&amp;aacute;s all&amp;aacute; del final de la misma matriz, o ambos son punteros nulos, entonces el resultado de la resta es igual a &lt;code&gt;(&lt;a href=&quot;../types/ptrdiff_t&quot;&gt;std::ptrdiff_t&lt;/a&gt;)0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e60c2f6520b56b9cab3b22f7509b4a9255b562" translate="yes" xml:space="preserve">
          <source>If the value in the first dimension is erroneous for any of these reasons,</source>
          <target state="translated">Si el valor en la primera dimensión es erróneo por cualquiera de estas razones,</target>
        </trans-unit>
        <trans-unit id="030063b706611cf1e8e06a4ae59ec7618b58db95" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;ch&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si el valor de &lt;code&gt;ch&lt;/code&gt; no es representable como &lt;code&gt;wchar_t&lt;/code&gt; ni es igual al valor de la macro &lt;code&gt;WEOF&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="248a5c7e458d6f5d84a843bb9bad9a695797de69" translate="yes" xml:space="preserve">
          <source>If the value of &lt;code&gt;wc&lt;/code&gt; is neither representable as a &lt;code&gt;wchar_t&lt;/code&gt; nor equal to the value of the macro &lt;code&gt;WEOF&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si el valor de &lt;code&gt;wc&lt;/code&gt; no es representable como &lt;code&gt;wchar_t&lt;/code&gt; ni igual al valor de la macro &lt;code&gt;WEOF&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="95ab164f16af6b727b63cdf344a7e218377e5641" translate="yes" xml:space="preserve">
          <source>If the value of base is &lt;code&gt;​0​&lt;/code&gt;, the numeric base is auto-detected: if the prefix is &lt;code&gt;0&lt;/code&gt;, the base is octal, if the prefix is &lt;code&gt;0x&lt;/code&gt; or &lt;code&gt;0X&lt;/code&gt;, the base is hexadecimal, otherwise the base is decimal.</source>
          <target state="translated">Si el valor de base es &lt;code&gt;​0​&lt;/code&gt; , la base num&amp;eacute;rica es detectada autom&amp;aacute;ticamente: si el prefijo es &lt;code&gt;0&lt;/code&gt; , la base es octal, si el prefijo es &lt;code&gt;0x&lt;/code&gt; o &lt;code&gt;0X&lt;/code&gt; , la base es hexadecimal, de lo contrario la base es decimal.</target>
        </trans-unit>
        <trans-unit id="70a9c765b78740ba6c067e64a0ddbb7ae2ac6060" translate="yes" xml:space="preserve">
          <source>If the value of the integer literal is too big to fit in any of the types allowed by suffix/base combination and the compiler supports extended integer types (such as &lt;code&gt;__int128&lt;/code&gt;) the literal may be given the extended integer type -- otherwise the program is ill-formed.</source>
          <target state="translated">Si el valor del literal entero es demasiado grande para caber en cualquiera de los tipos permitidos por la combinaci&amp;oacute;n de sufijo / base y el compilador admite tipos enteros extendidos (como &lt;code&gt;__int128&lt;/code&gt; ), el literal puede recibir el tipo entero extendido; de lo contrario, el programa es mal formado</target>
        </trans-unit>
        <trans-unit id="e8c33ee241a255a63ad79ee3a3348d39830a7425" translate="yes" xml:space="preserve">
          <source>If the value to be stored in &lt;code&gt;*exp&lt;/code&gt; is outside the range of &lt;code&gt;int&lt;/code&gt;, the behavior is unspecified.</source>
          <target state="translated">Si el valor que se almacenar&amp;aacute; en &lt;code&gt;*exp&lt;/code&gt; est&amp;aacute; fuera del rango de &lt;code&gt;int&lt;/code&gt; , el comportamiento no se especifica.</target>
        </trans-unit>
        <trans-unit id="e2f54be830759cbe8fb68d644557c982f45181ea" translate="yes" xml:space="preserve">
          <source>If the value type is known to be a built-in type, the const variant should return by value.</source>
          <target state="translated">Si se sabe que el tipo de valor es un tipo incorporado,la variante const debería regresar por valor.</target>
        </trans-unit>
        <trans-unit id="90307671f8933d3e9e5abc11ed1d390a29f7fef2" translate="yes" xml:space="preserve">
          <source>If the variant is &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt;, returns &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt;.</source>
          <target state="translated">Si la variante es &lt;a href=&quot;valueless_by_exception&quot;&gt;valueless_by_exception&lt;/a&gt; , devoluciones &lt;a href=&quot;variant_npos&quot;&gt;variant_npos&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="fa561126aaa10ae89524de188dae5e165b1fdb67" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, none.</source>
          <target state="translated">Si el vector cambió de capacidad,todos ellos.Si no,ninguna.</target>
        </trans-unit>
        <trans-unit id="4d3428e86be4da734a232d16973b7cf3b93b4058" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only end().</source>
          <target state="translated">Si el vector cambió de capacidad,todos ellos.Si no es así,sólo end().</target>
        </trans-unit>
        <trans-unit id="72ef803ef1a355b795f9869f64ff81133821942a" translate="yes" xml:space="preserve">
          <source>If the vector changed capacity, all of them. If not, only those after the insertion point.</source>
          <target state="translated">Si el vector cambió de capacidad,todos ellos.Si no,sólo los que están después del punto de inserción.</target>
        </trans-unit>
        <trans-unit id="eb75958a443f6e86954852258d39617127eed64b" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state &lt;code&gt;*ps&lt;/code&gt; represents the initial shift state.</source>
          <target state="translated">Si el car&amp;aacute;cter ancho producido es el car&amp;aacute;cter nulo, el estado de conversi&amp;oacute;n &lt;code&gt;*ps&lt;/code&gt; representa el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="24382f133af9ec92a179262afb80b489903f3a55" translate="yes" xml:space="preserve">
          <source>If the wide character produced is the null character, the conversion state stored in &lt;code&gt;*ps&lt;/code&gt; is the initial shift state.</source>
          <target state="translated">Si el car&amp;aacute;cter ancho producido es el car&amp;aacute;cter nulo, el estado de conversi&amp;oacute;n almacenado en &lt;code&gt;*ps&lt;/code&gt; es el estado de desplazamiento inicial.</target>
        </trans-unit>
        <trans-unit id="0c78b539f6ef73fa78a596278e160b79dda2072b" translate="yes" xml:space="preserve">
          <source>If there are multiple declarations with different lexical orders (e.g. a function template declared with trailing return type, to be substituted after a parameter, and redeclared with ordinary return type that would be substituted before the parameter), then the program is ill-formed; no diagnostic required.</source>
          <target state="translated">Si hay múltiples declaraciones con diferentes órdenes léxicos (por ejemplo,una plantilla de funciones declarada con el tipo de retorno posterior,para ser sustituida después de un parámetro,y redeclarada con el tipo de retorno ordinario que sería sustituido antes del parámetro),entonces el programa está mal formado;no se requiere ningún diagnóstico.</target>
        </trans-unit>
        <trans-unit id="d2b18351965a2fe087972c4fc08282cc6ca24208" translate="yes" xml:space="preserve">
          <source>If there are multiple overloads of the function or operator being called, after the implicit conversion sequence is built from &lt;code&gt;T1&lt;/code&gt; to each available &lt;code&gt;T2&lt;/code&gt;, &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt; rules decide which overload is compiled.</source>
          <target state="translated">Si hay m&amp;uacute;ltiples sobrecargas de la funci&amp;oacute;n u operador que se est&amp;aacute; llamando, despu&amp;eacute;s de que la secuencia de conversi&amp;oacute;n impl&amp;iacute;cita se construye desde &lt;code&gt;T1&lt;/code&gt; a cada &lt;code&gt;T2&lt;/code&gt; disponible , las reglas de &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; deciden qu&amp;eacute; sobrecarga se compila.</target>
        </trans-unit>
        <trans-unit id="a5a33472c5c80216c585ac1f3e2bb1b8d2b913cd" translate="yes" xml:space="preserve">
          <source>If there are multiple parameters, each &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair is deduced separately and the deduced template arguments are then combined. If deduction fails or is ambiguous for any &lt;code&gt;P&lt;/code&gt;/&lt;code&gt;A&lt;/code&gt; pair or if different pairs yield different deduced template arguments, or if any template argument remains neither deduced nor explicitly specified, compilation fails.</source>
          <target state="translated">Si hay m&amp;uacute;ltiples par&amp;aacute;metros, cada par &lt;code&gt;P&lt;/code&gt; / &lt;code&gt;A&lt;/code&gt; se deduce por separado y los argumentos de plantilla deducidos se combinan. Si la deducci&amp;oacute;n falla o es ambigua para cualquier par &lt;code&gt;P&lt;/code&gt; / &lt;code&gt;A&lt;/code&gt; o si diferentes pares producen argumentos de plantilla deducidos diferentes, o si alg&amp;uacute;n argumento de plantilla permanece ni deducido ni expl&amp;iacute;citamente especificado, la compilaci&amp;oacute;n falla.</target>
        </trans-unit>
        <trans-unit id="08ff4d812abea495b9856132aa9d1453e7f49ba6" translate="yes" xml:space="preserve">
          <source>If there are multiple return statements, they must all deduce to the same type.</source>
          <target state="translated">Si hay múltiples declaraciones de retorno,todas deben deducirse al mismo tipo.</target>
        </trans-unit>
        <trans-unit id="56e2a9dcbebace2c5e7ec9081f6a581a3eccd3f0" translate="yes" xml:space="preserve">
          <source>If there are no elements</source>
          <target state="translated">Si no hay elementos</target>
        </trans-unit>
        <trans-unit id="2be453c0735328c6008b2c9ff54809c970ae7dd0" translate="yes" xml:space="preserve">
          <source>If there are no elements, the behavior is undefined.</source>
          <target state="translated">Si no hay elementos,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="60124398219caa2545336ef3688db0d123bcef47" translate="yes" xml:space="preserve">
          <source>If there are no matches, copies the entire sequence into &lt;code&gt;out&lt;/code&gt; as-is, by &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(first, last, out)&lt;/code&gt;</source>
          <target state="translated">Si no hay coincidencias, copia la secuencia completa en &lt;code&gt;out&lt;/code&gt; como est&amp;aacute;, por &lt;code&gt;out = &lt;a href=&quot;../algorithm/copy&quot;&gt;std::copy&lt;/a&gt;(first, last, out)&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="430a0a9ceb3976f6b074269c72597aae319e083f" translate="yes" xml:space="preserve">
          <source>If there are no more entries left in the currently iterated directory, the iteration is resumed over the parent directory. The process is repeated if the parent directory has no sibling entries that can to be iterated on. If the parent of the directory hierarchy that has been recursively iterated on is reached (there are no candidate entries at &lt;code&gt;depth() == 0)&lt;/code&gt;, &lt;code&gt;*this&lt;/code&gt; is set to an end iterator.</source>
          <target state="translated">Si no quedan m&amp;aacute;s entradas en el directorio iterado actualmente, la iteraci&amp;oacute;n se reanuda sobre el directorio padre. El proceso se repite si el directorio principal no tiene entradas entre hermanos que se puedan iterar. Si se alcanza el padre de la jerarqu&amp;iacute;a de directorios que se ha iterado recursivamente (no hay entradas candidatas en &lt;code&gt;depth() == 0)&lt;/code&gt; , &lt;code&gt;*this&lt;/code&gt; se establece en un iterador final.</target>
        </trans-unit>
        <trans-unit id="786c19346a6501f7f519d77c25d16a5bd6120203" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex or the mutex is not locked, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Si no hay un mutex asociado o el mutex no est&amp;aacute; bloqueado, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; con un c&amp;oacute;digo de error de &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cd20e611e7f59595531f451ca3dfeabb2921c4e5" translate="yes" xml:space="preserve">
          <source>If there is no associated mutex, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; with an error code of &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Si no hay un mutex asociado, &lt;code&gt;&lt;a href=&quot;../../error/system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; con un c&amp;oacute;digo de error de &lt;code&gt;&lt;a href=&quot;../../error/errc&quot;&gt;std::errc::operation_not_permitted&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5d214d3c80c859a6e49e6fef5913cd6a8474d164" translate="yes" xml:space="preserve">
          <source>If there is no corresponding call to &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt;, or if &lt;code&gt;va_end&lt;/code&gt; is not called before a function that calls &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; returns, the behavior is undefined.</source>
          <target state="translated">Si no hay una llamada correspondiente a &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; , o si no se llama a &lt;code&gt;va_end&lt;/code&gt; antes de que &lt;code&gt;&lt;a href=&quot;va_start&quot;&gt;va_start&lt;/a&gt;&lt;/code&gt; una funci&amp;oacute;n que llama a va_start o &lt;code&gt;&lt;a href=&quot;va_copy&quot;&gt;va_copy&lt;/a&gt;&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="82e2ba4ed8370caec8cb2a4375b819fec9dd1a0f" translate="yes" xml:space="preserve">
          <source>If there is no pattern match, returns a value of type &lt;code&gt;from_chars_result&lt;/code&gt; such that &lt;code&gt;ptr&lt;/code&gt; equals &lt;code&gt;first&lt;/code&gt; and &lt;code&gt;ec&lt;/code&gt; equals &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;value&lt;/code&gt; is unmodified.</source>
          <target state="translated">Si no hay coincidencia de patr&amp;oacute;n, devuelve un valor de tipo &lt;code&gt;from_chars_result&lt;/code&gt; tal que &lt;code&gt;ptr&lt;/code&gt; es igual a &lt;code&gt;first&lt;/code&gt; y la &lt;code&gt;ec&lt;/code&gt; es igual a &lt;code&gt;&lt;a href=&quot;../error/errc&quot;&gt;std::errc::invalid_argument&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;value&lt;/code&gt; no se modifica.</target>
        </trans-unit>
        <trans-unit id="bb2824bbf3f97be3e717eef3b6756fb7dd5b0ccf" translate="yes" xml:space="preserve">
          <source>If there is no return statement or if the argument of the return statement is a void expression, the declared return type must be either &lt;code&gt;decltype(auto)&lt;/code&gt;, in which case the deduced return type is &lt;code&gt;void&lt;/code&gt;, or (possibly cv-qualified) &lt;code&gt;auto&lt;/code&gt; , in which case the deduced return type is then (identically cv-qualified) &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">Si no hay una declaraci&amp;oacute;n de retorno o si el argumento de la declaraci&amp;oacute;n de retorno es una expresi&amp;oacute;n nula, el tipo de retorno declarado debe ser &lt;code&gt;decltype(auto)&lt;/code&gt; , en cuyo caso el tipo de retorno deducido es &lt;code&gt;void&lt;/code&gt; o (posiblemente calificado por cv) &lt;code&gt;auto&lt;/code&gt; , en cuyo caso el tipo de devoluci&amp;oacute;n deducido es entonces (id&amp;eacute;nticamente calificado para cv) &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9786fb90520614ec4de44d4ccd5a94337ce70dc0" translate="yes" xml:space="preserve">
          <source>If there is no value of type &lt;code&gt;To&lt;/code&gt; corresponding to the value representation produced, the behavior is undefined. If there are multiple such values, which value is produced is unspecified.</source>
          <target state="translated">Si no hay ning&amp;uacute;n valor de tipo &lt;code&gt;To&lt;/code&gt; correspondiente a la representaci&amp;oacute;n del valor producido, el comportamiento es indefinido. Si hay m&amp;uacute;ltiples valores de este tipo, el valor que se produce no se especifica.</target>
        </trans-unit>
        <trans-unit id="08e7e744ae0e0c5037802c6defe497d81baa4ef8" translate="yes" xml:space="preserve">
          <source>If there is not enough memory, the old memory block is not freed and null pointer is returned.</source>
          <target state="translated">Si no hay suficiente memoria,el viejo bloque de memoria no se libera y se devuelve el puntero nulo.</target>
        </trans-unit>
        <trans-unit id="75b29d8574fca6602e9dfcd68f07686982e86cb2" translate="yes" xml:space="preserve">
          <source>If there is nothing on the left hand side of the &lt;code&gt;::&lt;/code&gt;, the lookup considers only declarations made in the global namespace scope (or introduced into the global namespace by a &lt;a href=&quot;namespace&quot;&gt;using declaration&lt;/a&gt;). This makes it possible to refer to such names even if they were hidden by a local declaration:</source>
          <target state="translated">Si no hay nada en el lado izquierdo de &lt;code&gt;::&lt;/code&gt; , la b&amp;uacute;squeda considera solo las declaraciones realizadas en el &amp;aacute;mbito del espacio de nombres global (o introducidas en el espacio de nombres global mediante una &lt;a href=&quot;namespace&quot;&gt;declaraci&amp;oacute;n de uso&lt;/a&gt; ). Esto hace posible hacer referencia a dichos nombres incluso si estaban ocultos por una declaraci&amp;oacute;n local:</target>
        </trans-unit>
        <trans-unit id="a39354352c3a36abb4078e05bc0601edf6cd7f44" translate="yes" xml:space="preserve">
          <source>If there was a &lt;code&gt;memory_order_seq_cst&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; operation X</source>
          <target state="translated">Si hubo una &lt;code&gt;memory_order_seq_cst&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;atomic_thread_fence&quot;&gt;std::atomic_thread_fence&lt;/a&gt;&lt;/code&gt; X</target>
        </trans-unit>
        <trans-unit id="ad371531997ade6500f19cfb02b883b25ff79f63" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">Si estas funciones no cumplen con la &lt;code&gt;lock.owns_lock()==true&lt;/code&gt; ( lock.owns_lock () == true y &lt;code&gt;lock.mutex()&lt;/code&gt; est&amp;aacute; bloqueado por el hilo de llamada), se llama a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Por ejemplo, esto podr&amp;iacute;a suceder si volver a bloquear el mutex arroja una excepci&amp;oacute;n,</target>
        </trans-unit>
        <trans-unit id="8b7c68c75d237fbfbeeafab70e579d60f492f831" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postcondition (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">Si estas funciones no cumplen con la condici&amp;oacute;n posterior (el &lt;code&gt;lock&lt;/code&gt; est&amp;aacute; bloqueado por el hilo de llamada), se llama a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Por ejemplo, esto podr&amp;iacute;a suceder si volver a bloquear el mutex arroja una excepci&amp;oacute;n,</target>
        </trans-unit>
        <trans-unit id="e64ebeb583017ab34a1b336b3949d0e606ed7464" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock.owns_lock()==true&lt;/code&gt; and &lt;code&gt;lock.mutex()&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">Si estas funciones no cumplen con las condiciones &lt;code&gt;lock.owns_lock()==true&lt;/code&gt; ( lock.owns_lock () == true y &lt;code&gt;lock.mutex()&lt;/code&gt; est&amp;aacute; bloqueado por el hilo de llamada), se llama a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Por ejemplo, esto podr&amp;iacute;a suceder si volver a bloquear el mutex arroja una excepci&amp;oacute;n,</target>
        </trans-unit>
        <trans-unit id="80d1cce971ef81ebeb27b3f75282ca12f479c4a3" translate="yes" xml:space="preserve">
          <source>If these functions fail to meet the postconditions (&lt;code&gt;lock&lt;/code&gt; is locked by the calling thread), &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; is called. For example, this could happen if relocking the mutex throws an exception,</source>
          <target state="translated">Si estas funciones no cumplen con las condiciones posteriores (el &lt;code&gt;lock&lt;/code&gt; est&amp;aacute; bloqueado por el hilo de llamada), se llama a &lt;code&gt;&lt;a href=&quot;../../error/terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; . Por ejemplo, esto podr&amp;iacute;a suceder si volver a bloquear el mutex arroja una excepci&amp;oacute;n,</target>
        </trans-unit>
        <trans-unit id="3d778c344c068708c3e9722504ddb91a10967713" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;codecvt&lt;/code&gt; facet does not define a conversion, no characters are converted. &lt;code&gt;to_next&lt;/code&gt; is set to be equal to &lt;code&gt;to&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt; is unchanged, and &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">Si esta faceta &lt;code&gt;codecvt&lt;/code&gt; no define una conversi&amp;oacute;n, no se convierten caracteres. &lt;code&gt;to_next&lt;/code&gt; se establece para que sea igual &lt;code&gt;to&lt;/code&gt; , &lt;code&gt;state&lt;/code&gt; no ha cambiado, y &lt;code&gt;&lt;a href=&quot;../codecvt_base&quot;&gt;std::codecvt_base::noconv&lt;/a&gt;&lt;/code&gt; se devuelve.</target>
        </trans-unit>
        <trans-unit id="aacf8a59ed2ae04fea1befba59a2f4989fe43a0b" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied byte-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="translated">Si este objeto &lt;code&gt;wstring_convert&lt;/code&gt; se construy&amp;oacute; sin una cadena de error de byte proporcionada por el usuario, arroja &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; en caso de error de conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cbcd6f179051e3d4d790103a0692450f238f91b6" translate="yes" xml:space="preserve">
          <source>If this &lt;code&gt;wstring_convert&lt;/code&gt; object was constructed without a user-supplied wide-error string, throws &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; on conversion failure.</source>
          <target state="translated">Si este objeto &lt;code&gt;wstring_convert&lt;/code&gt; se construy&amp;oacute; sin una cadena de error ancho suministrada por el usuario, arroja &lt;code&gt;&lt;a href=&quot;../../error/range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; en caso de error de conversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f6ba9b5bd88a92b215f9d46a302f511d4c0d3235" translate="yes" xml:space="preserve">
          <source>If this function is called after I/O has occurred on the standard stream, the behavior is implementation-defined: implementations range from no effect to destroying the read buffer.</source>
          <target state="translated">Si se llama a esta función después de que se haya producido una E/S en el flujo estándar,el comportamiento está definido por la implementación:las implementaciones van desde la ausencia de efecto hasta la destrucción del búfer de lectura.</target>
        </trans-unit>
        <trans-unit id="7ab8ebc954b0557ea6a9a5ccedd0ab0cb9a2ceb2" translate="yes" xml:space="preserve">
          <source>If this function is called twice on the same &lt;code&gt;obj&lt;/code&gt;, the behavior is undefined.</source>
          <target state="translated">Si esta funci&amp;oacute;n se llama dos veces en el mismo &lt;code&gt;obj&lt;/code&gt; , el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="5b1e8e769c369fe401942d10347ef2341bebc1e8" translate="yes" xml:space="preserve">
          <source>If transfer of control enters the scope of any automatic variables (e.g. by jumping forward over a declaration statement), the program is ill-formed (cannot be compiled), unless all variables whose scope is entered have.</source>
          <target state="translated">Si la transferencia de control entra en el ámbito de cualquier variable automática (por ejemplo,saltando por encima de una declaración de declaración),el programa está mal formado (no se puede compilar),a menos que todas las variables cuyo ámbito se introduce lo hayan hecho.</target>
        </trans-unit>
        <trans-unit id="9007006fca17d8a04caf552baacfbe914165d918" translate="yes" xml:space="preserve">
          <source>If transfer of control exits the scope of any automatic variables (e.g. by jumping backwards to a point before the declarations of such variables or by jumping forward out of a compound statement where the variables are scoped), the destructors are called for all variables whose scope was exited, in the order opposite to the order of their construction.</source>
          <target state="translated">Si la transferencia de control sale del ámbito de cualesquiera variables automáticas (por ejemplo,saltando hacia atrás a un punto anterior a las declaraciones de esas variables o saltando hacia adelante de una declaración compuesta en la que las variables tienen un alcance),los destructores son llamados para todas las variables cuyo alcance se haya salido,en el orden contrario al de su construcción.</target>
        </trans-unit>
        <trans-unit id="96de619385ef72541fd42f53b710eb1ba726dc0a" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Key&lt;/code&gt;s are equal according to &lt;code&gt;Pred&lt;/code&gt;, &lt;code&gt;Hash&lt;/code&gt; must return the same value for both keys.</source>
          <target state="translated">Si dos &lt;code&gt;Key&lt;/code&gt; son iguales seg&amp;uacute;n &lt;code&gt;Pred&lt;/code&gt; , &lt;code&gt;Hash&lt;/code&gt; debe devolver el mismo valor para ambas claves.</target>
        </trans-unit>
        <trans-unit id="21514f17271611919ab5d31d97737af032553cf0" translate="yes" xml:space="preserve">
          <source>If two conversion sequences are indistinguishable because they have the same rank, the following additional rules apply:</source>
          <target state="translated">Si dos secuencias de conversión son indistinguibles porque tienen el mismo rango,se aplican las siguientes reglas adicionales:</target>
        </trans-unit>
        <trans-unit id="236b56e175db6d0402c006ec6f6fe29bfcd434e0" translate="yes" xml:space="preserve">
          <source>If two or more overloads accept different pointer types, an overload for &lt;code&gt;std::nullptr_t&lt;/code&gt; is necessary to accept a null pointer argument.</source>
          <target state="translated">Si dos o m&amp;aacute;s sobrecargas aceptan diferentes tipos de puntero, es necesaria una sobrecarga para &lt;code&gt;std::nullptr_t&lt;/code&gt; para aceptar un argumento de puntero nulo.</target>
        </trans-unit>
        <trans-unit id="1df13f76013467c8d1808876f2f6ad361b81ec46" translate="yes" xml:space="preserve">
          <source>If two pointers are not specified to compare greater or compare equal, the result of the comparison is unspecified. The result may be nondeterministic, and need not be consistent even for multiple evaluations of the same expression with the same operands in the same execution of the program:</source>
          <target state="translated">Si no se especifican dos punteros para comparar mayor o igual,el resultado de la comparación no se especifica.El resultado puede ser no determinístico,y no tiene por qué ser consistente ni siquiera para evaluaciones múltiples de la misma expresión con los mismos operandos en la misma ejecución del programa:</target>
        </trans-unit>
        <trans-unit id="54c474a432a885a9d80c638012c2da37dcdf5a0e" translate="yes" xml:space="preserve">
          <source>If two ranges have equivalent elements and are of the same length, then the ranges are lexicographically</source>
          <target state="translated">Si dos gamas tienen elementos equivalentes y son de la misma longitud,entonces las gamas son lexicográficamente</target>
        </trans-unit>
        <trans-unit id="dea9e99a4902829c785e86953d9771a67436d749" translate="yes" xml:space="preserve">
          <source>If two thread identifiers compare equal, they have identical textual representations; if they do not compare equal, their representations are distinct.</source>
          <target state="translated">Si dos identificadores de hilos se comparan de igual manera,tienen representaciones textuales idénticas;si no se comparan de igual manera,sus representaciones son distintas.</target>
        </trans-unit>
        <trans-unit id="44df2c42d0c8b0977cc12b1567332b861f35e2c9" translate="yes" xml:space="preserve">
          <source>If two union members are standard-layout types, it's well-defined to examine their common subsequence on any compiler.</source>
          <target state="translated">Si dos miembros del sindicato son de tipo estándar,está bien definido examinar su subsecuente común en cualquier compilador.</target>
        </trans-unit>
        <trans-unit id="905593757752d3cb5b8a000e5d6df93d8badb63b" translate="yes" xml:space="preserve">
          <source>If two using-declarations inherit the constructor with the same signature (from two direct base classes), the program is ill-formed.</source>
          <target state="translated">Si dos declaraciones de uso heredan el constructor con la misma firma (de dos clases de base directa),el programa está mal formado.</target>
        </trans-unit>
        <trans-unit id="b3ee41429cd3e4ea61f8eae244494a1cc4dbc646" translate="yes" xml:space="preserve">
          <source>If type is an array type, an array of objects is initialized.</source>
          <target state="translated">Si el tipo es un tipo de matriz,se inicializa una matriz de objetos.</target>
        </trans-unit>
        <trans-unit id="dfd366835c89e7a8dac1ada14ac3a1a2f256aa18" translate="yes" xml:space="preserve">
          <source>If type-constraint is &lt;code&gt;Concept&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt;, then the constraint expression &lt;code&gt;Concept&amp;lt;T, A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; must be valid and return &lt;code&gt;true&lt;/code&gt;;</source>
          <target state="translated">Si el tipo de obst&amp;aacute;culos es &lt;code&gt;Concept&amp;lt;A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; , entonces la expresi&amp;oacute;n de restricci&amp;oacute;n &lt;code&gt;Concept&amp;lt;T, A&lt;sub&gt;1&lt;/sub&gt;, ..., A&lt;sub&gt;n&lt;/sub&gt;&amp;gt;&lt;/code&gt; debe ser v&amp;aacute;lido y devolver &lt;code&gt;true&lt;/code&gt; ;</target>
        </trans-unit>
        <trans-unit id="37e1efeb1f04dd65befd738a35a8fbab85af47d5" translate="yes" xml:space="preserve">
          <source>If type-constraint is present, let &lt;code&gt;T&lt;/code&gt; be the type deduced for the placeholder, &lt;code&gt;T&lt;/code&gt; must satisfy the immediately-declared constraint of type-constraint. That is,</source>
          <target state="translated">Si la restricci&amp;oacute;n de tipo est&amp;aacute; presente, deje que &lt;code&gt;T&lt;/code&gt; sea ​​el tipo deducido para el marcador de posici&amp;oacute;n, &lt;code&gt;T&lt;/code&gt; debe satisfacer la restricci&amp;oacute;n de restricci&amp;oacute;n de tipo declarada de inmediato. Es decir,</target>
        </trans-unit>
        <trans-unit id="60c6cdefb849b977d1ac7bc22c41f84525eb69b1" translate="yes" xml:space="preserve">
          <source>If value-initialization in overload (1) is undesirable, for example, if the elements are of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="translated">Si la inicializaci&amp;oacute;n del valor en la sobrecarga (1) no es deseable, por ejemplo, si los elementos son de tipo no clase y no se necesita poner a cero, puede evitarse proporcionando una &lt;a href=&quot;http://stackoverflow.com/a/21028912/273767&quot;&gt;construcci&amp;oacute;n Allocator :: personalizada&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="471d29d119a51d5505a44bc2b58788054e85e209" translate="yes" xml:space="preserve">
          <source>If value-initialization in overload (1) is undesirable, for example, if the elements are of non-class type and zeroing out is not needed, it can be avoided by providing a &lt;a href=&quot;https://stackoverflow.com/a/21028912/273767&quot;&gt;custom Allocator::construct&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f66ab74451a3db452059ec3845f07a89e06bbf3" translate="yes" xml:space="preserve">
          <source>If wc is the null wide character &lt;code&gt;L'\0'&lt;/code&gt;, a null byte is stored, preceded by any shift sequence necessary to restore the initial shift state and the conversion state parameter &lt;code&gt;*ps&lt;/code&gt; is updated to represent the initial shift state.</source>
          <target state="translated">Si wc es el car&amp;aacute;cter ancho nulo &lt;code&gt;L'\0'&lt;/code&gt; , se almacena un byte nulo, precedido por cualquier secuencia de cambio necesaria para restaurar el estado de cambio inicial y el par&amp;aacute;metro del estado de conversi&amp;oacute;n &lt;code&gt;*ps&lt;/code&gt; se actualiza para representar el estado de cambio inicial.</target>
        </trans-unit>
        <trans-unit id="32c015539aa6def36ac45f02ee69383d444c9a17" translate="yes" xml:space="preserve">
          <source>If width specifier is used, matches up to</source>
          <target state="translated">Si se utiliza el especificador de ancho,coincide hasta</target>
        </trans-unit>
        <trans-unit id="80643aeb5f10297c8773a32774b36761e19c9f6e" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; may be raised</source>
          <target state="translated">Si x es cero e y es infinito o si x es infinito e y es cero, y z es un NaN, entonces se devuelve NaN y se puede aumentar &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="217b0f1a492e46dd9c7d22b89fac1d204972e19f" translate="yes" xml:space="preserve">
          <source>If x is zero and y is infinite or if x is infinite and y is zero, and z is not a NaN, then NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si x es cero e y es infinito o si x es infinito e y es cero, y z no es un NaN, entonces se devuelve NaN y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="46f35d1f1e835536b48c1d1451cead305f826b6a" translate="yes" xml:space="preserve">
          <source>If x or y are NaN, NaN is returned</source>
          <target state="translated">Si x o y son NaN,NaN se devuelve</target>
        </trans-unit>
        <trans-unit id="448389c4ec48e9adff6b8542b1d7d5e0005baf1b" translate="yes" xml:space="preserve">
          <source>If x*y is an exact infinity and z is an infinity with the opposite sign, NaN is returned and &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt; is raised</source>
          <target state="translated">Si x * y es un infinito exacto y z es un infinito con el signo opuesto, se devuelve NaN y se eleva &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INVALID&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="3bdeffa5a91b0032e30c68e073ce8335607fac7a" translate="yes" xml:space="preserve">
          <source>If you do not have C++11, an equivalent to &lt;code&gt;std::find_if_not&lt;/code&gt; is to use &lt;code&gt;std::find_if&lt;/code&gt; with the negated predicate.</source>
          <target state="translated">Si no tiene C ++ 11, un equivalente a &lt;code&gt;std::find_if_not&lt;/code&gt; es usar &lt;code&gt;std::find_if&lt;/code&gt; con el predicado negado.</target>
        </trans-unit>
        <trans-unit id="dee1d062b9bd3ef2ac4463366425592d8bf6079d" translate="yes" xml:space="preserve">
          <source>If z is NaN, and x*y aren't 0*Inf or Inf*0, then NaN is returned (without FE_INVALID)</source>
          <target state="translated">Si z es NaN,y x*y no son 0*Inf o Inf*0,entonces se devuelve NaN (sin FE_INVÁLIDO)</target>
        </trans-unit>
        <trans-unit id="fede8b50b6882e5d3ce2a02e4778a6b33e6bfd1e" translate="yes" xml:space="preserve">
          <source>If |arg| &amp;gt; 1, a domain error occurs and NaN is returned.</source>
          <target state="translated">Si | arg | &amp;gt; 1, se produce un error de dominio y se devuelve NaN.</target>
        </trans-unit>
        <trans-unit id="19ae8a036da573c60fcd648999f547940ac705f3" translate="yes" xml:space="preserve">
          <source>If |k|&amp;gt;1, a domain error may occur</source>
          <target state="translated">Si | k |&amp;gt; 1, puede producirse un error de dominio</target>
        </trans-unit>
        <trans-unit id="f54d83c12cb912afe24330261b82ab51323c3c37" translate="yes" xml:space="preserve">
          <source>If |x| &amp;gt; 1, a domain error may occur</source>
          <target state="translated">Si | x | &amp;gt; 1, puede ocurrir un error de dominio</target>
        </trans-unit>
        <trans-unit id="124d00d6f3d9dc4a6bd589c99e1ea07d87b1c00a" translate="yes" xml:space="preserve">
          <source>If, after a using-directive was used to nominate some namespace, the namespace is extended and additional members and/or using-directives are added to it, those additional members and the additional namespaces are visible through the using-directive (in contrast with using-declaration).</source>
          <target state="translated">Si,después de que se haya utilizado una directiva de uso para designar algún espacio de nombres,se amplía el espacio de nombres y se le añaden miembros y/o directivas de uso adicionales,esos miembros y los espacios de nombres adicionales son visibles a través de la directiva de uso (en contraste con la declaración de uso).</target>
        </trans-unit>
        <trans-unit id="f18ec98606b2fb57c51cf2d2b42ed110712ce687" translate="yes" xml:space="preserve">
          <source>If, after considering all pairs of overloaded templates, there is one that is unambiguously more specialized than all others, that template's specialization is selected, otherwise compilation fails.</source>
          <target state="translated">Si,después de considerar todos los pares de plantillas sobrecargadas,hay una que es inequívocamente más especializada que todas las demás,se selecciona la especialización de esa plantilla,de lo contrario la compilación falla.</target>
        </trans-unit>
        <trans-unit id="18db54187de2ad0a31a7c5e4bdded4c034fc402d" translate="yes" xml:space="preserve">
          <source>If, after construction, the member &lt;code&gt;regex_iterator&lt;/code&gt; is not an end-of-sequence iterator, sets the member pointer to the address of the current &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si, despu&amp;eacute;s de la construcci&amp;oacute;n, el miembro &lt;code&gt;regex_iterator&lt;/code&gt; no es un iterador de fin de secuencia, establece el puntero del miembro en la direcci&amp;oacute;n del &lt;code&gt;&lt;a href=&quot;../sub_match&quot;&gt;std::sub_match&lt;/a&gt;&lt;/code&gt; actual .</target>
        </trans-unit>
        <trans-unit id="24d2b4c0d32e555ffdf12e4f24627c557a463748" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">Si, despu&amp;eacute;s de copiar el car&amp;aacute;cter nulo final de &lt;code&gt;src&lt;/code&gt; , no se alcanza el &lt;code&gt;count&lt;/code&gt; , se escriben caracteres nulos adicionales en &lt;code&gt;dest&lt;/code&gt; hasta que se haya escrito el total de caracteres de &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6321b986a2eb461234e0b8b628d35dcf35b6aeb" translate="yes" xml:space="preserve">
          <source>If, after copying the terminating null wide character from &lt;code&gt;src&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt; is not reached, additional null wide characters are written to &lt;code&gt;dest&lt;/code&gt; until the total of &lt;code&gt;count&lt;/code&gt; characters have been written.</source>
          <target state="translated">Si, despu&amp;eacute;s de copiar el car&amp;aacute;cter ancho nulo final de &lt;code&gt;src&lt;/code&gt; , no se alcanza el &lt;code&gt;count&lt;/code&gt; , se escriben caracteres anchos nulos adicionales en &lt;code&gt;dest&lt;/code&gt; hasta que se haya escrito el total de caracteres de &lt;code&gt;count&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b833da015ca09bbc003a6a35757746d54b28eaa" translate="yes" xml:space="preserve">
          <source>If, after overload resolution, the order of declaration of the aggregate's members does not match for the selected overload, the initialization of the parameter will be ill-formed.</source>
          <target state="translated">Si,tras la resolución de la sobrecarga,el orden de declaración de los miembros del agregado no coincide con la sobrecarga seleccionada,la inicialización del parámetro estará mal formada.</target>
        </trans-unit>
        <trans-unit id="4344e13bb6aa8857aeb8da90f2cfb52094846e93" translate="yes" xml:space="preserve">
          <source>If, after the using-declaration was used to take a member from a namespace, the namespace is extended and additional declarations for the same name are introduced, those additional declarations do not become visible through the using-declaration (in contrast with using-directive). One exception is when a using-declaration names a class template: partial specializations introduced later are effectively visible, because their &lt;a href=&quot;lookup&quot;&gt;lookup&lt;/a&gt; proceeds through the primary template.</source>
          <target state="translated">Si, despu&amp;eacute;s de usar la declaraci&amp;oacute;n de uso para tomar un miembro de un espacio de nombres, el espacio de nombre se extiende y se introducen declaraciones adicionales para el mismo nombre, esas declaraciones adicionales no se hacen visibles a trav&amp;eacute;s de la declaraci&amp;oacute;n de uso (en contraste con la directiva de uso ) Una excepci&amp;oacute;n es cuando una declaraci&amp;oacute;n de uso nombra una plantilla de clase: las especializaciones parciales introducidas m&amp;aacute;s tarde son efectivamente visibles, porque su &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda&lt;/a&gt; procede a trav&amp;eacute;s de la plantilla primaria.</target>
        </trans-unit>
        <trans-unit id="dbce6be800bfbd414094242237e485ad6d751c14" translate="yes" xml:space="preserve">
          <source>If, by the time &lt;code&gt;call_once&lt;/code&gt; is called, &lt;code&gt;flag&lt;/code&gt; indicates that &lt;code&gt;f&lt;/code&gt; was already called, &lt;code&gt;call_once&lt;/code&gt; returns right away (such a call to &lt;code&gt;call_once&lt;/code&gt; is known as</source>
          <target state="translated">Si, para cuando se llama a &lt;code&gt;call_once&lt;/code&gt; , el &lt;code&gt;flag&lt;/code&gt; indica que ya se llam&amp;oacute; a &lt;code&gt;f&lt;/code&gt; , &lt;code&gt;call_once&lt;/code&gt; regresa de inmediato (una llamada a &lt;code&gt;call_once&lt;/code&gt; se conoce como</target>
        </trans-unit>
        <trans-unit id="515903e5cd9a30bdc013b27094038c879ea5e3ca" translate="yes" xml:space="preserve">
          <source>If, instead of a function body, the special syntax &lt;code&gt;= delete&amp;nbsp;;&lt;/code&gt; is used, the function is defined as</source>
          <target state="translated">Si, en lugar de un cuerpo de funci&amp;oacute;n, la sintaxis especial &lt;code&gt;= delete&amp;nbsp;;&lt;/code&gt; se utiliza, la funci&amp;oacute;n se define como</target>
        </trans-unit>
        <trans-unit id="1fcb027646c98dda89397bc3d304d3c40f2112ab" translate="yes" xml:space="preserve">
          <source>If, prior to this call, &lt;code&gt;*this&lt;/code&gt; has an associated mutex ((&lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; returns a non-null pointer) and has acquired ownership of it (&lt;code&gt;owns()&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;), the mutex is unlocked by calling &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si, antes de esta llamada, &lt;code&gt;*this&lt;/code&gt; tiene un mutex asociado (( &lt;code&gt;&lt;a href=&quot;mutex&quot;&gt;mutex()&lt;/a&gt;&lt;/code&gt; devuelve un puntero no nulo) y ha adquirido la propiedad de este ( &lt;code&gt;owns()&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; ), el mutex se desbloquea llamando a &lt;code&gt;&lt;a href=&quot;../shared_mutex/unlock_shared&quot;&gt;unlock_shared()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cddfcce1d6482355377933166f2bf61ba8023df9" translate="yes" xml:space="preserve">
          <source>If, when this instance of &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; was constructed, a custom classification table was provided and the second argument to the constructor (the boolean &lt;code&gt;del&lt;/code&gt;) was &lt;code&gt;true&lt;/code&gt;, then this destructor executes &lt;code&gt;delete[] table()&lt;/code&gt;.</source>
          <target state="translated">Si, cuando se construy&amp;oacute; esta instancia de &lt;code&gt;&lt;a href=&quot;../ctype&quot;&gt;std::ctype&lt;/a&gt;&amp;lt;char&amp;gt;&lt;/code&gt; , se proporcion&amp;oacute; una tabla de clasificaci&amp;oacute;n personalizada y el segundo argumento para el constructor (el &lt;code&gt;del&lt;/code&gt; booleano ) era &lt;code&gt;true&lt;/code&gt; , entonces este destructor ejecuta la &lt;code&gt;delete[] table()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abf34976945e39546eb65c898c5e72a940d36da7" translate="yes" xml:space="preserve">
          <source>Ignore symlinks</source>
          <target state="translated">Ignorar los enlaces simbólicos</target>
        </trans-unit>
        <trans-unit id="3c9993c27a919660753159130e530c6cef6861a2" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in a template parameter type</source>
          <target state="translated">Expresión mal formada utilizada en un tipo de parámetro de plantilla</target>
        </trans-unit>
        <trans-unit id="e25011561bbd556c89b469f62fed950e3e750d2a" translate="yes" xml:space="preserve">
          <source>Ill-formed expression used in the function type</source>
          <target state="translated">Expresión mal formada utilizada en el tipo de función</target>
        </trans-unit>
        <trans-unit id="e769494ea641bd01735c8978b12dae80bc631fc2" translate="yes" xml:space="preserve">
          <source>Illegal byte sequence</source>
          <target state="translated">Secuencia de bytes ilegal</target>
        </trans-unit>
        <trans-unit id="d87c7055340deb568caf4674b187c44939256ef2" translate="yes" xml:space="preserve">
          <source>Illustrates the difference in the matching algorithm between ECMAScript and POSIX regular expressions.</source>
          <target state="translated">Ilustra la diferencia en el algoritmo de concordancia entre las expresiones regulares ECMAScript y POSIX.</target>
        </trans-unit>
        <trans-unit id="13da76356b1fa19b7292603df60cd8183deacc7b" translate="yes" xml:space="preserve">
          <source>Imbues &lt;code&gt;u&lt;/code&gt; with the locale &lt;code&gt;loc&lt;/code&gt;</source>
          <target state="translated">Impregna &lt;code&gt;u&lt;/code&gt; con la configuraci&amp;oacute;n regional &lt;code&gt;loc&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="8781d615fd77be9578225c40ac67b9471394cced" translate="yes" xml:space="preserve">
          <source>Implementation</source>
          <target state="translated">Implementation</target>
        </trans-unit>
        <trans-unit id="1bec87acbedb55cac0fd8887b67c78afe18b54a1" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior control</source>
          <target state="translated">La implementación de control de comportamiento definido</target>
        </trans-unit>
        <trans-unit id="dd1e3f977c02056ea472998c02c487e2316720f9" translate="yes" xml:space="preserve">
          <source>Implementation defined behavior is controlled by &lt;code&gt;#pragma&lt;/code&gt; directive.</source>
          <target state="translated">El comportamiento definido de implementaci&amp;oacute;n est&amp;aacute; controlado por la directiva &lt;code&gt;#pragma&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="baec7f3938747fde7fd91e8cd29d528dd3ee3a7c" translate="yes" xml:space="preserve">
          <source>Implementation defined class type. The name &lt;code&gt;proxy&lt;/code&gt; is for exposition only.</source>
          <target state="translated">Implementaci&amp;oacute;n del tipo de clase definida. El nombre &lt;code&gt;proxy&lt;/code&gt; es solo para exposici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e0bf2dc952ab6d2617aa9b9ee013534f9eeb5b62" translate="yes" xml:space="preserve">
          <source>Implementation notes</source>
          <target state="translated">Notas de aplicación</target>
        </trans-unit>
        <trans-unit id="ac4df666d0cf4b162038d0ca49842cbe67665bba" translate="yes" xml:space="preserve">
          <source>Implementation properties</source>
          <target state="translated">Propiedades de implementación</target>
        </trans-unit>
        <trans-unit id="618e4b612934a7109a06661620d8dd64653307f6" translate="yes" xml:space="preserve">
          <source>Implementation test to check if setbuf() is supported on a dynamic strstream (output obtained with Sun Studio).</source>
          <target state="translated">Prueba de implementación para comprobar si setbuf()está soportado en un strstream dinámico (salida obtenida con Sun Studio).</target>
        </trans-unit>
        <trans-unit id="4ba79c92bcb0daad8f101d0490ccc2e884002f26" translate="yes" xml:space="preserve">
          <source>Implementation-defined meaning, but POSIX XSI specifies that when set on a directory, only file owners may delete files even if the directory is writeable to others (used with &lt;code&gt;/tmp&lt;/code&gt;)</source>
          <target state="translated">Significado definido por la implementaci&amp;oacute;n, pero POSIX XSI especifica que cuando se establece en un directorio, solo los propietarios de archivos pueden eliminar archivos incluso si el directorio es grabable para otros (usado con &lt;code&gt;/tmp&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="c4dfef564acdd2d91911e7e70e08d38d4e85e505" translate="yes" xml:space="preserve">
          <source>Implementation-defined native handle object.</source>
          <target state="translated">Objeto de manejo nativo definido por la implementación.</target>
        </trans-unit>
        <trans-unit id="5df371b6c82001fdb73bd4a012e00b058a54aeba" translate="yes" xml:space="preserve">
          <source>Implementation-defined pathname format, auto-detected where possible</source>
          <target state="translated">Formato de ruta definido por la implementación,auto-detectado cuando sea posible</target>
        </trans-unit>
        <trans-unit id="667c8eda998c1c080db13b731500db6f8a8c9f3c" translate="yes" xml:space="preserve">
          <source>Implementation-defined value. If &lt;code&gt;command&lt;/code&gt; is a null pointer, returns a nonzero value if and only if the command processor exists.</source>
          <target state="translated">Valor definido por la implementaci&amp;oacute;n. Si el &lt;code&gt;command&lt;/code&gt; es un puntero nulo, devuelve un valor distinto de cero si y solo si el procesador de comando existe.</target>
        </trans-unit>
        <trans-unit id="2b90c22fbd261737448cc728280b9e1a0b2564f9" translate="yes" xml:space="preserve">
          <source>Implementation-defined.</source>
          <target state="translated">Implementation-defined.</target>
        </trans-unit>
        <trans-unit id="fc59b9097e566566bcbc34003e0d601ccd5cbd0c" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to avoid dynamic allocations for small objects, but such an optimization may only be applied to types for which &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Se recomienda que las implementaciones eviten las asignaciones din&amp;aacute;micas para objetos peque&amp;ntilde;os, pero dicha optimizaci&amp;oacute;n solo puede aplicarse a los tipos para los que &lt;code&gt;&lt;a href=&quot;../types/is_move_constructible&quot;&gt;std::is_nothrow_move_constructible&lt;/a&gt;&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d4e582a58851ee6c4bb6dc2e172c7707251917f" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to declare the placeholders as if by &lt;code&gt;inline constexpr /*unspecified*/ _1;&lt;/code&gt;, although declaring them by &lt;code&gt;extern /*unspecified*/ _1;&lt;/code&gt; is still allowed by the standard.</source>
          <target state="translated">Se alienta a las implementaciones a declarar los marcadores de posici&amp;oacute;n como si fuera por &lt;code&gt;inline constexpr /*unspecified*/ _1;&lt;/code&gt; , aunque declar&amp;aacute;ndolos por &lt;code&gt;extern /*unspecified*/ _1;&lt;/code&gt; todav&amp;iacute;a est&amp;aacute; permitido por el est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="fc2283d4e61c94c8b4cf57a3cc3008b1c58fed08" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not consider &lt;code&gt;p&lt;/code&gt; not existing to be an error.</source>
          <target state="translated">Se recomienda que las implementaciones no consideren que &lt;code&gt;p&lt;/code&gt; no existente sea un error.</target>
        </trans-unit>
        <trans-unit id="4cdbff21c557331fbffdc58f3ae0f283ef89f728" translate="yes" xml:space="preserve">
          <source>Implementations are encouraged to not provide any programmatic way to query, set, or modify the build level or to set or modify the violation handler.</source>
          <target state="translated">Se alienta a las implementaciones a que no proporcionen ninguna forma programática de consultar,establecer o modificar el nivel de construcción o de establecer o modificar el manejador de violaciones.</target>
        </trans-unit>
        <trans-unit id="0fc00335f1f76568cf7bc5d27173b1a48e4839fb" translate="yes" xml:space="preserve">
          <source>Implementations are not permitted to declare library functions as &lt;code&gt;constexpr&lt;/code&gt; unless the standard says the function is &lt;code&gt;constexpr&lt;/code&gt;.</source>
          <target state="translated">No se permite que las implementaciones declaren funciones de biblioteca como &lt;code&gt;constexpr&lt;/code&gt; a menos que el est&amp;aacute;ndar indique que la funci&amp;oacute;n es &lt;code&gt;constexpr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cac6f663736c0881de57437359b44434cf63f3b6" translate="yes" xml:space="preserve">
          <source>Implementations may provide specializations of &lt;code&gt;std::numeric_limits&lt;/code&gt; for implementation-specific types: e.g. GCC provides &lt;code&gt;std::numeric_limits&amp;lt;__int128&amp;gt;&lt;/code&gt;. Non-standard libraries may &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;add specializations&lt;/a&gt; for library-provided types, e.g. &lt;a href=&quot;http://openexr.com/&quot;&gt;OpenEXR&lt;/a&gt; provides &lt;code&gt;std::numeric_limits&amp;lt;half&amp;gt;&lt;/code&gt; for a 16-bit floating-point type.</source>
          <target state="translated">Las implementaciones pueden proporcionar especializaciones de &lt;code&gt;std::numeric_limits&lt;/code&gt; para tipos espec&amp;iacute;ficos de implementaci&amp;oacute;n: por ejemplo, GCC proporciona &lt;code&gt;std::numeric_limits&amp;lt;__int128&amp;gt;&lt;/code&gt; . Las bibliotecas no est&amp;aacute;ndar pueden &lt;a href=&quot;http://en.cppreference.com/w/cpp/language/extending_std&quot;&gt;agregar especializaciones&lt;/a&gt; para los tipos proporcionados por la biblioteca, por ejemplo, &lt;a href=&quot;http://openexr.com/&quot;&gt;OpenEXR&lt;/a&gt; proporciona &lt;code&gt;std::numeric_limits&amp;lt;half&amp;gt;&lt;/code&gt; para un tipo de punto flotante de 16 bits.</target>
        </trans-unit>
        <trans-unit id="e11e78a73a7bdbeba97a62a3332a0fcaea58d4d7" translate="yes" xml:space="preserve">
          <source>Implementations that do not support C++17, but support &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;ISO 29124:2010&lt;/a&gt;, provide this function if &lt;code&gt;__STDCPP_MATH_SPEC_FUNCS__&lt;/code&gt; is defined by the implementation to a value at least 201003L and if the user defines &lt;code&gt;__STDCPP_WANT_MATH_SPEC_FUNCS__&lt;/code&gt; before including any standard library headers.</source>
          <target state="translated">Las implementaciones que no admiten C ++ 17, pero que admiten &lt;a href=&quot;http://en.cppreference.com/w/cpp/experimental/special_math&quot;&gt;ISO 29124: 2010&lt;/a&gt; , proporcionan esta funci&amp;oacute;n si &lt;code&gt;__STDCPP_MATH_SPEC_FUNCS__&lt;/code&gt; se define por la implementaci&amp;oacute;n en un valor de al menos 201003L y si el usuario define &lt;code&gt;__STDCPP_WANT_MATH_SPEC_FUNCS__&lt;/code&gt; antes de incluir cualquier encabezado de biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="70e8f87cf29af9772a694ae2cede769b63d6dda0" translate="yes" xml:space="preserve">
          <source>Implementations that do not support ISO 29124:2010 but support TR 19768:2007 (TR1), provide this function in the header &lt;code&gt;tr1/cmath&lt;/code&gt; and namespace &lt;code&gt;std::tr1&lt;/code&gt;.</source>
          <target state="translated">Las implementaciones que no admiten ISO 29124: 2010 pero admiten TR 19768: 2007 (TR1), proporcionan esta funci&amp;oacute;n en el encabezado &lt;code&gt;tr1/cmath&lt;/code&gt; y el espacio de nombres &lt;code&gt;std::tr1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="773665687bef6caf01efcdb3d35a7cb85d3b76c9" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="translated">Las implementaciones generalmente garantizan una precisi&amp;oacute;n de menos de 1 ulp (unidades en &amp;uacute;ltimo lugar): &lt;a href=&quot;http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt; , &lt;a href=&quot;http://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt; , &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6a1e74b0c42f643746739d370decb51f6b1090af" translate="yes" xml:space="preserve">
          <source>Implementations usually guarantee precision of less than 1 ulp (units in the last place): &lt;a href=&quot;https://sourceware.org/git/?p=glibc.git;a=blob_plain;f=sysdeps/ieee754/dbl-64/e_hypot.c&quot;&gt;GNU&lt;/a&gt;, &lt;a href=&quot;https://www.freebsd.org/cgi/cvsweb.cgi/src/lib/msun/src/e_hypot.c?rev=1.13.4.2;content-type=text/plain&quot;&gt;BSD&lt;/a&gt;, &lt;a href=&quot;http://www.open64.net/doc/d5/d3f/hypot_8c-source.html&quot;&gt;Open64&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1270f12ce6696248d9babe2729d237c7e58364" translate="yes" xml:space="preserve">
          <source>Implements the analogs of the unary arithmetic operators for complex numbers.</source>
          <target state="translated">Implementa los análogos de los operadores aritméticos unarios para números complejos.</target>
        </trans-unit>
        <trans-unit id="ecc1f13a5483ad5061a47e46d970f730cb42f7e5" translate="yes" xml:space="preserve">
          <source>Implements the binary operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="translated">Implementa los operadores binarios para la aritmética compleja y para la aritmética mixta compleja/escalar.Los argumentos escalares se tratan como números complejos con la parte real igual al argumento y la parte imaginaria puesta a cero.</target>
        </trans-unit>
        <trans-unit id="c4afda3b855163af9d0d3b6360d184e0bdc5cd94" translate="yes" xml:space="preserve">
          <source>Implements the compound assignment operators for complex arithmetic and for mixed complex/scalar arithmetic. Scalar arguments are treated as complex numbers with the real part equal to the argument and the imaginary part set to zero.</source>
          <target state="translated">Implementa los operadores de asignación de compuestos para la aritmética compleja y para la aritmética mixta compleja/escalar.Los argumentos escalares se tratan como números complejos con la parte real igual al argumento y la parte imaginaria puesta a cero.</target>
        </trans-unit>
        <trans-unit id="7b890ec344a13c8ecc3220d297694526da2518e7" translate="yes" xml:space="preserve">
          <source>Implements unary plus and unary minus for the durations.</source>
          <target state="translated">Implementa unary más y unary menos para las duraciones.</target>
        </trans-unit>
        <trans-unit id="978783100f08201e0e5529544f86d4a285682f97" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence consists of the following, in this order:</source>
          <target state="translated">La secuencia de conversión implícita consiste en lo siguiente,en este orden:</target>
        </trans-unit>
        <trans-unit id="1429b69e907debf636007c5f2b2aa8f332893f57" translate="yes" xml:space="preserve">
          <source>Implicit conversion sequence in list-initialization</source>
          <target state="translated">Secuencia de conversión implícita en la inicialización de la lista</target>
        </trans-unit>
        <trans-unit id="a454cb8b77503090cbd9a357441f356bcc77421b" translate="yes" xml:space="preserve">
          <source>Implicit conversions</source>
          <target state="translated">Conversiones implícitas</target>
        </trans-unit>
        <trans-unit id="46354cbf9b435d43405dcf0d28126a074735a10d" translate="yes" xml:space="preserve">
          <source>Implicit conversions are performed whenever an expression of some type &lt;code&gt;T1&lt;/code&gt; is used in context that does not accept that type, but accepts some other type &lt;code&gt;T2&lt;/code&gt;; in particular:</source>
          <target state="translated">Las conversiones impl&amp;iacute;citas se realizan cada vez que se usa una expresi&amp;oacute;n de alg&amp;uacute;n tipo &lt;code&gt;T1&lt;/code&gt; en un contexto que no acepta ese tipo, pero acepta alg&amp;uacute;n otro tipo &lt;code&gt;T2&lt;/code&gt; ; en particular:</target>
        </trans-unit>
        <trans-unit id="c7e1233543f67ff6021074ff2ae9773f138a2071" translate="yes" xml:space="preserve">
          <source>Implicit conversions between two durations normally depends on the tick period of the durations. However, implicit conversions can happen regardless of tick period if &lt;code&gt;std::chrono::treat_as_floating_point&amp;lt;Rep&amp;gt;::value == true&lt;/code&gt;.</source>
          <target state="translated">Las conversiones impl&amp;iacute;citas entre dos duraciones normalmente dependen del per&amp;iacute;odo de tics de las duraciones. Sin embargo, las conversiones impl&amp;iacute;citas pueden ocurrir independientemente del per&amp;iacute;odo de tick si &lt;code&gt;std::chrono::treat_as_floating_point&amp;lt;Rep&amp;gt;::value == true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cff2a76253e4ae1d3384d748888091cc614f0787" translate="yes" xml:space="preserve">
          <source>Implicit expression variations</source>
          <target state="translated">Variaciones de expresión implícitas</target>
        </trans-unit>
        <trans-unit id="6deeab06530145f211662ed2cb9cf74741af72c3" translate="yes" xml:space="preserve">
          <source>Implicit instantiation</source>
          <target state="translated">Instanciación implícita</target>
        </trans-unit>
        <trans-unit id="46c4cf71d06da185f299f0f266b516eb714362c2" translate="yes" xml:space="preserve">
          <source>Implicitly declared copy assignment operator</source>
          <target state="translated">Operador de asignación de copias implícitamente declarado</target>
        </trans-unit>
        <trans-unit id="f3b3376d1419db08d028d5d3e6c6df0f0035aa37" translate="yes" xml:space="preserve">
          <source>Implicitly declared destructor</source>
          <target state="translated">Implícitamente declarado destructor</target>
        </trans-unit>
        <trans-unit id="0562f19403fee4205b21d8bb018af2a9b080047c" translate="yes" xml:space="preserve">
          <source>Implicitly-declared and user-defined non-explicit &lt;a href=&quot;copy_constructor&quot;&gt;copy constructors&lt;/a&gt; and &lt;a href=&quot;move_constructor&quot;&gt;move constructors&lt;/a&gt; are converting constructors.</source>
          <target state="translated">Impl&amp;iacute;citamente-declarados y no expl&amp;iacute;citos definidos por el usuario &lt;a href=&quot;copy_constructor&quot;&gt;constructores de copia&lt;/a&gt; y &lt;a href=&quot;move_constructor&quot;&gt;constructores movimiento&lt;/a&gt; son la conversi&amp;oacute;n de constructores.</target>
        </trans-unit>
        <trans-unit id="29a6f3e1205f66c508c2094943ddce2c63b0df90" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy assignment operator</source>
          <target state="translated">Operador de asignación de copias implícitamente declarado</target>
        </trans-unit>
        <trans-unit id="a6d4013875adefe27157f85be3bba73a81597a9f" translate="yes" xml:space="preserve">
          <source>Implicitly-declared copy constructor</source>
          <target state="translated">Constructor de copias implícitamente declarado</target>
        </trans-unit>
        <trans-unit id="88095a2668d811c3785a1fa8299728b3a2949e56" translate="yes" xml:space="preserve">
          <source>Implicitly-declared default constructor</source>
          <target state="translated">Constructor por defecto implícitamente declarado</target>
        </trans-unit>
        <trans-unit id="58d35239637c6ad0d309cc3ac73e345488ae6f80" translate="yes" xml:space="preserve">
          <source>Implicitly-declared destructor</source>
          <target state="translated">Destructor declarado implícitamente</target>
        </trans-unit>
        <trans-unit id="a122664f9fa35a0ead17f50a517e4e30c5f78e62" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move assignment operator</source>
          <target state="translated">Operador de asignación de movimientos implícitamente declarado</target>
        </trans-unit>
        <trans-unit id="2c98bb0a4aaf09d346ed78f5a0b9b9a10f6c45be" translate="yes" xml:space="preserve">
          <source>Implicitly-declared move constructor</source>
          <target state="translated">Constructora de movimientos implícitamente declarados</target>
        </trans-unit>
        <trans-unit id="2deeed834989276fef215f6f2897d39d3740f2f0" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy assignment operator</source>
          <target state="translated">Operador de asignación de copias implícitamente definido</target>
        </trans-unit>
        <trans-unit id="d011d88c050a6f60568345047d29ebc388337773" translate="yes" xml:space="preserve">
          <source>Implicitly-defined copy constructor</source>
          <target state="translated">Constructor de copias implícitamente definido</target>
        </trans-unit>
        <trans-unit id="fa97e996fd2560cf2c05804b139c35767f0e76e5" translate="yes" xml:space="preserve">
          <source>Implicitly-defined default constructor</source>
          <target state="translated">Constructor por defecto implícitamente definido</target>
        </trans-unit>
        <trans-unit id="061bd07a1bb1a33b801c708770977b87d559dec3" translate="yes" xml:space="preserve">
          <source>Implicitly-defined destructor</source>
          <target state="translated">Destructor implícito</target>
        </trans-unit>
        <trans-unit id="2904db3125ebf0c63383992eb2b2968ba47ba5e2" translate="yes" xml:space="preserve">
          <source>Implicitly-defined member functions</source>
          <target state="translated">Funciones de los miembros implícitamente definidas</target>
        </trans-unit>
        <trans-unit id="e45913a1e2322cc7a36b3505067db026e25257da" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move assignment operator</source>
          <target state="translated">Operador de asignación de movimientos definidos implícitamente</target>
        </trans-unit>
        <trans-unit id="4ebcbcc97e562ec198f2e53e43d491b81d9344ee" translate="yes" xml:space="preserve">
          <source>Implicitly-defined move constructor</source>
          <target state="translated">Constructor de movimientos implícitamente definidos</target>
        </trans-unit>
        <trans-unit id="2f48272a7bcd8ca888d2cfc92fd1bc8b4d291257" translate="yes" xml:space="preserve">
          <source>Implicitly-generated deduction guides</source>
          <target state="translated">Guías de deducción generadas implícitamente</target>
        </trans-unit>
        <trans-unit id="27328a2eb2f15815a68b1653d19575045b8cf992" translate="yes" xml:space="preserve">
          <source>In 2's complement systems, the absolute value of the most-negative value is out of range, e.g. for 32-bit 2's complement type int, INT_MIN is -2147483648, but the would-be result 2147483648 is greater than INT_MAX, which is 2147483647.</source>
          <target state="translated">En los sistemas de complemento de 2,el valor absoluto del valor más negativo está fuera de rango,por ejemplo,para el complemento de 32 bits de tipo int,INT_MIN es -2147483648,pero el posible resultado 2147483648 es mayor que INT_MAX,que es 2147483647.</target>
        </trans-unit>
        <trans-unit id="b5fd98f8c63f3d298c51c647d77132a000415d4f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, when a namespace is added to the set of associated namespaces, its inline namespaces are added as well, and if an inline namespace is added to the list of associated namespaces, its enclosing namespace is added as well.</source>
          <target state="translated">En la &lt;a href=&quot;adl&quot;&gt;b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; , cuando se agrega un espacio de nombres al conjunto de espacios de nombres asociados, tambi&amp;eacute;n se agregan sus espacios de nombres en l&amp;iacute;nea, y si se agrega un espacio de nombres en l&amp;iacute;nea a la lista de espacios de nombres asociados, tambi&amp;eacute;n se agrega su espacio de nombres adjunto.</target>
        </trans-unit>
        <trans-unit id="9fd1e0ac5e63fbea64f332e88d4780d848f55564" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;constant_expression&quot;&gt;constant expression&lt;/a&gt; and &lt;a href=&quot;constant_initialization&quot;&gt;constant initialization&lt;/a&gt;, return value optimization (RVO) is guaranteed, however, named return value optimization (NRVO) is forbidden (note: this is specified by post-C++14 defect report CWG 2022 and reversed by defect report CWG 2278):</source>
          <target state="translated">En &lt;a href=&quot;constant_expression&quot;&gt;expresi&amp;oacute;n constante&lt;/a&gt; e &lt;a href=&quot;constant_initialization&quot;&gt;inicializaci&amp;oacute;n constante&lt;/a&gt; , la optimizaci&amp;oacute;n del valor de retorno (RVO) est&amp;aacute; garantizada, sin embargo, la optimizaci&amp;oacute;n del valor de retorno con nombre (NRVO) est&amp;aacute; prohibida (nota: esto se especifica mediante el informe de defectos posterior a C ++ 14 CWG 2022 y se invierte mediante el informe de defectos CWG 2278):</target>
        </trans-unit>
        <trans-unit id="4438658486a8aa1c2ccb17440e6244e19bb12c43" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;coroutines&quot;&gt;coroutines&lt;/a&gt;, copy/move of the parameter into coroutine state may be elided where this does not change the behavior of the program other than by omitting the calls to the parameter's constructor and destructor. This can take place if the parameter is never referenced after a suspension point or when the entire coroutine state was never heap-allocated in the first place.</source>
          <target state="translated">En las &lt;a href=&quot;coroutines&quot;&gt;rutinas&lt;/a&gt; , la copia / mover el par&amp;aacute;metro al estado de la rutina se puede elidir cuando esto no cambia el comportamiento del programa, salvo omitiendo las llamadas al constructor y destructor del par&amp;aacute;metro. Esto puede tener lugar si el par&amp;aacute;metro nunca se hace referencia despu&amp;eacute;s de un punto de suspensi&amp;oacute;n o cuando el estado de rutina completo nunca se asign&amp;oacute; en primer lugar.</target>
        </trans-unit>
        <trans-unit id="752b262a5dc8786ae6cab7940e196fea49ff6ccb" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;fold&quot;&gt;fold-expressions&lt;/a&gt;, the pattern is the entire subexpression that does not contain an unexpanded parameter pack.</source>
          <target state="translated">En &lt;a href=&quot;fold&quot;&gt;las expresiones de plegado&lt;/a&gt; , el patr&amp;oacute;n es la subexpresi&amp;oacute;n completa que no contiene un paquete de par&amp;aacute;metros sin expandir.</target>
        </trans-unit>
        <trans-unit id="2242cd439921fc4c92bc135cffe3759d57213422" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;list_initialization&quot;&gt;list initialization&lt;/a&gt;, the argument is a braced-init-list, which isn't an expression, so the implicit conversion sequence into the parameter type for the purpose of overload resolution is decided by the following special rules:</source>
          <target state="translated">En la &lt;a href=&quot;list_initialization&quot;&gt;inicializaci&amp;oacute;n de la lista&lt;/a&gt; , el argumento es una lista de inicializaci&amp;oacute;n arriostrada, que no es una expresi&amp;oacute;n, por lo que la secuencia de conversi&amp;oacute;n impl&amp;iacute;cita en el tipo de par&amp;aacute;metro para la resoluci&amp;oacute;n de sobrecarga se decide mediante las siguientes reglas especiales:</target>
        </trans-unit>
        <trans-unit id="1cc4dbef738efa286661d780a703351be8b0b7f1" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Best_viable_function&quot;&gt;overload resolution&lt;/a&gt;, partial ordering takes precedence over whether a function template is generated from a guide: if the function template generated from the constructor is more specialized than the one generated from the deduction guide, the one generated from the constructor is chosen. Because the copy deduction candidate is typically more specialized than a wrapping constructor, this rule means that copying is generally preferred over wrapping.</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Best_viable_function&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; , el orden parcial tiene prioridad sobre si una plantilla de funci&amp;oacute;n se genera a partir de una gu&amp;iacute;a: si la plantilla de funci&amp;oacute;n generada por el constructor es m&amp;aacute;s especializada que la generada a partir de la gu&amp;iacute;a de deducci&amp;oacute;n, se elige la generada por el constructor. Debido a que el candidato de deducci&amp;oacute;n de copia es t&amp;iacute;picamente m&amp;aacute;s especializado que un constructor de envoltura, esta regla significa que generalmente se prefiere la copia sobre la envoltura.</target>
        </trans-unit>
        <trans-unit id="4809c5e41e7473cccbc72a4bb155bdc02191303e" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every combination of types &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, where class type &lt;code&gt;B&lt;/code&gt; is either the same class as &lt;code&gt;D&lt;/code&gt; or an unambiguous and accessible base class of &lt;code&gt;D&lt;/code&gt;, and &lt;code&gt;R&lt;/code&gt; is either an object or function type, the following function signature participates in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada combinaci&amp;oacute;n de tipos &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , donde la clase tipo &lt;code&gt;B&lt;/code&gt; es la misma clase que &lt;code&gt;D&lt;/code&gt; o una clase base de &lt;code&gt;D&lt;/code&gt; inequ&amp;iacute;voca y accesible , y &lt;code&gt;R&lt;/code&gt; es un tipo de objeto o funci&amp;oacute;n , la siguiente firma de funci&amp;oacute;n participa en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="624c4590775fbf40a4b7d04856d19fc9508c5fa6" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every object type &lt;code&gt;T&lt;/code&gt; (possibly cv-qualified), the following function signature participates in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada tipo de objeto &lt;code&gt;T&lt;/code&gt; (posiblemente calificado por cv), la siguiente firma de funci&amp;oacute;n participa en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="307ea5bb116870783914632b4b12d175efc040fc" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every optionally volatile-qualified arithmetic type &lt;code&gt;A&lt;/code&gt; other than &lt;code&gt;bool&lt;/code&gt;, and for every optionally volatile-qualified pointer &lt;code&gt;P&lt;/code&gt; to optionally cv-qualified object type, the following function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada tipo de aritm&amp;eacute;tica &lt;code&gt;A&lt;/code&gt; opcionalmente vol&amp;aacute;til calificado que no sea &lt;code&gt;bool&lt;/code&gt; , y para cada puntero calificado opcionalmente vol&amp;aacute;til &lt;code&gt;P&lt;/code&gt; a tipo de objeto opcionalmente cv calificado, las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="5990cf25ac820a864a2b308a05c41a666871b396" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair A1 and A2, where A1 is an arithmetic type (optionally volatile-qualified) and A2 is a promoted arithmetic type, the following function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada par A1 y A2, donde A1 es un tipo aritm&amp;eacute;tico (opcionalmente calificado como vol&amp;aacute;til) y A2 es un tipo aritm&amp;eacute;tico promovido, las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="8d3869a5bce1a140062b4b7e7874a7e2f0b63bc7" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; and for every object type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada par de tipos aritm&amp;eacute;ticos promovidos &lt;code&gt;L&lt;/code&gt; y &lt;code&gt;R&lt;/code&gt; y para cada tipo de objeto &lt;code&gt;T&lt;/code&gt; , las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="b24752ca21e578d5ccc2e9cc894a56665fc96230" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, including enumeration types, the following function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada par de tipos aritm&amp;eacute;ticos promovidos &lt;code&gt;L&lt;/code&gt; y &lt;code&gt;R&lt;/code&gt; , incluidos los tipos de enumeraci&amp;oacute;n, las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="fd26ab1ed7c9b56dae3b9425960ee35cb9730a3f" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted arithmetic types &lt;code&gt;LA&lt;/code&gt; and &lt;code&gt;RA&lt;/code&gt; and for every pair of promoted integral types &lt;code&gt;LI&lt;/code&gt; and &lt;code&gt;RI&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada par de tipos aritm&amp;eacute;ticos promovidos &lt;code&gt;LA&lt;/code&gt; y &lt;code&gt;RA&lt;/code&gt; y para cada par de tipos integrales promovidos &lt;code&gt;LI&lt;/code&gt; y &lt;code&gt;RI&lt;/code&gt; , las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="f476dbd74c2f442c1c2e2829bce88b4a88341d7d" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt; the following function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada par de tipos integrales promovidos &lt;code&gt;L&lt;/code&gt; y &lt;code&gt;R&lt;/code&gt; , las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="eb835b282c835e4cba40899b90f1b4b1b4026a72" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every pair of promoted integral types &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;R&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada par de tipos integrales promovidos &lt;code&gt;L&lt;/code&gt; y &lt;code&gt;R&lt;/code&gt; , las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="c4a93fe8e1bc45c860bc0b892d8c877cf026beb8" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every promoted arithmetic type &lt;code&gt;A&lt;/code&gt; and for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada aritm&amp;eacute;tica promovida tipo &lt;code&gt;A&lt;/code&gt; y para cada tipo &lt;code&gt;T&lt;/code&gt; , las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="fb2d8e1a38d1a77a396a0e77f09d5580ac4be3ba" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt; that is either object type (possibly cv-qualified) or function type (not const- or ref-qualified), the following function signature participates in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada tipo &lt;code&gt;T&lt;/code&gt; que sea tipo de objeto (posiblemente calificado por cv) o tipo de funci&amp;oacute;n (no calificado const o ref), la siguiente firma de funci&amp;oacute;n participa en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="401b7699fa1e8e938b279018437f1606b4040a67" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for every type &lt;code&gt;T&lt;/code&gt;, the following function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para cada tipo &lt;code&gt;T&lt;/code&gt; , las siguientes firmas de funci&amp;oacute;n participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="0c2aad84e7da44f63319332803f4b852d30346b4" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, for pointer or enumeration type &lt;code&gt;T&lt;/code&gt;, the following function signature participates in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , para el puntero o el tipo de enumeraci&amp;oacute;n &lt;code&gt;T&lt;/code&gt; , la siguiente firma de funci&amp;oacute;n participa en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="5cea19a589fd752a8bdd766f6cd3803387a4d265" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, the following built-in function signatures participate in overload resolution:</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , las siguientes firmas de funciones integradas participan en la resoluci&amp;oacute;n de sobrecarga:</target>
        </trans-unit>
        <trans-unit id="ee813279dc64b0e3db6b8e7e767214afb0a3c85c" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;overload resolution against user-defined operators&lt;/a&gt;, this operator does not introduce any additional function signatures: built-in address-of operator does not apply if there exists an overloaded &lt;code&gt;operator&amp;amp;&lt;/code&gt; that is a &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;viable function&lt;/a&gt;.</source>
          <target state="translated">En la &lt;a href=&quot;overload_resolution#Call_to_an_overloaded_operator&quot;&gt;resoluci&amp;oacute;n de sobrecarga contra operadores definidos por el usuario&lt;/a&gt; , este operador no introduce ninguna firma de funci&amp;oacute;n adicional: la direcci&amp;oacute;n integrada del operador no se aplica si existe un &lt;code&gt;operator&amp;amp;&lt;/code&gt; sobrecargado y esa es una &lt;a href=&quot;overload_resolution#Viable_functions&quot;&gt;funci&amp;oacute;n viable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dd138803f2292cc51a5e2969a85f684f859f9f88" translate="yes" xml:space="preserve">
          <source>In &lt;a href=&quot;using_declaration&quot;&gt;using declaration&lt;/a&gt;, ellipsis may appear in the list of declarators, this is useful when deriving from a parameter pack:</source>
          <target state="translated">Al &lt;a href=&quot;using_declaration&quot;&gt;usar la declaraci&amp;oacute;n&lt;/a&gt; , pueden aparecer puntos suspensivos en la lista de declaradores, esto es &amp;uacute;til cuando se deriva de un paquete de par&amp;aacute;metros:</target>
        </trans-unit>
        <trans-unit id="c58f1f0803bbe584686a6a997ca2d9633a806b36" translate="yes" xml:space="preserve">
          <source>In C prior to C99 (but not in C++), unsuffixed decimal values that do not fit in &lt;code&gt;long int&lt;/code&gt; are allowed to have the type &lt;code&gt;unsigned long int&lt;/code&gt;.</source>
          <target state="translated">En C anterior a C99 (pero no en C ++), los valores decimales no combinados que no caben en &lt;code&gt;long int&lt;/code&gt; pueden tener el tipo &lt;code&gt;unsigned long int&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="11a679b4f1f70ac38a1af627d070d394e3b260d2" translate="yes" xml:space="preserve">
          <source>In C++, unlike C, variables cannot be declared &lt;code&gt;register&lt;/code&gt;.</source>
          <target state="translated">En C ++, a diferencia de C, las variables no se pueden declarar como &lt;code&gt;register&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9036e8af52064611d82c261ee7c4ae9a4cdd7015" translate="yes" xml:space="preserve">
          <source>In C++11 and C++14 it is valid to construct a &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; from a &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">En C ++ 11 y C ++ 14 es v&amp;aacute;lido construir un &lt;code&gt;&lt;a href=&quot;../shared_ptr&quot;&gt;std::shared_ptr&lt;/a&gt;&amp;lt;T&amp;gt;&lt;/code&gt; partir de un &lt;code&gt;&lt;a href=&quot;../unique_ptr&quot;&gt;std::unique_ptr&lt;/a&gt;&amp;lt;T[]&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d7851c45dc812ab508d940b1e3b960f585dcd4c8" translate="yes" xml:space="preserve">
          <source>In C++11, &lt;code&gt;broken_promise&lt;/code&gt; was specified to equal zero despite &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt;/&lt;code&gt;&lt;a href=&quot;../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; using zero to mean &quot;no error&quot;. This was fixed in C++14.</source>
          <target state="translated">En C ++ 11, &lt;code&gt;broken_promise&lt;/code&gt; se especific&amp;oacute; para que sea igual a cero a pesar de &lt;code&gt;&lt;a href=&quot;../error/error_code&quot;&gt;std::error_code&lt;/a&gt;&lt;/code&gt; / &lt;code&gt;&lt;a href=&quot;../error/error_condition&quot;&gt;std::error_condition&lt;/a&gt;&lt;/code&gt; usando cero para significar &quot;sin error&quot;. Esto se solucion&amp;oacute; en C ++ 14.</target>
        </trans-unit>
        <trans-unit id="c2a0733225045f42e4ffac4f7cced1fd8bd01edc" translate="yes" xml:space="preserve">
          <source>In C++11, expressions that:</source>
          <target state="translated">En C++11,las expresiones que:</target>
        </trans-unit>
        <trans-unit id="8a471ce8454b0c44c542d11c1ba3841025440979" translate="yes" xml:space="preserve">
          <source>In C++11, these constants were specified with redundant keyword &lt;code&gt;static&lt;/code&gt;, which was removed by C++14 via &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053&quot;&gt;LWG issue 2053&lt;/a&gt;.</source>
          <target state="translated">En C ++ 11, estas constantes se especificaron con palabras clave &lt;code&gt;static&lt;/code&gt; redundantes , que C ++ 14 elimin&amp;oacute; mediante el &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#2053&quot;&gt;problema 2053 de LWG&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="984160a3e04fdf728c84931473e5065db87d2de8" translate="yes" xml:space="preserve">
          <source>In C++17, &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; was made mandatory in some situations, and that required separation of prvalue expressions from the temporary objects initialized by them, resulting in the system we have today. Note that, in contrast with the C++11 scheme, prvalues are no longer moved from.</source>
          <target state="translated">En C ++ 17, la &lt;a href=&quot;copy_elision&quot;&gt;elisi&amp;oacute;n de copia&lt;/a&gt; se hizo obligatoria en algunas situaciones, y eso requer&amp;iacute;a la separaci&amp;oacute;n de las expresiones prvalue de los objetos temporales inicializados por ellas, lo que resulta en el sistema que tenemos hoy. Tenga en cuenta que, en contraste con el esquema C ++ 11, los valores ya no se mueven.</target>
        </trans-unit>
        <trans-unit id="4f1bbad23b5985f92e8fd5da90bac9e6e27f0dfa" translate="yes" xml:space="preserve">
          <source>In C++98 prior to C++03 (which introduced value initialization), the expression &lt;code&gt;new T()&lt;/code&gt; was classified as default initialization and specified zero-initialization.</source>
          <target state="translated">En C ++ 98 anterior a C ++ 03 (que introdujo la inicializaci&amp;oacute;n del valor), la expresi&amp;oacute;n &lt;code&gt;new T()&lt;/code&gt; se clasific&amp;oacute; como inicializaci&amp;oacute;n predeterminada y especific&amp;oacute; cero inicializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9476240519883d62813958bad1862fa3943959d8" translate="yes" xml:space="preserve">
          <source>In C++98/C++03, if an error occurs, &lt;code&gt;v&lt;/code&gt; is left unchanged. In C++11, it is set to a value as described above.</source>
          <target state="translated">En C ++ 98 / C ++ 03, si se produce un error, &lt;code&gt;v&lt;/code&gt; no se modifica. En C ++ 11, se establece en un valor como se describe anteriormente.</target>
        </trans-unit>
        <trans-unit id="5a00b4bd83d09e5862a084a0513a75ec121bbf2e" translate="yes" xml:space="preserve">
          <source>In C, &lt;code&gt;putc()&lt;/code&gt; may be implemented as a macro, which is disallowed in C++. Therefore calls to &lt;code&gt;std::fputc()&lt;/code&gt; and &lt;code&gt;std::putc()&lt;/code&gt; always have the same effect.</source>
          <target state="translated">En C, &lt;code&gt;putc()&lt;/code&gt; puede implementarse como una macro, que no est&amp;aacute; permitida en C ++. Por lo tanto, las llamadas a &lt;code&gt;std::fputc()&lt;/code&gt; y &lt;code&gt;std::putc()&lt;/code&gt; siempre tienen el mismo efecto.</target>
        </trans-unit>
        <trans-unit id="cf9734438af23c6dfb132972af4a721d26ce5a2e" translate="yes" xml:space="preserve">
          <source>In C, character array of size one less than the size of the string literal may be initialized from a string literal; the resulting array is not null-terminated. This is not allowed in C++.</source>
          <target state="translated">En C,la matriz de caracteres de tamaño uno menor que el tamaño del literal de la cadena puede inicializarse a partir de un literal de la cadena;la matriz resultante no se anula.Esto no está permitido en C++.</target>
        </trans-unit>
        <trans-unit id="38e0a2f5a0dd182661a588f644d0e761c91db444" translate="yes" xml:space="preserve">
          <source>In C, character constants such as &lt;code&gt;'a'&lt;/code&gt; or &lt;code&gt;'\n'&lt;/code&gt; have type &lt;code&gt;int&lt;/code&gt;, rather than &lt;code&gt;char&lt;/code&gt;.</source>
          <target state="translated">En C, las constantes de caracteres como &lt;code&gt;'a'&lt;/code&gt; o &lt;code&gt;'\n'&lt;/code&gt; tienen el tipo &lt;code&gt;int&lt;/code&gt; , en lugar de &lt;code&gt;char&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c022ffe44f1e1cb8c1253d8ca27c1f6f5d7901e9" translate="yes" xml:space="preserve">
          <source>In C, inline functions do not have to be declared inline in every translation unit (at most one may be non-inline or extern inline), the function definitions do not have to be identical (but the behavior of the program must not depend on which one is called), and the function-local statics are distinct between different definitions of the same function.</source>
          <target state="translated">En C,las funciones en línea no tienen que ser declaradas en línea en cada unidad de traducción (a lo sumo una puede ser no en línea o externa en línea),las definiciones de las funciones no tienen que ser idénticas (pero el comportamiento del programa no debe depender de cuál se llame),y la estática de la función local es distinta entre las diferentes definiciones de la misma función.</target>
        </trans-unit>
        <trans-unit id="c2835e1b41b93ce6d5849cf55c8cf7a0e81c4f48" translate="yes" xml:space="preserve">
          <source>In C, string literals are of type &lt;code&gt;char[]&lt;/code&gt;, and can be assigned directly to a (non-const) &lt;code&gt;char*&lt;/code&gt;. C++03 allowed it as well (but deprecated it, as literals are &lt;code&gt;const&lt;/code&gt; in C++). C++11 no longer allows such assignments without a cast.</source>
          <target state="translated">En C, los literales de cadena son del tipo &lt;code&gt;char[]&lt;/code&gt; , y se pueden asignar directamente a un &lt;code&gt;char*&lt;/code&gt; (no const) . C ++ 03 tambi&amp;eacute;n lo permiti&amp;oacute; (pero lo desaprob&amp;oacute;, ya que los literales son &lt;code&gt;const&lt;/code&gt; antes en C ++). C ++ 11 ya no permite tales asignaciones sin un yeso.</target>
        </trans-unit>
        <trans-unit id="2ab9e9edb5ce53cff5c0a794854dbeaa98df7eba" translate="yes" xml:space="preserve">
          <source>In C, the address of a &lt;code&gt;register&lt;/code&gt; variable cannot be taken, but in C++, a variable declared &lt;code&gt;register&lt;/code&gt; is semantically indistinguishable from a variable declared without any storage class specifiers.</source>
          <target state="translated">En C, la direcci&amp;oacute;n de una variable de &lt;code&gt;register&lt;/code&gt; no se puede tomar, pero en C ++, un &lt;code&gt;register&lt;/code&gt; declarado variable es indistinguible sem&amp;aacute;nticamente de una variable declarada sin ning&amp;uacute;n especificador de clase de almacenamiento.</target>
        </trans-unit>
        <trans-unit id="c82c0f1785717e06dc6cfec64c1ec49afdff6848" translate="yes" xml:space="preserve">
          <source>In C, the macro &lt;code&gt;NULL&lt;/code&gt; may have the type &lt;code&gt;void*&lt;/code&gt;, but that is not allowed in C++.</source>
          <target state="translated">En C, la macro &lt;code&gt;NULL&lt;/code&gt; puede tener el tipo &lt;code&gt;void*&lt;/code&gt; , pero eso no est&amp;aacute; permitido en C ++.</target>
        </trans-unit>
        <trans-unit id="f0bfb9c61efe498d3321fdcd4f4cc72588b7c2a9" translate="yes" xml:space="preserve">
          <source>In C, the ternary conditional operator has higher precedence than assignment operators. Therefore, the expression &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt;, which is parsed in C++ as &lt;code&gt;e = ((a &amp;lt; d) ? (a++) : (a = d))&lt;/code&gt;, will fail to compile in C due to grammatical or semantic constraints in C. See the corresponding C page for details.</source>
          <target state="translated">En C, el operador condicional ternario tiene mayor prioridad que los operadores de asignaci&amp;oacute;n. Por lo tanto, la expresi&amp;oacute;n &lt;code&gt;e = a &amp;lt; d ? a++ : a = d&lt;/code&gt; , que se analiza en C ++ como &lt;code&gt;e = ((a &amp;lt; d) ? (a++) : (a = d))&lt;/code&gt; , no se compilar&amp;aacute; en C debido a restricciones gramaticales o sem&amp;aacute;nticas en C. Consulte las correspondientes C p&amp;aacute;gina para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="c59c494dc7b28d6f1ae3f3e1fba28d7c33f040e5" translate="yes" xml:space="preserve">
          <source>In IS0 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">En IS0 8601 las semanas comienzan con el lunes y la primera semana del año debe satisfacer los siguientes requisitos:</target>
        </trans-unit>
        <trans-unit id="c2409d0ab324438044b126d5eaae356ad25d17dc" translate="yes" xml:space="preserve">
          <source>In ISO 8601 weeks begin with Monday and the first week of the year must satisfy the following requirements:</source>
          <target state="translated">En ISO 8601 las semanas comienzan con el lunes y la primera semana del año debe satisfacer los siguientes requisitos:</target>
        </trans-unit>
        <trans-unit id="3f2df198c19b4d3aee57fa1d2f0a4c70b3d8c1de" translate="yes" xml:space="preserve">
          <source>In a</source>
          <target state="translated">En un</target>
        </trans-unit>
        <trans-unit id="0c962fc44a425f14d1e80539f2eadaa9d9481b53" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;class&lt;/code&gt; can be used to introduce &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt; type template parameters&lt;/a&gt; and &lt;a href=&quot;../language/template_parameters#Template_template_parameter&quot;&gt; template template parameters&lt;/a&gt;</source>
          <target state="translated">En una &lt;a href=&quot;../language/templates&quot;&gt;declaraci&amp;oacute;n de plantilla&lt;/a&gt; , la &lt;code&gt;class&lt;/code&gt; se puede usar para introducir &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;par&amp;aacute;metros de plantilla de tipo&lt;/a&gt; y par&amp;aacute;metros de &lt;a href=&quot;../language/template_parameters#Template_template_parameter&quot;&gt;plantilla de plantilla&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b62c4f9f476c687ff843ca517e75f7940028ba13" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;../language/templates&quot;&gt; template declaration&lt;/a&gt;, &lt;code&gt;typename&lt;/code&gt; can be used as an alternative to &lt;a href=&quot;class&quot;&gt; class&lt;/a&gt; to declare &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;type template parameters&lt;/a&gt;and template template parameters(since C++17).</source>
          <target state="translated">En una &lt;a href=&quot;../language/templates&quot;&gt;declaraci&amp;oacute;n de plantilla&lt;/a&gt; , &lt;code&gt;typename&lt;/code&gt; se puede usar como una alternativa a la &lt;a href=&quot;class&quot;&gt;clase&lt;/a&gt; para declarar &lt;a href=&quot;../language/template_parameters#Type_template_parameter&quot;&gt;par&amp;aacute;metros de plantilla de tipo&lt;/a&gt; y par&amp;aacute;metros de plantilla de plantilla (desde C ++ 17).</target>
        </trans-unit>
        <trans-unit id="6c62102a69b04462fa302dbc2df4626b43048568" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; declaration, it appears either immediately after the capture list, or immediately after the (keyword &lt;code&gt;mutable&lt;/code&gt; (if one is used).</source>
          <target state="translated">En una declaraci&amp;oacute;n &lt;a href=&quot;lambda&quot;&gt;lambda&lt;/a&gt; , aparece inmediatamente despu&amp;eacute;s de la lista de captura o inmediatamente despu&amp;eacute;s de la (palabra clave &lt;code&gt;mutable&lt;/code&gt; (si se usa una).</target>
        </trans-unit>
        <trans-unit id="e1d855aa75c086efbd816d762abc1c86bd8016f1" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type:</source>
          <target state="translated">En una &lt;a href=&quot;return&quot;&gt;declaraci&amp;oacute;n de retorno&lt;/a&gt; , cuando el operando es un &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; del mismo tipo de clase (ignorando &lt;a href=&quot;cv&quot;&gt;la calificaci&amp;oacute;n cv&lt;/a&gt; ) que el tipo de retorno de la funci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="177a6daaadac5e744a3c9483ebb25b9c5956b8d4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;return&quot;&gt;return statement&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and which is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the function return type. This variant of copy elision is known as NRVO, &quot;named return value optimization&quot;.</source>
          <target state="translated">En una &lt;a href=&quot;return&quot;&gt;declaraci&amp;oacute;n de devoluci&amp;oacute;n&lt;/a&gt; , cuando el operando es el nombre de un objeto no vol&amp;aacute;til con duraci&amp;oacute;n de almacenamiento autom&amp;aacute;tico, que no es un par&amp;aacute;metro de funci&amp;oacute;n o un par&amp;aacute;metro de cl&amp;aacute;usula catch, y que es del mismo tipo de clase (ignorando &lt;a href=&quot;cv&quot;&gt;la calificaci&amp;oacute;n cv&lt;/a&gt; ) como El tipo de retorno de funci&amp;oacute;n. Esta variante de copia de elisi&amp;oacute;n se conoce como NRVO, &quot;optimizaci&amp;oacute;n del valor de retorno denominado&quot;.</target>
        </trans-unit>
        <trans-unit id="fde11b27cc6006e08d96a8f3a53a33443f577fd4" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;throw&quot;&gt;throw-expression&lt;/a&gt;, when the operand is the name of a non-volatile object with automatic storage duration, which isn't a function parameter or a catch clause parameter, and whose scope does not extend past the innermost try-block (if there is a try-block).</source>
          <target state="translated">En una &lt;a href=&quot;throw&quot;&gt;expresi&amp;oacute;n de lanzamiento&lt;/a&gt; , cuando el operando es el nombre de un objeto no vol&amp;aacute;til con duraci&amp;oacute;n de almacenamiento autom&amp;aacute;tico, que no es un par&amp;aacute;metro de funci&amp;oacute;n o un par&amp;aacute;metro de cl&amp;aacute;usula catch, y cuyo alcance no se extiende m&amp;aacute;s all&amp;aacute; del bloque try m&amp;aacute;s interno (si hay un try-block).</target>
        </trans-unit>
        <trans-unit id="601aeec487cb6099c489a8b16b96b24dfb6cd755" translate="yes" xml:space="preserve">
          <source>In a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt;, when the argument is of the same type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the exception object thrown, the copy of the exception object is omitted and the body of the catch clause accesses the exception object directly, as if caught by reference (there cannot be a move from the exception object because it is always an lvalue). This is disabled if such copy elision would change the observable behavior of the program for any reason other than skipping the copy constructor and the destructor of the catch clause argument (for example, if the catch clause argument is modified, and the exception object is rethrown with &lt;code&gt;throw&lt;/code&gt;).</source>
          <target state="translated">En una &lt;a href=&quot;try_catch&quot;&gt;cl&amp;aacute;usula catch&lt;/a&gt; , cuando el argumento es del mismo tipo (ignorando &lt;a href=&quot;cv&quot;&gt;la calificaci&amp;oacute;n cv&lt;/a&gt; ) que el objeto de excepci&amp;oacute;n arrojado, se omite la copia del objeto de excepci&amp;oacute;n y el cuerpo de la cl&amp;aacute;usula catch accede directamente al objeto de excepci&amp;oacute;n, como si fuera capturado por referencia (no puede haber un movimiento desde el objeto de excepci&amp;oacute;n porque siempre es un valor l). Esto se deshabilita si dicha elisi&amp;oacute;n de copia cambiar&amp;iacute;a el comportamiento observable del programa por cualquier motivo que no sea omitir el constructor de copia y el destructor del argumento de la cl&amp;aacute;usula catch (por ejemplo, si se modifica el argumento de la cl&amp;aacute;usula catch y se vuelve a lanzar el objeto de excepci&amp;oacute;n con &lt;code&gt;throw&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="556d00127671f5f34cb70b7e4bc4f78905db67ff" translate="yes" xml:space="preserve">
          <source>In a base-specifier of a &lt;a href=&quot;derived_class&quot;&gt;derived class&lt;/a&gt; declaration, define the accessibility of inherited members of the subsequent base class.</source>
          <target state="translated">En un especificador base de una declaraci&amp;oacute;n de &lt;a href=&quot;derived_class&quot;&gt;clase derivada&lt;/a&gt; , defina la accesibilidad de los miembros heredados de la clase base posterior.</target>
        </trans-unit>
        <trans-unit id="02b565401cf5d5664e816543f1fd59c4e0eec827" translate="yes" xml:space="preserve">
          <source>In a class scope, the name of the current class is treated as if it were a public member name; this is called</source>
          <target state="translated">En el ámbito de una clase,el nombre de la clase actual se trata como si fuera un nombre de miembro público;se llama</target>
        </trans-unit>
        <trans-unit id="dd0fdaa3d2c6bc7e7e1f68aa336ca282ee91f5ee" translate="yes" xml:space="preserve">
          <source>In a class template, the injected-class-name can be used either as a template name that refers to the current template, or as a class name that refers to the current instantiation.</source>
          <target state="translated">En una plantilla de clase,el nombre de la clase inyectada puede utilizarse como un nombre de plantilla que se refiere a la plantilla actual,o como un nombre de clase que se refiere a la instanciación actual.</target>
        </trans-unit>
        <trans-unit id="44fa3b441a0dd74cd09577454cd3ff350af83aaa" translate="yes" xml:space="preserve">
          <source>In a comma expression &lt;code&gt;E1, E2&lt;/code&gt;, the expression &lt;code&gt;E1&lt;/code&gt; is evaluated, its result is &lt;a href=&quot;expressions#Discarded-value_expressions&quot;&gt;discarded&lt;/a&gt; (although if it has class type, it won't be destroyed &lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;until the end of the containing full expression&lt;/a&gt;), and its side effects are completed before evaluation of the expression &lt;code&gt;E2&lt;/code&gt; begins (note that a user-defined &lt;code&gt;operator,&lt;/code&gt; cannot guarantee sequencing)(until C++17).</source>
          <target state="translated">En una expresi&amp;oacute;n de coma &lt;code&gt;E1, E2&lt;/code&gt; , se eval&amp;uacute;a la expresi&amp;oacute;n &lt;code&gt;E1&lt;/code&gt; , se &lt;a href=&quot;expressions#Discarded-value_expressions&quot;&gt;descarta&lt;/a&gt; su resultado (aunque si tiene un tipo de clase, no se destruir&amp;aacute; &lt;a href=&quot;lifetime#Temporary_object_lifetime&quot;&gt;hasta el final de la expresi&amp;oacute;n completa que contiene&lt;/a&gt; ), y sus efectos secundarios se completan antes de la evaluaci&amp;oacute;n de la expresi&amp;oacute;n &lt;code&gt;E2&lt;/code&gt; comienza (tenga en cuenta que un &lt;code&gt;operator,&lt;/code&gt; definido por el usuario , no puede garantizar la secuencia) (hasta C ++ 17).</target>
        </trans-unit>
        <trans-unit id="6d39978f8296a8c3b0b3811afba0c562703be315" translate="yes" xml:space="preserve">
          <source>In a constexpr if statement, the value of condition must be a &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;contextually converted constant expression of type &lt;code&gt;bool&lt;/code&gt;&lt;/a&gt;. If the value is &lt;code&gt;true&lt;/code&gt;, then statement-false is discarded (if present), otherwise, statement-true is discarded.</source>
          <target state="translated">En una declaraci&amp;oacute;n constexpr if, el valor de la condici&amp;oacute;n debe ser una &lt;a href=&quot;constant_expression#Converted_constant_expression&quot;&gt;expresi&amp;oacute;n constante convertida contextualmente de tipo &lt;code&gt;bool&lt;/code&gt; &lt;/a&gt; . Si el valor es &lt;code&gt;true&lt;/code&gt; , se descarta el enunciado falso (si est&amp;aacute; presente); de lo contrario, se descarta el enunciado verdadero.</target>
        </trans-unit>
        <trans-unit id="ffa4404e890de02936df9088f71b377c51dc866e" translate="yes" xml:space="preserve">
          <source>In a declaration or a definition of a template, including alias template, a name that is not a member of the</source>
          <target state="translated">En una declaración o definición de una plantilla,incluida la plantilla de alias,un nombre que no sea miembro de la</target>
        </trans-unit>
        <trans-unit id="0d44582f7d0710a8597f720797b494b72912bece" translate="yes" xml:space="preserve">
          <source>In a function declaration, after a parameter with a default argument, all subsequent parameters must.</source>
          <target state="translated">En una declaración de función,después de un parámetro con un argumento por defecto,todos los parámetros posteriores deben.</target>
        </trans-unit>
        <trans-unit id="29bba75b946ab8a0a1465e021f70b5a3cf77b940" translate="yes" xml:space="preserve">
          <source>In a function parameter list, if an ellipsis appears in a parameter declaration (whether it names a function parameter pack (as in, Args&lt;code&gt;...&lt;/code&gt;args) or not) the parameter declaration is the pattern:</source>
          <target state="translated">En una lista de par&amp;aacute;metros de funciones, si aparece una elipsis en una declaraci&amp;oacute;n de par&amp;aacute;metros (ya sea que nombre un paquete de par&amp;aacute;metros de funciones (como en Args &lt;code&gt;...&lt;/code&gt; args) o no), la declaraci&amp;oacute;n de par&amp;aacute;metros es el patr&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="ff38e5d5bc4cb779e7363c8977789202cfec1e6e" translate="yes" xml:space="preserve">
          <source>In a function returning &lt;code&gt;void&lt;/code&gt;, the return statement with expression can be used, if the expression type is &lt;code&gt;void&lt;/code&gt;.</source>
          <target state="translated">En una funci&amp;oacute;n que devuelve &lt;code&gt;void&lt;/code&gt; , se puede usar la declaraci&amp;oacute;n return con expresi&amp;oacute;n si el tipo de expresi&amp;oacute;n es &lt;code&gt;void&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9aa7f5d4e2a651b7a8c4283d212b044b1deb7ca" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;mutex&quot;&gt;&lt;code&gt;mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;timed_mutex&lt;/code&gt; offers exclusive, non-recursive ownership semantics. In addition, &lt;code&gt;timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">De manera similar a &lt;a href=&quot;mutex&quot;&gt; &lt;code&gt;mutex&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;timed_mutex&lt;/code&gt; ofrece una sem&amp;aacute;ntica de propiedad exclusiva y no recursiva. Adem&amp;aacute;s, &lt;code&gt;timed_mutex&lt;/code&gt; proporciona la capacidad de intentar reclamar la propiedad de un &lt;code&gt;timed_mutex&lt;/code&gt; con un tiempo de espera a trav&amp;eacute;s de los &lt;a href=&quot;timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for()&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a105c84562cad718ddfbcbaeae2b0d01a57bb6a5" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;a href=&quot;timed_mutex&quot;&gt;&lt;code&gt;timed_mutex&lt;/code&gt;&lt;/a&gt;, &lt;code&gt;shared_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;shared_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;shared_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_for&quot;&gt;&lt;code&gt;try_lock_shared_for()&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;shared_timed_mutex/try_lock_shared_until&quot;&gt;&lt;code&gt;try_lock_shared_until()&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">De manera similar a &lt;a href=&quot;timed_mutex&quot;&gt; &lt;code&gt;timed_mutex&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;shared_timed_mutex&lt;/code&gt; proporciona la capacidad de intentar reclamar la propiedad de &lt;code&gt;shared_timed_mutex&lt;/code&gt; con un tiempo de espera a trav&amp;eacute;s de los &lt;a href=&quot;shared_timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;shared_timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;shared_timed_mutex/try_lock_shared_for&quot;&gt; &lt;code&gt;try_lock_shared_for()&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;shared_timed_mutex/try_lock_shared_until&quot;&gt; &lt;code&gt;try_lock_shared_until()&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="73ef1571fcba32d6299f7cfb10f71f4b33622399" translate="yes" xml:space="preserve">
          <source>In a manner similar to &lt;code&gt;&lt;a href=&quot;recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides exclusive, recursive ownership semantics. In addition, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; provides the ability to attempt to claim ownership of a &lt;code&gt;recursive_timed_mutex&lt;/code&gt; with a timeout via the &lt;a href=&quot;recursive_timed_mutex/try_lock_for&quot;&gt;&lt;code&gt;try_lock_for&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;recursive_timed_mutex/try_lock_until&quot;&gt;&lt;code&gt;try_lock_until&lt;/code&gt;&lt;/a&gt; methods.</source>
          <target state="translated">De manera similar a &lt;code&gt;&lt;a href=&quot;recursive_mutex&quot;&gt;std::recursive_mutex&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;recursive_timed_mutex&lt;/code&gt; proporciona una sem&amp;aacute;ntica de propiedad exclusiva y recursiva. Adem&amp;aacute;s, &lt;code&gt;recursive_timed_mutex&lt;/code&gt; proporciona la capacidad de intentar reclamar la propiedad de un &lt;code&gt;recursive_timed_mutex&lt;/code&gt; con un tiempo de espera a trav&amp;eacute;s de los m&amp;eacute;todos &lt;a href=&quot;recursive_timed_mutex/try_lock_for&quot;&gt; &lt;code&gt;try_lock_for&lt;/code&gt; &lt;/a&gt; y &lt;a href=&quot;recursive_timed_mutex/try_lock_until&quot;&gt; &lt;code&gt;try_lock_until&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6849ef8c2becfa3fc06c88b17ac43d2f4c411e40" translate="yes" xml:space="preserve">
          <source>In a member function declaration or definition, &lt;code&gt;override&lt;/code&gt; ensures that the function is virtual and is overriding a virtual function from a base class. The program is ill-formed (a compile-time error is generated) if this is not true.</source>
          <target state="translated">En una declaraci&amp;oacute;n o definici&amp;oacute;n de funci&amp;oacute;n miembro, la &lt;code&gt;override&lt;/code&gt; asegura que la funci&amp;oacute;n es virtual y anula una funci&amp;oacute;n virtual de una clase base. El programa est&amp;aacute; mal formado (se genera un error en tiempo de compilaci&amp;oacute;n) si esto no es cierto.</target>
        </trans-unit>
        <trans-unit id="e4f5d5b55ed5d6a1476b0d473859397b31a64db5" translate="yes" xml:space="preserve">
          <source>In a member-specification of a &lt;a href=&quot;class&quot;&gt;class/struct&lt;/a&gt; or &lt;a href=&quot;union&quot;&gt;union&lt;/a&gt;, define the accessibility of subsequent members.</source>
          <target state="translated">En una especificaci&amp;oacute;n de miembro de una &lt;a href=&quot;class&quot;&gt;clase / estructura&lt;/a&gt; o &lt;a href=&quot;union&quot;&gt;uni&amp;oacute;n&lt;/a&gt; , defina la accesibilidad de los miembros posteriores.</target>
        </trans-unit>
        <trans-unit id="94c1a387b407acb6d65fdcd502fe4af3873221a8" translate="yes" xml:space="preserve">
          <source>In a primary class template, the template parameter pack must be the final parameter in the template parameter list. In a function template, the template parameter pack may appear earlier in the list provided that all following parameters can be deduced from the function arguments, or have default arguments:</source>
          <target state="translated">En una plantilla de clase primaria,el paquete de parámetros de la plantilla debe ser el parámetro final en la lista de parámetros de la plantilla.En un modelo de función,el paquete de parámetros del modelo puede aparecer antes en la lista siempre que todos los parámetros siguientes puedan deducirse de los argumentos de la función o tengan argumentos por defecto:</target>
        </trans-unit>
        <trans-unit id="1d0f0e8e5fc7ee584cfdd9cc8db60b33727fe5d0" translate="yes" xml:space="preserve">
          <source>In a qualified name &lt;code&gt;C::D&lt;/code&gt;, if.</source>
          <target state="translated">En un nombre calificado &lt;code&gt;C::D&lt;/code&gt; , si.</target>
        </trans-unit>
        <trans-unit id="72a217ab1ac4987acb0fd819dc67e7faf17facb8" translate="yes" xml:space="preserve">
          <source>In a return statement or a throw-expression, if the compiler cannot perform copy elision but the conditions for copy elision are met or would be met, except that the source is a function parameter, the compiler will attempt to use the move constructor even if the object is designated by an lvalue; see &lt;a href=&quot;return#Notes&quot;&gt;return statement&lt;/a&gt; for details.</source>
          <target state="translated">En una declaraci&amp;oacute;n de retorno o una expresi&amp;oacute;n de lanzamiento, si el compilador no puede realizar la elisi&amp;oacute;n de copia pero se cumplen o se cumplir&amp;iacute;an las condiciones para la elisi&amp;oacute;n de copia, excepto que la fuente es un par&amp;aacute;metro de funci&amp;oacute;n, el compilador intentar&amp;aacute; usar el constructor de movimiento incluso si el objeto est&amp;aacute; designado por un valor l; vea la &lt;a href=&quot;return#Notes&quot;&gt;declaraci&amp;oacute;n de devoluci&amp;oacute;n&lt;/a&gt; para m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="cb9d44c1145d9374305ce7d0683c7666a1a8faf1" translate="yes" xml:space="preserve">
          <source>In a standard-layout union with an active member of non-union class type &lt;code&gt;T1&lt;/code&gt;, it is permitted to read a non-static data member &lt;code&gt;m&lt;/code&gt; of another union member of non-union class type &lt;code&gt;T2&lt;/code&gt; provided &lt;code&gt;m&lt;/code&gt; is part of the common initial sequence of &lt;code&gt;T1&lt;/code&gt; and &lt;code&gt;T2&lt;/code&gt; (except that reading a volatile member through non-volatile glvalue is undefined).</source>
          <target state="translated">En una uni&amp;oacute;n de dise&amp;ntilde;o est&amp;aacute;ndar con un miembro activo de la clase no sindical tipo &lt;code&gt;T1&lt;/code&gt; , se permite leer un miembro de datos no est&amp;aacute;tico &lt;code&gt;m&lt;/code&gt; de otro miembro sindical de la clase no sindical tipo &lt;code&gt;T2&lt;/code&gt; siempre que &lt;code&gt;m&lt;/code&gt; sea ​​parte de la secuencia inicial com&amp;uacute;n de &lt;code&gt;T1&lt;/code&gt; y &lt;code&gt;T2&lt;/code&gt; (excepto que la lectura de un miembro vol&amp;aacute;til a trav&amp;eacute;s de un valor de gl no vol&amp;aacute;til no est&amp;aacute; definida).</target>
        </trans-unit>
        <trans-unit id="57d94135b1f4411284cd0b70dd280cd47ea7b667" translate="yes" xml:space="preserve">
          <source>In a typical implementation, &lt;code&gt;std::shared_ptr&lt;/code&gt; holds only two pointers:</source>
          <target state="translated">En una implementaci&amp;oacute;n t&amp;iacute;pica, &lt;code&gt;std::shared_ptr&lt;/code&gt; contiene solo dos punteros:</target>
        </trans-unit>
        <trans-unit id="302df27cb656ad4b16b22d1abb7ca751d6dcd20f" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostream_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_ostream&lt;/code&gt; and a pointer to the first character in the delimiter string.</source>
          <target state="translated">En una implementaci&amp;oacute;n t&amp;iacute;pica, los &amp;uacute;nicos miembros de datos de &lt;code&gt;std::ostream_iterator&lt;/code&gt; son un puntero al &lt;code&gt;std::basic_ostream&lt;/code&gt; asociado y un puntero al primer car&amp;aacute;cter en la cadena delimitador.</target>
        </trans-unit>
        <trans-unit id="28d88a36238effdebec563fabaf3d6addb51154c" translate="yes" xml:space="preserve">
          <source>In a typical implementation, the only data members of &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; are a pointer to the associated &lt;code&gt;std::basic_streambuf&lt;/code&gt; and a boolean flag indicating if the the end of file condition has been reached.</source>
          <target state="translated">En una implementaci&amp;oacute;n t&amp;iacute;pica, los &amp;uacute;nicos miembros de datos de &lt;code&gt;std::ostreambuf_iterator&lt;/code&gt; son un puntero al &lt;code&gt;std::basic_streambuf&lt;/code&gt; asociado y un indicador booleano que indica si se ha alcanzado el final de la condici&amp;oacute;n del archivo.</target>
        </trans-unit>
        <trans-unit id="cf627f59eb9ce680a79832f3ab2b75fd54c9e5dc" translate="yes" xml:space="preserve">
          <source>In a valid C++ program, every thread eventually does one of the following:</source>
          <target state="translated">En un programa C++válido,cada hilo eventualmente hace una de las siguientes cosas:</target>
        </trans-unit>
        <trans-unit id="5fae65e7ec13a45d7642866607e117019083d5bd" translate="yes" xml:space="preserve">
          <source>In addition to being available via inclusion of the &amp;lt;tuple&amp;gt; header, the templates (3-5) are available when either of the headers &amp;lt;array&amp;gt; or &amp;lt;utility&amp;gt; are included.</source>
          <target state="translated">Adem&amp;aacute;s de estar disponibles mediante la inclusi&amp;oacute;n del encabezado &amp;lt;tuple&amp;gt;, las plantillas (3-5) est&amp;aacute;n disponibles cuando se incluyen cualquiera de los encabezados &amp;lt;array&amp;gt; o &amp;lt;utility&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="15c8d22eeeed9e3926980c7851a1d6015cd58fda" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::begin&lt;/code&gt; and &lt;code&gt;std::cbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de incluirse en &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , se garantiza que &lt;code&gt;std::begin&lt;/code&gt; y &lt;code&gt;std::cbegin&lt;/code&gt; estar&amp;aacute;n disponibles si se incluye alguno de los siguientes encabezados: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (desde C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (desde C ++ 17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; , y &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="338a7c84c19f8a1e820335032a79e38ce0602216" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::data&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de estar incluido en &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , se garantiza que &lt;code&gt;std::data&lt;/code&gt; estar&amp;aacute; disponible si se incluye alguno de los siguientes encabezados: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (desde C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; , y &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8ecedc3305486dab3dbe344b85d3d2b73a9d8eb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::empty&lt;/code&gt; is guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de estar incluido en &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , se garantiza que &lt;code&gt;std::empty&lt;/code&gt; estar&amp;aacute; disponible si se incluye alguno de los siguientes encabezados: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (desde C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; , y &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9360d86ce66685d75aa6a0b3e3f9a322ab2b75da" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::end&lt;/code&gt; and &lt;code&gt;std::cend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de incluirse en &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , se garantiza que &lt;code&gt;std::end&lt;/code&gt; y &lt;code&gt;std::cend&lt;/code&gt; estar&amp;aacute;n disponibles si se incluye alguno de los siguientes encabezados: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (desde C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (desde C ++ 17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; , y &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4a73cea37076402c9805971389b5c85fd80eb64" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rbegin&lt;/code&gt; and &lt;code&gt;std::crbegin&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de estar incluidos en &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , se garantiza que &lt;code&gt;std::rbegin&lt;/code&gt; y &lt;code&gt;std::crbegin&lt;/code&gt; estar&amp;aacute;n disponibles si se incluye alguno de los siguientes encabezados: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (desde C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (desde C ++ 17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; , y &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80150b5d7065d7588ce5758ee13c5f0c81f3d9cb" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::rend&lt;/code&gt; and &lt;code&gt;std::crend&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;(since C++17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de incluirse en &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , se garantiza que &lt;code&gt;std::rend&lt;/code&gt; y &lt;code&gt;std::crend&lt;/code&gt; estar&amp;aacute;n disponibles si se incluye alguno de los siguientes encabezados: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (desde C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; (desde C ++ 17), &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; , y &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ece481ac1f67deffb145ed3b4d4e6b31704b49ce" translate="yes" xml:space="preserve">
          <source>In addition to being included in &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt;, &lt;code&gt;std::size&lt;/code&gt; and &lt;code&gt;std::ssize&lt;/code&gt; are guaranteed to become available if any of the following headers are included: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt;(since C++20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt;, and &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de incluirse en &lt;code&gt;&amp;lt;iterator&amp;gt;&lt;/code&gt; , se garantiza que &lt;code&gt;std::size&lt;/code&gt; y &lt;code&gt;std::ssize&lt;/code&gt; estar&amp;aacute;n disponibles si se incluye alguno de los siguientes encabezados: &lt;code&gt;&amp;lt;array&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;deque&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;forward_list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;list&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;regex&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;set&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;span&amp;gt;&lt;/code&gt; (desde C ++ 20), &lt;code&gt;&amp;lt;string&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;string_view&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_map&amp;gt;&lt;/code&gt; , &lt;code&gt;&amp;lt;unordered_set&amp;gt;&lt;/code&gt; , y &lt;code&gt;&amp;lt;vector&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a875ba5ef1aeb5e5a529dc3dc7727bb4112f85b1" translate="yes" xml:space="preserve">
          <source>In addition to changing the file position indicator, &lt;code&gt;fseek&lt;/code&gt; undoes the effects of &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; and clears the end-of-file status, if applicable.</source>
          <target state="translated">Adem&amp;aacute;s de cambiar el indicador de posici&amp;oacute;n del archivo, &lt;code&gt;fseek&lt;/code&gt; deshace los efectos de &lt;code&gt;&lt;a href=&quot;ungetc&quot;&gt;std::ungetc&lt;/a&gt;&lt;/code&gt; y borra el estado del final del archivo, si corresponde.</target>
        </trans-unit>
        <trans-unit id="cf1188534c30ece32fd46ec4ab40935b4238d277" translate="yes" xml:space="preserve">
          <source>In addition to keywords, there are</source>
          <target state="translated">Además de las palabras clave,hay</target>
        </trans-unit>
        <trans-unit id="271348d0f95843d6de9b4a3bea7c7a4b2fb93975" translate="yes" xml:space="preserve">
          <source>In addition to sophisticated locale-dependent parsers and formatters provided by the &lt;a href=&quot;io&quot;&gt;C++ I/O&lt;/a&gt; library, the &lt;a href=&quot;io/c&quot;&gt;C I/O&lt;/a&gt; library, &lt;a href=&quot;string/basic_string#Numeric_conversions&quot;&gt;C++ string converters&lt;/a&gt;, and &lt;a href=&quot;string/byte#Conversions_to_numeric_formats&quot;&gt;C string converters&lt;/a&gt;, the header &lt;a href=&quot;header/charconv&quot;&gt;&lt;code&gt;&amp;lt;charconv&amp;gt;&lt;/code&gt;&lt;/a&gt; provides light-weight, locale-independent, non-allocating, non-throwing, ASCII-only parsers and formatters for arithmetic types.</source>
          <target state="translated">Adem&amp;aacute;s de los sofisticados analizadores y formateadores dependientes del entorno local proporcionados por la &lt;a href=&quot;io&quot;&gt;biblioteca de E / S C ++&lt;/a&gt; , la biblioteca de &lt;a href=&quot;io/c&quot;&gt;CI / O&lt;/a&gt; , &lt;a href=&quot;string/basic_string#Numeric_conversions&quot;&gt;los convertidores de cadena C ++&lt;/a&gt; y &lt;a href=&quot;string/byte#Conversions_to_numeric_formats&quot;&gt;los convertidores de cadena C&lt;/a&gt; , el encabezado &lt;a href=&quot;header/charconv&quot;&gt; &lt;code&gt;&amp;lt;charconv&amp;gt;&lt;/code&gt; &lt;/a&gt; proporciona un peso ligero, independiente del entorno, no asignar, no lanzar, analizadores y formateadores solo ASCII para tipos aritm&amp;eacute;ticos.</target>
        </trans-unit>
        <trans-unit id="792f40a7aa00c160ead2eca530fe86663d38f9ab" translate="yes" xml:space="preserve">
          <source>In addition to the above, the composite pointer type between pointer to function and pointer to noexcept function (as long as the function type is the same) is pointer to function.</source>
          <target state="translated">Además de lo anterior,el tipo de puntero compuesto entre el puntero a la función y el puntero a ninguna función (siempre que el tipo de función sea el mismo)es el puntero a la función.</target>
        </trans-unit>
        <trans-unit id="ae9ffad79cce78b91bc762e83fe3fface28c2158" translate="yes" xml:space="preserve">
          <source>In addition to the above, the standard library provides specializations for all (scoped and unscoped) enumeration types. These may be (but are not required to be) implemented as &lt;code&gt;std::hash&amp;lt;&lt;a href=&quot;../types/underlying_type&quot;&gt;std::underlying_type&lt;/a&gt;&amp;lt;Enum&amp;gt;::type&amp;gt;&lt;/code&gt;).</source>
          <target state="translated">Adem&amp;aacute;s de lo anterior, la biblioteca est&amp;aacute;ndar proporciona especializaciones para todos los tipos de enumeraci&amp;oacute;n (con y sin &amp;aacute;mbito). Estos pueden implementarse (pero no es obligatorio) como &lt;code&gt;std::hash&amp;lt;&lt;a href=&quot;../types/underlying_type&quot;&gt;std::underlying_type&lt;/a&gt;&amp;lt;Enum&amp;gt;::type&amp;gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="0d12b27afe84f919d4cf85c2c720f51dd78c7c47" translate="yes" xml:space="preserve">
          <source>In addition to the engines and distributions described above, the functions and constants from the C random library are also available though not recommended:</source>
          <target state="translated">Además de los motores y distribuciones descritos anteriormente,las funciones y constantes de la biblioteca aleatoria C también están disponibles,aunque no se recomiendan:</target>
        </trans-unit>
        <trans-unit id="d7885497c8e90724cd51455d17a67e9d4213e9e7" translate="yes" xml:space="preserve">
          <source>In addition to the use in collation, the implementation-specific format of the transformed string is known to &lt;a href=&quot;../../regex/regex_traits/transform_primary&quot;&gt;std::regex_traits&amp;lt;&amp;gt;::transform_primary&lt;/a&gt;, which is able to extract the equivalence class information.</source>
          <target state="translated">Adem&amp;aacute;s del uso en intercalaci&amp;oacute;n, el formato espec&amp;iacute;fico de implementaci&amp;oacute;n de la cadena transformada es conocido por &lt;a href=&quot;../../regex/regex_traits/transform_primary&quot;&gt;std :: regex_traits &amp;lt;&amp;gt; :: transform_primary&lt;/a&gt; , que puede extraer la informaci&amp;oacute;n de la clase de equivalencia.</target>
        </trans-unit>
        <trans-unit id="a698de81532c150ff1ad39e8d086bac28e3d07da" translate="yes" xml:space="preserve">
          <source>In addition, &lt;a href=&quot;bit_field&quot;&gt;bit field declarations&lt;/a&gt; are allowed.</source>
          <target state="translated">Adem&amp;aacute;s, se permiten &lt;a href=&quot;bit_field&quot;&gt;declaraciones de campo de bits&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4b8e054656c974f48dccf563843687d3cffa39b2" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; can be value-initialized to clear state with the expression &lt;code&gt;&lt;a href=&quot;../atomic_flag_init&quot;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt;. For an atomic_flag with static &lt;a href=&quot;../../language/storage_duration#Storage_duration&quot;&gt;storage duration&lt;/a&gt;, this guarantees &lt;a href=&quot;../../language/initialization#Static_initialization&quot;&gt;static initialization&lt;/a&gt;: the flag can be used in constructors of static objects.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;&lt;a href=&quot;../atomic_flag&quot;&gt;std::atomic_flag&lt;/a&gt;&lt;/code&gt; puede inicializarse en valores para borrar el estado con la expresi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;../atomic_flag_init&quot;&gt;ATOMIC_FLAG_INIT&lt;/a&gt;&lt;/code&gt; . Para un atomic_flag con &lt;a href=&quot;../../language/storage_duration#Storage_duration&quot;&gt;duraci&amp;oacute;n de almacenamiento&lt;/a&gt; est&amp;aacute;tico , esto garantiza &lt;a href=&quot;../../language/initialization#Static_initialization&quot;&gt;la inicializaci&amp;oacute;n est&amp;aacute;tica&lt;/a&gt; : la bandera se puede usar en constructores de objetos est&amp;aacute;ticos.</target>
        </trans-unit>
        <trans-unit id="7f193d95fb5f81fb5974342efbdfb55ebd6bb874" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;std::cerr.tie()&lt;/code&gt; returns &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; (same for &lt;code&gt;wcerr&lt;/code&gt; and &lt;code&gt;wcout&lt;/code&gt;), meaning that any output operation on &lt;code&gt;std::cerr&lt;/code&gt; first executes &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; (via &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt;'s constructor) (since C++11).</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;std::cerr.tie()&lt;/code&gt; devuelve &lt;code&gt;&amp;amp;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;&lt;/code&gt; (lo mismo para &lt;code&gt;wcerr&lt;/code&gt; y &lt;code&gt;wcout&lt;/code&gt; ), lo que significa que cualquier operaci&amp;oacute;n de salida en &lt;code&gt;std::cerr&lt;/code&gt; primero ejecuta &lt;code&gt;&lt;a href=&quot;cout&quot;&gt;std::cout&lt;/a&gt;.flush()&lt;/code&gt; (a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;basic_ostream/sentry&quot;&gt;std::basic_ostream::sentry&lt;/a&gt;&lt;/code&gt; constructor de centinela ) (desde C ++ 11).</target>
        </trans-unit>
        <trans-unit id="fa95bff2b2f1d155be7f57dab28372be4d7eb068" translate="yes" xml:space="preserve">
          <source>In addition, C-style cast notation is allowed to cast from, to, and between pointers to incomplete class type. If both expression and new_type are pointers to incomplete class types, it's unspecified whether static_cast or reinterpret_cast gets selected.</source>
          <target state="translated">Además,se permite que la notación de reparto de estilo C se lance desde,hacia y entre los punteros hasta el tipo de clase incompleta.Si tanto la expresión como new_type son punteros a tipos de clase incompletos,no se especifica si se selecciona static_cast o reinterpret_cast.</target>
        </trans-unit>
        <trans-unit id="ce46012134e55d98fb6c46e02b9a75f51edf17ba" translate="yes" xml:space="preserve">
          <source>In addition, a typical implementation holds a data member of type &lt;code&gt;&lt;a href=&quot;ios_base/openmode&quot;&gt;std::ios_base::openmode&lt;/a&gt;&lt;/code&gt; to indicate the status of the stream (input-only, output-only, input/output, at-end, etc).</source>
          <target state="translated">Adem&amp;aacute;s, una implementaci&amp;oacute;n t&amp;iacute;pica contiene un miembro de datos de tipo &lt;code&gt;&lt;a href=&quot;ios_base/openmode&quot;&gt;std::ios_base::openmode&lt;/a&gt;&lt;/code&gt; para indicar el estado de la secuencia (solo entrada, solo salida, entrada / salida, al final, etc.).</target>
        </trans-unit>
        <trans-unit id="f488b539106ae565b1a7adaef610b9d6be03b1fa" translate="yes" xml:space="preserve">
          <source>In addition, a value-initialized object of the type must produce a null value of that type. This null value shall only be equivalent to itself. Default initialization of the type may have an indeterminate value.</source>
          <target state="translated">Además,un objeto de valor inicial del tipo debe producir un valor nulo de ese tipo.Este valor nulo sólo será equivalente a sí mismo.La inicialización por defecto del tipo puede tener un valor indeterminado.</target>
        </trans-unit>
        <trans-unit id="7a8db860cf41b64de062e0a8128719f25222688f" translate="yes" xml:space="preserve">
          <source>In addition, accesses to atomic objects may establish inter-thread synchronization and order non-atomic memory accesses as specified by &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, los accesos a objetos at&amp;oacute;micos pueden establecer una sincronizaci&amp;oacute;n entre subprocesos y ordenar accesos a la memoria no at&amp;oacute;mica seg&amp;uacute;n lo especificado por &lt;code&gt;&lt;a href=&quot;memory_order&quot;&gt;std::memory_order&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15638d0e65e84f9a793f46e162b9a6f8ac56803a" translate="yes" xml:space="preserve">
          <source>In addition, all names declared in &lt;a href=&quot;namespace&quot;&gt;unnamed namespace&lt;/a&gt; or a namespace within an unnamed namespace, even ones explicitly declared &lt;code&gt;extern&lt;/code&gt;, have internal linkage.</source>
          <target state="translated">Adem&amp;aacute;s, todos los nombres declarados en un espacio de &lt;a href=&quot;namespace&quot;&gt;nombres sin nombre&lt;/a&gt; o un espacio de nombres dentro de un espacio de nombres sin nombre, incluso aquellos declarados expl&amp;iacute;citamente como &lt;code&gt;extern&lt;/code&gt; os , tienen un enlace interno.</target>
        </trans-unit>
        <trans-unit id="49487efebaebbb07ca06e7cb34f9dc3b236bdf9b" translate="yes" xml:space="preserve">
          <source>In addition, evaluation of that expression is not allowed to call non-const member functions of the dereferenced iterators.</source>
          <target state="translated">Además,no se permite que la evaluación de esa expresión llame a las funciones de los miembros no conformes de los iteradores no referenciados.</target>
        </trans-unit>
        <trans-unit id="ff0e19edf9941c628d63cc46fd91d50b5ee3522e" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these four specializations.</source>
          <target state="translated">Además,cada objeto local construido en un programa de C++implementa sus propias versiones (específicas de la localidad)de estas cuatro especializaciones.</target>
        </trans-unit>
        <trans-unit id="34a1ac7c8b7c33c94bfab7f6061398698b960b4f" translate="yes" xml:space="preserve">
          <source>In addition, every locale object constructed in a C++ program implements its own (locale-specific) versions of these specializations.</source>
          <target state="translated">Además,cada objeto local construido en un programa de C++implementa sus propias versiones (específicas de la localidad)de estas especializaciones.</target>
        </trans-unit>
        <trans-unit id="d46580f66bb3168b2878f24c3024ecea21ce496c" translate="yes" xml:space="preserve">
          <source>In addition, for each class template &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; declared in this header, &lt;code&gt;std::&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; and &lt;code&gt;std::w&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; are declared as a synonym of &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;char&amp;gt;&lt;/code&gt; and &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; respectively.</source>
          <target state="translated">Adem&amp;aacute;s, para cada plantilla de clase &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; declarada en este encabezado, &lt;code&gt;std::&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; y &lt;code&gt;std::w&lt;i&gt;T&lt;/i&gt;&lt;/code&gt; se declaran como sin&amp;oacute;nimos de &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;char&amp;gt;&lt;/code&gt; y &lt;code&gt;std::basic_&lt;i&gt;T&lt;/i&gt;&amp;lt;wchar_t&amp;gt;&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="5d1d9f9e3417a73b82b4272cc321a2469fc45949" translate="yes" xml:space="preserve">
          <source>In addition, if the lvalue is of volatile-qualified class type, a volatile copy-constructor is required to initialize the resulting rvalue temporary.</source>
          <target state="translated">Además,si el valor l es de un tipo de clase calificado como volátil,se requiere un constructor de copias volátil para inicializar el valor r resultante temporalmente.</target>
        </trans-unit>
        <trans-unit id="9ce4f9734cf334aa096d562134cd27bb864fe82d" translate="yes" xml:space="preserve">
          <source>In addition, implementations are allowed to:</source>
          <target state="translated">Además,se permiten las implementaciones:</target>
        </trans-unit>
        <trans-unit id="6fca944845bc26e72a63f6ee2aaf3fc85bb418c7" translate="yes" xml:space="preserve">
          <source>In addition, it's undefined behavior to #define or #undef names identical to &lt;a href=&quot;../keywords&quot;&gt;keywords&lt;/a&gt;. If at least one standard library header is included, it's undefined behavior to #define or #undef identifiers identical to names declared in any standard library header.</source>
          <target state="translated">Adem&amp;aacute;s, es un comportamiento indefinido para #definir o #undef nombres id&amp;eacute;nticos a las &lt;a href=&quot;../keywords&quot;&gt;palabras clave&lt;/a&gt; . Si se incluye al menos un encabezado de biblioteca est&amp;aacute;ndar, es un comportamiento indefinido para #definir o #undef identificadores id&amp;eacute;nticos a los nombres declarados en cualquier encabezado de biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="9d2f44e82fedbe71cbece0ffe227d0a0158a8b14" translate="yes" xml:space="preserve">
          <source>In addition, many &lt;a href=&quot;../types&quot;&gt;type traits&lt;/a&gt; are implemented using SFINAE.</source>
          <target state="translated">Adem&amp;aacute;s, muchos &lt;a href=&quot;../types&quot;&gt;rasgos de tipo&lt;/a&gt; se implementan utilizando SFINAE.</target>
        </trans-unit>
        <trans-unit id="e92c1e872be57b036dbc2507bb5706e7b76dcd09" translate="yes" xml:space="preserve">
          <source>In addition, member and non-member functions are provided to support the following operations:</source>
          <target state="translated">Además,se proporcionan funciones de miembro y no miembro para apoyar las siguientes operaciones:</target>
        </trans-unit>
        <trans-unit id="89093684fff07258cc05ff168ca489272759c61f" translate="yes" xml:space="preserve">
          <source>In addition, so-called</source>
          <target state="translated">Además,el llamado</target>
        </trans-unit>
        <trans-unit id="29000479e98fa4979896c6eb46f598587861c215" translate="yes" xml:space="preserve">
          <source>In addition, synchronized C++ streams are guaranteed to be thread-safe (individual characters output from multiple threads may interleave, but no data races occur).</source>
          <target state="translated">Además,se garantiza que los flujos sincronizados de C++son seguros para los hilos (los caracteres individuales que salen de múltiples hilos pueden intercalarse,pero no se producen carreras de datos).</target>
        </trans-unit>
        <trans-unit id="5fea8ea2966b10c7537944404433308f3b7b4ff6" translate="yes" xml:space="preserve">
          <source>In addition, the following standard library facilities accept any Callable type (not just &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt;).</source>
          <target state="translated">Adem&amp;aacute;s, las siguientes instalaciones de biblioteca est&amp;aacute;ndar aceptan cualquier tipo invocable (no solo &lt;a href=&quot;functionobject&quot;&gt;FunctionObject&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="6c22d022938dfbf51f3ef71122c0c58581f4ff83" translate="yes" xml:space="preserve">
          <source>In addition, the implicit conversion in copy-initialization must produce &lt;code&gt;T&lt;/code&gt; directly from the initializer, while, e.g. direct-initialization expects an implicit conversion from the initializer to an argument of &lt;code&gt;T&lt;/code&gt;'s constructor.</source>
          <target state="translated">Adem&amp;aacute;s, la conversi&amp;oacute;n impl&amp;iacute;cita en la inicializaci&amp;oacute;n de copia debe producir &lt;code&gt;T&lt;/code&gt; directamente desde el inicializador, mientras que, por ejemplo, la inicializaci&amp;oacute;n directa espera una conversi&amp;oacute;n impl&amp;iacute;cita desde el inicializador a un argumento del constructor de &lt;code&gt;T&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92a67045a12eca5e07b1c4404b9093c3441f456c" translate="yes" xml:space="preserve">
          <source>In addition, the standard exception types &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../overflow_error/overflow_error&quot;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../underflow_error/underflow_error&quot;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../../regex/regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; are derived from &lt;code&gt;std::runtime_error&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, los tipos de excepci&amp;oacute;n est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;../range_error/range_error&quot;&gt;std::range_error&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../overflow_error/overflow_error&quot;&gt;std::overflow_error&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../underflow_error/underflow_error&quot;&gt;std::underflow_error&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../../regex/regex_error&quot;&gt;std::regex_error&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../system_error&quot;&gt;std::system_error&lt;/a&gt;&lt;/code&gt; se derivan de &lt;code&gt;std::runtime_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46ca753eadbc6e64c330f063c04cf76079373fe6" translate="yes" xml:space="preserve">
          <source>In addition, the standard library offers several RAII wrappers to manage user-provided resources:</source>
          <target state="translated">Además,la biblioteca estándar ofrece varios envoltorios RAII para gestionar los recursos proporcionados por los usuarios:</target>
        </trans-unit>
        <trans-unit id="891107f99b45712dab34dbd0d5adc64b629b07b9" translate="yes" xml:space="preserve">
          <source>In addition, two function templates are</source>
          <target state="translated">Además,hay dos plantillas de funciones</target>
        </trans-unit>
        <trans-unit id="ff24fd16f36ec6c36c829ad13c5fdc98ceb02332" translate="yes" xml:space="preserve">
          <source>In addition, unparenthesized type is greedy: it will include every token that can be a part of a declarator:</source>
          <target state="translated">Además,el tipo sin paréntesis es codicioso:incluirá todas las fichas que puedan formar parte de un declarante:</target>
        </trans-unit>
        <trans-unit id="33a1d90854c6b62d20682a431d3deb3e352e1570" translate="yes" xml:space="preserve">
          <source>In addition, volatile accesses are not atomic (concurrent read and write is a &lt;a href=&quot;../language/memory_model&quot;&gt;data race&lt;/a&gt;) and do not order memory (non-volatile memory accesses may be freely reordered around the volatile access).</source>
          <target state="translated">Adem&amp;aacute;s, los accesos vol&amp;aacute;tiles no son at&amp;oacute;micos (la lectura y escritura concurrentes son una &lt;a href=&quot;../language/memory_model&quot;&gt;carrera de datos&lt;/a&gt; ) y no ordenan la memoria (los accesos de memoria no vol&amp;aacute;tiles pueden reordenarse libremente alrededor del acceso vol&amp;aacute;til).</target>
        </trans-unit>
        <trans-unit id="3cb2abcf8bbfd3a7bfabbd1249bd200fcbc8e347" translate="yes" xml:space="preserve">
          <source>In addition, within the namespace &lt;code&gt;std::chrono&lt;/code&gt;, the directive &lt;code&gt;using namespace literals::chrono_literals;&lt;/code&gt; is provided by the standard library, so that if a programmer uses &lt;code&gt;using namespace std::chrono;&lt;/code&gt; to gain access to the classes in the chrono library, the corresponding literal operators become visible as well.</source>
          <target state="translated">Adem&amp;aacute;s, dentro del espacio de nombres &lt;code&gt;std::chrono&lt;/code&gt; , la directiva que &lt;code&gt;using namespace literals::chrono_literals;&lt;/code&gt; es proporcionado por la biblioteca est&amp;aacute;ndar, de modo que si un programador usa el &lt;code&gt;using namespace std::chrono;&lt;/code&gt; Para obtener acceso a las clases en la biblioteca crono, los operadores literales correspondientes tambi&amp;eacute;n se hacen visibles.</target>
        </trans-unit>
        <trans-unit id="208c76a1040cc2d170e334de617b92960c4a9549" translate="yes" xml:space="preserve">
          <source>In all cases in which the call to &lt;code&gt;regex_search&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;match.prefix().first&lt;/code&gt; will be equal to the previous value of &lt;code&gt;match[0].second&lt;/code&gt; and for each index</source>
          <target state="translated">En todos los casos en que la llamada a &lt;code&gt;regex_search&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;match.prefix().first&lt;/code&gt; ser&amp;aacute; igual al valor anterior de &lt;code&gt;match[0].second&lt;/code&gt; y para cada &amp;iacute;ndice</target>
        </trans-unit>
        <trans-unit id="b3e3fd9de0235c44f06b8f45f6682e2f71d0e99c" translate="yes" xml:space="preserve">
          <source>In all cases the deleter is initialized from &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;decltype(d)&amp;gt;(d)&lt;/code&gt;.</source>
          <target state="translated">En todos los casos, el eliminador se inicializa desde &lt;code&gt;&lt;a href=&quot;../../utility/forward&quot;&gt;std::forward&lt;/a&gt;&amp;lt;decltype(d)&amp;gt;(d)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="702fc4c8ea20caf42025f3c5b2479929ca73939e" translate="yes" xml:space="preserve">
          <source>In all cases, a constructor selected to copy or move an object is odr-used even if &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt; takes place.</source>
          <target state="translated">En todos los casos, un constructor seleccionado para copiar o mover un objeto se usa odr, incluso si se &lt;a href=&quot;copy_elision&quot;&gt;copia la elisi&amp;oacute;n&lt;/a&gt; realiza una .</target>
        </trans-unit>
        <trans-unit id="448921a2325557aed9e228f8da4e834b6e28cdeb" translate="yes" xml:space="preserve">
          <source>In all cases, attr is an optional sequence of &lt;a href=&quot;attributes&quot;&gt;attributes&lt;/a&gt;. When appearing immediately after the identifier, it applies to the object being declared.</source>
          <target state="translated">En todos los casos, attr es una secuencia opcional de &lt;a href=&quot;attributes&quot;&gt;atributos&lt;/a&gt; . Cuando aparece inmediatamente despu&amp;eacute;s del identificador, se aplica al objeto que se declara.</target>
        </trans-unit>
        <trans-unit id="83161a84bc1a7a51d78f0506c4b7ea19c215e3d3" translate="yes" xml:space="preserve">
          <source>In all cases, cv-qualifiers are ignored by typeid (that is, &lt;code&gt;typeid(const T) == typeid(T)&lt;/code&gt;).</source>
          <target state="translated">En todos los casos, los calificadores cv son ignorados por typeid (es decir, &lt;code&gt;typeid(const T) == typeid(T)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="10f7d85b749093104c6f7b42f1410b3aa41a5078" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;&lt;code&gt;Traits::eq&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="translated">En todos los casos, la igualdad se verifica llamando a &lt;a href=&quot;../char_traits/cmp&quot;&gt; &lt;code&gt;Traits::eq&lt;/code&gt; &lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e78e8c07f5b30e31f34be5630e807f2679203b79" translate="yes" xml:space="preserve">
          <source>In all cases, equality is checked by calling &lt;a href=&quot;../char_traits/cmp&quot;&gt;Traits::eq&lt;/a&gt;.</source>
          <target state="translated">En todos los casos, la igualdad se verifica llamando a &lt;a href=&quot;../char_traits/cmp&quot;&gt;Traits :: eq&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="42ce3a010af7213a4ee16fafe2f69cd257e4ea24" translate="yes" xml:space="preserve">
          <source>In all cases, for the built-in operators, lhs and rhs must have either.</source>
          <target state="translated">En todos los casos,para los operadores incorporados,lhs y rhs deben tener cualquiera de los dos.</target>
        </trans-unit>
        <trans-unit id="773f0f51c30de4ead22498372e4d412e3f3708c1" translate="yes" xml:space="preserve">
          <source>In all cases, if &lt;code&gt;ptr&lt;/code&gt; is a null pointer, the standard library deallocation functions do nothing. If the pointer passed to the standard library deallocation function was not obtained from the corresponding standard library allocation function, the behavior is undefined.</source>
          <target state="translated">En todos los casos, si &lt;code&gt;ptr&lt;/code&gt; es un puntero nulo, las funciones de desasignaci&amp;oacute;n de biblioteca est&amp;aacute;ndar no hacen nada. Si el puntero pasado a la funci&amp;oacute;n de desasignaci&amp;oacute;n de biblioteca est&amp;aacute;ndar no se obtuvo de la funci&amp;oacute;n de asignaci&amp;oacute;n de biblioteca est&amp;aacute;ndar correspondiente, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="013ee203d2185f13defcfecaa9d4ae3f3d4ae52b" translate="yes" xml:space="preserve">
          <source>In all cases, if the empty pair of braces &lt;code&gt;{} &lt;/code&gt; is used and &lt;code&gt;T&lt;/code&gt; is an</source>
          <target state="translated">En todos los casos, si se usa el par de llaves vac&amp;iacute;as &lt;code&gt;{} &lt;/code&gt; y &lt;code&gt;T&lt;/code&gt; es un</target>
        </trans-unit>
        <trans-unit id="9dfb4259d8b5e6ee928f73bc11c3685d70ea5622" translate="yes" xml:space="preserve">
          <source>In all cases, it is the stored pointer (the one returned by &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt;) that is compared, rather than the managed pointer (the one passed to the deleter when use_count goes to zero). The two pointers may differ in a shared_ptr created using the aliasing constructor.</source>
          <target state="translated">En todos los casos, se compara el puntero almacenado (el devuelto por &lt;code&gt;&lt;a href=&quot;get&quot;&gt;get()&lt;/a&gt;&lt;/code&gt; ), en lugar del puntero administrado (el que se pasa al eliminador cuando use_count va a cero). Los dos punteros pueden diferir en un shared_ptr creado usando el constructor de alias.</target>
        </trans-unit>
        <trans-unit id="f050a06aeea57760c69721a08f3162ee7c38913e" translate="yes" xml:space="preserve">
          <source>In all cases, the conversion begins in initial shift state, unless non-initial starting state was provided to this &lt;code&gt;wstring_convert&lt;/code&gt; constructor. The number of characters converted and the final value of the conversion state are remembered and can be accessed with &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;converted&quot;&gt;converted()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En todos los casos, la conversi&amp;oacute;n comienza en el estado de cambio inicial, a menos que se haya proporcionado un estado de inicio no inicial a este constructor &lt;code&gt;wstring_convert&lt;/code&gt; . El n&amp;uacute;mero de caracteres convertidos y el valor final del estado de conversi&amp;oacute;n se recuerdan y se puede acceder con &lt;code&gt;&lt;a href=&quot;state&quot;&gt;state()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;converted&quot;&gt;converted()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89b8bdb3cdd26cc5757a5fc307bf6e8cbadfa071" translate="yes" xml:space="preserve">
          <source>In all cases, throws &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;size() + ins_count &amp;gt; max_size()&lt;/code&gt; where &lt;code&gt;ins_count&lt;/code&gt; is the number of characters that will be inserted and may throw any exceptions thrown by &lt;code&gt;Allocator::allocate&lt;/code&gt;.</source>
          <target state="translated">En todos los casos, arroja &lt;code&gt;&lt;a href=&quot;../../error/length_error/length_error&quot;&gt;std::length_error&lt;/a&gt;&lt;/code&gt; if &lt;code&gt;size() + ins_count &amp;gt; max_size()&lt;/code&gt; donde &lt;code&gt;ins_count&lt;/code&gt; es el n&amp;uacute;mero de caracteres que se insertar&amp;aacute;n y puede arrojar cualquier excepci&amp;oacute;n lanzada por &lt;code&gt;Allocator::allocate&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bec4825b469bd22420b217d83b3fa4ef3c1c3f" translate="yes" xml:space="preserve">
          <source>In all other cases the result is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">En todos los dem&amp;aacute;s casos, el resultado es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0ee8040c05c6072650b3fc884f5719734c12fb2" translate="yes" xml:space="preserve">
          <source>In all other cases, neither template is more specialized than the other with regards to the type(s) deduced by this P/A pair.</source>
          <target state="translated">En todos los demás casos,ninguna de las plantillas es más especializada que la otra en cuanto al tipo o tipos deducidos por este par de P/A.</target>
        </trans-unit>
        <trans-unit id="e58e6d192ec64176fdc1379f81dba51aa0d986c8" translate="yes" xml:space="preserve">
          <source>In all other cases, the result is exact (&lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; is never raised) and &lt;a href=&quot;../fenv/fe_round&quot;&gt;the current rounding mode&lt;/a&gt; is ignored</source>
          <target state="translated">En todos los dem&amp;aacute;s casos, el resultado es exacto ( &lt;code&gt;&lt;a href=&quot;../fenv/fe_exceptions&quot;&gt;FE_INEXACT&lt;/a&gt;&lt;/code&gt; nunca se eleva) y se ignora el &lt;a href=&quot;../fenv/fe_round&quot;&gt;modo de redondeo actual&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="725c5378c2d25e77fa8739dfffb5cdbf3d501bf2" translate="yes" xml:space="preserve">
          <source>In all these contexts, the function selected from the overload set is the function whose type matches the pointer to function, reference to function, or pointer to member function type that is expected by</source>
          <target state="translated">En todos estos contextos,la función seleccionada del conjunto de sobrecarga es la función cuyo tipo coincide con el puntero a la función,la referencia a la función o el puntero al tipo de función miembro que se espera de</target>
        </trans-unit>
        <trans-unit id="42e33142558dfcb4a52d9857fc0366f3d6fbcb3d" translate="yes" xml:space="preserve">
          <source>In an inline function,</source>
          <target state="translated">En una función en línea,</target>
        </trans-unit>
        <trans-unit id="e54ee587ae8370595daaa17b48b214c6cedbda36" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;std::terminate&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En cualquier caso, &lt;code&gt;std::terminate&lt;/code&gt; llama al &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; actualmente instalado . El est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;terminate_handler&quot;&gt;std::terminate_handler&lt;/a&gt;&lt;/code&gt; llama a &lt;code&gt;&lt;a href=&quot;../utility/program/abort&quot;&gt;std::abort&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3dd5c3a82e6a3c58b090861766b926905a15762" translate="yes" xml:space="preserve">
          <source>In any case, &lt;code&gt;str.width(0)&lt;/code&gt; is called to cancel the effects of &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En cualquier caso, se llama a &lt;code&gt;str.width(0)&lt;/code&gt; para cancelar los efectos de &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c3348754a124fedffbdcc31ba4b5c403932481c" translate="yes" xml:space="preserve">
          <source>In any case, an additional fictional function template derived as above from a hypothetical constructor &lt;code&gt;C(C)&lt;/code&gt; is added, called the copy deduction candidate.</source>
          <target state="translated">En cualquier caso, una plantilla de funci&amp;oacute;n ficticia adicional derivada como anteriormente de un constructor hipot&amp;eacute;tico &lt;code&gt;C(C)&lt;/code&gt; , llamada candidato de deducci&amp;oacute;n de copia.</target>
        </trans-unit>
        <trans-unit id="fa4b872de2f5ce03a3a38ccff298fd27acc8cd7f" translate="yes" xml:space="preserve">
          <source>In any case, container operations (as well as algorithms, or any other C++ standard library functions) may be parallelized internally as long as this does not change the user-visible results (e.g. &lt;code&gt;&lt;a href=&quot;algorithm/transform&quot;&gt;std::transform&lt;/a&gt;&lt;/code&gt; may be parallelized, but not &lt;code&gt;&lt;a href=&quot;algorithm/for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; which is specified to visit each element of a sequence in order)</source>
          <target state="translated">En cualquier caso, las operaciones de contenedor (as&amp;iacute; como los algoritmos o cualquier otra funci&amp;oacute;n de biblioteca est&amp;aacute;ndar de C ++) se pueden paralelizar internamente siempre que esto no cambie los resultados visibles para el usuario (por ejemplo, &lt;code&gt;&lt;a href=&quot;algorithm/transform&quot;&gt;std::transform&lt;/a&gt;&lt;/code&gt; puede ser paralelo, pero no &lt;code&gt;&lt;a href=&quot;algorithm/for_each&quot;&gt;std::for_each&lt;/a&gt;&lt;/code&gt; que se especifica para visitar cada elemento de una secuencia en orden)</target>
        </trans-unit>
        <trans-unit id="2da0390056e4062badb9f03f93f263c86a863ecf" translate="yes" xml:space="preserve">
          <source>In any case, if &lt;code&gt;count&amp;gt;0&lt;/code&gt;, it then stores a null character &lt;code&gt;CharT()&lt;/code&gt; into the next successive location of the array and updates &lt;code&gt;gcount()&lt;/code&gt;.</source>
          <target state="translated">En cualquier caso, si &lt;code&gt;count&amp;gt;0&lt;/code&gt; , almacena un car&amp;aacute;cter nulo &lt;code&gt;CharT()&lt;/code&gt; en la siguiente ubicaci&amp;oacute;n sucesiva de la matriz y actualiza &lt;code&gt;gcount()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4df2d850754842c746a077f1d7414c07173a5713" translate="yes" xml:space="preserve">
          <source>In any case, if U is an incomplete type, the program is ill-formed.</source>
          <target state="translated">En cualquier caso,si la U es un tipo incompleto,el programa está mal formado.</target>
        </trans-unit>
        <trans-unit id="ea9753e092b975406e86e9a75ca8490421b85d80" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).</source>
          <target state="translated">En cualquier caso,si se lanza una excepción por cualquier razón,esta función no tiene ningún efecto (fuerte garantía de excepción).</target>
        </trans-unit>
        <trans-unit id="6ea5742f9037c3ece834bf38253ccb990e6ae335" translate="yes" xml:space="preserve">
          <source>In any case, if an exception is thrown for any reason, this function has no effect (strong exception guarantee).(since C++11).</source>
          <target state="translated">En cualquier caso,si se lanza una excepción por cualquier razón,esta función no tiene ningún efecto (fuerte garantía de excepción).(desde C++11).</target>
        </trans-unit>
        <trans-unit id="5ad29af16c7a4b0eae9f716a384a3fe434c038e3" translate="yes" xml:space="preserve">
          <source>In any case, if any part of a type name is non-deduced, the entire type name is non-deduced context. However, compound types can include both deduced and non-deduced type names. For example, in &lt;code&gt;A&amp;lt;T&amp;gt;::B&amp;lt;T2&amp;gt;&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt; is non-deduced because of rule #1 (nested name specifier), and &lt;code&gt;T2&lt;/code&gt; is non-deduced because it is part of the same type name, but in &lt;code&gt;void(*f)(typename A&amp;lt;T&amp;gt;::B, A&amp;lt;T&amp;gt;)&lt;/code&gt;, the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;::B&lt;/code&gt; is non-deduced (because of the same rule), while the &lt;code&gt;T&lt;/code&gt; in &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; is deduced.</source>
          <target state="translated">En cualquier caso, si alguna parte de un nombre de tipo no se deduce, el nombre completo del tipo es contexto no deducido. Sin embargo, los tipos compuestos pueden incluir nombres de tipos deducidos y no deducidos. Por ejemplo, en &lt;code&gt;A&amp;lt;T&amp;gt;::B&amp;lt;T2&amp;gt;&lt;/code&gt; , &lt;code&gt;T&lt;/code&gt; no se deduce debido a la regla # 1 (especificador de nombre anidado), y &lt;code&gt;T2&lt;/code&gt; no se deduce porque es parte del mismo nombre de tipo, pero est&amp;aacute; &lt;code&gt;void(*f)(typename A&amp;lt;T&amp;gt;::B, A&amp;lt;T&amp;gt;)&lt;/code&gt; , la &lt;code&gt;T&lt;/code&gt; en &lt;code&gt;A&amp;lt;T&amp;gt;::B&lt;/code&gt; no se deduce (debido a la misma regla), mientras que la &lt;code&gt;T&lt;/code&gt; en &lt;code&gt;A&amp;lt;T&amp;gt;&lt;/code&gt; se deduce</target>
        </trans-unit>
        <trans-unit id="bac936a68f34bcde27ef8af2c5541d05870721a4" translate="yes" xml:space="preserve">
          <source>In any case, if the conversion function fails &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; is assigned to &lt;code&gt;err&lt;/code&gt;</source>
          <target state="translated">En cualquier caso, si la funci&amp;oacute;n de conversi&amp;oacute;n falla &lt;code&gt;&lt;a href=&quot;../../io/ios_base/iostate&quot;&gt;std::ios_base::failbit&lt;/a&gt;&lt;/code&gt; se asigna a &lt;code&gt;err&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f692dd6979a28b812ff55210b84b6db94eddba7d" translate="yes" xml:space="preserve">
          <source>In any case, if the pointed-to type is different from the array element type, disregarding cv qualifications, at every level if the elements are themselves pointers, the behavior of pointer arithmetic is undefined. In particular, pointer arithmetic with pointer to base, which is pointing at an element of an array of derived objects is undefined.</source>
          <target state="translated">En cualquier caso,si el tipo de puntero es diferente del tipo de elemento de la matriz,sin tener en cuenta las calificaciones de cv,en cada nivel si los elementos son en sí mismos punteros,el comportamiento de la aritmética de los punteros es indefinido.En particular,la aritmética de puntero con puntero a base,que está apuntando a un elemento de una matriz de objetos derivados,no está definida.</target>
        </trans-unit>
        <trans-unit id="a6713811e3c955566cd61aabae4ba44639991bc9" translate="yes" xml:space="preserve">
          <source>In any case, if the value of the right operand is negative or is greater or equal to the number of bits in the promoted left operand, the behavior is undefined.</source>
          <target state="translated">En cualquier caso,si el valor del operando derecho es negativo o es mayor o igual al número de bits del operando izquierdo promocionado,el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="e408e1ffc24f4902a539b882cf7a3ebb2a011be7" translate="yes" xml:space="preserve">
          <source>In any case, sets the &lt;code&gt;gcount()&lt;/code&gt; counter to zero.</source>
          <target state="translated">En cualquier caso, establece el &lt;code&gt;gcount()&lt;/code&gt; en cero.</target>
        </trans-unit>
        <trans-unit id="3d278d5d6ccb754380b757eb2f8bd5786624cf05" translate="yes" xml:space="preserve">
          <source>In any case, the argument list for the purpose of overload resolution is the argument list of the function call expression preceded by the implied object argument &lt;code&gt;E&lt;/code&gt; (when matching against the surrogate function, the user-defined conversion will automatically convert the implied object argument to the first argument of the surrogate function).</source>
          <target state="translated">En cualquier caso, la lista de argumentos con el prop&amp;oacute;sito de resoluci&amp;oacute;n de sobrecarga es la lista de argumentos de la expresi&amp;oacute;n de llamada de funci&amp;oacute;n precedida por el argumento del objeto impl&amp;iacute;cito &lt;code&gt;E&lt;/code&gt; (cuando se compara con la funci&amp;oacute;n sustituta, la conversi&amp;oacute;n definida por el usuario convertir&amp;aacute; autom&amp;aacute;ticamente el argumento del objeto impl&amp;iacute;cito en El primer argumento de la funci&amp;oacute;n sustituta).</target>
        </trans-unit>
        <trans-unit id="ba7e54962dc6ba91c1893f539a5af9b0dd3bcd03" translate="yes" xml:space="preserve">
          <source>In any case, the call to &lt;code&gt;std::async&lt;/code&gt;</source>
          <target state="translated">En cualquier caso, la llamada a &lt;code&gt;std::async&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac7f68c6ecc54f2511911cdf7e14078e65684035" translate="yes" xml:space="preserve">
          <source>In any case, the check is made whether the &lt;code&gt;char&lt;/code&gt; obtained from the previous steps is allowed in the input field that would be parsed by &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; given the conversion specifier selected in Stage 1. If it is allowed, it is accumulated in a temporary buffer and Stage 2 repeats. If it is not allowed, Stage 2 terminates.</source>
          <target state="translated">En cualquier caso, se verifica si el &lt;code&gt;char&lt;/code&gt; obtenido de los pasos anteriores est&amp;aacute; permitido en el campo de entrada que ser&amp;iacute;a analizado por &lt;code&gt;&lt;a href=&quot;../../io/c/scanf&quot;&gt;std::scanf&lt;/a&gt;&lt;/code&gt; dado el especificador de conversi&amp;oacute;n seleccionado en la Etapa 1. Si est&amp;aacute; permitido, se acumula en un buffer temporal y la etapa 2 se repite. Si no est&amp;aacute; permitido, la Etapa 2 termina.</target>
        </trans-unit>
        <trans-unit id="7239f4c6ede432f98a1ba74015ef9a8efc5ff852" translate="yes" xml:space="preserve">
          <source>In any case, the path class behaves as if it stores a pathname in the native format and automatically converts to generic format as needed (each member function specifies which format it interprets the path as).</source>
          <target state="translated">En cualquier caso,la clase de trayectoria se comporta como si almacenara una trayectoria en el formato nativo y se convirtiera automáticamente en formato genérico según sea necesario (cada función miembro especifica el formato con el que interpreta la trayectoria).</target>
        </trans-unit>
        <trans-unit id="d3d5f9fb69cc2220358beed9110dba0f5144fa1f" translate="yes" xml:space="preserve">
          <source>In any case, the result is a &lt;code&gt;bool&lt;/code&gt; prvalue.</source>
          <target state="translated">En cualquier caso, el resultado es un &lt;code&gt;bool&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bdbc8735ab228c93f4f0db0b86729ff991ed9876" translate="yes" xml:space="preserve">
          <source>In any case, the resulting value is one of at most two floating-point values closest to the value of the string matching the pattern, after rounding according to &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En cualquier caso, el valor resultante es uno de los dos valores de punto flotante m&amp;aacute;s cercanos al valor de la cadena que coincide con el patr&amp;oacute;n, despu&amp;eacute;s de redondear de acuerdo con &lt;code&gt;&lt;a href=&quot;../types/numeric_limits/float_round_style&quot;&gt;std::round_to_nearest&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c407d2239a1860dec731b410278172d7d1e7af2e" translate="yes" xml:space="preserve">
          <source>In any case, updates the private member variable that is accessed by &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En cualquier caso, actualiza la variable miembro privado a la que accede &lt;code&gt;&lt;a href=&quot;is_open&quot;&gt;is_open()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd58a7b2537b4b1d9769b336c69ed0405e2bf357" translate="yes" xml:space="preserve">
          <source>In any event, whether terminating by exception or returning, the sentry's destructor is called before leaving this function.</source>
          <target state="translated">En cualquier caso,ya sea terminando por excepción o regresando,el destructor del centinela es llamado antes de dejar esta función.</target>
        </trans-unit>
        <trans-unit id="9d70a008be456375cc51641818d2f498b0e8cfe0" translate="yes" xml:space="preserve">
          <source>In both cases, virt-specifier-seq, if used, is either &lt;code&gt;override&lt;/code&gt; or &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;.</source>
          <target state="translated">En ambos casos, virt-specifier-seq, si se usa, es &lt;code&gt;override&lt;/code&gt; o &lt;a href=&quot;final&quot;&gt;final&lt;/a&gt; , o &lt;code&gt;final override&lt;/code&gt; o &lt;code&gt;override final&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7735a0f86f64131cc2baeb3f9d91024df4a0f2ac" translate="yes" xml:space="preserve">
          <source>In brief, a class that defines &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; automatically gets compiler-generated operators ==, !=, &amp;lt;, &amp;lt;=, &amp;gt;, and &amp;gt;=. A class can define &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; as defaulted, in which case the compiler will also generate the code for that operator.</source>
          <target state="translated">En resumen, una clase que define el &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; obtiene autom&amp;aacute;ticamente operadores generados por el compilador ==,! =, &amp;lt;, &amp;lt;=,&amp;gt; Y&amp;gt; =. Una clase puede definir el &lt;code&gt;operator&amp;lt;=&amp;gt;&lt;/code&gt; como predeterminado, en cuyo caso el compilador tambi&amp;eacute;n generar&amp;aacute; el c&amp;oacute;digo para ese operador.</target>
        </trans-unit>
        <trans-unit id="b4aca348b75aa570f1a0831d21e79e759aa35c7a" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax (1) (with round parentheses) and a &lt;a href=&quot;function&quot;&gt;function declaration&lt;/a&gt;, the compiler always chooses function declaration. This disambiguation rule is sometimes counter-intuitive and has been called the &lt;a href=&quot;https://en.wikipedia.org/wiki/Most_vexing_parse&quot;&gt;most vexing parse&lt;/a&gt;.</source>
          <target state="translated">En caso de ambig&amp;uuml;edad entre una declaraci&amp;oacute;n de variable utilizando la sintaxis de inicializaci&amp;oacute;n directa (1) (con par&amp;eacute;ntesis) y una &lt;a href=&quot;function&quot;&gt;declaraci&amp;oacute;n de funci&amp;oacute;n&lt;/a&gt; , el compilador siempre elige la declaraci&amp;oacute;n de funci&amp;oacute;n. Esta regla de desambiguaci&amp;oacute;n es a veces contra-intuitiva y se ha llamado el &lt;a href=&quot;https://en.wikipedia.org/wiki/Most_vexing_parse&quot;&gt;an&amp;aacute;lisis m&amp;aacute;s irritante&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="901202dfb183bd5273740fd75a6cb4999a9adde4" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between a variable declaration using the direct-initialization syntax and a function declaration, the compiler always chooses function declaration; see &lt;a href=&quot;direct_initialization#Notes&quot;&gt;direct-initialization&lt;/a&gt;.</source>
          <target state="translated">En caso de ambig&amp;uuml;edad entre una declaraci&amp;oacute;n de variable que utiliza la sintaxis de inicializaci&amp;oacute;n directa y una declaraci&amp;oacute;n de funci&amp;oacute;n, el compilador siempre elige la declaraci&amp;oacute;n de funci&amp;oacute;n; ver &lt;a href=&quot;direct_initialization#Notes&quot;&gt;inicializaci&amp;oacute;n directa&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="584cb1daba5fb668ec776aaad71f0f0a1e678a65" translate="yes" xml:space="preserve">
          <source>In case of ambiguity between the size of the bit field and the default member initializer, the longest sequence of tokens that forms a valid size is chosen:</source>
          <target state="translated">En caso de ambigüedad entre el tamaño del campo de bits y el inicializador de miembros por defecto,se elige la secuencia más larga de fichas que forman un tamaño válido:</target>
        </trans-unit>
        <trans-unit id="c60f89be5e6a24d3e9af482fb30cc5225a2b9c40" translate="yes" xml:space="preserve">
          <source>In class definition</source>
          <target state="translated">En la definición de clase</target>
        </trans-unit>
        <trans-unit id="0ed480b0f5f767a36b4cca750fd3df5eb7dea2c0" translate="yes" xml:space="preserve">
          <source>In class template</source>
          <target state="translated">En la plantilla de la clase</target>
        </trans-unit>
        <trans-unit id="88cf7e36aa40464925cb0cdb822a38f9a11a2e03" translate="yes" xml:space="preserve">
          <source>In class templates, &lt;code&gt;this&lt;/code&gt; is a &lt;a href=&quot;dependent_name&quot;&gt;dependent expression&lt;/a&gt;, and explicit &lt;code&gt;this-&amp;gt;&lt;/code&gt; may be used to force another expression to become dependent.</source>
          <target state="translated">En las plantillas de clase, &lt;code&gt;this&lt;/code&gt; es una &lt;a href=&quot;dependent_name&quot;&gt;expresi&amp;oacute;n dependiente&lt;/a&gt; , y expl&amp;iacute;citamente &lt;code&gt;this-&amp;gt;&lt;/code&gt; puede usarse para forzar que otra expresi&amp;oacute;n se vuelva dependiente.</target>
        </trans-unit>
        <trans-unit id="9bb902edc779601077555fd4ba8ae150af319a7a" translate="yes" xml:space="preserve">
          <source>In contrast to &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;std::fmod()&lt;/a&gt;&lt;/code&gt;, the returned value is not guaranteed to have the same sign as &lt;code&gt;x&lt;/code&gt;.</source>
          <target state="translated">A diferencia de &lt;code&gt;&lt;a href=&quot;fmod&quot;&gt;std::fmod()&lt;/a&gt;&lt;/code&gt; , no se garantiza que el valor devuelto tenga el mismo signo que &lt;code&gt;x&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29e6d4a4833ba899fe54d6d48cb6237bf996c237" translate="yes" xml:space="preserve">
          <source>In copy-list-initialization, if phase 2 selects an explicit constructor, the initialization is ill-formed (as opposed to all over copy-initializations where explicit constructors are not even considered).</source>
          <target state="translated">En la inicialización de la lista de copias,si la fase 2 selecciona un constructor explícito,la inicialización está mal formada (a diferencia de todas las inicializaciones de copias en las que ni siquiera se consideran los constructores explícitos).</target>
        </trans-unit>
        <trans-unit id="0f662aa9e7fe6829be9755a0bb2464c6d5830c0c" translate="yes" xml:space="preserve">
          <source>In declarations</source>
          <target state="translated">En las declaraciones</target>
        </trans-unit>
        <trans-unit id="6cfdd0eb8f38950930fcb84521ccaa8ab0f3a576" translate="yes" xml:space="preserve">
          <source>In declarations, attributes may appear both before the whole declaration and directly after the name of the entity that is declared, in which case they are combined. In most other situations, attributes apply to the directly preceding entity.</source>
          <target state="translated">En las declaraciones,los atributos pueden aparecer tanto antes de toda la declaración como directamente después del nombre de la entidad declarada,en cuyo caso se combinan.En la mayoría de las demás situaciones,los atributos se aplican a la entidad directamente precedente.</target>
        </trans-unit>
        <trans-unit id="2913833b48b2894352d88e1660f11e59aa09d3c6" translate="yes" xml:space="preserve">
          <source>In detail</source>
          <target state="translated">En detalle</target>
        </trans-unit>
        <trans-unit id="9ea333fa04508f8dc9aec394ed0e05cc9396345e" translate="yes" xml:space="preserve">
          <source>In detail, the common comparison type of a list of n types T0...Tn-1 is defined as follows:</source>
          <target state="translated">En detalle,el tipo de comparación común de una lista de n tipos T0...Tn-1 se define de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0c0bc79ad40602f6280764ba3e86b0386a7085c2" translate="yes" xml:space="preserve">
          <source>In detail:</source>
          <target state="translated">En detalle:</target>
        </trans-unit>
        <trans-unit id="c02c2129e19b776dcabd51f1ec40f2e879325a96" translate="yes" xml:space="preserve">
          <source>In direct-list-initialization (but not in copy-list-initalization), when deducing the meaning of the &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; from a braced-init-list, the braced-init-list must contain only one element, and the type of auto will be the type of that element:</source>
          <target state="translated">En la inicializaci&amp;oacute;n de lista directa (pero no en la inicializaci&amp;oacute;n de lista de copia), cuando se deduce el significado del &lt;a href=&quot;auto&quot;&gt;auto&lt;/a&gt; de una lista de inicializaci&amp;oacute;n arriostrada, la lista de inicializaci&amp;oacute;n arriostrada debe contener solo un elemento, y el tipo de auto ser el tipo de ese elemento:</target>
        </trans-unit>
        <trans-unit id="c32c9ac9a30d2bf4ad4aaca0daac65dbd6f4dbc0" translate="yes" xml:space="preserve">
          <source>In each case</source>
          <target state="translated">En cada caso</target>
        </trans-unit>
        <trans-unit id="8ff5c44b9f8d73aec0aa66262a809a1b948e7c53" translate="yes" xml:space="preserve">
          <source>In each case, the object (or individual elements if &lt;code&gt;T&lt;/code&gt; is an array type)(since C++20) will be destroyed by &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt;, where &lt;code&gt;p&lt;/code&gt; is a pointer to the object and &lt;code&gt;X&lt;/code&gt; is its type.</source>
          <target state="translated">En cada caso, el objeto (o elementos individuales si &lt;code&gt;T&lt;/code&gt; es un tipo de matriz) (ya que C ++ 20) ser&amp;aacute; destruido por &lt;code&gt;p-&amp;gt;~X()&lt;/code&gt; , donde &lt;code&gt;p&lt;/code&gt; es un puntero al objeto y &lt;code&gt;X&lt;/code&gt; es su tipo.</target>
        </trans-unit>
        <trans-unit id="a0acff1fbd7c81794afc6d04ed614676c2d1a5ea" translate="yes" xml:space="preserve">
          <source>In each context, the name of an overloaded function may be preceded by address-of operator &lt;code&gt;&amp;amp;&lt;/code&gt; and may be enclosed in a redundant set of parentheses.</source>
          <target state="translated">En cada contexto, el nombre de una funci&amp;oacute;n sobrecargada puede ir precedido de operador de direcci&amp;oacute;n &lt;code&gt;&amp;amp;&lt;/code&gt; y puede ser encerrado en un conjunto redundante de par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="580d311d2c3830913522a71b0ee0845b37f593cf" translate="yes" xml:space="preserve">
          <source>In either case, &lt;code&gt;std::unexpected&lt;/code&gt; calls the currently installed &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt;. The default &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; calls &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En cualquier caso, &lt;code&gt;std::unexpected&lt;/code&gt; llama al &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; actualmente instalado . El valor predeterminado de &lt;code&gt;&lt;a href=&quot;unexpected_handler&quot;&gt;std::unexpected_handler&lt;/a&gt;&lt;/code&gt; llama a &lt;code&gt;&lt;a href=&quot;../terminate&quot;&gt;std::terminate&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6513d1fe43b0727e95c4ecbedbc97f1ff6159779" translate="yes" xml:space="preserve">
          <source>In either case, an additional null character value &lt;code&gt;CharT()&lt;/code&gt; is stored at the end of the output. If no characters were extracted, sets &lt;a href=&quot;../ios_base/iostate&quot;&gt;&lt;code&gt;failbit&lt;/code&gt;&lt;/a&gt; (the null character is still written, to the first position in the output). Finally, calls &lt;code&gt;st.width(0)&lt;/code&gt; to cancel the effects of &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;, if any.  3).</source>
          <target state="translated">En cualquier caso, un valor de car&amp;aacute;cter nulo adicional &lt;code&gt;CharT()&lt;/code&gt; se almacena al final de la salida. Si no se extrajeron caracteres, establece el &lt;a href=&quot;../ios_base/iostate&quot;&gt; &lt;code&gt;failbit&lt;/code&gt; &lt;/a&gt; (el car&amp;aacute;cter nulo a&amp;uacute;n se escribe en la primera posici&amp;oacute;n de la salida). Finalmente, llama a &lt;code&gt;st.width(0)&lt;/code&gt; para cancelar los efectos de &lt;code&gt;&lt;a href=&quot;../manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; , si los hay. 3)</target>
        </trans-unit>
        <trans-unit id="8164d479fcc12457fe047a38c7a34d5e26adfd63" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed (rebalancing may occur, as with &lt;code&gt;&lt;a href=&quot;erase&quot;&gt;erase()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">En cualquier caso, no se copian ni mueven elementos, solo se vuelven a asignar los punteros internos de los nodos del contenedor (puede producirse un reequilibrio, como con &lt;code&gt;&lt;a href=&quot;erase&quot;&gt;erase()&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3eb50cbaf3e01225bd1ecea1bf00b9412ffb6b4a" translate="yes" xml:space="preserve">
          <source>In either case, no elements are copied or moved, only the internal pointers of the container nodes are repointed.</source>
          <target state="translated">En cualquier caso,no se copian ni se mueven elementos,sólo se reubican los punteros internos de los nodos contenedores.</target>
        </trans-unit>
        <trans-unit id="c657cee6a5de51a9466de54eb7a34b06cf204249" translate="yes" xml:space="preserve">
          <source>In either case, stores the number of characters extracted in the member variable accessed by subsequent calls to &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;sb&lt;/code&gt; is a null pointer or if no characters were inserted into &lt;code&gt;sb&lt;/code&gt;, calls &lt;code&gt;setstate(failbit)&lt;/code&gt; (which may throw &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; if enabled).</source>
          <target state="translated">En cualquier caso, almacena el n&amp;uacute;mero de caracteres extra&amp;iacute;dos en la variable miembro a la que acceden las llamadas posteriores a &lt;code&gt;&lt;a href=&quot;gcount&quot;&gt;gcount()&lt;/a&gt;&lt;/code&gt; . Si &lt;code&gt;sb&lt;/code&gt; es un puntero nulo o si no se insertaron caracteres en &lt;code&gt;sb&lt;/code&gt; , llama a &lt;code&gt;setstate(failbit)&lt;/code&gt; (que puede arrojar &lt;code&gt;&lt;a href=&quot;../ios_base/failure&quot;&gt;std::ios_base::failure&lt;/a&gt;&lt;/code&gt; si est&amp;aacute; habilitado).</target>
        </trans-unit>
        <trans-unit id="f958e451ccea1b7f622427f43a20430e7db91448" translate="yes" xml:space="preserve">
          <source>In existing implementations, the number of weak pointers is incremented (&lt;a href=&quot;https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected&quot;&gt;[1]&lt;/a&gt;, &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p&quot;&gt;[2]&lt;/a&gt;) if there is a shared pointer to the same control block.</source>
          <target state="translated">En implementaciones existentes, el n&amp;uacute;mero de punteros d&amp;eacute;biles se incrementa ( &lt;a href=&quot;https://stackoverflow.com/questions/43297517/stdshared-ptr-internals-weak-count-more-than-expected&quot;&gt;[1]&lt;/a&gt; , &lt;a href=&quot;https://www.reddit.com/r/cpp/comments/3eia29/stdshared_ptrs_secret_constructor/ctfeh1p&quot;&gt;[2]&lt;/a&gt; ) si hay un puntero compartido al mismo bloque de control.</target>
        </trans-unit>
        <trans-unit id="1241f4b4a5871614c0b0e937d887dd31b0d585a9" translate="yes" xml:space="preserve">
          <source>In expressions</source>
          <target state="translated">En expresiones</target>
        </trans-unit>
        <trans-unit id="db2370d3e7ba69273bdb62a10e047b42c0843bf1" translate="yes" xml:space="preserve">
          <source>In function-like macros, a &lt;code&gt;#&lt;/code&gt; operator before an identifier in the replacement-list runs the identifier through parameter replacement and encloses the result in quotes, effectively creating a string literal. In addition, the preprocessor adds backslashes to escape the quotes surrounding embedded string literals, if any, and doubles the backslashes within the string as necessary. All leading and trailing whitespace is removed, and any sequence of whitespace in the middle of the text (but not inside embedded string literals) is collapsed to a single space. This operation is called &quot;stringification&quot;. If the result of stringification is not a valid string literal, the behavior is undefined.</source>
          <target state="translated">En macros similares a funciones, un operador &lt;code&gt;#&lt;/code&gt; antes de un identificador en la lista de reemplazo ejecuta el identificador a trav&amp;eacute;s del reemplazo de par&amp;aacute;metros y encierra el resultado entre comillas, creando efectivamente un literal de cadena. Adem&amp;aacute;s, el preprocesador agrega barras diagonales inversas para escapar de las comillas que rodean los literales de cadena incrustados, si existen, y duplica las barras diagonales inversas dentro de la cadena seg&amp;uacute;n sea necesario. Se eliminan todos los espacios en blanco iniciales y finales, y cualquier secuencia de espacios en blanco en el medio del texto (pero no dentro de los literales de cadena incrustados) se contrae en un solo espacio. Esta operaci&amp;oacute;n se llama &quot;stringificaci&amp;oacute;n&quot;. Si el resultado de la stringificaci&amp;oacute;n no es un literal de cadena v&amp;aacute;lido, el comportamiento es indefinido.</target>
        </trans-unit>
        <trans-unit id="1a66e73cddda4a347472a74c2bcb63aabea7fcb6" translate="yes" xml:space="preserve">
          <source>In general, for any trivially copyable type &lt;code&gt;T&lt;/code&gt; and an object &lt;code&gt;obj1&lt;/code&gt; of &lt;code&gt;T&lt;/code&gt;, the underlying bytes of &lt;code&gt;obj1&lt;/code&gt; can be copied (e.g. by means of &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt;) into an array of &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;unsigned char&lt;/code&gt; or &lt;a href=&quot;byte&quot;&gt;&lt;code&gt;std::byte&lt;/code&gt;&lt;/a&gt; or into &lt;code&gt;obj2&lt;/code&gt;, a distinct object of &lt;code&gt;T&lt;/code&gt;. Neither &lt;code&gt;obj1&lt;/code&gt; nor &lt;code&gt;obj2&lt;/code&gt; may be a potentially-overlapping subobject.</source>
          <target state="translated">En general, para cualquier tipo &lt;code&gt;T&lt;/code&gt; trivialmente copiable y un objeto &lt;code&gt;obj1&lt;/code&gt; de &lt;code&gt;T&lt;/code&gt; , los bytes subyacentes de &lt;code&gt;obj1&lt;/code&gt; se pueden copiar (por ejemplo, mediante &lt;code&gt;&lt;a href=&quot;../string/byte/memcpy&quot;&gt;std::memcpy&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; ) en una matriz de &lt;code&gt;char&lt;/code&gt; , &lt;code&gt;unsigned char&lt;/code&gt; o &lt;a href=&quot;byte&quot;&gt; &lt;code&gt;std::byte&lt;/code&gt; &lt;/a&gt; o en &lt;code&gt;obj2&lt;/code&gt; , un objeto distinto de &lt;code&gt;T&lt;/code&gt; . Ni &lt;code&gt;obj1&lt;/code&gt; ni &lt;code&gt;obj2&lt;/code&gt; pueden ser un subobjeto potencialmente superpuesto.</target>
        </trans-unit>
        <trans-unit id="38fcfe4d6a87e17a455c75a9b0e425f272558b3d" translate="yes" xml:space="preserve">
          <source>In general, implicit conversion from one multi-level pointer to another follows the rules described in &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;qualification conversions&lt;/a&gt; and in &lt;a href=&quot;operator_comparison#Pointer_comparison_operators&quot;&gt;pointer comparison operators&lt;/a&gt;.</source>
          <target state="translated">En general, la conversi&amp;oacute;n impl&amp;iacute;cita de un puntero multinivel a otro sigue las reglas descritas en las &lt;a href=&quot;implicit_cast#Qualification_conversions&quot;&gt;conversiones de calificaci&amp;oacute;n&lt;/a&gt; y en los &lt;a href=&quot;operator_comparison#Pointer_comparison_operators&quot;&gt;operadores de comparaci&amp;oacute;n de punteros&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="81b4dfcd41b67e7e484427a572743c0af786423b" translate="yes" xml:space="preserve">
          <source>In general, the candidate function whose parameters match the arguments most closely is the one that is called.</source>
          <target state="translated">En general,la función candidata cuyos parámetros coinciden más con los argumentos es la que se llama.</target>
        </trans-unit>
        <trans-unit id="1c76635c26067171ee4fb88a5e53efe29ca5200a" translate="yes" xml:space="preserve">
          <source>In general, the lifetime of a temporary cannot be further extended by &quot;passing it on&quot;: a second reference, initialized from the reference to which the temporary was bound, does not affect its lifetime.</source>
          <target state="translated">En general,la vida útil de un temporario no puede prolongarse más &quot;transmitiéndolo&quot;:una segunda referencia,iniciada a partir de la referencia a la que estaba vinculado el temporario,no afecta a su vida útil.</target>
        </trans-unit>
        <trans-unit id="3b068778e762f7be532eacfc3e630095231dc1ab" translate="yes" xml:space="preserve">
          <source>In generic contexts, the destructor call syntax can be used with an object of non-class type; this is known as pseudo-destructor call: see &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;member access operator&lt;/a&gt;.</source>
          <target state="translated">En contextos gen&amp;eacute;ricos, la sintaxis de la llamada destructor se puede usar con un objeto de tipo no clase; esto se conoce como llamada pseudodestructor: ver &lt;a href=&quot;operator_member_access#Built-in_member_access_operators&quot;&gt;operador de acceso de miembros&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0e96e30536ed7d7370721a29eb0a3baf8e9861d0" translate="yes" xml:space="preserve">
          <source>In locales other than &lt;code&gt;&quot;C&quot;&lt;/code&gt;, an alphabetic character is a character for which &lt;code&gt;std::isupper()&lt;/code&gt; or &lt;code&gt;std::islower()&lt;/code&gt; returns non-zero or any other character considered alphabetic by the locale. In any case, &lt;code&gt;std::iscntrl()&lt;/code&gt;, &lt;code&gt;std::isdigit()&lt;/code&gt;, &lt;code&gt;std::ispunct()&lt;/code&gt; and &lt;code&gt;std::isspace()&lt;/code&gt; will return zero for this character.</source>
          <target state="translated">En configuraciones regionales distintas a &lt;code&gt;&quot;C&quot;&lt;/code&gt; , un car&amp;aacute;cter alfab&amp;eacute;tico es un car&amp;aacute;cter para el cual &lt;code&gt;std::isupper()&lt;/code&gt; o &lt;code&gt;std::islower()&lt;/code&gt; devuelve un car&amp;aacute;cter distinto de cero o cualquier otro car&amp;aacute;cter considerado alfab&amp;eacute;tico por la configuraci&amp;oacute;n regional. En cualquier caso, &lt;code&gt;std::iscntrl()&lt;/code&gt; , &lt;code&gt;std::isdigit()&lt;/code&gt; , &lt;code&gt;std::ispunct()&lt;/code&gt; y &lt;code&gt;std::isspace()&lt;/code&gt; devolver&amp;aacute;n cero para este car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="2c7ad051625c76a00388473f47c41ae5d264a453" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">En muchas implementaciones, &lt;code&gt;is_nothrow_constructible&lt;/code&gt; tambi&amp;eacute;n verifica si el destructor arroja porque efectivamente no es &lt;code&gt;noexcept(T(arg))&lt;/code&gt; . Lo mismo se aplica a &lt;code&gt;is_trivially_constructible&lt;/code&gt; , que, en estas implementaciones, tambi&amp;eacute;n requiere que el destructor sea trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;error GCC 51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG, problema 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99de1bf720237b75f07b5ab247c8e8bd64241fc2" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33323ec4f069d0c0b878342b0a8185699b19819e" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">En muchas implementaciones, &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; tambi&amp;eacute;n verifica si el destructor arroja porque efectivamente no es &lt;code&gt;noexcept(T(arg))&lt;/code&gt; . Lo mismo se aplica a &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt; , que, en estas implementaciones, tambi&amp;eacute;n requiere que el destructor sea trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;error GCC 51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG, problema 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae21e32d43a5b8a2c5c70ffceb70d5fb04307666" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_copy_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_copy_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accf831c87b14d37d2cc6eafd0090b844f5f9b51" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T())&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_default_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">En muchas implementaciones, &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; tambi&amp;eacute;n verifica si el destructor arroja porque efectivamente no es &lt;code&gt;noexcept(T())&lt;/code&gt; . Lo mismo se aplica a &lt;code&gt;is_trivially_default_constructible&lt;/code&gt; , que, en estas implementaciones, tambi&amp;eacute;n requiere que el destructor sea trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;error GCC 51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG, problema 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="438ba1a0beef26968ab6a2cc4d97b48f26dcb853" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_default_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T())&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_default_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d90dd0a15587a98cbedbb69df63e111504c94d0" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_move_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="translated">En muchas implementaciones, &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; tambi&amp;eacute;n verifica si el destructor arroja porque efectivamente no es &lt;code&gt;noexcept(T(arg))&lt;/code&gt; . Lo mismo se aplica a &lt;code&gt;is_trivially_move_constructible&lt;/code&gt; , que, en estas implementaciones, tambi&amp;eacute;n requiere que el destructor sea trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452 &lt;/a&gt;&lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG n&amp;uacute;mero 2116&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bbc7a800f8051280b4337f76efed7cbb0d60440e" translate="yes" xml:space="preserve">
          <source>In many implementations, &lt;code&gt;is_nothrow_move_constructible&lt;/code&gt; also checks if the destructor throws because it is effectively &lt;code&gt;noexcept(T(arg))&lt;/code&gt;. Same applies to &lt;code&gt;is_trivially_move_constructible&lt;/code&gt;, which, in these implementations, also requires that the destructor is trivial: &lt;a href=&quot;https://gcc.gnu.org/bugzilla/show_bug.cgi?id=51452&quot;&gt;GCC bug 51452&lt;/a&gt;&lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-active.html#2116&quot;&gt;LWG issue 2116&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f61cbb399593cd96a01d7c1e70f3b86ca51dd80" translate="yes" xml:space="preserve">
          <source>In many implementations, standard output is line-buffered, and writing &lt;code&gt;'\n'&lt;/code&gt; causes a flush anyway, unless &lt;code&gt;std::ios::sync_with_stdio(false)&lt;/code&gt; was executed. In those situations, unnecessary &lt;code&gt;endl&lt;/code&gt; only degrades the performance of file output, not standard output.</source>
          <target state="translated">En muchas implementaciones, la salida est&amp;aacute;ndar tiene un buffer de l&amp;iacute;nea, y escribir &lt;code&gt;'\n'&lt;/code&gt; causa un vaciado de todos modos, a menos que se ejecute &lt;code&gt;std::ios::sync_with_stdio(false)&lt;/code&gt; . En esas situaciones, &lt;code&gt;endl&lt;/code&gt; innecesario solo degrada el rendimiento de la salida del archivo, no la salida est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="b5cc9d63c613364dc5793e8e7ac9b68a692864f4" translate="yes" xml:space="preserve">
          <source>In many situations, copy constructors are optimized out even if they would produce observable side-effects, see &lt;a href=&quot;copy_elision&quot;&gt;copy elision&lt;/a&gt;.</source>
          <target state="translated">En muchas situaciones, los constructores de copias se optimizan incluso si produjeran efectos secundarios observables, ver &lt;a href=&quot;copy_elision&quot;&gt;copia de elisi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="361bbab390512b139df616a956291652c3a5e8eb" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">En la mayor&amp;iacute;a de las implementaciones, esta funci&amp;oacute;n actualiza un objeto est&amp;aacute;tico global de tipo &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; medida que procesa a trav&amp;eacute;s de la cadena, y no puede ser invocado simult&amp;aacute;neamente por dos hilos, &lt;code&gt;&lt;a href=&quot;mbsrtowcs&quot;&gt;std::mbsrtowcs&lt;/a&gt;&lt;/code&gt; deber&amp;iacute;a usarse en tales casos.</target>
        </trans-unit>
        <trans-unit id="49690d1d0c037eea359d8320b2de46145cef5181" translate="yes" xml:space="preserve">
          <source>In most implementations, this function updates a global static object of type &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; as it processes through the string, and cannot be called simultaneously by two threads, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; should be used in such cases.</source>
          <target state="translated">En la mayor&amp;iacute;a de las implementaciones, esta funci&amp;oacute;n actualiza un objeto est&amp;aacute;tico global de tipo &lt;code&gt;&lt;a href=&quot;mbstate_t&quot;&gt;std::mbstate_t&lt;/a&gt;&lt;/code&gt; medida que se procesa a trav&amp;eacute;s de la cadena, y no puede ser invocado simult&amp;aacute;neamente por dos hilos, &lt;code&gt;&lt;a href=&quot;wcsrtombs&quot;&gt;std::wcsrtombs&lt;/a&gt;&lt;/code&gt; debe usarse en tales casos.</target>
        </trans-unit>
        <trans-unit id="88d76a48f8f96c35da8c08d45a4e62de40b811d7" translate="yes" xml:space="preserve">
          <source>In most implementations, this returns &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt;.</source>
          <target state="translated">En la mayor&amp;iacute;a de las implementaciones, esto devuelve &lt;code&gt;&lt;a href=&quot;../../types/numeric_limits&quot;&gt;std::numeric_limits&lt;/a&gt;&amp;lt;size_type&amp;gt;::max() / sizeof(value_type)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9dfeb8ee21790e4ab7902716cd854784402ed77a" translate="yes" xml:space="preserve">
          <source>In multithreaded environment, the value returned by use_count is approximate (typical implementations use a &lt;a href=&quot;../../atomic/memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt; load).</source>
          <target state="translated">En un entorno multiproceso, el valor devuelto por use_count es aproximado (las implementaciones t&amp;iacute;picas usan una carga &lt;a href=&quot;../../atomic/memory_order&quot;&gt;memory_order_relaxed&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b0b00c8c047435001bd2de135f45ca01beaae4c1" translate="yes" xml:space="preserve">
          <source>In namespace and block scope</source>
          <target state="translated">En el espacio de nombres y el alcance del bloque</target>
        </trans-unit>
        <trans-unit id="20891e1e3bb66c9419f1d516300d8501998694a6" translate="yes" xml:space="preserve">
          <source>In old or nonconforming compilers, using the &lt;a href=&quot;../language/operator_alternative&quot;&gt;alternative operator representations&lt;/a&gt; may still require including this header.</source>
          <target state="translated">En compiladores antiguos o no conformes, el uso de &lt;a href=&quot;../language/operator_alternative&quot;&gt;representaciones alternativas del operador&lt;/a&gt; a&amp;uacute;n puede requerir incluir este encabezado.</target>
        </trans-unit>
        <trans-unit id="976a60901e43304c76c9540f3f429a8d9f4c6a87" translate="yes" xml:space="preserve">
          <source>In order for a template to be instantiated, every template parameter (type, non-type, or template) must be replaced by a corresponding template argument. For &lt;a href=&quot;class_template&quot;&gt;class templates&lt;/a&gt;, the arguments are either explicitly provided, &lt;a href=&quot;deduction_guide&quot;&gt;deduced from the initializer&lt;/a&gt;, (since C++17) or defaulted. For &lt;a href=&quot;function_template&quot;&gt;function templates&lt;/a&gt;, the arguments are explicitly provided, &lt;a href=&quot;template_argument_deduction&quot;&gt;deduced from the context&lt;/a&gt;, or defaulted.</source>
          <target state="translated">Para que se pueda instanciar una plantilla, cada par&amp;aacute;metro de plantilla (tipo, no tipo o plantilla) debe reemplazarse por un argumento de plantilla correspondiente. Para &lt;a href=&quot;class_template&quot;&gt;las plantillas de clase&lt;/a&gt; , los argumentos se proporcionan expl&amp;iacute;citamente, se &lt;a href=&quot;deduction_guide&quot;&gt;deducen del inicializador&lt;/a&gt; (desde C ++ 17) o est&amp;aacute;n predeterminados. Para &lt;a href=&quot;function_template&quot;&gt;las plantillas de funci&amp;oacute;n&lt;/a&gt; , los argumentos se proporcionan expl&amp;iacute;citamente, se &lt;a href=&quot;template_argument_deduction&quot;&gt;deducen del contexto&lt;/a&gt; o est&amp;aacute;n predeterminados.</target>
        </trans-unit>
        <trans-unit id="2d740db339a5645df895be9040440821225a705c" translate="yes" xml:space="preserve">
          <source>In order for an exception to be caught, the throw-expression has to be inside a &lt;a href=&quot;try_catch&quot;&gt;try-block&lt;/a&gt; or inside a function called from a try-block, and there has to be a &lt;a href=&quot;try_catch&quot;&gt;catch clause&lt;/a&gt; that matches the type of the exception object.</source>
          <target state="translated">Para que se capture una excepci&amp;oacute;n, la expresi&amp;oacute;n de lanzamiento debe estar dentro de un &lt;a href=&quot;try_catch&quot;&gt;bloque try&lt;/a&gt; o dentro de una funci&amp;oacute;n llamada desde un bloque try, y debe haber una &lt;a href=&quot;try_catch&quot;&gt;cl&amp;aacute;usula catch&lt;/a&gt; que coincida con el tipo del objeto de excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b7a11d6633f27612217d043955d8513b0eaf805c" translate="yes" xml:space="preserve">
          <source>In order to compile a function call, the compiler must first perform &lt;a href=&quot;lookup&quot;&gt;name lookup&lt;/a&gt;, which, for functions, may involve &lt;a href=&quot;adl&quot;&gt;argument-dependent lookup&lt;/a&gt;, and for function templates may be followed by &lt;a href=&quot;template_argument_deduction&quot;&gt;template argument deduction&lt;/a&gt;. If these steps produce more than one</source>
          <target state="translated">Para compilar una llamada de funci&amp;oacute;n, el compilador primero debe realizar una &lt;a href=&quot;lookup&quot;&gt;b&amp;uacute;squeda de nombre&lt;/a&gt; , que, para las funciones, puede implicar &lt;a href=&quot;adl&quot;&gt;una b&amp;uacute;squeda dependiente de argumentos&lt;/a&gt; , y para las plantillas de funciones puede ir seguido de una &lt;a href=&quot;template_argument_deduction&quot;&gt;deducci&amp;oacute;n de argumentos de plantilla&lt;/a&gt; . Si estos pasos producen m&amp;aacute;s de uno</target>
        </trans-unit>
        <trans-unit id="c439dee89b66538a41331ba7addd781be9e95710" translate="yes" xml:space="preserve">
          <source>In order to examine all matches within the target sequence, &lt;code&gt;std::regex_search&lt;/code&gt; may be called in a loop, restarting each time from &lt;code&gt;m[0].second&lt;/code&gt; of the previous call. &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; offers an easy interface to this iteration.</source>
          <target state="translated">Para examinar todas las coincidencias dentro de la secuencia de destino, &lt;code&gt;std::regex_search&lt;/code&gt; puede llamarse en un bucle, reiniciando cada vez desde &lt;code&gt;m[0].second&lt;/code&gt; de la llamada anterior. &lt;code&gt;&lt;a href=&quot;regex_iterator&quot;&gt;std::regex_iterator&lt;/a&gt;&lt;/code&gt; ofrece una interfaz f&amp;aacute;cil para esta iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="93e5fcbc9e67b4e1b987a567473422ebf0dee92c" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;class_template&quot;&gt;class template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. In the following contexts the compiler will deduce the missing template arguments from the type of the initializer:</source>
          <target state="translated">Para crear una instancia de una &lt;a href=&quot;class_template&quot;&gt;plantilla de clase&lt;/a&gt; , se deben conocer todos los argumentos de la plantilla, pero no se debe especificar cada argumento de la plantilla. En los siguientes contextos, el compilador deducir&amp;aacute; los argumentos de plantilla faltantes del tipo de inicializador:</target>
        </trans-unit>
        <trans-unit id="9bf61b9c2f6c8ed792b21ac9dd2327e234ccbf15" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;a href=&quot;function_template&quot;&gt;function template&lt;/a&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted, when an address of a function template is taken, and in some &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;other contexts&lt;/a&gt;:</source>
          <target state="translated">Para crear una instancia de una &lt;a href=&quot;function_template&quot;&gt;plantilla de funci&amp;oacute;n&lt;/a&gt; , se debe conocer cada argumento de plantilla, pero no se debe especificar cada argumento de plantilla. Cuando sea posible, el compilador deducir&amp;aacute; los argumentos de plantilla faltantes de los argumentos de la funci&amp;oacute;n. Esto ocurre cuando se intenta una llamada de funci&amp;oacute;n, cuando se toma la direcci&amp;oacute;n de una plantilla de funci&amp;oacute;n y en algunos &lt;a href=&quot;template_argument_deduction#Other_contexts&quot;&gt;otros contextos&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="8076ca3c217ff4a7a98ccc16264bf0332155e2a1" translate="yes" xml:space="preserve">
          <source>In order to instantiate a &lt;strong&gt;function template&lt;/strong&gt;, every template argument must be known, but not every template argument has to be specified. When possible, the compiler will deduce the missing template arguments from the function arguments. This occurs when a function call is attempted and when an address of a function template is taken.</source>
          <target state="translated">Para crear una instancia de una &lt;strong&gt;plantilla de funci&amp;oacute;n&lt;/strong&gt; , se debe conocer cada argumento de plantilla, pero no se debe especificar cada argumento de plantilla. Cuando sea posible, el compilador deducir&amp;aacute; los argumentos de plantilla faltantes de los argumentos de la funci&amp;oacute;n. Esto ocurre cuando se intenta una llamada de funci&amp;oacute;n y cuando se toma la direcci&amp;oacute;n de una plantilla de funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ed244da1aecd793a261081beab12c67de2da00bb" translate="yes" xml:space="preserve">
          <source>In order to satisfy alignment requirements of all non-static members of a &lt;a href=&quot;class&quot;&gt;class&lt;/a&gt;,</source>
          <target state="translated">Para satisfacer los requisitos de alineaci&amp;oacute;n de todos los miembros no est&amp;aacute;ticos de una &lt;a href=&quot;class&quot;&gt;clase&lt;/a&gt; ,</target>
        </trans-unit>
        <trans-unit id="2dce1c16904fec9d3889052abdb4ab00a4c0f330" translate="yes" xml:space="preserve">
          <source>In order to satisfy the requirements of array-oriented access, an implementation is constrained to store the real and imaginary components of a &lt;code&gt;std::complex&lt;/code&gt; specialization in separate and adjacent memory locations. Possible declarations for its non-static data members include:</source>
          <target state="translated">Para satisfacer los requisitos de acceso orientado a matrices, una implementaci&amp;oacute;n est&amp;aacute; limitada a almacenar los componentes reales e imaginarios de una especializaci&amp;oacute;n &lt;code&gt;std::complex&lt;/code&gt; en ubicaciones de memoria separadas y adyacentes. Las posibles declaraciones para sus miembros de datos no est&amp;aacute;ticos incluyen:</target>
        </trans-unit>
        <trans-unit id="d223a004acbe8c2ee4258ddff41fb5bd9c563a88" translate="yes" xml:space="preserve">
          <source>In order to wait in a shared mutex in shared ownership mode, &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; can be used (&lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; requires &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; and so can only wait in unique ownership mode).</source>
          <target state="translated">Con el fin de esperar en un mutex compartida en el modo de propiedad compartida, &lt;code&gt;&lt;a href=&quot;condition_variable_any&quot;&gt;std::condition_variable_any&lt;/a&gt;&lt;/code&gt; se puede utilizar ( &lt;code&gt;&lt;a href=&quot;condition_variable&quot;&gt;std::condition_variable&lt;/a&gt;&lt;/code&gt; requiere &lt;code&gt;&lt;a href=&quot;unique_lock&quot;&gt;std::unique_lock&lt;/a&gt;&lt;/code&gt; por lo que s&amp;oacute;lo se puede esperar en el modo de propiedad &amp;uacute;nica).</target>
        </trans-unit>
        <trans-unit id="a0570d7fb641b108923426180a7da145cd589a42" translate="yes" xml:space="preserve">
          <source>In other words, &lt;code&gt;std::bind_front(f, bound_args...)(call_args...)&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(f, bound_args..., call_args....)&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, &lt;code&gt;std::bind_front(f, bound_args...)(call_args...)&lt;/code&gt; es equivalente a &lt;code&gt;&lt;a href=&quot;invoke&quot;&gt;std::invoke&lt;/a&gt;(f, bound_args..., call_args....)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9c4cf6f1de09d5243e6d12c4b6e447d38d42628" translate="yes" xml:space="preserve">
          <source>In other words, after replacing the type (e.g. an iterator type) in a well-formed non-aggregate initialization with &lt;code&gt;dangling&lt;/code&gt;, the resulting initialization is also well-formed.</source>
          <target state="translated">En otras palabras, despu&amp;eacute;s de reemplazar el tipo (por ejemplo, un tipo de iterador) en una inicializaci&amp;oacute;n no agregada bien formada con &lt;code&gt;dangling&lt;/code&gt; , la inicializaci&amp;oacute;n resultante tambi&amp;eacute;n est&amp;aacute; bien formada.</target>
        </trans-unit>
        <trans-unit id="2fdcde52c9613f8d9965c24cc761c64f7f29bbf9" translate="yes" xml:space="preserve">
          <source>In other words, if an algorithm takes a Predicate &lt;code&gt;pred&lt;/code&gt; and an iterator &lt;code&gt;first&lt;/code&gt;, it should be able to test the object of the type pointed to by the iterator &lt;code&gt;first&lt;/code&gt; using the given predicate via a construct like &lt;code&gt;if(pred(*first)) {...}&lt;/code&gt;.</source>
          <target state="translated">En otras palabras, si un algoritmo toma un Predicate &lt;code&gt;pred&lt;/code&gt; y un iterador &lt;code&gt;first&lt;/code&gt; , deber&amp;iacute;a poder probar el objeto del tipo se&amp;ntilde;alado por el iterador &lt;code&gt;first&lt;/code&gt; usando el predicado dado a trav&amp;eacute;s de una construcci&amp;oacute;n como &lt;code&gt;if(pred(*first)) {...}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="491de468bd659078aefdfec90cf19da2bcde4cae" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common reference type must preserve equality.</source>
          <target state="translated">En otras palabras,la conversión al tipo de referencia común debe preservar la igualdad.</target>
        </trans-unit>
        <trans-unit id="1515a939c60d7a0551eb77267cda9623a3ec082e" translate="yes" xml:space="preserve">
          <source>In other words, the conversion to the common type must preserve equality.</source>
          <target state="translated">En otras palabras,la conversión al tipo común debe preservar la igualdad.</target>
        </trans-unit>
        <trans-unit id="e7bf915fd2c7af366ac00ae6abbc509a778d1910" translate="yes" xml:space="preserve">
          <source>In other words, the summation operations may be performed in arbitrary order, and the behavior is nondeterministic if &lt;code&gt;binary_op&lt;/code&gt; is not associative.</source>
          <target state="translated">En otras palabras, las operaciones de suma pueden realizarse en orden arbitrario, y el comportamiento no es determinista si &lt;code&gt;binary_op&lt;/code&gt; no es asociativo.</target>
        </trans-unit>
        <trans-unit id="a80c785731fa7946b71b60f0a1b2f2901be26657" translate="yes" xml:space="preserve">
          <source>In overload (1), if &lt;code&gt;T&lt;/code&gt;'s move constructor is not &lt;code&gt;noexcept&lt;/code&gt; and T is not &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;, vector will use the throwing move constructor. If it throws, the guarantee is waived and the effects are unspecified.</source>
          <target state="translated">En la sobrecarga (1), si el constructor de movimiento de &lt;code&gt;T&lt;/code&gt; no est&amp;aacute; &lt;code&gt;noexcept&lt;/code&gt; y T no es &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; en &lt;code&gt;*this&lt;/code&gt; , vector usar&amp;aacute; el constructor de movimiento de lanzamiento. Si arroja, se renuncia a la garant&amp;iacute;a y los efectos no se especifican.</target>
        </trans-unit>
        <trans-unit id="da0255ac708e972224b54cc46137f223d8fcb17c" translate="yes" xml:space="preserve">
          <source>In particular, &lt;code&gt;std::move&lt;/code&gt; produces an &lt;a href=&quot;../language/value_category&quot;&gt;xvalue expression&lt;/a&gt; that identifies its argument &lt;code&gt;t&lt;/code&gt;. It is exactly equivalent to a static_cast to an rvalue reference type.</source>
          <target state="translated">En particular, &lt;code&gt;std::move&lt;/code&gt; produce una &lt;a href=&quot;../language/value_category&quot;&gt;expresi&amp;oacute;n xvalue&lt;/a&gt; que identifica su argumento &lt;code&gt;t&lt;/code&gt; . Es exactamente equivalente a un static_cast a un tipo de referencia rvalue.</target>
        </trans-unit>
        <trans-unit id="bc5f562f16c7f3516fd8ac3ab2d0a32811211b88" translate="yes" xml:space="preserve">
          <source>In particular, all hard links for the same file or directory are equivalent, and a symlink and its target on the same file system are equivalent.</source>
          <target state="translated">En particular,todos los enlaces duros para el mismo archivo o directorio son equivalentes,y un enlace simbólico y su objetivo en el mismo sistema de archivos son equivalentes.</target>
        </trans-unit>
        <trans-unit id="6c9eea59b15650f810d84d6038841dd320cdfa3e" translate="yes" xml:space="preserve">
          <source>In particular, for negative_sign of &lt;code&gt;&quot;-&quot;&lt;/code&gt;, the formatting may appear as &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt;, while for negative_sign of &lt;code&gt;&quot;()&quot;&lt;/code&gt; it would appear as &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt;.</source>
          <target state="translated">En particular, para el &lt;code&gt;&quot;-1.23 &amp;euro;&quot;&lt;/code&gt; negativo de &lt;code&gt;&quot;-&quot;&lt;/code&gt; , el formato puede aparecer como &quot;-1.23 &amp;euro;&quot; , mientras que para el signo negativo de &lt;code&gt;&quot;()&quot;&lt;/code&gt; aparecer&amp;aacute; como &lt;code&gt;&quot;(1.23 &amp;euro;)&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9805358780c9313bdf8b46c3d77f45f54ffa9c0" translate="yes" xml:space="preserve">
          <source>In particular, like all rvalues, xvalues bind to rvalue references, and like all glvalues, xvalues may be &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polymorphic&lt;/a&gt;, and non-class xvalues may be &lt;a href=&quot;cv&quot;&gt;cv-qualified&lt;/a&gt;.</source>
          <target state="translated">En particular, como todos los valores, los valores x se unen a las referencias de valor, y como todos los valores, los valores x pueden ser &lt;a href=&quot;objects#Polymorphic_objects&quot;&gt;polim&amp;oacute;rficos&lt;/a&gt; , y los valores x que no son de clase pueden ser &lt;a href=&quot;cv&quot;&gt;calificados por cv&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3440815d0cff772e37f45dd6a4e47c1dc0bf363e" translate="yes" xml:space="preserve">
          <source>In particular, non-copyable arguments and array to pointer conversion.</source>
          <target state="translated">En particular,los argumentos no copiables y la conversión de matriz a puntero.</target>
        </trans-unit>
        <trans-unit id="25d069cd55a0e3cbff6493480ec850fae36c0fdc" translate="yes" xml:space="preserve">
          <source>In particular, this implies that string literals, addresses of array elements, and addresses of non-static members cannot be used as template arguments to instantiate templates whose corresponding non-type template parameters are pointers to objects.</source>
          <target state="translated">En particular,esto implica que los literales de las cadenas,las direcciones de los elementos de la matriz y las direcciones de los miembros no estáticos no pueden utilizarse como argumentos de plantilla para instanciar plantillas cuyos correspondientes parámetros de plantillas no tipo son punteros a los objetos.</target>
        </trans-unit>
        <trans-unit id="16b8d6ec9c39d406c45bf8c3a95070cf38451515" translate="yes" xml:space="preserve">
          <source>In particular, this implies that the failures of constructors (see also &lt;a href=&quot;raii&quot;&gt;RAII&lt;/a&gt;) and most operators should be reported by throwing exceptions.</source>
          <target state="translated">En particular, esto implica que las fallas de los constructores (ver tambi&amp;eacute;n &lt;a href=&quot;raii&quot;&gt;RAII&lt;/a&gt; ) y la mayor&amp;iacute;a de los operadores deben informarse lanzando excepciones.</target>
        </trans-unit>
        <trans-unit id="6bd64e741fcbffe364b20bed2e39dc776e83f8c6" translate="yes" xml:space="preserve">
          <source>In particular, this implies that.</source>
          <target state="translated">En particular,esto implica que.</target>
        </trans-unit>
        <trans-unit id="7778e57383bfe144db5dc5276001e50344a7eb81" translate="yes" xml:space="preserve">
          <source>In practice, constant initialization is performed at compile time, and pre-calculated object representations are stored as part of the program image (e.g. in the &lt;code&gt;.data&lt;/code&gt; section). If a variable is both &lt;code&gt;const&lt;/code&gt; and constant-initialized, its object representation may be stored in a read-only section of the program image (e.g. the &lt;code&gt;.rodata&lt;/code&gt; section).</source>
          <target state="translated">En la pr&amp;aacute;ctica, la inicializaci&amp;oacute;n constante se realiza en tiempo de compilaci&amp;oacute;n, y las representaciones de objetos precalculadas se almacenan como parte de la imagen del programa (por ejemplo, en la secci&amp;oacute;n &lt;code&gt;.data&lt;/code&gt; ). Si una variable es &lt;code&gt;const&lt;/code&gt; ante y con inicializaci&amp;oacute;n constante, su representaci&amp;oacute;n de objeto puede almacenarse en una secci&amp;oacute;n de solo lectura de la imagen del programa (por ejemplo, la secci&amp;oacute;n &lt;code&gt;.rodata&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c5f7e6132c24b431ab05a1b29a68ed1255266ac7" translate="yes" xml:space="preserve">
          <source>In practice, implementations of &lt;code&gt;std::copy&lt;/code&gt; avoid multiple assignments and use bulk copy functions such as &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; if the value type is &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt;.</source>
          <target state="translated">En la pr&amp;aacute;ctica, las implementaciones de &lt;code&gt;std::copy&lt;/code&gt; evitan m&amp;uacute;ltiples asignaciones y usan funciones de copia masiva como &lt;code&gt;&lt;a href=&quot;../string/byte/memmove&quot;&gt;std::memmove&lt;/a&gt;&lt;/code&gt; si el tipo de valor es &lt;a href=&quot;../named_req/triviallycopyable&quot;&gt;TriviallyCopyable&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4166dd075003042b54540673bbf26b17c11851e9" translate="yes" xml:space="preserve">
          <source>In practice, they may be implemented as function objects, or with special compiler extensions.</source>
          <target state="translated">En la práctica,pueden implementarse como objetos de función,o con extensiones especiales del compilador.</target>
        </trans-unit>
        <trans-unit id="66affe68d971b057413c1675fbe61348d2fbb2ee" translate="yes" xml:space="preserve">
          <source>In practice, this means that the synchronized C++ streams are unbuffered, and each I/O operation on a C++ stream is immediately applied to the corresponding C stream's buffer. This makes it possible to freely mix C++ and C I/O.</source>
          <target state="translated">En la práctica,esto significa que los flujos sincronizados de C++no tienen búfer,y cada operación de E/S en un flujo de C++se aplica inmediatamente al búfer del flujo de C correspondiente.Esto permite mezclar libremente C++y E/S de C.</target>
        </trans-unit>
        <trans-unit id="a9d5344404c3cda159f179c91a199091db72dee1" translate="yes" xml:space="preserve">
          <source>In simple cases, both pImpl and factory method break compile-time dependency between the implementation and the users of the class interface. Factory method creates a hidden dependency on the vtable, and so reordering, adding, or removing virtual member functions breaks the ABI. The pImpl approach has no hidden dependencies, however if the implementation class is a class template specialization, the compilation firewall benefit is lost: the users of the interface must observe the entire template definition in order to instantiate the correct specialization. A common design approach in this case is to refactor the implementation in a way that avoids parametrization, this is another use case for the C++ Core Guidelines &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary&quot;&gt;T.61 Do not over-parametrize members&lt;/a&gt; and &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface&quot;&gt;T.84 Use a non-template core implementation to provide an ABI-stable interface&lt;/a&gt;.</source>
          <target state="translated">En casos simples, tanto pImpl como el m&amp;eacute;todo de f&amp;aacute;brica rompen la dependencia en tiempo de compilaci&amp;oacute;n entre la implementaci&amp;oacute;n y los usuarios de la interfaz de clase. El m&amp;eacute;todo de f&amp;aacute;brica crea una dependencia oculta en la tabla vtable, por lo que reordenar, agregar o eliminar funciones de miembros virtuales rompe la ABI. El enfoque pImpl no tiene dependencias ocultas, sin embargo, si la clase de implementaci&amp;oacute;n es una especializaci&amp;oacute;n de plantilla de clase, el beneficio del firewall de compilaci&amp;oacute;n se pierde: los usuarios de la interfaz deben observar la definici&amp;oacute;n completa de la plantilla para crear una instancia de la especializaci&amp;oacute;n correcta. Un enfoque de dise&amp;ntilde;o com&amp;uacute;n en este caso es refactorizar la implementaci&amp;oacute;n de una manera que evite la parametrizaci&amp;oacute;n, este es otro caso de uso para las Directrices principales de C ++ &lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#Rt-scary&quot;&gt;T.61 No sobre-parametrice a los miembros&lt;/a&gt; y&lt;a href=&quot;https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#t84-use-a-non-template-core-implementation-to-provide-an-abi-stable-interface&quot;&gt;T.84 Utilice una implementaci&amp;oacute;n central sin plantilla para proporcionar una interfaz estable ABI&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="e257383e8a791be56a7795dcfa164d94b6cff0ea" translate="yes" xml:space="preserve">
          <source>In some contexts, only type names can validly appear. In these contexts, a dependent qualified name is assumed to name a type and no &lt;code&gt;typename&lt;/code&gt; is required:</source>
          <target state="translated">En algunos contextos, solo los nombres de tipo pueden aparecer v&amp;aacute;lidamente. En estos contextos, un nombre calificado dependiente se supone que el nombre de un tipo y no &lt;code&gt;typename&lt;/code&gt; se requiere:</target>
        </trans-unit>
        <trans-unit id="b4f0ab4a86013d411969196467703372e7da8ad4" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are the 7-bit JIS, BOCU-1 and &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="translated">En algunas codificaciones multibyte, cualquier secuencia de caracteres multibyte dada puede representar diferentes caracteres dependiendo de las secuencias de bytes anteriores, conocidas como &quot;secuencias de desplazamiento&quot;. Dichas codificaciones se conocen como dependientes del estado: se requiere conocimiento del estado de cambio actual para interpretar cada car&amp;aacute;cter. Un NTMBS solo es v&amp;aacute;lido si comienza y termina en el estado de cambio inicial: si se us&amp;oacute; una secuencia de cambio, la secuencia de desplazamiento correspondiente debe estar presente antes del car&amp;aacute;cter nulo de terminaci&amp;oacute;n. Ejemplos de tales codificaciones son JIS de 7 bits, BOCU-1 y &lt;a href=&quot;http://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1ce53c84d0931440c6f3fc451cf445803c97d375" translate="yes" xml:space="preserve">
          <source>In some multibyte encodings, any given multibyte character sequence may represent different characters depending on the previous byte sequences, known as &quot;shift sequences&quot;. Such encodings are known as state-dependent: knowledge of the current shift state is required to interpret each character. An NTMBS is only valid if it begins and ends in the initial shift state: if a shift sequence was used, the corresponding unshift sequence has to be present before the terminating null character. Examples of such encodings are the 7-bit JIS, BOCU-1 and &lt;a href=&quot;https://www.unicode.org/reports/tr6&quot;&gt;SCSU&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="621567d318323c5c0c22b8501fb1f3c5e2acd90e" translate="yes" xml:space="preserve">
          <source>In such a nested declaration, some of the levels may remain unspecialized (except that it can't specialize a class member template if its enclosing class is unspecialized). For each of those levels, the declaration needs &lt;code&gt;template&amp;lt;arguments&amp;gt;&lt;/code&gt;, because such specializations are themselves templates:</source>
          <target state="translated">En una declaraci&amp;oacute;n anidada de este tipo, algunos de los niveles pueden permanecer sin especializar (excepto que no puede especializar una plantilla de miembro de clase si su clase adjunta no est&amp;aacute; especializada). Para cada uno de esos niveles, la declaraci&amp;oacute;n necesita una &lt;code&gt;template&amp;lt;arguments&amp;gt;&lt;/code&gt; , porque tales especializaciones son en s&amp;iacute; mismas plantillas:</target>
        </trans-unit>
        <trans-unit id="816350383b2c1e072a6ac4d701ae17bc019c55f8" translate="yes" xml:space="preserve">
          <source>In the C programming language, at least one named parameter must appear before the ellipsis parameter, so &lt;code&gt;printz(...);&lt;/code&gt; is not valid. In C++, this form is allowed even though the arguments passed to such function are not accessible, and is commonly used as the fallback overload in &lt;a href=&quot;sfinae&quot;&gt;SFINAE&lt;/a&gt;, exploiting the lowest priority of the ellipsis conversion in &lt;a href=&quot;overload_resolution&quot;&gt;overload resolution&lt;/a&gt;.</source>
          <target state="translated">En el lenguaje de programaci&amp;oacute;n C, al menos un par&amp;aacute;metro con nombre debe aparecer antes del par&amp;aacute;metro de puntos suspensivos, por lo que &lt;code&gt;printz(...);&lt;/code&gt; no es v&amp;aacute;lido. En C ++, este formulario est&amp;aacute; permitido a pesar de que los argumentos pasados ​​a dicha funci&amp;oacute;n no son accesibles, y se usa com&amp;uacute;nmente como la sobrecarga de &lt;a href=&quot;sfinae&quot;&gt;respaldo&lt;/a&gt; en SFINAE , explotando la prioridad m&amp;aacute;s baja de la conversi&amp;oacute;n de puntos suspensivos en la &lt;a href=&quot;overload_resolution&quot;&gt;resoluci&amp;oacute;n de sobrecarga&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7448b8bb4cfc9ef5b6d6148816f9abc314f332d" translate="yes" xml:space="preserve">
          <source>In the C programming language, the &lt;code&gt;goto&lt;/code&gt; statement has fewer restrictions and can enter the scope of any variable other than variable-length array or variably-modified pointer.</source>
          <target state="translated">En el lenguaje de programaci&amp;oacute;n C, la instrucci&amp;oacute;n &lt;code&gt;goto&lt;/code&gt; tiene menos restricciones y puede ingresar al alcance de cualquier variable que no sea una matriz de longitud variable o un puntero modificado de forma variable.</target>
        </trans-unit>
        <trans-unit id="11df4d5daefca94681eb0c6608609ae515a3f4d3" translate="yes" xml:space="preserve">
          <source>In the C programming language, the width of a bit field cannot exceed the width of the underlying type.</source>
          <target state="translated">En el lenguaje de programación C,el ancho de un campo de bits no puede exceder el ancho del tipo subyacente.</target>
        </trans-unit>
        <trans-unit id="bfc682244d852627ff0d041c2287a081b50d47c4" translate="yes" xml:space="preserve">
          <source>In the above example, if non-ADL lookup for operator&amp;lt;&amp;lt; were allowed from the instantiation context, the instantiation of &lt;code&gt;E::writeObject&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; would have two different definitions: one using &lt;code&gt;P1::operator&amp;lt;&amp;lt;&lt;/code&gt; and one using &lt;code&gt;P2::operator&amp;lt;&amp;lt;&lt;/code&gt;. Such ODR violation may not be detected by the linker, leading to one or the other being used in both instances.</source>
          <target state="translated">En el ejemplo anterior, si la b&amp;uacute;squeda de ADL para el operador &amp;lt;&amp;lt; fuera permitida desde el contexto de instanciaci&amp;oacute;n, la instanciaci&amp;oacute;n de &lt;code&gt;E::writeObject&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&lt;/code&gt; tendr&amp;iacute;a dos definiciones diferentes: una usando &lt;code&gt;P1::operator&amp;lt;&amp;lt;&lt;/code&gt; y otra usando &lt;code&gt;P2::operator&amp;lt;&amp;lt;&lt;/code&gt; . Es posible que el vinculador no detecte dicha violaci&amp;oacute;n de ODR, lo que lleva a que uno u otro se use en ambos casos.</target>
        </trans-unit>
        <trans-unit id="94f9ba60d2631df2a644921fed4cce7a6456d2d7" translate="yes" xml:space="preserve">
          <source>In the above,</source>
          <target state="translated">En lo anterior,</target>
        </trans-unit>
        <trans-unit id="f761fd1f890c95288965ab17065f5bc7b6d6b538" translate="yes" xml:space="preserve">
          <source>In the above, &lt;code&gt;Alloc&lt;/code&gt; is a type that satisfies &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt;or is a pointer type convertible to &lt;code&gt;std::experimental::pmr::memory_resource*&lt;/code&gt;(library fundamentals TS).</source>
          <target state="translated">En lo anterior, &lt;code&gt;Alloc&lt;/code&gt; es un tipo que satisface &lt;a href=&quot;../named_req/allocator&quot;&gt;Allocator&lt;/a&gt; o es un tipo de puntero convertible a &lt;code&gt;std::experimental::pmr::memory_resource*&lt;/code&gt; (fundamentos de la biblioteca TS).</target>
        </trans-unit>
        <trans-unit id="4cc61cf6708e3ef42bac60b85582a7b7be2f3f6f" translate="yes" xml:space="preserve">
          <source>In the body of a cv-qualified function, the &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt; pointer is cv-qualified, e.g. in a &lt;code&gt;const&lt;/code&gt; member function, only other const member functions may be called normally. (A non-const member function may still be called if &lt;a href=&quot;const_cast&quot;&gt;const_cast&lt;/a&gt; is applied or through an access path that does not involve &lt;a href=&quot;this&quot;&gt;this&lt;/a&gt;.).</source>
          <target state="translated">En el cuerpo de una funci&amp;oacute;n calificada por cv, &lt;a href=&quot;this&quot;&gt;este&lt;/a&gt; puntero est&amp;aacute; calificado por cv, por ejemplo, en una funci&amp;oacute;n miembro &lt;code&gt;const&lt;/code&gt; , solo se pueden llamar normalmente a otras funciones miembro const. (Todav&amp;iacute;a se puede llamar a una funci&amp;oacute;n miembro que no sea const si se aplica &lt;a href=&quot;const_cast&quot;&gt;const_cast&lt;/a&gt; o mediante una ruta de acceso que no implique &lt;a href=&quot;this&quot;&gt;esto&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="893e73a07f97db13bb810fec92b5bc2d9c3779e6" translate="yes" xml:space="preserve">
          <source>In the body of the loop, the following steps take place:</source>
          <target state="translated">En el cuerpo del bucle,tienen lugar los siguientes pasos:</target>
        </trans-unit>
        <trans-unit id="905f50bd3c725e6724b6b75435c36c4e71558664" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of a type parameter is a typedef-name which aliases the type supplied when the template is instantiated.</source>
          <target state="translated">En el cuerpo de la declaración de la plantilla,el nombre de un parámetro de tipo es un nombre tipedef que alias el tipo suministrado cuando la plantilla es instanciada.</target>
        </trans-unit>
        <trans-unit id="7218fc3a4992cbcd0152232cad3f51efabb5d84f" translate="yes" xml:space="preserve">
          <source>In the body of the template declaration, the name of this parameter is a template-name (and needs arguments to be instantiated).</source>
          <target state="translated">En el cuerpo de la declaración de la plantilla,el nombre de este parámetro es un nombre de plantilla (y necesita argumentos para ser instanciado).</target>
        </trans-unit>
        <trans-unit id="900936499efddab53cef702850868c269921a8b7" translate="yes" xml:space="preserve">
          <source>In the case of equality, as determined by &lt;code&gt;operator==&lt;/code&gt;, only lexical representations are compared. Therefore, &lt;code&gt;path(&quot;a&quot;) == path(&quot;b&quot;)&lt;/code&gt; is never &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">En el caso de la igualdad, seg&amp;uacute;n lo determinado por el &lt;code&gt;operator==&lt;/code&gt; , solo se comparan las representaciones l&amp;eacute;xicas. Por lo tanto, &lt;code&gt;path(&quot;a&quot;) == path(&quot;b&quot;)&lt;/code&gt; nunca es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ea417255bb9a3e4e66840a148e5a0eeb99a4a75" translate="yes" xml:space="preserve">
          <source>In the case of equivalence, as determined by &lt;a href=&quot;../equivalent&quot;&gt;&lt;code&gt;equivalent()&lt;/code&gt;&lt;/a&gt;, it is checked whether two paths</source>
          <target state="translated">En el caso de equivalencia, seg&amp;uacute;n lo determinado por &lt;a href=&quot;../equivalent&quot;&gt; &lt;code&gt;equivalent()&lt;/code&gt; &lt;/a&gt; , se verifica si dos caminos</target>
        </trans-unit>
        <trans-unit id="0918c8dba94ff6fd94b2510e1844c87eba4fa8bc" translate="yes" xml:space="preserve">
          <source>In the case of thrown exception, the states of the contained values of &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt; are determined by the exception safety guarantees of &lt;code&gt;swap&lt;/code&gt; of type &lt;code&gt;T&lt;/code&gt; or &lt;code&gt;T&lt;/code&gt;'s move constructor, whichever is called. For both &lt;code&gt;*this&lt;/code&gt; and &lt;code&gt;other&lt;/code&gt;, if the object contained a value, it is left containing a value, and the other way round.</source>
          <target state="translated">En el caso de una excepci&amp;oacute;n lanzada, los estados de los valores contenidos de &lt;code&gt;*this&lt;/code&gt; y &lt;code&gt;other&lt;/code&gt; est&amp;aacute;n determinados por las garant&amp;iacute;as de seguridad de excepci&amp;oacute;n del &lt;code&gt;swap&lt;/code&gt; del constructor de movimientos de tipo &lt;code&gt;T&lt;/code&gt; o &lt;code&gt;T&lt;/code&gt; , cualquiera que se llame. Tanto para &lt;code&gt;*this&lt;/code&gt; como para &lt;code&gt;other&lt;/code&gt; , si el objeto conten&amp;iacute;a un valor, se deja que contenga un valor, y viceversa.</target>
        </trans-unit>
        <trans-unit id="74253cd795fea072a07aa9a7e78a4232e8101c59" translate="yes" xml:space="preserve">
          <source>In the cases (1,2), virt-specifier-seq, if used, is either &lt;a href=&quot;override&quot;&gt;override&lt;/a&gt; or &lt;code&gt;final&lt;/code&gt;, or &lt;code&gt;final override&lt;/code&gt; or &lt;code&gt;override final&lt;/code&gt;. In the case (3), the only allowed value of class-virt-specifier, if used, is &lt;code&gt;final&lt;/code&gt;.</source>
          <target state="translated">En los casos (1,2), virt-specifier-seq, si se usa, es &lt;a href=&quot;override&quot;&gt;anulaci&amp;oacute;n&lt;/a&gt; o &lt;code&gt;final&lt;/code&gt; , o &lt;code&gt;final override&lt;/code&gt; o &lt;code&gt;override final&lt;/code&gt; . En el caso (3), el &amp;uacute;nico valor permitido de class-virt-specifier, si se usa, es &lt;code&gt;final&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64cdd0ab070b191de582e146726ae3b52445aff7" translate="yes" xml:space="preserve">
          <source>In the context of a &lt;a href=&quot;direct_initialization&quot;&gt;direct-initialization&lt;/a&gt;, a &lt;code&gt;bool&lt;/code&gt; object may be initialized from a prvalue of type &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt;, including &lt;code&gt;nullptr&lt;/code&gt;. The resulting value is &lt;code&gt;false&lt;/code&gt;. However, this is not considered to be an implicit conversion.</source>
          <target state="translated">En el contexto de una &lt;a href=&quot;direct_initialization&quot;&gt;inicializaci&amp;oacute;n directa&lt;/a&gt; , un objeto &lt;code&gt;bool&lt;/code&gt; se puede inicializar a partir de un valor de tipo &lt;code&gt;&lt;a href=&quot;../types/nullptr_t&quot;&gt;std::nullptr_t&lt;/a&gt;&lt;/code&gt; , incluido &lt;code&gt;nullptr&lt;/code&gt; . El valor resultante es &lt;code&gt;false&lt;/code&gt; . Sin embargo, esto no se considera una conversi&amp;oacute;n impl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="c2371f6402972bc45972f3f09d5d022fcbd00df0" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; are replaced with respective uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt;.</source>
          <target state="translated">En la configuraci&amp;oacute;n regional &quot;C&quot; predeterminada, las siguientes letras min&amp;uacute;sculas &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; se reemplazan con las letras may&amp;uacute;sculas respectivas &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f82450bef11bed620bb59a03e863ef7afabcdad8" translate="yes" xml:space="preserve">
          <source>In the default &quot;C&quot; locale, the following uppercase letters &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; are replaced with respective lowercase letters &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt;.</source>
          <target state="translated">En la configuraci&amp;oacute;n regional &quot;C&quot; predeterminada, las siguientes letras may&amp;uacute;sculas &lt;code&gt;ABCDEFGHIJKLMNOPQRSTUVWXYZ&lt;/code&gt; se reemplazan con las letras min&amp;uacute;sculas respectivas &lt;code&gt;abcdefghijklmnopqrstuvwxyz&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="27d01f4ee118275f671ea1fc69da0b10c876ae4d" translate="yes" xml:space="preserve">
          <source>In the definition above,</source>
          <target state="translated">En la definición anterior,</target>
        </trans-unit>
        <trans-unit id="b73a608fd45fbdf0b5c22a44851fbc673377e55d" translate="yes" xml:space="preserve">
          <source>In the definition of a constructor of a class,</source>
          <target state="translated">En la definición de un constructor de una clase,</target>
        </trans-unit>
        <trans-unit id="92eaf109eca502313374c00968739b34523e2380" translate="yes" xml:space="preserve">
          <source>In the definitions above,</source>
          <target state="translated">En las definiciones anteriores,</target>
        </trans-unit>
        <trans-unit id="817086841623d69755c18cd1a550bd17dbc9cec2" translate="yes" xml:space="preserve">
          <source>In the end, calls &lt;code&gt;str.width(0)&lt;/code&gt; to cancel the effects of any &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Al final, llama a &lt;code&gt;str.width(0)&lt;/code&gt; para cancelar los efectos de cualquier &lt;code&gt;&lt;a href=&quot;../../io/manip/setw&quot;&gt;std::setw&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c655d96839ca7780fa82778f8220c935df02845d" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.*E2&lt;/code&gt;:</source>
          <target state="translated">En la expresi&amp;oacute;n &lt;code&gt;E1.*E2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7b082767dd5ca682cdbd1f19496a9ffb37833f35" translate="yes" xml:space="preserve">
          <source>In the expression &lt;code&gt;E1.E2&lt;/code&gt;:</source>
          <target state="translated">En la expresi&amp;oacute;n &lt;code&gt;E1.E2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9db07dd430b24754012846b56b013710f95fae18" translate="yes" xml:space="preserve">
          <source>In the expression above, the identifier &lt;code&gt;swap&lt;/code&gt; is looked up in the same manner as the one used by the C++17 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; trait.</source>
          <target state="translated">En la expresi&amp;oacute;n anterior, el &lt;code&gt;swap&lt;/code&gt; identificador se busca de la misma manera que el utilizado por el rasgo C ++ 17 &lt;code&gt;&lt;a href=&quot;../../types/is_swappable&quot;&gt;std::is_nothrow_swappable&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e914c03795fc0434d207252646fcc5c2fbb853f" translate="yes" xml:space="preserve">
          <source>In the following cases the expression specifying the first dimension is erroneous:</source>
          <target state="translated">En los siguientes casos la expresión que especifica la primera dimensión es errónea:</target>
        </trans-unit>
        <trans-unit id="bb90da930e22170c110ed69983a4cd8c89699138" translate="yes" xml:space="preserve">
          <source>In the following cases, the injected-class-name is treated as a template-name of the class template itself:</source>
          <target state="translated">En los siguientes casos,el nombre de la clase inyectada se trata como un nombre de plantilla de la propia clase:</target>
        </trans-unit>
        <trans-unit id="6f57e7c031dc103138aa47aafe5169cd4d0818a3" translate="yes" xml:space="preserve">
          <source>In the following cases, the types, templates, and non-type values that are used to compose &lt;code&gt;P&lt;/code&gt; do not participate in template argument deduction, but instead</source>
          <target state="translated">En los siguientes casos, los tipos, plantillas y valores que no son de tipo que se usan para componer &lt;code&gt;P&lt;/code&gt; no participan en la deducci&amp;oacute;n de argumentos de plantilla, sino que</target>
        </trans-unit>
        <trans-unit id="18a089e2076eb0c963948461ded82840d2c5491f" translate="yes" xml:space="preserve">
          <source>In the following contexts ADL-only lookup (that is, lookup in associated namespaces only) takes place:</source>
          <target state="translated">En los siguientes contextos se realiza la búsqueda sólo de ADL (es decir,la búsqueda en los espacios de nombres asociados solamente):</target>
        </trans-unit>
        <trans-unit id="1e7e564013cddb0a744a7b7d9845915473666e88" translate="yes" xml:space="preserve">
          <source>In the following contexts, a context-specific type &lt;code&gt;T&lt;/code&gt; is expected, and the expression &lt;code&gt;e&lt;/code&gt; of class type &lt;code&gt;E&lt;/code&gt; is only allowed if &lt;code&gt;E&lt;/code&gt; has a single non-explicit &lt;a href=&quot;cast_operator&quot;&gt;user-defined conversion function&lt;/a&gt; to an allowable type(until C++14)there is exactly one type &lt;code&gt;T&lt;/code&gt; among the allowable types such that &lt;code&gt;E&lt;/code&gt; has non-explicit conversion functions whose return types are (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt; or reference to (possibly cv-qualified) &lt;code&gt;T&lt;/code&gt;, and &lt;code&gt;e&lt;/code&gt; is implicitly convertible to &lt;code&gt;T&lt;/code&gt;(since C++14). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">En los siguientes contextos, se espera un tipo &lt;code&gt;T&lt;/code&gt; espec&amp;iacute;fico de contexto , y la expresi&amp;oacute;n &lt;code&gt;e&lt;/code&gt; de la clase tipo &lt;code&gt;E&lt;/code&gt; solo se permite si &lt;code&gt;E&lt;/code&gt; tiene una &amp;uacute;nica &lt;a href=&quot;cast_operator&quot;&gt;funci&amp;oacute;n de conversi&amp;oacute;n definida por el usuario&lt;/a&gt; no expl&amp;iacute;cita a un tipo permitido (hasta C ++ 14) all&amp;iacute; es exactamente un tipo &lt;code&gt;T&lt;/code&gt; entre los tipos permitidos, de modo que &lt;code&gt;E&lt;/code&gt; tiene funciones de conversi&amp;oacute;n no expl&amp;iacute;citas cuyos tipos de retorno son (posiblemente calificados por cv) &lt;code&gt;T&lt;/code&gt; o referencia a (posiblemente calificados por cv) &lt;code&gt;T&lt;/code&gt; , y &lt;code&gt;e&lt;/code&gt; es impl&amp;iacute;citamente convertible a &lt;code&gt;T&lt;/code&gt; (ya que C ++ 14). Dicha expresi&amp;oacute;n &lt;code&gt;e&lt;/code&gt; se dice que es</target>
        </trans-unit>
        <trans-unit id="e9d454a482529bf2ee5e3a62d016e12659bf0446" translate="yes" xml:space="preserve">
          <source>In the following contexts, the type &lt;code&gt;bool&lt;/code&gt; is expected and the implicit conversion is performed if the declaration &lt;code&gt;bool t(e);&lt;/code&gt; is well-formed (that is, an explicit conversion function such as &lt;code&gt;explicit T::operator bool() const;&lt;/code&gt; is considered). Such expression &lt;code&gt;e&lt;/code&gt; is said to be</source>
          <target state="translated">En los siguientes contextos, se espera el tipo &lt;code&gt;bool&lt;/code&gt; y la conversi&amp;oacute;n impl&amp;iacute;cita se realiza si la declaraci&amp;oacute;n &lt;code&gt;bool t(e);&lt;/code&gt; est&amp;aacute; bien formado (es decir, se considera una funci&amp;oacute;n de conversi&amp;oacute;n expl&amp;iacute;cita como &lt;code&gt;explicit T::operator bool() const;&lt;/code&gt; ). Dicha expresi&amp;oacute;n &lt;code&gt;e&lt;/code&gt; se dice que es</target>
        </trans-unit>
        <trans-unit id="e8e08b92d2240f4a88c69d4e69a8df8c00816b49" translate="yes" xml:space="preserve">
          <source>In the following examples, the fictitious arguments will be called U1, U2.</source>
          <target state="translated">En los siguientes ejemplos,los argumentos ficticios se llamarán U1,U2.</target>
        </trans-unit>
        <trans-unit id="2ebb63b824c4cdb079972404f91cbe60baeddcf6" translate="yes" xml:space="preserve">
          <source>In the implementation used to execute this example, overflow() over-allocates the put area to 512 bytes: a call to str() would only return the four initialized bytes, but the next 508 calls to sputc() would not require new calls to overflow().</source>
          <target state="translated">En la implementación utilizada para ejecutar este ejemplo,overflow()sobreasigna el área de put a 512 bytes:una llamada a str()sólo devolvería los cuatro bytes inicializados,pero las siguientes 508 llamadas a sputc()no requerirían nuevas llamadas a overflow().</target>
        </trans-unit>
        <trans-unit id="f8c299b36b8a4498bc3547746db843fd4f953399" translate="yes" xml:space="preserve">
          <source>In the initialization of a variable, when the initializer expression is a &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the variable type:</source>
          <target state="translated">En la inicializaci&amp;oacute;n de una variable, cuando la expresi&amp;oacute;n inicializadora es un &lt;a href=&quot;value_category&quot;&gt;prvalue&lt;/a&gt; del mismo tipo de clase (ignorando &lt;a href=&quot;cv&quot;&gt;la calificaci&amp;oacute;n cv&lt;/a&gt; ) que el tipo de variable:</target>
        </trans-unit>
        <trans-unit id="27c642266c0731a2e8f833d8f0a3ec3946651726" translate="yes" xml:space="preserve">
          <source>In the initialization of an object, when the source object is a nameless temporary and is of the same class type (ignoring &lt;a href=&quot;cv&quot;&gt;cv-qualification&lt;/a&gt;) as the target object. When the nameless temporary is the operand of a return statement, this variant of copy elision is known as RVO, &quot;return value optimization&quot;.</source>
          <target state="translated">En la inicializaci&amp;oacute;n de un objeto, cuando el objeto de origen es un temporal sin nombre y es del mismo tipo de clase (ignorando &lt;a href=&quot;cv&quot;&gt;la calificaci&amp;oacute;n cv&lt;/a&gt; ) que el objeto de destino. Cuando el temporal sin nombre es el operando de una declaraci&amp;oacute;n de retorno, esta variante de copia de elisi&amp;oacute;n se conoce como RVO, &quot;optimizaci&amp;oacute;n del valor de retorno&quot;.</target>
        </trans-unit>
        <trans-unit id="5c373829034265c5b0e2556da1a4e7ca6ed3781b" translate="yes" xml:space="preserve">
          <source>In the integer and floating-point digit sequences, optional separators &lt;code&gt;'&lt;/code&gt; are allowed between any two digits and are ignored</source>
          <target state="translated">En las secuencias de d&amp;iacute;gitos enteros y de coma flotante, los separadores opcionales &lt;code&gt;'&lt;/code&gt; se permite entre dos d&amp;iacute;gitos y se ignoran</target>
        </trans-unit>
        <trans-unit id="1597dcf21e743f45fe04b66865d76eb95469ddd2" translate="yes" xml:space="preserve">
          <source>In the published C++11 and C++14 standards, this function was specified to require &lt;code&gt;mapped_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; and &lt;code&gt;key_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;. This specification was defective and was fixed by &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;LWG issue 2469&lt;/a&gt;, and the description above incorporates the resolution of that issue.</source>
          <target state="translated">En los est&amp;aacute;ndares publicados C ++ 11 y C ++ 14, esta funci&amp;oacute;n se especific&amp;oacute; para requerir que &lt;code&gt;mapped_type&lt;/code&gt; sea &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; y &lt;code&gt;key_type&lt;/code&gt; sea &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; o &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; en &lt;code&gt;*this&lt;/code&gt; . Esta especificaci&amp;oacute;n era defectuosa y fue corregida por el &lt;a href=&quot;http://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;problema 2469 de LWG&lt;/a&gt; , y la descripci&amp;oacute;n anterior incorpora la resoluci&amp;oacute;n de ese problema.</target>
        </trans-unit>
        <trans-unit id="27a6c22d4c82c1acd2252a8c6e5b33af7b1999a8" translate="yes" xml:space="preserve">
          <source>In the published C++11 and C++14 standards, this function was specified to require &lt;code&gt;mapped_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/defaultinsertable&quot;&gt;DefaultInsertable&lt;/a&gt; and &lt;code&gt;key_type&lt;/code&gt; to be &lt;a href=&quot;../../named_req/copyinsertable&quot;&gt;CopyInsertable&lt;/a&gt; or &lt;a href=&quot;../../named_req/moveinsertable&quot;&gt;MoveInsertable&lt;/a&gt; into &lt;code&gt;*this&lt;/code&gt;. This specification was defective and was fixed by &lt;a href=&quot;https://cplusplus.github.io/LWG/lwg-defects.html#2469&quot;&gt;LWG issue 2469&lt;/a&gt;, and the description above incorporates the resolution of that issue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984b95b188d8b6ed51c0929b5bbcca151d81d732" translate="yes" xml:space="preserve">
          <source>In the second form of if statement (the one including else), if statement-true is also an if statement then that inner if statement must contain an else part as well (in other words, in nested if-statements, the else is associated with the closest if that doesn't have an else).</source>
          <target state="translated">En la segunda forma de declaración if (la que incluye otro),si la declaración-verdadera es también una declaración if,entonces esa declaración if interna debe contener también otra parte (en otras palabras,en las declaraciones if anidadas,la otra se asocia con la más cercana si no tiene otra parte).</target>
        </trans-unit>
        <trans-unit id="b7c2588aa39c2094ccbf6764f2545ff5d48d7081" translate="yes" xml:space="preserve">
          <source>In the unary-binary overload (3,6), &lt;code&gt;unary_op&lt;/code&gt; is not applied to &lt;code&gt;init&lt;/code&gt;.</source>
          <target state="translated">En la sobrecarga binaria unaria (3,6), &lt;code&gt;unary_op&lt;/code&gt; no se aplica a &lt;code&gt;init&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f46af473d10885afbc17d62f3973969b56f43750" translate="yes" xml:space="preserve">
          <source>In these initializer expressions, &lt;code&gt;e&lt;/code&gt; is an lvalue if the type of the entity &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; is an lvalue reference (this only happens if the ref-operator is &lt;code&gt;&amp;amp;&lt;/code&gt; or if it is &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and the initializer expression is an lvalue) and an xvalue otherwise (this effectively performs a kind of perfect forwarding), &lt;code&gt;i&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; prvalue, and &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; is always interpreted as a template parameter list.</source>
          <target state="translated">En estas expresiones inicializadoras, &lt;code&gt;e&lt;/code&gt; es un valor l si el tipo de la entidad &lt;code&gt;&lt;i&gt;e&lt;/i&gt;&lt;/code&gt; es una referencia lvalue (esto solo sucede si el operador ref es &lt;code&gt;&amp;amp;&lt;/code&gt; o si es &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y la expresi&amp;oacute;n inicializadora es un valor l) y un valor x de lo contrario (esto realiza efectivamente un tipo de reenv&amp;iacute;o perfecto), &lt;code&gt;i&lt;/code&gt; es un valor est&amp;aacute;ndar &lt;code&gt;&lt;a href=&quot;../types/size_t&quot;&gt;std::size_t&lt;/a&gt;&lt;/code&gt; , y &lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt; siempre se interpreta como una lista de par&amp;aacute;metros de plantilla.</target>
        </trans-unit>
        <trans-unit id="5edaaa50a68b7de4d405f0db9e2d071386701607" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; F in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after Y.</source>
          <target state="translated">En este caso, todas las reservas at&amp;oacute;micas no at&amp;oacute;micas y relajadas que se &lt;a href=&quot;memory_order&quot;&gt;secuencian antes de&lt;/a&gt; F en el hilo A &lt;a href=&quot;memory_order&quot;&gt;suceder&amp;aacute;n antes de&lt;/a&gt; todas las cargas at&amp;oacute;micas no at&amp;oacute;micas y relajadas de las mismas ubicaciones realizadas en el hilo B despu&amp;eacute;s de Y.</target>
        </trans-unit>
        <trans-unit id="0a4cf3adc0dea1f1e86d6ff23d2e32a0caa67f56" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; FA in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after FB.</source>
          <target state="translated">En este caso, todas las reservas at&amp;oacute;micas no at&amp;oacute;micas y relajadas que se &lt;a href=&quot;memory_order&quot;&gt;secuencian antes de&lt;/a&gt; FA en el subproceso A &lt;a href=&quot;memory_order&quot;&gt;suceder&amp;aacute;n antes de&lt;/a&gt; todas las cargas at&amp;oacute;micas no at&amp;oacute;micas y relajadas de las mismas ubicaciones realizadas en el subproceso B despu&amp;eacute;s de FB.</target>
        </trans-unit>
        <trans-unit id="8725b52d3c1fdf65bcce6d3f222c3cb193f19490" translate="yes" xml:space="preserve">
          <source>In this case, all non-atomic and relaxed atomic stores that are &lt;a href=&quot;memory_order&quot;&gt;sequenced-before&lt;/a&gt; X in thread A will &lt;a href=&quot;memory_order&quot;&gt;happen-before&lt;/a&gt; all non-atomic and relaxed atomic loads from the same locations made in thread B after F.</source>
          <target state="translated">En este caso, todas las reservas at&amp;oacute;micas no at&amp;oacute;micas y relajadas que se &lt;a href=&quot;memory_order&quot;&gt;secuencian antes de&lt;/a&gt; X en el hilo A &lt;a href=&quot;memory_order&quot;&gt;suceder&amp;aacute;n antes de&lt;/a&gt; todas las cargas at&amp;oacute;micas no at&amp;oacute;micas y relajadas de las mismas ubicaciones realizadas en el hilo B despu&amp;eacute;s de F.</target>
        </trans-unit>
        <trans-unit id="c0eb534d99bfe7cabd6fc507165a3b864a58be3c" translate="yes" xml:space="preserve">
          <source>In this case, the keyword</source>
          <target state="translated">En este caso,la palabra clave</target>
        </trans-unit>
        <trans-unit id="353019d63051611e784bf71d2adc4b77fb808f2b" translate="yes" xml:space="preserve">
          <source>In this case, the member of any specialization of A becomes a friend. This does not involve instantiating the primary template A: the only requirements are that the deduction of the template parameters of A from that specialization succeeds, and that substitution of the deduced template arguments into the friend declaration produces a declaration that would be a valid redeclaration of the member of the specialization:</source>
          <target state="translated">En este caso,el miembro de cualquier especialización de A se convierte en un amigo.No se trata de instanciar la plantilla primaria A:los únicos requisitos son que la deducción de los parámetros de la plantilla de A de esa especialización tenga éxito,y que la sustitución de los argumentos de la plantilla deducidos en la declaración de amigo produzca una declaración que sea una redeclaración válida del miembro de la especialización:</target>
        </trans-unit>
        <trans-unit id="216570cc099d91d9e8fcba19ae0d75946676ed16" translate="yes" xml:space="preserve">
          <source>In this case, the target constructor is selected by overload resolution and executed first, then the control returns to the delegating constructor and its body is executed.</source>
          <target state="translated">En este caso,el constructor objetivo es seleccionado por resolución de sobrecarga y ejecutado primero,luego el control regresa al constructor delegado y su cuerpo es ejecutado.</target>
        </trans-unit>
        <trans-unit id="06f9e15b2ae9be584dce74848cf7b7f2676331fc" translate="yes" xml:space="preserve">
          <source>In this example, initial allocation of the underlying array was for 16 bytes.</source>
          <target state="translated">En este ejemplo,la asignación inicial de la matriz subyacente fue de 16 bytes.</target>
        </trans-unit>
        <trans-unit id="330c586d17d06314846a2d3fffc6301809c539ee" translate="yes" xml:space="preserve">
          <source>In this example, two values that compare equal under this comparison (which is case-insensitive on the member &lt;code&gt;name&lt;/code&gt; can be distinguished by functions that are case-sensitive:</source>
          <target state="translated">En este ejemplo, dos valores que se comparan igual bajo esta comparaci&amp;oacute;n (que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas en el &lt;code&gt;name&lt;/code&gt; del miembro se pueden distinguir por funciones que distinguen entre may&amp;uacute;sculas y min&amp;uacute;sculas:</target>
        </trans-unit>
        <trans-unit id="ff5a35c9480e5a35d467f9e8b2a4ffafdc16c703" translate="yes" xml:space="preserve">
          <source>In those situations where copy assignment cannot benefit from resource reuse (it does not manage a heap-allocated array and does not have a (possibly transitive) member that does, such as a member &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt;), there is a popular convenient shorthand: the copy-and-swap assignment operator, which takes its parameter by value (thus working as both copy- and move-assignment depending on the value category of the argument), swaps with the parameter, and lets the destructor clean it up.</source>
          <target state="translated">En aquellas situaciones en las que la asignaci&amp;oacute;n de copias no puede beneficiarse de la reutilizaci&amp;oacute;n de recursos (no administra una matriz asignada en el mont&amp;oacute;n y no tiene un miembro (posiblemente transitivo) que s&amp;iacute; lo tenga, como un miembro &lt;code&gt;&lt;a href=&quot;../container/vector&quot;&gt;std::vector&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../string/basic_string&quot;&gt;std::string&lt;/a&gt;&lt;/code&gt; ), all&amp;iacute; es una abreviatura conveniente y popular: el operador de asignaci&amp;oacute;n de copiar y cambiar, que toma su par&amp;aacute;metro por valor (por lo tanto, funciona como asignaci&amp;oacute;n de copia y movimiento seg&amp;uacute;n la categor&amp;iacute;a de valor del argumento), intercambia con el par&amp;aacute;metro y permite destructor limpiarlo.</target>
        </trans-unit>
        <trans-unit id="44d42e4e7cdc63f569100975fee76f3a07f480d3" translate="yes" xml:space="preserve">
          <source>In typical usage, &lt;code&gt;count&lt;/code&gt; is the size of the destination array.</source>
          <target state="translated">En uso t&amp;iacute;pico, &lt;code&gt;count&lt;/code&gt; es el tama&amp;ntilde;o de la matriz de destino.</target>
        </trans-unit>
        <trans-unit id="4027a85dd787fe56399bbb11ac7adf2fe0eee28f" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error. &lt;code&gt;eof()&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;fail&quot;&gt;fail()&lt;/a&gt;&lt;/code&gt; can then be used to distinguish between different error conditions.</source>
          <target state="translated">En el uso t&amp;iacute;pico, el procesamiento del flujo de entrada se detiene ante cualquier error. &lt;code&gt;eof()&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;fail&quot;&gt;fail()&lt;/a&gt;&lt;/code&gt; se pueden usar para distinguir entre diferentes condiciones de error.</target>
        </trans-unit>
        <trans-unit id="1c6002149b8d6c5a43ae8ee73b0dbdfdf5535c0c" translate="yes" xml:space="preserve">
          <source>In typical usage, input stream processing stops on any error; &lt;code&gt;feof&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; are then used to distinguish between different error conditions.</source>
          <target state="translated">En el uso t&amp;iacute;pico, el procesamiento del flujo de entrada se detiene ante cualquier error; &lt;code&gt;feof&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;ferror&quot;&gt;std::ferror&lt;/a&gt;&lt;/code&gt; se utilizan para distinguir entre diferentes condiciones de error.</target>
        </trans-unit>
        <trans-unit id="21e3e82b3a013fa09de3345372c2bcda63c11cf0" translate="yes" xml:space="preserve">
          <source>In typical use cases, this function is the last thing called by a detached thread.</source>
          <target state="translated">En los casos típicos de uso,esta función es la última cosa llamada por un hilo suelto.</target>
        </trans-unit>
        <trans-unit id="7790a0c7a8cccc64f38d56e2325db218d5c6811d" translate="yes" xml:space="preserve">
          <source>Inappropriate I/O control operation</source>
          <target state="translated">Operación de control de E/S inapropiada</target>
        </trans-unit>
        <trans-unit id="db54974f7f0ad531e35648ba85b9388029b4d7ef" translate="yes" xml:space="preserve">
          <source>Includes</source>
          <target state="translated">Includes</target>
        </trans-unit>
        <trans-unit id="8705867aeef60bcf6e033673dc025bf70ea7c829" translate="yes" xml:space="preserve">
          <source>Includes January 4</source>
          <target state="translated">Incluye el 4 de enero</target>
        </trans-unit>
        <trans-unit id="ea5fdcf7120862d98b9dd3dd4a179e2277f2b2e6" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;a href=&quot;memory/new/operator_new&quot;&gt;&lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt;, &lt;a href=&quot;memory/new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt;, &lt;code&gt;&lt;a href=&quot;memory/new/set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Incluye, por ejemplo, &lt;a href=&quot;memory/new/operator_new&quot;&gt; &lt;code&gt;operator new&lt;/code&gt; &lt;/a&gt; , &lt;a href=&quot;memory/new/operator_delete&quot;&gt; &lt;code&gt;operator delete&lt;/code&gt; &lt;/a&gt; , &lt;code&gt;&lt;a href=&quot;memory/new/set_new_handler&quot;&gt;std::set_new_handler&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbc9d5a2379fe53e6888d69ff2cfd239b49d1c65" translate="yes" xml:space="preserve">
          <source>Includes e.g. &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;memory/c/free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Incluye, por ejemplo, &lt;code&gt;&lt;a href=&quot;memory/c/malloc&quot;&gt;std::malloc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;memory/c/free&quot;&gt;std::free&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1e25648908297ca3a4ff1a029bba15e376074f7a" translate="yes" xml:space="preserve">
          <source>Includes first Thursday of the year</source>
          <target state="translated">Incluye el primer jueves del año</target>
        </trans-unit>
        <trans-unit id="2effbb73909ece6a25dcb3109ac70345242cea64" translate="yes" xml:space="preserve">
          <source>Includes other source file into current source file at the line immediately after the directive.</source>
          <target state="translated">Incluye otro archivo de fuente en el archivo de fuente actual en la línea inmediatamente después de la directiva.</target>
        </trans-unit>
        <trans-unit id="28d47aeec93ecafec39966de5877d68ae0fa0071" translate="yes" xml:space="preserve">
          <source>Including &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; behaves as if it defines a static storage duration object of type &lt;code&gt;&lt;a href=&quot;../io/ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt;, whose constructor initializes the standard stream objects if it is the first &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be constructed, and whose destructor flushes those objects (except for &lt;code&gt;cin&lt;/code&gt; and &lt;code&gt;wcin&lt;/code&gt;) if it is the last &lt;code&gt;std::ios_base::Init&lt;/code&gt; object to be destroyed.</source>
          <target state="translated">La inclusi&amp;oacute;n de &lt;code&gt;&amp;lt;iostream&amp;gt;&lt;/code&gt; se comporta como si define un objeto de duraci&amp;oacute;n de almacenamiento est&amp;aacute;tico de tipo &lt;code&gt;&lt;a href=&quot;../io/ios_base/init&quot;&gt;std::ios_base::Init&lt;/a&gt;&lt;/code&gt; , cuyo constructor inicializa los objetos de flujo est&amp;aacute;ndar si es el primer objeto &lt;code&gt;std::ios_base::Init&lt;/code&gt; que se construir&amp;aacute;, y cuyo destructor limpia esos objetos (excepto &lt;code&gt;cin&lt;/code&gt; y &lt;code&gt;wcin&lt;/code&gt; ) si es el &amp;uacute;ltimo objeto &lt;code&gt;std::ios_base::Init&lt;/code&gt; que se destruir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="5cd1c15a802ac17b19b885143fcfe2ec21636c5b" translate="yes" xml:space="preserve">
          <source>Including &lt;strong&gt;&lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/strong&gt; also defines all &lt;a href=&quot;../feature_test#Library_features&quot;&gt;library feature-testing macros&lt;/a&gt;.</source>
          <target state="translated">La inclusi&amp;oacute;n de &lt;strong&gt; &lt;code&gt;&amp;lt;version&amp;gt;&lt;/code&gt; &lt;/strong&gt; tambi&amp;eacute;n define todas &lt;a href=&quot;../feature_test#Library_features&quot;&gt;las macros de prueba de caracter&amp;iacute;sticas de la biblioteca&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1221ac54217af05f258b4f8aa9f00478c543372d" translate="yes" xml:space="preserve">
          <source>Incomparable values are..</source>
          <target state="translated">Los valores incomparables son..</target>
        </trans-unit>
        <trans-unit id="1ab3146cdd793eb63530b9c56d89f5648c4b83e9" translate="yes" xml:space="preserve">
          <source>Incomplete type</source>
          <target state="translated">Tipo incompleto</target>
        </trans-unit>
        <trans-unit id="38e49d07d428f67ddcca69cc70a81d4cae36a937" translate="yes" xml:space="preserve">
          <source>Increase the capacity of the vector to a value that's greater or equal to &lt;code&gt;new_cap&lt;/code&gt;. If &lt;code&gt;new_cap&lt;/code&gt; is greater than the current &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt;, new storage is allocated, otherwise the method does nothing.</source>
          <target state="translated">Aumente la capacidad del vector a un valor que sea mayor o igual a &lt;code&gt;new_cap&lt;/code&gt; . Si &lt;code&gt;new_cap&lt;/code&gt; es mayor que la &lt;code&gt;&lt;a href=&quot;capacity&quot;&gt;capacity()&lt;/a&gt;&lt;/code&gt; actual () , se asigna nuevo almacenamiento; de lo contrario, el m&amp;eacute;todo no hace nada.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
