<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="d4dfea1ce63878f9ba8f72e4692fc1e8aa917a62" translate="yes" xml:space="preserve">
          <source>If the port command is aborted, &lt;code&gt;false&lt;/code&gt; is returned, otherwise &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si se cancela el comando de puerto, se devuelve &lt;code&gt;false&lt;/code&gt; ; de lo contrario, &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1c15fb5c83bfc2a91269d248f12f67e81fee63b" translate="yes" xml:space="preserve">
          <source>If the port driver does not support synchronous control operations.</source>
          <target state="translated">Si el controlador del puerto no soporta operaciones de control sincrónico.</target>
        </trans-unit>
        <trans-unit id="0d0817e3d68cbd798c7a2e44b1c69c87bcdb5eaf" translate="yes" xml:space="preserve">
          <source>If the port driver so decides for any reason (probably something wrong with &lt;code&gt;Operation&lt;/code&gt; or &lt;code&gt;Data&lt;/code&gt;).</source>
          <target state="translated">Si el controlador del puerto as&amp;iacute; lo decide por cualquier motivo (probablemente hay alg&amp;uacute;n problema con la &lt;code&gt;Operation&lt;/code&gt; o los &lt;code&gt;Data&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6d151f89de14a3a981ce006759dc3e5172e69a5a" translate="yes" xml:space="preserve">
          <source>If the port has terminated for some reason.</source>
          <target state="translated">Si el puerto ha terminado por alguna razón.</target>
        </trans-unit>
        <trans-unit id="478c30ae507a35c9772a0df1cd3d96a72d57ca57" translate="yes" xml:space="preserve">
          <source>If the port identified by &lt;code&gt;Port&lt;/code&gt; is not open, &lt;code&gt;undefined&lt;/code&gt; is returned. If the port is closed and the calling process was previously linked to the port, the exit signal from the port is guaranteed to be delivered before &lt;code&gt;port_info/2&lt;/code&gt; returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Si el puerto identificado por &lt;code&gt;Port&lt;/code&gt; no est&amp;aacute; abierto, se devuelve &lt;code&gt;undefined&lt;/code&gt; . Si el puerto est&amp;aacute; cerrado y el proceso de llamada se vincul&amp;oacute; previamente al puerto, se garantiza que la se&amp;ntilde;al de salida del puerto se entregar&amp;aacute; antes de que &lt;code&gt;port_info/2&lt;/code&gt; regrese &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="853a76f0837b416b340a6bf46f68d0b7ffc26aa7" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy any more.</source>
          <target state="translated">Si el puerto está ocupado,el proceso de llamada se suspende hasta que el puerto ya no esté ocupado.</target>
        </trans-unit>
        <trans-unit id="8e93ad76f9dc1354beffe48343ad7231e136396f" translate="yes" xml:space="preserve">
          <source>If the port is busy, the calling process is suspended until the port is not busy anymore.</source>
          <target state="translated">Si el puerto está ocupado,el proceso de llamada se suspende hasta que el puerto ya no esté ocupado.</target>
        </trans-unit>
        <trans-unit id="6e75c78d0feb81a1196647eabb58d38723b98522" translate="yes" xml:space="preserve">
          <source>If the port program closes its &lt;code&gt;stdout&lt;/code&gt; without exiting, option &lt;code&gt;exit_status&lt;/code&gt; does not work.</source>
          <target state="translated">Si el programa de puerto cierra su &lt;code&gt;stdout&lt;/code&gt; sin salir, la opci&amp;oacute;n &lt;code&gt;exit_status&lt;/code&gt; no funciona.</target>
        </trans-unit>
        <trans-unit id="db113293208f7fe3c23990353c9eaabbd0d53db0" translate="yes" xml:space="preserve">
          <source>If the port program is to be updated, the code for the &lt;code&gt;gen_server&lt;/code&gt; can be extended with a &lt;code&gt;code_change&lt;/code&gt; function, which closes the old port and opens a new port. (If necessary, the &lt;code&gt;gen_server&lt;/code&gt; can first request data that must be saved from the port program and pass this data to the new port):</source>
          <target state="translated">Si se va a actualizar el programa del puerto, el c&amp;oacute;digo para &lt;code&gt;gen_server&lt;/code&gt; se puede ampliar con una funci&amp;oacute;n &lt;code&gt;code_change&lt;/code&gt; , que cierra el puerto antiguo y abre un puerto nuevo. (Si es necesario, &lt;code&gt;gen_server&lt;/code&gt; puede solicitar primero datos que deben guardarse del programa de puerto y pasar estos datos al nuevo puerto):</target>
        </trans-unit>
        <trans-unit id="38a0c5b075f7274afd3c7af203177b865a7ca3d6" translate="yes" xml:space="preserve">
          <source>If the process calling &lt;code&gt;erlang:resume_process/1&lt;/code&gt; had not previously increased the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt;.</source>
          <target state="translated">Si el proceso que llama a &lt;code&gt;erlang:resume_process/1&lt;/code&gt; no hab&amp;iacute;a aumentado previamente el recuento de suspensiones en el proceso identificado por &lt;code&gt;Suspendee&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9584990023c5a96bcc22ea4479bca2d11aee6db9" translate="yes" xml:space="preserve">
          <source>If the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;Ret = {error, Reason}&lt;/code&gt; will be returned if the calling process traps exits.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dde4932a93f8e946ee90206f0656471a4679385" translate="yes" xml:space="preserve">
          <source>If the process does not exist, a &lt;code&gt;noproc&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si el proceso no existe, se &lt;code&gt;noproc&lt;/code&gt; una excepci&amp;oacute;n noproc .</target>
        </trans-unit>
        <trans-unit id="20b1fa7364ea436067720e9fd90a1b6ba70feb9e" translate="yes" xml:space="preserve">
          <source>If the process executing the call does not belong to any application, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Si el proceso que ejecuta la llamada no pertenece a ninguna aplicaci&amp;oacute;n, la funci&amp;oacute;n devuelve &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="581efb60de5599bb6f030da89d279c27e9892d5a" translate="yes" xml:space="preserve">
          <source>If the process has any message in its message queue, the process is awakened immediately in the same way as described earlier.</source>
          <target state="translated">Si el proceso tiene algún mensaje en su cola de mensajes,el proceso se despierta inmediatamente de la misma manera que se describió anteriormente.</target>
        </trans-unit>
        <trans-unit id="084bfd0c081f4fee78443d764a32418d4196357e" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; has a registered name, also an &lt;code&gt;InfoTuple&lt;/code&gt; with item &lt;code&gt;registered_name&lt;/code&gt; is included.</source>
          <target state="translated">Si el proceso identificado por &lt;code&gt;Pid&lt;/code&gt; tiene un nombre registrado, tambi&amp;eacute;n se &lt;code&gt;InfoTuple&lt;/code&gt; un InfoTuple con el elemento &lt;code&gt;registered_name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b81261e08e1610fbb4a750870cfa04d7610f65e5" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local process.</source>
          <target state="translated">Si el proceso identificado por &lt;code&gt;Pid&lt;/code&gt; no es un proceso local existente.</target>
        </trans-unit>
        <trans-unit id="6f56d002efe6106da3a84a3e2016c451482b68c7" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is &amp;gt; 2,000,000,000 suspends and will never be lower.</source>
          <target state="translated">Si el proceso identificado por &lt;code&gt;Suspendee&lt;/code&gt; ha sido suspendido m&amp;aacute;s veces por el proceso de llamada de las que pueden representar las estructuras de datos internas utilizadas actualmente. El l&amp;iacute;mite del sistema es&amp;gt; 2,000,000,000 de suspensiones y nunca ser&amp;aacute; menor.</target>
        </trans-unit>
        <trans-unit id="036dbfabe540cf1c1a2eb6e8693ac0992c59c911" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; has been suspended more times by the calling process than can be represented by the currently used internal data structures. The system limit is greater than 2,000,000,000 suspends and will never be lower.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6414a88b13aa6c8a9b8f6f5c8c66d946440583" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is not alive.</source>
          <target state="translated">Si el proceso identificado por &lt;code&gt;Suspendee&lt;/code&gt; no est&amp;aacute; vivo.</target>
        </trans-unit>
        <trans-unit id="641aca5b56bf74307b3adf498b7c5e8e5c4b1259" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is the same process as the process calling &lt;code&gt;erlang:suspend_process/2&lt;/code&gt;.</source>
          <target state="translated">Si el proceso identificado por &lt;code&gt;Suspendee&lt;/code&gt; es el mismo proceso que el proceso que llama a &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="651c23453333c69005cd277bbe1fcf8cf3b85f49" translate="yes" xml:space="preserve">
          <source>If the process identified by &lt;code&gt;Suspendee&lt;/code&gt; resides on another node.</source>
          <target state="translated">Si el proceso identificado por &lt;code&gt;Suspendee&lt;/code&gt; reside en otro nodo.</target>
        </trans-unit>
        <trans-unit id="e4ca7dc0b151bb1f9cd8a2a4aff6bffd4a0444e4" translate="yes" xml:space="preserve">
          <source>If the process is alive and a single &lt;code&gt;Item&lt;/code&gt; is specified, the returned value is the corresponding &lt;code&gt;InfoTuple&lt;/code&gt;, unless &lt;code&gt;Item =:= registered_name&lt;/code&gt; and the process has no registered name. In this case, &lt;code&gt;[]&lt;/code&gt; is returned. This strange behavior is because of historical reasons, and is kept for backward compatibility.</source>
          <target state="translated">Si el proceso est&amp;aacute; activo y se especifica un solo &lt;code&gt;Item&lt;/code&gt; , el valor devuelto es el &lt;code&gt;InfoTuple&lt;/code&gt; correspondiente , a menos que el &lt;code&gt;Item =:= registered_name&lt;/code&gt; nombre_registrado y el proceso no tenga un nombre registrado. En este caso, se devuelve &lt;code&gt;[]&lt;/code&gt; . Este comportamiento extra&amp;ntilde;o se debe a razones hist&amp;oacute;ricas y se mantiene por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="1a9a0fee2f5bd85201e0094b8e33070b42b45236" translate="yes" xml:space="preserve">
          <source>If the process is to replace its state using the fun &lt;code&gt;StateFun&lt;/code&gt;, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">Si el proceso va a reemplazar su estado usando el divertido &lt;code&gt;StateFun&lt;/code&gt; , &lt;code&gt;handle_system_msg&lt;/code&gt; llama:</target>
        </trans-unit>
        <trans-unit id="3df3174e4f4f8d76818b78c9db43318524d54225" translate="yes" xml:space="preserve">
          <source>If the process is to return its state, &lt;code&gt;handle_system_msg&lt;/code&gt; calls:</source>
          <target state="translated">Si el proceso debe devolver su estado, &lt;code&gt;handle_system_msg&lt;/code&gt; llama:</target>
        </trans-unit>
        <trans-unit id="54575a5d04700d078536008be3d7a71568b2f2f0" translate="yes" xml:space="preserve">
          <source>If the process or port is already registered (already has a name).</source>
          <target state="translated">Si el proceso o puerto ya está registrado (ya tiene un nombre).</target>
        </trans-unit>
        <trans-unit id="72499bc5509543fc3c3a1dc36c89e29a09a5bee5" translate="yes" xml:space="preserve">
          <source>If the process potentially can get many messages in its queue, you are advised to set the flag to &lt;code&gt;off_heap&lt;/code&gt;. This because a garbage collection with many messages placed on the heap can become extremely expensive and the process can consume large amounts of memory. Performance of the actual message passing is however generally better when not using flag &lt;code&gt;off_heap&lt;/code&gt;.</source>
          <target state="translated">Si el proceso puede potencialmente obtener muchos mensajes en su cola, se recomienda configurar el indicador en &lt;code&gt;off_heap&lt;/code&gt; . Esto se debe a que una recolecci&amp;oacute;n de elementos no utilizados con muchos mensajes colocados en el mont&amp;oacute;n puede resultar extremadamente costosa y el proceso puede consumir grandes cantidades de memoria. Sin embargo, el rendimiento del paso de mensajes real es generalmente mejor cuando no se usa flag &lt;code&gt;off_heap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2977b37e3f3fa2bacc4a55c85d9c30b69a4999c8" translate="yes" xml:space="preserve">
          <source>If the process terminates with another reason than &lt;code&gt;normal&lt;/code&gt; or &lt;code&gt;shutdown&lt;/code&gt;, a crash report is generated. For more information about the crash report, see the SASL User's Guide.</source>
          <target state="translated">Si el proceso termina por un motivo diferente al &lt;code&gt;normal&lt;/code&gt; o se &lt;code&gt;shutdown&lt;/code&gt; , se genera un informe de bloqueo. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el informe de fallas, consulte la Gu&amp;iacute;a del usuario de SASL.</target>
        </trans-unit>
        <trans-unit id="24d7be87e875bc81d2fad8f3b3e621f25756c364" translate="yes" xml:space="preserve">
          <source>If the process was spawned using a fun, &lt;code&gt;initial_call/1&lt;/code&gt; no longer returns the fun, but the module, function for the local function implementing the fun, and the arity, for example, &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; (meaning that the fun was created in function &lt;code&gt;some_module:work/3&lt;/code&gt;). The reason is that keeping the fun would prevent code upgrade for the module, and that a significant amount of memory could be wasted.</source>
          <target state="translated">Si el proceso se gener&amp;oacute; usando una diversi&amp;oacute;n, &lt;code&gt;initial_call/1&lt;/code&gt; ya no devuelve la diversi&amp;oacute;n, sino el m&amp;oacute;dulo, la funci&amp;oacute;n para la funci&amp;oacute;n local que implementa la diversi&amp;oacute;n y la aridad, por ejemplo, &lt;code&gt;{some_module,-work/3-fun-0-,0}&lt;/code&gt; (lo que significa que la diversi&amp;oacute;n se cre&amp;oacute; en la funci&amp;oacute;n &lt;code&gt;some_module:work/3&lt;/code&gt; ). La raz&amp;oacute;n es que mantener la diversi&amp;oacute;n evitar&amp;iacute;a la actualizaci&amp;oacute;n del c&amp;oacute;digo del m&amp;oacute;dulo y que se podr&amp;iacute;a desperdiciar una cantidad significativa de memoria.</target>
        </trans-unit>
        <trans-unit id="e063f0c97bd3b9f2ca10490b0726825eb1a13207" translate="yes" xml:space="preserve">
          <source>If the program is too large to be profiled by &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;, &lt;code&gt;cprof&lt;/code&gt; can be used to locate code parts that are to be more thoroughly profiled using &lt;code&gt;fprof&lt;/code&gt; or &lt;code&gt;eprof&lt;/code&gt;.</source>
          <target state="translated">Si el programa es demasiado grande para ser perfilado por &lt;code&gt;fprof&lt;/code&gt; o &lt;code&gt;eprof&lt;/code&gt; , &lt;code&gt;cprof&lt;/code&gt; se puede usar para ubicar partes de c&amp;oacute;digo que deben perfilarse m&amp;aacute;s a fondo usando &lt;code&gt;fprof&lt;/code&gt; o &lt;code&gt;eprof&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c014cbf0073f75ddbbd2b83b405b67fe36da992" translate="yes" xml:space="preserve">
          <source>If the provided public key is not found, the authentication fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62378f1f957382ee8a052b1c61d99645a009e49" translate="yes" xml:space="preserve">
          <source>If the pure encode/decode performance really is a serious issue, our erl_dist encoder could be used, as the encoding/decoding of the erlang distribution format is much faster than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">Si el rendimiento de la codificación/decodificación pura es realmente un problema serio,se podría utilizar nuestro codificador erl_dist,ya que la codificación/decodificación del formato de distribución erlang es mucho más rápida que todas las demás alternativas.Su mayor inconveniente es que no ha sido aprobado como una codificación válida de mensajes Megaco/H.248.</target>
        </trans-unit>
        <trans-unit id="a4deb3a5f5f018b337b5754c6b3743ec42918472" translate="yes" xml:space="preserve">
          <source>If the quantifier is {0}, the assertion is never obeyed during matching. However, it can contain internal capturing parenthesized groups that are called from elsewhere through the subroutine mechanism.</source>
          <target state="translated">Si el cuantificador es {0},la afirmación nunca es obedecida durante el emparejamiento.Sin embargo,puede contener grupos entre paréntesis de captura interna que son llamados desde otro lugar a través del mecanismo de subrutinas.</target>
        </trans-unit>
        <trans-unit id="15a112cbde0806d4bd82db516d60932759dd1e88" translate="yes" xml:space="preserve">
          <source>If the regular expression contains capturing subpatterns, like in:</source>
          <target state="translated">Si la expresión regular contiene subpatrones de captura,como en:</target>
        </trans-unit>
        <trans-unit id="53c05be9c33eb1a96dab74d00ca7378c333d60b5" translate="yes" xml:space="preserve">
          <source>If the regular expression is previously compiled, the option list can only contain the following options:</source>
          <target state="translated">Si la expresión regular se ha compilado previamente,la lista de opciones sólo puede contener las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="22619338e12940ef34ae589b0ca2c131b656f3a0" translate="yes" xml:space="preserve">
          <source>If the regular expression was previously compiled with option &lt;code&gt;unicode&lt;/code&gt;, &lt;code&gt;Subject&lt;/code&gt; is to be provided as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise any &lt;code&gt;iodata()&lt;/code&gt; will do. If compilation is involved and option &lt;code&gt;unicode&lt;/code&gt; is specified, both &lt;code&gt;Subject&lt;/code&gt; and the regular expression are to be specified as valid Unicode &lt;code&gt;charlists()&lt;/code&gt;.</source>
          <target state="translated">Si la expresi&amp;oacute;n regular se compil&amp;oacute; previamente con la opci&amp;oacute;n &lt;code&gt;unicode&lt;/code&gt; , el &lt;code&gt;Subject&lt;/code&gt; se debe proporcionar como una lista de caracteres Unicode v&amp;aacute;lida &lt;code&gt;charlist()&lt;/code&gt; ; de lo contrario, cualquier &lt;code&gt;iodata()&lt;/code&gt; servir&amp;aacute;. Si est&amp;aacute; involucrada la compilaci&amp;oacute;n y se especifica la opci&amp;oacute;n &lt;code&gt;unicode&lt;/code&gt; , tanto el &lt;code&gt;Subject&lt;/code&gt; como la expresi&amp;oacute;n regular deben especificarse como &lt;code&gt;charlists()&lt;/code&gt; Unicode v&amp;aacute;lidas () .</target>
        </trans-unit>
        <trans-unit id="95cb6c73038fea5d38c77487c266df25c09c2a93" translate="yes" xml:space="preserve">
          <source>If the release is to be upgraded, it must also include the SASL application.</source>
          <target state="translated">Si se va a actualizar la versión,también debe incluir la aplicación SASL.</target>
        </trans-unit>
        <trans-unit id="209b3e073d6604d9f31c31d6ea0d348f2a50c0c5" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;.</source>
          <target state="translated">Si el paquete de lanzamiento va a contener un nuevo sistema de ejecuci&amp;oacute;n de Erlang, el directorio &lt;code&gt;bin&lt;/code&gt; del sistema de ejecuci&amp;oacute;n especificado &lt;code&gt;{erts,Dir}&lt;/code&gt; se copia en &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="363cb8688a551cced7d3018ac246f3d6efe48af3" translate="yes" xml:space="preserve">
          <source>If the release package is to contain a new Erlang runtime system, the &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt; directory of the specified runtime system &lt;code&gt;{erts,Dir}&lt;/code&gt; is copied to &lt;code&gt;erts-ErtsVsn/bin&lt;/code&gt;. Some erts executables are not copied by default, if you want to include all executables you can give the &lt;code&gt;erts_all&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f636f7002f64f569ae3d458b76d340d2355447e2" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue, as this function spawns off a middleman process to act as (a void) destination for such an orphan reply. This feature also makes this function more expensive than &lt;code&gt;call/4&lt;/code&gt; at the caller's end.</source>
          <target state="translated">Si la respuesta llega despu&amp;eacute;s de que se agota el tiempo de espera de la llamada, ning&amp;uacute;n mensaje contamina la cola de mensajes de la persona que llama, ya que esta funci&amp;oacute;n genera un proceso intermediario para que act&amp;uacute;e como destino (nulo) para dicha respuesta hu&amp;eacute;rfana. Esta caracter&amp;iacute;stica tambi&amp;eacute;n hace que esta funci&amp;oacute;n sea m&amp;aacute;s cara que la &lt;code&gt;call/4&lt;/code&gt; al final de la llamada.</target>
        </trans-unit>
        <trans-unit id="97bf926e93bf111383afef246646bb072493b10d" translate="yes" xml:space="preserve">
          <source>If the reply arrives after the call times out, no message contaminates the caller's message queue.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="72de28ff26e478c709ccef28f5ec9b72f45a4e23" translate="yes" xml:space="preserve">
          <source>If the report browser is used offline, the reports can be copied to another directory specified when starting the browser. If no such directory is specified, the browser reads reports from the SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt;.</source>
          <target state="translated">Si el navegador de informes se utiliza sin conexi&amp;oacute;n, los informes se pueden copiar a otro directorio especificado al iniciar el navegador. Si no se especifica dicho directorio, el navegador lee los informes de SASL &lt;code&gt;error_logger_mf_dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d403abf04385b59be919058fa57d3e12c76fe7b9" translate="yes" xml:space="preserve">
          <source>If the request functions for the SFTP channel return &lt;code&gt;{error, timeout}&lt;/code&gt;, no answer was received from the server within the expected time.</source>
          <target state="translated">Si la solicitud funciona para el retorno del canal SFTP &lt;code&gt;{error, timeout}&lt;/code&gt; , no se recibi&amp;oacute; respuesta del servidor dentro del tiempo esperado.</target>
        </trans-unit>
        <trans-unit id="68fcf1aa779848125b39efeaf9b8566022844620" translate="yes" xml:space="preserve">
          <source>If the request is an HTTP/1.1 request, the URI can be in the absolute URI format. In that case, &lt;code&gt;httpd&lt;/code&gt; saves the absolute URI in this field. An Example of an absolute URI is &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</source>
          <target state="translated">Si la solicitud es una solicitud HTTP / 1.1, el URI puede estar en formato de URI absoluto. En ese caso, &lt;code&gt;httpd&lt;/code&gt; guarda el URI absoluto en este campo. Un ejemplo de un URI absoluto es &lt;code&gt;&quot;http://ServerName:Part/cgi-bin/find.pl?person=jocke&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="bf8c6e0e4e32eeefc924406bd2971a4ed6ef9777" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the answer times out then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = timeout&lt;/code&gt;.</source>
          <target state="translated">Si la solicitud se codifica y env&amp;iacute;a correctamente, pero la respuesta se agota, se &lt;code&gt;handle_error/4&lt;/code&gt; una devoluci&amp;oacute;n de llamada handle_error / 4 con &lt;code&gt;Reason = timeout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d362d3cf60cb0af09ab64c13d49db2cee633e8f5" translate="yes" xml:space="preserve">
          <source>If the request is successfully encoded and sent but the service in question is stopped before an answer is received then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = cancel&lt;/code&gt;.</source>
          <target state="translated">Si la solicitud se codifica y env&amp;iacute;a correctamente, pero el servicio en cuesti&amp;oacute;n se detiene antes de recibir una respuesta, se &lt;code&gt;handle_error/4&lt;/code&gt; una devoluci&amp;oacute;n de llamada handle_error / 4 con &lt;code&gt;Reason = cancel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61d25df3bedf5d0be2cd7d314bbaa9b30da48753" translate="yes" xml:space="preserve">
          <source>If the request reached the peer, was handled and the response reached the requesting node the &lt;code&gt;&lt;a href=&quot;#type-req_status&quot;&gt;req_status()&lt;/a&gt;&lt;/code&gt; is the status reported from the peer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9756cb158d71aee0a6ade83d17f9f5f0e83f232d" translate="yes" xml:space="preserve">
          <source>If the requested data is available, the subentry is associated with &lt;code&gt;Name&lt;/code&gt; so that the value of the element can be read with &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; provided &lt;code&gt;Name&lt;/code&gt; is used instead of the whole &lt;code&gt;Required&lt;/code&gt; term.</source>
          <target state="translated">Si los datos solicitados est&amp;aacute; disponible, el sub-entrada se asocia con &lt;code&gt;Name&lt;/code&gt; para que el valor del elemento se puede leer con &lt;code&gt;&lt;a href=&quot;#get_config-1&quot;&gt;ct:get_config/1,2&lt;/a&gt;&lt;/code&gt; proporcionada &lt;code&gt;Name&lt;/code&gt; se utiliza en lugar de toda la &lt;code&gt;Required&lt;/code&gt; plazo.</target>
        </trans-unit>
        <trans-unit id="5e0bd29420b56350fa2aea428f5bb429a285d8aa" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated by setting the STDLIB variable during emulator startup, and the callback module cannot be loaded, a default restricted shell allowing only the commands &lt;code&gt;q()&lt;/code&gt; and &lt;code&gt;init:stop()&lt;/code&gt; is used as fallback.</source>
          <target state="translated">Si el shell restringido se activa configurando la variable STDLIB durante el inicio del emulador, y el m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada no se puede cargar, se utiliza un shell restringido predeterminado que solo permite los comandos &lt;code&gt;q()&lt;/code&gt; e &lt;code&gt;init:stop()&lt;/code&gt; como respaldo.</target>
        </trans-unit>
        <trans-unit id="724b8206454c6a949fb926da63637eb525b4710d" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt; start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ffe48dc12c1fe598f1a22c84e21f70cadbb61864" translate="yes" xml:space="preserve">
          <source>If the restricted shell is activated using &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; and the callback module cannot be loaded, an error report is sent to the error logger and the call returns &lt;code&gt;{error,Reason}&lt;/code&gt;.</source>
          <target state="translated">Si el shell restringido se activa usando &lt;code&gt;&lt;a href=&quot;#start_restricted-1&quot;&gt;start_restricted/1&lt;/a&gt;&lt;/code&gt; y el m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada no se puede cargar, se env&amp;iacute;a un informe de error al registrador de errores y la llamada devuelve &lt;code&gt;{error,Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d723ff157f68fb866c4e720b4a0eacba9b30b870" translate="yes" xml:space="preserve">
          <source>If the result of the list comprehension will &lt;strong&gt;obviously&lt;/strong&gt; not be used, a list will not be constructed. For example, in this code:</source>
          <target state="translated">Si el resultado de la comprensi&amp;oacute;n de la lista, &lt;strong&gt;obviamente,&lt;/strong&gt; no se utilizar&amp;aacute;, no se construir&amp;aacute; una lista. Por ejemplo, en este c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="ef688930e9bc0a09ddfd80d412acb665d77d541c" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system does, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute, so under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">Si el sistema de tiempo de ejecuci&amp;oacute;n est&amp;aacute; en &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi time warp mode&lt;/a&gt;&lt;/code&gt; , la compensaci&amp;oacute;n de tiempo se cambia cuando el sistema de tiempo de ejecuci&amp;oacute;n detecta que la &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; ha cambiado. Sin embargo, el sistema de tiempo de ejecuci&amp;oacute;n no detecta esto inmediatamente cuando ocurre. Una tarea que verifica la compensaci&amp;oacute;n de tiempo est&amp;aacute; programada para ejecutarse al menos una vez por minuto, por lo que, en condiciones normales de funcionamiento, esto debe detectarse en un minuto, pero durante una carga pesada puede llevar m&amp;aacute;s tiempo.</target>
        </trans-unit>
        <trans-unit id="9ee5563a77256009bf8489bde46cade77b9f2b67" translate="yes" xml:space="preserve">
          <source>If the runtime system is in &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt;, the time offset is changed when the runtime system detects that the &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; has changed. The runtime system will, however, not detect this immediately when it occurs. A task checking the time offset is scheduled to execute at least once a minute; so, under normal operation this is to be detected within a minute, but during heavy load it can take longer time.</source>
          <target state="translated">Si el sistema de tiempo de ejecuci&amp;oacute;n est&amp;aacute; en &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; , la compensaci&amp;oacute;n de tiempo se cambia cuando el sistema de tiempo de ejecuci&amp;oacute;n detecta que la &lt;code&gt;&lt;a href=&quot;time_correction#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; ha cambiado. Sin embargo, el sistema de tiempo de ejecuci&amp;oacute;n no detectar&amp;aacute; esto inmediatamente cuando ocurra. Una tarea que verifica la compensaci&amp;oacute;n de tiempo est&amp;aacute; programada para ejecutarse al menos una vez por minuto; por lo tanto, en funcionamiento normal, esto se debe detectar en un minuto, pero durante una carga pesada puede llevar m&amp;aacute;s tiempo.</target>
        </trans-unit>
        <trans-unit id="842b5ecda8b77bc83a3f2909c3c676e780a3ce01" translate="yes" xml:space="preserve">
          <source>If the same option is set at two different levels, the one at the highest level is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554e754ec098db2cf4c76a2930674bed5aa17796" translate="yes" xml:space="preserve">
          <source>If the scheme &lt;code&gt;https&lt;/code&gt; is used, the &lt;code&gt;SSL&lt;/code&gt; application must be started. When &lt;code&gt;https&lt;/code&gt; links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt;is not supported.</source>
          <target state="translated">Si se utiliza el esquema &lt;code&gt;https&lt;/code&gt; , se debe iniciar la aplicaci&amp;oacute;n &lt;code&gt;SSL&lt;/code&gt; . Cuando los enlaces &lt;code&gt;https&lt;/code&gt; deben pasar por un proxy, la extensi&amp;oacute;n del m&amp;eacute;todo CONNECT a HTTP-1.1 se utiliza para establecer un t&amp;uacute;nel y luego la conexi&amp;oacute;n se actualiza a TLS. Sin embargo, no se admite la &quot;actualizaci&amp;oacute;n de TLS&quot; seg&amp;uacute;n &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd39ec873a6f1811f7fd75cdbff8a27a1e922646" translate="yes" xml:space="preserve">
          <source>If the scheme &lt;code&gt;https&lt;/code&gt; is used, the &lt;code&gt;SSL&lt;/code&gt; application must be started. When &lt;code&gt;https&lt;/code&gt; links need to go through a proxy, the CONNECT method extension to HTTP-1.1 is used to establish a tunnel and then the connection is upgraded to TLS. However, &quot;TLS upgrade&quot; according to &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc2817.txt&quot;&gt;RFC 2817&lt;/a&gt;&lt;/code&gt;is not supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c3e2a035a8c91596ec4431ba0d0a851882160c2" translate="yes" xml:space="preserve">
          <source>If the second operand for &lt;code&gt;is_number/2&lt;/code&gt; is a literal, it will be moved to X register 1023. Then &lt;code&gt;is_number/2&lt;/code&gt; will test whether the value stored in X register 1023 is a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35c6f2a7a376dda13bb7ffd101ed27e0bb2c89e4" translate="yes" xml:space="preserve">
          <source>If the selected cipher needs to have the input data partioned into blocks of a certain size, the &lt;code&gt;init_fun()&lt;/code&gt; should return the second form of return value with the &lt;code&gt;chunk_size()&lt;/code&gt; set to the block size. If the &lt;code&gt;chunk_size()&lt;/code&gt; is &lt;code&gt;undefined&lt;/code&gt;, the size of the &lt;code&gt;PlainBin&lt;/code&gt;s varies, because this is intended for stream crypto, whereas a fixed &lt;code&gt;chunk_size()&lt;/code&gt; is intended for block crypto. A &lt;code&gt;chunk_size()&lt;/code&gt; can be changed in the return from the &lt;code&gt;crypto_fun()&lt;/code&gt;. The value can be changed between &lt;code&gt;pos_integer()&lt;/code&gt; and &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8d199b5f396cd79b8cc290ec04cb85c9575f0f8" translate="yes" xml:space="preserve">
          <source>If the sender would have to be suspended to do the send, &lt;code&gt;nosuspend&lt;/code&gt; is returned instead.</source>
          <target state="translated">Si el remitente debe ser suspendido para realizar el env&amp;iacute;o, se devuelve &lt;code&gt;nosuspend&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="603b5cbedb1c18808b9a489511a61b63ed3b0c0b" translate="yes" xml:space="preserve">
          <source>If the server changes callback module using any of the actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, be aware that it is always the current callback module that will get this callback call. That the current callback module handles the current state and data update should be no surprise, but it must be able to handle even parts of the state and data that it is not familiar with, somehow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6d3e8ae70c643b6deb59daac018ce037067a9f" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Si el servidor no est&amp;aacute; especificado en un archivo de configuraci&amp;oacute;n, use &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="d8838b36f111de63a4782ef1a364bbbead7e4773" translate="yes" xml:space="preserve">
          <source>If the server is not specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Si el servidor no est&amp;aacute; especificado en un archivo de configuraci&amp;oacute;n, use &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="70355032eca4c9d76df601e10da3a7d335f3ed0d" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, or if a named client is needed for logging purposes (see section &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; in this module), use &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Si las opciones del servidor se especifican en un archivo de configuraci&amp;oacute;n, o si se necesita un cliente con nombre para fines de registro (consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#Logging&quot;&gt;Logging&lt;/a&gt;&lt;/code&gt; en este m&amp;oacute;dulo), utilice &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="57f23c3daad60ed51515d51367aea45626c02cd9" translate="yes" xml:space="preserve">
          <source>If the server options are specified in a configuration file, use &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Si las opciones del servidor se especifican en un archivo de configuraci&amp;oacute;n, utilice &lt;code&gt;&lt;a href=&quot;#connect-2&quot;&gt;connect/2&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="2dcdba9665f7f05be3244027d112ec31bf32434c" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client matching a host listed in the &lt;code&gt;sni_hosts&lt;/code&gt; option, the specific options for that host will override previously specified options. The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">Si el servidor recibe una SNI (Indicaci&amp;oacute;n de nombre de servidor) del cliente que coincide con un host listado en la opci&amp;oacute;n &lt;code&gt;sni_hosts&lt;/code&gt; , las opciones espec&amp;iacute;ficas para ese host anular&amp;aacute;n las opciones especificadas previamente. La opci&amp;oacute;n &lt;code&gt;sni_fun&lt;/code&gt; y &lt;code&gt;sni_hosts&lt;/code&gt; son mutuamente excluyentes.</target>
        </trans-unit>
        <trans-unit id="6872d76e7fd0c2b2043184ce306dcf6a44377861" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; list. The function should be defined as: fun(ServerName :: string()) -&amp;gt; &lt;code&gt;&lt;a href=&quot;#type-server_option&quot;&gt;[server_option()] &lt;/a&gt;&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f88346e63ca31b635eaa59afabe4ac1246f3dd96" translate="yes" xml:space="preserve">
          <source>If the server receives a SNI (Server Name Indication) from the client, the given function will be called to retrieve &lt;code&gt;[ssl_option()]&lt;/code&gt; for the indicated server. These options will be merged into predefined &lt;code&gt;[ssl_option()]&lt;/code&gt;. The function should be defined as: &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; and can be specified as a fun or as named &lt;code&gt;fun module:function/1&lt;/code&gt; The option &lt;code&gt;sni_fun&lt;/code&gt;, and &lt;code&gt;sni_hosts&lt;/code&gt; are mutually exclusive.</source>
          <target state="translated">Si el servidor recibe una SNI (Indicaci&amp;oacute;n de nombre de servidor) del cliente, se llamar&amp;aacute; a la funci&amp;oacute;n dada para recuperar &lt;code&gt;[ssl_option()]&lt;/code&gt; para el servidor indicado. Estas opciones se fusionar&amp;aacute;n en &lt;code&gt;[ssl_option()]&lt;/code&gt; predefinidas . La funci&amp;oacute;n debe definirse como: &lt;code&gt;fun(ServerName :: string()) -&amp;gt; [ssl_option()]&lt;/code&gt; y puede especificarse como un &lt;code&gt;fun module:function/1&lt;/code&gt; divertido o con nombre divertido: funci&amp;oacute;n / 1 La opci&amp;oacute;n &lt;code&gt;sni_fun&lt;/code&gt; y &lt;code&gt;sni_hosts&lt;/code&gt; son mutuamente excluyentes.</target>
        </trans-unit>
        <trans-unit id="37d0a58e6098abfba1624874ecb647d5100c0c46" translate="yes" xml:space="preserve">
          <source>If the size of the files is decreased, the change immediately affects the current log. It does not change the size of log files already full until the next time they are used.</source>
          <target state="translated">Si se reduce el tamaño de los archivos,el cambio afecta inmediatamente al registro actual.No cambia el tamaño de los archivos de registro que ya están llenos hasta la próxima vez que se utilicen.</target>
        </trans-unit>
        <trans-unit id="48531719e2548f233ac5471f827038efdab7d452" translate="yes" xml:space="preserve">
          <source>If the size of the live data in the process is less than the minimum heap size, the first garbage collection occurring after the process is awakened ensures that the heap size is changed to a size not smaller than the minimum heap size.</source>
          <target state="translated">Si el tamaño de los datos en vivo en el proceso es menor que el tamaño mínimo de la pila,la primera recogida de basura que se produzca después de que se despierte el proceso asegura que el tamaño de la pila se cambie a un tamaño no menor que el tamaño mínimo de la pila.</target>
        </trans-unit>
        <trans-unit id="55a92bc9b80ccffb05ef0f4d2b0d2c00367ee298" translate="yes" xml:space="preserve">
          <source>If the skipped test case belongs to a test case group, the first argument is a tuple &lt;code&gt;{FuncName,GroupName}&lt;/code&gt;, otherwise only the function name.</source>
          <target state="translated">Si el caso de prueba omitido pertenece a un grupo de casos de prueba, el primer argumento es una tupla &lt;code&gt;{FuncName,GroupName}&lt;/code&gt; ; de lo contrario, solo el nombre de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a70f753063df0478c5593d2eec5283aea16d43ef" translate="yes" xml:space="preserve">
          <source>If the snmp agent is configured as a distributed Erlang application, it will during takeover try to load the same MIBs that were loaded at the old node. It uses the same filenames as the old node. If the MIBs are not located in the same paths at the different nodes, the MIBs must be loaded explicitly after takeover.</source>
          <target state="translated">Si el agente snmp está configurado como una aplicación Erlang distribuida,durante la toma de posesión intentará cargar las mismas MIB que se cargaron en el nodo antiguo.Utiliza los mismos nombres de archivo que el nodo antiguo.Si las MIBs no se encuentran en las mismas rutas en los diferentes nodos,las MIBs deben ser cargadas explícitamente después de la toma de posesión.</target>
        </trans-unit>
        <trans-unit id="512aa9feb42b459cd059aa3fe2168a1e5258567a" translate="yes" xml:space="preserve">
          <source>If the socket is a listen socket, we use a separate (regular) file for two purposes:</source>
          <target state="translated">Si el zócalo es un zócalo de escucha,usamos un archivo separado (regular)para dos propósitos:</target>
        </trans-unit>
        <trans-unit id="fc7067034e5330d9330814dab9d3d85a46c9af7c" translate="yes" xml:space="preserve">
          <source>If the socket is closed, the following message is delivered:</source>
          <target state="translated">Si el enchufe está cerrado,se entrega el siguiente mensaje:</target>
        </trans-unit>
        <trans-unit id="4128dcf4e6f00732687760eccb66b0c9d45f8d7a" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;active&lt;/a&gt;&lt;/code&gt; mode data received data is delivered to the controlling process as messages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4248f996c2d366444661dd551e1e934e80a81f5" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;&lt;a href=&quot;#option-active&quot;&gt;passive&lt;/a&gt;&lt;/code&gt; mode data can be received through the &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/1,2&lt;/a&gt;&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c734cf077ea6e84216c28020bf0dfe0c224786a4" translate="yes" xml:space="preserve">
          <source>If the socket is in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details) and its message counter drops to &lt;code&gt;0&lt;/code&gt;, the following message is delivered to indicate that the socket has transitioned to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode:</source>
          <target state="translated">Si el socket est&amp;aacute; en modo &lt;code&gt;{active, N}&lt;/code&gt; (consulte &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; para obtener m&amp;aacute;s detalles) y su contador de mensajes cae a &lt;code&gt;0&lt;/code&gt; , se env&amp;iacute;a el siguiente mensaje para indicar que el socket ha pasado a pasivo ( &lt;code&gt;{active, false}&lt;/code&gt; ) modo:</target>
        </trans-unit>
        <trans-unit id="bb22ea2f6ffe71f664a8e18b7f47a0d62e0aa24d" translate="yes" xml:space="preserve">
          <source>If the socket is in a busy state, the socket is set in a not busy state when the amount of data queued internally by the ERTS socket implementation falls below this limit. Defaults to 4 kB.</source>
          <target state="translated">Si el socket está en un estado ocupado,el socket se pone en un estado no ocupado cuando la cantidad de datos en cola internamente por la implementación del socket ERTS cae por debajo de este límite.El valor por defecto es de 4 kB.</target>
        </trans-unit>
        <trans-unit id="0860cb89a1cd48e8809f57a8b0f0cb44187efe24" translate="yes" xml:space="preserve">
          <source>If the socket is not in an active mode, data can be retrieved through the &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; calls. Notice that arriving UDP packets that are longer than the receive buffer option specifies can be truncated without warning.</source>
          <target state="translated">Si el socket no est&amp;aacute; en modo activo, los datos se pueden recuperar a trav&amp;eacute;s de las llamadas &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2,3&lt;/a&gt;&lt;/code&gt; . Tenga en cuenta que los paquetes UDP que llegan m&amp;aacute;s largos de lo que especifica la opci&amp;oacute;n de b&amp;uacute;fer de recepci&amp;oacute;n se pueden truncar sin previo aviso.</target>
        </trans-unit>
        <trans-unit id="479b7a4579a072626569e57eba743d1c2936d55c" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfer is complete may cause this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="886690ee1274e874585cd62a60964392f36c218d" translate="yes" xml:space="preserve">
          <source>If the socket is set in active mode, this function will transfer any messages in the mailbox of the caller to the new controlling process. If any other process is interacting with the socket while the transfer is happening, the transfer may not work correctly and messages may remain in the caller's mailbox. For instance changing the sockets active mode before the transfere is complete may cause this.</source>
          <target state="translated">Si el enchufe está configurado en modo activo,esta función transferirá cualquier mensaje del buzón de la persona que llama al nuevo proceso de control.Si algún otro proceso está interactuando con el socket mientras se realiza la transferencia,ésta puede no funcionar correctamente y los mensajes pueden permanecer en el buzón de la persona que llama.Por ejemplo,el cambio del modo activo de los sockets antes de que la transferencia se complete puede causar esto.</target>
        </trans-unit>
        <trans-unit id="2ef7d7003c6284dd13030d6ae0c0a5544dc8ae67" translate="yes" xml:space="preserve">
          <source>If the socket message queue is in a busy state, the socket message queue is set in a not busy state when the amount of data queued in the message queue falls below this limit. Notice that this limit only concerns data that has not yet reached the ERTS internal socket implementation. Defaults to 4 kB.</source>
          <target state="translated">Si la cola de mensajes de sockets está en un estado de ocupado,la cola de mensajes de sockets se establece en un estado de no ocupado cuando la cantidad de datos en la cola de mensajes cae por debajo de este límite.Observe que este límite sólo afecta a los datos que aún no han llegado a la implementación interna de sockets de ERTS.El valor por defecto es de 4 kB.</target>
        </trans-unit>
        <trans-unit id="0489cec8cde9abcfab25b3cd056616ee2153c497" translate="yes" xml:space="preserve">
          <source>If the source file and/or the output file cannot be opened using &lt;code&gt;file:open/2&lt;/code&gt;, the function returns &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; where &lt;code&gt;File&lt;/code&gt; is the file name and &lt;code&gt;Reason&lt;/code&gt; is the error reason.</source>
          <target state="translated">Si el archivo fuente y / o el archivo de salida no se pueden abrir usando &lt;code&gt;file:open/2&lt;/code&gt; , la funci&amp;oacute;n devuelve &lt;code&gt;{error,{file,File,Reason}}&lt;/code&gt; donde &lt;code&gt;File&lt;/code&gt; es el nombre del archivo y &lt;code&gt;Reason&lt;/code&gt; es el motivo del error.</target>
        </trans-unit>
        <trans-unit id="8e799a198169d10fe4c08d9a95c18d2093196332" translate="yes" xml:space="preserve">
          <source>If the spawn operation succeeds, a new process is created on the node identified by &lt;code&gt;Node&lt;/code&gt;. When a spawn operation succeeds, the caller will by default be sent a message on the form &lt;code&gt;{ReplyTag, ReqId, ok, Pid}&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. Such a message is referred to as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d585722d9492cc72567d38442d77e34fd8ab9264" translate="yes" xml:space="preserve">
          <source>If the special process is set to trap exits and if the parent process terminates, the expected behavior is to terminate with the same reason:</source>
          <target state="translated">Si el proceso especial está configurado para atrapar salidas y si el proceso padre termina,el comportamiento esperado es terminar con la misma razón:</target>
        </trans-unit>
        <trans-unit id="7455375f6d9089c7881123f4a8458dbe542389f7" translate="yes" xml:space="preserve">
          <source>If the specified &lt;code&gt;SessionId&lt;/code&gt; is equal to the current session Id, an error is returned.</source>
          <target state="translated">Si el &lt;code&gt;SessionId&lt;/code&gt; especificado es igual al Id de la sesi&amp;oacute;n actual, se devuelve un error.</target>
        </trans-unit>
        <trans-unit id="d619307390edd39ec2b02ca669e7b364961dec45" translate="yes" xml:space="preserve">
          <source>If the specified allocator types are not enabled, the call will fail with &lt;code&gt;{error, not_enabled}&lt;/code&gt;.</source>
          <target state="translated">Si los tipos de asignador especificados no est&amp;aacute;n habilitados, la llamada fallar&amp;aacute; con &lt;code&gt;{error, not_enabled}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45c304ea9f8890bedad2957ce64c3d9052640688" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, or if the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Si la aplicaci&amp;oacute;n especificada no est&amp;aacute; cargada, o si el proceso que ejecuta la llamada no pertenece a ninguna aplicaci&amp;oacute;n, la funci&amp;oacute;n devuelve &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="661935b4fcb704bdedb21cd7cd8d1037467c6a3a" translate="yes" xml:space="preserve">
          <source>If the specified application is not loaded, the function returns &lt;code&gt;undefined&lt;/code&gt;. If the process executing the call does not belong to any application, the function returns &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Si la aplicaci&amp;oacute;n especificada no est&amp;aacute; cargada, la funci&amp;oacute;n devuelve &lt;code&gt;undefined&lt;/code&gt; . Si el proceso que ejecuta la llamada no pertenece a ninguna aplicaci&amp;oacute;n, la funci&amp;oacute;n devuelve &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ee2eec511fb223edba405cd2c1e33b5dd8cf299" translate="yes" xml:space="preserve">
          <source>If the specified event handler is not installed, the function returns &lt;code&gt;{error,bad_module}&lt;/code&gt;. If the callback function fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. If the event manager dies before or during the request this function returns &lt;code&gt;{error,{Reason, EventMgrRef}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a926434bb6d9a3523835439ccc5767bd6572dff3" translate="yes" xml:space="preserve">
          <source>If the specified process does not belong to any application, or if the specified process or module does not exist, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Si el proceso especificado no pertenece a ninguna aplicaci&amp;oacute;n, o si el proceso o m&amp;oacute;dulo especificado no existe, la funci&amp;oacute;n devuelve &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b16c97bb4dc09a19744a2eb9750dd2d9bb5ce54" translate="yes" xml:space="preserve">
          <source>If the startup procedure fails, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; returns the cryptic tuple &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt;. To get more information about the start failure, use command-line arguments &lt;code&gt;-boot start_sasl&lt;/code&gt; as argument to the &lt;code&gt;erl&lt;/code&gt; script.</source>
          <target state="translated">Si el procedimiento de inicio falla, la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; devuelve la tupla cr&amp;iacute;ptica &lt;code&gt;{error,{shutdown, {mnesia_sup,start_link,[normal,[]]}}}&lt;/code&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el error de inicio, use los argumentos de la l&amp;iacute;nea de comandos &lt;code&gt;-boot start_sasl&lt;/code&gt; como argumento para el script &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cbaf50d401e5c21095fb8f1fd28f9a45786128e" translate="yes" xml:space="preserve">
          <source>If the state changes, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="translated">Si el estado cambia,la cola de eventos entrantes se reajusta para empezar con el más antiguo aplazado.</target>
        </trans-unit>
        <trans-unit id="c8895677551ffa4a3c90ee4e7e492bffa6d9c323" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge. The challenge message can have two different formats:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36cb412738e6e082151303db455deefb75f1506a" translate="yes" xml:space="preserve">
          <source>If the status was &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;ok_simultaneous&lt;/code&gt;, the handshake continues with &lt;code&gt;B&lt;/code&gt; sending &lt;code&gt;A&lt;/code&gt; another message, the challenge. The challenge contains the same type of information as the &quot;name&quot; message initially sent from &lt;code&gt;A&lt;/code&gt; to &lt;code&gt;B&lt;/code&gt;, plus a 32-bit challenge:</source>
          <target state="translated">Si el estado era &lt;code&gt;ok&lt;/code&gt; u &lt;code&gt;ok_simultaneous&lt;/code&gt; , el protocolo de enlace contin&amp;uacute;a con &lt;code&gt;B&lt;/code&gt; enviando a &lt;code&gt;A&lt;/code&gt; otro mensaje, el desaf&amp;iacute;o. El desaf&amp;iacute;o contiene el mismo tipo de informaci&amp;oacute;n que el mensaje &quot;nombre&quot; enviado inicialmente de &lt;code&gt;A&lt;/code&gt; a &lt;code&gt;B&lt;/code&gt; , m&amp;aacute;s un desaf&amp;iacute;o de 32 bits:</target>
        </trans-unit>
        <trans-unit id="beeeb7c98813879b37a7bf671f3521d70f7d4fcc" translate="yes" xml:space="preserve">
          <source>If the storage type of the schema is &lt;code&gt;ram_copies&lt;/code&gt;, that is, a disc-less node, &lt;code&gt;Mnesia&lt;/code&gt; does not use the disc on that particular node. The disc use is enabled by changing the storage type of table &lt;code&gt;schema&lt;/code&gt; to &lt;code&gt;disc_copies&lt;/code&gt;.</source>
          <target state="translated">Si el tipo de almacenamiento del esquema es &lt;code&gt;ram_copies&lt;/code&gt; , es decir, un nodo sin disco, &lt;code&gt;Mnesia&lt;/code&gt; no usa el disco en ese nodo en particular. El uso del disco se habilita cambiando el tipo de almacenamiento del &lt;code&gt;schema&lt;/code&gt; de tabla a &lt;code&gt;disc_copies&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72c9602796f4ff2e2861a3fe314dbf863ef6f3fa" translate="yes" xml:space="preserve">
          <source>If the structured type has a component with an embedded &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; which embedded type in turn is a &lt;code&gt;SEQUENCE&lt;/code&gt;/&lt;code&gt;SET&lt;/code&gt;, it gives a record with the &lt;code&gt;SEQUENCE OF&lt;/code&gt;/&lt;code&gt;SET OF&lt;/code&gt; addition as in the following example:</source>
          <target state="translated">Si el tipo estructurado tiene un componente con una &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; incrustado cuyo tipo incrustado a su vez es una &lt;code&gt;SEQUENCE&lt;/code&gt; / &lt;code&gt;SET&lt;/code&gt; , da un registro con la adici&amp;oacute;n &lt;code&gt;SEQUENCE OF&lt;/code&gt; / &lt;code&gt;SET OF&lt;/code&gt; como en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="3f062c1144e1678c566106b319cf580ce31c88b8" translate="yes" xml:space="preserve">
          <source>If the style sheet is installed as in this example, the categories are private to the suite in question. They can be used by all test cases in the suite, but cannot be used by other suites. A suite private style sheet, if specified, is used in favor of a global style sheet (one specified with flag &lt;code&gt;-stylesheet&lt;/code&gt;). A stylesheet tuple (as returned by &lt;code&gt;suite/0&lt;/code&gt; above) can also be returned from a test case information function. In this case the categories specified in the style sheet can only be used in that particular test case. A test case private style sheet is used in favor of a suite or global level style sheet.</source>
          <target state="translated">Si la hoja de estilo se instala como en este ejemplo, las categor&amp;iacute;as son privadas para la suite en cuesti&amp;oacute;n. Pueden ser utilizados por todos los casos de prueba de la suite, pero no pueden ser utilizados por otras suites. Una hoja de estilo privada de la suite, si se especifica, se usa a favor de una hoja de estilo global (una especificada con flag &lt;code&gt;-stylesheet&lt;/code&gt; ). Una tupla de hoja de estilo (como la devuelve &lt;code&gt;suite/0&lt;/code&gt; arriba) tambi&amp;eacute;n se puede devolver desde una funci&amp;oacute;n de informaci&amp;oacute;n de caso de prueba. En este caso, las categor&amp;iacute;as especificadas en la hoja de estilo solo se pueden usar en ese caso de prueba en particular. Se utiliza una hoja de estilo privada de caso de prueba a favor de una suite o una hoja de estilo de nivel global.</target>
        </trans-unit>
        <trans-unit id="5ef2b08f553195b967c4c1ec0d687b8410583635" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;aaaac...&quot;, after the first match attempt fails (starting at the first character in the string), the starting point skips on to start the next attempt at &quot;c&quot;. Notice that a possessive quantifier does not have the same effect as this example; although it would suppress backtracking during the first match attempt, the second attempt would start at the second character instead of skipping on to &quot;c&quot;.</source>
          <target state="translated">Si el sujeto es &quot;aaaac...&quot;,después de que falle el primer intento de coincidencia (empezando por el primer carácter de la cadena),el punto de partida se salta para empezar el siguiente intento en &quot;c&quot;.Nótese que un cuantificador posesivo no tiene el mismo efecto que este ejemplo;aunque suprimiría el retroceso durante el primer intento de coincidencia,el segundo intento comenzaría en el segundo carácter en lugar de saltar a la &quot;c&quot;.</target>
        </trans-unit>
        <trans-unit id="325365b23f57e117a3a5f1be4ba75e874fad7352" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;abac&quot;, Perl matches, but PCRE fails because the (*COMMIT) in the second repeat of the group acts.</source>
          <target state="translated">Si el sujeto es &quot;abac&quot;,Perl coincide,pero PCRE falla porque el (*COMMIT)en la segunda repetición del grupo actúa.</target>
        </trans-unit>
        <trans-unit id="2a1b1d46006ae1cc02a5125b44f3a589d400f8b8" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;ba&quot;, this pattern does not match. As .*? is ungreedy, it initially matches zero characters. The condition (?=a) then fails, the character &quot;b&quot; is matched, but &quot;c&quot; is not. At this point, matching does not backtrack to .*? as can perhaps be expected from the presence of the | character. The conditional subpattern is part of the single alternative that comprises the whole pattern, and so the match fails. (If there was a backtrack into .*?, allowing it to match &quot;b&quot;, the match would succeed.)</source>
          <target state="translated">Si el sujeto es &quot;ba&quot;,este patrón no coincide.Como el .*? no es codicioso,inicialmente coincide con cero caracteres.La condición (?=a)entonces falla,el carácter &quot;b&quot; coincide,pero &quot;c&quot; no.En este punto,la coincidencia no retrocede a .*? como tal vez pueda esperarse de la presencia del carácter |.El subpatrón condicional es parte de la única alternativa que comprende todo el patrón,y por lo tanto la coincidencia falla.(Si hubiera un retroceso a .*?,permitiéndole coincidir con &quot;b&quot;,la coincidencia tendría éxito).</target>
        </trans-unit>
        <trans-unit id="61ab084c99ad2f6aacca28fcd587b3400e6c929a" translate="yes" xml:space="preserve">
          <source>If the subject is &quot;xyz123abc123&quot;, the match point is the fourth character. Therefore, such a pattern is not implicitly anchored.</source>
          <target state="translated">Si el sujeto es &quot;xyz123abc123&quot;,el punto de coincidencia es el cuarto carácter.Por lo tanto,tal patrón no está implícitamente anclado.</target>
        </trans-unit>
        <trans-unit id="f58702e52fe311a5928a0c529284a25593f9a63b" translate="yes" xml:space="preserve">
          <source>If the subsystems option is not present, the value of &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; is used. This enables the sftp subsystem by default. The option can be set to the empty list if you do not want the daemon to run any subsystems.</source>
          <target state="translated">Si la opci&amp;oacute;n subsystems no est&amp;aacute; presente, se utiliza el valor de &lt;code&gt;ssh_sftpd:subsystem_spec([])&lt;/code&gt; . Esto habilita el subsistema sftp de forma predeterminada. La opci&amp;oacute;n puede establecerse en la lista vac&amp;iacute;a si no desea que el demonio ejecute ning&amp;uacute;n subsistema.</target>
        </trans-unit>
        <trans-unit id="56f01b4c736d33d8a8e4b807a7321e237504b729" translate="yes" xml:space="preserve">
          <source>If the supervisor and its child processes are successfully created (that is, if all child process start functions return &lt;code&gt;{ok,Child}&lt;/code&gt;, &lt;code&gt;{ok,Child,Info}&lt;/code&gt;, or &lt;code&gt;ignore&lt;/code&gt;), the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of the supervisor.</source>
          <target state="translated">Si el supervisor y sus procesos secundarios se crean correctamente (es decir, si todas las funciones de inicio de procesos secundarios devuelven &lt;code&gt;{ok,Child}&lt;/code&gt; , &lt;code&gt;{ok,Child,Info}&lt;/code&gt; o &lt;code&gt;ignore&lt;/code&gt; ), la funci&amp;oacute;n devuelve &lt;code&gt;{ok,Pid}&lt;/code&gt; , donde &lt;code&gt;Pid&lt;/code&gt; es el pid del supervisor.</target>
        </trans-unit>
        <trans-unit id="ce27df4e7a72330922127644fc5b4154720386f2" translate="yes" xml:space="preserve">
          <source>If the supervisor bridge and the subsystem are successfully started, the function returns &lt;code&gt;{ok,Pid}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is is the pid of the supervisor bridge.</source>
          <target state="translated">Si el puente supervisor y el subsistema se inician con &amp;eacute;xito, la funci&amp;oacute;n devuelve &lt;code&gt;{ok,Pid}&lt;/code&gt; , donde &lt;code&gt;Pid&lt;/code&gt; es el pid del puente supervisor.</target>
        </trans-unit>
        <trans-unit id="ee5bca92e596da338cae7a1a6835c08aaca7ab2c" translate="yes" xml:space="preserve">
          <source>If the supervisor is &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the &lt;code&gt;pid()&lt;/code&gt; of the child process. If the specified process is alive, but is not a child of the specified supervisor, the function returns &lt;code&gt;{error,not_found}&lt;/code&gt;. If the child specification identifier is specified instead of a &lt;code&gt;pid()&lt;/code&gt;, the function returns &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt;.</source>
          <target state="translated">Si el supervisor es &lt;code&gt;simple_one_for_one&lt;/code&gt; , &lt;code&gt;Id&lt;/code&gt; debe ser el &lt;code&gt;pid()&lt;/code&gt; del proceso hijo. Si el proceso especificado est&amp;aacute; vivo, pero no es hijo del supervisor especificado, la funci&amp;oacute;n devuelve &lt;code&gt;{error,not_found}&lt;/code&gt; . Si se especifica el identificador de la especificaci&amp;oacute;n secundaria en lugar de un &lt;code&gt;pid()&lt;/code&gt; , la funci&amp;oacute;n devuelve &lt;code&gt;{error,simple_one_for_one}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fde2c4d92373b2df91d47d89bec456be3c098325" translate="yes" xml:space="preserve">
          <source>If the supervisor is not &lt;code&gt;simple_one_for_one&lt;/code&gt;, &lt;code&gt;Id&lt;/code&gt; must be the child specification identifier. The process, if any, is terminated and, unless it is a temporary child, the child specification is kept by the supervisor. The child process can later be restarted by the supervisor. The child process can also be restarted explicitly by calling &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; to remove the child specification.</source>
          <target state="translated">Si el supervisor no es &lt;code&gt;simple_one_for_one&lt;/code&gt; , &lt;code&gt;Id&lt;/code&gt; debe ser el identificador de especificaci&amp;oacute;n secundaria. El proceso, si lo hay, finaliza y, a menos que sea un ni&amp;ntilde;o temporal, el supervisor conserva la especificaci&amp;oacute;n del ni&amp;ntilde;o. Posteriormente, el supervisor puede reiniciar el proceso hijo. El proceso hijo tambi&amp;eacute;n se puede reiniciar expl&amp;iacute;citamente llamando a &lt;code&gt;&lt;a href=&quot;#restart_child-2&quot;&gt;restart_child/2&lt;/a&gt;&lt;/code&gt; . Utilice &lt;code&gt;&lt;a href=&quot;#delete_child-2&quot;&gt;delete_child/2&lt;/a&gt;&lt;/code&gt; para eliminar la especificaci&amp;oacute;n secundaria.</target>
        </trans-unit>
        <trans-unit id="22f9e859ab134b7ee555cf61c0b88a7c31c26892" translate="yes" xml:space="preserve">
          <source>If the supervisor is not running, the function fails with the reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">Si el supervisor no se est&amp;aacute; ejecutando, la funci&amp;oacute;n falla con el motivo &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f1a06a02433874f4dbf2fb6692571bffc468e3a" translate="yes" xml:space="preserve">
          <source>If the suspend count on the process identified by &lt;code&gt;Suspendee&lt;/code&gt; is increased, &lt;code&gt;true&lt;/code&gt; is returned, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si aumenta el recuento de suspensiones en el proceso identificado por &lt;code&gt;Suspendee&lt;/code&gt; , se devuelve &lt;code&gt;true&lt;/code&gt; , de lo contrario &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d5607c3dc66f8ee4fed4118cbb2c89a903f53e7" translate="yes" xml:space="preserve">
          <source>If the syntax for a recursive subpattern call (either by number or by name) is used outside the parentheses to which it refers, it operates like a subroutine in a programming language. The called subpattern can be defined before or after the reference. A numbered reference can be absolute or relative, as in the following examples:</source>
          <target state="translated">Si la sintaxis de una llamada de subpatrón recursiva (ya sea por número o por nombre)se utiliza fuera de los paréntesis a los que se refiere,funciona como una subrutina en un lenguaje de programación.El subpatrón llamado puede definirse antes o después de la referencia.Una referencia numerada puede ser absoluta o relativa,como en los ejemplos siguientes:</target>
        </trans-unit>
        <trans-unit id="2c95678de3724de5573a03d131e0386d7f73cde7" translate="yes" xml:space="preserve">
          <source>If the system consists of several Erlang nodes, each node can use its own version of the release. The release handler is a locally registered process and must be called at each node where an upgrade or downgrade is required. A release handling instruction, &lt;code&gt;sync_nodes&lt;/code&gt;, can be used to synchronize the release handler processes at a number of nodes, see the &lt;code&gt;appup(4)&lt;/code&gt; manual page in SASL.</source>
          <target state="translated">Si el sistema consta de varios nodos Erlang, cada nodo puede usar su propia versi&amp;oacute;n de la versi&amp;oacute;n. El controlador de versiones es un proceso registrado localmente y se debe llamar en cada nodo donde se requiere una actualizaci&amp;oacute;n o degradaci&amp;oacute;n. Se puede usar una instrucci&amp;oacute;n de manejo de &lt;code&gt;sync_nodes&lt;/code&gt; , sync_nodes , para sincronizar los procesos del manejador de versiones en varios nodos, consulte la p&amp;aacute;gina de manual &lt;code&gt;appup(4)&lt;/code&gt; en SASL.</target>
        </trans-unit>
        <trans-unit id="5a9dfa8802f7c28fb7268599a87d430596fb7e4c" translate="yes" xml:space="preserve">
          <source>If the system is halted by the BIF &lt;code&gt;erlang:halt/1&lt;/code&gt;, the slogan is the string parameter passed to the BIF, otherwise it is a description generated by the emulator or the (Erlang) kernel. Normally the message is enough to understand the problem, but some messages are described here. Notice that the suggested reasons for the crash are &lt;strong&gt;only suggestions&lt;/strong&gt;. The exact reasons for the errors can vary depending on the local applications and the underlying operating system.</source>
          <target state="translated">Si el sistema es detenido por el BIF &lt;code&gt;erlang:halt/1&lt;/code&gt; , el eslogan es el par&amp;aacute;metro de cadena que se pasa al BIF; de lo contrario, es una descripci&amp;oacute;n generada por el emulador o el kernel (Erlang). Normalmente, el mensaje es suficiente para comprender el problema, pero aqu&amp;iacute; se describen algunos mensajes. Tenga en cuenta que las razones sugeridas para el bloqueo son &lt;strong&gt;solo sugerencias&lt;/strong&gt; . Las razones exactas de los errores pueden variar seg&amp;uacute;n las aplicaciones locales y el sistema operativo subyacente.</target>
        </trans-unit>
        <trans-unit id="6a757ef96ac1cd490bb1c008318b2e3635c8724c" translate="yes" xml:space="preserve">
          <source>If the system is to be rebooted because of missing heartbeats, or a terminated Erlang runtime system, environment variable &lt;code&gt;HEART_COMMAND&lt;/code&gt; must be set before the system is started. If this variable is not set, a warning text is printed but the system does not reboot.</source>
          <target state="translated">Si el sistema debe reiniciarse debido a la falta de latidos, o un sistema de tiempo de ejecuci&amp;oacute;n Erlang terminado, la variable de entorno &lt;code&gt;HEART_COMMAND&lt;/code&gt; debe configurarse antes de que se inicie el sistema. Si no se establece esta variable, se imprime un texto de advertencia, pero el sistema no se reinicia.</target>
        </trans-unit>
        <trans-unit id="7201254cce87e2757d3c2088109f6b9433e91391" translate="yes" xml:space="preserve">
          <source>If the system upgrade fails, &lt;code&gt;Mnesia&lt;/code&gt; must be restarted on all &lt;code&gt;db_nodes&lt;/code&gt; to restore the old database. The fallback is automatically deinstalled after a successful startup. The function &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; can also be used to deinstall the fallback after a successful system upgrade. Again, this is a distributed operation that is either performed on all &lt;code&gt;db_nodes&lt;/code&gt; or none. Both the installation and deinstallation of fallbacks require Erlang to be operational on all &lt;code&gt;db_nodes&lt;/code&gt;, but it does not matter if &lt;code&gt;Mnesia&lt;/code&gt; is running or not.</source>
          <target state="translated">Si la actualizaci&amp;oacute;n del sistema falla, &lt;code&gt;Mnesia&lt;/code&gt; debe reiniciarse en todos los &lt;code&gt;db_nodes&lt;/code&gt; para restaurar la base de datos anterior. El respaldo se desinstala autom&amp;aacute;ticamente despu&amp;eacute;s de un inicio exitoso. La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#uninstall_fallback-0&quot;&gt;mnesia:uninstall_fallback()&lt;/a&gt;&lt;/code&gt; tambi&amp;eacute;n se puede usar para desinstalar el respaldo despu&amp;eacute;s de una actualizaci&amp;oacute;n exitosa del sistema. Nuevamente, esta es una operaci&amp;oacute;n distribuida que se realiza en todos los &lt;code&gt;db_nodes&lt;/code&gt; o en ninguno. Tanto la instalaci&amp;oacute;n como la desinstalaci&amp;oacute;n de fallbacks requieren que Erlang est&amp;eacute; operativo en todos los &lt;code&gt;db_nodes&lt;/code&gt; , pero no importa si &lt;code&gt;Mnesia&lt;/code&gt; se est&amp;aacute; ejecutando o no.</target>
        </trans-unit>
        <trans-unit id="820e07b72de8d7275e79b190e2ecc622e6ffa577" translate="yes" xml:space="preserve">
          <source>If the system uses release handling, this is to be set to a program similar to &lt;code&gt;start_erl.exe&lt;/code&gt;.</source>
          <target state="translated">Si el sistema usa el manejo de versiones, esto debe configurarse en un programa similar a &lt;code&gt;start_erl.exe&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0d7a8bf37699409a1736ff33b25beed75456c38" translate="yes" xml:space="preserve">
          <source>If the table has been fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the time when the table was first fixed by a process, which either is or is not one of the processes it is fixed by now.</source>
          <target state="translated">Si la tabla se ha arreglado usando &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt;safe_fixtable/2&lt;/a&gt;&lt;/code&gt; , la llamada devuelve una tupla donde &lt;code&gt;FixationTime&lt;/code&gt; es el momento en que la tabla fue arreglada por primera vez por un proceso, que es o no es uno de los procesos que ya est&amp;aacute; arreglado.</target>
        </trans-unit>
        <trans-unit id="28d80bca5a16b32c018007fa19be0d36c5975d0c" translate="yes" xml:space="preserve">
          <source>If the table identifier is invalid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="510048f902d277dbbdb552040e33a360934aad3f" translate="yes" xml:space="preserve">
          <source>If the table is a hash table, that is, if it is not an &lt;code&gt;ordered_set&lt;/code&gt;.</source>
          <target state="translated">Si la tabla es una tabla hash, es decir, si no es un &lt;code&gt;ordered_set&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8586c3c8b193a91489791658c1ee464303da1bd1" translate="yes" xml:space="preserve">
          <source>If the table is a hash table. Contains statistics about the table, such as the maximum, minimum, and average chain length. Having a maximum much larger than the average, and a standard deviation much larger than the expected standard deviation is a sign that the hashing of the terms behaves badly for some reason.</source>
          <target state="translated">Si la mesa es una mesa de hachís.Contiene estadísticas sobre la tabla,como la longitud máxima,mínima y media de la cadena.Tener un máximo mucho mayor que el promedio y una desviación estándar mucho mayor que la desviación estándar esperada es una señal de que el hash de los términos se comporta mal por alguna razón.</target>
        </trans-unit>
        <trans-unit id="fcb4375c9095616a2c1fcb3c7937a674a11eced4" translate="yes" xml:space="preserve">
          <source>If the table is an &lt;code&gt;ordered_set&lt;/code&gt;. (The number of elements is the same as the number of objects in the table.)</source>
          <target state="translated">Si la tabla es un &lt;code&gt;ordered_set&lt;/code&gt; . (El n&amp;uacute;mero de elementos es el mismo que el n&amp;uacute;mero de objetos de la tabla).</target>
        </trans-unit>
        <trans-unit id="fe825b9dd24dc79930168b7d8e9410fc4ed428ff" translate="yes" xml:space="preserve">
          <source>If the table is deleted, the &lt;code&gt;tid()&lt;/code&gt; will be invalid even if another named table is created with the same name.</source>
          <target state="translated">Si se elimina la tabla, &lt;code&gt;tid()&lt;/code&gt; no ser&amp;aacute; v&amp;aacute;lido incluso si se crea otra tabla con el mismo nombre.</target>
        </trans-unit>
        <trans-unit id="8e50f5b3f9353a3565bdface1fd102e6a022cef3" translate="yes" xml:space="preserve">
          <source>If the table is empty, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">Si la tabla est&amp;aacute; vac&amp;iacute;a, se devuelve &lt;code&gt;'$end_of_table'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="060a5cb7c2a9190e262dad862fd197847d59b457" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt; ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f3fb17408533c8e1e68861ca6b015faef26d511" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;&lt;a href=&quot;#safe_fixtable-2&quot;&gt; safe_fixtable/2&lt;/a&gt;&lt;/code&gt;, the call returns a tuple where &lt;code&gt;FixationTime&lt;/code&gt; is the last time when the table changed from unfixed to fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3adb98d90a256345bb402384863d0ffa16d7d03" translate="yes" xml:space="preserve">
          <source>If the table is fixed using &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; or some internal mechanism.</source>
          <target state="translated">Si la tabla se arregla usando &lt;code&gt;ets:safe_fixtable/2&lt;/code&gt; o alg&amp;uacute;n mecanismo interno.</target>
        </trans-unit>
        <trans-unit id="ab8f1f3f8186f2a911707d67d645de8494934784" translate="yes" xml:space="preserve">
          <source>If the table is not fixed at all, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5a1ad070d201f061059ad07a51c09a4b677d0c7" translate="yes" xml:space="preserve">
          <source>If the table never has been fixed, the call returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si la tabla nunca se ha arreglado, la llamada devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1106f60b23247fd532e1f3435b3e146b85e02356" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;ordered_set&lt;/code&gt; and the key of the inserted object &lt;strong&gt;compares equal&lt;/strong&gt; to the key of any object in the table, the old object is replaced.</source>
          <target state="translated">Si el tipo de tabla es &lt;code&gt;ordered_set&lt;/code&gt; y la clave del objeto insertado es &lt;strong&gt;igual&lt;/strong&gt; a la clave de cualquier objeto de la tabla, se reemplaza el objeto antiguo.</target>
        </trans-unit>
        <trans-unit id="4533fa2ede8fbfe73be80457c07b8f040691fe23" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. Avoid duplicate keys, otherwise the file becomes unnecessarily fragmented. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">Si el tipo de tabla se &lt;code&gt;set&lt;/code&gt; y existe m&amp;aacute;s de un objeto con una clave dada, uno de los objetos que se elija. Este no es necesariamente el &amp;uacute;ltimo objeto con la clave dada en la secuencia de objetos devueltos por las funciones de entrada. Evite las claves duplicadas, de lo contrario, el archivo se fragmentar&amp;aacute; innecesariamente. Esto es v&amp;aacute;lido tambi&amp;eacute;n para objetos duplicados almacenados en tablas de tipo &lt;code&gt;bag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56d2753779e61ff48cb39b5aa4b2593e74eb1601" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and more than one object exists with a given key, one of the objects is chosen. This is not necessarily the last object with the given key in the sequence of objects returned by the input functions. This holds also for duplicated objects stored in tables of type &lt;code&gt;bag&lt;/code&gt;.</source>
          <target state="translated">Si el tipo de tabla se &lt;code&gt;set&lt;/code&gt; y existe m&amp;aacute;s de un objeto con una clave dada, uno de los objetos que se elija. Este no es necesariamente el &amp;uacute;ltimo objeto con la clave dada en la secuencia de objetos devueltos por las funciones de entrada. Esto es v&amp;aacute;lido tambi&amp;eacute;n para objetos duplicados almacenados en tablas de tipo &lt;code&gt;bag&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cae4c49d2565269908072cf718d1492a11aec56f" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt; and the key of the inserted objects &lt;strong&gt;matches&lt;/strong&gt; the key of any object in the table, the old object is replaced.</source>
          <target state="translated">Si el tipo de tabla se &lt;code&gt;set&lt;/code&gt; y la clave de los objetos insertados &lt;strong&gt;coincide con&lt;/strong&gt; la clave de cualquier objeto en la tabla, se sustituye el antiguo objeto.</target>
        </trans-unit>
        <trans-unit id="a9fdebabfb947c83919e8f9a54708d4bc09db924" translate="yes" xml:space="preserve">
          <source>If the table type is &lt;code&gt;set&lt;/code&gt;, the function returns either the empty list or a list with one object, as there cannot be more than one object with a given key. If the table type is &lt;code&gt;bag&lt;/code&gt; or &lt;code&gt;duplicate_bag&lt;/code&gt;, the function returns a list of arbitrary length.</source>
          <target state="translated">Si el tipo de tabla se &lt;code&gt;set&lt;/code&gt; , la funci&amp;oacute;n devuelve cualquiera de la lista vac&amp;iacute;a o una lista con un objeto, ya que no puede haber m&amp;aacute;s de un objeto con una clave dada. Si el tipo de tabla es &lt;code&gt;bag&lt;/code&gt; o &lt;code&gt;duplicate_bag&lt;/code&gt; , la funci&amp;oacute;n devuelve una lista de longitud arbitraria.</target>
        </trans-unit>
        <trans-unit id="52326346a5221b9ea31e1cab3b15e1198497f8cc" translate="yes" xml:space="preserve">
          <source>If the table uses &lt;code&gt;==/2&lt;/code&gt; when comparing keys for equality, the &lt;code&gt;qlc&lt;/code&gt; module looks up the constant regardless of which operator is used in the QLC. However, &lt;code&gt;==/2&lt;/code&gt; is to be preferred:</source>
          <target state="translated">Si la tabla usa &lt;code&gt;==/2&lt;/code&gt; al comparar claves para la igualdad, el m&amp;oacute;dulo &lt;code&gt;qlc&lt;/code&gt; busca la constante independientemente del operador que se use en el QLC. Sin embargo, se prefiere &lt;code&gt;==/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c174173c48e462e86139389a0e63bdc440243b08" translate="yes" xml:space="preserve">
          <source>If the table was compressed.</source>
          <target state="translated">Si la mesa fue comprimida.</target>
        </trans-unit>
        <trans-unit id="c18aa6aeb37dae91506c755f84a591f149b7a42e" translate="yes" xml:space="preserve">
          <source>If the target host is a &quot;special&quot; node, the FTP address must be specified in the configuration file as follows:</source>
          <target state="translated">Si el host de destino es un nodo &quot;especial&quot;,la dirección FTP debe especificarse en el archivo de configuración de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ba53604fe2dbaeba0c697aca59ebed25bdd01e29" translate="yes" xml:space="preserve">
          <source>If the target host is something else, for example, a UNIX host, the configuration file must also include the username and password (both strings):</source>
          <target state="translated">Si el host de destino es otra cosa,por ejemplo,un host UNIX,el archivo de configuración debe incluir también el nombre de usuario y la contraseña (ambas cadenas):</target>
        </trans-unit>
        <trans-unit id="df661b54e46a56f3d279f98bcc4be4b32bc0814f" translate="yes" xml:space="preserve">
          <source>If the test case function crashes or exits purposely, it is considered &lt;strong&gt;failed&lt;/strong&gt;. If it returns a value (no matter what value), it is considered successful. An exception to this rule is the return value &lt;code&gt;{skip,Reason}&lt;/code&gt;. If this tuple is returned, the test case is considered skipped and is logged as such.</source>
          <target state="translated">Si la funci&amp;oacute;n del caso de prueba falla o se cierra intencionalmente, se considera &lt;strong&gt;fallida&lt;/strong&gt; . Si devuelve un valor (sin importar el valor), se considera exitoso. Una excepci&amp;oacute;n a esta regla es el valor de retorno &lt;code&gt;{skip,Reason}&lt;/code&gt; . Si se devuelve esta tupla, el caso de prueba se considera omitido y se registra como tal.</target>
        </trans-unit>
        <trans-unit id="4997e9150d0cf8e0e80015106a039f2b0f15d2c2" translate="yes" xml:space="preserve">
          <source>If the test case returns the tuple &lt;code&gt;{comment,Comment}&lt;/code&gt;, the case is considered successful and &lt;code&gt;Comment&lt;/code&gt; is printed in the overview log file. This is equal to calling &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el caso de prueba devuelve la tupla &lt;code&gt;{comment,Comment}&lt;/code&gt; , el caso se considera exitoso y el &lt;code&gt;Comment&lt;/code&gt; se imprime en el archivo de registro general. Esto equivale a llamar &lt;code&gt;&lt;a href=&quot;ct#comment-1&quot;&gt;ct:comment(Comment)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60f08b0f13ca3dba151d2fa93224be6770ab9243" translate="yes" xml:space="preserve">
          <source>If the test is started with option &lt;code&gt;create_priv_dir&lt;/code&gt; set to &lt;code&gt;manual_per_tc&lt;/code&gt;, in order for the test case to use the private directory, it must first create it by calling this function.</source>
          <target state="translated">Si la prueba se inicia con la opci&amp;oacute;n &lt;code&gt;create_priv_dir&lt;/code&gt; establecida en &lt;code&gt;manual_per_tc&lt;/code&gt; , para que el caso de prueba use el directorio privado, primero debe crearlo llamando a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ff477a5e0193222aeda2ed720ed9cd26684dd49a" translate="yes" xml:space="preserve">
          <source>If the test session is instead started with a call to &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt;, the result is that test &lt;code&gt;t1&lt;/code&gt; does not run on &lt;code&gt;ct_node@host_x&lt;/code&gt; (or any other node) while test &lt;code&gt;t3&lt;/code&gt; runs on both &lt;code&gt;ct_node@host_y&lt;/code&gt; and &lt;code&gt;ct_node@host_z&lt;/code&gt;.</source>
          <target state="translated">Si la sesi&amp;oacute;n de prueba se inicia con una llamada a &lt;code&gt;ct_master:run(TestSpecName, [ct_node@host_z], [ct_node@host_x])&lt;/code&gt; , el resultado es que la prueba &lt;code&gt;t1&lt;/code&gt; no se ejecuta en &lt;code&gt;ct_node@host_x&lt;/code&gt; (ni en ning&amp;uacute;n otro nodo) mientras la prueba &lt;code&gt;t3&lt;/code&gt; se ejecuta tanto en &lt;code&gt;ct_node@host_y&lt;/code&gt; como en &lt;code&gt;ct_node@host_z&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66bd8e7ff485cff1898efb9a85ff8aa7af9d4928" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt; Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a10a6be714753d43b2d04e3f31a9e74da2fca330" translate="yes" xml:space="preserve">
          <source>If the text between the parentheses consists of a sequence of digits, the condition is true if a capturing subpattern of that number has previously matched. If more than one capturing subpattern with the same number exists (see section &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; earlier), the condition is true if any of them have matched. An alternative notation is to precede the digits with a plus or minus sign. In this case, the subpattern number is relative rather than absolute. The most recently opened parentheses can be referenced by (?(-1), the next most recent by (?(-2), and so on. Inside loops, it can also make sense to refer to subsequent groups. The next parentheses to be opened can be referenced as (?(+1), and so on. (The value zero in any of these forms is not used; it provokes a compile-time error.)</source>
          <target state="translated">Si el texto entre par&amp;eacute;ntesis consta de una secuencia de d&amp;iacute;gitos, la condici&amp;oacute;n es verdadera si un subpatr&amp;oacute;n de captura de ese n&amp;uacute;mero ha coincidido previamente. Si existe m&amp;aacute;s de un subpatr&amp;oacute;n de captura con el mismo n&amp;uacute;mero (consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#sect12&quot;&gt;Duplicate Subpattern Numbers&lt;/a&gt;&lt;/code&gt; anteriormente), la condici&amp;oacute;n es verdadera si alguno de ellos coincide. Una notaci&amp;oacute;n alternativa es preceder a los d&amp;iacute;gitos con un signo m&amp;aacute;s o menos. En este caso, el n&amp;uacute;mero de subpatr&amp;oacute;n es relativo en lugar de absoluto. Los par&amp;eacute;ntesis abiertos m&amp;aacute;s recientemente pueden ser referenciados por (? (- 1), el siguiente m&amp;aacute;s reciente por (? (- 2), y as&amp;iacute; sucesivamente. Dentro de los bucles, tambi&amp;eacute;n puede tener sentido hacer referencia a grupos posteriores. Los siguientes par&amp;eacute;ntesis a ser abierto puede ser referenciado como (? (+ 1), y as&amp;iacute; sucesivamente (el valor cero en cualquiera de estas formas no se usa; provoca un error en tiempo de compilaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="6ca3d61691a2fc7b57ea4b8b07508db553495848" translate="yes" xml:space="preserve">
          <source>If the timer is of type &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt;, then for each intermediate timout, the reply will be resent (this is valid until the ack is received or the timer expires).</source>
          <target state="translated">Si el temporizador es de tipo &lt;code&gt;#megaco_incr_timer{}&lt;/code&gt; , entonces para cada tiempo de espera intermedio, se reenviar&amp;aacute; la respuesta (esto es v&amp;aacute;lido hasta que se reciba el acuse de recibo o expire el temporizador).</target>
        </trans-unit>
        <trans-unit id="0e94483da50a1b3ed8b94f80ddcd411d6145f16b" translate="yes" xml:space="preserve">
          <source>If the trace tuple has five elements, the fifth element will be sent as the &lt;code&gt;extra&lt;/code&gt; value in the &lt;code&gt;Opts&lt;/code&gt; maps.</source>
          <target state="translated">Si la tupla de seguimiento tiene cinco elementos, el quinto elemento se enviar&amp;aacute; como valor &lt;code&gt;extra&lt;/code&gt; en los mapas de &lt;code&gt;Opts&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ce02e8f59bcb0c0b8b781eb7d69a7e655a35279" translate="yes" xml:space="preserve">
          <source>If the traced node is diskless, &lt;code&gt;ttb&lt;/code&gt; must be started from a trace control node with disk access, and option &lt;code&gt;file&lt;/code&gt; must be specified to function &lt;code&gt;tracer/2&lt;/code&gt; with value &lt;code&gt;{local, File}&lt;/code&gt;, for example:</source>
          <target state="translated">Si el nodo rastreado no tiene disco, &lt;code&gt;ttb&lt;/code&gt; debe iniciarse desde un nodo de control de rastreo con acceso al disco, y el &lt;code&gt;file&lt;/code&gt; opciones debe especificarse para la funci&amp;oacute;n &lt;code&gt;tracer/2&lt;/code&gt; con el valor &lt;code&gt;{local, File}&lt;/code&gt; , por ejemplo:</target>
        </trans-unit>
        <trans-unit id="83ebb917b401f97bb196808428e528b58ff6d85f" translate="yes" xml:space="preserve">
          <source>If the tracing process/port dies or the tracer module returns &lt;code&gt;remove&lt;/code&gt;, the flags are silently removed.</source>
          <target state="translated">Si el proceso / puerto de rastreo muere o el m&amp;oacute;dulo de rastreo vuelve a &lt;code&gt;remove&lt;/code&gt; , los indicadores se eliminan silenciosamente.</target>
        </trans-unit>
        <trans-unit id="73568089bc427934a8063420408d7fe082af563e" translate="yes" xml:space="preserve">
          <source>If the tracing should continue after the function returns, for example if it is a start function that spawns processes to be profiled, you can use &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt;. The tracing has to be stopped at a suitable later time using &lt;code&gt;fprof:trace(stop)&lt;/code&gt;.</source>
          <target state="translated">Si el rastreo debe continuar despu&amp;eacute;s de que la funci&amp;oacute;n regrese, por ejemplo, si es una funci&amp;oacute;n de inicio que genera procesos para ser perfilados, puede usar &lt;code&gt;fprof:apply(M, F, Args, [continue | OtherOpts])&lt;/code&gt; . El rastreo debe detenerse en un momento posterior adecuado mediante &lt;code&gt;fprof:trace(stop)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1df5baebd9c38dac3e2f05812c6dc531db1c4b38" translate="yes" xml:space="preserve">
          <source>If the transport connection with the peer goes down after the request has been sent but before an answer has been received then an attempt is made to resend the request to an alternate peer. If no such peer is available, or if the subsequent &lt;code&gt;pick_peer/4&lt;/code&gt; callback rejects the candidates, then a &lt;code&gt;handle_error/4&lt;/code&gt; callback takes place with &lt;code&gt;Reason = failover&lt;/code&gt;. If a peer is selected then a &lt;code&gt;prepare_retransmit/3&lt;/code&gt; callback takes place, after which the semantics are the same as following an initial &lt;code&gt;prepare_request/3&lt;/code&gt; callback.</source>
          <target state="translated">Si la conexi&amp;oacute;n de transporte con el par se cae despu&amp;eacute;s de que se ha enviado la solicitud, pero antes de que se haya recibido una respuesta, se intenta reenviar la solicitud a un par alternativo. Si no hay ning&amp;uacute;n par disponible, o si la devoluci&amp;oacute;n &lt;code&gt;pick_peer/4&lt;/code&gt; llamada pick_peer / 4 posterior rechaza a los candidatos, se &lt;code&gt;handle_error/4&lt;/code&gt; una devoluci&amp;oacute;n de llamada handle_error / 4 con &lt;code&gt;Reason = failover&lt;/code&gt; . Si se selecciona un par, se lleva a cabo una devoluci&amp;oacute;n &lt;code&gt;prepare_retransmit/3&lt;/code&gt; llamada prepare_retransmit / 3 , despu&amp;eacute;s de lo cual la sem&amp;aacute;ntica es la misma que la siguiente a una devoluci&amp;oacute;n &lt;code&gt;prepare_request/3&lt;/code&gt; llamada prepare_request / 3 inicial .</target>
        </trans-unit>
        <trans-unit id="94a9657c264118b8bd17be6e7ec65d9a46f4bb3e" translate="yes" xml:space="preserve">
          <source>If the upgrade or downgrade fails, the application can end up in an inconsistent state.</source>
          <target state="translated">Si la actualización o la degradación fallan,la aplicación puede terminar en un estado inconsistente.</target>
        </trans-unit>
        <trans-unit id="dcf53bce4100d9193f2229bae322274401770092" translate="yes" xml:space="preserve">
          <source>If the user for some reason wants to pass the trace token to a port, this must be done manually in the code of the port controlling process. The port controlling processes have to check the appropriate sequential trace settings (as obtained from &lt;code&gt;seq_trace:get_token/1&lt;/code&gt;) and include trace information in the message data sent to their respective ports.</source>
          <target state="translated">Si el usuario por alguna raz&amp;oacute;n desea pasar el token de seguimiento a un puerto, debe hacerlo manualmente en el c&amp;oacute;digo del proceso de control del puerto. Los procesos de control de puertos deben verificar la configuraci&amp;oacute;n de seguimiento secuencial apropiada (obtenida de &lt;code&gt;seq_trace:get_token/1&lt;/code&gt; ) e incluir informaci&amp;oacute;n de seguimiento en los datos del mensaje enviados a sus respectivos puertos.</target>
        </trans-unit>
        <trans-unit id="7e2e034ddd571c04bf0e9592e1523dc28c51cfbb" translate="yes" xml:space="preserve">
          <source>If the user has configured transports &lt;strong&gt;with&lt;/strong&gt; options then those will take precedence over these options. See &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files#agent_information&quot;&gt;agent information&lt;/a&gt;&lt;/code&gt; for more info.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99b23a58d8baa9de2a26d48114ccdc0aba9a7898" translate="yes" xml:space="preserve">
          <source>If the user specifies a whole directory of test suites for the test, the execution order of the suites depends on how the files are listed by the operating system, which varies between systems.</source>
          <target state="translated">Si el usuario especifica un directorio completo de suites de prueba para la prueba,el orden de ejecución de las suites depende de la forma en que el sistema operativo enumera los archivos,que varía según los sistemas.</target>
        </trans-unit>
        <trans-unit id="ec74a0aa34a3fff9b86b849a4c4f4303fc09ca09" translate="yes" xml:space="preserve">
          <source>If the user wants to run all test suites for a test object (or an OTP application) by specifying only the top directory (for example, with start flag/option &lt;code&gt;dir&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; primarily looks for test suite modules in a subdirectory named &lt;code&gt;test&lt;/code&gt;. If this subdirectory does not exist, the specified top directory is assumed to be the test directory, and test suites are read from there instead.</source>
          <target state="translated">Si el usuario desea ejecutar todos los conjuntos de pruebas para un objeto de prueba (o una aplicaci&amp;oacute;n OTP) especificando solo el directorio superior (por ejemplo, con el indicador de inicio / opci&amp;oacute;n &lt;code&gt;dir&lt;/code&gt; ), &lt;code&gt;Common Test&lt;/code&gt; busca principalmente los m&amp;oacute;dulos del conjunto de pruebas en un subdirectorio llamado &lt;code&gt;test&lt;/code&gt; . Si este subdirectorio no existe, se supone que el directorio superior especificado es el directorio de prueba y, en su lugar, se leen las suites de prueba desde all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="effd9156da460f544cefc46b3b70768d9f3c1b10" translate="yes" xml:space="preserve">
          <source>If the user wants to update the record, it is more efficient to use &lt;code&gt;write/sticky_write&lt;/code&gt; as the &lt;code&gt;LockKind&lt;/code&gt;. If majority checking is active on the table, it is checked as soon as a write lock is attempted. This can be used to end quickly if the majority condition is not met.</source>
          <target state="translated">Si el usuario desea actualizar el registro, es m&amp;aacute;s eficiente usar &lt;code&gt;write/sticky_write&lt;/code&gt; como &lt;code&gt;LockKind&lt;/code&gt; . Si la verificaci&amp;oacute;n de la mayor&amp;iacute;a est&amp;aacute; activa en la mesa, se verifica tan pronto como se intenta un bloqueo de escritura. Esto se puede utilizar para finalizar r&amp;aacute;pidamente si no se cumple la condici&amp;oacute;n de mayor&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="2a0e7330d21e34b34dfa69e0d3eeb795d5ed2f32" translate="yes" xml:space="preserve">
          <source>If the user wants to view load values as percentage of machine capacity, then this way of measuring presents a problem, because the load values are not restricted to a fixed interval. In this case, the following simple mathematical transformation can produce the load value as a percentage:</source>
          <target state="translated">Si el usuario quiere ver los valores de carga como porcentaje de la capacidad de la máquina,entonces esta forma de medir presenta un problema,porque los valores de carga no están restringidos a un intervalo fijo.En este caso,la siguiente transformación matemática simple puede producir el valor de la carga como un porcentaje:</target>
        </trans-unit>
        <trans-unit id="02fc968f89b25d7af28da18289c9216741ffd871" translate="yes" xml:space="preserve">
          <source>If the user's DSA, RSA or ECDSA key is protected by a passphrase, it can be supplied with thoose options.</source>
          <target state="translated">Si la clave DSA,RSA o ECDSA del usuario está protegida por una frase clave,se puede suministrar con esas opciones.</target>
        </trans-unit>
        <trans-unit id="753352e4298655af61f31e670724bf4c6d758094" translate="yes" xml:space="preserve">
          <source>If the value &lt;code&gt;Value&lt;/code&gt; is equal to the value previously stored for the key, &lt;code&gt;put/2&lt;/code&gt; will do nothing and return quickly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cf4ed00376d14751e45211a8a3a5480eebc775a" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt; (passive mode), the process must explicitly receive incoming data by calling &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; (depending on the type of socket).</source>
          <target state="translated">Si el valor es &lt;code&gt;false&lt;/code&gt; (modo pasivo), el proceso debe recibir expl&amp;iacute;citamente los datos entrantes llamando a &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2,3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_udp#recv-2&quot;&gt;gen_udp:recv/2,3&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;gen_sctp#recv-1&quot;&gt;gen_sctp:recv/1,2&lt;/a&gt;&lt;/code&gt; (dependiendo del tipo de socket ).</target>
        </trans-unit>
        <trans-unit id="f8c0f324daf0fe9bcb732c8ba7fcf4c76dd808ad" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;false&lt;/code&gt;, Igor will read source files without passing them through the Erlang preprocessor (&lt;code&gt;epp&lt;/code&gt;), in order to avoid expansion of preprocessor directives such as &lt;code&gt;-include(...).&lt;/code&gt;, &lt;code&gt;-define(...).&lt;/code&gt; and &lt;code&gt;-ifdef(...)&lt;/code&gt;, and macro calls such as &lt;code&gt;?LINE&lt;/code&gt; and &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;, i.e., preprocessing is not done. (See the module &lt;code&gt;epp_dodger&lt;/code&gt; for details.)</source>
          <target state="translated">Si el valor es &lt;code&gt;false&lt;/code&gt; , Igor leer&amp;aacute; los archivos de origen sin pasarlos por el preprocesador Erlang ( &lt;code&gt;epp&lt;/code&gt; ), para evitar la expansi&amp;oacute;n de las directivas del preprocesador como &lt;code&gt;-include(...).&lt;/code&gt; , &lt;code&gt;-define(...).&lt;/code&gt; y &lt;code&gt;-ifdef(...)&lt;/code&gt; , y llamadas de macro como &lt;code&gt;?LINE&lt;/code&gt; y &lt;code&gt;?MY_MACRO(x, y)&lt;/code&gt; . El valor predeterminado es &lt;code&gt;false&lt;/code&gt; , es decir, no se realiza el preprocesamiento. (Consulte el m&amp;oacute;dulo &lt;code&gt;epp_dodger&lt;/code&gt; para obtener m&amp;aacute;s detalles).</target>
        </trans-unit>
        <trans-unit id="c37d2b8a16c01a498b8f51d057c13420aaeecac6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;once&lt;/code&gt; (&lt;code&gt;{active, once}&lt;/code&gt;), &lt;strong&gt;one&lt;/strong&gt; data message from the socket is sent to the process. To receive one more message, &lt;code&gt;setopts/2&lt;/code&gt; must be called again with option &lt;code&gt;{active, once}&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;once&lt;/code&gt; ( &lt;code&gt;{active, once}&lt;/code&gt; ), se env&amp;iacute;a &lt;strong&gt;un&lt;/strong&gt; mensaje de datos del socket al proceso. Para recibir un mensaje m&amp;aacute;s, se debe volver a llamar a &lt;code&gt;setopts/2&lt;/code&gt; con la opci&amp;oacute;n &lt;code&gt;{active, once}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0edabfc9ae44692cbce9f0269af3098b558ce7c2" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all &lt;code&gt;-import(...)&lt;/code&gt; declarations in the original code will be expanded in the result; otherwise, as much as possible of the original import declarations will be preserved. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , todas las &lt;code&gt;-import(...)&lt;/code&gt; en el c&amp;oacute;digo original se expandir&amp;aacute;n en el resultado; de lo contrario, se conservar&amp;aacute; la mayor cantidad posible de las declaraciones de importaci&amp;oacute;n originales. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ec9a61337586e188fec4ae4002aa86a696c3f2b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all import statements will be removed and calls to imported functions will be expanded to explicit remote calls. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , todas las declaraciones de importaci&amp;oacute;n se eliminar&amp;aacute;n y las llamadas a funciones importadas se expandir&amp;aacute;n a llamadas remotas expl&amp;iacute;citas. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b8cea8ff6b46a563bc83a9fce55c5e6cf84c9e7" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all information messages and warning messages will be suppressed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , se suprimir&amp;aacute;n todos los mensajes de informaci&amp;oacute;n y de advertencia. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3bccb9c8103eb8444c9724207cd93db68090eda5" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all matches &quot;&lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt;&quot; where &lt;code&gt;E&lt;/code&gt; is a case-, if- or receive-expression whose branches all return n-tuples (or explicitly throw exceptions) will be rewritten to bind and export the variables &lt;code&gt;V1&lt;/code&gt;, ..., &lt;code&gt;Vn&lt;/code&gt; directly. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , todas las coincidencias &quot; &lt;code&gt;{V1, ..., Vn} = E&lt;/code&gt; &quot; donde &lt;code&gt;E&lt;/code&gt; es una expresi&amp;oacute;n de caso, si o recepci&amp;oacute;n cuyas ramas devuelven n-tuplas (o arrojan expl&amp;iacute;citamente excepciones) se reescribir&amp;aacute;n para enlazar y exportar las variables &lt;code&gt;V1&lt;/code&gt; , ..., &lt;code&gt;Vn&lt;/code&gt; directamente. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e252402ddfc7629809ad75d385749bf1c28429eb" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, all options that affect how the code is modified are set to &quot;no changes&quot;. For example, to only update guard tests, and nothing else, use the options &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt;. (Recall that options closer to the beginning of the list have higher precedence.)</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , todas las opciones que afectan c&amp;oacute;mo se modifica el c&amp;oacute;digo se establecen en &quot;sin cambios&quot;. Por ejemplo, para actualizar solo las pruebas de protecci&amp;oacute;n, y nada m&amp;aacute;s, use las opciones &lt;code&gt;[new_guard_tests, idem]&lt;/code&gt; . (Recuerde que las opciones m&amp;aacute;s cercanas al principio de la lista tienen mayor prioridad).</target>
        </trans-unit>
        <trans-unit id="661aadd35dfccaaf93a78302865c3cfe6ab3529d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, calls to &lt;code&gt;lists:map/2&lt;/code&gt; and &lt;code&gt;lists:filter/2&lt;/code&gt; will be rewritten using list comprehensions. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , las llamadas a las &lt;code&gt;lists:map/2&lt;/code&gt; y &lt;code&gt;lists:filter/2&lt;/code&gt; se reescribir&amp;aacute;n usando listas por comprensi&amp;oacute;n. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db560d66c74e2b5edc2b415e1318b63374234171" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, existing files will be renamed before new files are opened for writing. The new names are formed by appending the string given by the &lt;code&gt;backup_suffix&lt;/code&gt; option to the original name. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , se cambiar&amp;aacute; el nombre de los archivos existentes antes de que se abran nuevos archivos para escritura. Los nuevos nombres se forman agregando la cadena dada por la opci&amp;oacute;n &lt;code&gt;backup_suffix&lt;/code&gt; al nombre original. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f45a2885644fae2f95e314f116a38cf230d32c75" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be changed to use the old names instead of the new ones, e.g. &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;false&lt;/code&gt;. This option overrides the &lt;code&gt;new_guard_tests&lt;/code&gt; option.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , las pruebas de protecci&amp;oacute;n se cambiar&amp;aacute;n para usar los nombres antiguos en lugar de los nuevos, por ejemplo, &quot; &lt;code&gt;integer(X)&lt;/code&gt; &quot; en lugar de &quot; &lt;code&gt;is_integer(X)&lt;/code&gt; &quot;. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; . Esta opci&amp;oacute;n anula la opci&amp;oacute;n &lt;code&gt;new_guard_tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7cd8fb5c207c507a51e1775733171389edb7af" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, guard tests will be updated to use the new names, e.g. &quot;&lt;code&gt;is_integer(X)&lt;/code&gt;&quot; instead of &quot;&lt;code&gt;integer(X)&lt;/code&gt;&quot;. The default value is &lt;code&gt;true&lt;/code&gt;. See also &lt;code&gt;old_guard_tests&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , las pruebas de protecci&amp;oacute;n se actualizar&amp;aacute;n para usar los nuevos nombres, por ejemplo, &quot; &lt;code&gt;is_integer(X)&lt;/code&gt; &quot; en lugar de &quot; &lt;code&gt;integer(X)&lt;/code&gt; &quot;. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; . Consulte tambi&amp;eacute;n &lt;code&gt;old_guard_tests&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3065ef5e6ab38f54db2ee2363766ab33259e9b9" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, instead of the file being written to disk it will be printed to stdout. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , en lugar de que el archivo se escriba en el disco, se imprimir&amp;aacute; en la salida est&amp;aacute;ndar. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54052ea83b3ce0b0af928cdbcc55b6fae8e4433d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no banner comment will be added at the top of the resulting module, even if the target module does not have the same name as any of the input modules. Instead, Igor will try to preserve the look of the module whose code is at the top of the output. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , no se agregar&amp;aacute; ning&amp;uacute;n comentario de banner en la parte superior del m&amp;oacute;dulo resultante, incluso si el m&amp;oacute;dulo de destino no tiene el mismo nombre que ninguno de los m&amp;oacute;dulos de entrada. En cambio, Igor intentar&amp;aacute; preservar el aspecto del m&amp;oacute;dulo cuyo c&amp;oacute;digo se encuentra en la parte superior de la salida. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f87660fc4a181394247f96baa377c54c6755f37" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , no se modificar&amp;aacute; ning&amp;uacute;n archivo. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df3ab32bc54bd17610cc1947d346139f4464db6e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no files will be modified; this is typically most useful if the &lt;code&gt;verbose&lt;/code&gt; flag is enabled, to generate reports about the program files without affecting them. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , no se modificar&amp;aacute; ning&amp;uacute;n archivo; esto suele ser m&amp;aacute;s &amp;uacute;til si el indicador &lt;code&gt;verbose&lt;/code&gt; est&amp;aacute; habilitado, para generar informes sobre los archivos de programa sin afectarlos. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c857b2ddea91c4f1382dc10632fa790ebcc157d4" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, no header comments will be added to the resulting module at the beginning of each section of code that originates from a particular input module. The default value is &lt;code&gt;false&lt;/code&gt;, which means that section headers are normally added whenever more than two or more modules are merged.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , no se agregar&amp;aacute;n comentarios de encabezado al m&amp;oacute;dulo resultante al comienzo de cada secci&amp;oacute;n de c&amp;oacute;digo que se origine en un m&amp;oacute;dulo de entrada en particular. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; , lo que significa que los encabezados de secci&amp;oacute;n normalmente se agregan siempre que se combinan m&amp;aacute;s de dos o m&amp;aacute;s m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="f7502caa9d0a180e8b6ee5deb22eb2a7558a013b" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, preprocessing will be done when reading the source code. See &lt;code&gt;merge_files/4&lt;/code&gt; for details.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , se realizar&amp;aacute; el preprocesamiento al leer el c&amp;oacute;digo fuente. Consulte &lt;code&gt;merge_files/4&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="3ba203d3ce53c0ee7058adbf1504acdd24b9e757" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , se emitir&amp;aacute;n mensajes de progreso mientras se ejecuta el programa, a menos que la opci&amp;oacute;n &lt;code&gt;quiet&lt;/code&gt; sea &lt;code&gt;true&lt;/code&gt; . El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="915746ee8197f7425e23cffea24b153e1f1e18c8" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running, unless the &lt;code&gt;quiet&lt;/code&gt; option is &lt;code&gt;true&lt;/code&gt;. The default value when calling &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , se emitir&amp;aacute;n mensajes de progreso mientras se ejecuta el programa, a menos que la opci&amp;oacute;n &lt;code&gt;quiet&lt;/code&gt; sea &lt;code&gt;true&lt;/code&gt; . El valor predeterminado al llamar a &lt;code&gt;&lt;a href=&quot;#dir-2&quot;&gt;dir/2&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b91774a83e666475650d9139217c76fff02c41ca" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, progress messages will be output while the program is running; the default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , se emitir&amp;aacute;n mensajes de progreso mientras se ejecuta el programa; el valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87c71038a7138f9d28b15166013d2ec5e72ecbcc" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, source code comments in the original files will be preserved in the output. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , los comentarios del c&amp;oacute;digo fuente en los archivos originales se conservar&amp;aacute;n en la salida. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40369b32150fd62bc05caf551bc811ec5c61e8d3" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, stub module files will be automatically generated for all exported modules that do not have the same name as the target module. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , los archivos del m&amp;oacute;dulo de c&amp;oacute;digo auxiliar se generar&amp;aacute;n autom&amp;aacute;ticamente para todos los m&amp;oacute;dulos exportados que no tengan el mismo nombre que el m&amp;oacute;dulo de destino. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b9de1f4216e6f225a7647de788bed6302d6db97" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, subdirectories will be visited recursively. The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , los subdirectorios se visitar&amp;aacute;n de forma recursiva. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8586c382194eee0170ba6e0221153350f302413e" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, symbolic directory links will be followed. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , se seguir&amp;aacute;n los enlaces de directorios simb&amp;oacute;licos. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3143c0f4c2f0487a47c16bc04f718d7c6ca270ba" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, the resulting code will be processed using the &lt;code&gt;erl_tidy&lt;/code&gt; module, which removes unused functions and does general code cleanup. (See &lt;code&gt;erl_tidy:module/2&lt;/code&gt; for additional options.) The default value is &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , el c&amp;oacute;digo resultante se procesar&amp;aacute; mediante el m&amp;oacute;dulo &lt;code&gt;erl_tidy&lt;/code&gt; , que elimina las funciones no utilizadas y realiza una limpieza general del c&amp;oacute;digo. (Consulte &lt;code&gt;erl_tidy:module/2&lt;/code&gt; para ver opciones adicionales). El valor predeterminado es &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d698e4a7611a1338e29756a796838536c672223" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, this is equivalent to listing all of the input modules in the &lt;code&gt;export&lt;/code&gt; option. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , esto equivale a enumerar todos los m&amp;oacute;dulos de entrada en la opci&amp;oacute;n de &lt;code&gt;export&lt;/code&gt; aci&amp;oacute;n . El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="365ed702372c3b3974abae9c5b1bac335c2e40e6" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, unused functions will not be removed from the code. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , las funciones no utilizadas no se eliminar&amp;aacute;n del c&amp;oacute;digo. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c43f17f91393f09fcaccf937fae28a97b0723f0d" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;true&lt;/code&gt;, which is the default, everything received from the socket is sent as messages to the receiving process.</source>
          <target state="translated">Si el valor es &lt;code&gt;true&lt;/code&gt; , que es el valor predeterminado, todo lo recibido del socket se env&amp;iacute;a como mensajes al proceso de recepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8c39732459bb5c7d2ede3da9e66866784c1270ea" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, all file attributes &lt;code&gt;-file(...)&lt;/code&gt; in the input sources will be preserved in the resulting code. If the value is &lt;code&gt;comment&lt;/code&gt;, they will be turned into comments, but remain in their original positions in the code relative to the other source code forms. If the value is &lt;code&gt;no&lt;/code&gt;, all file attributes will be removed from the code, unless they have attached comments, in which case they will be handled as in the &lt;code&gt;comment&lt;/code&gt; case. The default value is &lt;code&gt;no&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;yes&lt;/code&gt; , todos los atributos de archivo &lt;code&gt;-file(...)&lt;/code&gt; en las fuentes de entrada se conservar&amp;aacute;n en el c&amp;oacute;digo resultante. Si el valor es &lt;code&gt;comment&lt;/code&gt; , se convertir&amp;aacute;n en comentarios, pero permanecer&amp;aacute;n en sus posiciones originales en el c&amp;oacute;digo en relaci&amp;oacute;n con las otras formas del c&amp;oacute;digo fuente. Si el valor es &lt;code&gt;no&lt;/code&gt; , todos los atributos del archivo se eliminar&amp;aacute;n del c&amp;oacute;digo, a menos que tengan comentarios adjuntos, en cuyo caso se manejar&amp;aacute;n como en el caso de &lt;code&gt;comment&lt;/code&gt; . El valor predeterminado es &lt;code&gt;no&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adbcfdf4ba5a2347d9fb627ce201117dc5c0ef19" translate="yes" xml:space="preserve">
          <source>If the value is &lt;code&gt;yes&lt;/code&gt;, comments will be inserted where important changes have been made in the code. If the value is &lt;code&gt;always&lt;/code&gt;, &lt;strong&gt;all&lt;/strong&gt; changes to the code will be commented. If the value is &lt;code&gt;no&lt;/code&gt;, changes will be made without comments. The default value is &lt;code&gt;yes&lt;/code&gt;.</source>
          <target state="translated">Si el valor es &lt;code&gt;yes&lt;/code&gt; , se insertar&amp;aacute;n comentarios donde se hayan realizado cambios importantes en el c&amp;oacute;digo. Si el valor es &lt;code&gt;always&lt;/code&gt; , se comentar&amp;aacute;n &lt;strong&gt;todos los&lt;/strong&gt; cambios en el c&amp;oacute;digo. Si el valor es &lt;code&gt;no&lt;/code&gt; , los cambios se realizar&amp;aacute;n sin comentarios. El valor predeterminado es &lt;code&gt;yes&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6e4b8b19f612e8db0497538210759f4a802a7a" translate="yes" xml:space="preserve">
          <source>If the value is an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), the value is added to the socket's count of data messages sent to the controlling process. A socket's default message count is &lt;code&gt;0&lt;/code&gt;. If a negative value is specified, and its magnitude is equal to or greater than the socket's current message count, the socket's message count is set to &lt;code&gt;0&lt;/code&gt;. Once the socket's message count reaches &lt;code&gt;0&lt;/code&gt;, either because of sending received data messages to the process or by being explicitly set, the process is then notified by a special message, specific to the type of socket, that the socket has entered passive mode. Once the socket enters passive mode, to receive more messages &lt;code&gt;setopts/2&lt;/code&gt; must be called again to set the socket back into an active mode.</source>
          <target state="translated">Si el valor es un n&amp;uacute;mero entero &lt;code&gt;N&lt;/code&gt; en el rango de -32768 a 32767 (inclusive), el valor se suma al recuento de mensajes de datos del socket enviados al proceso de control. El recuento de mensajes predeterminado de un socket es &lt;code&gt;0&lt;/code&gt; . Si se especifica un valor negativo y su magnitud es igual o mayor que el recuento de mensajes actual del socket, el recuento de mensajes del socket se establece en &lt;code&gt;0&lt;/code&gt; . Una vez que el recuento de mensajes del socket llega a &lt;code&gt;0&lt;/code&gt; , ya sea por enviar mensajes de datos recibidos al proceso o por haber sido configurado expl&amp;iacute;citamente, el proceso es notificado mediante un mensaje especial, espec&amp;iacute;fico para el tipo de socket, que el socket ha entrado en modo pasivo. Una vez que el socket entra en modo pasivo, para recibir m&amp;aacute;s mensajes &lt;code&gt;setopts/2&lt;/code&gt; debe llamarse de nuevo para poner el socket de nuevo en un modo activo.</target>
        </trans-unit>
        <trans-unit id="1d64e50bdb357fa38cbabe7df4a1ba284de8e2a3" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is not changed. To reset unspecified data to default values, use &lt;code&gt;&lt;a href=&quot;#set_handler_config-3&quot;&gt; set_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5530eeda0dbd39b2cfac3192200b6c910a3a3fc5" translate="yes" xml:space="preserve">
          <source>If the value is incomplete, which for example can be the case for the &lt;code&gt;config&lt;/code&gt; key, it is up to the handler implementation how the unspecified parts are set. For all handlers in the Kernel application, unspecified data for the &lt;code&gt;config&lt;/code&gt; key is set to default values. To update only specified data, and keep the existing configuration for the rest, use &lt;code&gt;&lt;a href=&quot;#update_handler_config-3&quot;&gt; update_handler_config/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f27ae6e2444bd7a3381110a92ec6a09bd736a61c" translate="yes" xml:space="preserve">
          <source>If the value is unreached, the socket closes for that connection.</source>
          <target state="translated">Si no se alcanza el valor,el enchufe se cierra para esa conexión.</target>
        </trans-unit>
        <trans-unit id="f1873f4ce26bcbe85d55d9e02a463ab1ca24901c" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;keep_labels&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, which is the default, the &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; of vertices and edges of &lt;code&gt;Digraph&lt;/code&gt; are used for the subgraph as well. If the value is &lt;code&gt;false&lt;/code&gt;, default label &lt;code&gt;[]&lt;/code&gt; is used for the vertices and edges of the subgroup.</source>
          <target state="translated">Si el valor de la opci&amp;oacute;n &lt;code&gt;keep_labels&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , que es el valor predeterminado, las &lt;code&gt;&lt;a href=&quot;#label&quot;&gt;labels&lt;/a&gt;&lt;/code&gt; de v&amp;eacute;rtices y bordes de &lt;code&gt;Digraph&lt;/code&gt; tambi&amp;eacute;n se usan para el subgr&amp;aacute;fico . Si el valor es &lt;code&gt;false&lt;/code&gt; , la etiqueta predeterminada &lt;code&gt;[]&lt;/code&gt; se usa para los v&amp;eacute;rtices y bordes del subgrupo.</target>
        </trans-unit>
        <trans-unit id="4ff461d2c9c387ebf9328f2e5d5e82024d6aaa59" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;&lt;a href=&quot;digraph#new-1&quot;&gt;digraph:new/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcc67adc4c7849178ee3be6d998ddde43abc28f4" translate="yes" xml:space="preserve">
          <source>If the value of option &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;inherit&lt;/code&gt;, which is the default, the type of &lt;code&gt;Digraph&lt;/code&gt; is used for the subgraph as well. Otherwise the option value of &lt;code&gt;type&lt;/code&gt; is used as argument to &lt;code&gt;digraph:new/1&lt;/code&gt;.</source>
          <target state="translated">Si el valor del &lt;code&gt;type&lt;/code&gt; de opci&amp;oacute;n es &lt;code&gt;inherit&lt;/code&gt; , que es el predeterminado, el tipo de &lt;code&gt;Digraph&lt;/code&gt; tambi&amp;eacute;n se usa para el subgr&amp;aacute;fico . De lo contrario, el valor de la opci&amp;oacute;n de &lt;code&gt;type&lt;/code&gt; se utiliza como argumento para &lt;code&gt;digraph:new/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba47bdc09cc087bab1feb6d4f337fa682850229e" translate="yes" xml:space="preserve">
          <source>If the values listed in &lt;code&gt;os_mon.app&lt;/code&gt; do not suit your needs, do &lt;strong&gt;not&lt;/strong&gt; edit that file. Instead &lt;strong&gt;override&lt;/strong&gt; the values in a &lt;strong&gt;system configuration file&lt;/strong&gt;, the full pathname of which is given on the command line to &lt;code&gt;erl&lt;/code&gt;.</source>
          <target state="translated">Si los valores enumerados en &lt;code&gt;os_mon.app&lt;/code&gt; no se ajustan a sus necesidades, &lt;strong&gt;no&lt;/strong&gt; edite ese archivo. En su lugar, &lt;strong&gt;anule&lt;/strong&gt; los valores en un &lt;strong&gt;archivo de configuraci&amp;oacute;n del sistema&lt;/strong&gt; , cuyo nombre de ruta completo se proporciona en la l&amp;iacute;nea de comando a &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="637ddb8332f78117eadb8a8c376db3cd6652f59a" translate="yes" xml:space="preserve">
          <source>If the variable &lt;code&gt;V&lt;/code&gt; is unbound, it becomes bound to the value associated with the key &lt;code&gt;K&lt;/code&gt;, which must exist in the map &lt;code&gt;M&lt;/code&gt;. If the variable &lt;code&gt;V&lt;/code&gt; is bound, it must match the value associated with &lt;code&gt;K&lt;/code&gt; in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Si la variable &lt;code&gt;V&lt;/code&gt; es no unido, que se une a los valor asociado a la clave &lt;code&gt;K&lt;/code&gt; , que debe existir en el mapa &lt;code&gt;M&lt;/code&gt; . Si la variable &lt;code&gt;V&lt;/code&gt; est&amp;aacute; obligado, que debe coincidir con el valor asociado con &lt;code&gt;K&lt;/code&gt; en &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e06ed1ef13287cb442c8f8b9883fc1684b5a4b49" translate="yes" xml:space="preserve">
          <source>If the variable is set to &lt;code&gt;0&lt;/code&gt; seconds, the runtime system does not even attempt to write the crash dump file. It only terminates. This is the default if option &lt;code&gt;-heart&lt;/code&gt; is passed to &lt;code&gt;erl&lt;/code&gt; and &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is not set.</source>
          <target state="translated">Si la variable se establece en &lt;code&gt;0&lt;/code&gt; segundos, el sistema de tiempo de ejecuci&amp;oacute;n ni siquiera intenta escribir el archivo de volcado por ca&amp;iacute;da. Solo termina. Este es el valor predeterminado si se pasa la opci&amp;oacute;n &lt;code&gt;-heart&lt;/code&gt; a &lt;code&gt;erl&lt;/code&gt; y no se establece &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="259fac0804e610fe7290a6be7722e9d68bc70fed" translate="yes" xml:space="preserve">
          <source>If the variable is set to a positive value &lt;code&gt;S&lt;/code&gt;, wait for &lt;code&gt;S&lt;/code&gt; seconds to complete the crash dump file and then terminates the runtime system with a &lt;code&gt;SIGALRM&lt;/code&gt; signal.</source>
          <target state="translated">Si la variable se establece en un valor positivo &lt;code&gt;S&lt;/code&gt; , espere &lt;code&gt;S&lt;/code&gt; segundos para completar el archivo de volcado por ca&amp;iacute;da y luego finaliza el sistema en tiempo de ejecuci&amp;oacute;n con una se&amp;ntilde;al &lt;code&gt;SIGALRM&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5ca06888e679b9ce4fb0be32462ee441fe3c9ca" translate="yes" xml:space="preserve">
          <source>If the verify callback fun always returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the TLS/DTLS handshake does not terminate regarding verification failures and the connection is established.</source>
          <target state="translated">Si la diversi&amp;oacute;n de verificaci&amp;oacute;n de devoluci&amp;oacute;n de llamada siempre devuelve &lt;code&gt;{valid, UserState}&lt;/code&gt; , el protocolo de enlace TLS / DTLS no finaliza con respecto a las fallas de verificaci&amp;oacute;n y se establece la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="719c8b9484d3005b5e9e676b6c959670afe78ad3" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped, an alert is sent to the peer, and the TLS/DTLS handshake terminates.</source>
          <target state="translated">Si la diversi&amp;oacute;n de verificaci&amp;oacute;n de devoluci&amp;oacute;n de llamada regresa &lt;code&gt;{fail, Reason}&lt;/code&gt; , el proceso de verificaci&amp;oacute;n se detiene inmediatamente, se env&amp;iacute;a una alerta al par y el protocolo de enlace TLS / DTLS termina.</target>
        </trans-unit>
        <trans-unit id="cde2fb6c16d058822f25ed6337c5a200ce4ffc36" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{fail, Reason}&lt;/code&gt;, the verification process is immediately stopped. If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process is continued. This can be used to accept specific path validation errors, such as &lt;code&gt;selfsigned_peer&lt;/code&gt;, as well as verifying application-specific extensions. If called with an extension unknown to the user application, the return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">Si la diversi&amp;oacute;n de la devoluci&amp;oacute;n de llamada de verificaci&amp;oacute;n regresa &lt;code&gt;{fail, Reason}&lt;/code&gt; , el proceso de verificaci&amp;oacute;n se detiene inmediatamente. Si la diversi&amp;oacute;n de devoluci&amp;oacute;n de llamada de verificaci&amp;oacute;n devuelve &lt;code&gt;{valid, UserState}&lt;/code&gt; , el proceso de verificaci&amp;oacute;n contin&amp;uacute;a. Esto se puede usar para aceptar errores de validaci&amp;oacute;n de ruta espec&amp;iacute;ficos, como &lt;code&gt;selfsigned_peer&lt;/code&gt; , as&amp;iacute; como para verificar extensiones espec&amp;iacute;ficas de la aplicaci&amp;oacute;n. Si se llama con una extensi&amp;oacute;n desconocida para la aplicaci&amp;oacute;n del usuario, se utilizar&amp;aacute; el valor de retorno &lt;code&gt;{unknown, UserState}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ce417b1938b35d2181946cc1bbef96b4151dd19" translate="yes" xml:space="preserve">
          <source>If the verify callback fun returns &lt;code&gt;{valid, UserState}&lt;/code&gt;, the verification process continues.</source>
          <target state="translated">Si la diversi&amp;oacute;n de devoluci&amp;oacute;n de llamada de verificaci&amp;oacute;n devuelve &lt;code&gt;{valid, UserState}&lt;/code&gt; , el proceso de verificaci&amp;oacute;n contin&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="0df79b705a85e7a2500ba7951bd6d85a1ee9ec5b" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="translated">Si la versi&amp;oacute;n le&amp;iacute;da del archivo &lt;code&gt;OTP_VERSION&lt;/code&gt; en un sistema de desarrollo tiene un sufijo &lt;code&gt;**&lt;/code&gt; , el sistema ha sido parcheado usando la herramienta &lt;code&gt;&lt;a href=&quot;../installation_guide/otp-patch-apply&quot;&gt;otp_patch_apply&lt;/a&gt;&lt;/code&gt; . En este caso, el sistema consta de versiones de la aplicaci&amp;oacute;n de varias versiones de OTP. La versi&amp;oacute;n que precede al sufijo &lt;code&gt;**&lt;/code&gt; corresponde a la versi&amp;oacute;n OTP del sistema base que se ha parcheado. Tenga en cuenta que si un sistema de desarrollo se actualiza por otros medios que &lt;code&gt;otp_patch_apply&lt;/code&gt; sean otp_patch_apply , el archivo &lt;code&gt;OTP_VERSION&lt;/code&gt; puede identificar una versi&amp;oacute;n incorrecta de OTP.</target>
        </trans-unit>
        <trans-unit id="e21657b92f7a7a61994f9d4f2c34a81fd507ae44" translate="yes" xml:space="preserve">
          <source>If the version read from the &lt;code&gt;OTP_VERSION&lt;/code&gt; file in a development system has a &lt;code&gt;**&lt;/code&gt; suffix, the system has been patched using the &lt;code&gt;otp_patch_apply&lt;/code&gt; tool. In this case, the system consists of application versions from multiple OTP versions. The version preceding the &lt;code&gt;**&lt;/code&gt; suffix corresponds to the OTP version of the base system that has been patched. Notice that if a development system is updated by other means than &lt;code&gt;otp_patch_apply&lt;/code&gt;, the file &lt;code&gt;OTP_VERSION&lt;/code&gt; can identify an incorrect OTP version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f230a4391a7ac08d14e4fb4510c5ba298ff9d5d7" translate="yes" xml:space="preserve">
          <source>If the wrap log is not full because all files are not yet used, &lt;code&gt;{error, end_of_log}&lt;/code&gt; is returned if trying to step outside the log.</source>
          <target state="translated">Si el registro de ajuste no est&amp;aacute; lleno porque a&amp;uacute;n no se han utilizado todos los archivos &lt;code&gt;{error, end_of_log}&lt;/code&gt; se devuelve {error, end_of_log} si se intenta salir del registro.</target>
        </trans-unit>
        <trans-unit id="f46b1e432470475ec50697579521d2c2bae67ee6" translate="yes" xml:space="preserve">
          <source>If then a new instance of the module is loaded (for example, because of error correction), the code of the previous instance becomes 'old', and all export entries referring to the previous instance are removed. After that, the new instance is loaded as for the first time, and becomes 'current'.</source>
          <target state="translated">Si entonces se carga una nueva instancia del módulo (por ejemplo,debido a la corrección de errores),el código de la instancia anterior se convierte en &quot;antiguo&quot;,y se eliminan todas las entradas de exportación que se refieren a la instancia anterior.Después de eso,la nueva instancia se carga como por primera vez,y se convierte en &quot;actual&quot;.</target>
        </trans-unit>
        <trans-unit id="a1c29be5cd8e91fa1db97518d47656645435250e" translate="yes" xml:space="preserve">
          <source>If there already exists a child specification with the specified identifier, &lt;code&gt;ChildSpec&lt;/code&gt; is discarded, and the function returns &lt;code&gt;{error,already_present}&lt;/code&gt; or &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt;, depending on if the corresponding child process is running or not.</source>
          <target state="translated">Si ya existe una especificaci&amp;oacute;n secundaria con el identificador especificado, &lt;code&gt;ChildSpec&lt;/code&gt; se descarta y la funci&amp;oacute;n devuelve &lt;code&gt;{error,already_present}&lt;/code&gt; o &lt;code&gt;{error,{already_started,Child}}&lt;/code&gt; , dependiendo de si el proceso secundario correspondiente se est&amp;aacute; ejecutando o no.</target>
        </trans-unit>
        <trans-unit id="29f67842a562c035ba90f5d1c233372af3669459" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupBridgeName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">Si ya existe un proceso con el &lt;code&gt;SupBridgeName&lt;/code&gt; especificado , la funci&amp;oacute;n devuelve &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; , donde &lt;code&gt;Pid&lt;/code&gt; es el pid de ese proceso.</target>
        </trans-unit>
        <trans-unit id="b068d3b22b44bd5f6e7c211c147d05d61566b01d" translate="yes" xml:space="preserve">
          <source>If there already exists a process with the specified &lt;code&gt;SupName&lt;/code&gt;, the function returns &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt;, where &lt;code&gt;Pid&lt;/code&gt; is the pid of that process.</source>
          <target state="translated">Si ya existe un proceso con el &lt;code&gt;SupName&lt;/code&gt; especificado , la funci&amp;oacute;n devuelve &lt;code&gt;{error,{already_started,Pid}}&lt;/code&gt; , donde &lt;code&gt;Pid&lt;/code&gt; es el pid de ese proceso.</target>
        </trans-unit>
        <trans-unit id="b8fb3b2e8b37c9a0306fd62b9b9f0fc3fa52b199" translate="yes" xml:space="preserve">
          <source>If there already is current code for the module, that code will remain current and can be called until the &lt;code&gt;on_load&lt;/code&gt; function has returned. If the &lt;code&gt;on_load&lt;/code&gt; function fails, the current code (if any) will remain current. If there is no current code for a module, any process that makes an external call to the module before the &lt;code&gt;on_load&lt;/code&gt; function has finished will be suspended until the &lt;code&gt;on_load&lt;/code&gt; function have finished.</source>
          <target state="translated">Si ya hay un c&amp;oacute;digo actual para el m&amp;oacute;dulo, ese c&amp;oacute;digo seguir&amp;aacute; siendo actual y se puede llamar hasta que la funci&amp;oacute;n &lt;code&gt;on_load&lt;/code&gt; haya regresado. Si la funci&amp;oacute;n &lt;code&gt;on_load&lt;/code&gt; falla, el c&amp;oacute;digo actual (si lo hay) seguir&amp;aacute; siendo actual. Si no hay un c&amp;oacute;digo actual para un m&amp;oacute;dulo, cualquier proceso que realice una llamada externa al m&amp;oacute;dulo antes de que &lt;code&gt;on_load&lt;/code&gt; funci&amp;oacute;n on_load se suspender&amp;aacute; hasta que finalice la funci&amp;oacute;n &lt;code&gt;on_load&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6ff40b943ba1d358ca3fc56a993cb85906a59fb" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828714b66dcf56b96deedb054ba47d438cc6af67" translate="yes" xml:space="preserve">
          <source>If there are enqueued events the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; for the possibly new state is called with the oldest enqueued event, and we start again from the top of this list.</source>
          <target state="translated">Si hay eventos en cola, se llama a la &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; de llamada de estado para el estado posiblemente nuevo con el evento en cola m&amp;aacute;s antiguo, y comenzamos de nuevo desde la parte superior de esta lista.</target>
        </trans-unit>
        <trans-unit id="e9b0222c78d7e23a53bc0a01971716c3d93b0537" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt; erlang:garbage_collect/0 &lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44555dd341d5b0e52ff1661ee5eda131159416ee" translate="yes" xml:space="preserve">
          <source>If there are enqueued events to process when hibrnation is requested, this is optimized by not hibernating but instead calling &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; to simulate that the &lt;code&gt;gen_statem&lt;/code&gt; entered hibernation and immediately got awakened by an enqueued event.</source>
          <target state="translated">Si hay eventos en cola para procesar cuando se solicita la hibrnaci&amp;oacute;n, esto se optimiza no hibernando, sino llamando a &lt;code&gt;erlang:garbage_collect/0&lt;/code&gt; para simular que &lt;code&gt;gen_statem&lt;/code&gt; entr&amp;oacute; en hibernaci&amp;oacute;n e inmediatamente fue despertado por un evento en cola.</target>
        </trans-unit>
        <trans-unit id="8322fe14ba9a9426d69e7f2423c508cc09e9ca48" translate="yes" xml:space="preserve">
          <source>If there are more than one modify_algorithms options, the result is undefined.</source>
          <target state="translated">Si hay más de una opción de modificar_algoritmos,el resultado es indefinido.</target>
        </trans-unit>
        <trans-unit id="3690ce212d6493d7841d406b4cec0802d81f2e96" translate="yes" xml:space="preserve">
          <source>If there are no more associations in the iterator, &lt;code&gt;none&lt;/code&gt; is returned.</source>
          <target state="translated">Si no hay m&amp;aacute;s asociaciones en el iterador, &lt;code&gt;none&lt;/code&gt; se devuelve ninguna .</target>
        </trans-unit>
        <trans-unit id="e9815b352e2d989c9ac48ca673c35c72745e841d" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is not recommended to use this atom as the key for any user records.</source>
          <target state="translated">Si no hay registros en la tabla, esta funci&amp;oacute;n devuelve el &amp;aacute;tomo &lt;code&gt;'$end_of_table'&lt;/code&gt; . No se recomienda utilizar este &amp;aacute;tomo como clave para ning&amp;uacute;n registro de usuario.</target>
        </trans-unit>
        <trans-unit id="45cad60d0486a292ed0c0af70654056064441d58" translate="yes" xml:space="preserve">
          <source>If there are no records in the table, this function returns the atom &lt;code&gt;'$end_of_table'&lt;/code&gt;. It is therefore highly undesirable, but not disallowed, to use this atom as the key for any user records.</source>
          <target state="translated">Si no hay registros en la tabla, esta funci&amp;oacute;n devuelve el &amp;aacute;tomo &lt;code&gt;'$end_of_table'&lt;/code&gt; . Por lo tanto, es altamente indeseable, pero no desaprobado, usar este &amp;aacute;tomo como clave para cualquier registro de usuario.</target>
        </trans-unit>
        <trans-unit id="8503df3ac3ca7273d732e58802cad2a3a0dfc645" translate="yes" xml:space="preserve">
          <source>If there are no suitable peers, or if &lt;code&gt;pick_peer/4&lt;/code&gt; rejects them by returning &lt;code&gt;false&lt;/code&gt;, then &lt;code&gt;{error,no_connection}&lt;/code&gt; is returned. Otherwise &lt;code&gt;pick_peer/4&lt;/code&gt; is followed by a &lt;code&gt;prepare_request/3&lt;/code&gt; callback, the message is encoded and then sent.</source>
          <target state="translated">Si no hay pares adecuados, o si &lt;code&gt;pick_peer/4&lt;/code&gt; los rechaza devolviendo &lt;code&gt;false&lt;/code&gt; , se devuelve &lt;code&gt;{error,no_connection}&lt;/code&gt; . De &lt;code&gt;pick_peer/4&lt;/code&gt; contrario, pick_peer / 4 va seguido de una devoluci&amp;oacute;n &lt;code&gt;prepare_request/3&lt;/code&gt; llamada prepare_request / 3 , el mensaje se codifica y luego se env&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="17bbd36158389d16f581ae00cabe7d0d4b0d0c37" translate="yes" xml:space="preserve">
          <source>If there are open NETCONF sessions on the connection, these will be brutally aborted. To avoid this, close each session with &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Si hay sesiones NETCONF abiertas en la conexi&amp;oacute;n, estas ser&amp;aacute;n brutalmente abortadas. Para evitar esto, cierre cada sesi&amp;oacute;n con &lt;code&gt;&lt;a href=&quot;#close_session-1&quot;&gt;close_session/1,2&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="744bfeb045fa800e48c24a368ddf960ab780e491" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; of the driver. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">Si hay otros &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; del controlador, los recuentos de referencia del controlador simplemente se reducen, de modo que la persona que llama ya no se considera un &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; del controlador. Para escenarios de uso, vea la &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; al principio de este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="ad1eb612ef6dd4e45361d0987788045dfb4b5f75" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of the driver, the reference counts of the driver is merely decreased, so that the caller is no longer considered a &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt;. For use scenarios, see the &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; in the beginning of this module.</source>
          <target state="translated">Si hay otros &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; del controlador, los recuentos de referencia del controlador simplemente se reducen, de modo que la persona que llama ya no se considera un &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;user&lt;/a&gt;&lt;/code&gt; . Para escenarios de uso, vea la &lt;code&gt;&lt;a href=&quot;#scenarios&quot;&gt;description&lt;/a&gt;&lt;/code&gt; al principio de este m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="3a3b63451c0aef92b5965292576792be22d886c0" translate="yes" xml:space="preserve">
          <source>If there are other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; of this driver, the function returns &lt;code&gt;{error, pending_process}&lt;/code&gt;, but if there are no other users, the function call hangs until all open ports are closed.</source>
          <target state="translated">Si hay otros &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; de este controlador, la funci&amp;oacute;n devuelve &lt;code&gt;{error, pending_process}&lt;/code&gt; , pero si no hay otros usuarios, la llamada a la funci&amp;oacute;n se cuelga hasta que se cierran todos los puertos abiertos.</target>
        </trans-unit>
        <trans-unit id="ddfc5d95528ec782f6cb446ae853ade32ce2c1f9" translate="yes" xml:space="preserve">
          <source>If there are two active table replicas, all information is still available if one replica fails. This can be an important property in many applications. Furthermore, if a table replica exists at two specific nodes, applications that execute at either of these nodes can read data from the table without accessing the network. Network operations are considerably slower and consume more resources than local operations.</source>
          <target state="translated">Si hay dos réplicas de la mesa activas,toda la información está disponible si una de las réplicas falla.Esta puede ser una propiedad importante en muchas aplicaciones.Además,si existe una réplica de la tabla en dos nodos específicos,las aplicaciones que se ejecutan en cualquiera de esos nodos pueden leer los datos de la tabla sin acceder a la red.Las operaciones de la red son considerablemente más lentas y consumen más recursos que las operaciones locales.</target>
        </trans-unit>
        <trans-unit id="4c985df66903880210d4fc66a0001c590df114fc" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;erase/1&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="370b7e007fd730b4b67804cb8f3411b765c85a30" translate="yes" xml:space="preserve">
          <source>If there existed a previous persistent term associated with key &lt;code&gt;Key&lt;/code&gt;, a global GC has been initiated when &lt;code&gt;put/2&lt;/code&gt; returns. See &lt;code&gt;&lt;a href=&quot;#description&quot;&gt;Description&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02a74b61b8a7a65ef993947d91f15d8fda49a9eb" translate="yes" xml:space="preserve">
          <source>If there has not been any exceptions in a process, the stacktrace is &lt;code&gt;[]&lt;/code&gt;. After a code change for the process, the stacktrace can also be reset to &lt;code&gt;[]&lt;/code&gt;.</source>
          <target state="translated">Si no ha habido excepciones en un proceso, el seguimiento de pila es &lt;code&gt;[]&lt;/code&gt; . Despu&amp;eacute;s de un cambio de c&amp;oacute;digo para el proceso, el seguimiento de pila tambi&amp;eacute;n se puede restablecer a &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="231307e5b86795ba02c3c7007a265d1b3815a9d6" translate="yes" xml:space="preserve">
          <source>If there is NO &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;Subject&lt;/code&gt; field will be checked. All &lt;code&gt;CN&lt;/code&gt; names will be compared to all hostnames</source>
          <target state="translated">Si NO existe el campo &lt;code&gt;Subject Alternate Name&lt;/code&gt; del &lt;code&gt;Subject&lt;/code&gt; , se marcar&amp;aacute; el campo Asunto . Todos los nombres de &lt;code&gt;CN&lt;/code&gt; se comparar&amp;aacute;n con todos los nombres de host</target>
        </trans-unit>
        <trans-unit id="68e6d1b8204d4e4cbe66b0a3f70bd3fdbea57001" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Subject Alternate Name&lt;/code&gt; field, the &lt;code&gt;{uri_id,string()}&lt;/code&gt; in the function call will be compared to any &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; in the Certificate field. If the two &lt;code&gt;strings()&lt;/code&gt; are equal (case insensitive), there is a match. The same applies for any &lt;code&gt;{dns_id,string()}&lt;/code&gt; in the call which is compared with all &lt;code&gt;{dNSName,string()}&lt;/code&gt; in the Certificate field.</source>
          <target state="translated">Si hay un campo de &lt;code&gt;Subject Alternate Name&lt;/code&gt; , el &lt;code&gt;{uri_id,string()}&lt;/code&gt; en la llamada a la funci&amp;oacute;n se comparar&amp;aacute; con cualquier &lt;code&gt;{uniformResourceIdentifier,string()}&lt;/code&gt; en el campo Certificado. Si las dos &lt;code&gt;strings()&lt;/code&gt; son iguales (no distinguen entre may&amp;uacute;sculas y min&amp;uacute;sculas), hay una coincidencia. Lo mismo se aplica a cualquier &lt;code&gt;{dns_id,string()}&lt;/code&gt; en la llamada que se compara con todos los &lt;code&gt;{dNSName,string()}&lt;/code&gt; en el campo Certificado.</target>
        </trans-unit>
        <trans-unit id="7f945a017af252bdab418ccd24ce5005c146d8f7" translate="yes" xml:space="preserve">
          <source>If there is a &lt;code&gt;Value&lt;/code&gt; in &lt;code&gt;List&lt;/code&gt; such that &lt;code&gt;Pred(Value)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, returns &lt;code&gt;{value, Value}&lt;/code&gt; for the first such &lt;code&gt;Value&lt;/code&gt;, otherwise returns &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si hay un &lt;code&gt;Value&lt;/code&gt; en la &lt;code&gt;List&lt;/code&gt; tal que &lt;code&gt;Pred(Value)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , devuelve &lt;code&gt;{value, Value}&lt;/code&gt; para el primer &lt;code&gt;Value&lt;/code&gt; ese tipo ; de lo contrario, devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f55a97af173d19104e4db4d68ae43bf0a349635" translate="yes" xml:space="preserve">
          <source>If there is a garbage collection before the result is stored, the stack will move and if the &lt;code&gt;d&lt;/code&gt; operand refered to a Y register, the pointer will no longer be valid. (Y registers are stored on the stack.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d37a03a5a10dfe3b584b5087ad2e3ee6b552e40a" translate="yes" xml:space="preserve">
          <source>If there is a matching failure to the right, backtracking onto (*PRUNE) causes it to be triggered, and its action is taken. There can never be a backtrack onto (*COMMIT).</source>
          <target state="translated">Si hay un fallo a la derecha,al retroceder a (*PRUNE)provoca que se dispare,y se toma su acción.Nunca puede haber un retroceso en (*COMMIT).</target>
        </trans-unit>
        <trans-unit id="772eaa5a9bb7c808e1d1ad944ded54de87cfcbf6" translate="yes" xml:space="preserve">
          <source>If there is a syntax error somewhere in the text (like the missing semicolon in the second clause above) this allows Merl to generate an error message pointing to the exact line in your source code. (Just remember to comma-separate the strings in the list, otherwise Erlang will concatenate the string fragments as if they were a single string.)</source>
          <target state="translated">Si hay un error de sintaxis en algún lugar del texto (como el punto y coma que falta en la segunda cláusula anterior)esto permite a Merl generar un mensaje de error que apunta a la línea exacta en su código fuente.(Sólo recuerda separar las cadenas de la lista por comas,de lo contrario Erlang concatenará los fragmentos de la cadena como si fueran una sola cadena).</target>
        </trans-unit>
        <trans-unit id="eb988198b3b89a8ead41c2c06ba00583a45e57ec" translate="yes" xml:space="preserve">
          <source>If there is an &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; option on some level the whole set is replaced by that in that option and &lt;strong&gt;all modify_algorithms are applied&lt;/strong&gt; in level ordering.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8de65cd10bf00bba2999acc7df58c16d7692021" translate="yes" xml:space="preserve">
          <source>If there is data buffered in the socket port, the attempt to shutdown the socket is postponed until that data is written to the kernel socket send buffer. If any errors are encountered, the socket is closed and &lt;code&gt;{error, closed}&lt;/code&gt; is returned on the next &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si hay datos almacenados en el b&amp;uacute;fer en el puerto del socket, el intento de apagar el socket se pospone hasta que esos datos se escriben en el b&amp;uacute;fer de env&amp;iacute;o del socket del n&amp;uacute;cleo. Si se encuentran errores, el conector se cierra y se devuelve &lt;code&gt;{error, closed}&lt;/code&gt; en el siguiente &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#send-2&quot;&gt;send/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab5c589483e29b598b39704e5336b70db6c69642" translate="yes" xml:space="preserve">
          <source>If there is more than one subpattern with the same name, the earliest one is used.</source>
          <target state="translated">Si hay más de un subpatrón con el mismo nombre,se utiliza el más antiguo.</target>
        </trans-unit>
        <trans-unit id="bbc551c6c725ba0dac8c61943a105b6a103c7e97" translate="yes" xml:space="preserve">
          <source>If there is no matching message in the mailbox, the timeout occurs immediately.</source>
          <target state="translated">Si no hay ningún mensaje coincidente en el buzón,el tiempo de espera se produce inmediatamente.</target>
        </trans-unit>
        <trans-unit id="cc738995866b9be8195d9f8399cccd32d281ee8b" translate="yes" xml:space="preserve">
          <source>If there is no matching pattern with a true guard sequence, a &lt;code&gt;case_clause&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Si no hay un patr&amp;oacute;n coincidente con una secuencia de guarda verdadera, se produce un error en tiempo de ejecuci&amp;oacute;n &lt;code&gt;case_clause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f5a0ffa17cfe9167811739038f7d8ac026fb1794" translate="yes" xml:space="preserve">
          <source>If there is no public key of a specified type available, the corresponding entry is ignored. Note that the available set is dependent on the underlying cryptolib and current user's public keys.</source>
          <target state="translated">Si no hay disponible una clave pública de un tipo determinado,se ignora la entrada correspondiente.Tenga en cuenta que el conjunto disponible depende de la criptolib subyacente y de las claves públicas del usuario actual.</target>
        </trans-unit>
        <trans-unit id="2104c47ce32bc96eff6c32dbc5479f514ba24093" translate="yes" xml:space="preserve">
          <source>If there is not enough space available on the heap to satisfy the &lt;code&gt;test_heap&lt;/code&gt; instructions request for memory, then a garbage collection is initiated. It may happen immediately in the &lt;code&gt;test_heap&lt;/code&gt; instruction, or it can be delayed until a later time depending on what state the process is in. If the garbage collection is delayed, any memory needed will be allocated in heap fragments. Heap fragments are extra memory blocks that are a part of the young heap, but are not allocated in the contigious area where terms normally reside. See &lt;code&gt;&lt;a href=&quot;#The-young-heap&quot;&gt;The young heap&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c43ed956f51818838543c55451a2fcd8d8fee88" translate="yes" xml:space="preserve">
          <source>If there was a supervised connection between &lt;code&gt;Handler1&lt;/code&gt; and a process &lt;code&gt;Pid&lt;/code&gt;, there is a supervised connection between &lt;code&gt;Handler2&lt;/code&gt; and &lt;code&gt;Pid&lt;/code&gt; instead.</source>
          <target state="translated">Si hubo una conexi&amp;oacute;n supervisada entre &lt;code&gt;Handler1&lt;/code&gt; y un &lt;code&gt;Pid&lt;/code&gt; de proceso , hay una conexi&amp;oacute;n supervisada entre &lt;code&gt;Handler2&lt;/code&gt; y &lt;code&gt;Pid&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="3c67211fc881043f6c0597b9ecfceb976f47baf4" translate="yes" xml:space="preserve">
          <source>If there was some bug in &lt;code&gt;lists:reverse/1&lt;/code&gt; that made it return something other than &lt;code&gt;[2,1]&lt;/code&gt; when it got &lt;code&gt;[1,2]&lt;/code&gt; as input, then the last test above would throw a &lt;code&gt;badmatch&lt;/code&gt; error. The first two (we assume they do not get a &lt;code&gt;badmatch&lt;/code&gt;) would simply return &lt;code&gt;[]&lt;/code&gt; and &lt;code&gt;[1]&lt;/code&gt;, respectively, so both succeed. (Note that EUnit is not psychic: if you write a test that returns a value, even if it is the wrong value, EUnit will consider it a success. You must make sure that the test is written so that it causes a crash if the result is not what it should be.)</source>
          <target state="translated">Si hab&amp;iacute;a alg&amp;uacute;n error en las &lt;code&gt;lists:reverse/1&lt;/code&gt; que lo hiciera devolver algo distinto de &lt;code&gt;[2,1]&lt;/code&gt; cuando obtuvo &lt;code&gt;[1,2]&lt;/code&gt; como entrada, entonces la &amp;uacute;ltima prueba anterior arrojar&amp;iacute;a un error de &lt;code&gt;badmatch&lt;/code&gt; incorrecta. Los dos primeros (asumimos que no obtienen una &lt;code&gt;badmatch&lt;/code&gt; ) simplemente devolver&amp;iacute;an &lt;code&gt;[]&lt;/code&gt; y &lt;code&gt;[1]&lt;/code&gt; , respectivamente, por lo que ambos tienen &amp;eacute;xito. (Tenga en cuenta que EUnit no es ps&amp;iacute;quico: si escribe una prueba que devuelve un valor, incluso si es un valor incorrecto, EUnit lo considerar&amp;aacute; un &amp;eacute;xito. Debe asegurarse de que la prueba est&amp;eacute; escrita de modo que provoque un bloqueo si el El resultado no es el que deber&amp;iacute;a ser.)</target>
        </trans-unit>
        <trans-unit id="ac4dc8c4f9cc87ef06af906dc31bb54276084fd9" translate="yes" xml:space="preserve">
          <source>If these requirements are not fulfilled, the system may behave very bad.</source>
          <target state="translated">Si no se cumplen estos requisitos,el sistema puede comportarse muy mal.</target>
        </trans-unit>
        <trans-unit id="b741a6b0067d17a99e20727d386f0f44e405815c" translate="yes" xml:space="preserve">
          <source>If these return values are used from a &lt;strong&gt;state enter call&lt;/strong&gt; the &lt;code&gt;OldState&lt;/code&gt; does not change, but if used from an event handling &lt;strong&gt;state callback&lt;/strong&gt; the new &lt;strong&gt;state enter call's&lt;/strong&gt;&lt;code&gt;OldState&lt;/code&gt; will be the current state.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e69ed9e46453ec19298157c854f6a3eaec0abc5" translate="yes" xml:space="preserve">
          <source>If this attribute is not specified, the version defaults to the MD5 checksum of the module.</source>
          <target state="translated">Si no se especifica este atributo,la versión por defecto es la suma de comprobación MD5 del módulo.</target>
        </trans-unit>
        <trans-unit id="aa0c65a5a17658e764f89aa9eb9e0a1ff2afe4bb" translate="yes" xml:space="preserve">
          <source>If this callback is exported but fails, to hide possibly sensitive data, the default function will instead return &lt;code&gt;{State,Info}&lt;/code&gt;, where &lt;code&gt;Info&lt;/code&gt; says nothing but the fact that &lt;code&gt;format_status/2&lt;/code&gt; has crashed.</source>
          <target state="translated">Si esta devoluci&amp;oacute;n de llamada se exporta pero falla, para ocultar datos posiblemente confidenciales, la funci&amp;oacute;n predeterminada devolver&amp;aacute; &lt;code&gt;{State,Info}&lt;/code&gt; , donde &lt;code&gt;Info&lt;/code&gt; no dice nada m&amp;aacute;s que el hecho de que &lt;code&gt;format_status/2&lt;/code&gt; se ha bloqueado.</target>
        </trans-unit>
        <trans-unit id="714e5e0a8e521c47efda0340fa656dbd50e5c01b" translate="yes" xml:space="preserve">
          <source>If this configuration parameter is set, it replaces both the default report callback, and any report callback found in metadata. That is, all reports are converted by this configured function.</source>
          <target state="translated">Si se establece este parámetro de configuración,reemplaza tanto la llamada de informe predeterminada como cualquier llamada de informe que se encuentre en los metadatos.Es decir,todos los informes son convertidos por esta función configurada.</target>
        </trans-unit>
        <trans-unit id="1be583879f0eb7412bbdfda911217bb43a748c07" translate="yes" xml:space="preserve">
          <source>If this does not work on your system, the documentation is included as HTML in the Erlang/OTP release. You can also read the documentation as HTML or download it as PDF from either of the sites www.erlang.se (commercial Erlang) or www.erlang.org (open source). For example, for Erlang/OTP release R9B:</source>
          <target state="translated">Si esto no funciona en su sistema,la documentación se incluye como HTML en la versión Erlang/OTP.También puede leer la documentación como HTML o descargarla como PDF desde cualquiera de los sitios www.erlang.se (Erlang comercial)o www.erlang.org (código abierto).Por ejemplo,para la versión Erlang/OTP R9B:</target>
        </trans-unit>
        <trans-unit id="a3eb530f2543acfe6aa144c1bf97c7dbef8076b8" translate="yes" xml:space="preserve">
          <source>If this feature is used while no such &lt;code&gt;TimeoutType&lt;/code&gt; is running then a time-out event is immediately delivered as when starting a &lt;code&gt;&lt;a href=&quot;#Time-Out%20Zero&quot;&gt;Time-Out Zero&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7ae399292df5e1214de0f1c430950be7c775936" translate="yes" xml:space="preserve">
          <source>If this flag is present, &lt;code&gt;global&lt;/code&gt; does not maintain a fully connected network of distributed Erlang nodes, and then global name registration cannot be used; see &lt;code&gt;global(3)&lt;/code&gt;.</source>
          <target state="translated">Si esta bandera est&amp;aacute; presente, &lt;code&gt;global&lt;/code&gt; no mantiene una red completamente conectada de nodos Erlang distribuidos, y entonces no se puede utilizar el registro de nombre global; ver &lt;code&gt;global(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f07b81995e2058716b31282ea839a19974f67348" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; is returned when there are errors. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si se establece esta bandera, se devuelve &lt;code&gt;{error, Errors, Warnings}&lt;/code&gt; cuando hay errores. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5398762fceee6e07d9e93fb018e02eda7d682593" translate="yes" xml:space="preserve">
          <source>If this flag is set, &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; is returned when there are errors.</source>
          <target state="translated">Si se establece esta bandera &lt;code&gt;{error,ErrorList,WarningList}&lt;/code&gt; cuando hay errores.</target>
        </trans-unit>
        <trans-unit id="6be13d0e071b42b8d41878615f2879c487393169" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field containing &lt;code&gt;Warnings&lt;/code&gt; is added to the tuple returned upon success. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si se establece este indicador, se agrega un campo adicional que contiene &lt;code&gt;Warnings&lt;/code&gt; a la tupla devuelta en caso de &amp;eacute;xito. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3313bf48f0cdfa74884b1da2da53a7543532d3d4" translate="yes" xml:space="preserve">
          <source>If this flag is set, an extra field, containing &lt;code&gt;WarningList&lt;/code&gt;, is added to the tuples returned on success.</source>
          <target state="translated">Si se establece este indicador , se agrega un campo adicional, que contiene &lt;code&gt;WarningList&lt;/code&gt; , a las tuplas devueltas en caso de &amp;eacute;xito.</target>
        </trans-unit>
        <trans-unit id="a4261f0fa61ea721311b8153168daa7bcae82ceb" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to process the action requests itself or to delegate the processing to this function.</source>
          <target state="translated">Si esta función es invocada o no es controlada por la respuesta de la llamada precedente a handle_trans_request/3.La función handle_trans_request/3 puede decidir procesar las peticiones de acción por sí misma o delegar el procesamiento a esta función.</target>
        </trans-unit>
        <trans-unit id="759c6aff89e36cb13b1929cdb56543f2723e5912" translate="yes" xml:space="preserve">
          <source>If this function gets invoked or not, is controlled by the reply from the preceding call to handle_trans_request/3. The handle_trans_request/3 function may decide to return {handle_ack, ack_data()} or {handle_sloppy_ack, ack_data()} meaning that you need an immediate acknowledgement of the reply and that this function should be invoked to handle the acknowledgement.</source>
          <target state="translated">Si esta función es invocada o no,es controlada por la respuesta de la llamada precedente a handle_trans_request/3.La función handle_trans_request/3 puede decidir devolver {handle_ack,ack_data()}o {handle_sloppy_ack,ack_data()}lo que significa que necesita un reconocimiento inmediato de la respuesta y que esta función debería ser invocada para manejar el reconocimiento.</target>
        </trans-unit>
        <trans-unit id="2db2202db664ddf13d01713aaa8bc9ba006f0ed4" translate="yes" xml:space="preserve">
          <source>If this function is called, it can only be called once and must be called before any other functions in the &lt;code&gt;ei&lt;/code&gt; library are called.</source>
          <target state="translated">Si se llama a esta funci&amp;oacute;n, solo se puede llamar una vez y se debe llamar antes de llamar a cualquier otra funci&amp;oacute;n de la biblioteca &lt;code&gt;ei&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63459ad5b8a5024794d9f8294a76e897d53d7890" translate="yes" xml:space="preserve">
          <source>If this function is called, it may only be called once directly after the call to function &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se llama a esta funci&amp;oacute;n, solo se puede llamar una vez directamente despu&amp;eacute;s de la llamada a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#erl_init&quot;&gt;erl_init()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cdd06471c1b7c9a2e79736c5c3baade29102ed76" translate="yes" xml:space="preserve">
          <source>If this function is called, it will be called again, either with &lt;code&gt;undo&lt;/code&gt; or with &lt;code&gt;set&lt;/code&gt; as first argument.</source>
          <target state="translated">Si se llama a esta funci&amp;oacute;n, se volver&amp;aacute; a llamar, ya sea con &lt;code&gt;undo&lt;/code&gt; o con &lt;code&gt;set&lt;/code&gt; como primer argumento.</target>
        </trans-unit>
        <trans-unit id="57d5ad72a18485e89bafa2b5eeeeaab800a1356c" translate="yes" xml:space="preserve">
          <source>If this function is not called, the start function returns an error tuple (if a link and/or a time-out is used) or hang otherwise.</source>
          <target state="translated">Si no se llama a esta función,la función de inicio devuelve una tupla de error (si se utiliza un enlace y/o un time-out)o se cuelga de otra manera.</target>
        </trans-unit>
        <trans-unit id="8c7cb778dcaeb301678f8381c719400450da4a70" translate="yes" xml:space="preserve">
          <source>If this function returns with a next state that does not match equal (&lt;code&gt;=/=&lt;/code&gt;) to the current state, all postponed events are retried in the next state.</source>
          <target state="translated">Si esta funci&amp;oacute;n regresa con un siguiente estado que no coincide ( &lt;code&gt;=/=&lt;/code&gt; ) con el estado actual, todos los eventos pospuestos se reintentan en el siguiente estado.</target>
        </trans-unit>
        <trans-unit id="3a0ed99dde48840d29c014e939552bc11b14d1d1" translate="yes" xml:space="preserve">
          <source>If this function's body does not return an inline constant value the callback module is doing something strange.</source>
          <target state="translated">Si el cuerpo de esta función no devuelve un valor constante en línea,el módulo de devolución de llamada está haciendo algo extraño.</target>
        </trans-unit>
        <trans-unit id="33d0e448805fb8a37d99a0aff84679f18601e686" translate="yes" xml:space="preserve">
          <source>If this is a &lt;strong&gt;state change&lt;/strong&gt;, the queue of incoming events is reset to start with the oldest postponed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82460753c54ada648d7c9b05b35bd78eae8d83fe" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean use something like this:</source>
          <target state="translated">Si esto es un problema;para generar un booleano usar algo como esto:</target>
        </trans-unit>
        <trans-unit id="c64d2ab7023f50eed11754a4818012e0a3833abd" translate="yes" xml:space="preserve">
          <source>If this is a problem; to generate a boolean with these algorithms use something like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ac87d883ad765b014bd68fa86e8b2ac8f132c75" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NOASSERT macro, forcing the assert macros to always be enabled regardless of other settings.</source>
          <target state="translated">Si se define esta macro,anula la macro NOASSERT,obligando a que las macros de afirmación estén siempre activadas independientemente de otras configuraciones.</target>
        </trans-unit>
        <trans-unit id="ef12b2a17adab036f91ae1c37a457dabe1673cb6" translate="yes" xml:space="preserve">
          <source>If this macro is defined, it overrides the NODEBUG macro, forcing the debugging macros to be enabled.</source>
          <target state="translated">Si se define esta macro,anula la macro NODEBUG,obligando a activar las macros de depuración.</target>
        </trans-unit>
        <trans-unit id="f89fd4ecae86929dc6deae32a5e245a30ab74c60" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the assert macros will have no effect, when testing is also disabled. See &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt;. When testing is enabled, the assert macros are always enabled automatically and cannot be disabled.</source>
          <target state="translated">Si se define esta macro, las macros de aserci&amp;oacute;n no tendr&amp;aacute;n ning&amp;uacute;n efecto cuando las pruebas tambi&amp;eacute;n est&amp;eacute;n deshabilitadas. Consulte &lt;code&gt;&lt;a href=&quot;#Assert_macros&quot;&gt;Assert macros&lt;/a&gt;&lt;/code&gt; . Cuando la prueba est&amp;aacute; habilitada, las macros de aserci&amp;oacute;n siempre se habilitan autom&amp;aacute;ticamente y no se pueden deshabilitar.</target>
        </trans-unit>
        <trans-unit id="79358b57c58e42b823acfaf278614ec9c7ce54cc" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the automatic exporting or stripping of test functions will be disabled.</source>
          <target state="translated">Si se define esta macro,se desactivará la exportación automática o la eliminación de las funciones de prueba.</target>
        </trans-unit>
        <trans-unit id="6681ab5371316488374f8d3a60e956558c52d69e" translate="yes" xml:space="preserve">
          <source>If this macro is defined, the debugging macros will have no effect. See &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;NODEBUG&lt;/code&gt; also implies &lt;code&gt;NOASSERT&lt;/code&gt;, unless testing is enabled.</source>
          <target state="translated">Si se define esta macro, las macros de depuraci&amp;oacute;n no tendr&amp;aacute;n ning&amp;uacute;n efecto. Consulte &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;NODEBUG&lt;/code&gt; tambi&amp;eacute;n implica &lt;code&gt;NOASSERT&lt;/code&gt; , a menos que las pruebas est&amp;eacute;n habilitadas.</target>
        </trans-unit>
        <trans-unit id="781581d91da20944d9d397cd0ddb27951b613d6e" translate="yes" xml:space="preserve">
          <source>If this option is present, the table data is stored in a more compact format to consume less memory. However, it will make table operations slower. Especially operations that need to inspect entire objects, such as &lt;code&gt;match&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;, get much slower. The key element is not compressed.</source>
          <target state="translated">Si esta opci&amp;oacute;n est&amp;aacute; presente, los datos de la tabla se almacenan en un formato m&amp;aacute;s compacto para consumir menos memoria. Sin embargo, har&amp;aacute; que las operaciones de la tabla sean m&amp;aacute;s lentas. Especialmente las operaciones que necesitan inspeccionar objetos completos, como hacer &lt;code&gt;match&lt;/code&gt; y &lt;code&gt;select&lt;/code&gt; , se vuelven mucho m&amp;aacute;s lentas. El elemento clave no est&amp;aacute; comprimido.</target>
        </trans-unit>
        <trans-unit id="39baea08169404ce3fe44fe53586745d1c2f63db" translate="yes" xml:space="preserve">
          <source>If this option is present, the table is registered under its &lt;code&gt;Name&lt;/code&gt; which can then be used instead of the table identifier in subsequent operations.</source>
          <target state="translated">Si esta opci&amp;oacute;n est&amp;aacute; presente, la tabla se registra bajo su &lt;code&gt;Name&lt;/code&gt; que luego se puede usar en lugar del identificador de la tabla en operaciones posteriores.</target>
        </trans-unit>
        <trans-unit id="ee4b6929098a40cbdbaf168a7fca6dd6bafa6ed5" translate="yes" xml:space="preserve">
          <source>If this option is set, most white space characters in the pattern are totally ignored except when escaped or inside a character class. However, white space is not allowed within sequences such as &lt;code&gt;(?&amp;gt;&lt;/code&gt; that introduce various parenthesized subpatterns, nor within a numerical quantifier such as &lt;code&gt;{1,3}&lt;/code&gt;. However, ignorable white space is permitted between an item and a following quantifier and between a quantifier and a following + that indicates possessiveness.</source>
          <target state="translated">Si se establece esta opci&amp;oacute;n, la mayor&amp;iacute;a de los caracteres de espacio en blanco en el patr&amp;oacute;n se ignoran por completo, excepto cuando se escapan o est&amp;aacute;n dentro de una clase de car&amp;aacute;cter. Sin embargo, no se permiten espacios en blanco dentro de secuencias como &lt;code&gt;(?&amp;gt;&lt;/code&gt; Que introducen varios subpatrones entre par&amp;eacute;ntesis, ni dentro de un cuantificador num&amp;eacute;rico como &lt;code&gt;{1,3}&lt;/code&gt; . Sin embargo, se permiten espacios en blanco ignorables entre un elemento y un cuantificador siguiente y entre un cuantificador y un siguiente + que indica posesividad.</target>
        </trans-unit>
        <trans-unit id="fdc99f2839fcd867c278ae874f9e2a13c5e1d784" translate="yes" xml:space="preserve">
          <source>If this option is written in the source code, as a &lt;code&gt;-compile&lt;/code&gt; directive, the syntax &lt;code&gt;F/A&lt;/code&gt; can be used instead of &lt;code&gt;{F,A}&lt;/code&gt;, for example:</source>
          <target state="translated">Si esta opci&amp;oacute;n est&amp;aacute; escrita en el c&amp;oacute;digo fuente, como una directiva &lt;code&gt;-compile&lt;/code&gt; , se puede usar la sintaxis &lt;code&gt;F/A&lt;/code&gt; en lugar de &lt;code&gt;{F,A}&lt;/code&gt; , por ejemplo:</target>
        </trans-unit>
        <trans-unit id="bd13526ac2fef0e27a961572d9dc8a9a077d1b66" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/hosts&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">Si este par&amp;aacute;metro no se especifica, el valor predeterminado es &lt;code&gt;/etc/hosts&lt;/code&gt; a menos variable de entorno &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; est&amp;aacute; establecida, la cual define el directorio para este archivo a un tal que no sea &lt;code&gt;/etc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe1c08841ffeb7fe23cca25114d889442e8c01cb" translate="yes" xml:space="preserve">
          <source>If this parameter is not specified, it defaults to &lt;code&gt;/etc/resolv.conf&lt;/code&gt; unless environment variable &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; is set, which defines the directory for this file to some maybe other than &lt;code&gt;/etc&lt;/code&gt;.</source>
          <target state="translated">Si no se especifica este par&amp;aacute;metro, el valor predeterminado es &lt;code&gt;/etc/resolv.conf&lt;/code&gt; menos variable de entorno &lt;code&gt;ERL_INET_ETC_DIR&lt;/code&gt; se establece, que define el directorio para este archivo a un tal que no sea &lt;code&gt;/etc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45ec4c57907492a2ec83d9fdbff265e2b0072af9" translate="yes" xml:space="preserve">
          <source>If this pattern is embedded in a larger one, a relative reference can be used:</source>
          <target state="translated">Si este patrón está incrustado en uno más grande,se puede utilizar una referencia relativa:</target>
        </trans-unit>
        <trans-unit id="e8050ea746b1df5e9d9c36102bf42da460ef8d08" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file, which uses Apache-like syntax. The file must include all properties listed under mandatory properties. The Apache-like syntax is the property, written as one word where each new word begins with a capital, followed by a white-space, followed by the value, followed by a new line.</source>
          <target state="translated">Si se define esta propiedad, &lt;code&gt;Inets&lt;/code&gt; espera encontrar todas las dem&amp;aacute;s propiedades definidas en este archivo, que utiliza una sintaxis similar a Apache. El archivo debe incluir todas las propiedades enumeradas en propiedades obligatorias. La sintaxis similar a Apache es la propiedad, escrita como una palabra donde cada nueva palabra comienza con una may&amp;uacute;scula, seguida de un espacio en blanco, seguida del valor, seguida de una nueva l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="09a2a375a69f2029267ac74ac850aabd642821a4" translate="yes" xml:space="preserve">
          <source>If this property is defined, &lt;code&gt;Inets&lt;/code&gt; expects to find all other properties defined in this file. The file must include all properties listed under mandatory properties.</source>
          <target state="translated">Si se define esta propiedad, &lt;code&gt;Inets&lt;/code&gt; espera encontrar todas las dem&amp;aacute;s propiedades definidas en este archivo. El archivo debe incluir todas las propiedades enumeradas en propiedades obligatorias.</target>
        </trans-unit>
        <trans-unit id="fd3402a2f2f441f42f83cdd07b86e7ab04f0ace1" translate="yes" xml:space="preserve">
          <source>If this situation is not acceptable, this function can be used to override the strategy of the Mnesia table load algorithm. This can lead to a situation where some transaction effects are lost with an inconsistent database as result, but for some applications high availability is more important than consistent data.</source>
          <target state="translated">Si esta situación no es aceptable,esta función puede utilizarse para anular la estrategia del algoritmo de carga de la tabla de Mnesia.Esto puede conducir a una situación en la que se pierdan algunos efectos de la transacción con una base de datos incoherente como resultado,pero para algunas aplicaciones la alta disponibilidad es más importante que la consistencia de los datos.</target>
        </trans-unit>
        <trans-unit id="059c4f891420c8ec95d1abb34b55edc8941662f6" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each mib- entry is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic mibentry name is used for different oid's.</source>
          <target state="translated">Si este valor es falso,entonces al cargar un mib-cada entrada del mib-se comprueba antes de la instalación del mib.El propósito de la comprobación es evitar que el mismo nombre simbólico de la mib-entrada sea usado para diferentes oid's.</target>
        </trans-unit>
        <trans-unit id="d5be0ef33ffc0742762d89cfb5dcdc57978e4cec" translate="yes" xml:space="preserve">
          <source>If this value is false, then when loading a mib each trap is checked prior to installation of the mib. The purpose of the check is to prevent that the same symbolic trap name is used for different trap's.</source>
          <target state="translated">Si este valor es falso,entonces al cargar una pluma se comprueba cada trampa antes de la instalación de la pluma.El propósito de la comprobación es evitar que el mismo nombre simbólico de la trampa se utilice para diferentes trampas.</target>
        </trans-unit>
        <trans-unit id="d93bdc2ebb6849c84f900f395d346a1101af31f5" translate="yes" xml:space="preserve">
          <source>If this was part of a larger pattern, you would not want to recurse the entire pattern, so instead you can use:</source>
          <target state="translated">Si esto fuera parte de un patrón más grande,no querría volver a recorrer todo el patrón,así que en su lugar puede usar:</target>
        </trans-unit>
        <trans-unit id="739efd088e9bee0d304554cfa5fdd5c4e61ba305" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time can warp forwards or stop, or even freeze for extended periods of time. There are then no guarantees that the frequency of the Erlang monotonic clock is accurate or stable.</source>
          <target state="translated">Si se desactiva la corrección del tiempo,el tiempo monótono de Erlang puede deformarse hacia adelante o detenerse,o incluso congelarse durante períodos de tiempo prolongados.Entonces no hay garantías de que la frecuencia del reloj monótono de Erlang sea precisa o estable.</target>
        </trans-unit>
        <trans-unit id="ffd673f8288d651f4732e547bc38b22a211807fc" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, Erlang monotonic time leaps forward if OS system time leaps forward. If OS system time leaps backwards, Erlang monotonic time stops briefly, but it does not freeze for extended periods of time. This as the time offset is changed to align Erlang system time with OS system time.</source>
          <target state="translated">Si la corrección de tiempo está desactivada,el tiempo monótono de Erlang salta hacia adelante si el tiempo del sistema operativo salta hacia adelante.Si el tiempo del sistema OS salta hacia atrás,el tiempo monótono de Erlang se detiene brevemente,pero no se congela durante períodos de tiempo prolongados.Esto como el desplazamiento de tiempo se cambia para alinear la hora del sistema Erlang con la del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="e95c3e3e415f307880ab62a824dbb61d407166b0" translate="yes" xml:space="preserve">
          <source>If time correction is disabled, changes in OS system time affects the monotonic clock the same way as when the &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Si la correcci&amp;oacute;n de tiempo est&amp;aacute; deshabilitada, los cambios en la hora del sistema operativo afectan el reloj mon&amp;oacute;tono de la misma manera que cuando se usa el &lt;code&gt;&lt;a href=&quot;#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d01b0a13b53f09d09cc8091e67871a996e4027e2" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, adjustments to the Erlang monotonic clock are made to keep its frequency as correct as possible. However, &lt;strong&gt;no&lt;/strong&gt; adjustments are made trying to align Erlang system time and OS system time. That is, during the preliminary phase Erlang system time and OS system time can diverge from each other, and no attempt is made to prevent this.</source>
          <target state="translated">Si la correcci&amp;oacute;n de tiempo est&amp;aacute; habilitada, se realizan ajustes en el reloj mon&amp;oacute;tono Erlang para mantener su frecuencia lo m&amp;aacute;s correcta posible. Sin embargo, &lt;strong&gt;no&lt;/strong&gt; se realizan ajustes para intentar alinear la hora del sistema Erlang y la hora del sistema operativo. Es decir, durante la fase preliminar, el tiempo del sistema Erlang y el tiempo del sistema operativo pueden diferir entre s&amp;iacute;, y no se intenta evitar esto.</target>
        </trans-unit>
        <trans-unit id="d5d7906513f874fdde48593a22b63bd033c683a3" translate="yes" xml:space="preserve">
          <source>If time correction is enabled, the Erlang runtime system makes use of both &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt;, to adjust the frequency of the Erlang monotonic clock. Time correction ensures that &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; does not warp and that the frequency is relatively accurate. The type of frequency adjustments depends on the time warp mode used. Section &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; provides more details.</source>
          <target state="translated">Si se habilita la correcci&amp;oacute;n de tiempo, las marcas de tiempo de ejecuci&amp;oacute;n del sistema de Erlang uso tanto de &lt;code&gt;&lt;a href=&quot;#OS_System_Time&quot;&gt;OS system time&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#OS_Monotonic_Time&quot;&gt;OS monotonic time&lt;/a&gt;&lt;/code&gt; , para ajustar la frecuencia del reloj mon&amp;oacute;tona Erlang. La correcci&amp;oacute;n de tiempo garantiza que el &lt;code&gt;&lt;a href=&quot;#Erlang_Monotonic_Time&quot;&gt;Erlang monotonic time&lt;/a&gt;&lt;/code&gt; no se deforme y que la frecuencia sea relativamente precisa. El tipo de ajustes de frecuencia depende del modo de deformaci&amp;oacute;n de tiempo utilizado. La secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;Time Warp Modes&lt;/a&gt;&lt;/code&gt; proporciona m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="86c57207a0af2011d419b53ca97897d73a612495" translate="yes" xml:space="preserve">
          <source>If time correction is not enabled, Erlang monotonic time freezes when OS system time leaps backwards. The freeze of monotonic time continues until OS system time catches up. The freeze can continue for a long time. When OS system time leaps forwards, Erlang monotonic time also leaps forward.</source>
          <target state="translated">Si la corrección del tiempo no está activada,el tiempo monótono de Erlang se congela cuando el tiempo del sistema operativo salta hacia atrás.La congelación del tiempo monótono continúa hasta que el tiempo del sistema operativo lo alcance.La congelación puede continuar durante mucho tiempo.Cuando el tiempo del sistema operativo salta hacia adelante,el tiempo monótono de Erlang también salta hacia adelante.</target>
        </trans-unit>
        <trans-unit id="ef091f899ba472aeda63ed1965cfed9d0bedc0a4" translate="yes" xml:space="preserve">
          <source>If trace mode is turned on this tells the ODBC driver to write a trace log to the file SQL.LOG that is placed in the current directory of the erlang emulator. This information may be useful if you suspect there might be a bug in the erlang ODBC application, and it might be relevant for you to send this file to our support. Otherwise you will probably not have much use of this.</source>
          <target state="translated">Si el modo de rastreo está activado,esto le dice al controlador ODBC que escriba un registro de rastreo en el archivo SQL.LOG que se encuentra en el directorio actual del emulador erlang.Esta información puede ser útil si sospecha que puede haber un error en la aplicación ODBC erlang,y puede ser relevante para usted enviar este archivo a nuestro soporte.De lo contrario,es probable que no tenga mucho uso de esto.</target>
        </trans-unit>
        <trans-unit id="06cb7989133609c0050ffc5dbb44bd39095de5a4" translate="yes" xml:space="preserve">
          <source>If tracing could be enabled for &lt;code&gt;P&lt;/code&gt; and all processes in &lt;code&gt;Rootset&lt;/code&gt;, the function returns &lt;code&gt;{ok,Value}&lt;/code&gt; when &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; returns with the value &lt;code&gt;Value&lt;/code&gt;, or &lt;code&gt;{error,Reason}&lt;/code&gt; if &lt;code&gt;Fun()&lt;/code&gt;/&lt;code&gt;apply&lt;/code&gt; fails with exit reason &lt;code&gt;Reason&lt;/code&gt;. Otherwise it returns &lt;code&gt;{error, Reason}&lt;/code&gt; immediately.</source>
          <target state="translated">Si el rastreo se puede habilitar para &lt;code&gt;P&lt;/code&gt; y todos los procesos en &lt;code&gt;Rootset&lt;/code&gt; , la funci&amp;oacute;n devuelve &lt;code&gt;{ok,Value}&lt;/code&gt; cuando &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; devuelve con el valor &lt;code&gt;Value&lt;/code&gt; , o &lt;code&gt;{error,Reason}&lt;/code&gt; si &lt;code&gt;Fun()&lt;/code&gt; / &lt;code&gt;apply&lt;/code&gt; falla con el motivo de salida &lt;code&gt;Reason&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;{error, Reason}&lt;/code&gt; inmediatamente.</target>
        </trans-unit>
        <trans-unit id="171abc361e25e3e1820951c40db50f386bc4e18d" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for ECC curve selection. If false (the default), use the client's preference.</source>
          <target state="translated">Si es cierto,use la preferencia del servidor para la selección de la curva ECC.Si es falso (el valor predeterminado),utilice la preferencia del cliente.</target>
        </trans-unit>
        <trans-unit id="f6448c429179ffe9a0559b10e022f36f7d57c48b" translate="yes" xml:space="preserve">
          <source>If true, use the server's preference for cipher selection. If false (the default), use the client's preference.</source>
          <target state="translated">Si es cierto,utilice la preferencia del servidor para la selección del cifrado.Si es falso (el predeterminado),utilice la preferencia del cliente.</target>
        </trans-unit>
        <trans-unit id="93560debed8026dcf2a2983b09444126fc93994e" translate="yes" xml:space="preserve">
          <source>If two &lt;code&gt;Dates&lt;/code&gt; are specified, reports that occurred between those dates are returned.</source>
          <target state="translated">Si se especifican dos &lt;code&gt;Dates&lt;/code&gt; , se devuelven los informes que ocurrieron entre esas fechas.</target>
        </trans-unit>
        <trans-unit id="33b891be28a40228827989eecbc682bd1e8b9bf9" translate="yes" xml:space="preserve">
          <source>If two matching keys are declared, the latter key takes precedence.</source>
          <target state="translated">Si se declaran dos llaves coincidentes,la última llave tiene prioridad.</target>
        </trans-unit>
        <trans-unit id="67258d8af06879035a6caf89796f47f253a79805" translate="yes" xml:space="preserve">
          <source>If two processes open the same table by giving the same name and arguments, the table has two users. If one user closes the table, it remains open until the second user closes it.</source>
          <target state="translated">Si dos procesos abren la misma tabla dando el mismo nombre y argumentos,la tabla tiene dos usuarios.Si un usuario cierra la tabla,ésta permanece abierta hasta que el segundo usuario la cierre.</target>
        </trans-unit>
        <trans-unit id="2c7260077a6430e57fb912e3299409f44a7a3f23" translate="yes" xml:space="preserve">
          <source>If two processes perform &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; simultaneously, both updates take effect without the risk of losing one of the updates. The new value &lt;code&gt;NewVal&lt;/code&gt; of the counter is returned.</source>
          <target state="translated">Si dos procesos realizan &lt;code&gt;mnesia:dirty_update_counter/3&lt;/code&gt; simult&amp;aacute;neamente, ambas actualizaciones entran en vigor sin el riesgo de perder una de las actualizaciones. Se &lt;code&gt;NewVal&lt;/code&gt; nuevo valor NewVal del contador.</target>
        </trans-unit>
        <trans-unit id="b5c7e523459e9f766dca300b6ab1c5e2e9c17d90" translate="yes" xml:space="preserve">
          <source>If used on the top level in a guard, it tests whether the argument is a floating point number; for clarity, use &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Si se usa en el nivel superior de una guardia, prueba si el argumento es un n&amp;uacute;mero de coma flotante; para mayor claridad, use &lt;code&gt;&lt;a href=&quot;#is_float-1&quot;&gt;is_float/1&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="c1158bf11097606b6592798bf3682a97d2961056" translate="yes" xml:space="preserve">
          <source>If verification is turned on and the file was written with option &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt;, reading the file is slower and consumes radically more CPU time than otherwise.</source>
          <target state="translated">Si la verificaci&amp;oacute;n est&amp;aacute; activada y el archivo se escribi&amp;oacute; con la opci&amp;oacute;n &lt;code&gt;{extended_info, [md5sum]}&lt;/code&gt; , la lectura del archivo es m&amp;aacute;s lenta y consume radicalmente m&amp;aacute;s tiempo de CPU que de otra manera.</target>
        </trans-unit>
        <trans-unit id="79df61d77a356cef20daff35817557c31ea1feae" translate="yes" xml:space="preserve">
          <source>If warnings are turned on (option &lt;code&gt;report_warnings&lt;/code&gt; described earlier), the following options control what type of warnings that are generated.  Except from &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt;, the following options have two forms:</source>
          <target state="translated">Si las advertencias est&amp;aacute;n activadas (opci&amp;oacute;n &lt;code&gt;report_warnings&lt;/code&gt; descrita anteriormente), las siguientes opciones controlan el tipo de advertencias que se generan. A excepci&amp;oacute;n de &lt;code id=&quot;erl_lint_options&quot;&gt;{warn_format,Verbosity}&lt;/code&gt; , las siguientes opciones tienen dos formas:</target>
        </trans-unit>
        <trans-unit id="46f6514af342c03660ff3a127d8c0abce6e94d29" translate="yes" xml:space="preserve">
          <source>If we are connected (and if the connection handle is not &lt;code&gt;NULL&lt;/code&gt;), we log out from the database. We need to check if we should encode an &lt;code&gt;'ok'&lt;/code&gt;, as we can get here from function &lt;code&gt;stop&lt;/code&gt;, which does not return data to the emulator:</source>
          <target state="translated">Si estamos conectados (y si el identificador de conexi&amp;oacute;n no es &lt;code&gt;NULL&lt;/code&gt; ), salimos de la base de datos. Necesitamos verificar si debemos codificar un &lt;code&gt;'ok'&lt;/code&gt; , ya que podemos llegar aqu&amp;iacute; desde la &lt;code&gt;stop&lt;/code&gt; funci&amp;oacute;n , que no devuelve datos al emulador:</target>
        </trans-unit>
        <trans-unit id="3e3531248524d3e767663c5b51a2a6884e4678a8" translate="yes" xml:space="preserve">
          <source>If we are not at security-level &lt;code&gt;noAuthNoPriv&lt;/code&gt;, this could be complicated, since the agent will then continue with stage 2, before which the usm-related updates must be done.</source>
          <target state="translated">Si no estamos en el nivel de seguridad &lt;code&gt;noAuthNoPriv&lt;/code&gt; , esto podr&amp;iacute;a ser complicado, ya que el agente luego continuar&amp;aacute; con la etapa 2, antes de la cual se deben realizar las actualizaciones relacionadas con usm.</target>
        </trans-unit>
        <trans-unit id="5d4840bdbaaa7e01cbfc9ee43e1a031173374de2" translate="yes" xml:space="preserve">
          <source>If we are not connecting, we wait for results from a &lt;code&gt;PQsendQuery&lt;/code&gt;, so we get the result and return it. The encoding is done with the same functions as in the earlier example.</source>
          <target state="translated">Si no nos estamos conectando, esperamos los resultados de una &lt;code&gt;PQsendQuery&lt;/code&gt; , por lo que obtenemos el resultado y lo devolvemos. La codificaci&amp;oacute;n se realiza con las mismas funciones que en el ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="337a2fc4e3a2d30ff212f197ed2e62e6a68516c6" translate="yes" xml:space="preserve">
          <source>If we are sure that this kind of situation cannot ensue, we may specify the involved modules as &quot;safe&quot;, and all calls between them will become local. Note that if the target module itself is specified as safe, &quot;remote&quot; calls to itself will be turned into local calls. This would destroy the code replacement properties of e.g. a typical server loop.</source>
          <target state="translated">Si estamos seguros de que este tipo de situación no puede producirse,podemos especificar los módulos implicados como &quot;seguros&quot;,y todas las llamadas entre ellos serán locales.Tenga en cuenta que si el propio módulo objetivo se especifica como seguro,las llamadas &quot;remotas&quot; a sí mismo se convertirán en llamadas locales.Esto destruiría las propiedades de sustitución de código de,por ejemplo,un bucle típico de servidor.</target>
        </trans-unit>
        <trans-unit id="7b66416ada226ef11ca8c9b5f2f89c92815edf3c" translate="yes" xml:space="preserve">
          <source>If we disregard the contended cases, we will inevitably get a higher latency when scheduling signals for execution at a later time than by executing the signal immediately. In order to preserve the low latency we now first check if this is a contended case or not. If it is, we schedule the signal for later execution; otherwise, we execute the signal immediately. It is a contended case if other signals already are scheduled on the port, or if we fail to acquire the port lock. That is we will not block waiting for the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97b9f19e72ab9cc61b4cedbac5bd537174daa35" translate="yes" xml:space="preserve">
          <source>If we disregard the locking issues, the original solution is very appealing. The mapping from process identifier to index into the array is very fast, and this property is something we would like to keep. The vast majority of operations on these tables are lookups so optimizing for lookups is what we want to do.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea9c359ef122e371e6ca40c1302512863ec587e1" translate="yes" xml:space="preserve">
          <source>If we have a result from a connect, indicated by having data in the &lt;code&gt;x&lt;/code&gt; buffer, we no longer need to select on output (&lt;code&gt;ready_output&lt;/code&gt;), so we remove this by calling &lt;code&gt;driver_select&lt;/code&gt;.</source>
          <target state="translated">Si tenemos un resultado de una conexi&amp;oacute;n, indicado por tener datos en el b&amp;uacute;fer &lt;code&gt;x&lt;/code&gt; , ya no necesitamos seleccionar en la salida ( &lt;code&gt;ready_output&lt;/code&gt; ), por lo que eliminamos esto llamando a &lt;code&gt;driver_select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b39cddb5344c13a7bcee4c7a5972425c4aa9fc95" translate="yes" xml:space="preserve">
          <source>If we have forgotten the &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; there would be a message similar to this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce67181f9dec94f63a49d2d4f68889369954004" translate="yes" xml:space="preserve">
          <source>If we now add the filter to the running &lt;code&gt;Collector&lt;/code&gt;:</source>
          <target state="translated">Si ahora agregamos el filtro al &lt;code&gt;Collector&lt;/code&gt; ejecuci&amp;oacute;n :</target>
        </trans-unit>
        <trans-unit id="f3ffad68dd3aaa3ee27c0008bb99580f0a57f8f2" translate="yes" xml:space="preserve">
          <source>If we now send a message from the shell on the node &lt;code&gt;ant@stack&lt;/code&gt;, where all sends from the shell are traced:</source>
          <target state="translated">Si ahora enviamos un mensaje desde el shell en el nodo &lt;code&gt;ant@stack&lt;/code&gt; , donde se rastrean todos los env&amp;iacute;os desde el shell:</target>
        </trans-unit>
        <trans-unit id="43717b37beb4229f520c407e6567fb6706951645" translate="yes" xml:space="preserve">
          <source>If we only want debug messages from a specific process it is possible to do this with a filter like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcc29b0b458c2d8c07af3ed4af13280313ed829" translate="yes" xml:space="preserve">
          <source>If we only want to match operands of a certain type, we can use a type constraint. A type constraint consists of one or more lowercase letters, each specifying a type. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd0ecc6f7afe07e419db3c1ee4dc39311f3c9091" translate="yes" xml:space="preserve">
          <source>If we remove the &lt;code&gt;-no_next&lt;/code&gt; directive, the code would look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71461022e8b1964785f01d0fea411534999fdbfe" translate="yes" xml:space="preserve">
          <source>If we run it like this: &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; The result will be &lt;code&gt;result_xs.html&lt;/code&gt;. When the input file is of the same structure as the previous &quot;motorcycles&quot; XML files but it has a little more 'bike' elements and the 'manufacturer' elements are not in order.</source>
          <target state="translated">Si lo ejecutamos as&amp;iacute;: &lt;code&gt;motorcycles2html:process_to_file('result_xs.html', 'motorcycles2.xml').&lt;/code&gt; El resultado ser&amp;aacute; &lt;code&gt;result_xs.html&lt;/code&gt; . Cuando el archivo de entrada tiene la misma estructura que los archivos XML de &quot;motocicletas&quot; anteriores, pero tiene un poco m&amp;aacute;s de elementos de &quot;bicicleta&quot; y los elementos de &quot;fabricante&quot; no est&amp;aacute;n en orden.</target>
        </trans-unit>
        <trans-unit id="245971475847fb8e843dded9b9424bc7fe234a7a" translate="yes" xml:space="preserve">
          <source>If we would have had a huge amount of unique identifiers available, it would have tempting to drop or modify this ordering property as described above. The ordering property could for example be based on the scheduler performing the spawn operation. It would have been possible to reserve large ranges of identifiers exclusive for each scheduler thread which could be used minimizing the need for communication when allocating identifiers. The amount of identifiers we got to work with today is, however, not even close to be enough for such an approach.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b8886cb75b357ed32d80a6eee9f949abb29be57" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; x, then x = y (&lt;code&gt;F&lt;/code&gt; is antisymmetric).</source>
          <target state="translated">Si x &lt;code&gt;F&lt;/code&gt; y y y &lt;code&gt;F&lt;/code&gt; x, entonces x = y ( &lt;code&gt;F&lt;/code&gt; es antisim&amp;eacute;trica).</target>
        </trans-unit>
        <trans-unit id="6b92816031334184272820ee86857aab64402f87" translate="yes" xml:space="preserve">
          <source>If x &lt;code&gt;F&lt;/code&gt; y and y &lt;code&gt;F&lt;/code&gt; z, then x &lt;code&gt;F&lt;/code&gt; z (&lt;code&gt;F&lt;/code&gt; is transitive).</source>
          <target state="translated">Si x &lt;code&gt;F&lt;/code&gt; y y y &lt;code&gt;F&lt;/code&gt; z, entonces x &lt;code&gt;F&lt;/code&gt; z ( &lt;code&gt;F&lt;/code&gt; es transitiva).</target>
        </trans-unit>
        <trans-unit id="efd0edc2f934fb0989fdc0ef3a93bc0dc5861448" translate="yes" xml:space="preserve">
          <source>If x is a family from I to X, then x[i] denotes the value of the function at index i. The notation &quot;a family in X&quot; is used for such a family.</source>
          <target state="translated">Si x es una familia de I a X,entonces x[i]denota el valor de la función en el índice i.La notación &quot;una familia en X&quot; se utiliza para dicha familia.</target>
        </trans-unit>
        <trans-unit id="0460fccf75563cd103af603f5ff0df7bee5d29db" translate="yes" xml:space="preserve">
          <source>If x is a family of subsets of X, the union of the range of x is called the &lt;strong&gt;union of the family&lt;/strong&gt; x.</source>
          <target state="translated">Si x es una familia de subconjuntos de X, la uni&amp;oacute;n del rango de x se llama &lt;strong&gt;uni&amp;oacute;n de la familia&lt;/strong&gt; x.</target>
        </trans-unit>
        <trans-unit id="7f8b7662a485e830efd5dc24b42b4f66a23c755f" translate="yes" xml:space="preserve">
          <source>If x is non-empty (the index set is non-empty), the &lt;strong&gt;intersection of the family&lt;/strong&gt; x is the intersection of the range of x.</source>
          <target state="translated">Si x no est&amp;aacute; vac&amp;iacute;o (el conjunto de &amp;iacute;ndices no est&amp;aacute; vac&amp;iacute;o), la &lt;strong&gt;intersecci&amp;oacute;n de la familia&lt;/strong&gt; x es la intersecci&amp;oacute;n del rango de x.</target>
        </trans-unit>
        <trans-unit id="a742ef9245b7658b6ec0801964c4c0ea9a5eb508" translate="yes" xml:space="preserve">
          <source>If you &lt;strong&gt;must&lt;/strong&gt; return all data stored in the Ets table, you can use &lt;code&gt;ets:tab2list/1&lt;/code&gt;. However, usually you are only interested in a subset of the information in which case &lt;code&gt;ets:tab2list/1&lt;/code&gt; is expensive. If you only want to extract one field from each record, for example, the age of every person, then:</source>
          <target state="translated">Si &lt;strong&gt;debe&lt;/strong&gt; devolver todos los datos almacenados en la tabla de Ets, puede usar &lt;code&gt;ets:tab2list/1&lt;/code&gt; . Sin embargo, normalmente solo le interesa un subconjunto de la informaci&amp;oacute;n, en cuyo caso &lt;code&gt;ets:tab2list/1&lt;/code&gt; es caro. Si solo desea extraer un campo de cada registro, por ejemplo, la edad de cada persona, entonces:</target>
        </trans-unit>
        <trans-unit id="6695ce447118dd0e7ea4d4f74aa540c19c250112" translate="yes" xml:space="preserve">
          <source>If you are building Erlang/OTP from git you will need to run &lt;code&gt;./otp_build autoconf&lt;/code&gt; to generate the configure scripts.</source>
          <target state="translated">Si est&amp;aacute; &lt;code&gt;./otp_build autoconf&lt;/code&gt; Erlang / OTP desde git, deber&amp;aacute; ejecutar ./otp_build autoconf para generar los scripts de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="da52602929c7fc0635b8326b6c38bbbd66979f5f" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version of Erlang, you should set up PATHs etc a little differently. We have two templates to make things work in both Cygwin and MSYS but needs editing to work with MSYS2 (see the comments in the script). The following one is for 32 bits:</source>
          <target state="translated">Si estás construyendo una versión de 64 bits de Erlang,deberías configurar los PATHs etc.de forma un poco diferente.Tenemos dos plantillas para hacer que las cosas funcionen tanto en Cygwin como en MSYS pero necesita ser editada para trabajar con MSYS2 (ver los comentarios en el guión).La siguiente es para 32 bits:</target>
        </trans-unit>
        <trans-unit id="28fd7cee740e8f1e008d545c9af326623f6f2da9" translate="yes" xml:space="preserve">
          <source>If you are building a 64 bit version, you supply &lt;code&gt;otp_build&lt;/code&gt; with an architecture parameter:</source>
          <target state="translated">Si est&amp;aacute; &lt;code&gt;otp_build&lt;/code&gt; una versi&amp;oacute;n de 64 bits, proporcione a otp_build un par&amp;aacute;metro de arquitectura:</target>
        </trans-unit>
        <trans-unit id="11d01d76312a6e1beca90d30f576e8ba920e3045" translate="yes" xml:space="preserve">
          <source>If you are building in &lt;code&gt;git&lt;/code&gt; you first need to generate the &lt;code&gt;configure&lt;/code&gt; scripts:</source>
          <target state="translated">Si est&amp;aacute; &lt;code&gt;git&lt;/code&gt; en git , primero debe generar los scripts de &lt;code&gt;configure&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="08ca29e8fc627bd8865e44b098a309f0c218de8e" translate="yes" xml:space="preserve">
          <source>If you are building in Git, you want to read the &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; section of &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; before proceeding.</source>
          <target state="translated">Si est&amp;aacute; compilando en Git, desea leer la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;install#How-to-Build-and-Install-ErlangOTP&quot;&gt;Building in Git&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;install&quot;&gt;$ERL_TOP/HOWTO/INSTALL.md&lt;/a&gt;&lt;/code&gt; antes de continuar.</target>
        </trans-unit>
        <trans-unit id="059356cb46cb61018f3078a8c089ba933432567b" translate="yes" xml:space="preserve">
          <source>If you are distributing the source code for your application for other people to compile and run, you probably want to ensure that the code compiles even if EUnit is not available. Like the example in the previous section, you can put the following lines in a common header file:</source>
          <target state="translated">Si está distribuyendo el código fuente de su aplicación para que otras personas lo compilen y lo ejecuten,probablemente quiera asegurarse de que el código se compila aunque EUnit no esté disponible.Como en el ejemplo de la sección anterior,puedes poner las siguientes líneas en un archivo de cabecera común:</target>
        </trans-unit>
        <trans-unit id="3f548e035d4acfc541b42547c9972c54765ffd2c" translate="yes" xml:space="preserve">
          <source>If you are executing in a mode where time offset can change, and you want to get the actual Erlang system time when the event occurred, you can save the time offset as a third element in the tuple (the least significant element when comparing three-tuples).</source>
          <target state="translated">Si se está ejecutando en un modo en el que el desfase horario puede cambiar,y se desea obtener la hora real del sistema Erlang cuando se produjo el evento,se puede guardar el desfase horario como un tercer elemento de la tupla (el elemento menos significativo cuando se comparan tres tuplas).</target>
        </trans-unit>
        <trans-unit id="65eab1decf1d5f02b76e57b9a0f013425229d73c" translate="yes" xml:space="preserve">
          <source>If you are going to build a 64bit Windows version, you should make sure to get MinGW's 64bit gcc installed with Cygwin. It's in one of the development packages.</source>
          <target state="translated">Si vas a construir una versión de Windows de 64 bits,debes asegurarte de tener instalado el gcc de 64 bits de MinGW con Cygwin.Está en uno de los paquetes de desarrollo.</target>
        </trans-unit>
        <trans-unit id="e873962d506d0453e258cd67b870cfcf9fdf56aa" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt; erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="abcce25aa490a7895d515f9ea238920455b90682" translate="yes" xml:space="preserve">
          <source>If you are interested in Erlang system time at the time when the event occurred, you can also save the time offset before or after saving the events using &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt;. Erlang monotonic time added with the time offset corresponds to Erlang system time.</source>
          <target state="translated">Si est&amp;aacute; interesado en la hora del sistema Erlang en el momento en que ocurri&amp;oacute; el evento, tambi&amp;eacute;n puede guardar la compensaci&amp;oacute;n de tiempo antes o despu&amp;eacute;s de guardar los eventos usando &lt;code&gt;&lt;a href=&quot;erlang#time_offset-0&quot;&gt;erlang:time_offset/0&lt;/a&gt;&lt;/code&gt; . El tiempo mon&amp;oacute;tono de Erlang agregado con el desplazamiento de tiempo corresponde al tiempo del sistema de Erlang.</target>
        </trans-unit>
        <trans-unit id="2501e29b8883667aa63c6065f64ad533173ff055" translate="yes" xml:space="preserve">
          <source>If you are new to &lt;code&gt;gen_statem&lt;/code&gt; and want an overview of concepts and operation the section &lt;code&gt; gen_statem&amp;nbsp;Behaviour &lt;/code&gt; located in the User's Guide &lt;code&gt; OTP Design Principles &lt;/code&gt; is recommended to read before this reference manual, possibly after the Description section you are reading here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ec4906363d7f3a0f656197645460eb641bfd86b" translate="yes" xml:space="preserve">
          <source>If you are not familiar with Cygwin, MSYS, MSYS2 or a Unix environment, you&amp;rsquo;ll probably need to read up a bit on how that works. There are plenty of documentation about this online.</source>
          <target state="translated">Si no est&amp;aacute; familiarizado con Cygwin, MSYS, MSYS2 o un entorno Unix, probablemente necesitar&amp;aacute; leer un poco sobre c&amp;oacute;mo funciona. Hay mucha documentaci&amp;oacute;n sobre esto en l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="79e81e9c6f10164072a2c4df28a3214be53b197f" translate="yes" xml:space="preserve">
          <source>If you are not sure that OS system time is correct, set it to a time that is guaranteed to be earlier than actual POSIX time before starting the Erlang runtime system, just to be safe.</source>
          <target state="translated">Si no está seguro de que la hora del sistema operativo sea la correcta,fíjela a una hora que esté garantizada que sea anterior a la hora real de POSIX antes de iniciar el sistema de tiempo de ejecución Erlang,sólo para estar seguros.</target>
        </trans-unit>
        <trans-unit id="139e4db82ce537b7ca402bb5648cb80768493b2d" translate="yes" xml:space="preserve">
          <source>If you are only interested in the age of all persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">Si sólo te interesa la edad de todas las personas llamadas &quot;Bryan&quot;,entonces:</target>
        </trans-unit>
        <trans-unit id="a4b3fb25184745a8c5de1f41ef693f7c3d65a1fb" translate="yes" xml:space="preserve">
          <source>If you are running on a platform supporting HiPE and if you have not disabled HiPE, you can compile a module into native code like this from the Erlang shell:</source>
          <target state="translated">Si se está ejecutando en una plataforma que soporta HiPE y si no se ha desactivado HiPE,se puede compilar un módulo en código nativo como este desde el shell de Erlang:</target>
        </trans-unit>
        <trans-unit id="12bada1e7a2afb8d739c0b1c4888bc6d1de99967" translate="yes" xml:space="preserve">
          <source>If you are testing a distributed Erlang application, it is likely that code you want included in the code coverage analysis gets executed on another Erlang node than the one &lt;code&gt;Common Test&lt;/code&gt; is running on. If so, you must specify these other nodes in the cover specification file or add them dynamically to the code coverage set of nodes. For details on the latter, see module &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si est&amp;aacute; probando una aplicaci&amp;oacute;n Erlang distribuida, es probable que el c&amp;oacute;digo que desea incluir en el an&amp;aacute;lisis de cobertura de c&amp;oacute;digo se ejecute en otro nodo Erlang que no sea el que se est&amp;aacute; ejecutando &lt;code&gt;Common Test&lt;/code&gt; . Si es as&amp;iacute;, debe especificar estos otros nodos en el archivo de especificaci&amp;oacute;n de portada o agregarlos din&amp;aacute;micamente al conjunto de nodos de cobertura de c&amp;oacute;digo. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre este &amp;uacute;ltimo, consulte el m&amp;oacute;dulo &lt;code&gt;&lt;a href=&quot;ct_cover&quot;&gt;ct_cover&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c864b6e67ea1285ed3a001c19cfbf05fe7b8b75d" translate="yes" xml:space="preserve">
          <source>If you are unsure whether you have freed the terms properly, you can use the following function to see the status of the fixed term allocator:</source>
          <target state="translated">Si no está seguro de haber liberado los términos correctamente,puede utilizar la siguiente función para ver el estado del asignador de términos fijos:</target>
        </trans-unit>
        <trans-unit id="785964c082f500e973ee23af1227a47d2e13719e" translate="yes" xml:space="preserve">
          <source>If you can edit and recompile the source code, it is convenient to insert &lt;code&gt;fprof:trace(start)&lt;/code&gt; and &lt;code&gt;fprof:trace(stop)&lt;/code&gt; before and after the code to be profiled. All spawned processes are also traced. If you want some other filename than the default try &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt;.</source>
          <target state="translated">Si puede editar y recompilar el c&amp;oacute;digo fuente, es conveniente insertar &lt;code&gt;fprof:trace(start)&lt;/code&gt; y &lt;code&gt;fprof:trace(stop)&lt;/code&gt; antes y despu&amp;eacute;s del c&amp;oacute;digo a perfilar. Tambi&amp;eacute;n se rastrean todos los procesos generados. Si desea un nombre de archivo diferente al predeterminado, pruebe con &lt;code&gt;fprof:trace(start, &quot;my_fprof.trace&quot;)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b5adefb435e12cfcf7b44d388cd53353f9f445a0" translate="yes" xml:space="preserve">
          <source>If you combine catching exceptions from this function with &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; to avoid that the calling process dies when the call times out, you will have to be prepared to handle a late reply. Note that there is an odd chance to get a late reply even with &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; or &lt;code&gt;infinity&lt;/code&gt; for example in the event of network problems. So why not just let the calling process die by not catching the exception?</source>
          <target state="translated">Si combina la captura de excepciones de esta funci&amp;oacute;n con &lt;code&gt;{dirty_timeout,T}&lt;/code&gt; para evitar que el proceso de llamada muera cuando la llamada se agota, tendr&amp;aacute; que estar preparado para manejar una respuesta tard&amp;iacute;a. Tenga en cuenta que existe una extra&amp;ntilde;a posibilidad de obtener una respuesta tard&amp;iacute;a incluso con &lt;code&gt;{dirty_timeout,infinity}&lt;/code&gt; o &lt;code&gt;infinity&lt;/code&gt; , por ejemplo, en caso de problemas de red. Entonces, &amp;iquest;por qu&amp;eacute; no dejar que el proceso de llamada muera al no detectar la excepci&amp;oacute;n?</target>
        </trans-unit>
        <trans-unit id="926494dd9305a4cb191069b2570f8e16c82b75b1" translate="yes" xml:space="preserve">
          <source>If you compare with the code you will see there also that &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; was called only from &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; and itself, and called only &lt;code&gt;file:write/2&lt;/code&gt;, note the number of calls to &lt;code&gt;file:write/2&lt;/code&gt;. But here we see that &lt;code&gt;suspend&lt;/code&gt; was called a few times. This is a pseudo function that indicates that the process was suspended while executing in &lt;code&gt;foo:create_file_slow/3&lt;/code&gt;, and since there is no &lt;code&gt;receive&lt;/code&gt; or &lt;code&gt;erlang:yield/0&lt;/code&gt; in the code, it must be Erlang scheduling suspensions, or the trace file driver compensating for large file write operations (these are regarded as a schedule out followed by a schedule in to the same process).</source>
          <target state="translated">Si compara con el c&amp;oacute;digo, ver&amp;aacute; all&amp;iacute; tambi&amp;eacute;n que &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; fue llamado solo desde &lt;code&gt;foo:create_file_slow/2&lt;/code&gt; y &amp;eacute;l mismo, y llamado solo &lt;code&gt;file:write/2&lt;/code&gt; , tenga en cuenta el n&amp;uacute;mero de llamadas a &lt;code&gt;file:write/2&lt;/code&gt; . Pero aqu&amp;iacute; vemos que &lt;code&gt;suspend&lt;/code&gt; er se llam&amp;oacute; varias veces. Esta es una pseudo funci&amp;oacute;n que indica que el proceso se suspendi&amp;oacute; mientras se ejecutaba en &lt;code&gt;foo:create_file_slow/3&lt;/code&gt; , y dado que no hay ninguna &lt;code&gt;receive&lt;/code&gt; o &lt;code&gt;erlang:yield/0&lt;/code&gt; en el c&amp;oacute;digo, debe ser Erlang programando suspensiones, o el controlador del archivo de seguimiento compensando para operaciones de escritura de archivos grandes (se consideran como una programaci&amp;oacute;n de salida seguida de una programaci&amp;oacute;n en el mismo proceso).</target>
        </trans-unit>
        <trans-unit id="4da979d104276d1b284d0d0ed5628a6c4ba8264c" translate="yes" xml:space="preserve">
          <source>If you compile with the following, the result is one merged module &lt;code&gt;MyModule.erl&lt;/code&gt; with the generated code from the three ASN.1 specs:</source>
          <target state="translated">Si compila con lo siguiente, el resultado es un m&amp;oacute;dulo combinado &lt;code&gt;MyModule.erl&lt;/code&gt; con el c&amp;oacute;digo generado a partir de las tres especificaciones ASN.1:</target>
        </trans-unit>
        <trans-unit id="229f423b538bb335420959949ffa6439771ff69b" translate="yes" xml:space="preserve">
          <source>If you compose your own &lt;code&gt;cipher_suites()&lt;/code&gt; make sure they are filtered for cryptolib support &lt;code&gt;&lt;a href=&quot;#filter_cipher_suites-2&quot;&gt; ssl:filter_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; Additionaly the functions &lt;code&gt;&lt;a href=&quot;#append_cipher_suites-2&quot;&gt; ssl:append_cipher_suites/2 &lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#prepend_cipher_suites-2&quot;&gt; ssl:prepend_cipher_suites/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#suite_to_str-1&quot;&gt;ssl:suite_to_str/1&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#str_to_suite-1&quot;&gt;ssl:str_to_suite/1&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#suite_to_openssl_str-1&quot;&gt;ssl:suite_to_openssl_str/1&lt;/a&gt;&lt;/code&gt; also exist to help creating customized cipher suite lists.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2523acc9d9b699bb6e45fe3319252f79d5b73690" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip, Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34553151842c57d51c700a2176df03643a8e288f" translate="yes" xml:space="preserve">
          <source>If you decide not to run the test case after all, return &lt;code&gt;{skip,Reason}&lt;/code&gt;. &lt;code&gt;Reason&lt;/code&gt; is then printed in field &lt;code&gt;Comment&lt;/code&gt; on the HTML result page.</source>
          <target state="translated">Si, despu&amp;eacute;s de todo, decide no ejecutar el caso de prueba, devuelva &lt;code&gt;{skip,Reason}&lt;/code&gt; . &lt;code&gt;Reason&lt;/code&gt; se imprime en el campo &lt;code&gt;Comment&lt;/code&gt; de la p&amp;aacute;gina de resultados HTML.</target>
        </trans-unit>
        <trans-unit id="cc41ca02f8abc69bcba03c2039a4711eec766fcf" translate="yes" xml:space="preserve">
          <source>If you desire to also use some other general cover configuration together with this option you should insert the AppName in between the option and its value creating a three tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32b5510ec0b67d605ceab6963978d04cd1ab40d6" translate="yes" xml:space="preserve">
          <source>If you develop linked-in drivers (shared library) you need to link using &lt;code&gt;gcc&lt;/code&gt; and the flags &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt;. You also include &lt;code&gt;-fno-common&lt;/code&gt; in &lt;code&gt;CFLAGS&lt;/code&gt; when compiling. Use &lt;code&gt;.so&lt;/code&gt; as the library suffix.</source>
          <target state="translated">Si desarrolla controladores vinculados (biblioteca compartida), debe vincular usando &lt;code&gt;gcc&lt;/code&gt; y las banderas &lt;code&gt;-bundle -flat_namespace -undefined suppress&lt;/code&gt; . Tambi&amp;eacute;n incluye &lt;code&gt;-fno-common&lt;/code&gt; en &lt;code&gt;CFLAGS&lt;/code&gt; al compilar. Utilice &lt;code&gt;.so&lt;/code&gt; como sufijo de la biblioteca.</target>
        </trans-unit>
        <trans-unit id="9af22866bc3303d3e5e15bb7da268298a32e5b69" translate="yes" xml:space="preserve">
          <source>If you do not have a complete binary of the file content, you can instead chunk through the file and check part by part. The return-tuple &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; from function &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; comes in handy. The incomplete rest from one chunk of data read from the file is prepended to the next chunk and we therefore avoid the problem of character boundaries when reading chunks of bytes in UTF-8 encoding:</source>
          <target state="translated">Si no tiene un binario completo del contenido del archivo, puede fragmentar el archivo y verificar parte por parte. La tupla de retorno &lt;code&gt;{incomplete,Decoded,Rest}&lt;/code&gt; de la funci&amp;oacute;n &lt;code&gt;unicode:characters_to_binary/1,2,3&lt;/code&gt; es &amp;uacute;til. El resto incompleto de un fragmento de datos le&amp;iacute;dos del archivo se antepone al siguiente fragmento y, por lo tanto, evitamos el problema de los l&amp;iacute;mites de caracteres al leer fragmentos de bytes en codificaci&amp;oacute;n UTF-8:</target>
        </trans-unit>
        <trans-unit id="d69c0d8ff5a49420e5ccb90500698b1a5b852393" translate="yes" xml:space="preserve">
          <source>If you do not need the statistical quality of this function, there are faster algorithms in the &lt;code&gt;rand&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec8d18a133f467591527f3dafe062626f3a3e3a8" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt; enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fdd3948b5b8d018a253264434e3fdb3b1f2c9e" translate="yes" xml:space="preserve">
          <source>If you do not need to reallocate or keep the data alive across NIF calls, consider using &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; instead as it will allocate small binaries on the process heap when possible.</source>
          <target state="translated">Si no necesita reasignar o mantener vivos los datos en las llamadas NIF, considere usar &lt;code&gt;&lt;a href=&quot;#enif_make_new_binary&quot;&gt;enif_make_new_binary&lt;/a&gt;&lt;/code&gt; en su lugar, ya que asignar&amp;aacute; peque&amp;ntilde;os binarios en el mont&amp;oacute;n de procesos cuando sea posible.</target>
        </trans-unit>
        <trans-unit id="0d84e01d642f906e2813071c9f195dfd3ff33506" translate="yes" xml:space="preserve">
          <source>If you do ordinary &lt;code&gt;send&lt;/code&gt; or &lt;code&gt;receive&lt;/code&gt; trace on the system, you will only see ordinary message passing, not the other information transfers listed above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5226c0c04d7fd8e63c97c31f497edc30ae0498fc" translate="yes" xml:space="preserve">
          <source>If you don't use X-windows, you might want to setup the Windows console window by selecting properties in the console system menu (upper left corner of the window, the Cygwin icon in the title bar). Especially setting a larger screen buffer size (lines) is useful as it gets you a scrollbar so you can see whatever error messages that might appear.</source>
          <target state="translated">Si no utiliza X-windows,es posible que desee configurar la ventana de la consola de Windows seleccionando las propiedades en el menú del sistema de la consola (esquina superior izquierda de la ventana,el icono de Cygwin en la barra de título).Especialmente la configuración de un tamaño de búfer de pantalla más grande (líneas)es útil ya que le proporciona una barra de desplazamiento para que pueda ver cualquier mensaje de error que pueda aparecer.</target>
        </trans-unit>
        <trans-unit id="c1c77e78076b1c45254b83e1685877227a58e370" translate="yes" xml:space="preserve">
          <source>If you explicitly want to set the program name in the argument vector, option &lt;code&gt;arg0&lt;/code&gt; can be used.</source>
          <target state="translated">Si desea establecer expl&amp;iacute;citamente el nombre del programa en el vector de argumentos, se puede utilizar la opci&amp;oacute;n &lt;code&gt;arg0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f75fbec32c4686a4e8aec99dc351f8983616950b" translate="yes" xml:space="preserve">
          <source>If you fail to clear thread-specific data in an emulator thread before letting it out of your control, you might never be able to clear this data with later unexpected errors in other parts of the system as a result.</source>
          <target state="translated">Si no consigues borrar los datos específicos de un hilo del emulador antes de dejarlo fuera de tu control,puede que nunca seas capaz de borrar estos datos con posteriores errores inesperados en otras partes del sistema como resultado.</target>
        </trans-unit>
        <trans-unit id="09268e829b124cfcf4bd5de6e9875906ac8513d6" translate="yes" xml:space="preserve">
          <source>If you feel comfortable with the environment and build system, and have all the necessary tools, you have a great opportunity to make the Erlang/OTP distribution for Windows better. Please submit any suggestions to our &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; and patches to our &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; to let them find their way into the next version of Erlang. If making changes to the build system (like makefiles etc) please bear in mind that the same makefiles are used on Unix/VxWorks, so that your changes don't break other platforms. That of course goes for C-code too; system specific code resides in the &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; and &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; directories mostly. The &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; directory is for common code.</source>
          <target state="translated">Si se siente c&amp;oacute;modo con el entorno y el sistema de compilaci&amp;oacute;n, y tiene todas las herramientas necesarias, tiene una gran oportunidad para mejorar la distribuci&amp;oacute;n Erlang / OTP para Windows. Env&amp;iacute;e cualquier sugerencia a nuestra &lt;code&gt;&lt;a href=&quot;http://bugs.erlang.org&quot;&gt;JIRA&lt;/a&gt;&lt;/code&gt; y parches a nuestro &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp&quot;&gt;git project&lt;/a&gt;&lt;/code&gt; para que puedan encontrar su camino hacia la pr&amp;oacute;xima versi&amp;oacute;n de Erlang. Si realiza cambios en el sistema de compilaci&amp;oacute;n (como archivos MAKE, etc.), tenga en cuenta que se utilizan los mismos archivos MAKE en Unix / VxWorks, para que sus cambios no rompan otras plataformas. Eso, por supuesto, tambi&amp;eacute;n se aplica al c&amp;oacute;digo C; El c&amp;oacute;digo espec&amp;iacute;fico del sistema reside principalmente en los &lt;code&gt;$ERL_TOP/erts/emulator/sys/win32&lt;/code&gt; y &lt;code&gt;$ERL_TOP/erts/etc/win32&lt;/code&gt; . El &lt;code&gt;$ERL_TOP/erts/emulator/beam&lt;/code&gt; es para c&amp;oacute;digo com&amp;uacute;n.</target>
        </trans-unit>
        <trans-unit id="c1e46734643c479e7f6063eb73e949cb06d69d85" translate="yes" xml:space="preserve">
          <source>If you find that some common Logger usage is missing from this guide, please open a pull request on github with the suggested addition</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7e44c265926484064ef3996081db76eb5b3893" translate="yes" xml:space="preserve">
          <source>If you frequently do a lookup on a field that is not the key of the table, you lose performance using &quot;mnesia:select/match_object&quot; as this function traverses the whole table. You can create a secondary index instead and use &quot;mnesia:index_read&quot; to get faster access, however this requires more memory.</source>
          <target state="translated">Si se hace una búsqueda frecuente en un campo que no es la clave de la tabla,se pierde rendimiento usando &quot;mnesia:select/match_object&quot; ya que esta función atraviesa toda la tabla.Puedes crear un índice secundario en su lugar y usar &quot;mnesia:index_read&quot; para obtener un acceso más rápido,sin embargo esto requiere más memoria.</target>
        </trans-unit>
        <trans-unit id="d250cbc8ce8f103748e70e8012ae4812e69e6b6e" translate="yes" xml:space="preserve">
          <source>If you got a public key &lt;code&gt;PubKey&lt;/code&gt; and a related list of attributes &lt;code&gt;Attributes&lt;/code&gt; as returned by &lt;code&gt;ssh_decode/2&lt;/code&gt;, you can create a new SSH file, for example:</source>
          <target state="translated">Si tiene una clave p&amp;uacute;blica &lt;code&gt;PubKey&lt;/code&gt; y una lista relacionada de atributos &lt;code&gt;Attributes&lt;/code&gt; devueltos por &lt;code&gt;ssh_decode/2&lt;/code&gt; , puede crear un nuevo archivo SSH, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d64558ffe085d81fb4c2a7370d51643970e9b47a" translate="yes" xml:space="preserve">
          <source>If you hack the emulator, you can build the emulator executable by standing in &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; and do a simple</source>
          <target state="translated">Si piratea el emulador, puedes compilar el ejecutable del emulador coloc&amp;aacute;ndote en &lt;code&gt;$ERL_TOP/erts/emulator&lt;/code&gt; y hacer un simple</target>
        </trans-unit>
        <trans-unit id="57dee92dc02000c0c82e5fb9e2da62997a25dbd7" translate="yes" xml:space="preserve">
          <source>If you have Xcode 4.3, or later, you will also need to download &quot;Command Line Tools&quot; via the Downloads preference pane in Xcode.</source>
          <target state="translated">Si tienes Xcode 4.3,o posterior,también necesitarás descargar &quot;Herramientas de la línea de comandos&quot; a través del panel de preferencias de descargas en Xcode.</target>
        </trans-unit>
        <trans-unit id="709a85ba273f4493deb19337d8dab86c17b51b44" translate="yes" xml:space="preserve">
          <source>If you have a list of lists &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt;, then you can sum the lengths of all the strings in &lt;code&gt;L&lt;/code&gt; as follows:</source>
          <target state="translated">Si tiene una lista de listas &lt;code&gt;L = [&quot;I&quot;,&quot;like&quot;,&quot;Erlang&quot;]&lt;/code&gt; , entonces puede sumar las longitudes de todas las cadenas en &lt;code&gt;L&lt;/code&gt; de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="06562602ec1a77035c75bd6f06f61c39f1543c77" translate="yes" xml:space="preserve">
          <source>If you have added the declaration &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; to your module, as described above, you only need to compile the module, and run the automatically exported function &lt;code&gt;test()&lt;/code&gt;. For example, if your module was named &lt;code&gt;m&lt;/code&gt;, then calling &lt;code&gt;m:test()&lt;/code&gt; will run EUnit on all the tests defined in the module. You do not need to write &lt;code&gt;-export&lt;/code&gt; declarations for the test functions. This is all done by magic.</source>
          <target state="translated">Si ha agregado la declaraci&amp;oacute;n &lt;code&gt;-include_lib(&quot;eunit/include/eunit.hrl&quot;)&lt;/code&gt; a su m&amp;oacute;dulo, como se describe anteriormente, solo necesita compilar el m&amp;oacute;dulo y ejecutar la funci&amp;oacute;n exportada autom&amp;aacute;ticamente &lt;code&gt;test()&lt;/code&gt; . Por ejemplo, si su m&amp;oacute;dulo se llam&amp;oacute; &lt;code&gt;m&lt;/code&gt; , entonces llamar a &lt;code&gt;m:test()&lt;/code&gt; ejecutar&amp;aacute; EUnit en todas las pruebas definidas en el m&amp;oacute;dulo. No es necesario escribir declaraciones de &lt;code&gt;-export&lt;/code&gt; para las funciones de prueba. Todo esto se hace por arte de magia.</target>
        </trans-unit>
        <trans-unit id="144f513a5aa39876b81ef2c80a71c2be4b26f4ef" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;install&lt;/code&gt; target, install the documentation using the &lt;code&gt;install-docs&lt;/code&gt; target. Install locations determined by &lt;code&gt;configure&lt;/code&gt; will be used. &lt;code&gt;$DESTDIR&lt;/code&gt; can be used the same way as when doing &lt;code&gt;make install&lt;/code&gt;.</source>
          <target state="translated">Si ha instalado Erlang / OTP utilizando la &lt;code&gt;install&lt;/code&gt; de destino, instalar la documentaci&amp;oacute;n mediante la &lt;code&gt;install-docs&lt;/code&gt; objetivo. Se utilizar&amp;aacute;n las ubicaciones de instalaci&amp;oacute;n determinadas por &lt;code&gt;configure&lt;/code&gt; . &lt;code&gt;$DESTDIR&lt;/code&gt; se puede usar de la misma manera que al hacer &lt;code&gt;make install&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f15d88801e622a2cdd2d2c7fe2a4a670f216ed9a" translate="yes" xml:space="preserve">
          <source>If you have installed Erlang/OTP using the &lt;code&gt;release&lt;/code&gt; target, install the documentation using the &lt;code&gt;release_docs&lt;/code&gt; target. You typically want to use the same &lt;code&gt;RELEASE_ROOT&lt;/code&gt; as when invoking &lt;code&gt;make release&lt;/code&gt;.</source>
          <target state="translated">Si ha instalado Erlang / OTP con el destino de la &lt;code&gt;release&lt;/code&gt; , instale la documentaci&amp;oacute;n con el destino &lt;code&gt;release_docs&lt;/code&gt; . Por lo general, desea usar el mismo &lt;code&gt;RELEASE_ROOT&lt;/code&gt; que al invocar &lt;code&gt;make release&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56c20a2d676e8cfb31affcccb02e9255a03aa95c" translate="yes" xml:space="preserve">
          <source>If you have installed documentation in the OTP installation, also build the documentation:</source>
          <target state="translated">Si ha instalado la documentación en la instalación de la OTP,también construya la documentación:</target>
        </trans-unit>
        <trans-unit id="e2d1684e846a6a2121920a90b95e7857c8b4feb5" translate="yes" xml:space="preserve">
          <source>If you have just built Erlang/OTP in the current source tree, you have already ran &lt;code&gt;configure&lt;/code&gt; and do not need to do this again; otherwise, run &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">Si acaba de construir Erlang / OTP en el &amp;aacute;rbol de fuentes actual, ya ha ejecutado &lt;code&gt;configure&lt;/code&gt; y no es necesario que vuelva a hacerlo; de lo contrario, ejecute &lt;code&gt;configure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="636ce5c9d1bb03f9748b5bbe5ec2f545e4d839b3" translate="yes" xml:space="preserve">
          <source>If you have many servers in one node and they have some state(s) in their lifetime in which the servers can be expected to idle for a while, and the amount of heap memory all these servers need is a problem, then the memory footprint of a server can be mimimized by hibernating it through &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt;.</source>
          <target state="translated">Si tiene muchos servidores en un nodo y tienen algunos estados durante su vida &amp;uacute;til en los que se puede esperar que los servidores est&amp;eacute;n inactivos por un tiempo, y la cantidad de memoria de pila que todos estos servidores necesitan es un problema, entonces la huella de memoria de un servidor se puede &lt;code&gt;proc_lib:hibernate/3&lt;/code&gt; hibernando a trav&amp;eacute;s de proc_lib: hibernate / 3 .</target>
        </trans-unit>
        <trans-unit id="9cf69c3d3514b68c365fa229d8d36e057061c7ae" translate="yes" xml:space="preserve">
          <source>If you have one function that does the task that you want to profile, and the function returns when the profiling should stop, it is convenient to use &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; and related for the tracing step.</source>
          <target state="translated">Si tiene una funci&amp;oacute;n que realiza la tarea que desea perfilar, y la funci&amp;oacute;n regresa cuando la creaci&amp;oacute;n de perfiles deber&amp;iacute;a detenerse, es conveniente usar &lt;code&gt;fprof:apply(Module, Function, Args)&lt;/code&gt; y relacionado para el paso de seguimiento.</target>
        </trans-unit>
        <trans-unit id="4add882c433457afa2edf542bb650cc29a895ccb" translate="yes" xml:space="preserve">
          <source>If you have public-key data and want to create a PEM file this can be done by calling functions &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; and &lt;code&gt;pem_encode/1&lt;/code&gt; and saving the result to a file. For example, assume that you have &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt;. Then you can create a PEM-&quot;RSA PUBLIC KEY&quot; file (ASN.1 type &lt;code&gt;'RSAPublicKey'&lt;/code&gt;) or a PEM-&quot;PUBLIC KEY&quot; file (&lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1 type).</source>
          <target state="translated">Si tiene datos de clave p&amp;uacute;blica y desea crear un archivo PEM, puede hacerlo llamando a las funciones &lt;code&gt;public_key:pem_entry_encode/2&lt;/code&gt; y &lt;code&gt;pem_encode/1&lt;/code&gt; y guardando el resultado en un archivo. Por ejemplo, suponga que tiene &lt;code&gt;PubKey = 'RSAPublicKey'{}&lt;/code&gt; . Luego puede crear un archivo PEM- &quot;RSA PUBLIC KEY&quot; (tipo ASN.1 &lt;code&gt;'RSAPublicKey'&lt;/code&gt; ) o un archivo PEM- &quot;PUBLIC KEY&quot; (tipo &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; ASN.1).</target>
        </trans-unit>
        <trans-unit id="bff364d7b744c7c80f16da3e2585cd7454157cd3" translate="yes" xml:space="preserve">
          <source>If you have system configuration data that is neither file-location-dependent nor site-dependent, it can be convenient to create &lt;code&gt;sys.config&lt;/code&gt; early, so it becomes part of the target system tar file created by &lt;code&gt;target_system:create/1&lt;/code&gt;. In fact, if you in the current directory create not only the file &lt;code&gt;mysystem.rel&lt;/code&gt;, but also file &lt;code&gt;sys.config&lt;/code&gt;, the latter file is tacitly put in the appropriate directory.</source>
          <target state="translated">Si tiene datos de configuraci&amp;oacute;n del sistema que no dependen de la ubicaci&amp;oacute;n del archivo ni del sitio, puede ser conveniente crear &lt;code&gt;sys.config&lt;/code&gt; antes, para que se convierta en parte del archivo tar del sistema de destino creado por &lt;code&gt;target_system:create/1&lt;/code&gt; . De hecho, si en el directorio actual crea no solo el archivo &lt;code&gt;mysystem.rel&lt;/code&gt; , sino tambi&amp;eacute;n el archivo &lt;code&gt;sys.config&lt;/code&gt; , este &amp;uacute;ltimo archivo se coloca t&amp;aacute;citamente en el directorio apropiado.</target>
        </trans-unit>
        <trans-unit id="dd12871aeecfcf251ad76c0f1867361b2f02e152" translate="yes" xml:space="preserve">
          <source>If you have your cross compilation configuration in a file, pass it using the &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; command line argument. If not, pass &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt;, and the configuration variables using a &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; syntax on the command line (same as in (3)). Note that &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; have to be passed one way or the other; either by using &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; and &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; in the configuration file, or by using the &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt;, and &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; command line arguments.</source>
          <target state="translated">Si tiene su configuraci&amp;oacute;n de compilaci&amp;oacute;n cruzada en un archivo, p&amp;aacute;selo usando el argumento de l&amp;iacute;nea de comando &lt;code&gt;--xcomp-conf=&amp;lt;FILE&amp;gt;&lt;/code&gt; . De lo contrario, pase &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; , &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; y las variables de configuraci&amp;oacute;n utilizando una sintaxis &lt;code&gt;&amp;lt;VARIABLE&amp;gt;=&amp;lt;VALUE&amp;gt;&lt;/code&gt; en la l&amp;iacute;nea de comando (igual que en (3)). Tenga en cuenta que &lt;code&gt;&amp;lt;HOST&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;lt;BUILD&amp;gt;&lt;/code&gt; deben pasarse de una forma u otra; ya sea usando &lt;code&gt;erl_xcomp_host=&amp;lt;HOST&amp;gt;&lt;/code&gt; y &lt;code&gt;erl_xcomp_build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; en el archivo de configuraci&amp;oacute;n, o usando los argumentos de l&amp;iacute;nea de comando &lt;code&gt;--host=&amp;lt;HOST&amp;gt;&lt;/code&gt; y &lt;code&gt;--build=&amp;lt;BUILD&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="496f196f55a6fe378376abb5b448050f783c1628" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another &lt;strong&gt;state callback&lt;/strong&gt; of yours, you have not done a &lt;strong&gt;state change&lt;/strong&gt; and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a130450837fa7de4006e06dfdf6e7651f3519c93" translate="yes" xml:space="preserve">
          <source>If you in &lt;code&gt;gen_statem&lt;/code&gt;, for example, postpone an event in one state and then call another state callback of yours, you have not changed states and hence the postponed event is not retried, which is logical but can be confusing.</source>
          <target state="translated">Si en &lt;code&gt;gen_statem&lt;/code&gt; , por ejemplo, pospone un evento en un estado y luego llama a otro estado de devoluci&amp;oacute;n de llamada, no ha cambiado de estado y, por lo tanto, el evento pospuesto no se vuelve a intentar, lo cual es l&amp;oacute;gico pero puede resultar confuso.</target>
        </trans-unit>
        <trans-unit id="0b9dac884f6e658e0d27a929573db5f362853b18" translate="yes" xml:space="preserve">
          <source>If you instead receives the XML doc as a string you can parse it by &lt;code&gt;xmerl_scan:string/1&lt;/code&gt;. Both file/2 and string/2 exists where the second argument is a list of options to the parser, see the &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si, en cambio, recibe el documento XML como una cadena, puede analizarlo mediante &lt;code&gt;xmerl_scan:string/1&lt;/code&gt; . Tanto el archivo / 2 como la cadena / 2 existen donde el segundo argumento es una lista de opciones para el analizador, consulte el &lt;code&gt;&lt;a href=&quot;xmerl_scan&quot;&gt;reference manual&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3677b7b2be331958bb1cd558066c15e2ccbebc50" translate="yes" xml:space="preserve">
          <source>If you know that the binaries you return are always small, you are advised to use driver API calls that do not require a pre-allocated binary, for example, &lt;code&gt;driver_output()&lt;/code&gt; or &lt;code&gt;erl_drv_output_term()&lt;/code&gt;, using the &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; format, to allow the runtime to construct a heap binary.</source>
          <target state="translated">Si sabe que los binarios que devuelve son siempre peque&amp;ntilde;os, se recomienda utilizar llamadas a la API del controlador que no requieren un binario preasignado, por ejemplo, &lt;code&gt;driver_output()&lt;/code&gt; o &lt;code&gt;erl_drv_output_term()&lt;/code&gt; , utilizando el formato &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; , para permitir el tiempo de ejecuci&amp;oacute;n. para construir un binario de mont&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ec9a6635ce4a0b540125a17cac3147d60753ebe4" translate="yes" xml:space="preserve">
          <source>If you know the location of the &lt;code&gt;escript&lt;/code&gt; executable, the first line can directly give the path to &lt;code&gt;escript&lt;/code&gt;, for example:</source>
          <target state="translated">Si conoce la ubicaci&amp;oacute;n del ejecutable &lt;code&gt;escript&lt;/code&gt; , la primera l&amp;iacute;nea puede proporcionar directamente la ruta a &lt;code&gt;escript&lt;/code&gt; , por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b659d556ba001a4273a3f6f58c5f3fae0a2ecf0c" translate="yes" xml:space="preserve">
          <source>If you leave a mutex locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">Si deja un mutex bloqueado en un subproceso del emulador cuando deja el subproceso fuera de su control, es &lt;strong&gt;muy probable que&lt;/strong&gt; bloquee todo el emulador.</target>
        </trans-unit>
        <trans-unit id="1b0a6367d887c72eef350e1e461ed2440088fd89" translate="yes" xml:space="preserve">
          <source>If you leave an rwlock locked in an emulator thread when you let the thread out of your control, you will &lt;strong&gt;very likely&lt;/strong&gt; deadlock the whole emulator.</source>
          <target state="translated">Si deja un rwlock bloqueado en un hilo del emulador cuando deja el hilo fuera de su control, es &lt;strong&gt;muy probable que&lt;/strong&gt; bloquee todo el emulador.</target>
        </trans-unit>
        <trans-unit id="2051d057687b13e60280ea15afa70933db6bc2e6" translate="yes" xml:space="preserve">
          <source>If you must remain compatible with the USTAR tar format, you must ensure file paths being stored are less than 255 bytes in total, with a maximum filename component length of 100 bytes. USTAR uses a header field (prefix) in addition to the name field, and splits file paths longer than 100 bytes into two parts. This split is done on a directory boundary, and is done in such a way to make the best use of the space available in those two fields, but in practice this will often mean that you have less than 255 bytes for a path. &lt;code&gt;erl_tar&lt;/code&gt; will automatically upgrade the format to PAX to handle longer filenames, so this is only an issue if you need to extract the archive with an older implementation of &lt;code&gt;erl_tar&lt;/code&gt; or &lt;code&gt;tar&lt;/code&gt; which does not support PAX. In this case, the PAX headers will be extracted as regular files, and you will need to apply them manually.</source>
          <target state="translated">Si debe seguir siendo compatible con el formato tar USTAR, debe asegurarse de que las rutas de archivo que se almacenan tengan menos de 255 bytes en total, con una longitud m&amp;aacute;xima del componente de nombre de archivo de 100 bytes. USTAR utiliza un campo de encabezado (prefijo) adem&amp;aacute;s del campo de nombre y divide las rutas de archivo de m&amp;aacute;s de 100 bytes en dos partes. Esta divisi&amp;oacute;n se realiza en el l&amp;iacute;mite de un directorio y se realiza de tal manera que se hace el mejor uso del espacio disponible en esos dos campos, pero en la pr&amp;aacute;ctica esto a menudo significar&amp;aacute; que tiene menos de 255 bytes para una ruta. &lt;code&gt;erl_tar&lt;/code&gt; actualizar&amp;aacute; autom&amp;aacute;ticamente el formato a PAX para manejar nombres de archivo m&amp;aacute;s largos, por lo que esto es solo un problema si necesita extraer el archivo con una implementaci&amp;oacute;n anterior de &lt;code&gt;erl_tar&lt;/code&gt; o &lt;code&gt;tar&lt;/code&gt; que no es compatible con PAX. En este caso, los encabezados PAX se extraer&amp;aacute;n como archivos normales y deber&amp;aacute; aplicarlos manualmente.</target>
        </trans-unit>
        <trans-unit id="25dcb500f427185c223988b86fbacdec9413c19c" translate="yes" xml:space="preserve">
          <source>If you need all information stored in the Ets table about persons named &quot;Bryan&quot;, then:</source>
          <target state="translated">Si necesitas toda la información almacenada en la tabla Ets sobre las personas llamadas &quot;Bryan&quot;,entonces:</target>
        </trans-unit>
        <trans-unit id="f37451567abb8a5fc173c77a71ec77e3d5bec387" translate="yes" xml:space="preserve">
          <source>If you need cryptographically strong random numbers use &lt;code&gt;&lt;a href=&quot;#rand_seed_alg_s-1&quot;&gt;rand_seed_alg_s/1&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;Alg =:= crypto&lt;/code&gt; or &lt;code&gt;Alg =:= crypto_cache&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0103403298226ace2d2d7dda7dc0c9b1cec0d2bd" translate="yes" xml:space="preserve">
          <source>If you need to access a relational database such as &lt;code&gt;sqlserver&lt;/code&gt;, &lt;code&gt;mysql&lt;/code&gt;, &lt;code&gt;postgres&lt;/code&gt;, &lt;code&gt;oracle&lt;/code&gt;, &lt;code&gt;cybase&lt;/code&gt; etc. from your erlang application using the Erlang ODBC interface is a good way to go about it.</source>
          <target state="translated">Si necesita acceder a una base de datos relacional como &lt;code&gt;sqlserver&lt;/code&gt; , &lt;code&gt;mysql&lt;/code&gt; , &lt;code&gt;postgres&lt;/code&gt; , &lt;code&gt;oracle&lt;/code&gt; , &lt;code&gt;cybase&lt;/code&gt; , etc.desde su aplicaci&amp;oacute;n erlang, usar la interfaz Erlang ODBC es una buena manera de hacerlo.</target>
        </trans-unit>
        <trans-unit id="062952594b89959967de93ea3f7d77ceb7f51d4f" translate="yes" xml:space="preserve">
          <source>If you need to be able to repeat the sequence use this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9153977b046897dff8af7e0a644f81df1265049" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that a time-out message cannot arrive after this, unless you have postponed it before (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may have arrived just before you cancelling it, so you may have to read out such a message from the process mailbox depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="translated">Si necesita cancelar un temporizador debido a alg&amp;uacute;n otro evento, puede usar &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; . Tenga en cuenta que un mensaje de tiempo de espera no puede llegar despu&amp;eacute;s de esto, a menos que lo haya pospuesto antes (consulte la siguiente secci&amp;oacute;n), as&amp;iacute; que aseg&amp;uacute;rese de no posponer accidentalmente dichos mensajes. Tambi&amp;eacute;n tenga en cuenta que es posible que haya llegado un mensaje de tiempo de espera justo antes de cancelarlo, por lo que es posible que deba leer dicho mensaje en el buz&amp;oacute;n de correo de proceso, seg&amp;uacute;n el valor de retorno de &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c795f2c3cb53282059f2c8f8a7e14a7e129d266c" translate="yes" xml:space="preserve">
          <source>If you need to cancel a timer because of some other event, you can use &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;. Note that no time-out message will arrive after this (because the timer has been explicitly canceled), unless you have already postponed one earlier (see the next section), so ensure that you do not accidentally postpone such messages. Also note that a time-out message may arrive during a &lt;strong&gt;state callback&lt;/strong&gt; that is cancelling the timer, so you may have to read out such a message from the process mailbox, depending on the return value from &lt;code&gt;erlang:cancel_timer(Tref)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f62eb303efefa39c68fc73abc117f5184daeab26" translate="yes" xml:space="preserve">
          <source>If you need to define a new function that does garbage collection, you should give it the prefix &lt;code&gt;erts_gc_&lt;/code&gt;. If that is not possible you should update the regular expression so that it will match your new function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05af26e95eb9bb5371b21575710d131d97fecf50" translate="yes" xml:space="preserve">
          <source>If you need to perform configuration operations to run your test, you can implement configuration functions in your suite. The result from a configuration function is configuration data, or &lt;code&gt;Config&lt;/code&gt;. This is a list of key-value tuples that get passed from the configuration function to the test cases (possibly through configuration functions on &quot;lower level&quot;). The data flow looks as follows:</source>
          <target state="translated">Si necesita realizar operaciones de configuraci&amp;oacute;n para ejecutar su prueba, puede implementar funciones de configuraci&amp;oacute;n en su suite. El resultado de una funci&amp;oacute;n de configuraci&amp;oacute;n son los datos de configuraci&amp;oacute;n o &lt;code&gt;Config&lt;/code&gt; . Esta es una lista de tuplas clave-valor que se pasan de la funci&amp;oacute;n de configuraci&amp;oacute;n a los casos de prueba (posiblemente a trav&amp;eacute;s de funciones de configuraci&amp;oacute;n en el &quot;nivel inferior&quot;). El flujo de datos tiene el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="1580293999144403cc43337470ad032b5154d650" translate="yes" xml:space="preserve">
          <source>If you need to use Erlang code that is not &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt;, and you need to start the Erlang runtime system before OS system time has been corrected, you may want to use the single time warp mode.</source>
          <target state="translated">Si necesita usar c&amp;oacute;digo Erlang que no sea &lt;code&gt;&lt;a href=&quot;#Time_Warp_Safe_Code&quot;&gt;time warp safe&lt;/a&gt;&lt;/code&gt; , y necesita iniciar el sistema de tiempo de ejecuci&amp;oacute;n de Erlang antes de que se corrija la hora del sistema operativo, es posible que desee usar el modo de time warp &amp;uacute;nico.</target>
        </trans-unit>
        <trans-unit id="0e3af53f2c07526824c69b1abdb7517239318228" translate="yes" xml:space="preserve">
          <source>If you need to use thread-specific data in an emulator thread, only have the thread-specific data set while the thread is under your control, and clear the thread-specific data before you let the thread out of your control.</source>
          <target state="translated">Si necesita utilizar datos específicos de un hilo en un hilo de emulador,sólo disponga del conjunto de datos específicos del hilo mientras éste esté bajo su control,y borre los datos específicos del hilo antes de dejar el hilo fuera de su control.</target>
        </trans-unit>
        <trans-unit id="4f32b6b35644f5b16edce6c4d78753a25d38ebfb" translate="yes" xml:space="preserve">
          <source>If you need to verify the bootstrap beam files match the provided source files, use &lt;code&gt;./otp_build update_primary&lt;/code&gt; to create a new commit that contains differences, if any exist.</source>
          <target state="translated">Si necesita verificar que los archivos de haz de arranque coincidan con los archivos de origen proporcionados, use &lt;code&gt;./otp_build update_primary&lt;/code&gt; para crear una nueva confirmaci&amp;oacute;n que contenga diferencias, si existen.</target>
        </trans-unit>
        <trans-unit id="a564a81cdbcd1f7df3fcca09ff995949d4ddcb79" translate="yes" xml:space="preserve">
          <source>If you or your system has special requirements please read the &lt;code&gt;Makefile&lt;/code&gt; for additional configuration information.</source>
          <target state="translated">Si usted o su sistema tienen requisitos especiales, lea el &lt;code&gt;Makefile&lt;/code&gt; para obtener informaci&amp;oacute;n de configuraci&amp;oacute;n adicional.</target>
        </trans-unit>
        <trans-unit id="c9741cf8a267768b2bd92351adecbc979f0aa0dd" translate="yes" xml:space="preserve">
          <source>If you plan to change code without restarting your system, you must use an external fun (&lt;code&gt;fun Module:Function/Arity&lt;/code&gt;) as function &lt;code&gt;Resolve&lt;/code&gt;. If you use a local fun, you can never replace the code for the module that the fun belongs to.</source>
          <target state="translated">Si va a cambiar el c&amp;oacute;digo sin necesidad de reiniciar el sistema, se debe utilizar un divertido externa ( &lt;code&gt;fun Module:Function/Arity&lt;/code&gt; ) en funci&amp;oacute;n &lt;code&gt;Resolve&lt;/code&gt; r . Si usa una diversi&amp;oacute;n local, nunca podr&amp;aacute; reemplazar el c&amp;oacute;digo del m&amp;oacute;dulo al que pertenece la diversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3d19108a84a5eb3bb48cef4ccb2f6536e5feabf9" translate="yes" xml:space="preserve">
          <source>If you read back the option value using &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; and get no value, the option does not exist in the host operating system. The behavior of both an IPv6 and an IPv4 socket listening on the same port, and for an IPv6 socket getting IPv4 traffic is then no longer predictable.</source>
          <target state="translated">Si vuelve a leer el valor de la opci&amp;oacute;n usando &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; y no obtiene ning&amp;uacute;n valor, la opci&amp;oacute;n no existe en el sistema operativo del host. El comportamiento tanto de un socket IPv6 como de un socket IPv4 escuchando en el mismo puerto, y para un socket IPv6 que recibe tr&amp;aacute;fico IPv4, ya no es predecible.</target>
        </trans-unit>
        <trans-unit id="85b82b7060fb8d9f6ed2cb286e33072d08347f0f" translate="yes" xml:space="preserve">
          <source>If you really, really want to, you may call it &quot;Inga&quot;.</source>
          <target state="translated">Si realmente,realmente quieres,puedes llamarlo &quot;Inga&quot;.</target>
        </trans-unit>
        <trans-unit id="0ad8b8f8006dc094fc060a805431e5051049c527" translate="yes" xml:space="preserve">
          <source>If you set the &lt;code&gt;call&lt;/code&gt; trace flag, you also have to set a &lt;strong&gt;trace pattern&lt;/strong&gt; for the functions you want to trace:</source>
          <target state="translated">Si configura la &lt;code&gt;call&lt;/code&gt; rastreo de llamadas , tambi&amp;eacute;n debe configurar un &lt;strong&gt;patr&amp;oacute;n de rastreo&lt;/strong&gt; para las funciones que desea rastrear:</target>
        </trans-unit>
        <trans-unit id="593fb6e309e5d0f221339df106e191b090ca84ba" translate="yes" xml:space="preserve">
          <source>If you simply want to format a paragraph of plain text, you probably want to use the &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; function, as in the following example:</source>
          <target state="translated">Si simplemente desea formatear un p&amp;aacute;rrafo de texto sin formato, probablemente desee utilizar la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#text_par-2&quot;&gt;text_par/2&lt;/a&gt;&lt;/code&gt; , como en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="da6562fe0a7c0b54c043b4d0278072613df57ef3" translate="yes" xml:space="preserve">
          <source>If you start this program with &lt;code&gt;code_lock:start([17])&lt;/code&gt; you can unlock with &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt;</source>
          <target state="translated">Si inicia este programa con &lt;code&gt;code_lock:start([17])&lt;/code&gt; puede desbloquear con &lt;code&gt;code_lock:down(17), code_lock:up(17).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cace6db1c9825fe249b9c220bf578982c6ffbbda" translate="yes" xml:space="preserve">
          <source>If you successfully parse the XML file with the validation on as in: &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; you know that the XML document is valid and has the structure according to the DTD.</source>
          <target state="translated">Si analiza correctamente el archivo XML con la validaci&amp;oacute;n &lt;code&gt;xmerl_scan:file('motorcycles.xml',[{validation,true}])&lt;/code&gt; como en: xmerl_scan: file ('motorcycles.xml', [{validation, true}]) , sabe que el documento XML es v&amp;aacute;lido y tiene la estructura de acuerdo con la DTD.</target>
        </trans-unit>
        <trans-unit id="d59053b915a39ff162dae55e7504e339f09a4e42" translate="yes" xml:space="preserve">
          <source>If you try to do the same again with another city, an error is returned:</source>
          <target state="translated">Si intentas hacer lo mismo con otra ciudad,se devuelve un error:</target>
        </trans-unit>
        <trans-unit id="a798d01202205d436563f3b0bd17d64f51325641" translate="yes" xml:space="preserve">
          <source>If you try to store an object in the registry and there is an existing object with the same key, the new value replaces the old one. This is done regardless of whether the new object and the old one have the same type, so you can, for example, replace a string with an integer. If the existing value is a string or binary, it is freed before the new value is assigned.</source>
          <target state="translated">Si intentas almacenar un objeto en el registro y hay un objeto existente con la misma clave,el nuevo valor reemplaza al antiguo.Esto se hace independientemente de si el nuevo objeto y el antiguo tienen el mismo tipo,por lo que puede,por ejemplo,reemplazar una cadena con un número entero.Si el valor existente es una cadena o binario,se libera antes de que se asigne el nuevo valor.</target>
        </trans-unit>
        <trans-unit id="515a151c90cdd13d9e4906d959838a101ec214d6" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;erl_connect_init()&lt;/code&gt;, your node will have a short name, that is, it will not be fully qualified. If you need to use fully qualified (long) names, use &lt;code&gt;erl_connect_xinit()&lt;/code&gt; instead.</source>
          <target state="translated">Si usa &lt;code&gt;erl_connect_init()&lt;/code&gt; , su nodo tendr&amp;aacute; un nombre corto, es decir, no estar&amp;aacute; completamente calificado. Si necesita usar nombres completos (largos), use &lt;code&gt;erl_connect_xinit()&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="0d834de6c7b4bcac9902d0548059107a16f86a8b" translate="yes" xml:space="preserve">
          <source>If you use &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the code for each application is placed in a separate directory following a pre-defined &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si usa &lt;code&gt;systools&lt;/code&gt; , las herramientas de Erlang / OTP para empaquetar c&amp;oacute;digo (ver &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ), el c&amp;oacute;digo para cada aplicaci&amp;oacute;n se coloca en un directorio separado siguiendo una &lt;code&gt;&lt;a href=&quot;#app_dir&quot;&gt;directory structure&lt;/a&gt;&lt;/code&gt; predefinida .</target>
        </trans-unit>
        <trans-unit id="8dfdc592f173581c774f93af24400d86f856a5e1" translate="yes" xml:space="preserve">
          <source>If you use an old apace-like configuration file.</source>
          <target state="translated">Si usas un viejo archivo de configuración como el de Apache.</target>
        </trans-unit>
        <trans-unit id="16a79b696fe4d902f78f4a9ec278a5c8cacbb001" translate="yes" xml:space="preserve">
          <source>If you use multiple CTHs, the first part of the return tuple is used as input for the next CTH. So in the previous example the next CTH can get &lt;code&gt;{fail,Reason}&lt;/code&gt; as the second parameter. If you have many CTHs interacting, do not let each CTH return &lt;code&gt;fail&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt;. Instead, return that an action is to be taken through the &lt;code&gt;Config&lt;/code&gt; list and implement a CTH that, at the end, takes the correct action.</source>
          <target state="translated">Si usa m&amp;uacute;ltiples CTH, la primera parte de la tupla de retorno se usa como entrada para el siguiente CTH. Entonces, en el ejemplo anterior, el siguiente CTH puede obtener &lt;code&gt;{fail,Reason}&lt;/code&gt; como segundo par&amp;aacute;metro. Si tiene muchos CTH interactuando, no permita que cada retorno de CTH &lt;code&gt;fail&lt;/code&gt; o se &lt;code&gt;skip&lt;/code&gt; . En su lugar, devuelva que se debe realizar una acci&amp;oacute;n a trav&amp;eacute;s de la lista de &lt;code&gt;Config&lt;/code&gt; e implemente un CTH que, al final, tome la acci&amp;oacute;n correcta.</target>
        </trans-unit>
        <trans-unit id="930cef54ac87bd2c1ca6f2387bf6edcd93ce9313" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;Erl_Interface&lt;/code&gt; functions in a threaded application based on POSIX threads or Solaris threads, then &lt;code&gt;Erl_Interface&lt;/code&gt; needs access to some of the synchronization facilities in your threads package. You must specify extra compiler flags to indicate which of the packages you use. Define &lt;code&gt;_REENTRANT&lt;/code&gt; and either &lt;code&gt;STHREADS&lt;/code&gt; or &lt;code&gt;PTHREADS&lt;/code&gt;. The default is to use POSIX threads if &lt;code&gt;_REENTRANT&lt;/code&gt; is specified.</source>
          <target state="translated">Si usa las funciones &lt;code&gt;Erl_Interface&lt;/code&gt; en una aplicaci&amp;oacute;n con subprocesos basada en subprocesos POSIX o subprocesos de Solaris, entonces &lt;code&gt;Erl_Interface&lt;/code&gt; necesita acceso a algunas de las funciones de sincronizaci&amp;oacute;n en su paquete de subprocesos. Debe especificar indicadores de compilador adicionales para indicar cu&amp;aacute;l de los paquetes utiliza. Defina &lt;code&gt;_REENTRANT&lt;/code&gt; y &lt;code&gt;STHREADS&lt;/code&gt; o &lt;code&gt;PTHREADS&lt;/code&gt; . El valor predeterminado es utilizar subprocesos POSIX si se especifica &lt;code&gt;_REENTRANT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="918394c05671a0235e153985bd2840211574395e" translate="yes" xml:space="preserve">
          <source>If you use the &lt;code&gt;ct_run&lt;/code&gt; program, you can start the Erlang shell and &lt;code&gt;Common Test&lt;/code&gt; in one go by using the flag &lt;code&gt;-shell&lt;/code&gt; and, optionally, flag &lt;code&gt;-config&lt;/code&gt; and/or &lt;code&gt;-userconfig&lt;/code&gt;.</source>
          <target state="translated">Si usa el programa &lt;code&gt;ct_run&lt;/code&gt; , puede iniciar el shell Erlang y &lt;code&gt;Common Test&lt;/code&gt; de una sola vez usando el indicador &lt;code&gt;-shell&lt;/code&gt; y, opcionalmente, el indicador &lt;code&gt;-config&lt;/code&gt; y / o &lt;code&gt;-userconfig&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3feb64f146fe919b2a69ce546c85439b7b8b28d7" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2153b220590bbe864e1f5e224d987fcb64330153" translate="yes" xml:space="preserve">
          <source>If you want an Erlang node to have a remote job active from the start (rather than the default local job), start Erlang with flag &lt;code&gt;-remsh&lt;/code&gt;, for example, &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</source>
          <target state="translated">Si desea que un nodo Erlang tenga un trabajo remoto activo desde el principio (en lugar del trabajo local predeterminado), inicie Erlang con la bandera &lt;code&gt;-remsh&lt;/code&gt; , por ejemplo, &lt;code&gt;erl -sname this_node -remsh other_node@other_host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="50de302c93e8bacbc69e071b7eec983f033e6a07" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#call-4&quot;&gt;erpc:call()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e8ce10cfe9321c8cbd6786fc123b13ea0a780a" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#multicall-4&quot;&gt;erpc:multicall()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88f9444d15f637070cc1c5665eb79410298eb57c" translate="yes" xml:space="preserve">
          <source>If you want the ability to distinguish between results, you may want to consider using the &lt;code&gt;&lt;a href=&quot;erpc#send_request-4&quot;&gt;erpc:send_request()&lt;/a&gt;&lt;/code&gt; function from the &lt;code&gt;erpc&lt;/code&gt; module instead. This also gives you the ability retrieve the results in other useful ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4038140d6bff952f2f9f5f48acf2d27c3f6092b" translate="yes" xml:space="preserve">
          <source>If you want the connection to be associated with &lt;code&gt;Handle&lt;/code&gt; only (if you, for example, need to open multiple connections to a host), use &lt;code&gt;Key&lt;/code&gt;, the configuration variable name, to specify the target. Notice that a connection without an associated target name can only be closed with the &lt;code&gt;Handle&lt;/code&gt; value.</source>
          <target state="translated">Si desea que la conexi&amp;oacute;n se asocie solo con &lt;code&gt;Handle&lt;/code&gt; (si, por ejemplo, necesita abrir varias conexiones a un host), use &lt;code&gt;Key&lt;/code&gt; , el nombre de la variable de configuraci&amp;oacute;n, para especificar el destino. Tenga en cuenta que una conexi&amp;oacute;n sin un nombre de destino asociado solo se puede cerrar con el valor de &lt;code&gt;Handle&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9c1ebb966c6523b3c1b7beffcce3bfa9b40caeb1" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt; erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92c8c9a37ae2934ad0217ae03b7ce8edb49f913c" translate="yes" xml:space="preserve">
          <source>If you want the same format as returned by &lt;code&gt;erlang:now/0&lt;/code&gt;, use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si desea el mismo formato que devuelve &lt;code&gt;erlang:now/0&lt;/code&gt; , use &lt;code&gt;&lt;a href=&quot;erlang#timestamp-0&quot;&gt;erlang:timestamp/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="340edf748ea085618e9e02efc24d38acd583eead" translate="yes" xml:space="preserve">
          <source>If you want to add the information about a black Harley Davidsson 1200 cc Sportster motorcycle from 2003 that is in shape as new in the motorcycles.xml document you can put the data in a simple-form data structure like:</source>
          <target state="translated">Si quieres añadir la información sobre una motocicleta Harley Davidsson negra de 1200 cc Sportster del 2003 que está en forma como nueva en el documento motorcycles.xml puedes poner los datos en una estructura de datos de forma simple como:</target>
        </trans-unit>
        <trans-unit id="76e13e233caef4d78d7dc7bb7c518cb87cbe184c" translate="yes" xml:space="preserve">
          <source>If you want to apply patches of multiple OTP applications that resides in different OTP versions, you have to apply these patches in multiple steps. It is only possible to apply multiple OTP applications from the same OTP version at once.</source>
          <target state="translated">Si quieres aplicar parches de múltiples aplicaciones OTP que residen en diferentes versiones de OTP,tienes que aplicar estos parches en múltiples pasos.Sólo es posible aplicar varias aplicaciones OTP de la misma versión OTP a la vez.</target>
        </trans-unit>
        <trans-unit id="42438cc3a906ec708300aa20929e7d2e6e66a173" translate="yes" xml:space="preserve">
          <source>If you want to build the &lt;code&gt;wx&lt;/code&gt; application, you will need to get wxWidgets-3.0 (&lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; from &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt;) or get it from github with bug fixes:</source>
          <target state="translated">Si desea construir la aplicaci&amp;oacute;n &lt;code&gt;wx&lt;/code&gt; , deber&amp;aacute; obtener wxWidgets-3.0 ( &lt;code&gt;wxWidgets-3.0.3.tar.bz2&lt;/code&gt; de &lt;code&gt;&lt;a href=&quot;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&quot;&gt;https://github.com/wxWidgets/wxWidgets/releases/download/v3.0.3/wxWidgets-3.0.3.tar.bz2&lt;/a&gt;&lt;/code&gt; ) u obtenerlo de github con correcciones de errores:</target>
        </trans-unit>
        <trans-unit id="60d473a6aa433acfb9c1c6ca737fe13eaf0848c9" translate="yes" xml:space="preserve">
          <source>If you want to build using a compatible Erlang/OTP system in the &lt;code&gt;$PATH&lt;/code&gt;, jump to (3).</source>
          <target state="translated">Si desea construir usando un sistema Erlang / OTP compatible en &lt;code&gt;$PATH&lt;/code&gt; , vaya a (3).</target>
        </trans-unit>
        <trans-unit id="eb5df9d9054fc0c4d2d1fdf02282b9d140be554d" translate="yes" xml:space="preserve">
          <source>If you want to change the file name of the implicit -file() attributes inserted during preprocessing, you can do with &lt;code&gt;{source_name, SourceName}&lt;/code&gt;. If unset it will default to the name of the opened file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c541b95485f056deb59b7660fe1bc3263ea0c2c7" translate="yes" xml:space="preserve">
          <source>If you want to copy a library (an application) newly built, to a release area, you do like with the emulator:</source>
          <target state="translated">Si quieres copiar una biblioteca (una aplicación)recién construida,a un área de lanzamiento,hazlo como con el emulador:</target>
        </trans-unit>
        <trans-unit id="478802cbe47a5a6b031caf1a058324304adf72a9" translate="yes" xml:space="preserve">
          <source>If you want to do structured logging, but still want to have some control of how the final log message is formatted you can give a &lt;code&gt;report_cb&lt;/code&gt; as part of the metadata with your log event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af39ab464f4c4ad6184b7312f8ff3491ab00be0a" translate="yes" xml:space="preserve">
          <source>If you want to force a matching failure at some point in a pattern, the most convenient way to do it is with (?!), as an empty string always matches. So, an assertion that requires there is not to be an empty string must always fail. The backtracking control verb (*FAIL) or (*F) is a synonym for (?!).</source>
          <target state="translated">Si quieres forzar un fallo de coincidencia en algún punto de un patrón,la forma más conveniente de hacerlo es con (?!),ya que una cadena vacía siempre coincide.Por lo tanto,una afirmación que requiere que no haya una cadena vacía siempre debe fallar.El verbo de control de retroceso (*FAIL)o (*F)es un sinónimo de (?!).</target>
        </trans-unit>
        <trans-unit id="b53c1301abde2142a7a519277a4e352002bba7dc" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after a &lt;strong&gt;state change&lt;/strong&gt;, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d95e36a6d42c79b8d9f3cbb7ca6b72d1dfb12b0" translate="yes" xml:space="preserve">
          <source>If you want to ignore a particular event in the current state and handle it in a future state, you can postpone the event. A postponed event is retried after the state has changed, that is, &lt;code&gt;OldState =/= NewState&lt;/code&gt;.</source>
          <target state="translated">Si desea ignorar un evento en particular en el estado actual y manejarlo en un estado futuro, puede posponer el evento. Un evento pospuesto se vuelve a intentar despu&amp;eacute;s de que el estado haya cambiado, es decir, &lt;code&gt;OldState =/= NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9b637ab1ccef72c8ef19f9dd28f47f58deee1a99" translate="yes" xml:space="preserve">
          <source>If you want to limit the size of the trace logs, you can use wrap logs. This works almost like a circular buffer. You can specify the maximum number of binary logs and the maximum size of each log. &lt;code&gt;ttb&lt;/code&gt; then creates a new binary log each time a log reaches the maximum size. When the maximum number of logs are reached, the oldest log is deleted before a new one is created.</source>
          <target state="translated">Si desea limitar el tama&amp;ntilde;o de los registros de seguimiento, puede utilizar los registros de ajuste. Esto funciona casi como un b&amp;uacute;fer circular. Puede especificar el n&amp;uacute;mero m&amp;aacute;ximo de registros binarios y el tama&amp;ntilde;o m&amp;aacute;ximo de cada registro. &lt;code&gt;ttb&lt;/code&gt; luego crea un nuevo registro binario cada vez que un registro alcanza el tama&amp;ntilde;o m&amp;aacute;ximo. Cuando se alcanza el n&amp;uacute;mero m&amp;aacute;ximo de registros, el registro m&amp;aacute;s antiguo se elimina antes de crear uno nuevo.</target>
        </trans-unit>
        <trans-unit id="3ba20665ef257abe2a78ab66aec5b8422b06c770" translate="yes" xml:space="preserve">
          <source>If you want to match typical palindromic phrases, the pattern must ignore all non-word characters, which can be done as follows:</source>
          <target state="translated">Si se quiere hacer coincidir con las típicas frases palindrómicas,el patrón debe ignorar todos los caracteres no denominativos,lo que se puede hacer de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ecc0e9164bc34f28d81e7ffb4afcab4e5c0c14b8" translate="yes" xml:space="preserve">
          <source>If you want to only print run-time per thread type you can do:</source>
          <target state="translated">Si quieres imprimir sólo el tiempo de ejecución por tipo de hilo puedes hacerlo:</target>
        </trans-unit>
        <trans-unit id="be41c980691226fb7b2d6a9c0782adc2d56de58a" translate="yes" xml:space="preserve">
          <source>If you want to output the content of an XML element or an attribute you will get the value as a string by the &lt;code&gt;value_of&lt;/code&gt; function:</source>
          <target state="translated">Si desea generar el contenido de un elemento XML o un atributo, obtendr&amp;aacute; el valor como una cadena por la funci&amp;oacute;n &lt;code&gt;value_of&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e7aef053601a6ea882918cfebb175091d4d52943" translate="yes" xml:space="preserve">
          <source>If you want to parse the XML file motorcycles.xml you run it in the Erlang shell like:</source>
          <target state="translated">Si quieres analizar el archivo XML motorcycles.xml lo ejecutas en el shell de Erlang como:</target>
        </trans-unit>
        <trans-unit id="6e509b56bd064c6196e8412d4a6710ea854feb39" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt; driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0f0b294d62ab97983874294bfe640932bf22f5a" translate="yes" xml:space="preserve">
          <source>If you want to pass a binary and do not already have the content of the binary in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, you can benefit from using &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; instead of creating an &lt;code&gt;ErlDrvBinary&lt;/code&gt; through &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; and then pass the binary through &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt;. The runtime system often allocates binaries smarter if &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; is used. However, if the content of the binary to pass already resides in an &lt;code&gt;ErlDrvBinary&lt;/code&gt;, it is normally better to pass the binary using &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; and the &lt;code&gt;ErlDrvBinary&lt;/code&gt; in question.</source>
          <target state="translated">Si desea pasar un binario y a&amp;uacute;n no tiene el contenido del binario en un &lt;code&gt;ErlDrvBinary&lt;/code&gt; , puede beneficiarse de utilizar &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; en lugar de crear un &lt;code&gt;ErlDrvBinary&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;#driver_alloc_binary&quot;&gt;driver_alloc_binary&lt;/a&gt;&lt;/code&gt; y luego pasar el binario a trav&amp;eacute;s de &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; . El sistema de tiempo de ejecuci&amp;oacute;n a menudo asigna binarios de forma m&amp;aacute;s inteligente si se utiliza &lt;code&gt;ERL_DRV_BUF2BINARY&lt;/code&gt; . Sin embargo, si el contenido del binario para pasar ya reside en un &lt;code&gt;ErlDrvBinary&lt;/code&gt; , normalmente es mejor pasar el binario usando &lt;code&gt;ERL_DRV_BINARY&lt;/code&gt; y el &lt;code&gt;ErlDrvBinary&lt;/code&gt; en cuesti&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="480d25bad4b8ee292973eb9f4a96b57aec47c435" translate="yes" xml:space="preserve">
          <source>If you want to separate your test code from your normal code (at least for testing the exported functions), you can simply write the test functions in a module named &lt;code&gt;m_tests&lt;/code&gt; (note: not &lt;code&gt;m_test&lt;/code&gt;), if your module is named &lt;code&gt;m&lt;/code&gt;. Then, whenever you ask EUnit to test the module &lt;code&gt;m&lt;/code&gt;, it will also look for the module &lt;code&gt;m_tests&lt;/code&gt; and run those tests as well. See &lt;code&gt;ModuleName&lt;/code&gt; in the section &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; for details.</source>
          <target state="translated">Si desea separar su c&amp;oacute;digo de prueba de su c&amp;oacute;digo normal (al menos para probar las funciones exportadas), simplemente puede escribir las funciones de prueba en un m&amp;oacute;dulo llamado &lt;code&gt;m_tests&lt;/code&gt; (nota: no &lt;code&gt;m_test&lt;/code&gt; ), si su m&amp;oacute;dulo se llama &lt;code&gt;m&lt;/code&gt; . Luego, siempre que le pida a EUnit que pruebe el m&amp;oacute;dulo &lt;code&gt;m&lt;/code&gt; , tambi&amp;eacute;n buscar&amp;aacute; el m&amp;oacute;dulo &lt;code&gt;m_tests&lt;/code&gt; y ejecutar&amp;aacute; esas pruebas tambi&amp;eacute;n. Consulte &lt;code&gt;ModuleName&lt;/code&gt; en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#Primitives&quot;&gt;Primitives&lt;/a&gt;&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="7febab41e67d722699474affa70aca83861a7f64" translate="yes" xml:space="preserve">
          <source>If you want to tailor your Erlang/OTP build and installation, please read on for detailed information about the individual steps.</source>
          <target state="translated">Si desea adaptar su construcción e instalación de Erlang/OTP,por favor siga leyendo para obtener información detallada sobre los pasos individuales.</target>
        </trans-unit>
        <trans-unit id="5c51074011b9826995f35f468d11eff897ad5c37" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="translated">Si desea rastrear llamadas de funci&amp;oacute;n (es decir, si tiene una &lt;code&gt;call&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; rastreo establecida en cualquier proceso), tambi&amp;eacute;n debe establecer patrones de rastreo en las funciones requeridas con ttb: tp / 2,3,4 o &lt;code&gt;&lt;a href=&quot;ttb#-0&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt; . Una funci&amp;oacute;n solo se rastrea si tiene un patr&amp;oacute;n de rastreo. El patr&amp;oacute;n de rastreo especifica c&amp;oacute;mo rastrear la funci&amp;oacute;n utilizando especificaciones de coincidencia. Las especificaciones de coincidencia se describen en la &lt;code&gt;ERTS User's Guide&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c40a044ef678327852ece515ee5ae9954050c2e8" translate="yes" xml:space="preserve">
          <source>If you want to trace function calls (that is, if you have trace flag &lt;code&gt;call&lt;/code&gt; set on any process), you must also set trace patterns on the required function(s) with &lt;code&gt;&lt;a href=&quot;ttb#tp-2&quot;&gt;ttb:tp/2,3,4&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ttb#tpl-2&quot;&gt;ttb:tpl/2,3,4&lt;/a&gt;&lt;/code&gt;. A function is only traced if it has a trace pattern. The trace pattern specifies how to trace the function by using match specifications. Match specifications are described in the &lt;code&gt;ERTS User's Guide&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4204e5cb6bf67f77002e41cae41377b945558f43" translate="yes" xml:space="preserve">
          <source>If you want your systems logs to be printed to a file instead, you must configure the default handler to do so. The simplest way is to include the following in your &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Si desea que los registros de su sistema se impriman en un archivo, debe configurar el controlador predeterminado para hacerlo. La forma m&amp;aacute;s sencilla es incluir lo siguiente en su &lt;code&gt;&lt;a href=&quot;config&quot;&gt;sys.config&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bc1242f30c23d446d1188a6ac120aa5dbc4659e1" translate="yes" xml:space="preserve">
          <source>If you wish to exit the interactive mode (for example, to start an automated test run with &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;), call function &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt;. This shuts down the running &lt;code&gt;ct&lt;/code&gt; application. Associations between configuration names and data created with &lt;code&gt;require&lt;/code&gt; are consequently deleted. Function &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; takes you back into interactive mode, but the previous state is not restored.</source>
          <target state="translated">Si desea salir del modo interactivo (por ejemplo, para iniciar una ejecuci&amp;oacute;n de prueba automatizada con &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; ), llame a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ct#stop_interactive-0&quot;&gt;ct:stop_interactive/0&lt;/a&gt;&lt;/code&gt; . Esto cierra la aplicaci&amp;oacute;n &lt;code&gt;ct&lt;/code&gt; en ejecuci&amp;oacute;n . En consecuencia, se eliminan las asociaciones entre los nombres de configuraci&amp;oacute;n y los datos creados con &lt;code&gt;require&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ct#start_interactive-0&quot;&gt;ct:start_interactive/0&lt;/a&gt;&lt;/code&gt; lo lleva de regreso al modo interactivo, pero el estado anterior no se restaura.</target>
        </trans-unit>
        <trans-unit id="e10f84ca92ffa048cba38c4e906ca1f626ae3a34" translate="yes" xml:space="preserve">
          <source>If you wish to store an arbitrary pointer in the registry, specify a &lt;code&gt;size&lt;/code&gt; of &lt;code&gt;0&lt;/code&gt;. In this case, the object itself is not transferred by an &lt;code&gt;ei_reg_dump()&lt;/code&gt; operation, only the pointer value.</source>
          <target state="translated">Si desea almacenar un puntero arbitrario en el registro, especifique un &lt;code&gt;size&lt;/code&gt; de &lt;code&gt;0&lt;/code&gt; . En este caso, el objeto en s&amp;iacute; no se transfiere mediante una operaci&amp;oacute;n &lt;code&gt;ei_reg_dump()&lt;/code&gt; , solo el valor del puntero.</target>
        </trans-unit>
        <trans-unit id="ebce7ca5b1598f3fc834609ac79ed9ef57b76a9b" translate="yes" xml:space="preserve">
          <source>If you're unable to produce back-ticks on your keyboard, you can use the ksh variant:</source>
          <target state="translated">Si no puedes producir back-ticks en tu teclado,puedes usar la variante ksh:</target>
        </trans-unit>
        <trans-unit id="898016192f939b5abb6e665e68d4a556cad78625" translate="yes" xml:space="preserve">
          <source>If you're using MinGW's MSYS instead, you need to change the &lt;code&gt;C_DRV&lt;/code&gt; setting, which would read:</source>
          <target state="translated">Si est&amp;aacute; utilizando MSYS de MinGW en su lugar, debe cambiar la configuraci&amp;oacute;n de &lt;code&gt;C_DRV&lt;/code&gt; , que leer&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="b80191fd2f2a93c0231ee04e580f333dbbc4b2c1" translate="yes" xml:space="preserve">
          <source>If you've upgraded the source with a patch you may need to clean up from previous builds before the new build. Make sure to read the &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; section below before doing a &lt;code&gt;make clean&lt;/code&gt;.</source>
          <target state="translated">Si ha actualizado la fuente con un parche, es posible que deba limpiar las versiones anteriores antes de la nueva. Aseg&amp;uacute;rese de leer la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#Advanced-configuration-and-build-of-ErlangOTP_Building_Prebuilt-Source-Release&quot;&gt;Pre-built Source Release&lt;/a&gt;&lt;/code&gt; continuaci&amp;oacute;n antes de hacer una &lt;code&gt;make clean&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="94d3d2824c70cd2f197cb4a4e891f6adbf0d6555" translate="yes" xml:space="preserve">
          <source>If your application has multiple levels of supervision, then do not simply set the restart intensities to the same values on all levels. Keep in mind that the total number of restarts (before the top level supervisor gives up and terminates the application) will be the product of the intensity values of all the supervisors above the failing child process.</source>
          <target state="translated">Si su aplicación tiene múltiples niveles de supervisión,entonces no se limite a establecer las intensidades de reinicio a los mismos valores en todos los niveles.Tenga en cuenta que el número total de reinicios (antes de que el supervisor de nivel superior se rinda y termine la aplicación)será el producto de los valores de intensidad de todos los supervisores por encima del proceso del niño que falla.</target>
        </trans-unit>
        <trans-unit id="8bdaa0464a895b83db580413a1dfb239d0cea7a3" translate="yes" xml:space="preserve">
          <source>If your driver supports scrollable cursors you have a little more freedom, and can do things like this.</source>
          <target state="translated">Si tu conductor soporta los cursores desplazables tienes un poco más de libertad,y puedes hacer cosas como esta.</target>
        </trans-unit>
        <trans-unit id="d4baf8bf70284fc593a0f0c3da52f4c0847c8447" translate="yes" xml:space="preserve">
          <source>If your process logic is convenient to describe as a state machine, and you want any of these &lt;code&gt;gen_statem&lt;/code&gt; key features:</source>
          <target state="translated">Si la l&amp;oacute;gica de su proceso es conveniente para describirla como una m&amp;aacute;quina de estado y desea cualquiera de estas &lt;code&gt;gen_statem&lt;/code&gt; clave de gen_statem :</target>
        </trans-unit>
        <trans-unit id="3a769c81046d5475e30518ad57d42d8c20c63372" translate="yes" xml:space="preserve">
          <source>If your test code writes to the standard output, you may be surprised to see that the text does not appear on the console when the tests are running. This is because EUnit captures all standard output from test functions (this also includes setup and cleanup functions, but not generator functions), so that it can be included in the test report if errors occur. To bypass EUnit and print text directly to the console while testing, you can write to the &lt;code&gt;user&lt;/code&gt; output stream, as in &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt;. The recommended way of doing this is to use the EUnit &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt;, which make it much simpler.</source>
          <target state="translated">Si su c&amp;oacute;digo de prueba se escribe en la salida est&amp;aacute;ndar, es posible que se sorprenda al ver que el texto no aparece en la consola cuando se est&amp;aacute;n ejecutando las pruebas. Esto se debe a que EUnit captura toda la salida est&amp;aacute;ndar de las funciones de prueba (esto tambi&amp;eacute;n incluye las funciones de configuraci&amp;oacute;n y limpieza, pero no las funciones del generador), de modo que se puede incluir en el informe de prueba si se producen errores. Para omitir EUnit e imprimir texto directamente en la consola durante la prueba, puede escribir en el flujo de salida del &lt;code&gt;user&lt;/code&gt; , como en &lt;code&gt;io:format(user, &quot;~w&quot;, [Term])&lt;/code&gt; . La forma recomendada de hacer esto es usar las &lt;code&gt;&lt;a href=&quot;#Debugging_macros&quot;&gt;Debugging macros&lt;/a&gt;&lt;/code&gt; EUnit , que lo hacen mucho m&amp;aacute;s simple.</target>
        </trans-unit>
        <trans-unit id="7e46e774253b8a01c9e57b4a236314fe7c6f0933" translate="yes" xml:space="preserve">
          <source>If, for example, only information originating from the UNIX kernel is to be supervised, the line is to begin with &lt;code&gt;kern.LEVEL&lt;/code&gt;. For the possible values of &lt;code&gt;LEVEL&lt;/code&gt;, see &lt;code&gt;syslog.conf(5)&lt;/code&gt;.</source>
          <target state="translated">Si, por ejemplo, solo se va a supervisar la informaci&amp;oacute;n que se origina en el kernel de UNIX, la l&amp;iacute;nea debe comenzar con &lt;code&gt;kern.LEVEL&lt;/code&gt; . Para conocer los posibles valores de &lt;code&gt;LEVEL&lt;/code&gt; , consulte &lt;code&gt;syslog.conf(5)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e15af770ad74c816f0b9bed18089dc4b7b6949" translate="yes" xml:space="preserve">
          <source>If, however, the more brutal variant is preferred, the the release upgrade file can be handwritten using only the single upgrade instruction &lt;code&gt;restart_emulator&lt;/code&gt;. This instruction, in contrast to &lt;code&gt;restart_new_emulator&lt;/code&gt;, causes the emulator to restart with the new versions of &lt;strong&gt;all&lt;/strong&gt; applications.</source>
          <target state="translated">Sin embargo, si se prefiere la variante m&amp;aacute;s brutal, el archivo de actualizaci&amp;oacute;n de la versi&amp;oacute;n se puede escribir a mano utilizando solo la instrucci&amp;oacute;n de actualizaci&amp;oacute;n &amp;uacute;nica &lt;code&gt;restart_emulator&lt;/code&gt; . Esta instrucci&amp;oacute;n, a diferencia de &lt;code&gt;restart_new_emulator&lt;/code&gt; , hace que el emulador se reinicie con las nuevas versiones de &lt;strong&gt;todas las&lt;/strong&gt; aplicaciones.</target>
        </trans-unit>
        <trans-unit id="8767a6609841ad161f8c8ba70fce614ffbb6d735" translate="yes" xml:space="preserve">
          <source>If, however, the profiling time is short, and the host machine OS does not support high resolution cpu time measurements, some few OS schedulings may show up as ridiculously long execution times for functions doing practically nothing. An example of a function more or less just composing a tuple in about 100 times the normal execution time has been seen, and when the tracing was repeated, the execution time became normal.</source>
          <target state="translated">Sin embargo,si el tiempo de elaboración de perfiles es corto,y el sistema operativo de la máquina anfitriona no soporta mediciones de tiempo de cpu de alta resolución,algunas pocas programaciones del sistema operativo pueden aparecer como tiempos de ejecución ridículamente largos para funciones que no hacen prácticamente nada.Se ha visto un ejemplo de una función que compone más o menos una tupla en unas 100 veces el tiempo de ejecución normal,y cuando se repitió el trazado,el tiempo de ejecución se volvió normal.</target>
        </trans-unit>
        <trans-unit id="59b8380df4e4f344feb44d33018af07ce17468c9" translate="yes" xml:space="preserve">
          <source>Ifopts :: &lt;code&gt;&lt;a href=&quot;#type-getifaddrs_ifopts&quot;&gt;getifaddrs_ifopts()&lt;/a&gt;&lt;/code&gt;}]} |</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ab139e8caa6336e1a75280870aaa88d194b8f0" translate="yes" xml:space="preserve">
          <source>Ignores the next term.</source>
          <target state="translated">Ignora el próximo período.</target>
        </trans-unit>
        <trans-unit id="556c1293becdd2112a2dbef3ccdc8818c38e5526" translate="yes" xml:space="preserve">
          <source>Igor will look for terms &lt;code&gt;{igor, List}&lt;/code&gt; in the compile options, where &lt;code&gt;List&lt;/code&gt; is a list of Igor-specific options, as follows:</source>
          <target state="translated">Igor buscar&amp;aacute; t&amp;eacute;rminos &lt;code&gt;{igor, List}&lt;/code&gt; en las opciones de compilaci&amp;oacute;n, donde &lt;code&gt;List&lt;/code&gt; es una lista de opciones espec&amp;iacute;ficas de Igor, de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="12b0ac37014df125334c7cd0aa5d1e3fd4b2112b" translate="yes" xml:space="preserve">
          <source>Igor: the Module Merger and Renamer.</source>
          <target state="translated">Igor:la fusión de módulos y el renombrador.</target>
        </trans-unit>
        <trans-unit id="434e93d1be37385e2cb586a90949b6d54ba9fb45" translate="yes" xml:space="preserve">
          <source>Illegal record use</source>
          <target state="translated">Uso de registros ilegales</target>
        </trans-unit>
        <trans-unit id="3e2e754eaf99ea7ee3f9e02b703f2ea22dce19f1" translate="yes" xml:space="preserve">
          <source>Imagine two nodes, &lt;code&gt;A&lt;/code&gt; that initiates the handshake and &lt;code&gt;B&lt;/code&gt; that accepts the connection.</source>
          <target state="translated">Imagine dos nodos, &lt;code&gt;A&lt;/code&gt; que inicia el protocolo de enlace y &lt;code&gt;B&lt;/code&gt; que acepta la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8170de3694759bfa15c0e42d75a0e2dbd2eae04c" translate="yes" xml:space="preserve">
          <source>Immediately after &lt;code&gt;{addr,_}&lt;/code&gt; follows &lt;code&gt;{netmask,_}&lt;/code&gt;.</source>
          <target state="translated">Inmediatamente despu&amp;eacute;s de &lt;code&gt;{addr,_}&lt;/code&gt; sigue &lt;code&gt;{netmask,_}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1bf55aaa279dcec7c69afe67e49a23edfac3d7b" translate="yes" xml:space="preserve">
          <source>Immediately closes a socket in one or two directions.</source>
          <target state="translated">Cierra inmediatamente un enchufe en una o dos direcciones.</target>
        </trans-unit>
        <trans-unit id="0146e3e7271e73fd4397519ed5ac080aa4266f79" translate="yes" xml:space="preserve">
          <source>Immediately thereafter follows &lt;code&gt;{broadaddr,_}&lt;/code&gt; if flag &lt;code&gt;broadcast&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; set and flag &lt;code&gt;pointtopoint&lt;/code&gt;&lt;strong&gt;is&lt;/strong&gt; set.</source>
          <target state="translated">Inmediatamente despu&amp;eacute;s sigue a &lt;code&gt;{broadaddr,_}&lt;/code&gt; si la &lt;code&gt;broadcast&lt;/code&gt; bandera &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute; establecida y la bandera &lt;code&gt;pointtopoint&lt;/code&gt; &lt;strong&gt;est&amp;aacute;&lt;/strong&gt; establecida.</target>
        </trans-unit>
        <trans-unit id="cb29b93b7dda93ac46a90e113b640a73b1abac2b" translate="yes" xml:space="preserve">
          <source>Immediately thereafter may &lt;code&gt;{broadaddr,_}&lt;/code&gt; follow if &lt;code&gt;broadcast&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;, or &lt;code&gt;{dstaddr,_}&lt;/code&gt; if &lt;code&gt;pointtopoint&lt;/code&gt; is member of &lt;code&gt;Flags&lt;/code&gt;. Both &lt;code&gt;{dstaddr,_}&lt;/code&gt; and &lt;code&gt;{broadaddr,_}&lt;/code&gt; does not occur for the same &lt;code&gt;{addr,_}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f115c5f2dd3a1366bda08a49baad63fd02afde98" translate="yes" xml:space="preserve">
          <source>Imperial_Aramaic</source>
          <target state="translated">Imperial_Aramaic</target>
        </trans-unit>
        <trans-unit id="bc83afa84755c20a6573a25450865f22d16b7af9" translate="yes" xml:space="preserve">
          <source>Implement a User-Specific Handler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3848d63613aeeb25bb34384b1787a4b8da6d6ff9" translate="yes" xml:space="preserve">
          <source>Implement an &lt;code&gt;outputv&lt;/code&gt; callback (instead of an &lt;code&gt;output&lt;/code&gt; callback) in the driver. If a driver has an &lt;code&gt;outputv&lt;/code&gt; callback, refc binaries passed in an iolist in the &lt;code&gt;Data&lt;/code&gt; argument for &lt;code&gt;port_command/2&lt;/code&gt; will be passed as references to the driver.</source>
          <target state="translated">Implemente una &lt;code&gt;outputv&lt;/code&gt; llamada de &lt;code&gt;output&lt;/code&gt; (en lugar de una devoluci&amp;oacute;n de llamada de salida ) en el controlador. Si un controlador tiene una &lt;code&gt;outputv&lt;/code&gt; llamada outputv , los binarios refc pasados ​​en una iolist en el argumento &lt;code&gt;Data&lt;/code&gt; para &lt;code&gt;port_command/2&lt;/code&gt; se pasar&amp;aacute;n como referencias al controlador.</target>
        </trans-unit>
        <trans-unit id="2550fab1130c47b29d0bf324dcd951c87cbd4c20" translate="yes" xml:space="preserve">
          <source>Implement the user(s).</source>
          <target state="translated">Implementar el usuario o usuarios.</target>
        </trans-unit>
        <trans-unit id="48c5877ca241f34b3f104510084da2e3f17d9449" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">Implementación:Se utiliza un árbol de búsqueda binario equilibrado.La complejidad del tiempo es proporcional al tronco N,donde N es el número de bloques libres.</target>
        </trans-unit>
        <trans-unit id="986bf772c885393163838b577762f2d1f9c7f455" translate="yes" xml:space="preserve">
          <source>Implementation: A balanced binary search tree is used. The time complexity is proportional to log N, where N is the number of sizes of free blocks.</source>
          <target state="translated">Implementación:Se utiliza un árbol de búsqueda binario equilibrado.La complejidad temporal es proporcional al tronco N,donde N es el número de tamaños de los bloques libres.</target>
        </trans-unit>
        <trans-unit id="bd869e893b5f7a40f0a166908e0bc628120afba1" translate="yes" xml:space="preserve">
          <source>Implementation: Balanced binary search trees are used. The time complexity is proportional to log N, where N is the number of free blocks.</source>
          <target state="translated">Implementación:Se utilizan árboles de búsqueda binarios equilibrados.La complejidad del tiempo es proporcional al tronco N,donde N es el número de bloques libres.</target>
        </trans-unit>
        <trans-unit id="46bfb88bf9e53e73f8388ee9ed0d26c11b02304f" translate="yes" xml:space="preserve">
          <source>Implementation: Inspect the first block in a free-list. If it satisfies the request, it is used, otherwise a new carrier is created. The implementation has a time complexity that is constant.</source>
          <target state="translated">Implementación:Inspeccionar el primer bloque de una lista libre.Si satisface la solicitud,se utiliza,de lo contrario se crea un nuevo portador.La implementación tiene una complejidad temporal que es constante.</target>
        </trans-unit>
        <trans-unit id="c6a2194bfaf5e060ecf03c5376d35a554cce3c35" translate="yes" xml:space="preserve">
          <source>Implementation: The implementation uses segregated free lists with a maximum block search depth (in each list) to find a good fit fast. When the maximum block search depth is small (by default 3), this implementation has a time complexity that is constant. The maximum block search depth can be configured using parameter &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Implementaci&amp;oacute;n: La implementaci&amp;oacute;n utiliza listas libres segregadas con una profundidad de b&amp;uacute;squeda de bloque m&amp;aacute;xima (en cada lista) para encontrar un buen ajuste r&amp;aacute;pidamente. Cuando la profundidad m&amp;aacute;xima de b&amp;uacute;squeda de bloques es peque&amp;ntilde;a (por defecto 3), esta implementaci&amp;oacute;n tiene una complejidad de tiempo constante. La profundidad m&amp;aacute;xima de b&amp;uacute;squeda de bloques se puede configurar mediante el par&amp;aacute;metro &lt;code&gt;&lt;a href=&quot;#M_mbsd&quot;&gt;mbsd&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aa4a22b5053f3e953012b88774f1658cf1eb84b" translate="yes" xml:space="preserve">
          <source>Implementing a Manager Application.</source>
          <target state="translated">Implementar una aplicación de gestión.</target>
        </trans-unit>
        <trans-unit id="d1d356a99f2a68bb32f56a5afc4fc7243ac4c122" translate="yes" xml:space="preserve">
          <source>Implementing an MIB can be a tedious task. Most probably, there is a need to test the agent before all tables and variables are implemented. In this case, the default instrumentation functions are useful. The toolkit can generate default instrumentation functions for variables as well as for tables. Consequently, a running prototype agent, which can handle &lt;code&gt;set&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt;, &lt;code&gt;get-next&lt;/code&gt; and table operations, is generated without any programming.</source>
          <target state="translated">Implementar un MIB puede ser una tarea tediosa. Lo m&amp;aacute;s probable es que sea necesario probar el agente antes de implementar todas las tablas y variables. En este caso, las funciones de instrumentaci&amp;oacute;n predeterminadas son &amp;uacute;tiles. El kit de herramientas puede generar funciones de instrumentaci&amp;oacute;n predeterminadas para variables y tablas. En consecuencia, se genera un agente prototipo en ejecuci&amp;oacute;n, que puede manejar las operaciones &lt;code&gt;set&lt;/code&gt; , &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;get-next&lt;/code&gt; y table, sin ninguna programaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5089bf216d6ab81557737c36828f21a117ecd8d4" translate="yes" xml:space="preserve">
          <source>Implementing support for Unicode character sets is an ongoing process. The Erlang Enhancement Proposal (EEP) 10 outlined the basics of Unicode support and specified a default encoding in binaries that all Unicode-aware modules are to handle in the future.</source>
          <target state="translated">La implementación del apoyo a los conjuntos de caracteres de Unicode es un proceso continuo.La Propuesta de Mejora de Erlang (EEP)10 esbozó los fundamentos del soporte de Unicode y especificó una codificación por defecto en los binarios que todos los módulos con conocimiento de Unicode deben manejar en el futuro.</target>
        </trans-unit>
        <trans-unit id="afb6d8666156732e31fdfd33a4e37fa8e0ff12b1" translate="yes" xml:space="preserve">
          <source>Implementing the MIB</source>
          <target state="translated">Implementación de la MIB</target>
        </trans-unit>
        <trans-unit id="3598443bca8912627263e77be152abb2f8fea1d8" translate="yes" xml:space="preserve">
          <source>Implements &lt;strong&gt;call streams with promises&lt;/strong&gt;, a type of RPC that does not suspend the caller until the result is finished. Instead, a key is returned, which can be used later to collect the value. The key can be viewed as a promise to deliver the answer.</source>
          <target state="translated">Implementa &lt;strong&gt;flujos de llamadas con promesas&lt;/strong&gt; , un tipo de RPC que no suspende a la persona que llama hasta que finaliza el resultado. En su lugar, se devuelve una clave, que se puede utilizar m&amp;aacute;s tarde para recopilar el valor. La clave puede verse como una promesa de entregar la respuesta.</target>
        </trans-unit>
        <trans-unit id="701e88bfb66430bf554605afebb5bc817eba6c88" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt; ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5852555552878975a45593281d37fefa3026933d" translate="yes" xml:space="preserve">
          <source>Implements an internal CRL (Certificate Revocation List) cache. In addition to implementing the &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; behaviour the following functions are available.</source>
          <target state="translated">Implementa una cach&amp;eacute; interna de CRL (lista de revocaci&amp;oacute;n de certificados). Adem&amp;aacute;s de implementar el comportamiento &lt;code&gt;&lt;a href=&quot;ssl_crl_cache_api&quot;&gt;ssl_crl_cache_api&lt;/a&gt;&lt;/code&gt; , est&amp;aacute;n disponibles las siguientes funciones.</target>
        </trans-unit>
        <trans-unit id="b29c8d309278d1184cdf0686f160a939ff31d257" translate="yes" xml:space="preserve">
          <source>Implements global (repetitive) search (flag &lt;code&gt;g&lt;/code&gt; in Perl). Each match is returned as a separate &lt;code&gt;list()&lt;/code&gt; containing the specific match and any matching subexpressions (or as specified by option &lt;code&gt;capture&lt;/code&gt;. The &lt;code&gt;Captured&lt;/code&gt; part of the return value is hence a &lt;code&gt;list()&lt;/code&gt; of &lt;code&gt;list()&lt;/code&gt;s when this option is specified.</source>
          <target state="translated">Implementa la b&amp;uacute;squeda global (repetitiva) (marca &lt;code&gt;g&lt;/code&gt; en Perl). Cada coincidencia se devuelve como una &lt;code&gt;list()&lt;/code&gt; separada () que contiene la coincidencia espec&amp;iacute;fica y las subexpresiones coincidentes (o seg&amp;uacute;n lo especificado por la &lt;code&gt;capture&lt;/code&gt; opci&amp;oacute;n . La parte &lt;code&gt;Captured&lt;/code&gt; del valor de retorno es, por lo tanto, una &lt;code&gt;list()&lt;/code&gt; de &lt;code&gt;list()&lt;/code&gt; s cuando se especifica esta opci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d0d6b7b06bc0717a09a0609e9b93d5b110576e74" translate="yes" xml:space="preserve">
          <source>Implements the transformation at compile time. This function is called by the compiler to do the source code transformation if and when header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is included in the source code.</source>
          <target state="translated">Implementa la transformaci&amp;oacute;n en tiempo de compilaci&amp;oacute;n. El compilador llama a esta funci&amp;oacute;n para realizar la transformaci&amp;oacute;n del c&amp;oacute;digo fuente si el archivo de encabezado &lt;code&gt;ms_transform.hrl&lt;/code&gt; est&amp;aacute; incluido en el c&amp;oacute;digo fuente.</target>
        </trans-unit>
        <trans-unit id="6edd4a0551006932a13f07152c0a0aa13d34aeb3" translate="yes" xml:space="preserve">
          <source>Implements the transformation when the &lt;code&gt;fun2ms/1&lt;/code&gt; functions are called from the shell. In this case, the abstract form is for one single fun (parsed by the Erlang shell). All imported variables are to be in the key-value list passed as &lt;code&gt;BoundEnvironment&lt;/code&gt;. The result is a term, normalized, that is, not in abstract format.</source>
          <target state="translated">Implementa la transformaci&amp;oacute;n cuando las funciones &lt;code&gt;fun2ms/1&lt;/code&gt; se llaman desde el shell. En este caso, la forma abstracta es para una sola diversi&amp;oacute;n (analizada por el shell de Erlang). Todas las variables importadas deben estar en la lista de valores-clave pasada como &lt;code&gt;BoundEnvironment&lt;/code&gt; . El resultado es un t&amp;eacute;rmino, normalizado, es decir, no en formato abstracto.</target>
        </trans-unit>
        <trans-unit id="5157539667ba028bf842cb4d314ce494573a8908" translate="yes" xml:space="preserve">
          <source>Implicitly when a specific instruction is defined. This is by far the most common way. Whenever a specific instruction is created, &lt;strong&gt;beam_makeops&lt;/strong&gt; automatically creates an internal generic instruction if it does not previously exist.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6fbc9d2bdd580e18ed0bc5805dc26db323d6f5f" translate="yes" xml:space="preserve">
          <source>Import</source>
          <target state="translated">Import</target>
        </trans-unit>
        <trans-unit id="b7c113ae3f8b579e4a0169b23cb527018f3cd218" translate="yes" xml:space="preserve">
          <source>Import configuration data (similar to &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt;).</source>
          <target state="translated">Importar datos de configuraci&amp;oacute;n (similar a &lt;code&gt;ct_run -config/-userconfig&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="64200c8515980ead3d6f6d1c54b72c0df1647038" translate="yes" xml:space="preserve">
          <source>Imported functions. Can be called the same way as local functions, that is, without any module prefix.</source>
          <target state="translated">Funciones importadas.Se pueden llamar de la misma manera que las funciones locales,es decir,sin ningún prefijo de módulo.</target>
        </trans-unit>
        <trans-unit id="e96159a0570df1d76f4d6b6b63ad56985185ffc2" translate="yes" xml:space="preserve">
          <source>Imports coverage data from the file &lt;code&gt;ExportFile&lt;/code&gt; created with &lt;code&gt;cover:export/1,2&lt;/code&gt;. Any analysis performed after this will include the imported data.</source>
          <target state="translated">Importa datos de cobertura del archivo &lt;code&gt;ExportFile&lt;/code&gt; creado con &lt;code&gt;cover:export/1,2&lt;/code&gt; . Cualquier an&amp;aacute;lisis realizado despu&amp;eacute;s de esto incluir&amp;aacute; los datos importados.</target>
        </trans-unit>
        <trans-unit id="6293ff4a8408c9b4904b5c4c8135a7dbb83fe606" translate="yes" xml:space="preserve">
          <source>Improper use can seriously degrade system performance.</source>
          <target state="translated">El uso inadecuado puede degradar seriamente el rendimiento del sistema.</target>
        </trans-unit>
        <trans-unit id="68545fd32c1a3f37a53bcab05bb6a3c24b6ca95e" translate="yes" xml:space="preserve">
          <source>In .emacs, the slash character &quot;/&quot; can be used as path separator. But if you decide to use the backslash character &quot;\&quot;, please not that you must use double backslashes, since they are treated as escape characters by Emacs.</source>
          <target state="translated">En el .emacs,el carácter de la barra &quot;/&quot; puede ser usado como separador de camino.Pero si decides usar el carácter de barra invertida &quot;\&quot;,por favor,no que debas usar barras invertidas dobles,ya que son tratados como caracteres de escape por Emacs.</target>
        </trans-unit>
        <trans-unit id="0f7795a31a2f6e68385e615d1e0b39534a4a427f" translate="yes" xml:space="preserve">
          <source>In 1994 the global tagging mode &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; was introduced. By putting &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; in the module header, the ASN.1 compiler automatically adds tags when needed. The following is the same specification in &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; mode:</source>
          <target state="translated">En 1994 se introdujo el modo de etiquetado global &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; . Al colocar &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; en el encabezado del m&amp;oacute;dulo, el compilador ASN.1 agrega etiquetas autom&amp;aacute;ticamente cuando es necesario. La siguiente es la misma especificaci&amp;oacute;n en el modo &lt;code&gt;AUTOMATIC TAGS&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b2eae1b23e89f4b197bf1ba45908178d3aa172d8" translate="yes" xml:space="preserve">
          <source>In 8-bit, non-UTF-8 mode, only the characters with code points &amp;lt; 256 are relevant.</source>
          <target state="translated">En el modo de 8 bits, no UTF-8, solo son relevantes los caracteres con puntos de c&amp;oacute;digo &amp;lt;256.</target>
        </trans-unit>
        <trans-unit id="fcb066c655ce1aa010477f09bef3fac0ead37f56" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under Cygwin/MSYS/MSYS2.</source>
          <target state="translated">En &lt;code&gt;$ERL_TOP&lt;/code&gt; , hay un script llamado &lt;code&gt;otp_build&lt;/code&gt; . Ese script maneja la molestia de proporcionar todos los par&amp;aacute;metros correctos para &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; y tambi&amp;eacute;n lo ayuda a configurar las variables de entorno correctas para trabajar con la fuente Erlang en Cygwin / MSYS / MSYS2.</target>
        </trans-unit>
        <trans-unit id="38e9bf33d69940366928f0c1e758698b02736bd6" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;$ERL_TOP&lt;/code&gt;, there is a script called &lt;code&gt;otp_build&lt;/code&gt;. That script handles the hassle of giving all the right parameters to &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; and also helps you set up the correct environment variables to work with the Erlang source under WSL.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e4870154b4a5f3a6bba7d020678f1436a7aad2" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant; the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant; the rest are to be 0. See &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;ID&lt;/code&gt; , solo 18 bits son significativos; el resto debe ser 0. En la &lt;code&gt;Creation&lt;/code&gt; , solo dos bits son significativos; el resto debe ser 0. Consulte &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0025e78fbaf5c3757dcab01eedc653609a16493" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Mnesia&lt;/code&gt;, all records in a table must have the same name. All the records must be instances of the same record type. The record name, however, does not necessarily have to be the same as the table name, although this is the case in most of the examples in this User's Guide. If a table is created without property &lt;code&gt;record_name&lt;/code&gt;, the following code ensures that all records in the tables have the same name as the table:</source>
          <target state="translated">En &lt;code&gt;Mnesia&lt;/code&gt; , todos los registros de una tabla deben tener el mismo nombre. Todos los registros deben ser instancias del mismo tipo de registro. Sin embargo, el nombre del registro no tiene que ser necesariamente el mismo que el de la tabla, aunque este es el caso en la mayor&amp;iacute;a de los ejemplos de esta Gu&amp;iacute;a del usuario. Si se crea una tabla sin la propiedad &lt;code&gt;record_name&lt;/code&gt; , el siguiente c&amp;oacute;digo garantiza que todos los registros de las tablas tengan el mismo nombre que la tabla:</target>
        </trans-unit>
        <trans-unit id="770b380d53bce026d82e5f70351df3a234e00dd1" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Module:Name/Arity&lt;/code&gt;, &lt;code&gt;Module&lt;/code&gt;, and &lt;code&gt;Name&lt;/code&gt; are atoms and &lt;code&gt;Arity&lt;/code&gt; is an integer. Starting from Erlang/OTP R15, &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt;, and &lt;code&gt;Arity&lt;/code&gt; can also be variables. A fun defined in this way refers to the function &lt;code&gt;Name&lt;/code&gt; with arity &lt;code&gt;Arity&lt;/code&gt; in the &lt;strong&gt;latest&lt;/strong&gt; version of module &lt;code&gt;Module&lt;/code&gt;. A fun defined in this way is not dependent on the code for the module in which it is defined.</source>
          <target state="translated">En &lt;code&gt;Module:Name/Arity&lt;/code&gt; , &lt;code&gt;Module&lt;/code&gt; y &lt;code&gt;Name&lt;/code&gt; son &amp;aacute;tomos y &lt;code&gt;Arity&lt;/code&gt; es un n&amp;uacute;mero entero. A partir de Erlang / OTP R15, &lt;code&gt;Module&lt;/code&gt; , &lt;code&gt;Name&lt;/code&gt; y &lt;code&gt;Arity&lt;/code&gt; tambi&amp;eacute;n pueden ser variables. Una diversi&amp;oacute;n definida de esta manera se refiere a la funci&amp;oacute;n &lt;code&gt;Name&lt;/code&gt; con &lt;code&gt;Arity&lt;/code&gt; en la &lt;strong&gt;&amp;uacute;ltima&lt;/strong&gt; versi&amp;oacute;n del m&amp;oacute;dulo &lt;code&gt;Module&lt;/code&gt; . Una diversi&amp;oacute;n definida de esta manera no depende del c&amp;oacute;digo del m&amp;oacute;dulo en el que est&amp;aacute; definida.</target>
        </trans-unit>
        <trans-unit id="e5df66c12eaa68ca0a48283d550d16d991720df0" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Name/Arity&lt;/code&gt;, &lt;code&gt;Name&lt;/code&gt; is an atom and &lt;code&gt;Arity&lt;/code&gt; is an integer. &lt;code&gt;Name/Arity&lt;/code&gt; must specify an existing local function. The expression is syntactic sugar for:</source>
          <target state="translated">En &lt;code&gt;Name/Arity&lt;/code&gt; , &lt;code&gt;Name&lt;/code&gt; es un &amp;aacute;tomo y &lt;code&gt;Arity&lt;/code&gt; es un n&amp;uacute;mero entero. &lt;code&gt;Name/Arity&lt;/code&gt; debe especificar una funci&amp;oacute;n local existente. La expresi&amp;oacute;n es az&amp;uacute;car sint&amp;aacute;ctica para:</target>
        </trans-unit>
        <trans-unit id="943fe69f8dfd82f02ed43163f6738a7b0394f445" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;OTP Configuration Parameters&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a472768ac00c2b862480bf36de83581f96978047" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;Type_List&lt;/code&gt; the &quot;path&quot; from the top type to each undecoded subcomponents is described. The top type of the path is an atom, the name of it. The action on each component/type that follows is described by one of &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;Type_List&lt;/code&gt; se describe la &quot;ruta&quot; desde el tipo superior a cada subcomponente no codificado. El tipo superior de la ruta es un &amp;aacute;tomo, su nombre. La acci&amp;oacute;n en cada componente / tipo que sigue se describe mediante uno de &lt;code&gt;{Name,parts}, {Name,undecoded}, {Name,Element_List}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="893648209f7036a7f9ac95fdc3c4a7d64bef1838" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;allocate_heap&lt;/code&gt;, the last operand is the number of live registers. It will only be used if there is not enough heap space and a garbage collection must be performed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c54988a1f913bda4c57ecea3e6f820b07cee1aa" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;attr&lt;/code&gt; the attributes of the object are stored as the logical &lt;strong&gt;OR&lt;/strong&gt; of its type (one of &lt;code&gt;EI_INT&lt;/code&gt;, &lt;code&gt;EI_FLT&lt;/code&gt;, &lt;code&gt;EI_BIN&lt;/code&gt;, and &lt;code&gt;EI_STR&lt;/code&gt;), whether it is marked for deletion (&lt;code&gt;EI_DELET&lt;/code&gt;), and whether it has been modified since the last backup to &lt;code&gt;Mnesia&lt;/code&gt; (&lt;code&gt;EI_DIRTY&lt;/code&gt;).</source>
          <target state="translated">En &lt;code&gt;attr&lt;/code&gt; , los atributos del objeto se almacenan como el &lt;strong&gt;OR&lt;/strong&gt; l&amp;oacute;gico de su tipo (uno de &lt;code&gt;EI_INT&lt;/code&gt; , &lt;code&gt;EI_FLT&lt;/code&gt; , &lt;code&gt;EI_BIN&lt;/code&gt; y &lt;code&gt;EI_STR&lt;/code&gt; ), si est&amp;aacute; marcado para su eliminaci&amp;oacute;n ( &lt;code&gt;EI_DELET&lt;/code&gt; ) y si se ha modificado desde la &amp;uacute;ltima copia de seguridad para &lt;code&gt;Mnesia&lt;/code&gt; ( &lt;code&gt;EI_DIRTY&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9643419e6aee2e17ffb863a8ef01b8323b347a6e" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions are given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="translated">En &lt;code&gt;ch1.erl&lt;/code&gt; y &lt;code&gt;ch2.erl&lt;/code&gt; anteriores, la implementaci&amp;oacute;n de los &lt;code&gt;channels/0&lt;/code&gt; , &lt;code&gt;alloc/1&lt;/code&gt; y &lt;code&gt;free/2&lt;/code&gt; se ha omitido intencionalmente, ya que no es relevante para el ejemplo. Para completar, a continuaci&amp;oacute;n se proporciona una forma de escribir estas funciones. Este es solo un ejemplo, una implementaci&amp;oacute;n realista debe poder manejar situaciones como quedarse sin canales para asignar, etc.</target>
        </trans-unit>
        <trans-unit id="27aabe06bd512676435ef4845535c23e8c05bacb" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ch1.erl&lt;/code&gt; and &lt;code&gt;ch2.erl&lt;/code&gt; above, the implementation of &lt;code&gt;channels/0&lt;/code&gt;, &lt;code&gt;alloc/1&lt;/code&gt;, and &lt;code&gt;free/2&lt;/code&gt; has been intentionally left out, as it is not relevant to the example. For completeness, one way to write these functions is given below. This is an example only, a realistic implementation must be able to handle situations like running out of channels to allocate, and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab0d5c626ce8dc42f39e1abeabf7105631919c54" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;ei_s_print_term()&lt;/code&gt;, parameter &lt;code&gt;s&lt;/code&gt; is to point to a dynamically (malloc) allocated string of &lt;code&gt;BUFSIZ&lt;/code&gt; bytes or a &lt;code&gt;NULL&lt;/code&gt; pointer. The string can be reallocated (and &lt;code&gt;*s&lt;/code&gt; can be updated) by this function if the result is more than &lt;code&gt;BUFSIZ&lt;/code&gt; characters. The string returned is &lt;code&gt;NULL&lt;/code&gt;-terminated.</source>
          <target state="translated">En &lt;code&gt;ei_s_print_term()&lt;/code&gt; , el par&amp;aacute;metro &lt;code&gt;s&lt;/code&gt; debe apuntar a una cadena asignada din&amp;aacute;micamente (malloc) de bytes &lt;code&gt;BUFSIZ&lt;/code&gt; o un puntero &lt;code&gt;NULL&lt;/code&gt; . La cadena se puede reasignar (y &lt;code&gt;*s&lt;/code&gt; se pueden actualizar) mediante esta funci&amp;oacute;n si el resultado tiene m&amp;aacute;s de &lt;code&gt;BUFSIZ&lt;/code&gt; caracteres. La cadena devuelta es &lt;code&gt;NULL&lt;/code&gt; terminada en.</target>
        </trans-unit>
        <trans-unit id="0a141cc5ac15d20e41285b60b7e1dbadddb212ee" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;file_logger&lt;/code&gt;:</source>
          <target state="translated">En &lt;code&gt;file_logger&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="7fbf17e1fc5bc4462fd00e9068033e131292be59" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;gen_statem&lt;/code&gt; we define a &lt;strong&gt;state change&lt;/strong&gt; as a &lt;strong&gt;state transition&lt;/strong&gt; in which the new state &lt;code&gt;S'&lt;/code&gt; is different from the current state &lt;code&gt;S&lt;/code&gt;, where &quot;different&quot; means Erlang's strict inequality: &lt;code&gt;=/=&lt;/code&gt; also known as &quot;does not match&quot;. &lt;code&gt;gen_statem&lt;/code&gt; does more things during &lt;strong&gt;state changes&lt;/strong&gt; than during other &lt;strong&gt;state transitions&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5dd48fe409f725dfa23be2b6d97df3560da702c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;is_eq_exact&lt;/code&gt;, the failure address (the first operand) will only be used if the two register operands are not equal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6953b7249dfd9871d1537ea03ef11de631fd526" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, filenames are bytewise encoded. This allows for list representation of all filenames in the system. However, a a file named &quot;&amp;Ouml;stersund.txt&quot;, appears in &lt;code&gt;file:list_dir/1&lt;/code&gt; either as &quot;&amp;Ouml;stersund.txt&quot; (if the filename was encoded in bytewise ISO Latin-1 by the program creating the file) or more probably as &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt;, which is a list containing UTF-8 bytes (not what you want). If you use Unicode filename translation on such a system, non-UTF-8 filenames are ignored by functions like &lt;code&gt;file:list_dir/1&lt;/code&gt;. They can be retrieved with function &lt;code&gt;file:list_dir_all/1&lt;/code&gt;, but wrongly encoded filenames appear as &quot;raw filenames&quot;.</source>
          <target state="translated">En &lt;code&gt;latin1&lt;/code&gt; modo, los nombres de archivo se byte a byte codificado. Esto permite la representaci&amp;oacute;n de una lista de todos los nombres de archivo en el sistema. Sin embargo, un archivo llamado &quot;&amp;Ouml;stersund.txt&quot;, aparece en &lt;code&gt;file:list_dir/1&lt;/code&gt; como &quot;&amp;Ouml;stersund.txt&quot; (si el nombre del archivo fue codificado en bytewise ISO Latin-1 por el programa que cre&amp;oacute; el archivo) o m&amp;aacute;s probablemente como &lt;code&gt;[195,150,115,116,101,114,115,117,110,100]&lt;/code&gt; , que es una lista que contiene bytes UTF-8 (no lo que desea). Si usa la traducci&amp;oacute;n de nombre de archivo Unicode en dicho sistema, los nombres de archivo que no son UTF-8 son ignorados por funciones como &lt;code&gt;file:list_dir/1&lt;/code&gt; . Se pueden recuperar con el &lt;code&gt;file:list_dir_all/1&lt;/code&gt; funci&amp;oacute;n : list_dir_all / 1 , pero los nombres de archivo codificados incorrectamente aparecen como &quot;nombres de archivo sin formato&quot;.</target>
        </trans-unit>
        <trans-unit id="116bd7f6b497e889e6e51bc1f52782d94cab61ab" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;latin1&lt;/code&gt; mode, the Erlang VM does not change the encoding of filenames. In &lt;code&gt;utf8&lt;/code&gt; mode, filenames can contain Unicode characters greater than 255 and the VM converts filenames back and forth to the native filename encoding (usually UTF-8, but UTF-16 on Windows).</source>
          <target state="translated">En el modo &lt;code&gt;latin1&lt;/code&gt; , Erlang VM no cambia la codificaci&amp;oacute;n de los nombres de archivo. En el modo &lt;code&gt;utf8&lt;/code&gt; , los nombres de archivo pueden contener caracteres Unicode mayores de 255 y la m&amp;aacute;quina virtual convierte los nombres de archivo de un lado a otro a la codificaci&amp;oacute;n del nombre de archivo nativo (generalmente UTF-8, pero UTF-16 en Windows).</target>
        </trans-unit>
        <trans-unit id="efaf4d06886c110e8f2a1c0d7f556c6c220cdc32" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;list_max/2&lt;/code&gt;, you walk down the list and use &lt;code&gt;Head&lt;/code&gt; instead of &lt;code&gt;Result_so_far&lt;/code&gt; when &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;when&lt;/code&gt; is a special word used before the -&amp;gt; in the function to say that you only use this part of the function if the test that follows is true. A test of this type is called &lt;strong&gt;guard&lt;/strong&gt;. If the guard is false (that is, the guard fails), the next part of the function is tried. In this case, if &lt;code&gt;Head&lt;/code&gt; is not greater than &lt;code&gt;Result_so_far&lt;/code&gt;, then it must be smaller or equal to it. This means that a guard on the next part of the function is not needed.</source>
          <target state="translated">En &lt;code&gt;list_max/2&lt;/code&gt; , recorre la lista y usa &lt;code&gt;Head&lt;/code&gt; en lugar de &lt;code&gt;Result_so_far&lt;/code&gt; cuando &lt;code&gt;Head&lt;/code&gt; &amp;gt; &lt;code&gt;Result_so_far&lt;/code&gt; . &lt;code&gt;when&lt;/code&gt; es una palabra especial que se usa antes de -&amp;gt; en la funci&amp;oacute;n para decir que solo usa esta parte de la funci&amp;oacute;n si la prueba que sigue es verdadera. Una prueba de este tipo se llama &lt;strong&gt;guardia&lt;/strong&gt; . Si la guardia es falsa (es decir, la guardia falla), se intenta la siguiente parte de la funci&amp;oacute;n. En este caso, si &lt;code&gt;Head&lt;/code&gt; no es mayor que &lt;code&gt;Result_so_far&lt;/code&gt; , entonces debe ser menor o igual. Esto significa que no se necesita una guardia en la siguiente parte de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5487ffcf59e4dcb4dda76a98d92b6b90dc718bb3" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;macros.tab&lt;/code&gt;, there is a definition of &lt;code&gt;GC_REGEXP&lt;/code&gt;. It will be described in &lt;code&gt;&lt;a href=&quot;#Syntax-of-tab-files_Defining-the-implementation_Macros-in-the-macrostab-file_The-GCREGEXP-definition&quot;&gt;a later section&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02cb096eaff82424f4a89dbad61cc6a39bc0e575" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;sort&lt;/code&gt; the fun is used:</source>
          <target state="translated">En &lt;code&gt;sort&lt;/code&gt; se usa la diversi&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="12c27e7f6632f170be6359162707f4b8a39d1d9c" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;terminal_logger&lt;/code&gt;:</source>
          <target state="translated">En &lt;code&gt;terminal_logger&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bbd6fe570f64e2ea4d9df82e02a34c966281d919" translate="yes" xml:space="preserve">
          <source>In &lt;code&gt;unicode&lt;/code&gt; mode, only ASCII numbers and letters have any special meaning after a backslash. All other characters (in particular, those whose code points are &amp;gt; 127) are treated as literals.</source>
          <target state="translated">En el modo &lt;code&gt;unicode&lt;/code&gt; , solo los n&amp;uacute;meros y letras ASCII tienen un significado especial despu&amp;eacute;s de una barra invertida. Todos los dem&amp;aacute;s caracteres (en particular, aquellos cuyos puntos de c&amp;oacute;digo son&amp;gt; 127) se tratan como literales.</target>
        </trans-unit>
        <trans-unit id="3192c3cf3b67f79505ca334fb569ea62ed1d48cb" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, decrypt &lt;code&gt;CipherText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and check the authenticity the &lt;code&gt;PlainText&lt;/code&gt; and &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data) using the &lt;code&gt;CipherTag&lt;/code&gt;. May return &lt;code&gt;error&lt;/code&gt; if the decryption or validation fail's</source>
          <target state="translated">En el modo AEAD (cifrado autenticado con datos asociados), descifre &lt;code&gt;CipherText&lt;/code&gt; de acuerdo con el cifrado de bloque de &lt;code&gt;Type&lt;/code&gt; y verifique la autenticidad del texto &lt;code&gt;PlainText&lt;/code&gt; y &lt;code&gt;AAD&lt;/code&gt; (datos autenticados asociados) utilizando &lt;code&gt;CipherTag&lt;/code&gt; . Puede devolver un &lt;code&gt;error&lt;/code&gt; si el descifrado o la validaci&amp;oacute;n fallan</target>
        </trans-unit>
        <trans-unit id="11cacd0985503ba6b7aa7e02c729d4cf5d9ec8c0" translate="yes" xml:space="preserve">
          <source>In AEAD (Authenticated Encryption with Associated Data) mode, encrypt &lt;code&gt;PlainText&lt;/code&gt;according to &lt;code&gt;Type&lt;/code&gt; block cipher and calculate &lt;code&gt;CipherTag&lt;/code&gt; that also authenticates the &lt;code&gt;AAD&lt;/code&gt; (Associated Authenticated Data).</source>
          <target state="translated">En el modo AEAD (Cifrado autenticado con datos asociados), cifre &lt;code&gt;PlainText&lt;/code&gt; seg&amp;uacute;n el cifrado de bloque de &lt;code&gt;Type&lt;/code&gt; y calcule &lt;code&gt;CipherTag&lt;/code&gt; que tambi&amp;eacute;n autentica los &lt;code&gt;AAD&lt;/code&gt; (Datos autenticados asociados).</target>
        </trans-unit>
        <trans-unit id="c038f0a7011f32aa3c2253ea59f81adb573ae04f" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is also possible to have components that are themselves structured types. For example, it is possible to have the following:</source>
          <target state="translated">En el ASN.1 también es posible tener componentes que son en sí mismos tipos estructurados.Por ejemplo,es posible tener lo siguiente:</target>
        </trans-unit>
        <trans-unit id="1fd6892220150bfbf692aea6c817cdbc6b525af4" translate="yes" xml:space="preserve">
          <source>In ASN.1 it is possible to have:</source>
          <target state="translated">En ASN.1 es posible tener:</target>
        </trans-unit>
        <trans-unit id="ac981922e3d2be3099b7dd819f976f8cd431aa5c" translate="yes" xml:space="preserve">
          <source>In ASN.1, &lt;code&gt;BIT STRING&lt;/code&gt; definitions can look as follows:</source>
          <target state="translated">En ASN.1, las definiciones de &lt;code&gt;BIT STRING&lt;/code&gt; pueden tener el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="e4c809e7fa181f22943bb3998e2675cc28fadeb7" translate="yes" xml:space="preserve">
          <source>In Appendix A of the Megaco/H.248 specification (RFC 3525), there are about 30 messages that shows a representative call flow. We have also added a few extra version 1, version 2 and version 3 messages. We have used these messages as basis for our measurements. Our figures have not been weighted in regard to how frequent the different kinds of messages that are sent between the media gateway and its controller.</source>
          <target state="translated">En el Apéndice A de la especificación Megaco/H.248 (RFC 3525),hay unos 30 mensajes que muestran un flujo de llamadas representativo.También hemos añadido algunos mensajes adicionales de la versión 1,la versión 2 y la versión 3.Hemos utilizado estos mensajes como base para nuestras mediciones.Nuestras cifras no han sido ponderadas con respecto a la frecuencia de los diferentes tipos de mensajes que se envían entre la pasarela de medios y su controlador.</target>
        </trans-unit>
        <trans-unit id="a6d6cb54546267c7ab63766eec09cee649711a31" translate="yes" xml:space="preserve">
          <source>In Erlang code it can look as follows:</source>
          <target state="translated">En el código Erlang puede verse de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="aba42f54367f97fea68495b7cac79db5d13869f6" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt; erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt; erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e5807093e6d87fdc7a49890d975be36f4a0da6c" translate="yes" xml:space="preserve">
          <source>In Erlang the BIF &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; is used to convert a term into the external format. To convert binary data encoding to a term, the BIF &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; is used.</source>
          <target state="translated">En Erlang, el &lt;code&gt;erlang:term_to_binary/1,2&lt;/code&gt; BIF : term_to_binary / 1,2 se usa para convertir un t&amp;eacute;rmino al formato externo. Para convertir la codificaci&amp;oacute;n de datos binarios en un t&amp;eacute;rmino, se utiliza el &lt;code&gt;erlang:binary_to_term/1&lt;/code&gt; BIF : binary_to_term / 1 .</target>
        </trans-unit>
        <trans-unit id="cfeed77756208eb4d9dfb0d9a3e58ff900cc5da1" translate="yes" xml:space="preserve">
          <source>In Erlang the following can apply:</source>
          <target state="translated">En Erlang se puede aplicar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="55425998bade0d03c70bf896550329d58b5b495b" translate="yes" xml:space="preserve">
          <source>In Erlang, a Bin is used for constructing binaries and matching binary patterns. A Bin is written with the following syntax:</source>
          <target state="translated">En Erlang,se utiliza un contenedor para construir binarios y hacer coincidir los patrones binarios.Un Bin se escribe con la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="27260c403bb29fda2001d4a6be0835230872a64b" translate="yes" xml:space="preserve">
          <source>In Erlang, strings are lists of integers. A string was until Erlang/OTP R13 defined to be encoded in the ISO Latin-1 (ISO 8859-1) character set, which is, code point by code point, a subrange of the Unicode character set.</source>
          <target state="translated">En Erlang,las cuerdas son listas de números enteros.Una cadena era hasta Erlang/OTP R13 definida para ser codificada en el juego de caracteres ISO Latin-1 (ISO 8859-1),que es,punto de código por punto de código,un subrango del juego de caracteres Unicode.</target>
        </trans-unit>
        <trans-unit id="000d471cb67467678d1ade49d91a91cbdff773ac" translate="yes" xml:space="preserve">
          <source>In Erlang, the &lt;code&gt;SET&lt;/code&gt; type is used exactly as &lt;code&gt;SEQUENCE&lt;/code&gt;. Notice that if BER or DER encoding rules are used, decoding a &lt;code&gt;SET&lt;/code&gt; is slower than decoding a &lt;code&gt;SEQUENCE&lt;/code&gt; because the components must be sorted.</source>
          <target state="translated">En Erlang, el tipo &lt;code&gt;SET&lt;/code&gt; se usa exactamente como &lt;code&gt;SEQUENCE&lt;/code&gt; . Tenga en cuenta que si se utilizan reglas de codificaci&amp;oacute;n BER o DER, decodificar un &lt;code&gt;SET&lt;/code&gt; es m&amp;aacute;s lento que decodificar una &lt;code&gt;SEQUENCE&lt;/code&gt; porque los componentes deben ordenarse.</target>
        </trans-unit>
        <trans-unit id="111866cd1ba49a2b43af4850505bc155722873f8" translate="yes" xml:space="preserve">
          <source>In Erlang, the full UTF-16 range is supported when applicable, like in the &lt;code&gt;unicode&lt;/code&gt; module and in the bit syntax.</source>
          <target state="translated">En Erlang, se admite el rango UTF-16 completo cuando corresponde, como en el m&amp;oacute;dulo &lt;code&gt;unicode&lt;/code&gt; y en la sintaxis de bits.</target>
        </trans-unit>
        <trans-unit id="2a7efb592ded3e962f361d6c4ea93e492befd66f" translate="yes" xml:space="preserve">
          <source>In Erlang, there is no interface to retrieve a mark with &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt;, so only the secondary purpose is relevant to the Erlang programmer.</source>
          <target state="translated">En Erlang, no hay una interfaz para recuperar una marca con &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; , por lo que solo el prop&amp;oacute;sito secundario es relevante para el programador de Erlang.</target>
        </trans-unit>
        <trans-unit id="2c60f9a05486134b501e5953f76c349e506d6f0f" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 17.0, the encoding default for Erlang source files was switched to UTF-8.</source>
          <target state="translated">En Erlang/OTP 17.0,la codificación por defecto de los archivos fuente de Erlang fue cambiada a UTF-8.</target>
        </trans-unit>
        <trans-unit id="6916e39092e66107b55f61baa3016b3f04cf8426" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 20.0, atoms and function can contain Unicode characters. Module names, application names, and node names are still restricted to the ISO Latin-1 range.</source>
          <target state="translated">En Erlang/OTP 20.0,los átomos y la función pueden contener caracteres Unicode.Los nombres de los módulos,los nombres de las aplicaciones y los nombres de los nodos siguen estando restringidos al rango ISO Latin-1.</target>
        </trans-unit>
        <trans-unit id="198d0d1078d6039827840866a4f6899fdbe8d43c" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP 21.0, a new API for logging was added. The old &lt;code&gt;error_logger&lt;/code&gt; module can still be used by legacy code, but log events are redirected to the new Logger API. New code should use the Logger API directly.</source>
          <target state="translated">En Erlang / OTP 21.0, se agreg&amp;oacute; una nueva API para el registro. El antiguo m&amp;oacute;dulo &lt;code&gt;error_logger&lt;/code&gt; todav&amp;iacute;a puede ser utilizado por c&amp;oacute;digo heredado, pero los eventos de registro se redirigen a la nueva API de Logger. El nuevo c&amp;oacute;digo debe usar la API de Logger directamente.</target>
        </trans-unit>
        <trans-unit id="e0d8b8d2cdbb6065786dcebb0086f01cf068b155" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R16B the syntax of Erlang tokens was extended to handle Unicode. The support was limited to string literals and comments. More about the usage of Unicode in Erlang source files can be found in &lt;code&gt;STDLIB's User's Guide&lt;/code&gt;.</source>
          <target state="translated">En Erlang / OTP R16B, la sintaxis de los tokens de Erlang se ampli&amp;oacute; para manejar Unicode. El soporte se limit&amp;oacute; a cadenas literales y comentarios. Puede encontrar m&amp;aacute;s informaci&amp;oacute;n sobre el uso de Unicode en los archivos fuente de Erlang en la &lt;code&gt;STDLIB's User's Guide&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24ca06e1e4890e17adbf7557eee37d1f56256f49" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_Interface application (3.2.1 in the recent example).</source>
          <target state="translated">En Erlang / OTP R5B y versiones posteriores de OTP, los directorios &lt;code&gt;include&lt;/code&gt; y &lt;code&gt;lib&lt;/code&gt; se encuentran en &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; , donde &lt;code&gt;OTPROOT&lt;/code&gt; es el directorio ra&amp;iacute;z de la instalaci&amp;oacute;n de OTP ( &lt;code&gt;/usr/local/otp&lt;/code&gt; en el ejemplo reciente) y &lt;code&gt;VSN&lt;/code&gt; es la versi&amp;oacute;n de la aplicaci&amp;oacute;n Erl_Interface (3.2.1 en el ejemplo reciente).</target>
        </trans-unit>
        <trans-unit id="36bdb9cf8a7d0b24c3ea497881807594aa4ad9c3" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R5B and later versions of OTP, the &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; directories are situated under &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt;, where &lt;code&gt;OTPROOT&lt;/code&gt; is the root directory of the OTP installation (&lt;code&gt;/usr/local/otp&lt;/code&gt; in the recent example) and &lt;code&gt;VSN&lt;/code&gt; is the version of the Erl_interface application (3.2.1 in the recent example).</source>
          <target state="translated">En Erlang / OTP R5B y versiones posteriores de OTP, los directorios &lt;code&gt;include&lt;/code&gt; y &lt;code&gt;lib&lt;/code&gt; se encuentran en &lt;code&gt;OTPROOT/lib/erl_interface-VSN&lt;/code&gt; , donde &lt;code&gt;OTPROOT&lt;/code&gt; es el directorio ra&amp;iacute;z de la instalaci&amp;oacute;n de OTP ( &lt;code&gt;/usr/local/otp&lt;/code&gt; en el ejemplo reciente) y &lt;code&gt;VSN&lt;/code&gt; es la versi&amp;oacute;n de la aplicaci&amp;oacute;n Erl_interface (3.2.1 en el ejemplo reciente).</target>
        </trans-unit>
        <trans-unit id="e2c46173457c64237f426cb5d2c876573b902705" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP R6B, a library similar to Erl_Interface for Java was added called &lt;strong&gt;jinterface&lt;/strong&gt;. It provides a tool for Java programs to communicate with Erlang nodes.</source>
          <target state="translated">En Erlang / OTP R6B, se agreg&amp;oacute; una biblioteca similar a Erl_Interface para Java llamada &lt;strong&gt;jinterface&lt;/strong&gt; . Proporciona una herramienta para que los programas Java se comuniquen con los nodos de Erlang.</target>
        </trans-unit>
        <trans-unit id="1be37b0c5d13632dad76da8a59a995e7c35b67e8" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP SSH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e5f8580820830244cd23f79a16074f3a89cc2a" translate="yes" xml:space="preserve">
          <source>In Erlang/OTP, access to TCP/IP and UDP sockets is provided by the modules &lt;code&gt;gen_tcp&lt;/code&gt; and &lt;code&gt;gen_udp&lt;/code&gt; in Kernel. Both are easy to use and do not require detailed knowledge about the socket concept.</source>
          <target state="translated">En Erlang / OTP, el acceso a los sockets TCP / IP y UDP es proporcionado por los m&amp;oacute;dulos &lt;code&gt;gen_tcp&lt;/code&gt; y &lt;code&gt;gen_udp&lt;/code&gt; en Kernel. Ambos son f&amp;aacute;ciles de usar y no requieren conocimientos detallados sobre el concepto de enchufe.</target>
        </trans-unit>
        <trans-unit id="d098b9b5017423de630d21112a6b6fdc9450e7b2" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and raise exception &lt;code&gt;error:notsup&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a321356801dc3e599cf50b6af4d5dd7265663386" translate="yes" xml:space="preserve">
          <source>In FIPS mode all non-FIPS compliant algorithms are disabled and throw exception &lt;code&gt;not_supported&lt;/code&gt;. Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; that in FIPS mode returns the restricted list of available algorithms.</source>
          <target state="translated">En el modo FIPS, todos los algoritmos que no cumplen con FIPS est&amp;aacute;n deshabilitados y lanzan la excepci&amp;oacute;n &lt;code&gt;not_supported&lt;/code&gt; . Check &lt;code&gt;&lt;a href=&quot;#supports-0&quot;&gt;supports&lt;/a&gt;&lt;/code&gt; que en el modo FIPS devuelve la lista restringida de algoritmos disponibles.</target>
        </trans-unit>
        <trans-unit id="9654a53fa988a8beebddaefffba6dff20182607b" translate="yes" xml:space="preserve">
          <source>In FIPS mode non-validated algorithms are disabled. This may cause some unexpected problems in application relying on crypto.</source>
          <target state="translated">En el modo FIPS los algoritmos no validados están desactivados.Esto puede causar algunos problemas inesperados en la aplicación que se basa en el cripto.</target>
        </trans-unit>
        <trans-unit id="cfd282a1087eca416799317762a7b472853e3b7b" translate="yes" xml:space="preserve">
          <source>In German, the letter &quot;&amp;szlig;&quot; (sharp s) is in lower case, but the uppercase equivalent is &quot;SS&quot;.</source>
          <target state="translated">En alem&amp;aacute;n, la letra &quot;&amp;szlig;&quot; (s sostenida) est&amp;aacute; en min&amp;uacute;sculas, pero el equivalente en may&amp;uacute;sculas es &quot;SS&quot;.</target>
        </trans-unit>
        <trans-unit id="b43a09972d3f89ca539f6f835ed50cfae17cb115" translate="yes" xml:space="preserve">
          <source>In Greek, the letter &quot;&amp;Sigma;&quot; has two different lowercase forms, &quot;&amp;sigmaf;&quot; in word-final position and &quot;&amp;sigma;&quot; elsewhere.</source>
          <target state="translated">En griego, la letra &quot;&amp;Sigma;&quot; tiene dos formas diferentes en min&amp;uacute;sculas, &quot;&amp;sigmaf;&quot; en la posici&amp;oacute;n final de la palabra y &quot;&amp;sigma;&quot; en cualquier otro lugar.</target>
        </trans-unit>
        <trans-unit id="dbc72349c6922ca4db9e6cdf6ae70618450c536a" translate="yes" xml:space="preserve">
          <source>In OTP 19.1 a backwards incompatible change of the return tuple from &lt;code&gt;&lt;a href=&quot;#Module:init-1&quot;&gt;Module:init/1&lt;/a&gt;&lt;/code&gt; was made and the mandatory callback function &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt; Module:callback_mode/0 &lt;/a&gt;&lt;/code&gt; was introduced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e33a7d9a961a4a7fa95fde9918750cd7d701cd7" translate="yes" xml:space="preserve">
          <source>In OTP 20 it is desirable to remove all cipher suites that uses rsa kexchange (removed from default in 21)</source>
          <target state="translated">En el OTP 20 es deseable eliminar todas las suites de cifrado que utilizan rsa kexchange (eliminado por defecto en el 21)</target>
        </trans-unit>
        <trans-unit id="7d0e8cf6bf94176944af04a938b90942b47513e4" translate="yes" xml:space="preserve">
          <source>In OTP 20.0 &lt;code&gt;&lt;a href=&quot;#type-generic_timeout&quot;&gt; generic time-outs &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="10e2f6c474b1b1d220a10a173940715aea514162" translate="yes" xml:space="preserve">
          <source>In OTP 22.1 time-out content &lt;code&gt;&lt;a href=&quot;#type-timeout_update_action&quot;&gt; update &lt;/a&gt;&lt;/code&gt; and explicit time-out &lt;code&gt;&lt;a href=&quot;#type-timeout_cancel_action&quot;&gt; cancel &lt;/a&gt;&lt;/code&gt; were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="622615c8bd1e5f7d554b06396b647aa8c7919009" translate="yes" xml:space="preserve">
          <source>In OTP 22.3 the possibility to change the callback module with actions &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;change_callback_module&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;push_callback_module&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;pop_callback_module&lt;/a&gt;&lt;/code&gt;, was added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dd0ef79035e7eb69969f59887721bb5f12a900" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All pids are now encoded using &lt;code&gt;NEW_PID_EXT&lt;/code&gt;, even external pids received as &lt;code&gt;&lt;a href=&quot;#PID_EXT&quot;&gt;PID_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d163fad14d17015b8103733844b0e3f38ec8db" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All ports are now encoded using &lt;code&gt;NEW_PORT_EXT&lt;/code&gt;, even external ports received as &lt;code&gt;&lt;a href=&quot;#PORT_EXT&quot;&gt;PORT_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a5fb5345ccfcb78e9b4e7ee07de85592dd8a9f4" translate="yes" xml:space="preserve">
          <source>In OTP 23 distribution flag &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_BIG_CREATION&quot;&gt;DFLAG_BIG_CREATION&lt;/a&gt;&lt;/code&gt; became mandatory. All references are now encoded using &lt;code&gt;NEWER_REFERENCE_EXT&lt;/code&gt;, even external references received as &lt;code&gt;&lt;a href=&quot;#NEW_REFERENCE_EXT&quot;&gt;NEW_REFERENCE_EXT&lt;/a&gt;&lt;/code&gt; from older nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3265c64793aa53ad0a1577895b26f55843cba1fb" translate="yes" xml:space="preserve">
          <source>In OTP R16, modules are loaded without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire load operation. The code loading is carried out by a normal Erlang process that is scheduled like all the others. The load operation is completed by making the loaded code visible to all processes in a consistent way with one single atomic instruction. Non-blocking code loading will improve real-time characteristics when modules are loaded/upgraded on a running SMP system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12e0125ea56af5dfd2fd2fd039ae24bfa32ef473" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, &lt;code&gt;uper&lt;/code&gt; or &lt;code&gt;jer&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c8d7cdc42675f7eb3ae5329539c1c0357e28904" translate="yes" xml:space="preserve">
          <source>In OTP R16, the options were simplified. The back end is chosen using one of the options &lt;code&gt;ber&lt;/code&gt;, &lt;code&gt;per&lt;/code&gt;, or &lt;code&gt;uper&lt;/code&gt;. Options &lt;code&gt;optimize&lt;/code&gt;, &lt;code&gt;nif&lt;/code&gt;, and &lt;code&gt;driver&lt;/code&gt; options are no longer necessary (and the ASN.1 compiler generates a warning if they are used). Options &lt;code&gt;ber_bin&lt;/code&gt;, &lt;code&gt;per_bin&lt;/code&gt;, and &lt;code&gt;uper_bin&lt;/code&gt; options still work, but generates a warning.</source>
          <target state="translated">En OTP R16, las opciones se simplificaron. El back-end se elige usando una de las opciones &lt;code&gt;ber&lt;/code&gt; , &lt;code&gt;per&lt;/code&gt; o &lt;code&gt;uper&lt;/code&gt; . Las opciones &lt;code&gt;optimize&lt;/code&gt; , &lt;code&gt;nif&lt;/code&gt; y las opciones del &lt;code&gt;driver&lt;/code&gt; ya no son necesarias (y el compilador ASN.1 genera una advertencia si se utilizan). Opciones &lt;code&gt;ber_bin&lt;/code&gt; opciones ber_bin , &lt;code&gt;per_bin&lt;/code&gt; y &lt;code&gt;uper_bin&lt;/code&gt; a&amp;uacute;n funcionan, pero generan una advertencia.</target>
        </trans-unit>
        <trans-unit id="7beb2f37419ff75d8af6c1507fb66b318ae63c2b" translate="yes" xml:space="preserve">
          <source>In OTP R16, trace breakpoints are set in the code without blocking the VM. Erlang processes may continue executing undisturbed in parallel during the entire operation. The same base technique is used as for code loading. A staging area of breakpoints is prepared and then made active with a single atomic operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d070e27ec63b672cbbc0cd22453c8a0bbd814f44" translate="yes" xml:space="preserve">
          <source>In OTP releases before R9C, the abstract code after some more processing was stored in the Beam file. The first element of the tuple would be either &lt;code&gt;abstract_v1&lt;/code&gt; (in OTP R7B) or &lt;code&gt;abstract_v2&lt;/code&gt; (in OTP R8B).</source>
          <target state="translated">En las versiones de OTP anteriores a R9C, el c&amp;oacute;digo abstracto despu&amp;eacute;s de un poco m&amp;aacute;s de procesamiento se almacenaba en el archivo Beam. El primer elemento de la tupla ser&amp;iacute;a &lt;code&gt;abstract_v1&lt;/code&gt; (en OTP R7B) o &lt;code&gt;abstract_v2&lt;/code&gt; (en OTP R8B).</target>
        </trans-unit>
        <trans-unit id="921af396e8f5461445f280e270dd2b5414708d3b" translate="yes" xml:space="preserve">
          <source>In OTP, &lt;strong&gt;application&lt;/strong&gt; denotes a component implementing some specific functionality, that can be started and stopped as a unit, and that can be reused in other systems. This module interacts with &lt;strong&gt;application controller&lt;/strong&gt;, a process started at every Erlang runtime system. This module contains functions for controlling applications (for example, starting and stopping applications), and functions to access information about applications (for example, configuration parameters).</source>
          <target state="translated">En OTP, &lt;strong&gt;aplicaci&amp;oacute;n&lt;/strong&gt; denota un componente que implementa alguna funcionalidad espec&amp;iacute;fica, que se puede iniciar y detener como una unidad, y que se puede reutilizar en otros sistemas. Este m&amp;oacute;dulo interact&amp;uacute;a con el &lt;strong&gt;controlador de la aplicaci&amp;oacute;n&lt;/strong&gt; , un proceso que se inicia en cada sistema de tiempo de ejecuci&amp;oacute;n de Erlang. Este m&amp;oacute;dulo contiene funciones para controlar aplicaciones (por ejemplo, iniciar y detener aplicaciones) y funciones para acceder a informaci&amp;oacute;n sobre aplicaciones (por ejemplo, par&amp;aacute;metros de configuraci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="eca3632f8a0f156b49e9fa89891e0ee96a189926" translate="yes" xml:space="preserve">
          <source>In OTP, an &lt;strong&gt;event manager&lt;/strong&gt; is a named object to which events can be sent. An &lt;strong&gt;event&lt;/strong&gt; can be, for example, an error, an alarm, or some information that is to be logged.</source>
          <target state="translated">En OTP, un &lt;strong&gt;administrador de eventos&lt;/strong&gt; es un objeto con nombre al que se pueden enviar eventos. Un &lt;strong&gt;evento&lt;/strong&gt; puede ser, por ejemplo, un error, una alarma o alguna informaci&amp;oacute;n que se va a registrar.</target>
        </trans-unit>
        <trans-unit id="457a0e3d6ddd599be8d5102b7c849920a5dc095d" translate="yes" xml:space="preserve">
          <source>In OTP-21 the default primary log level is &lt;code&gt;notice&lt;/code&gt;. The means that many log messages are by default not printed. This includes the progress reports of supervisors. In order to get progress reports you need to raise the primary log level to &lt;code&gt;info&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d287ac5001b044c81427ccf014f3ddfd35b4ee5b" translate="yes" xml:space="preserve">
          <source>In OpenSSH</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a90aedd16eab7e90ca5158413abefdf208107564" translate="yes" xml:space="preserve">
          <source>In PCRE, a subpattern can be named in one of three ways: &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; or &lt;code&gt;(?'name'...)&lt;/code&gt; as in Perl, or &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; as in Python. References to capturing parentheses from other parts of the pattern, such as back references, recursion, and conditions, can be made by name and by number.</source>
          <target state="translated">En PCRE, un subpatr&amp;oacute;n se puede nombrar de una de estas tres formas: &lt;code&gt;(?&amp;lt;name&amp;gt;...)&lt;/code&gt; o &lt;code&gt;(?'name'...)&lt;/code&gt; como en Perl, o &lt;code&gt;(?P&amp;lt;name&amp;gt;...)&lt;/code&gt; como en Pit&amp;oacute;n. Las referencias a la captura de par&amp;eacute;ntesis de otras partes del patr&amp;oacute;n, como referencias anteriores, recursividad y condiciones, se pueden hacer por nombre y por n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="256aeea3c9968f0c93cc31456d90fd25ae389948" translate="yes" xml:space="preserve">
          <source>In PCRE, it matches &quot;bab&quot;. The first capturing parentheses match &quot;b&quot;, then in the second group, when the back reference \1 fails to match &quot;b&quot;, the second alternative matches &quot;a&quot;, and then recurses. In the recursion, \1 does now match &quot;b&quot; and so the whole match succeeds. In Perl, the pattern fails to match because inside the recursive call \1 cannot access the externally set value.</source>
          <target state="translated">En PCRE,coincide con &quot;bab&quot;.El primer paréntesis de captura coincide con &quot;b&quot;,luego en el segundo grupo,cuando la referencia trasera \1 no coincide con &quot;b&quot;,la segunda alternativa coincide con &quot;a&quot;,y luego se repite.En la recursividad,\1 ahora coincide con &quot;b&quot; y por lo tanto todo el partido tiene éxito.En Perl,el patrón no coincide porque dentro de la llamada recursiva \1 no puede acceder al valor establecido externamente.</target>
        </trans-unit>
        <trans-unit id="1bdbe179924ece7a6399c61e126213e1ec2fdb03" translate="yes" xml:space="preserve">
          <source>In Perl, the sequences \l, \L, \u, and \U are recognized by its string handler and used to modify the case of following characters. PCRE does not support these escape sequences.</source>
          <target state="translated">En Perl,las secuencias \ ~ -L,\ ~ -L,\ ~ y \ ~ U son reconocidos por su manejador de la cadena y se utiliza para modificar el caso de los siguientes personajes.PCRE no soporta estas secuencias de escape.</target>
        </trans-unit>
        <trans-unit id="6c9f67deea2c96d4c87a2b517cca3a419aaafb51" translate="yes" xml:space="preserve">
          <source>In R4B and earlier versions of OTP, &lt;code&gt;include&lt;/code&gt; and &lt;code&gt;lib&lt;/code&gt; are situated under &lt;code&gt;OTPROOT/usr&lt;/code&gt;.</source>
          <target state="translated">En R4B y versiones anteriores de OTP, &lt;code&gt;include&lt;/code&gt; y &lt;code&gt;lib&lt;/code&gt; se encuentran en &lt;code&gt;OTPROOT/usr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a3afab8c285c30f15c650612a9e9a18aec7d293" translate="yes" xml:space="preserve">
          <source>In SNMP, the &lt;code&gt;set&lt;/code&gt; operation is atomic. Either all variables which are specified in a &lt;code&gt;set&lt;/code&gt; operation are changed, or none are changed. Therefore, the &lt;code&gt;set&lt;/code&gt; operation is divided into two phases. In the first phase, the new value of each variable is checked against the definition of the variable in the MIB. The following definitions are checked:</source>
          <target state="translated">En SNMP, la operaci&amp;oacute;n del &lt;code&gt;set&lt;/code&gt; es at&amp;oacute;mica. Se cambian todas las variables que se especifican en una operaci&amp;oacute;n de &lt;code&gt;set&lt;/code&gt; o no se cambia ninguna. Por tanto, la operaci&amp;oacute;n del &lt;code&gt;set&lt;/code&gt; se divide en dos fases. En la primera fase, el nuevo valor de cada variable se compara con la definici&amp;oacute;n de la variable en el MIB. Se verifican las siguientes definiciones:</target>
        </trans-unit>
        <trans-unit id="021a1af44ce27aa9f05d1c38410af20ca7b60806" translate="yes" xml:space="preserve">
          <source>In SNMPv1 and SNMPv2c, the community string in the message was used for (at least) three different purposes:</source>
          <target state="translated">En SNMPv1 y SNMPv2c,la cadena de la comunidad en el mensaje se utilizó para (al menos)tres propósitos diferentes:</target>
        </trans-unit>
        <trans-unit id="02cb323587a2984dde2a87bd71f9d85e1a736a34" translate="yes" xml:space="preserve">
          <source>In SNMPv3, each of these usage areas has its own unique mechanism. A context is identified by the name of the SNMP entity, &lt;code&gt;contextEngineID&lt;/code&gt;, and the name of the context, &lt;code&gt;contextName&lt;/code&gt;. Each SNMPv3 message contains values for these two parameters.</source>
          <target state="translated">En SNMPv3, cada una de estas &amp;aacute;reas de uso tiene su propio mecanismo &amp;uacute;nico. Un contexto se identifica por el nombre de la entidad SNMP, &lt;code&gt;contextEngineID&lt;/code&gt; y el nombre del contexto, &lt;code&gt;contextName&lt;/code&gt; . Cada mensaje SNMPv3 contiene valores para estos dos par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="c5e1bb8d75f3351aa564c900b00a6b87a8524ac7" translate="yes" xml:space="preserve">
          <source>In TLS 1.3 the session reuse is replaced by a new session tickets mechanism based on the pre shared key concept. This mechanism also obsoletes the session tickets from RFC5077, not implemented by this application. See also &lt;code&gt;Session Tickets and Session Resumption in TLS-1.3 &lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5895f59f593a11e2ddc456b6ee6229093c87afb4" translate="yes" xml:space="preserve">
          <source>In Turkish, both dotted and dotless &quot;i&quot; exist in lower case and upper case forms.</source>
          <target state="translated">En turco,tanto la &quot;i&quot; punteada como la &quot;i&quot; sin puntear existen en forma de minúsculas y mayúsculas.</target>
        </trans-unit>
        <trans-unit id="878884e2dc7ceb0c8586c874280425307fca0f37" translate="yes" xml:space="preserve">
          <source>In UTF-8 mode, characters with values &amp;gt; 255 (0xffff) can be included in a class as a literal string of data units, or by using the \x{ escaping mechanism.</source>
          <target state="translated">En el modo UTF-8, los caracteres con valores&amp;gt; 255 (0xffff) se pueden incluir en una clase como una cadena literal de unidades de datos o mediante el mecanismo de escape \ x {.</target>
        </trans-unit>
        <trans-unit id="0723db02fb1375caa6de0f6695a31f67e99a568d" translate="yes" xml:space="preserve">
          <source>In Unicode filename mode, filenames given to BIF &lt;code&gt;open_port/2&lt;/code&gt; with option &lt;code&gt;{spawn_executable,...}&lt;/code&gt; are also interpreted as Unicode. So is the parameter list specified in option &lt;code&gt;args&lt;/code&gt; available when using &lt;code&gt;spawn_executable&lt;/code&gt;. The UTF-8 translation of arguments can be avoided using binaries, see section &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En el modo de nombre de archivo Unicode, los nombres de archivo dados a BIF &lt;code&gt;open_port/2&lt;/code&gt; con la opci&amp;oacute;n &lt;code&gt;{spawn_executable,...}&lt;/code&gt; tambi&amp;eacute;n se interpretan como Unicode. As&amp;iacute; es la lista de par&amp;aacute;metros especificados en la opci&amp;oacute;n &lt;code&gt;args&lt;/code&gt; disponible cuando se utiliza &lt;code&gt;spawn_executable&lt;/code&gt; . La traducci&amp;oacute;n UTF-8 de argumentos se puede evitar utilizando binarios, consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#notes-about-raw-filenames&quot;&gt;Notes About Raw Filenames&lt;/a&gt;&lt;/code&gt; archivos sin formato .</target>
        </trans-unit>
        <trans-unit id="19f2c130abf603c133bbd0f5a1747bb0969bbb8c" translate="yes" xml:space="preserve">
          <source>In Unicode mode, quantifiers apply to characters rather than to individual data units. Thus, for example, \x{100}{2} matches two characters, each of which is represented by a 2-byte sequence in a UTF-8 string. Similarly, \X{3} matches three Unicode extended grapheme clusters, each of which can be many data units long (and they can be of different lengths).</source>
          <target state="translated">En el modo Unicode,los cuantificadores se aplican a los caracteres y no a las unidades de datos individuales.Así,por ejemplo,\x{100}{2}coincide con dos caracteres,cada uno de los cuales se representa por una secuencia de 2 bytes en una cadena UTF-8.De manera similar,\X{3}coincide con tres grupos de grafos extendidos Unicode,cada uno de los cuales puede tener muchas unidades de datos (y pueden tener diferentes longitudes).</target>
        </trans-unit>
        <trans-unit id="a58382bb2f1e4ec5560be47f72bd53dd8fd73e07" translate="yes" xml:space="preserve">
          <source>In Unicode mode, two more characters whose code points are &amp;gt; 255 are added: LS (line separator, U+2028) and PS (paragraph separator, U+2029). Unicode character property support is not needed for these characters to be recognized.</source>
          <target state="translated">En el modo Unicode, se agregan dos caracteres m&amp;aacute;s cuyos puntos de c&amp;oacute;digo son&amp;gt; 255: LS (separador de l&amp;iacute;nea, U + 2028) y PS (separador de p&amp;aacute;rrafo, U + 2029). No se necesita el soporte de propiedades de caracteres Unicode para que estos caracteres sean reconocidos.</target>
        </trans-unit>
        <trans-unit id="b9bcf8117b716659d525a533ec0fd6a684678ba1" translate="yes" xml:space="preserve">
          <source>In Windows, all directory separators are forward slashes and the drive letter is in lower case.</source>
          <target state="translated">En Windows,todos los separadores de directorios son barras oblicuas y la letra de la unidad está en minúsculas.</target>
        </trans-unit>
        <trans-unit id="ad12d1518ecf9a65e8a75f2907c07a876915311c" translate="yes" xml:space="preserve">
          <source>In Windows, all functions return filenames with forward slashes only, even if the arguments contain backslashes. To normalize a filename by removing redundant directory separators, use &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En Windows, todas las funciones devuelven nombres de archivo solo con barras inclinadas, incluso si los argumentos contienen barras invertidas. Para normalizar un nombre de archivo eliminando los separadores de directorio redundantes, use &lt;code&gt;&lt;a href=&quot;#join-1&quot;&gt;join/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ef00d820ea8134fdb18c86e4ae50113bc762dcc" translate="yes" xml:space="preserve">
          <source>In a .config file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd45d713b47049d2ce36151c1dc290fc396f5a95" translate="yes" xml:space="preserve">
          <source>In a CTH, behavior can be hooked in after the following functions:</source>
          <target state="translated">En un CTH,el comportamiento puede ser enganchado después de las siguientes funciones:</target>
        </trans-unit>
        <trans-unit id="0a4189b805358c6e1539d1f92304f2c6381b6deb" translate="yes" xml:space="preserve">
          <source>In a CTH, the behavior can be hooked in before the following functions:</source>
          <target state="translated">En un CTH,el comportamiento puede ser enganchado antes de las siguientes funciones:</target>
        </trans-unit>
        <trans-unit id="effbd836389d7d8b463c9fd530b435aef42b51ae" translate="yes" xml:space="preserve">
          <source>In a KDE environment, select &lt;strong&gt;KDE Control Center (Personal Settings)&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional and Accessibility&lt;/strong&gt; &amp;gt; &lt;strong&gt;Keyboard Layout&lt;/strong&gt;.</source>
          <target state="translated">En un entorno KDE, seleccione &lt;strong&gt;Centro de control de KDE (Configuraci&amp;oacute;n personal)&lt;/strong&gt; &amp;gt; &lt;strong&gt;Regional y accesibilidad&lt;/strong&gt; &amp;gt; &lt;strong&gt;Distribuci&amp;oacute;n del teclado&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="5ff429dd35571b630c89a291b69ebf06abbcfc55" translate="yes" xml:space="preserve">
          <source>In a Supervision Tree</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33bc2d5f0d660142d0d63fc0df9ecd908613840a" translate="yes" xml:space="preserve">
          <source>In a UTF mode, PCRE does not allow the \C escape (which matches a single data unit even in a UTF mode) to appear in lookbehind assertions, as it makes it impossible to calculate the length of the lookbehind. The \X and \R escapes, which can match different numbers of data units, are not permitted either.</source>
          <target state="translated">En un modo UTF,PCRE no permite que el escape \C (que coincide con una sola unidad de datos incluso en un modo UTF)aparezca en las afirmaciones de lookbehind,ya que hace imposible calcular la longitud del lookbehind.Los escapes \X y \N \N R,que pueden coincidir con diferentes números de unidades de datos,tampoco están permitidos.</target>
        </trans-unit>
        <trans-unit id="2c87d0f65600acbab54733adb07b3f71b63b4920" translate="yes" xml:space="preserve">
          <source>In a Unix (Bourne) shell, it can look as follows (line breaks are for readability, they are not to be there when typed):</source>
          <target state="translated">En un shell de Unix (Bourne),puede tener el siguiente aspecto (los saltos de línea son para la legibilidad,no deben estar ahí cuando se teclea):</target>
        </trans-unit>
        <trans-unit id="9d1062a9134da719f643aea0a4d7fbb853ab2580" translate="yes" xml:space="preserve">
          <source>In a black-box testing scenario, &lt;code&gt;Common Test&lt;/code&gt;-based test programs connect to the target system(s) through standard O&amp;amp;M and CLI protocols. &lt;code&gt;Common Test&lt;/code&gt; provides implementations of, and wrapper interfaces to, some of these protocols (most of which exist as standalone components and applications in OTP). The wrappers simplify configuration and add verbosity for logging purposes. &lt;code&gt;Common Test&lt;/code&gt; is continously extended with useful support modules. However, notice that it is a straightforward task to use any Erlang/OTP component for testing purposes with &lt;code&gt;Common Test&lt;/code&gt;, without needing a &lt;code&gt;Common Test&lt;/code&gt; wrapper for it. It is as simple as calling Erlang functions. A number of target-independent interfaces are supported in &lt;code&gt;Common Test&lt;/code&gt;, such as Generic Telnet and FTP. These can be specialized or used directly for controlling instruments, traffic load generators, and so on.</source>
          <target state="translated">En un escenario de prueba de caja negra, los programas de prueba basados ​​en &lt;code&gt;Common Test&lt;/code&gt; conectan a los sistemas de destino a trav&amp;eacute;s de los protocolos est&amp;aacute;ndar de O&amp;amp;M y CLI. &lt;code&gt;Common Test&lt;/code&gt; proporciona implementaciones e interfaces contenedoras para algunos de estos protocolos (la mayor&amp;iacute;a de los cuales existen como componentes y aplicaciones independientes en OTP). Los contenedores simplifican la configuraci&amp;oacute;n y agregan verbosidad para fines de registro. &lt;code&gt;Common Test&lt;/code&gt; se ampl&amp;iacute;a continuamente con &amp;uacute;tiles m&amp;oacute;dulos de soporte. Sin embargo, tenga en cuenta que es una tarea sencilla utilizar cualquier componente de Erlang / OTP con fines de prueba con &lt;code&gt;Common Test&lt;/code&gt; , sin necesidad de un contenedor de &lt;code&gt;Common Test&lt;/code&gt; para ello. Es tan simple como llamar a funciones de Erlang. Se admiten varias interfaces independientes del objetivo en &lt;code&gt;Common Test&lt;/code&gt; , como Telnet gen&amp;eacute;rico y FTP. Estos pueden especializarse o usarse directamente para controlar instrumentos, generadores de carga de tr&amp;aacute;fico, etc.</target>
        </trans-unit>
        <trans-unit id="c1500508d272e3e1ef6dd2792fe28503800aeebb" translate="yes" xml:space="preserve">
          <source>In a callback module:</source>
          <target state="translated">En un módulo de devolución de llamada:</target>
        </trans-unit>
        <trans-unit id="87ab655f4b96d81d49f137e06e1185ae6b220c3d" translate="yes" xml:space="preserve">
          <source>In a debug-compiled emulator, &lt;code&gt;ASSERT(VALID_INSTR(next_pf));&lt;/code&gt; makes sure that &lt;code&gt;next_pf&lt;/code&gt; is a valid instruction (that is, that it points within the &lt;code&gt;process_main()&lt;/code&gt; function in &lt;code&gt;beam_emu.c&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b8b640abb829ff4cbfb271a5e40f88ec8ec137" translate="yes" xml:space="preserve">
          <source>In a distributed Erlang system, it is sometimes useful to connect to a node without also connecting to all other nodes. An example is some kind of O&amp;amp;M functionality used to inspect the status of a system, without disturbing it. For this purpose, a &lt;strong&gt;hidden node&lt;/strong&gt; can be used.</source>
          <target state="translated">En un sistema Erlang distribuido, a veces es &amp;uacute;til conectarse a un nodo sin conectarse tambi&amp;eacute;n a todos los dem&amp;aacute;s nodos. Un ejemplo es alg&amp;uacute;n tipo de funcionalidad de O&amp;amp;M que se utiliza para inspeccionar el estado de un sistema, sin perturbarlo. Para ello, se puede utilizar un &lt;strong&gt;nodo oculto&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="4aec9cfbd2b5a5b825d96878372130aac2263b76" translate="yes" xml:space="preserve">
          <source>In a distributed system with several Erlang nodes, it can be necessary to control applications in a distributed manner. If the node, where a certain application is running, goes down, the application is to be restarted at another node.</source>
          <target state="translated">En un sistema distribuido con varios nodos Erlang,puede ser necesario controlar las aplicaciones de manera distribuida.Si el nodo en el que se está ejecutando una determinada aplicación se cae,la aplicación debe reiniciarse en otro nodo.</target>
        </trans-unit>
        <trans-unit id="23225511bfc3875384d2792bd043f1c701a2c0ca" translate="yes" xml:space="preserve">
          <source>In a future Erlang/OTP release, it might be implemented a way to (optionally) preserve sharing.</source>
          <target state="translated">En un futuro lanzamiento de Erlang/OTP,podría implementarse una forma de (opcionalmente)preservar el intercambio.</target>
        </trans-unit>
        <trans-unit id="4a6305081dfcb5f7cad2ca28aa531435457c8383" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Dir&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">En una versi&amp;oacute;n futura, un tipo incorrecto de argumento &lt;code&gt;Dir&lt;/code&gt; probablemente generar&amp;aacute; una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1a6542a84ddb6812f9a19d1cc7c1b8efff7c3a54" translate="yes" xml:space="preserve">
          <source>In a future release, a bad type for argument &lt;code&gt;Filename&lt;/code&gt; will probably generate an exception.</source>
          <target state="translated">En una versi&amp;oacute;n futura, un tipo incorrecto de argumento &lt;code&gt;Filename&lt;/code&gt; probablemente generar&amp;aacute; una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f07b31928724d837c06543b0d4ac70cbfb01f2cb" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt; io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f9e2eab173886fa1c16faadaf18c5a216f901d1c" translate="yes" xml:space="preserve">
          <source>In a future release, this function may return more values and ranges. To avoid compatibility problems, it is recommended to use function &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En una versi&amp;oacute;n futura, esta funci&amp;oacute;n puede devolver m&amp;aacute;s valores y rangos. Para evitar problemas de compatibilidad, se recomienda utilizar la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;io_lib#printable_list-1&quot;&gt;io_lib:printable_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab65a5239391014eb913ce30baf2efae7d72ed7b" translate="yes" xml:space="preserve">
          <source>In a larger pattern, keeping track of parenthesis numbers can be tricky. This is made easier by the use of relative references. Instead of (?1) in the pattern above, you can write (?-2) to refer to the second most recently opened parentheses preceding the recursion. That is, a negative number counts capturing parentheses leftwards from the point at which it is encountered.</source>
          <target state="translated">En un patrón más grande,llevar la cuenta de los números entre paréntesis puede ser difícil.Esto se facilita con el uso de referencias relativas.En lugar de (?1)en el patrón anterior,se puede escribir (?-2)para referirse al segundo paréntesis más recientemente abierto que precede a la recursividad.Es decir,un número negativo cuenta capturando los paréntesis hacia la izquierda desde el punto en que se encuentra.</target>
        </trans-unit>
        <trans-unit id="521f7cdd5ab3fc62df36d3dfb682c92be20244f3" translate="yes" xml:space="preserve">
          <source>In a larger system with a user (in this case an MGC) distributed over several Erlang nodes, it looks a little bit different. Here the encoding is performed on the originating Erlang node (1) and the binary is forwarded to the node (2) with the physical network interface. When the potential message reply is received on the interface on node (2), it is decoded there and then different actions will be taken for each transaction in the message. The transaction reply will be forwarded in its decoded form to the originating node (1) while the other types of transactions will be handled locally on node (2).</source>
          <target state="translated">En un sistema más grande con un usuario (en este caso un MGC)distribuido en varios nodos de Erlang,se ve un poco diferente.Aquí la codificación se realiza en el nodo Erlang de origen (1)y el binario se reenvía al nodo (2)con la interfaz de la red física.Cuando se recibe la posible respuesta del mensaje en la interfaz del nodo (2),se descodifica allí y luego se realizan diferentes acciones para cada transacción del mensaje.La respuesta de la transacción se remitirá en su forma descodificada al nodo de origen (1),mientras que los demás tipos de transacciones se tramitarán localmente en el nodo (2).</target>
        </trans-unit>
        <trans-unit id="976ebf70f5a3964ad2dc1b919f7c060f1cb37e38" translate="yes" xml:space="preserve">
          <source>In a manner similar to the function &lt;code&gt;mnesia:index_read/3&lt;/code&gt;, any index information can be used when trying to match records. This function takes a pattern that obeys the same rules as the function &lt;code&gt;mnesia:match_object/3&lt;/code&gt;, except that this function requires the following conditions:</source>
          <target state="translated">De manera similar a la funci&amp;oacute;n &lt;code&gt;mnesia:index_read/3&lt;/code&gt; , se puede usar cualquier informaci&amp;oacute;n de &amp;iacute;ndice al intentar hacer coincidir registros. Esta funci&amp;oacute;n toma un patr&amp;oacute;n que obedece las mismas reglas que la funci&amp;oacute;n &lt;code&gt;mnesia:match_object/3&lt;/code&gt; , excepto que esta funci&amp;oacute;n requiere las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="4c4bc3edae976085e9a0d189975eeda0ad921051" translate="yes" xml:space="preserve">
          <source>In a monotonically increasing sequence of values, all values that have a predecessor are either larger than or equal to its predecessor.</source>
          <target state="translated">En una secuencia de valores monótonamente creciente,todos los valores que tienen un predecesor son mayores o iguales que su predecesor.</target>
        </trans-unit>
        <trans-unit id="1ab70776fb35c924c17c1cd7488da7d1d0d285f9" translate="yes" xml:space="preserve">
          <source>In a new version of the release, the application &lt;code&gt;ch_app&lt;/code&gt; is to be included in &lt;code&gt;prim_app&lt;/code&gt;. That is, its topmost supervisor &lt;code&gt;ch_sup&lt;/code&gt; is to be started as a child process to &lt;code&gt;prim_sup&lt;/code&gt;.</source>
          <target state="translated">En una nueva versi&amp;oacute;n del lanzamiento, la aplicaci&amp;oacute;n &lt;code&gt;ch_app&lt;/code&gt; se incluir&amp;aacute; en &lt;code&gt;prim_app&lt;/code&gt; . Es decir, su supervisor superior &lt;code&gt;ch_sup&lt;/code&gt; debe iniciarse como un proceso hijo de &lt;code&gt;prim_sup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="274b316a1d6a226ddaa81a91a28524b871d26fde" translate="yes" xml:space="preserve">
          <source>In a pattern matching, a left-hand side &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; is matched against a right-hand side &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt;. If the matching succeeds, any unbound variables in the pattern become bound. If the matching fails, a run-time error occurs.</source>
          <target state="translated">En una coincidencia de patrones, un lado de la mano izquierda &lt;code&gt;&lt;a href=&quot;expressions#pattern&quot;&gt;pattern&lt;/a&gt;&lt;/code&gt; se compara con un lado derecho &lt;code&gt;&lt;a href=&quot;expressions#term&quot;&gt;term&lt;/a&gt;&lt;/code&gt; . Si la coincidencia tiene &amp;eacute;xito, todas las variables no vinculadas del patr&amp;oacute;n se vincular&amp;aacute;n. Si la coincidencia falla, se produce un error en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a946839a1f3091d7ba3fdcd58b538b74992aa355" translate="yes" xml:space="preserve">
          <source>In a strictly monotonically increasing sequence of values, all values that have a predecessor are larger than its predecessor.</source>
          <target state="translated">En una secuencia de valores estrictamente monótona,todos los valores que tienen un predecesor son más grandes que su predecesor.</target>
        </trans-unit>
        <trans-unit id="31ff33f4c7a5907d10bf958b213e55ba1dc343c7" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers such as error loggers.</source>
          <target state="translated">En un árbol de supervisión,muchos de los procesos tienen estructuras similares,siguen patrones similares.Por ejemplo,los supervisores tienen una estructura similar.La única diferencia entre ellos es qué procesos infantiles supervisan.Muchos de los trabajadores son servidores en una relación servidor-cliente,máquinas de estado finito o manejadores de eventos como los registradores de errores.</target>
        </trans-unit>
        <trans-unit id="3efaceff063003bf44950693b3f902b21784c28f" translate="yes" xml:space="preserve">
          <source>In a supervision tree, many of the processes have similar structures, they follow similar patterns. For example, the supervisors are similar in structure. The only difference between them is which child processes they supervise. Many of the workers are servers in a server-client relation, finite-state machines, or event handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd210cc6dd528624657860bc47c1121fbe29a1ff" translate="yes" xml:space="preserve">
          <source>In a system implemented according to the OTP design principles, all processes, except system processes and special processes, reside in one of the behaviours &lt;code&gt;supervisor&lt;/code&gt;, &lt;code&gt;gen_server&lt;/code&gt;, &lt;code&gt;gen_fsm&lt;/code&gt;, &lt;code&gt;gen_statem&lt;/code&gt; or &lt;code&gt;gen_event&lt;/code&gt;. These belong to the STDLIB application and upgrading/downgrading normally requires an emulator restart.</source>
          <target state="translated">En un sistema implementado de acuerdo con los principios de dise&amp;ntilde;o de OTP, todos los procesos, excepto los procesos del sistema y los procesos especiales, residen en uno de los comportamientos &lt;code&gt;supervisor&lt;/code&gt; , &lt;code&gt;gen_server&lt;/code&gt; , &lt;code&gt;gen_fsm&lt;/code&gt; , &lt;code&gt;gen_statem&lt;/code&gt; o &lt;code&gt;gen_event&lt;/code&gt; . Estos pertenecen a la aplicaci&amp;oacute;n STDLIB y la actualizaci&amp;oacute;n / degradaci&amp;oacute;n normalmente requiere un reinicio del emulador.</target>
        </trans-unit>
        <trans-unit id="554c457d1fb565b9a6393985044814faed4608a5" translate="yes" xml:space="preserve">
          <source>In a system of &lt;code&gt;Mnesia&lt;/code&gt; nodes, every node is aware of the current location of all tables. In this example, data is replicated on both nodes and functions that manipulate the data in the tables can be executed on either of the two nodes. Code that manipulate &lt;code&gt;Mnesia&lt;/code&gt; data behaves identically regardless of where the data resides.</source>
          <target state="translated">En un sistema de nodos &lt;code&gt;Mnesia&lt;/code&gt; , todos los nodos conocen la ubicaci&amp;oacute;n actual de todas las tablas. En este ejemplo, los datos se replican en ambos nodos y las funciones que manipulan los datos en las tablas se pueden ejecutar en cualquiera de los dos nodos. El c&amp;oacute;digo que manipula los datos de &lt;code&gt;Mnesia&lt;/code&gt; se comporta de manera id&amp;eacute;ntica independientemente de d&amp;oacute;nde residan los datos.</target>
        </trans-unit>
        <trans-unit id="8b48851f5568a382a621cc92c48317c0fa23d6e3" translate="yes" xml:space="preserve">
          <source>In a system structured according to the OTP design principles, any process would be a child process belonging to a supervisor, see &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; in Changing a Supervisor.</source>
          <target state="translated">En un sistema estructurado de acuerdo con los principios de dise&amp;ntilde;o de la OTP, cualquier proceso ser&amp;iacute;a un proceso secundario que pertenece a un supervisor; consulte &lt;code&gt;&lt;a href=&quot;#sup_add&quot;&gt;Adding and Deleting Child Processes&lt;/a&gt;&lt;/code&gt; secundarios en Cambio de supervisor.</target>
        </trans-unit>
        <trans-unit id="44ba56c896fa716f74253d95bcea0e44a23d8f58" translate="yes" xml:space="preserve">
          <source>In a system that use comparatively few processes, performance &lt;strong&gt;might&lt;/strong&gt; be improved by increasing the minimum heap size using either the &lt;code&gt;+h&lt;/code&gt; option for &lt;code&gt;erl&lt;/code&gt; or on a process-per-process basis using the &lt;code&gt;min_heap_size&lt;/code&gt; option for &lt;code&gt;spawn_opt/4&lt;/code&gt;.</source>
          <target state="translated">En un sistema que utilice comparativamente pocos procesos, el rendimiento &lt;strong&gt;podr&amp;iacute;a&lt;/strong&gt; mejorarse aumentando el tama&amp;ntilde;o m&amp;iacute;nimo de pila utilizando el &lt;code&gt;+h&lt;/code&gt; opci&amp;oacute;n para &lt;code&gt;erl&lt;/code&gt; o sobre una base proceso-per-proceso usando el &lt;code&gt;min_heap_size&lt;/code&gt; opci&amp;oacute;n para &lt;code&gt;spawn_opt/4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f12319f42fd8dda78673d0ca45eab01cc78900" translate="yes" xml:space="preserve">
          <source>In a system with TCP-based distribution, this data is kept in the &lt;strong&gt;Erlang port mapper daemon&lt;/strong&gt; (&lt;code&gt;epmd&lt;/code&gt;), which is contacted when a distributed node starts. The lock file and a convention for the UDS listen socket's name remove the need for &lt;code&gt;epmd&lt;/code&gt; when using this distribution module. UDS is always restricted to one host, why avoiding a port mapper is easy.</source>
          <target state="translated">En un sistema con distribuci&amp;oacute;n basada en TCP, estos datos se guardan en el &lt;strong&gt;demonio del mapeador de puertos de Erlang&lt;/strong&gt; ( &lt;code&gt;epmd&lt;/code&gt; ), que se contacta cuando se inicia un nodo distribuido. El archivo de bloqueo y una convenci&amp;oacute;n para el nombre del socket de escucha de UDS eliminan la necesidad de &lt;code&gt;epmd&lt;/code&gt; cuando se utiliza este m&amp;oacute;dulo de distribuci&amp;oacute;n. UDS siempre est&amp;aacute; restringido a un host, por lo que evitar un mapeador de puertos es f&amp;aacute;cil.</target>
        </trans-unit>
        <trans-unit id="5ccaddcd0c823bd477d387b9058aa0fc21906850" translate="yes" xml:space="preserve">
          <source>In a table monitored by SNMP, all elements must be integers, strings, or lists of integers.</source>
          <target state="translated">En una tabla supervisada por el SNMP,todos los elementos deben ser enteros,cadenas o listas de enteros.</target>
        </trans-unit>
        <trans-unit id="f62f7aaa3c520340c959fbaf0d8e529944b88886" translate="yes" xml:space="preserve">
          <source>In a target system, the release upgrade file is to be located in directory &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;.</source>
          <target state="translated">En un sistema de destino, el archivo de actualizaci&amp;oacute;n de la versi&amp;oacute;n se ubicar&amp;aacute; en el directorio &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ac283a89487dcb253786b8bd6bb529084d29ffc" translate="yes" xml:space="preserve">
          <source>In a test suite, one must &lt;strong&gt;require&lt;/strong&gt; that a configuration variable (&lt;code&gt;CfgVarName&lt;/code&gt; in the previous definition) exists before attempting to read the associated value in a test case or configuration function.</source>
          <target state="translated">En un conjunto de pruebas, se debe &lt;strong&gt;requerir&lt;/strong&gt; que &lt;code&gt;CfgVarName&lt;/code&gt; una variable de configuraci&amp;oacute;n ( CfgVarName en la definici&amp;oacute;n anterior) antes de intentar leer el valor asociado en un caso de prueba o funci&amp;oacute;n de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4fb9fe0e283f20ff6583d865477e2f5797757ef1" translate="yes" xml:space="preserve">
          <source>In a tuple &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt;, if &lt;code&gt;CSSFile&lt;/code&gt; is specified with a path, for example, &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt;, this full name is used to locate the file. However, if only the file name is specified, for example, &lt;code&gt;categories.css&lt;/code&gt;, the CSS file is assumed to be located in the data directory, &lt;code&gt;data_dir&lt;/code&gt;, of the suite. The latter use is recommended, as it is portable compared to hard coding path names in the suite.</source>
          <target state="translated">En una tupla &lt;code&gt;{stylesheet,CSSFile}&lt;/code&gt; , si &lt;code&gt;CSSFile&lt;/code&gt; se especifica con una ruta, por ejemplo, &lt;code&gt;&quot;$TEST/styles/categories.css&quot;&lt;/code&gt; , este nombre completo se usa para ubicar el archivo. Sin embargo, si solo se especifica el nombre del archivo, por ejemplo, &lt;code&gt;categories.css&lt;/code&gt; , se asume que el archivo CSS est&amp;aacute; ubicado en el directorio de datos, &lt;code&gt;data_dir&lt;/code&gt; , de la suite. Se recomienda el &amp;uacute;ltimo uso, ya que es port&amp;aacute;til en comparaci&amp;oacute;n con los nombres de ruta de codificaci&amp;oacute;n r&amp;iacute;gida en la suite.</target>
        </trans-unit>
        <trans-unit id="1286250e203085fab759937a2009fa429066e481" translate="yes" xml:space="preserve">
          <source>In absence of spawn operation failures, atomically sets up a link between the calling process and the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#link-1&quot;&gt;link(Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea7833417b997c143c87f40d58a519fc4541a0bf" translate="yes" xml:space="preserve">
          <source>In addition to specifying a type letter, the actual value for the type can be specified. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c5578dc50a0864bd8d9d5138f6fed8f654dd2af" translate="yes" xml:space="preserve">
          <source>In addition to the &lt;code&gt;{Item,Value}&lt;/code&gt; pairs defined for &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt;, the following items are allowed:</source>
          <target state="translated">Adem&amp;aacute;s de los pares &lt;code&gt;{Item,Value}&lt;/code&gt; definidos para &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; , se permiten los siguientes elementos:</target>
        </trans-unit>
        <trans-unit id="1a79ac5033930298cd0d6e70aec5390fc42e348e" translate="yes" xml:space="preserve">
          <source>In addition to the Call Graph there is a graph called the  &lt;strong id=&quot;inter_call_graph&quot;&gt;Inter Call Graph&lt;/strong&gt;. This is a graph of calls (From, To) such that there is a chain of calls from From to To in the Call Graph, and every From and To is an exported function or an unused local function. The vertices are the same as for the Call Graph.</source>
          <target state="translated">Adem&amp;aacute;s del Gr&amp;aacute;fico de llamadas, hay un gr&amp;aacute;fico llamado &lt;strong id=&quot;inter_call_graph&quot;&gt;Gr&amp;aacute;fico entre llamadas&lt;/strong&gt; . Este es un gr&amp;aacute;fico de llamadas (De, A) de modo que hay una cadena de llamadas de Desde a A en el Gr&amp;aacute;fico de llamadas, y cada Desde y A es una funci&amp;oacute;n exportada o una funci&amp;oacute;n local no utilizada. Los v&amp;eacute;rtices son los mismos que para Call Graph.</target>
        </trans-unit>
        <trans-unit id="5ea131aa8ce39e0fad64d7f37053c449509534e3" translate="yes" xml:space="preserve">
          <source>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</source>
          <target state="translated">Adem&amp;aacute;s de los algoritmos negociados por el conjunto de cifrado utilizado para el intercambio de claves, el cifrado de carga &amp;uacute;til, la autenticaci&amp;oacute;n de mensajes y el c&amp;aacute;lculo pseudoaleatorio, se puede utilizar la extensi&amp;oacute;n del algoritmo de firma TLS &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; , de TLS 1.2, para negociar cu&amp;aacute;l algoritmo de firma para usar durante el protocolo de enlace TLS. Si no se admiten versiones de TLS inferiores a 1.2, el cliente enviar&amp;aacute; una extensi&amp;oacute;n de algoritmo de firma TLS con los algoritmos especificados por esta opci&amp;oacute;n. Predeterminado a</target>
        </trans-unit>
        <trans-unit id="08f56fb7610394014283a4c142a08a63d84be1ba" translate="yes" xml:space="preserve">
          <source>In addition to the algorithms negotiated by the cipher suite used for key exchange, payload encryption, message authentication and pseudo random calculation, the TLS signature algorithm extension &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc5246.txt&quot;&gt;Section 7.4.1.4.1 in RFC 5246&lt;/a&gt;&lt;/code&gt; may be used, from TLS 1.2, to negotiate which signature algorithm to use during the TLS handshake. If no lower TLS versions than 1.2 are supported, the client will send a TLS signature algorithm extension with the algorithms specified by this option. Defaults to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8211e020ecaee607aa2a72d41a52382183c4a8b5" translate="yes" xml:space="preserve">
          <source>In addition to the collection algorithm described above, the Erlang garbage collector also provides generational garbage collection. An additional heap, called the old heap, is used where the long lived data is stored. The original heap is called the young heap, or sometimes the allocation heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfba226beccd4a1427fc9d1c6106071bf62f4d15" translate="yes" xml:space="preserve">
          <source>In addition to the documentation here Erlang is described in several recent books like:</source>
          <target state="translated">Además de la documentación aquí Erlang se describe en varios libros recientes como:</target>
        </trans-unit>
        <trans-unit id="88d44d718b6e7d7989a95592c66be31f11e98097" translate="yes" xml:space="preserve">
          <source>In addition to the earlier:</source>
          <target state="translated">Además de lo anterior:</target>
        </trans-unit>
        <trans-unit id="890bb829697d00b41e1b4a5c52b5061881f7d784" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/2&lt;/code&gt; and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="translated">Adem&amp;aacute;s de la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada obligatoria &lt;code&gt;log/2&lt;/code&gt; , un m&amp;oacute;dulo manejador puede exportar las funciones de devoluci&amp;oacute;n de llamada opcionales &lt;code&gt;adding_handler/1&lt;/code&gt; , &lt;code&gt;changing_config/2&lt;/code&gt; y &lt;code&gt;removing_handler/1&lt;/code&gt; . Consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; en la p&amp;aacute;gina del manual del registrador (3) para obtener m&amp;aacute;s informaci&amp;oacute;n sobre estas funciones.</target>
        </trans-unit>
        <trans-unit id="4485e35d13b31a5f17e0ec8540bc97bc5f63738e" translate="yes" xml:space="preserve">
          <source>In addition to the mandatory callback function &lt;code&gt;log/2&lt;/code&gt;, a handler module can export the optional callback functions &lt;code&gt;adding_handler/1&lt;/code&gt;, &lt;code&gt;changing_config/3&lt;/code&gt;, &lt;code&gt;filter_config/1&lt;/code&gt;, and &lt;code&gt;removing_handler/1&lt;/code&gt;. See section &lt;code&gt;&lt;a href=&quot;logger#handler_callback_functions&quot;&gt;Handler Callback Functions&lt;/a&gt;&lt;/code&gt; in the logger(3) manual page for more information about these function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45082fc3acc3b9bc0e8feada04ef6474816b9ee7" translate="yes" xml:space="preserve">
          <source>In addition to the ordinary functions for receiving and sending files (see &lt;code&gt;recv/2&lt;/code&gt;, &lt;code&gt;recv/3&lt;/code&gt;, &lt;code&gt;send/2&lt;/code&gt;, and &lt;code&gt;send/3&lt;/code&gt;) there are functions for receiving remote files as binaries (see &lt;code&gt;recv_bin/2&lt;/code&gt;) and for sending binaries to be stored as remote files (see &lt;code&gt;send_bin/3&lt;/code&gt;).</source>
          <target state="translated">Adem&amp;aacute;s de las funciones ordinarias para recibir y enviar archivos (consulte &lt;code&gt;recv/2&lt;/code&gt; , &lt;code&gt;recv/3&lt;/code&gt; , &lt;code&gt;send/2&lt;/code&gt; y &lt;code&gt;send/3&lt;/code&gt; ), existen funciones para recibir archivos remotos como binarios (consulte &lt;code&gt;recv_bin/2&lt;/code&gt; ) y para enviar binarios a almacenarse como archivos remotos (consulte &lt;code&gt;send_bin/3&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="af29f18311535fbae0f8e4ae58bbff8300a8115f" translate="yes" xml:space="preserve">
          <source>In addition to the representations described earlier, the following deprecated representations are available if the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de las representaciones descritas anteriormente, las siguientes representaciones obsoletas est&amp;aacute;n disponibles si la especificaci&amp;oacute;n se ha compilado con la opci&amp;oacute;n &lt;code&gt;legacy_erlang_types&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86f6f7e492ba3b7949f4b38c0a7d47daec6054a6" translate="yes" xml:space="preserve">
          <source>In addition to the representations of forms, the list that represents a module declaration (as returned by functions in &lt;code&gt;epp(3)&lt;/code&gt; and &lt;code&gt;erl_parse(3)&lt;/code&gt;) can contain the following:</source>
          <target state="translated">Adem&amp;aacute;s de las representaciones de formularios, la lista que representa una declaraci&amp;oacute;n de m&amp;oacute;dulo (como la devuelven las funciones en &lt;code&gt;epp(3)&lt;/code&gt; y &lt;code&gt;erl_parse(3)&lt;/code&gt; ) puede contener lo siguiente:</target>
        </trans-unit>
        <trans-unit id="cd3b0823be609b58f269a346f9f2725dc8f84272" translate="yes" xml:space="preserve">
          <source>In addition to the signature_algorithms extension from TLS 1.2, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc8446.txt#section-4.2.3&quot;&gt;TLS 1.3 (RFC 5246 Section 4.2.3)&lt;/a&gt;&lt;/code&gt;adds the signature_algorithms_cert extension which enables having special requirements on the signatures used in the certificates that differs from the requirements on digital signatures as a whole. If this is not required this extension is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7229ff36909ba7ebefb7b021baf2857202005046" translate="yes" xml:space="preserve">
          <source>In addition to the signature_algorithms extension from TLS 1.2, &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc8446.txt#section-4.2.3&quot;&gt;TLS 1.3 (RFC 5246 Section 4.2.3)&lt;/a&gt;&lt;/code&gt;adds the signature_algorithms_cert extension which enables having special requirements on the signatures used in the certificates that differs from the requirements on digital signatures as a whole. If this is not required this extension is not needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ad8f4e74819a6f7578284e9cf32df82a24e4ca4" translate="yes" xml:space="preserve">
          <source>In addition to the standard Unicode properties described earlier, PCRE supports four more that make it possible to convert traditional escape sequences, such as \w and \s to use Unicode properties. PCRE uses these non-standard, non-Perl properties internally when the &lt;code&gt;ucp&lt;/code&gt; option is passed. However, they can also be used explicitly. The properties are as follows:</source>
          <target state="translated">Adem&amp;aacute;s de las propiedades est&amp;aacute;ndar de Unicode descritas anteriormente, PCRE admite cuatro m&amp;aacute;s que hacen posible convertir secuencias de escape tradicionales, como \ w y \ s, para usar propiedades Unicode. PCRE utiliza estas propiedades no est&amp;aacute;ndar y que no son de Perl internamente cuando se pasa la opci&amp;oacute;n &lt;code&gt;ucp&lt;/code&gt; . Sin embargo, tambi&amp;eacute;n se pueden utilizar expl&amp;iacute;citamente. Las propiedades son las siguientes:</target>
        </trans-unit>
        <trans-unit id="698d80c93fc7667e3d673153ab193877506b308a" translate="yes" xml:space="preserve">
          <source>In addition to the static supervision tree, dynamic child processes can be added to an existing supervisor with the following call:</source>
          <target state="translated">Además del árbol de supervisión estática,se pueden añadir procesos infantiles dinámicos a un supervisor existente con la siguiente llamada:</target>
        </trans-unit>
        <trans-unit id="58454c75737b607a068b4e77b1a88fd258a15b57" translate="yes" xml:space="preserve">
          <source>In addition to the trace log file(s), a file with extension &lt;code&gt;.ti&lt;/code&gt; is created when Trace Tool Builder is started. This is the trace information file. It is a binary file, which contains the process information, trace flags used, the name of the node to which it belongs, and all information written with function &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;.ti&lt;/code&gt; files are always fetched with other logs when the trace is stopped.</source>
          <target state="translated">Adem&amp;aacute;s de los archivos de registro de seguimiento, se crea un archivo con extensi&amp;oacute;n &lt;code&gt;.ti&lt;/code&gt; cuando se inicia Trace Tool Builder. Este es el archivo de informaci&amp;oacute;n de seguimiento. Es un archivo binario, que contiene la informaci&amp;oacute;n del proceso, las banderas de seguimiento utilizadas, el nombre del nodo al que pertenece y toda la informaci&amp;oacute;n escrita con la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ttb#write_trace_info-2&quot;&gt;ttb:write_trace_info/2&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;.ti&lt;/code&gt; archivos .ti siempre se recuperan con otros registros cuando se detiene el rastreo.</target>
        </trans-unit>
        <trans-unit id="ead83cfe423b6f87966ff81fd05657fc8c719fd4" translate="yes" xml:space="preserve">
          <source>In addition to these options, &lt;strong&gt;raw&lt;/strong&gt; option specifications can be used. The raw options are specified as a tuple of arity four, beginning with tag &lt;code&gt;raw&lt;/code&gt;, followed by the protocol level, the option number, and the option value specified as a binary. This corresponds to the second, third, and fourth arguments to the &lt;code&gt;setsockopt&lt;/code&gt; call in the C socket API. The option value must be coded in the native endianess of the platform and, if a structure is required, must follow the structure alignment conventions on the specific platform.</source>
          <target state="translated">Adem&amp;aacute;s de estas opciones, se pueden utilizar especificaciones de opciones sin &lt;strong&gt;procesar&lt;/strong&gt; . Las opciones sin procesar se especifican como una tupla de aridad cuatro, comenzando con la etiqueta sin &lt;code&gt;raw&lt;/code&gt; , seguida del nivel de protocolo, el n&amp;uacute;mero de opci&amp;oacute;n y el valor de la opci&amp;oacute;n especificado como binario. Esto corresponde al segundo, tercer y cuarto argumento de la llamada &lt;code&gt;setsockopt&lt;/code&gt; en la API de socket C. El valor de la opci&amp;oacute;n debe estar codificado en el endianess nativo de la plataforma y, si se requiere una estructura, debe seguir las convenciones de alineaci&amp;oacute;n de la estructura en la plataforma espec&amp;iacute;fica.</target>
        </trans-unit>
        <trans-unit id="ae1cf5f2bfcd3b60ef15c86d1e7f135dfc63d587" translate="yes" xml:space="preserve">
          <source>In addition to these, the following fields are automatically inserted by Logger, values taken from the two first parameters to &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Adem&amp;aacute;s de estos, Logger inserta autom&amp;aacute;ticamente los siguientes campos, valores tomados de los dos primeros par&amp;aacute;metros para &lt;code&gt;&lt;a href=&quot;#add_handler-3&quot;&gt;add_handler/3&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e583d04eef0dfd18104660d17dcc9b07446e62d3" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the &lt;code&gt;Event Tracers&lt;/code&gt; User's Guide contains the following chapters:</source>
          <target state="translated">Adem&amp;aacute;s de este cap&amp;iacute;tulo introductorio, la Gu&amp;iacute;a del usuario de &lt;code&gt;Event Tracers&lt;/code&gt; contiene los siguientes cap&amp;iacute;tulos:</target>
        </trans-unit>
        <trans-unit id="fd1509d104b7597ab782042099faae460d5ff6b5" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Megaco User's Guide contains the following chapters:</source>
          <target state="translated">Además de este capítulo introductorio,la Guía del Usuario de Megaco contiene los siguientes capítulos:</target>
        </trans-unit>
        <trans-unit id="5ad3911ee58ff673506ee22db5a2de1ed84850c6" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the Reltool User's Guide contains the following chapters:</source>
          <target state="translated">Además de este capítulo introductorio,la Guía del usuario del Reltool contiene los siguientes capítulos:</target>
        </trans-unit>
        <trans-unit id="7f5fdf190092c245c6414244e40560909cfcd608" translate="yes" xml:space="preserve">
          <source>In addition to this introductory chapter, the SNMP User's Guide contains the following chapters:</source>
          <target state="translated">Además de este capítulo introductorio,la Guía del usuario del SNMP contiene los siguientes capítulos:</target>
        </trans-unit>
        <trans-unit id="fb294dab84ef10ba93b7376a3a5eeb757826cec4" translate="yes" xml:space="preserve">
          <source>In addition, &lt;code&gt;#Record.Name&lt;/code&gt; returns the index in the tuple representation of &lt;code&gt;Name&lt;/code&gt; of the record &lt;code&gt;Record&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, &lt;code&gt;#Record.Name&lt;/code&gt; devuelve el &amp;iacute;ndice en la representaci&amp;oacute;n de tupla del &lt;code&gt;Name&lt;/code&gt; del registro &lt;code&gt;Record&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eec4f051098dd6dcb667d9032abc1d31d3cca680" translate="yes" xml:space="preserve">
          <source>In addition, EUnit will also look for another module whose name is &lt;code&gt;ModuleName&lt;/code&gt; plus the suffix &lt;code&gt;_tests&lt;/code&gt;, and if it exists, all the tests from that module will also be added. (If &lt;code&gt;ModuleName&lt;/code&gt; already contains the suffix &lt;code&gt;_tests&lt;/code&gt;, this is not done.) E.g., the specification &lt;code&gt;{module, mymodule}&lt;/code&gt; will run all tests in the modules &lt;code&gt;mymodule&lt;/code&gt; and &lt;code&gt;mymodule_tests&lt;/code&gt;. Typically, the &lt;code&gt;_tests&lt;/code&gt; module should only contain test cases that use the public interface of the main module (and no other code).</source>
          <target state="translated">Adem&amp;aacute;s, EUnit tambi&amp;eacute;n buscar&amp;aacute; otro m&amp;oacute;dulo cuyo nombre sea &lt;code&gt;ModuleName&lt;/code&gt; m&amp;aacute;s el sufijo &lt;code&gt;_tests&lt;/code&gt; , y si existe, tambi&amp;eacute;n se agregar&amp;aacute;n todas las pruebas de ese m&amp;oacute;dulo. (Si &lt;code&gt;ModuleName&lt;/code&gt; ya contiene el sufijo &lt;code&gt;_tests&lt;/code&gt; , esto no se hace). Por ejemplo, la especificaci&amp;oacute;n &lt;code&gt;{module, mymodule}&lt;/code&gt; ejecutar&amp;aacute; todas las pruebas en los m&amp;oacute;dulos &lt;code&gt;mymodule&lt;/code&gt; y &lt;code&gt;mymodule_tests&lt;/code&gt; . Normalmente, el m&amp;oacute;dulo &lt;code&gt;_tests&lt;/code&gt; solo debe contener casos de prueba que utilicen la interfaz p&amp;uacute;blica del m&amp;oacute;dulo principal (y ning&amp;uacute;n otro c&amp;oacute;digo).</target>
        </trans-unit>
        <trans-unit id="ec506ee3c0304b67799c67e512b132d1927abb1c" translate="yes" xml:space="preserve">
          <source>In addition, table properties can be set and changed. For details, see &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s, las propiedades de la tabla se pueden configurar y cambiar. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;code&gt;&lt;a href=&quot;mnesia_chap3#def_schema&quot;&gt;Define a Schema&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dfbb12ad016ab1664756254ead2ae4c40b6031b7" translate="yes" xml:space="preserve">
          <source>In addition, the following three built-in types exist and can be thought as defined below, though strictly their &quot;type definition&quot; is not valid syntax according to the type language defined above.</source>
          <target state="translated">Además,existen los tres tipos siguientes incorporados y pueden pensarse como se definen a continuación,aunque estrictamente su &quot;definición de tipo&quot; no es una sintaxis válida según el lenguaje de tipos definido anteriormente.</target>
        </trans-unit>
        <trans-unit id="2ba8529808e3d5d63f2c2cd138891fddd10121b3" translate="yes" xml:space="preserve">
          <source>In addition, the record fields can be further specified when using a record type by adding type information about the field as follows:</source>
          <target state="translated">Además,los campos de registro pueden especificarse con más detalle cuando se utiliza un tipo de registro añadiendo información de tipo sobre el campo,como se indica a continuación:</target>
        </trans-unit>
        <trans-unit id="0c6af5a9419b35f362c885bc58714fd954a7c605" translate="yes" xml:space="preserve">
          <source>In addition, you'll probably want to familiarize yourself with the &lt;code&gt;dbg&lt;/code&gt; module and possibly &lt;code&gt;seq_trace&lt;/code&gt; module as well.</source>
          <target state="translated">Adem&amp;aacute;s, probablemente querr&amp;aacute; familiarizarse con el m&amp;oacute;dulo &lt;code&gt;dbg&lt;/code&gt; y posiblemente &lt;code&gt;seq_trace&lt;/code&gt; m&amp;oacute;dulo seq_trace .</target>
        </trans-unit>
        <trans-unit id="fb5db34bbd4674c5c25f061b695fba808bb59735" translate="yes" xml:space="preserve">
          <source>In all functions errors, &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt;, can be thrown, where &lt;code&gt;Reason&lt;/code&gt; describes the error.</source>
          <target state="translated">En todas las funciones , se pueden lanzar errores, &lt;code&gt;{'EXIT',{Reason,Backtrace}}&lt;/code&gt; , donde &lt;code&gt;Reason&lt;/code&gt; describe el error.</target>
        </trans-unit>
        <trans-unit id="fe9689d5a6e2657c5f322d20399fbd839acfe486" translate="yes" xml:space="preserve">
          <source>In all of these cases, &lt;code&gt;ReplyInfo&lt;/code&gt; has the following structure:</source>
          <target state="translated">En todos estos casos, &lt;code&gt;ReplyInfo&lt;/code&gt; tiene la siguiente estructura:</target>
        </trans-unit>
        <trans-unit id="e5f12a8e126b9f100f177dad18ae6f54278d47be" translate="yes" xml:space="preserve">
          <source>In all other cases.</source>
          <target state="translated">En todos los demás casos.</target>
        </trans-unit>
        <trans-unit id="44ae32a10f43de59e7c1339560b615fa6de7f95e" translate="yes" xml:space="preserve">
          <source>In all other senses, the &lt;code&gt;_tmo&lt;/code&gt; functions inherit all the return values and the semantics from the functions without the &lt;code&gt;_tmo&lt;/code&gt; suffix.</source>
          <target state="translated">En todos los dem&amp;aacute;s sentidos, las funciones &lt;code&gt;_tmo&lt;/code&gt; heredan todos los valores de retorno y la sem&amp;aacute;ntica de las funciones sin el sufijo &lt;code&gt;_tmo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd966c15dbde5c1d758c9f9740c69468c511589a" translate="yes" xml:space="preserve">
          <source>In all the above examples, the object must exist and it must be of the right type for the specified operation. If you do not know the type of an object, you can ask:</source>
          <target state="translated">En todos los ejemplos anteriores,el objeto debe existir y debe ser del tipo adecuado para la operación especificada.Si no conoce el tipo de un objeto,puede preguntar:</target>
        </trans-unit>
        <trans-unit id="9216f7534e9c31fef68910373cd1fdb3e3fbdb95" translate="yes" xml:space="preserve">
          <source>In an OTP source code tree, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can be constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt;.</source>
          <target state="translated">En un &amp;aacute;rbol de c&amp;oacute;digo fuente de OTP, la versi&amp;oacute;n de OTP se puede leer desde el archivo de texto &lt;code&gt;&amp;lt;OTP source root&amp;gt;/OTP_VERSION&lt;/code&gt; . La ruta absoluta al archivo se puede construir llamando a &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;])&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a595d061787336fdc6e9d2d4c2dc217d3ec6e25" translate="yes" xml:space="preserve">
          <source>In an earlier version of this API, the &lt;code&gt;lookup&lt;/code&gt; function received two arguments, omitting &lt;code&gt;Issuer&lt;/code&gt;. For compatibility, this is still supported: if there is no &lt;code&gt;lookup/3&lt;/code&gt; function in the callback module, &lt;code&gt;lookup/2&lt;/code&gt; is called instead.</source>
          <target state="translated">En una versi&amp;oacute;n anterior de esta API, la funci&amp;oacute;n de &lt;code&gt;lookup&lt;/code&gt; recibi&amp;oacute; dos argumentos, omitiendo &lt;code&gt;Issuer&lt;/code&gt; . Por compatibilidad, esto todav&amp;iacute;a es compatible: si no hay &lt;code&gt;lookup/3&lt;/code&gt; funci&amp;oacute;n lookup / 3 en el m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada, se llama &lt;code&gt;lookup/2&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="b323e21a2ec47acd1da236b19d4a2d70f45bb77d" translate="yes" xml:space="preserve">
          <source>In an embedded system, there is usually no interactive shell. However, an operator can attach to the Erlang system by command &lt;code&gt;to_erl&lt;/code&gt;. The operator is then connected to the Erlang shell and can give ordinary Erlang commands. All interaction with the system through this shell is logged in a special directory.</source>
          <target state="translated">En un sistema embebido, generalmente no hay un shell interactivo. Sin embargo, un operador puede conectarse al sistema Erlang mediante el comando &lt;code&gt;to_erl&lt;/code&gt; . Luego, el operador se conecta al shell de Erlang y puede dar comandos de Erlang ordinarios. Toda la interacci&amp;oacute;n con el sistema a trav&amp;eacute;s de este shell se registra en un directorio especial.</target>
        </trans-unit>
        <trans-unit id="6affeed9ea78db2ead1d48cc4e80d6afbfafb4eb" translate="yes" xml:space="preserve">
          <source>In an installed OTP development system, the OTP version can be read from the text file &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt;. The absolute path to the file can by constructed by calling &lt;code&gt;filename:join([&lt;/code&gt;&lt;code&gt;code:root_dir()&lt;/code&gt;&lt;code&gt;, &quot;releases&quot;,&lt;/code&gt;&lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt;&lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt;</source>
          <target state="translated">En un sistema de desarrollo de OTP instalado, la versi&amp;oacute;n de OTP se puede leer desde el archivo de texto &lt;code&gt;&amp;lt;OTP installation root&amp;gt;/releases/&amp;lt;OTP release number&amp;gt;/OTP_VERSION&lt;/code&gt; . La ruta absoluta al archivo se puede construir llamando a &lt;code&gt;filename:join([&lt;/code&gt; &lt;code&gt;code:root_dir()&lt;/code&gt; &lt;code&gt;, &quot;releases&quot;,&lt;/code&gt; &lt;code&gt;erlang:system_info(otp_release)&lt;/code&gt; &lt;code&gt;, &quot;OTP_VERSION&quot;]).&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a4061d8e63786063b3eeabb1b52df7fa369545be" translate="yes" xml:space="preserve">
          <source>In an interactive system, the code loader provides demand-driven code loading, but in an embedded system the code loader loads all code immediately. The same version of &lt;code&gt;code&lt;/code&gt; is used in both cases. The code server calls &lt;code&gt;init:get_argument(mode)&lt;/code&gt; to determine if it is to run in demand mode or non-demand driven mode.</source>
          <target state="translated">En un sistema interactivo, el cargador de c&amp;oacute;digo proporciona carga de c&amp;oacute;digo impulsada por la demanda, pero en un sistema integrado, el cargador de c&amp;oacute;digo carga todo el c&amp;oacute;digo inmediatamente. En ambos casos se utiliza la misma versi&amp;oacute;n de &lt;code&gt;code&lt;/code&gt; . El servidor de c&amp;oacute;digo llama a &lt;code&gt;init:get_argument(mode)&lt;/code&gt; para determinar si debe ejecutarse en modo de demanda o en modo no impulsado por demanda.</target>
        </trans-unit>
        <trans-unit id="40c287b596d5b896af6235aa0ac1f4766bfd7a16" translate="yes" xml:space="preserve">
          <source>In both cases, the current token is set. In particular, if the token of a received message is empty, the current token of the process is set to empty.</source>
          <target state="translated">En ambos casos,la ficha actual está fijada.En particular,si la ficha de un mensaje recibido está vacía,la ficha actual del proceso se establece como vacía.</target>
        </trans-unit>
        <trans-unit id="6cb81d52aa37dc7833d69efc8ceea8d49076b214" translate="yes" xml:space="preserve">
          <source>In both cases, the first accessible element in the table should be returned. As the key columns are not accessible, this means that the third column is the first row.</source>
          <target state="translated">En ambos casos,se debe devolver el primer elemento accesible de la tabla.Como las columnas clave no son accesibles,esto significa que la tercera columna es la primera fila.</target>
        </trans-unit>
        <trans-unit id="c8bcfe99dfb6ce58aa580ed57d8b7b2260bf8c45" translate="yes" xml:space="preserve">
          <source>In both previous examples, &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; resets the trace token immediately after the traced function to avoid many trace messages because of the printouts in the Erlang shell.</source>
          <target state="translated">En los dos ejemplos anteriores, &lt;code&gt;seq_trace:reset_trace/0&lt;/code&gt; restablece el token de rastreo inmediatamente despu&amp;eacute;s de la funci&amp;oacute;n rastreada para evitar muchos mensajes de rastreo debido a las impresiones en el shell de Erlang.</target>
        </trans-unit>
        <trans-unit id="b04f25164a1486f33a08ec5a081e04f72ebc9e3b" translate="yes" xml:space="preserve">
          <source>In both storages, the documentation is written in the exactly same format: an Erlang term serialized to binary via &lt;code&gt; term_to_binary/1&lt;/code&gt;. The term may be optionally compressed when serialized. It must follow the type specification below:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e9979f7dc9c90d9448aea9a33897846d951ecc0" translate="yes" xml:space="preserve">
          <source>In brief, &lt;code&gt;Common Test&lt;/code&gt; supports:</source>
          <target state="translated">En resumen, &lt;code&gt;Common Test&lt;/code&gt; admite:</target>
        </trans-unit>
        <trans-unit id="219af38196dae5e5cf8e3928cdad6f56580aeb9d" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to do the following:</source>
          <target state="translated">En resumen,el CTH le permite hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="7808f617380ab0dd07679578966aad4ed29b5be3" translate="yes" xml:space="preserve">
          <source>In brief, CTH allows you to:</source>
          <target state="translated">En resumen,el CTH le permite:</target>
        </trans-unit>
        <trans-unit id="515fe8110084161af1176bfde998dc3668536ede" translate="yes" xml:space="preserve">
          <source>In brief, a simple test object consists of a single function that takes no arguments (possibly annotated with some additional metadata, i.e., a line number). Evaluation of the function either &lt;strong&gt;succeeds&lt;/strong&gt;, by returning some value (which is ignored), or &lt;strong&gt;fails&lt;/strong&gt;, by throwing an exception.</source>
          <target state="translated">En resumen, un objeto de prueba simple consta de una &amp;uacute;nica funci&amp;oacute;n que no acepta argumentos (posiblemente anotada con algunos metadatos adicionales, es decir, un n&amp;uacute;mero de l&amp;iacute;nea). La evaluaci&amp;oacute;n de la funci&amp;oacute;n &lt;strong&gt;tiene &amp;eacute;xito&lt;/strong&gt; al devolver alg&amp;uacute;n valor (que se ignora) o &lt;strong&gt;falla&lt;/strong&gt; al lanzar una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cf6c31b5ceac197ebb6de3ed74b4d965acf33272" translate="yes" xml:space="preserve">
          <source>In case of a &lt;code&gt;&lt;a href=&quot;#option-pwdfun&quot;&gt;pwdfun&lt;/a&gt;&lt;/code&gt; checking the user, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200407071e2ee196988d7a1889800e7d1509e085" translate="yes" xml:space="preserve">
          <source>In case of a match operation between a ReferenceID and a CN value from the &lt;code&gt;Subject&lt;/code&gt; field, the first argument to the fun is the extracted hostname from the ReferenceID, and the second argument is the tuple &lt;code&gt;{cn, string()}&lt;/code&gt; taken from the &lt;code&gt;Subject&lt;/code&gt; field. That makes it possible to have separate matching rules for Presented IDs from the &lt;code&gt;Subject&lt;/code&gt; field and from the &lt;code&gt;Subject Alternate Name&lt;/code&gt; field.</source>
          <target state="translated">En caso de una operaci&amp;oacute;n de coincidencia entre un ReferenceID y un valor CN del campo &lt;code&gt;Subject&lt;/code&gt; , el primer argumento de la diversi&amp;oacute;n es el nombre de host extra&amp;iacute;do del ReferenceID, y el segundo argumento es la tupla &lt;code&gt;{cn, string()}&lt;/code&gt; tomada del &lt;code&gt;Subject&lt;/code&gt; campo. Eso hace posible tener reglas de coincidencia independientes para los ID presentados del campo &lt;code&gt;Subject&lt;/code&gt; y del campo &lt;code&gt;Subject Alternate Name&lt;/code&gt; del sujeto .</target>
        </trans-unit>
        <trans-unit id="14abcc78e4a8808dcb7c6c248f2d73041919e75b" translate="yes" xml:space="preserve">
          <source>In case of a sftp request, an sftp server is started in with the user's rights. So it could read, write or delete files if allowed for that user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d57c67c502f00b82712590fc8169173e11b61f4a" translate="yes" xml:space="preserve">
          <source>In case of an error (for example, &lt;code&gt;addr_unreachable&lt;/code&gt;), field &lt;code&gt;error&lt;/code&gt; provides more diagnostics. In such cases, event &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; is automatically converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;error&lt;/code&gt; field value can be converted into a string using &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En caso de un error (por ejemplo, &lt;code&gt;addr_unreachable&lt;/code&gt; ), el &lt;code&gt;error&lt;/code&gt; de campo proporciona m&amp;aacute;s diagn&amp;oacute;sticos. En tales casos, el evento &lt;code&gt;#sctp_paddr_change{}&lt;/code&gt; se convierte autom&amp;aacute;ticamente en un t&amp;eacute;rmino de &lt;code&gt;error&lt;/code&gt; devuelto por &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; . El valor del campo de &lt;code&gt;error&lt;/code&gt; se puede convertir en una cadena usando &lt;code&gt;&lt;a href=&quot;#error_string-1&quot;&gt;error_string/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e587acfb74f322fbcfbbb116173319a489ae29e8" translate="yes" xml:space="preserve">
          <source>In case of an error, all instrumentation functions may return either an SNMPv1 or an SNMPv2 error code. If it returns an SNMPv2 code, it is converted into an SNMPv1 code before it is sent to a SNMPv1 manager. It is recommended to use the SNMPv2 error codes for all instrumentation functions, as these provide more details. See &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; for a description of error code conversions.</source>
          <target state="translated">En caso de error, todas las funciones de instrumentaci&amp;oacute;n pueden devolver un c&amp;oacute;digo de error SNMPv1 o SNMPv2. Si devuelve un c&amp;oacute;digo SNMPv2, se convierte en un c&amp;oacute;digo SNMPv1 antes de enviarlo a un administrador SNMPv1. Se recomienda utilizar los c&amp;oacute;digos de error SNMPv2 para todas las funciones de instrumentaci&amp;oacute;n, ya que proporcionan m&amp;aacute;s detalles. Consulte el &lt;code&gt;&lt;a href=&quot;snmp_app_a&quot;&gt;Appendix A&lt;/a&gt;&lt;/code&gt; para obtener una descripci&amp;oacute;n de las conversiones de c&amp;oacute;digos de error.</target>
        </trans-unit>
        <trans-unit id="53574543ae936142434ad121e0424851d134f56f" translate="yes" xml:space="preserve">
          <source>In case of an sftp request, an sftp server is started with the rights of the user of the Erlang emulator's OS process. So with sftp the authenticated user does not influence the rights.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ca8c5900d9e5d4e81eb7db9c8c5e95ada47eae8" translate="yes" xml:space="preserve">
          <source>In case of lists there is only percent-encoding. In binaries, however, both binary encoding and percent-encoding shall be considered. &lt;code&gt;transcode/2&lt;/code&gt; provides the means to convert between the supported encodings, it takes a &lt;code&gt;uri_string()&lt;/code&gt; and a list of options specifying inbound and outbound encodings.</source>
          <target state="translated">En el caso de las listas, solo hay codificaci&amp;oacute;n porcentual. En los binarios, sin embargo, se considerar&amp;aacute;n tanto la codificaci&amp;oacute;n binaria como la codificaci&amp;oacute;n porcentual. &lt;code&gt;transcode/2&lt;/code&gt; proporciona los medios para convertir entre las codificaciones admitidas, toma una &lt;code&gt;uri_string()&lt;/code&gt; y una lista de opciones que especifican las codificaciones entrantes y salientes.</target>
        </trans-unit>
        <trans-unit id="808f4c12856e1f075895b6b1b300374926fab373" translate="yes" xml:space="preserve">
          <source>In case of loading, monitoring can &lt;strong&gt;not&lt;/strong&gt; only get triggered by using option &lt;code&gt;{reload, ReloadOption}&lt;/code&gt;, but also in special cases where the load error is transient. Thus, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; is to be used under basically &lt;strong&gt;all&lt;/strong&gt; real world circumstances.</source>
          <target state="translated">En caso de carga, el monitoreo &lt;strong&gt;no&lt;/strong&gt; solo puede &lt;code&gt;{reload, ReloadOption}&lt;/code&gt; usando la opci&amp;oacute;n {reload, ReloadOption} , sino tambi&amp;eacute;n en casos especiales donde el error de carga es transitorio. Por lo tanto, &lt;code&gt;{monitor, pending_driver}&lt;/code&gt; se utilizar&amp;aacute; b&amp;aacute;sicamente en &lt;strong&gt;todas&lt;/strong&gt; las circunstancias del mundo real.</target>
        </trans-unit>
        <trans-unit id="c09622d21ce9a9b2d2c2d392f9cbc9b05b57cfb1" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;&lt;a href=&quot;#option-pk_check_user&quot;&gt;pk_check_user&lt;/a&gt;&lt;/code&gt; is set, the atom &lt;code&gt;pubkey&lt;/code&gt; is put in the password argument when validating a public key login. The pwdfun is then responsible to check that the user name is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2a8bc8abb7f5d55980d9c87519b99d19822bd2d" translate="yes" xml:space="preserve">
          <source>In case of the &lt;code&gt;{direct, exec_fun()}&lt;/code&gt; variant or no exec-option at all, all reads from &lt;code&gt;standard_input&lt;/code&gt; will be from the received data-events of type 0. Those are sent by the client. Similarily all writes to &lt;code&gt;standard_output&lt;/code&gt; will be sent as data-events to the client. An OS shell client like the command 'ssh' will usally use stdin and stdout for the user interface.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="977b39c15ba3f7569c95130949a0911293fdf7e5" translate="yes" xml:space="preserve">
          <source>In case where the Presented IDs are fetched from the &lt;code&gt;Subject&lt;/code&gt; certificate field, the names may contain wildcard characters. The function handles this as defined in &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En caso de que los ID presentados se obtengan del campo Certificado del &lt;code&gt;Subject&lt;/code&gt; , los nombres pueden contener caracteres comod&amp;iacute;n. La funci&amp;oacute;n maneja esto como se define en el &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc6125#section-6.4.3&quot;&gt;chapter 6.4.3 in RFC 6125&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c2392e0d50603f0a73106c4fc2922254ed71b25" translate="yes" xml:space="preserve">
          <source>In cases in which there is a choice between string() and binary() types for OctetString() and derived types, the representation is determined by the value of &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En los casos en los que hay una elecci&amp;oacute;n entre los tipos string () y binary () para OctetString () y tipos derivados, la representaci&amp;oacute;n est&amp;aacute; determinada por el valor de &lt;code&gt;&lt;a href=&quot;diameter#service_opt&quot;&gt;diameter:service_opt()&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;diameter#string_decode&quot;&gt;string_decode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef42ed541c5fd6f99645f29530b756b01b921460" translate="yes" xml:space="preserve">
          <source>In cases where it is known that the subject string contains no newlines, it is worth setting &lt;code&gt;dotall&lt;/code&gt; to obtain this optimization, or alternatively using ^ to indicate anchoring explicitly.</source>
          <target state="translated">En los casos en los que se sabe que la cadena de asunto no contiene nuevas l&amp;iacute;neas, vale la pena configurar &lt;code&gt;dotall&lt;/code&gt; para obtener esta optimizaci&amp;oacute;n o, alternativamente, usar ^ para indicar el anclaje expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="a1b58942bdfb61fbfab275afba5031d1b18f39aa" translate="yes" xml:space="preserve">
          <source>In cases where you want to redirect standard input and/or standard output or use Erlang in a pipeline, &lt;code&gt;werl&lt;/code&gt; is not suitable, and the &lt;code&gt;erl&lt;/code&gt; program is to be used instead.</source>
          <target state="translated">En los casos en los que desee redirigir la entrada est&amp;aacute;ndar y / o la salida est&amp;aacute;ndar o utilizar Erlang en una canalizaci&amp;oacute;n, &lt;code&gt;werl&lt;/code&gt; no es adecuado y, en su lugar, debe utilizarse el programa &lt;code&gt;erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43f3712fe1600a053e4d1e45bcba55920060bee0" translate="yes" xml:space="preserve">
          <source>In certain output functions and in the output of return values in the shell, Erlang tries to detect string data in lists and binaries heuristically. Typically you will see heuristic detection in a situation like this:</source>
          <target state="translated">En ciertas funciones de salida y en la salida de los valores de retorno en la cáscara,Erlang trata de detectar datos de cadena en listas y binarios heurísticamente.Típicamente se verá la detección heurística en una situación como esta:</target>
        </trans-unit>
        <trans-unit id="2913f30605a1fdbcd933f0b8e8b6036a00ba77d8" translate="yes" xml:space="preserve">
          <source>In certain situations, especially when the standard output is redirected, access to an I/O server specific for error messages can be convenient. The I/O device &lt;code&gt;standard_error&lt;/code&gt; can be used to direct output to whatever the current operating system considers a suitable I/O device for error output. Example on a Unix-like operating system:</source>
          <target state="translated">En determinadas situaciones, especialmente cuando se redirige la salida est&amp;aacute;ndar, el acceso a un servidor de E / S espec&amp;iacute;fico para mensajes de error puede resultar conveniente. El dispositivo de E / S &lt;code&gt;standard_error&lt;/code&gt; se puede utilizar para dirigir la salida a lo que el sistema operativo actual considere un dispositivo de E / S adecuado para la salida de error. Ejemplo en un sistema operativo similar a Unix:</target>
        </trans-unit>
        <trans-unit id="3962d4a09e381d0a5b5f8e864d0585d6a5883982" translate="yes" xml:space="preserve">
          <source>In combination with &lt;code&gt;{locations, true}&lt;/code&gt; this option prints the lock operations source file and line number entry-points along with statistics for each entry.</source>
          <target state="translated">En combinaci&amp;oacute;n con &lt;code&gt;{locations, true}&lt;/code&gt; esta opci&amp;oacute;n imprime el archivo de origen de las operaciones de bloqueo y los puntos de entrada del n&amp;uacute;mero de l&amp;iacute;nea junto con las estad&amp;iacute;sticas de cada entrada.</target>
        </trans-unit>
        <trans-unit id="d0663aa5a3512196f700ca9db937eddad06a6262" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, adds a phony target for each dependency.</source>
          <target state="translated">Junto con la opci&amp;oacute;n &lt;code&gt;-M&lt;/code&gt; o &lt;code&gt;-MF&lt;/code&gt; , agrega un objetivo falso para cada dependencia.</target>
        </trans-unit>
        <trans-unit id="71822bd1bd6d5c17ee53e249eaeb9feb7f740847" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, changes the name of the rule emitted to &lt;code&gt;Target&lt;/code&gt;.</source>
          <target state="translated">Junto con la opci&amp;oacute;n &lt;code&gt;-M&lt;/code&gt; o &lt;code&gt;-MF&lt;/code&gt; , cambia el nombre de la regla emitida a &lt;code&gt;Target&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="799eab09c6f865f28e612e123d49d644e3a08fdd" translate="yes" xml:space="preserve">
          <source>In conjunction with option &lt;code&gt;-M&lt;/code&gt; or &lt;code&gt;-MF&lt;/code&gt;, considers missing headers as generated files and adds them to the dependencies.</source>
          <target state="translated">En combinaci&amp;oacute;n con la opci&amp;oacute;n &lt;code&gt;-M&lt;/code&gt; o &lt;code&gt;-MF&lt;/code&gt; , encabezados considera que faltan como archivos generados y los agrega a las dependencias.</target>
        </trans-unit>
        <trans-unit id="d32124678089e39bfca82cfddf077b823139344c" translate="yes" xml:space="preserve">
          <source>In contrast to an RPC, a multicall is an RPC that is sent concurrently from one client to multiple servers. This is useful for collecting information from a set of nodes, or for calling a function on a set of nodes to achieve some side effects. It is semantically the same as iteratively making a series of RPCs on all the nodes, but the multicall is faster, as all the requests are sent at the same time and are collected one by one as they come back.</source>
          <target state="translated">A diferencia de una RPC,una multiconferencia es una RPC que se envía simultáneamente desde un cliente a varios servidores.Esto es útil para recoger información de un conjunto de nodos,o para llamar a una función de un conjunto de nodos para lograr algunos efectos secundarios.Semánticamente es lo mismo que hacer iterativamente una serie de RPC en todos los nodos,pero la multiconferencia es más rápida,ya que todas las peticiones se envían al mismo tiempo y se recogen una por una a medida que regresan.</target>
        </trans-unit>
        <trans-unit id="e6c250fb90561ab264baf4cf8dabd48e1c97e8c8" translate="yes" xml:space="preserve">
          <source>In contrast to most of the other callback functions, &lt;code&gt;stop_select&lt;/code&gt; is called independent of any port. No &lt;code&gt;ErlDrvData&lt;/code&gt; argument is passed to the function. No driver lock or port lock is guaranteed to be held. The port that called &lt;code&gt;driver_select&lt;/code&gt; can even be closed at the time &lt;code&gt;stop_select&lt;/code&gt; is called. But it can also be the case that &lt;code&gt;stop_select&lt;/code&gt; is called directly by &lt;code&gt;erl_driver:driver_select&lt;/code&gt;.</source>
          <target state="translated">A diferencia de la mayor&amp;iacute;a de las otras funciones de devoluci&amp;oacute;n de llamada, &lt;code&gt;stop_select&lt;/code&gt; se llama independientemente de cualquier puerto. No se &lt;code&gt;ErlDrvData&lt;/code&gt; ning&amp;uacute;n argumento ErlDrvData a la funci&amp;oacute;n. No se garantiza que se mantenga el bloqueo del conductor o del puerto. El puerto que llam&amp;oacute; a &lt;code&gt;driver_select&lt;/code&gt; puede incluso cerrarse en el momento en que se llama a &lt;code&gt;stop_select&lt;/code&gt; . Pero tambi&amp;eacute;n puede darse el caso de que &lt;code&gt;stop_select&lt;/code&gt; sea ​​llamado directamente por &lt;code&gt;erl_driver:driver_select&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72bf39173d9a61b211eba3bd517308261f47677f" translate="yes" xml:space="preserve">
          <source>In contrast, a subroutine call to a numbered subpattern always refers to the first one in the pattern with the given number. The following pattern matches &quot;abcabc&quot; or &quot;defabc&quot;:</source>
          <target state="translated">Por el contrario,una llamada de subrutina a un subpatrón numerado siempre se refiere al primero del patrón con el número dado.El siguiente patrón coincide con &quot;abcabc&quot; o &quot;defabc&quot;:</target>
        </trans-unit>
        <trans-unit id="2b1893e8c44648aaa4d2220a6408b6c74957584a" translate="yes" xml:space="preserve">
          <source>In crash dumps, the stack, messages, and the process dictionary are omitted.</source>
          <target state="translated">En los vertederos de emergencia,se omiten la pila,los mensajes y el diccionario de procesos.</target>
        </trans-unit>
        <trans-unit id="f5b30e844f19c774b16c52548000fcb4af87d281" translate="yes" xml:space="preserve">
          <source>In decryption, the &lt;code&gt;&lt;a href=&quot;#type-cryptolib_padding&quot;&gt;cryptolib_padding&lt;/a&gt;&lt;/code&gt; removes such padding, if present. The &lt;code&gt;&lt;a href=&quot;#type-otp_padding&quot;&gt;otp_padding&lt;/a&gt;&lt;/code&gt; is not removed - it has to be done elsewhere.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009dc66d33d0ffea38b40e283770f175ec84745e" translate="yes" xml:space="preserve">
          <source>In dirty context, that is, &lt;code&gt;sync_dirty&lt;/code&gt; or &lt;code&gt;async_dirty&lt;/code&gt;, the modified records are not stored in a local copy; instead, each record is updated separately. This generates much network traffic if the table has a replica on another node and has all the other drawbacks that dirty operations have. Especially for commands &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt;, the same drawbacks as described previously for &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; applies, that is, no writing to the table is to be done during iteration.</source>
          <target state="translated">En un contexto sucio, es decir, &lt;code&gt;sync_dirty&lt;/code&gt; o &lt;code&gt;async_dirty&lt;/code&gt; , los registros modificados no se almacenan en una copia local; en cambio, cada registro se actualiza por separado. Esto genera mucho tr&amp;aacute;fico de red si la tabla tiene una r&amp;eacute;plica en otro nodo y tiene todos los dem&amp;aacute;s inconvenientes que tienen las operaciones sucias. Especialmente para los comandos &lt;code&gt;&lt;a href=&quot;mnesia#first-1&quot;&gt;mnesia:first/1&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;mnesia#next-2&quot;&gt;mnesia:next/2&lt;/a&gt;&lt;/code&gt; , se aplican los mismos inconvenientes descritos anteriormente para &lt;code&gt;&lt;a href=&quot;mnesia#dirty_first-1&quot;&gt;mnesia:dirty_first/1&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;mnesia#dirty_next-2&quot;&gt;mnesia:dirty_next/2&lt;/a&gt;&lt;/code&gt; , es decir, no se debe escribir en la tabla durante la iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1a0a0d4d35649ef6ee46c466316008c66431587a" translate="yes" xml:space="preserve">
          <source>In each &lt;code&gt;Viewer&lt;/code&gt; there is only one filter that is active and all trace &lt;code&gt;Events&lt;/code&gt; that the &lt;code&gt;Viewer&lt;/code&gt; gets from the &lt;code&gt;Collector&lt;/code&gt; will pass thru that filter. By writing clever filters it is possible to customize how the &lt;code&gt;Events&lt;/code&gt; looks like in the viewer. The following filter in &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; replaces the actor names &lt;code&gt;mnesia_tm&lt;/code&gt; and &lt;code&gt;mnesia_locker&lt;/code&gt; and leaves everything else in the record as it was:</source>
          <target state="translated">En cada &lt;code&gt;Viewer&lt;/code&gt; solo hay un filtro activo y todos los &lt;code&gt;Events&lt;/code&gt; seguimiento que el &lt;code&gt;Viewer&lt;/code&gt; obtenga del &lt;code&gt;Collector&lt;/code&gt; pasar&amp;aacute;n por ese filtro. Al escribir filtros inteligentes, es posible personalizar el aspecto de los &lt;code&gt;Events&lt;/code&gt; en el visor. El siguiente filtro en &lt;code&gt;et/examples/et_demo.erl&lt;/code&gt; reemplaza los nombres de actor &lt;code&gt;mnesia_tm&lt;/code&gt; y &lt;code&gt;mnesia_locker&lt;/code&gt; y deja todo lo dem&amp;aacute;s en el registro como estaba:</target>
        </trans-unit>
        <trans-unit id="7207b6cf9942a41d2732aa49d03bc019b9c6508d" translate="yes" xml:space="preserve">
          <source>In each iteration, the first 8 bits in the binary will be skipped, not matched out.</source>
          <target state="translated">En cada iteración,los primeros 8 bits del binario serán salteados,no emparejados.</target>
        </trans-unit>
        <trans-unit id="eb6692c5b77a86308b6ebf869c484cc1ff8e5ede" translate="yes" xml:space="preserve">
          <source>In earlier Erlang/OTP releases, operations on too large binaries in general either fail or give incorrect results. In future releases, other operations that create binaries (such as &lt;code&gt;list_to_binary/1&lt;/code&gt;) will probably also enforce the same limit.</source>
          <target state="translated">En versiones anteriores de Erlang / OTP, las operaciones en binarios demasiado grandes en general fallan o dan resultados incorrectos. En versiones futuras, otras operaciones que crean binarios (como &lt;code&gt;list_to_binary/1&lt;/code&gt; ) probablemente tambi&amp;eacute;n impondr&amp;aacute;n el mismo l&amp;iacute;mite.</target>
        </trans-unit>
        <trans-unit id="a79ea28e01a94d82c32763fb4b89f0d00a82f9b8" translate="yes" xml:space="preserve">
          <source>In either case, the agent will do nothing, but return the retrieved ManagerEngineID (see &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; for more info) and possible continue with stage 2 of the discovery process.</source>
          <target state="translated">En cualquier caso, el agente no har&amp;aacute; nada m&amp;aacute;s que devolver el ManagerEngineID recuperado (ver &lt;code&gt;&lt;a href=&quot;snmpa#discovery&quot;&gt;discovery&lt;/a&gt;&lt;/code&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n) y posiblemente continuar con la etapa 2 del proceso de descubrimiento.</target>
        </trans-unit>
        <trans-unit id="6791868ca84c6905bfaf1ddbc9f4f687833d3165" translate="yes" xml:space="preserve">
          <source>In embedded mode, all code is loaded during system startup according to the boot script. (Code can also be loaded later by explicitly ordering the code server to do so.)</source>
          <target state="translated">En el modo incrustado,todo el código se carga durante el arranque del sistema según el guión de arranque.(El código también puede ser cargado más tarde ordenando explícitamente al servidor de código que lo haga).</target>
        </trans-unit>
        <trans-unit id="b50f303eb6355438df5780a62638469b2bf7dcf5" translate="yes" xml:space="preserve">
          <source>In embedded mode, first all modules are loaded. Then all &lt;code&gt;on_load&lt;/code&gt; functions are called. The system is terminated unless all of the &lt;code&gt;on_load&lt;/code&gt; functions return &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">En el modo integrado, primero se cargan todos los m&amp;oacute;dulos. Entonces se llaman todas las funciones &lt;code&gt;on_load&lt;/code&gt; . El sistema se termina a menos que todas las funciones &lt;code&gt;on_load&lt;/code&gt; regresen &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f2dd392efb3ccbc428fed625f643db9c1a171840" translate="yes" xml:space="preserve">
          <source>In embedded mode, modules are not auto loaded. Trying to use a module that has not been loaded results in an error. This mode is recommended when the boot script loads all modules, as it is typically done in OTP releases. (Code can still be loaded later by explicitly ordering the code server to do so).</source>
          <target state="translated">En el modo incrustado,los módulos no se cargan automáticamente.Intentar usar un módulo que no ha sido cargado da como resultado un error.Este modo se recomienda cuando el script de arranque carga todos los módulos,como suele hacerse en las versiones OTP.(El código puede ser cargado más tarde ordenando explícitamente al servidor de código que lo haga).</target>
        </trans-unit>
        <trans-unit id="a1f53217834ce9f061b0ce0f9fd6ed43fb29178a" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt; erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc60ce46c151028d30005b444c453c26498c7146" translate="yes" xml:space="preserve">
          <source>In embedded systems with a limited amount of RAM and no virtual memory, you might want to preserve memory by setting &lt;code&gt;Number&lt;/code&gt; to zero. (The value can be set globally, see &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">En sistemas integrados con una cantidad limitada de RAM y sin memoria virtual, es posible que desee conservar la memoria estableciendo &lt;code&gt;Number&lt;/code&gt; en cero. (El valor se puede establecer globalmente, consulte &lt;code&gt;&lt;a href=&quot;#system_flag-2&quot;&gt;erlang:system_flag/2&lt;/a&gt;&lt;/code&gt; . )</target>
        </trans-unit>
        <trans-unit id="a83f38724964e749e7fb12c41663c8a1d17b6a70" translate="yes" xml:space="preserve">
          <source>In essence, the function performs the same operation as &lt;code&gt;ei_xreceive_msg&lt;/code&gt;, but instead of using an &lt;code&gt;ei_x_buff&lt;/code&gt;, the function expects a pointer to a character pointer (&lt;code&gt;mbufp&lt;/code&gt;), where the character pointer is to point to a memory area allocated by &lt;code&gt;malloc&lt;/code&gt;. Argument &lt;code&gt;bufsz&lt;/code&gt; is to be a pointer to an integer containing the exact size (in bytes) of the memory area. The function may reallocate the memory area and will in such cases put the new size in &lt;code&gt;*bufsz&lt;/code&gt; and update &lt;code&gt;*mbufp&lt;/code&gt;.</source>
          <target state="translated">En esencia, la funci&amp;oacute;n realiza la misma operaci&amp;oacute;n que &lt;code&gt;ei_xreceive_msg&lt;/code&gt; , pero en lugar de utilizar un &lt;code&gt;ei_x_buff&lt;/code&gt; , la funci&amp;oacute;n espera un puntero a un puntero de car&amp;aacute;cter ( &lt;code&gt;mbufp&lt;/code&gt; ), donde el puntero de car&amp;aacute;cter debe apuntar a un &amp;aacute;rea de memoria asignada por &lt;code&gt;malloc&lt;/code&gt; . El argumento &lt;code&gt;bufsz&lt;/code&gt; debe ser un puntero a un n&amp;uacute;mero entero que contenga el tama&amp;ntilde;o exacto (en bytes) del &amp;aacute;rea de memoria. La funci&amp;oacute;n puede reasignar el &amp;aacute;rea de memoria y, en tales casos, pondr&amp;aacute; el nuevo tama&amp;ntilde;o en &lt;code&gt;*bufsz&lt;/code&gt; y actualizar&amp;aacute; &lt;code&gt;*mbufp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a0eed82352e329b2edf4d4c83a697e586f41d04" translate="yes" xml:space="preserve">
          <source>In every directory under &lt;code&gt;DocumentRoot&lt;/code&gt; or under an &lt;code&gt;Alias&lt;/code&gt; a user can place an access file. An access file is a plain text file that specifies the restrictions to consider before the web server answers to a request. If there are more than one access file in the path to the requested asset, the directives in the access file in the directory nearest the asset is used.</source>
          <target state="translated">En cada directorio bajo &lt;code&gt;DocumentRoot&lt;/code&gt; o bajo un &lt;code&gt;Alias&lt;/code&gt; , un usuario puede colocar un archivo de acceso. Un archivo de acceso es un archivo de texto sin formato que especifica las restricciones a considerar antes de que el servidor web responda a una solicitud. Si hay m&amp;aacute;s de un archivo de acceso en la ruta al activo solicitado, se utilizan las directivas en el archivo de acceso en el directorio m&amp;aacute;s cercano al activo.</target>
        </trans-unit>
        <trans-unit id="6115207717e886104fd373d8df969be5b6da13f2" translate="yes" xml:space="preserve">
          <source>In fact since random data is cached some numbers may get reproduced if you try, but this is unpredictable.</source>
          <target state="translated">De hecho,como los datos aleatorios se almacenan en la memoria caché,algunos números pueden reproducirse si lo intentas,pero esto es impredecible.</target>
        </trans-unit>
        <trans-unit id="b8c42f9c0fe05f000ea096a90949e9096c2f9d28" translate="yes" xml:space="preserve">
          <source>In fortunate cases, the inconsistency is only visible in tables belonging to a specific application. However, if a schema transaction is inconsistently recovered because of the enforced transaction recovery decision, the effects of the inconsistency can be fatal. However, if the higher priority is availability rather than consistency, it can be worth the risk.</source>
          <target state="translated">En los casos afortunados,la incoherencia sólo es visible en los cuadros pertenecientes a una aplicación específica.Sin embargo,si una transacción del esquema se recupera de manera inconsistente debido a la decisión de recuperación de la transacción ejecutada,los efectos de la inconsistencia pueden ser fatales.Sin embargo,si la mayor prioridad es la disponibilidad y no la coherencia,puede valer la pena el riesgo.</target>
        </trans-unit>
        <trans-unit id="711417732b3b7abd2d21d3e6c58e046cc718902b" translate="yes" xml:space="preserve">
          <source>In general, bugs are only fixed on the latest &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt;, and new features are introduced in the upcoming release that is under development. However, when we, due to internal reasons, fix bugs on older releases, these will be available and announced as well.</source>
          <target state="translated">En general, los errores solo se corrigen en la &amp;uacute;ltima &lt;code&gt;&lt;a href=&quot;versions#releases_and_patches&quot;&gt;release&lt;/a&gt;&lt;/code&gt; y se introducen nuevas funciones en la pr&amp;oacute;xima versi&amp;oacute;n que est&amp;aacute; en desarrollo. Sin embargo, cuando, por razones internas, corrijamos errores en versiones anteriores, tambi&amp;eacute;n estar&amp;aacute;n disponibles y anunciadas.</target>
        </trans-unit>
        <trans-unit id="8591b3b2816e58b50758f8b5b1d4a64b54ea4bb8" translate="yes" xml:space="preserve">
          <source>In general, subpatterns that were not assigned a value in the match are returned as the tuple &lt;code&gt;{-1,0}&lt;/code&gt; when &lt;code&gt;type&lt;/code&gt; is &lt;code&gt;index&lt;/code&gt;. Unassigned subpatterns are returned as the empty binary or list, respectively, for other return types. Consider the following regular expression:</source>
          <target state="translated">En general, los subpatrones a los que no se les asign&amp;oacute; un valor en la coincidencia se devuelven como la tupla &lt;code&gt;{-1,0}&lt;/code&gt; cuando el &lt;code&gt;type&lt;/code&gt; es &lt;code&gt;index&lt;/code&gt; . Los subpatrones no asignados se devuelven como el binario vac&amp;iacute;o o la lista, respectivamente, para otros tipos de devoluci&amp;oacute;n. Considere la siguiente expresi&amp;oacute;n regular:</target>
        </trans-unit>
        <trans-unit id="264b6524a328aed18af181468f92444ef5d0e1cd" translate="yes" xml:space="preserve">
          <source>In general, the &lt;code&gt;ei&lt;/code&gt; library is guaranteed to be compatible with other Erlang/OTP components that are 2 major releases older or newer than the &lt;code&gt;ei&lt;/code&gt; library itself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b4248b8374fe10eea98b0157468a4afeb3bbaff" translate="yes" xml:space="preserve">
          <source>In general, there are better ways than using time-outs to supervise parts of a distributed Erlang system. Time-outs are usually appropriate to supervise external events, for example, if you have expected a message from some external system within a specified time. For example, a time-out can be used to log a user out of the messenger system if they have not accessed it for, say, ten minutes.</source>
          <target state="translated">En general,hay mejores maneras que usar los tiempos muertos para supervisar partes de un sistema distribuido de Erlang.Los tiempos muertos suelen ser apropiados para supervisar eventos externos,por ejemplo,si se ha esperado un mensaje de algún sistema externo dentro de un tiempo determinado.Por ejemplo,un tiempo muerto puede utilizarse para desconectar a un usuario del sistema de mensajería si no ha accedido a él durante,por ejemplo,diez minutos.</target>
        </trans-unit>
        <trans-unit id="1f8e5e60557a33a0b1e1b193f222fccaafdbdfe2" translate="yes" xml:space="preserve">
          <source>In general, tuples are used where &quot;records&quot; or &quot;structs&quot; are used in other languages. Also, lists are used when representing things with varying sizes, that is, where linked lists are used in other languages.</source>
          <target state="translated">En general,las tuplas se utilizan cuando se usan &quot;registros&quot; o &quot;estructuras&quot; en otros idiomas.También se utilizan las listas cuando se representan cosas de tamaño variable,es decir,cuando se utilizan listas vinculadas en otros idiomas.</target>
        </trans-unit>
        <trans-unit id="1094cd272fde4947e952467ed139509ff51ffbba" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used in exceptional cases. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="translated">En general, las versiones pueden tener m&amp;aacute;s de tres partes. Entonces, las versiones se ordenan solo parcialmente. Estas versiones solo se utilizan en casos excepcionales. Cuando se agrega una parte adicional (de las tres partes normales) a un n&amp;uacute;mero de versi&amp;oacute;n, se crea una nueva rama de versiones. La nueva rama tiene un orden lineal con respecto a la versi&amp;oacute;n base. Sin embargo, las versiones en diferentes ramas no tienen orden y, por lo tanto, solo se puede concluir que todas incluyen lo que est&amp;aacute; incluido en su ancestro com&amp;uacute;n m&amp;aacute;s cercano. Cuando se ramifica varias veces desde la misma versi&amp;oacute;n base, se agregan &lt;code&gt;0&lt;/code&gt; partes entre la versi&amp;oacute;n base y la parte &lt;code&gt;1&lt;/code&gt; menos significativa hasta que se encuentra una versi&amp;oacute;n &amp;uacute;nica. Las versiones que tienen un pedido se pueden comparar como se describe en el p&amp;aacute;rrafo anterior.</target>
        </trans-unit>
        <trans-unit id="ba987c1f9181380720aed267fac74a6f9ee0f607" translate="yes" xml:space="preserve">
          <source>In general, versions can have more than three parts. The versions are then only partially ordered. Such versions are only used when branching off from another branch. When an extra part (out of the normal three parts) is added to a version number, a new branch of versions is made. The new branch has a linear order against the base version. However, versions on different branches have no order, and therefore one can only conclude that they all include what is included in their closest common ancestor. When branching multiple times from the same base version, &lt;code&gt;0&lt;/code&gt; parts are added between the base version and the least significant &lt;code&gt;1&lt;/code&gt; part until a unique version is found. Versions that have an order can be compared as described in the previous paragraph.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="687a73013b2ef41da5625c9f94315c9a3c6f0e31" translate="yes" xml:space="preserve">
          <source>In global trace mode, the collector will automatically start tracing on all connected Erlang nodes. When a node connects, a port tracer will be started on that node and a corresponding trace client on the collector node.</source>
          <target state="translated">En el modo de rastreo global,el colector comenzará automáticamente el rastreo en todos los nodos Erlang conectados.Cuando un nodo se conecta,se iniciará un trazador de puertos en ese nodo y un cliente de trazado correspondiente en el nodo colector.</target>
        </trans-unit>
        <trans-unit id="f00745ad8caa1afca6bdd4f2b710aba925b97dcb" translate="yes" xml:space="preserve">
          <source>In instructions that will not always execute the next instruction. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="581aa3bc4711cf7334b4a74e7f3a343e5b4ccbeb" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code is dynamically loaded when first referenced. When a call to a function in a module is made, and the module is not loaded, the code server searches the code path and loads the module into the system.</source>
          <target state="translated">En el modo interactivo,el código se carga dinámicamente cuando se hace referencia por primera vez.Cuando se hace una llamada a una función en un módulo,y el módulo no está cargado,el servidor de códigos busca la ruta del código y carga el módulo en el sistema.</target>
        </trans-unit>
        <trans-unit id="e0d2190b345450b7396978e3dbbae9980e03e388" translate="yes" xml:space="preserve">
          <source>In interactive mode, the code server maintains a search path, usually called the &lt;strong&gt;code path&lt;/strong&gt;, consisting of a list of directories, which it searches sequentially when trying to load a module.</source>
          <target state="translated">En el modo interactivo, el servidor de c&amp;oacute;digos mantiene una ruta de b&amp;uacute;squeda, generalmente llamada &lt;strong&gt;ruta de c&amp;oacute;digo&lt;/strong&gt; , que consta de una lista de directorios, que busca secuencialmente cuando intenta cargar un m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="1430b49bd146817f97ef7d06df225a493f066b2a" translate="yes" xml:space="preserve">
          <source>In interactive mode, which is default, only some code is loaded during system startup, basically the modules needed by the runtime system. Other code is dynamically loaded when first referenced. When a call to a function in a certain module is made, and the module is not loaded, the code server searches for and tries to load the module.</source>
          <target state="translated">En el modo interactivo,que es el predeterminado,sólo se carga algún código durante el inicio del sistema,básicamente los módulos que necesita el sistema en tiempo de ejecución.Otro código se carga dinámicamente cuando se hace referencia por primera vez.Cuando se hace una llamada a una función en un determinado módulo y éste no se carga,el servidor de códigos busca e intenta cargar el módulo.</target>
        </trans-unit>
        <trans-unit id="1a03bca7ddee9e30128d1091183803f61a0b8991" translate="yes" xml:space="preserve">
          <source>In its simplest forms, the &lt;code&gt;match_spec&lt;/code&gt; look as follows:</source>
          <target state="translated">En sus formas m&amp;aacute;s simples, &lt;code&gt;match_spec&lt;/code&gt; tiene el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="7ce538d7f4c53ffc660905f0d2354601ebec0177" translate="yes" xml:space="preserve">
          <source>In local mode, code is interpreted only at the current node. In global mode, code is interpreted at all known nodes. Processes at other nodes executing interpreted code are automatically displayed in the Monitor window and can be attached to like any other debugged process.</source>
          <target state="translated">En el modo local,el código se interpreta sólo en el nodo actual.En el modo global,el código se interpreta en todos los nodos conocidos.Los procesos en otros nodos que ejecutan el código interpretado se muestran automáticamente en la ventana del monitor y pueden ser adjuntados como cualquier otro proceso depurado.</target>
        </trans-unit>
        <trans-unit id="67bf06325d8975b88277745da18879c2a83cda5c" translate="yes" xml:space="preserve">
          <source>In low-memory systems (especially without virtual memory), setting the value to &lt;code&gt;0&lt;/code&gt; can help to conserve memory.</source>
          <target state="translated">En sistemas con poca memoria (especialmente sin memoria virtual), establecer el valor en &lt;code&gt;0&lt;/code&gt; puede ayudar a conservar la memoria.</target>
        </trans-unit>
        <trans-unit id="aff1ae241ba5a53367c964ba35e7d8b8a0df1b6b" translate="yes" xml:space="preserve">
          <source>In many applications, the overhead of processing a transaction can result in a loss of performance. Dirty operation are short cuts that bypass much of the processing and increase the speed of the transaction.</source>
          <target state="translated">En muchas aplicaciones,los gastos generales de la tramitación de una transacción pueden dar lugar a una pérdida de rendimiento.Las operaciones sucias son atajos que pasan por alto gran parte del procesamiento y aumentan la velocidad de la transacción.</target>
        </trans-unit>
        <trans-unit id="dd0e2f590c5adecb73ed1090aefb1bdd2efeb4bf" translate="yes" xml:space="preserve">
          <source>In many systems, transient states of overloaded queues are normal. Although this function returns &lt;code&gt;false&lt;/code&gt; does not mean that the other node is guaranteed to be non-responsive, it could be a temporary overload. Also, a return value of &lt;code&gt;true&lt;/code&gt; does only mean that the message can be sent on the (TCP) channel without blocking; the message is not guaranteed to arrive at the remote node. For a disconnected non-responsive node, the return value is &lt;code&gt;true&lt;/code&gt; (mimics the behavior of operator &lt;code&gt;!&lt;/code&gt;). The expected behavior and the actions to take when the function returns &lt;code&gt;false&lt;/code&gt; are application- and hardware-specific.</source>
          <target state="translated">En muchos sistemas, los estados transitorios de las colas sobrecargadas son normales. Aunque esta funci&amp;oacute;n devuelve &lt;code&gt;false&lt;/code&gt; no significa que se garantiza que el otro nodo no responder&amp;aacute;, podr&amp;iacute;a ser una sobrecarga temporal. Adem&amp;aacute;s, un valor de retorno &lt;code&gt;true&lt;/code&gt; solo significa que el mensaje se puede enviar en el canal (TCP) sin bloqueo; no se garantiza que el mensaje llegue al nodo remoto. Para un nodo desconectado que no responde, el valor de retorno es &lt;code&gt;true&lt;/code&gt; (&amp;iexcl;imita el comportamiento del operador &lt;code&gt;!&lt;/code&gt; ). El comportamiento esperado y las acciones a tomar cuando la funci&amp;oacute;n devuelve &lt;code&gt;false&lt;/code&gt; son espec&amp;iacute;ficas de la aplicaci&amp;oacute;n y del hardware.</target>
        </trans-unit>
        <trans-unit id="e52c3f887ab093e6f06a26dfc4388cf3cf2eeed6" translate="yes" xml:space="preserve">
          <source>In matching, this default value is only valid for the last element. All other bit string or binary elements in the matching must have a size specification.</source>
          <target state="translated">En la comparación,este valor por defecto sólo es válido para el último elemento.Todos los demás elementos binarios o cadenas de bits en la comparación deben tener una especificación de tamaño.</target>
        </trans-unit>
        <trans-unit id="0ea9b87be6bd6a217fdf52f85ea3b695fde92834" translate="yes" xml:space="preserve">
          <source>In microseconds</source>
          <target state="translated">En microsegundos</target>
        </trans-unit>
        <trans-unit id="74df42bf134f27883f855d9ef2904cba9dbfb304" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;&lt;a href=&quot;#type-custom_verify&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f9c5ec8a0a2225edde7d56a03b4792532c31fc" translate="yes" xml:space="preserve">
          <source>In mode &lt;code&gt;verify_none&lt;/code&gt; the default behavior is to allow all x509-path validation errors. See also option &lt;code&gt;verify_fun&lt;/code&gt;.</source>
          <target state="translated">En el modo &lt;code&gt;verify_none&lt;/code&gt; , el comportamiento predeterminado es permitir todos los errores de validaci&amp;oacute;n de x509-path. Vea tambi&amp;eacute;n la opci&amp;oacute;n &lt;code&gt;verify_fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adc9bd54e329d8564e9dd0fe90f0559b96ad7e59" translate="yes" xml:space="preserve">
          <source>In more technical terms, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; discards the call stack for the process, and then garbage collects the process. After this, all live data is in one continuous heap. The heap is then shrunken to the exact same size as the live data that it holds (even if that size is less than the minimum heap size for the process).</source>
          <target state="translated">En t&amp;eacute;rminos m&amp;aacute;s t&amp;eacute;cnicos, &lt;code&gt;erlang:hibernate/3&lt;/code&gt; descarta la pila de llamadas para el proceso y luego la basura recolecta el proceso. Despu&amp;eacute;s de esto, todos los datos en vivo est&amp;aacute;n en un mont&amp;oacute;n continuo. Luego, el mont&amp;oacute;n se reduce al mismo tama&amp;ntilde;o exacto que los datos en vivo que contiene (incluso si ese tama&amp;ntilde;o es menor que el tama&amp;ntilde;o m&amp;iacute;nimo del mont&amp;oacute;n para el proceso).</target>
        </trans-unit>
        <trans-unit id="7eeb2170c3262e24c6e629309332632b0551f1eb" translate="yes" xml:space="preserve">
          <source>In most API functions where you can use this address family the port number must be &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">En la mayor&amp;iacute;a de las funciones de API en las que puede utilizar esta familia de direcciones, el n&amp;uacute;mero de puerto debe ser &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96533e214a0da4a7dc13f9539128fcec0a90372f" translate="yes" xml:space="preserve">
          <source>In most cases, the &lt;code&gt;RootDir&lt;/code&gt; parameter should be set to the same as the &lt;code&gt;root_dir&lt;/code&gt; configuration parameter used in the call to &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (or &lt;code&gt;code:root_dir()&lt;/code&gt; if the configuration parameter is not set). In some cases it might be useful to evaluate the same target specification towards different root directories. This should, however, be used with great care as it requires equivalent file structures under all roots.</source>
          <target state="translated">En la mayor&amp;iacute;a de los casos, el par&amp;aacute;metro &lt;code&gt;RootDir&lt;/code&gt; debe establecerse en el mismo valor que el par&amp;aacute;metro de configuraci&amp;oacute;n &lt;code&gt;root_dir&lt;/code&gt; utilizado en la llamada a &lt;code&gt;reltool:get_target_spec/1&lt;/code&gt; (o &lt;code&gt;code:root_dir()&lt;/code&gt; si el par&amp;aacute;metro de configuraci&amp;oacute;n no est&amp;aacute; establecido). En algunos casos, puede resultar &amp;uacute;til evaluar la misma especificaci&amp;oacute;n de destino para diferentes directorios ra&amp;iacute;z. Sin embargo, esto debe usarse con mucho cuidado ya que requiere estructuras de archivo equivalentes en todas las ra&amp;iacute;ces.</target>
        </trans-unit>
        <trans-unit id="e5e6c46f0b948281f508f56232b244f2c0be68d3" translate="yes" xml:space="preserve">
          <source>In normal mode keystrokes from the user are collected and interpreted by &lt;code&gt;tty&lt;/code&gt;. Most of the &lt;strong&gt;Emacs&lt;/strong&gt; line-editing commands are supported. The following is a complete list of the supported line-editing commands.</source>
          <target state="translated">En el modo normal, &lt;code&gt;tty&lt;/code&gt; recopila e interpreta las pulsaciones de teclas del usuario . La mayor&amp;iacute;a de los comandos de edici&amp;oacute;n de l&amp;iacute;nea de &lt;strong&gt;Emacs&lt;/strong&gt; son compatibles. La siguiente es una lista completa de los comandos de edici&amp;oacute;n de l&amp;iacute;nea admitidos.</target>
        </trans-unit>
        <trans-unit id="1b91ce563204e764cc3b634a1e770a9c50a8ab66" translate="yes" xml:space="preserve">
          <source>In normal operation, the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; calls are almost for free. When tracing is needed, you can either activate tracing on these functions explicitly. Or you can combine the usage of &lt;code&gt;trace_global&lt;/code&gt; with the usage of &lt;code&gt;trace_pattern&lt;/code&gt;. When set, the &lt;code&gt;trace_pattern&lt;/code&gt; will automatically be activated on all connected nodes.</source>
          <target state="translated">En funcionamiento normal, las llamadas &lt;code&gt;et:trace_me/4,5&lt;/code&gt; son casi gratuitas. Cuando se necesita rastreo, puede activar el rastreo en estas funciones expl&amp;iacute;citamente. O puede combinar el uso de &lt;code&gt;trace_global&lt;/code&gt; con el uso de &lt;code&gt;trace_pattern&lt;/code&gt; . Cuando se establece, &lt;code&gt;trace_pattern&lt;/code&gt; se activar&amp;aacute; autom&amp;aacute;ticamente en todos los nodos conectados.</target>
        </trans-unit>
        <trans-unit id="eae1f10c8b9d4c5e175d3fc8937d4ffde9c0f51a" translate="yes" xml:space="preserve">
          <source>In order for an &lt;code&gt;erpc&lt;/code&gt; operation to succeed, the remote node also needs to support &lt;code&gt;erpc&lt;/code&gt;. Typically only ordinary Erlang nodes as of OTP 23 have &lt;code&gt;erpc&lt;/code&gt; support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01f7caa16342ff7be996c443808331cb189b3fd2" translate="yes" xml:space="preserve">
          <source>In order for an implementation to make full use of the enhanced SNMPv2 error codes, it is essential that the instrumentation functions always return SNMPv2 error codes, in case of error. These are translated into the corresponding SNMPv1 error codes by the agent, if necessary.</source>
          <target state="translated">Para que una implementación aproveche plenamente los códigos de error SNMPv2 mejorados,es esencial que las funciones de instrumentación siempre devuelvan los códigos de error SNMPv2,en caso de error.El agente los traduce a los códigos de error SNMPv1 correspondientes,si es necesario.</target>
        </trans-unit>
        <trans-unit id="91f9f99c50f34dfe6347f220890a64d23f9ce151" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt; driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5554904f6399d518ff690b91bb8e000b4bc410eb" translate="yes" xml:space="preserve">
          <source>In order for the Erlang driver thread API to function, thread support must be enabled in the runtime system. An Erlang driver can check if thread support is enabled by use of &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Notice that some functions in the Erlang driver API are thread-safe only when the runtime system has SMP support, also this information can be retrieved through &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt;. Also notice that many functions in the Erlang driver API are &lt;strong&gt;not&lt;/strong&gt; thread-safe, regardless of whether SMP support is enabled or not. If a function is not documented as thread-safe, it is &lt;strong&gt;not&lt;/strong&gt; thread-safe.</source>
          <target state="translated">Para que funcione la API de subprocesos del controlador Erlang, el soporte de subprocesos debe estar habilitado en el sistema de tiempo de ejecuci&amp;oacute;n. Un controlador Erlang puede verificar si el soporte de subprocesos est&amp;aacute; habilitado mediante el uso de &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; . Tenga en cuenta que algunas funciones en la API del controlador Erlang son seguras para subprocesos solo cuando el sistema en tiempo de ejecuci&amp;oacute;n tiene soporte SMP, tambi&amp;eacute;n esta informaci&amp;oacute;n se puede recuperar a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;#driver_system_info&quot;&gt;driver_system_info&lt;/a&gt;&lt;/code&gt; . Tambi&amp;eacute;n observe que muchas funciones en la API del controlador Erlang &lt;strong&gt;no&lt;/strong&gt; son seguras para subprocesos, independientemente de si la compatibilidad con SMP est&amp;aacute; habilitada o no. Si una funci&amp;oacute;n no est&amp;aacute; documentada como seguro para subprocesos, se &lt;strong&gt;no&lt;/strong&gt; seguro para subprocesos.</target>
        </trans-unit>
        <trans-unit id="652d6f0f7f2fd0f26e6c7835ec2944249c814b15" translate="yes" xml:space="preserve">
          <source>In order for the break/continue functionality to work, &lt;code&gt;Common Test&lt;/code&gt; must release the shell process controlling &lt;code&gt;stdin&lt;/code&gt;. This is done by setting start option &lt;code&gt;release_shell&lt;/code&gt; to &lt;code&gt;true&lt;/code&gt;. For details, see section &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Para que funcione la funcionalidad de interrupci&amp;oacute;n / continuaci&amp;oacute;n, &lt;code&gt;Common Test&lt;/code&gt; debe liberar el proceso de shell que controla &lt;code&gt;stdin&lt;/code&gt; . Esto se hace estableciendo la opci&amp;oacute;n de inicio &lt;code&gt;release_shell&lt;/code&gt; en &lt;code&gt;true&lt;/code&gt; . Para obtener m&amp;aacute;s detalles, consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;run_test_chapter#erlang_shell_or_program&quot;&gt;Running Tests from the Erlang Shell or from an Erlang Program&lt;/a&gt;&lt;/code&gt; en la Gu&amp;iacute;a del usuario.</target>
        </trans-unit>
        <trans-unit id="6e5ab42b46c29034052cc72be40b7ac14c2d1e1e" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt; +sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78380f5cb098afa599c64e0ffb0ba494ac35ede5" translate="yes" xml:space="preserve">
          <source>In order for the runtime system to be able to bind schedulers, the CPU topology must be known. If the runtime system fails to detect the CPU topology automatically, it can be defined. For more information on how to define the CPU topology, see command-line flag &lt;code&gt;+sct&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">Para que el sistema en tiempo de ejecuci&amp;oacute;n pueda vincular programadores, se debe conocer la topolog&amp;iacute;a de la CPU. Si el sistema en tiempo de ejecuci&amp;oacute;n no detecta la topolog&amp;iacute;a de la CPU autom&amp;aacute;ticamente, se puede definir. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo definir la topolog&amp;iacute;a de la CPU, consulte la l&amp;iacute;nea de comandos flag &lt;code&gt;+sct&lt;/code&gt; en &lt;code&gt;erl(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dca7b006090165b7c3c9be08fcb7f845ac2dfef6" translate="yes" xml:space="preserve">
          <source>In order for this to work properly, the user must ensure that the following two requirements are satisfied:</source>
          <target state="translated">Para que esto funcione correctamente,el usuario debe asegurarse de que se cumplan los dos requisitos siguientes:</target>
        </trans-unit>
        <trans-unit id="7316234f8d0404e7bccb8d56aec4837d25e8e904" translate="yes" xml:space="preserve">
          <source>In order to allow minimizing the performance loss, the &lt;code&gt;file_check&lt;/code&gt; parameter can be set to a positive integer value, &lt;code&gt;N&lt;/code&gt;. The handler will then skip reading the file information prior to writing, as long as no more than &lt;code&gt;N&lt;/code&gt; milliseconds have passed since it was last read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5fcbbc4da3a883acc2844e1722d4a3096e07d7" translate="yes" xml:space="preserve">
          <source>In order to append this data to the end of the motorcycles.xml document you have to parse the file and add Data to the end of the root element content.</source>
          <target state="translated">Para añadir estos datos al final del documento motocicletas.xml hay que analizar el archivo y añadir los datos al final del contenido del elemento raíz.</target>
        </trans-unit>
        <trans-unit id="1cc2af703c741622a9752f6130d1aed382c381ac" translate="yes" xml:space="preserve">
          <source>In order to avoid these situations we wanted to be able to do most of the fundamental operations on a process without having to acquire a lock on the process. Some examples of such fundamental operations are, moving a process between run queues, detecting if we need to insert it into a run queue or not, detecting if it is alive or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9606b78a849c5b14fbde9a528c5423519c626033" translate="yes" xml:space="preserve">
          <source>In order to be able to decide which run queue to use without having to lock any run queues, we moved all fixed balancing information out of the run queues into a global memory block. That is, migration paths and run queue limits. Information that need to be frequently updated, like for example maximum run queue length, were kept in the run queue, but instead of operating on this information under locks we now use atomic memory operations when accessing this information. This made it possible to first determine which run queue to use, without locking any run queues, and when decided, lock the chosen run queue and insert the process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c4f9a3c32af1c0aebd8c724db9f1fd7c9cd27f7" translate="yes" xml:space="preserve">
          <source>In order to be able to detect when it is safe to deallocate a previously used process structure, reference counting of the structure was used. Also this was problematic, since simultaneous lookups needed to modify the reference counter which also caused contention on the cache line where the reference counter was located. This since all modifications needs to be communicated between all involved processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="248b6946fb3d78aedfd7eb1945dab3d08fcb73b1" translate="yes" xml:space="preserve">
          <source>In order to be able to determine when all managed threads have reached the states that we are interested in we need to communicate between all involved threads. We of course want to minimize this communication.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b21c20f0ab3dedd86e0307763e8d967cc669941c" translate="yes" xml:space="preserve">
          <source>In order to be able to remove a carrier from one allocator instance and add it to another we need to be able to move references to the free blocks of the carrier between the allocator instances. The allocator instance specific data structure referring to the free blocks it manages often refers to the same carrier from multiple places. For example, when the address order best-fit strategy is used this data structure is a binary search tree spanning all carriers that the allocator instance manages. Free blocks in one specific carrier can be referred to from potentially every other carrier that is managed, and the amount of such references can be huge. That is, the work of removing the free blocks of such a carrier from the search tree will be huge. One way of solving this could be not to migrate carriers that contain lots of free blocks, but this would prevent us from migrating carriers that potentially need to be migrated in order to solve the problem we set out to solve.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98a8e7d2e52da6dad36a29e2bdfa8a3172fe51b" translate="yes" xml:space="preserve">
          <source>In order to compile Erlang code, a small Erlang bootstrap system has to be built, or an Erlang/OTP system of the same release as the one being built has to be provided in the &lt;code&gt;$PATH&lt;/code&gt;. The Erlang/OTP for the target system will be built using this Erlang system, together with the cross compilation tools provided.</source>
          <target state="translated">Para compilar el c&amp;oacute;digo Erlang, se debe construir un peque&amp;ntilde;o sistema de arranque Erlang, o se debe proporcionar un sistema Erlang / OTP de la misma versi&amp;oacute;n que el que se est&amp;aacute; construyendo en &lt;code&gt;$PATH&lt;/code&gt; . El Erlang / OTP para el sistema de destino se construir&amp;aacute; utilizando este sistema Erlang, junto con las herramientas de compilaci&amp;oacute;n cruzada proporcionadas.</target>
        </trans-unit>
        <trans-unit id="33c36db64d09c1349048183a11365e092986cc43" translate="yes" xml:space="preserve">
          <source>In order to determine when the events has happened we use a global counter that is incremented when all managed threads have called &lt;code&gt;erts_thr_progress_update()&lt;/code&gt; (or &lt;code&gt;erts_thr_progress_leader_update()&lt;/code&gt;). This could naively be implemented using a &quot;thread confirmed&quot; counter. This would however cause an explosion of communication where all involved processors would need to communicate with each other at each update.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa8bd01b2e2143b89a5d070a42db3498a1a3a7f5" translate="yes" xml:space="preserve">
          <source>In order to ensure data integrity, mutex'es are taken when needed. So, do not call this function often.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3bbb01425e78fa9829f765ceacdcbc84ac1251f2" translate="yes" xml:space="preserve">
          <source>In order to fit better into your existing logging infrastructure Logger can format its logging messages any way you want to. Either you can use the built-in formatter, or you can build your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15ce32715d8736617da44b2f7221256f14487b54" translate="yes" xml:space="preserve">
          <source>In order to fully understand the internal form you must get hold on a ASN.1 specification for the Megaco/H.248 protocol, and apply the rules above. Please, see the documentation of the ASN.1 compiler in Erlang/OTP for more details of the semantics in mapping between ASN.1 and the corresponding internal form.</source>
          <target state="translated">Para entender completamente la forma interna,debe obtener una especificación ASN.1 para el protocolo Megaco/H.248,y aplicar las reglas anteriores.Por favor,vea la documentación del compilador ASN.1 en Erlang/OTP para más detalles de la semántica en el mapeo entre ASN.1 y la forma interna correspondiente.</target>
        </trans-unit>
        <trans-unit id="ea6d5c582d5491e2165d48386242957c6fe3d344" translate="yes" xml:space="preserve">
          <source>In order to further simplify the tracing, you can make use of the &lt;code&gt;et:trace_me/4,5&lt;/code&gt; functions. These functions are intended to be invoked from other applications when there are interesting &lt;code&gt;Events&lt;/code&gt;, in your application that needs to be highlighted. The functions are extremely light weight as they do nothing besides returning an atom. These functions are specifically designed to be traced for. As the caller explicitly provides the values for the &lt;code&gt;Event Record&lt;/code&gt; fields, the default &lt;code&gt;Collector Filter&lt;/code&gt; is able to automatically provide a customized &lt;code&gt;Event Record&lt;/code&gt; without any user defined filter functions.</source>
          <target state="translated">Para simplificar a&amp;uacute;n m&amp;aacute;s el rastreo, puede hacer uso de las funciones &lt;code&gt;et:trace_me/4,5&lt;/code&gt; . Estas funciones est&amp;aacute;n pensadas para ser invocadas desde otras aplicaciones cuando hay &lt;code&gt;Events&lt;/code&gt; interesantes en su aplicaci&amp;oacute;n que necesitan ser resaltados. Las funciones son extremadamente ligeras ya que no hacen nada m&amp;aacute;s que devolver un &amp;aacute;tomo. Estas funciones est&amp;aacute;n dise&amp;ntilde;adas espec&amp;iacute;ficamente para rastrearlas. Como la persona que llama proporciona expl&amp;iacute;citamente los valores para los campos de &lt;code&gt;Event Record&lt;/code&gt; , el &lt;code&gt;Collector Filter&lt;/code&gt; predeterminado puede proporcionar autom&amp;aacute;ticamente un &lt;code&gt;Event Record&lt;/code&gt; personalizado sin ninguna funci&amp;oacute;n de filtro definida por el usuario.</target>
        </trans-unit>
        <trans-unit id="d72fdffcde207532623f4383c3bcc9252d8eb8ee" translate="yes" xml:space="preserve">
          <source>In order to implement delay of thread progress from unmanaged threads we use two reference counters. One being &lt;code&gt;current&lt;/code&gt; and one being &lt;code&gt;waiting&lt;/code&gt;. When an unmanaged thread wants to delay thread progress it increments &lt;code&gt;current&lt;/code&gt; and gets a handle back to the reference counter it incremented. When it later wants to enable continuation of thread progress it uses the handle to decrement the reference counter it previously incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03fc72bd9eea1c19e5c0da63c18725fd1977b35e" translate="yes" xml:space="preserve">
          <source>In order to improve this, state information was re-organized in the port structer, so that we can access it using atomic memory operations. This together with the new port table implementation, enabled us to lookup the port and inspect the state before acquiring the port lock, which in turn made it possible to perform preparations of signal data before acquiring the port lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d79e2feac48e88d730a559bbb82e697ebe900339" translate="yes" xml:space="preserve">
          <source>In order to make Xref easy to use, there are predefined analyses that perform some common tasks. Typically, a module or a release can be checked for calls to undefined functions. For the somewhat more advanced user there is a small, but rather flexible, language that can be used for selecting parts of the analyzed system and for doing some simple graph analyses on selected calls.</source>
          <target state="translated">Para que el Xref sea fácil de usar,hay análisis predefinidos que realizan algunas tareas comunes.Típicamente,un módulo o una versión pueden ser revisados por llamadas a funciones no definidas.Para el usuario algo más avanzado existe un lenguaje pequeño,pero bastante flexible,que puede utilizarse para seleccionar partes del sistema analizado y para hacer algunos análisis gráficos sencillos de las llamadas seleccionadas.</target>
        </trans-unit>
        <trans-unit id="aea5444714eb91d126874c6a93a730087a09d9a5" translate="yes" xml:space="preserve">
          <source>In order to migrate carriers between allocator instances we move them through a pool of carriers. In order for a carrier migration to complete, one scheduler needs to move the carrier into the pool, and another scheduler needs to take the carrier out of the pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28832355c97c24952004ab393607d4cf79bc0d06" translate="yes" xml:space="preserve">
          <source>In order to prepare the MG for the sending of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">Con el fin de preparar el MG para el envío del mensaje inicial,con suerte una solicitud de cambio de servicio,hay que hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="420729e1fc23e88c8dd82e270ff2157af4611c2e" translate="yes" xml:space="preserve">
          <source>In order to prepare the MGC for the reception of the initial message, hopefully a Service Change Request, the following needs to be done:</source>
          <target state="translated">Con el fin de preparar al MGC para la recepción del mensaje inicial,con suerte una solicitud de cambio de servicio,hay que hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="45fb88d2abad8087318cf9186878fe028a795bdf" translate="yes" xml:space="preserve">
          <source>In order to prevent multiple schedulers from trying to execute signals to/from the same port simultaneously, we need to be able to ensure that all signals to/from a port are executed in sequence on one scheduler. More or less, the only way to do this is to schedule all types of signals. Signals corresponding to a port can then be executed in sequence by one single scheduler thread. If only one thread tries to execute the port, no contention will appear on the port lock. Besides getting rid of the contention, processes sending signals to the port can also continue execution of their own Erlang code on other schedulers at the same time as the signaling code is executing on another scheduler.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="403d69677374c07e6c15d9b1403b168e3385a4f8" translate="yes" xml:space="preserve">
          <source>In order to prevent scenarios like this we've implemented support for migration of multi-block carriers between allocator instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07f515d2f2923cfaf0efd016e9309bd6ce7894d3" translate="yes" xml:space="preserve">
          <source>In order to provide a solution for scalable implementations of MG's and MGC's, a user may be distributed over several Erlang nodes. One of the Erlang nodes is connected to the physical network interface, but messages may be sent from other nodes and the replies are automatically forwarded back to the originating node.</source>
          <target state="translated">Con el fin de proporcionar una solución para implementaciones escalables de MG y MGC,un usuario puede estar distribuido en varios nodos Erlang.Uno de los nodos Erlang está conectado a la interfaz física de la red,pero se pueden enviar mensajes desde otros nodos y las respuestas se reenvían automáticamente al nodo de origen.</target>
        </trans-unit>
        <trans-unit id="9b7d500551c4dcb114f3424b88510f43e715d2cf" translate="yes" xml:space="preserve">
          <source>In order to reduce contention due to locking of allocator instances we introduced completely lock free instances tied to each scheduler thread, and an extra locked instance for other threads. The scheduler threads in the system is expected to do the major part of the work. Other threads may still be needed but should not perform any major and/or time critical work. The limited amount of contention that appears on the locked allocator instance can more or less be disregarded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f092b8785b0c724e3673cc03096bbd3fea047bff" translate="yes" xml:space="preserve">
          <source>In order to retrieve keylog information on a TLS 1.3 connection, it must be configured in advance to keep the client_random and various handshake secrets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9731fa13e74c2eca121fa5f3f64dcc4b8aa04753" translate="yes" xml:space="preserve">
          <source>In order to see the nitty gritty details of an &lt;code&gt;Event&lt;/code&gt; you may click on the &lt;code&gt;Event&lt;/code&gt; in order to start a &lt;code&gt;Contents Viewer&lt;/code&gt; for that &lt;code&gt;Event&lt;/code&gt;. In the &lt;code&gt;Contents Viewer&lt;/code&gt; there also is a filter menu that enables inspection of the &lt;code&gt;Event&lt;/code&gt; from other views than the one selected in the viewer. A click on the &lt;code&gt;new_tid&lt;/code&gt;&lt;code&gt;Event&lt;/code&gt; will cause a &lt;code&gt;Contents Viewer&lt;/code&gt; window to pop up, showing the &lt;code&gt;Event&lt;/code&gt; in the &lt;code&gt;mgr_actors&lt;/code&gt; view:</source>
          <target state="translated">Para ver los detalles esenciales de un &lt;code&gt;Event&lt;/code&gt; , puede hacer clic en el &lt;code&gt;Event&lt;/code&gt; para iniciar un &lt;code&gt;Contents Viewer&lt;/code&gt; para ese &lt;code&gt;Event&lt;/code&gt; . En el &lt;code&gt;Contents Viewer&lt;/code&gt; tambi&amp;eacute;n hay un men&amp;uacute; de filtro que permite la inspecci&amp;oacute;n del &lt;code&gt;Event&lt;/code&gt; o desde otras vistas distintas a la seleccionada en el visor. Un clic en el &lt;code&gt;Event&lt;/code&gt; &lt;code&gt;new_tid&lt;/code&gt; har&amp;aacute; que aparezca una ventana del &lt;code&gt;Contents Viewer&lt;/code&gt; , mostrando el &lt;code&gt;Event&lt;/code&gt; en la vista &lt;code&gt;mgr_actors&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="dbccfc8cfa22ee2e381053c5b4b92eaa192ba4f4" translate="yes" xml:space="preserve">
          <source>In order to set a different socket path the &lt;code id=&quot;SOCKET_PATH&quot;&gt;socket_path&lt;/code&gt; option can be set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92ff9cab23ed1e1a7df0e6479aae0e38297e97c3" translate="yes" xml:space="preserve">
          <source>In order to solve this, we introduced a new busy feature, namely &quot;busy port queue&quot;. The port has a limit of &lt;code&gt;command&lt;/code&gt; data that is allowed to be enqueued in the task queue. When this limit is reached, the port will automatically enter a busy port queue state. When in this state, senders of &lt;code&gt;command&lt;/code&gt; signals will be suspended, but &lt;code&gt;command&lt;/code&gt; signals will still be delivered to the port unless it is also in a busy port state. This limit is known as the high limit.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e67fa06e1bd38aa13f81fc5e8041b9e05f7af4" translate="yes" xml:space="preserve">
          <source>In order to test modifications of the process table we ran a couple of benchmarks where lots of processes are spawned and terminated simultaneously, and got a speedup of between 150-200%. Running a similar benchmark but with ports we got a speedup of about 130%.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89bee7955a9d3e10a16eb24de0ff7542bf8f388b" translate="yes" xml:space="preserve">
          <source>In order to use the Tags system a file named &lt;code&gt;TAGS&lt;/code&gt; must be created. The file can be seen as a database over all functions, records, and macros in all files in the project. The &lt;code&gt;TAGS&lt;/code&gt; file can be created using two different methods for Erlang. The first is the standard Emacs utility &quot;etags&quot;, the second is by using the Erlang module &lt;code&gt;tags&lt;/code&gt;.</source>
          <target state="translated">Para utilizar el sistema de etiquetas, se debe crear un archivo llamado &lt;code&gt;TAGS&lt;/code&gt; . El archivo puede verse como una base de datos sobre todas las funciones, registros y macros en todos los archivos del proyecto. El archivo &lt;code&gt;TAGS&lt;/code&gt; se puede crear utilizando dos m&amp;eacute;todos diferentes para Erlang. La primera es la utilidad est&amp;aacute;ndar de Emacs &quot;etags&quot;, la segunda es mediante el uso de las &lt;code&gt;tags&lt;/code&gt; m&amp;oacute;dulo Erlang .</target>
        </trans-unit>
        <trans-unit id="87d5585c6ba89972afd1216748dd8d8d098d28d5" translate="yes" xml:space="preserve">
          <source>In our measurements we have seen that there are no significant differences in message sizes between ASN.1 BER and the compact text format. Some care should be taken when using the pretty text style (which is used in all the examples included in the protocol specification and preferred during debugging sessions) since the messages can then be quite large. If the message size really is a serious issue, our per encoder should be used, as the ASN.1 PER format is much more compact than all the other alternatives. Its major drawback is that it is has not been approved as a valid Megaco/H.248 message encoding.</source>
          <target state="translated">En nuestras mediciones hemos visto que no hay diferencias significativas en los tamaños de los mensajes entre el ASN.1 BER y el formato de texto compacto.Hay que tener cierto cuidado al utilizar el estilo de texto bonito (que se utiliza en todos los ejemplos incluidos en la especificación del protocolo y que se prefiere durante las sesiones de depuración)ya que los mensajes pueden ser entonces bastante grandes.Si el tamaño del mensaje es realmente un problema serio,se debería utilizar nuestro per encoder,ya que el formato ASN.1 PER es mucho más compacto que todas las demás alternativas.Su mayor inconveniente es que no ha sido aprobado como una codificación de mensaje Megaco/H.248 válida.</target>
        </trans-unit>
        <trans-unit id="65532138e2b3ba308191e4f5508353fb9debf75b" translate="yes" xml:space="preserve">
          <source>In practice, object sets are usually declared to be extensible so that more objects can be added to the set later. Extensibility is indicated as follows:</source>
          <target state="translated">En la práctica,los conjuntos de objetos suelen declararse extensibles para poder añadir más objetos al conjunto más adelante.La extensibilidad se indica de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ce95e8a49f6cc63c7488544f7b729b9f298807b1" translate="yes" xml:space="preserve">
          <source>In previous versions of &lt;code&gt;file&lt;/code&gt;, modes were specified as one of the atoms &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;read_write&lt;/code&gt; instead of a list. This is still allowed for reasons of backwards compatibility, but is not to be used for new code. Also note that &lt;code&gt;read_write&lt;/code&gt; is not allowed in a mode list.</source>
          <target state="translated">En versiones anteriores del &lt;code&gt;file&lt;/code&gt; , los modos se especificaban como uno de los &amp;aacute;tomos de &lt;code&gt;read&lt;/code&gt; , &lt;code&gt;write&lt;/code&gt; o &lt;code&gt;read_write&lt;/code&gt; lugar de una lista. Esto todav&amp;iacute;a est&amp;aacute; permitido por razones de compatibilidad con versiones anteriores, pero no debe usarse para c&amp;oacute;digo nuevo. Tambi&amp;eacute;n tenga en cuenta que &lt;code&gt;read_write&lt;/code&gt; no est&amp;aacute; permitido en una lista de modos.</target>
        </trans-unit>
        <trans-unit id="f79c7cf33fb3cea437947f151dd1585b263646aa" translate="yes" xml:space="preserve">
          <source>In principle, this function calls the &lt;code&gt;process_received_message/4&lt;/code&gt; function via a &lt;code&gt;spawn&lt;/code&gt; to perform the actual processing.</source>
          <target state="translated">En principio, esta funci&amp;oacute;n llama a la funci&amp;oacute;n &lt;code&gt;process_received_message/4&lt;/code&gt; a trav&amp;eacute;s de un &lt;code&gt;spawn&lt;/code&gt; para realizar el procesamiento real.</target>
        </trans-unit>
        <trans-unit id="c1b13e4d52a1141022b35db2e3080247aecc4f96" translate="yes" xml:space="preserve">
          <source>In protocols that support client-initiated renegotiation, the cost of resources of such an operation is higher for the server than the client. This can act as a vector for denial of service attacks. The SSL application already takes measures to counter-act such attempts, but client-initiated renegotiation can be strictly disabled by setting this option to &lt;code&gt;false&lt;/code&gt;. The default value is &lt;code&gt;true&lt;/code&gt;. Note that disabling renegotiation can result in long-lived connections becoming unusable due to limits on the number of messages the underlying cipher suite can encipher.</source>
          <target state="translated">En los protocolos que admiten la renegociaci&amp;oacute;n iniciada por el cliente, el costo de los recursos de dicha operaci&amp;oacute;n es mayor para el servidor que para el cliente. Esto puede actuar como un vector para ataques de denegaci&amp;oacute;n de servicio. La aplicaci&amp;oacute;n SSL ya toma medidas para contrarrestar tales intentos, pero la renegociaci&amp;oacute;n iniciada por el cliente se puede deshabilitar estrictamente estableciendo esta opci&amp;oacute;n en &lt;code&gt;false&lt;/code&gt; . El valor predeterminado es &lt;code&gt;true&lt;/code&gt; . Tenga en cuenta que deshabilitar la renegociaci&amp;oacute;n puede provocar que las conexiones de larga duraci&amp;oacute;n se vuelvan inutilizables debido a los l&amp;iacute;mites en la cantidad de mensajes que el conjunto de cifrado subyacente puede cifrar.</target>
        </trans-unit>
        <trans-unit id="6c5be2b3b8e809c554958bbec452d00bc9526f02" translate="yes" xml:space="preserve">
          <source>In rare circumstances, this function can fail on Unix. It can occur if read permission does not exist for the parent directories of the current directory.</source>
          <target state="translated">En raras circunstancias,esta función puede fallar en el Unix.Puede ocurrir si el permiso de lectura no existe para los directorios padres del directorio actual.</target>
        </trans-unit>
        <trans-unit id="03d64f33ab45a7b9facd9b7d6fdfa4c86a07dd26" translate="yes" xml:space="preserve">
          <source>In reality, data models are seldom fully normalized. A realistic alternative to a normalized database model would be a data model that is not even in first normal form. &lt;code&gt;Mnesia&lt;/code&gt; is suitable for applications such as telecommunications, because it is easy to organize data in a flexible manner. A &lt;code&gt;Mnesia&lt;/code&gt; database is always organized as a set of tables. Each table is filled with rows, objects, and records. What sets &lt;code&gt;Mnesia&lt;/code&gt; apart is that individual fields in a record can contain any type of compound data structures. An individual field in a record can contain lists, tuples, functions, and even record code.</source>
          <target state="translated">En realidad, los modelos de datos rara vez est&amp;aacute;n completamente normalizados. Una alternativa realista a un modelo de base de datos normalizado ser&amp;iacute;a un modelo de datos que ni siquiera est&amp;aacute; en la primera forma normal. &lt;code&gt;Mnesia&lt;/code&gt; es adecuado para aplicaciones como las telecomunicaciones, porque es f&amp;aacute;cil de organizar los datos de forma flexible. Una &lt;code&gt;Mnesia&lt;/code&gt; datos de Mnesia siempre se organiza como un conjunto de tablas. Cada tabla est&amp;aacute; llena de filas, objetos y registros. Lo que distingue a &lt;code&gt;Mnesia&lt;/code&gt; es que los campos individuales de un registro pueden contener cualquier tipo de estructura de datos compuestos. Un campo individual en un registro puede contener listas, tuplas, funciones e incluso c&amp;oacute;digo de registro.</target>
        </trans-unit>
        <trans-unit id="6b66f371cbc8ed94f2c343e8c1182f27560a8689" translate="yes" xml:space="preserve">
          <source>In scenario 1, the test case process terminates normally after &lt;code&gt;case A&lt;/code&gt; has finished executing its test code without detecting any errors. The test case function returns a value and &lt;code&gt;Common Test&lt;/code&gt; logs the test case as successful.</source>
          <target state="translated">En el escenario 1, el proceso del caso de prueba termina normalmente despu&amp;eacute;s de que el &lt;code&gt;case A&lt;/code&gt; haya terminado de ejecutar su c&amp;oacute;digo de prueba sin detectar ning&amp;uacute;n error. La funci&amp;oacute;n de caso de prueba devuelve un valor y &lt;code&gt;Common Test&lt;/code&gt; registra el caso de prueba como exitoso.</target>
        </trans-unit>
        <trans-unit id="9c8810dc35fa4f97c050123bbb12b1701dd4c349" translate="yes" xml:space="preserve">
          <source>In scenario 2, an error is detected during test &lt;code&gt;case B&lt;/code&gt; execution. This causes the test &lt;code&gt;case B&lt;/code&gt; function to generate an exception and, as a result, the test case process exits with reason other than normal. &lt;code&gt;Common Test&lt;/code&gt; logs this as an unsuccessful (Failed) test case.</source>
          <target state="translated">En el escenario 2, se detecta un error durante la ejecuci&amp;oacute;n del &lt;code&gt;case B&lt;/code&gt; prueba B. Esto hace que la funci&amp;oacute;n del &lt;code&gt;case B&lt;/code&gt; prueba B genere una excepci&amp;oacute;n y, como resultado, el proceso del caso de prueba finaliza con una raz&amp;oacute;n distinta a la normal. &lt;code&gt;Common Test&lt;/code&gt; registra esto como un caso de prueba fallido (fallido).</target>
        </trans-unit>
        <trans-unit id="2b01a41bac5f590a4587dab197accc292b0c3e3d" translate="yes" xml:space="preserve">
          <source>In section about myths, the following myth was exposed: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En la secci&amp;oacute;n sobre mitos, se expuso el siguiente mito: &lt;code&gt;&lt;a href=&quot;myths#tail_recursive&quot;&gt;Tail-Recursive Functions are Much Faster Than Recursive Functions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b130fa00d240c9e2022bf6895671a7967856f662" translate="yes" xml:space="preserve">
          <source>In short, the &lt;code&gt;DebugType&lt;/code&gt; is intended for debugging only. Logs during production are better produced with the standard Erlang logging facilities.</source>
          <target state="translated">En resumen, &lt;code&gt;DebugType&lt;/code&gt; est&amp;aacute; dise&amp;ntilde;ado solo para depurar. Los troncos durante la producci&amp;oacute;n se producen mejor con las instalaciones de registro est&amp;aacute;ndar de Erlang.</target>
        </trans-unit>
        <trans-unit id="fa32d137f104b735ab84633f3591ddf26cbba0ca" translate="yes" xml:space="preserve">
          <source>In short:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71afdcc8f1caaa6350eb14b1d2094d34265774c1" translate="yes" xml:space="preserve">
          <source>In some applications, it can be unacceptable that replies from individual logs are ignored. An alternative in such situations is to use many local disk logs instead of one distributed disk log, and implement the distribution without use of the &lt;code&gt;disk_log&lt;/code&gt; module.</source>
          <target state="translated">En algunas aplicaciones, puede resultar inaceptable que se ignoren las respuestas de los registros individuales. Una alternativa en tales situaciones es usar muchos registros de disco local en lugar de un registro de disco distribuido e implementar la distribuci&amp;oacute;n sin usar el m&amp;oacute;dulo &lt;code&gt;disk_log&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3864ea2cdbd0987d0b4fb5eb5813e04593cf37fa" translate="yes" xml:space="preserve">
          <source>In some aspects the Erlang MIB compiler does not follow or implement the SMI fully. Here are the differences:</source>
          <target state="translated">En algunos aspectos el compilador MIB de Erlang no sigue o implementa el SMI completamente.Aquí están las diferencias:</target>
        </trans-unit>
        <trans-unit id="c9e14d58e80ba98377364e8269565a9b4e7f56ca" translate="yes" xml:space="preserve">
          <source>In some aspects the agent does not implement SNMP fully. Here are the differences:</source>
          <target state="translated">En algunos aspectos el agente no implementa el SNMP completamente.Aquí están las diferencias:</target>
        </trans-unit>
        <trans-unit id="397a384c819c2af0e32f82dcacb93ab35d42b161" translate="yes" xml:space="preserve">
          <source>In some cases, the Erlang syntax rules make it impossible to place a metavariable directly where you would like it. For example, you cannot write:</source>
          <target state="translated">En algunos casos,las reglas de la sintaxis de Erlang hacen imposible colocar una metavariable directamente donde se desea.Por ejemplo,no puedes escribir:</target>
        </trans-unit>
        <trans-unit id="c076f1de5baca283848280a649a2179b83e38d01" translate="yes" xml:space="preserve">
          <source>In some circumstances, the select/match operations do not need to scan the complete table. For example, if part of the key is bound when searching an &lt;code&gt;ordered_set&lt;/code&gt; table, or if it is a Mnesia table and there is a secondary index on the field that is selected/matched. If the key is fully bound, there is no point in doing a select/match, unless you have a bag table and are only interested in a subset of the elements with the specific key.</source>
          <target state="translated">En algunas circunstancias, las operaciones de selecci&amp;oacute;n / coincidencia no necesitan escanear la tabla completa. Por ejemplo, si parte de la clave est&amp;aacute; vinculada al buscar una tabla &lt;code&gt;ordered_set&lt;/code&gt; , o si es una tabla Mnesia y hay un &amp;iacute;ndice secundario en el campo que est&amp;aacute; seleccionado / emparejado. Si la clave est&amp;aacute; completamente vinculada, no tiene sentido hacer una selecci&amp;oacute;n / coincidencia, a menos que tenga una tabla de bolsa y solo est&amp;eacute; interesado en un subconjunto de los elementos con la clave espec&amp;iacute;fica.</target>
        </trans-unit>
        <trans-unit id="f29229d853517e42e24b621374f22a9695122f0f" translate="yes" xml:space="preserve">
          <source>In some contexts, only a string or an integer is allowed. For example, the directive &lt;code&gt;-file(Name, Line)&lt;/code&gt; requires that &lt;code&gt;Name&lt;/code&gt; is a string literal and &lt;code&gt;Line&lt;/code&gt; an integer literal:</source>
          <target state="translated">En algunos contextos, solo se permite una cadena o un n&amp;uacute;mero entero. Por ejemplo, la directiva &lt;code&gt;-file(Name, Line)&lt;/code&gt; requiere que &lt;code&gt;Name&lt;/code&gt; sea ​​un literal de cadena y &lt;code&gt;Line&lt;/code&gt; un literal entero:</target>
        </trans-unit>
        <trans-unit id="5a6b075e8a7cbcdea6adcceaf8693e0b814b7a53" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;locked&lt;/code&gt;, when a button is pressed, it is collected with the last pressed buttons up to the length of the correct code, and compared with the correct code. Depending on the result, the door is either unlocked and the &lt;code&gt;gen_statem&lt;/code&gt; goes to state &lt;code&gt;open&lt;/code&gt;, or the door remains in state &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">En el estado &lt;code&gt;locked&lt;/code&gt; , cuando se presiona un bot&amp;oacute;n, se recopila con los &amp;uacute;ltimos botones presionados hasta la longitud del c&amp;oacute;digo correcto y se compara con el c&amp;oacute;digo correcto. Dependiendo del resultado, la puerta se desbloquea y &lt;code&gt;gen_statem&lt;/code&gt; pasa al estado &lt;code&gt;open&lt;/code&gt; , o la puerta permanece en el estado &lt;code&gt;locked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9b6767bf0caff1be872c1139fc4118f63dc8ef9" translate="yes" xml:space="preserve">
          <source>In state &lt;code&gt;open&lt;/code&gt;, a button event is ignored by staying in the same state. This can also be done by returning &lt;code&gt;{keep_state, Data}&lt;/code&gt; or in this case since &lt;code&gt;Data&lt;/code&gt; unchanged even by returning &lt;code&gt;keep_state_and_data&lt;/code&gt;.</source>
          <target state="translated">En estado &lt;code&gt;open&lt;/code&gt; , un evento de bot&amp;oacute;n se ignora permaneciendo en el mismo estado. Esto tambi&amp;eacute;n se puede hacer devolviendo &lt;code&gt;{keep_state, Data}&lt;/code&gt; o en este caso desde &lt;code&gt;Data&lt;/code&gt; sin cambios incluso devolviendo &lt;code&gt;keep_state_and_data&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96ad0dfc8fa4580e2165853ef7429bd0d01832d6" translate="yes" xml:space="preserve">
          <source>In systems which create and delete &lt;strong&gt;many&lt;/strong&gt; sockets dynamically, it (the socket registry) could become a bottleneck. For such systems, there are a couple of ways to control the use of the socket registry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bdfbdd981c77f7212c651d17f2cefab1fd90c79" translate="yes" xml:space="preserve">
          <source>In systems with many processes, computation tasks that run for a short time can be spawned off into a new process with a higher minimum heap size. When the process is done, it sends the result of the computation to another process and terminates. If the minimum heap size is calculated properly, the process might not have to do any garbage collections at all. &lt;strong&gt;This optimization is not to be attempted without proper measurements.&lt;/strong&gt;</source>
          <target state="translated">En sistemas con muchos procesos, las tareas de c&amp;aacute;lculo que se ejecutan durante un tiempo breve pueden generarse en un nuevo proceso con un tama&amp;ntilde;o de pila m&amp;iacute;nimo m&amp;aacute;s alto. Cuando finaliza el proceso, env&amp;iacute;a el resultado del c&amp;aacute;lculo a otro proceso y termina. Si el tama&amp;ntilde;o de pila m&amp;iacute;nimo se calcula correctamente, es posible que el proceso no tenga que realizar ninguna recolecci&amp;oacute;n de elementos no utilizados. &lt;strong&gt;Esta optimizaci&amp;oacute;n no debe intentarse sin las medidas adecuadas.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="5746b70053e6262729b091cf67ef85a9f8ac776b" translate="yes" xml:space="preserve">
          <source>In telecommunications applications, there are different needs from the features provided by traditional DBMSs. The applications now implemented in Erlang need a mixture of a broad range of features, which generally are not satisfied by traditional DBMSs. Mnesia is designed with requirements like the following in mind:</source>
          <target state="translated">En las aplicaciones de telecomunicaciones,hay necesidades diferentes de las características que ofrecen los SGBD tradicionales.Las aplicaciones que ahora se implementan en Erlang necesitan una mezcla de una amplia gama de características,que generalmente no son satisfechas por los SGBD tradicionales.Mnesia está diseñado teniendo en cuenta requisitos como los siguientes:</target>
        </trans-unit>
        <trans-unit id="63011c7dfba9e10fc95124eaa2d33e3e8a0fca83" translate="yes" xml:space="preserve">
          <source>In the 32-bit implementation of Erlang, 536,870,911 bytes is the largest binary that can be constructed or matched using the bit syntax. In the 64-bit implementation, the maximum size is 2,305,843,009,213,693,951 bytes. If the limit is exceeded, bit syntax construction fails with a &lt;code&gt;system_limit&lt;/code&gt; exception, while any attempt to match a binary that is too large fails. This limit is enforced starting in R11B-4.</source>
          <target state="translated">En la implementaci&amp;oacute;n de 32 bits de Erlang, 536,870,911 bytes es el binario m&amp;aacute;s grande que se puede construir o emparejar usando la sintaxis de bits. En la implementaci&amp;oacute;n de 64 bits, el tama&amp;ntilde;o m&amp;aacute;ximo es 2,305,843,009,213,693,951 bytes. Si se excede el l&amp;iacute;mite, la construcci&amp;oacute;n de la sintaxis de bits falla con una excepci&amp;oacute;n &lt;code&gt;system_limit&lt;/code&gt; , mientras que cualquier intento de hacer coincidir un binario que es demasiado grande falla. Este l&amp;iacute;mite se aplica a partir de R11B-4.</target>
        </trans-unit>
        <trans-unit id="3b10f4238d4a411f4fac664bc42d174316e288c7" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchBody&lt;/code&gt; and &lt;code&gt;MatchCondition&lt;/code&gt; parts, only variables bound previously can be used.</source>
          <target state="translated">En las partes &lt;code&gt;MatchBody&lt;/code&gt; y &lt;code&gt;MatchCondition&lt;/code&gt; , solo se pueden usar variables vinculadas previamente.</target>
        </trans-unit>
        <trans-unit id="99f811cb87197b615b54046fe0178bf192579602" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, no unbound variables are allowed, so &lt;code&gt;'_'&lt;/code&gt; is interpreted as itself (an atom). Variables can only be bound in the &lt;code&gt;MatchHead&lt;/code&gt; part.</source>
          <target state="translated">En las partes &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; , no se permiten variables independientes , por lo que &lt;code&gt;'_'&lt;/code&gt; se interpreta como s&amp;iacute; mismo (un &amp;aacute;tomo). Las variables solo se pueden vincular en la parte &lt;code&gt;MatchHead&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41acf373b0923e27303ed2d9e613e3b6bc78210e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts, the interpretation is in some ways different. Literals in these parts can either be written &quot;as is&quot;, which works for all literals except tuples, or by using the special form &lt;code&gt;{const, T}&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is any Erlang term.</source>
          <target state="translated">En las partes &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; , la interpretaci&amp;oacute;n es diferente en algunos aspectos. Los literales en estas partes se pueden escribir &quot;tal cual&quot;, que funciona para todos los literales excepto tuplas, o usando la forma especial &lt;code&gt;{const, T}&lt;/code&gt; , donde &lt;code&gt;T&lt;/code&gt; es cualquier t&amp;eacute;rmino de Erlang.</target>
        </trans-unit>
        <trans-unit id="eb2046d2d5da3268f8e80e9b5760d8733ac6af46" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;MatchHead&lt;/code&gt; part, all literals (except the variables above) are interpreted &quot;as is&quot;.</source>
          <target state="translated">En la parte &lt;code&gt;MatchHead&lt;/code&gt; , todos los literales (excepto las variables anteriores) se interpretan &quot;tal cual&quot;.</target>
        </trans-unit>
        <trans-unit id="62822ca5758004378978f550b70109b8f746b1ba" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;compiler&lt;/code&gt; application, in the file &lt;code&gt;genop.tab&lt;/code&gt;, there is the following line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed8257c1305383c9e32994b91f6e1b51ce6d911e" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;do_perm&lt;/code&gt; we do the work, operating on the structure that was allocated in &lt;code&gt;output&lt;/code&gt;.</source>
          <target state="translated">En &lt;code&gt;do_perm&lt;/code&gt; hacemos el trabajo, operando en la estructura que se asign&amp;oacute; en la &lt;code&gt;output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e01e7a071ebc59bede92c3c9744f0cd30d2569a" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; example above, it is needed to include &lt;code&gt;ms_transform.hrl&lt;/code&gt; in the source code, as this is what triggers the parse transformation of the &lt;code&gt;ets:fun2ms/1&lt;/code&gt; call to a valid match specification. This also implies that the transformation is done at compile time (except when called from the shell) and therefore takes no resources in runtime. That is, although you use the more intuitive fun syntax, it gets as efficient in runtime as writing match specifications by hand.</source>
          <target state="translated">En el ejemplo de &lt;code&gt;ets:fun2ms/1&lt;/code&gt; anterior, es necesario incluir &lt;code&gt;ms_transform.hrl&lt;/code&gt; en el c&amp;oacute;digo fuente, ya que esto es lo que desencadena la transformaci&amp;oacute;n de an&amp;aacute;lisis de la llamada &lt;code&gt;ets:fun2ms/1&lt;/code&gt; a una especificaci&amp;oacute;n de coincidencia v&amp;aacute;lida. Esto tambi&amp;eacute;n implica que la transformaci&amp;oacute;n se realiza en tiempo de compilaci&amp;oacute;n (excepto cuando se llama desde el shell) y, por lo tanto, no requiere recursos en tiempo de ejecuci&amp;oacute;n. Es decir, aunque usa la sintaxis divertida m&amp;aacute;s intuitiva, se vuelve tan eficiente en tiempo de ejecuci&amp;oacute;n como escribir especificaciones de coincidencia a mano.</target>
        </trans-unit>
        <trans-unit id="11d9a975fdf9d1a5bae2119da6072d890e6e6ea9" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;main&lt;/code&gt; function, the C program is to listen for a message from Erlang and, according to the selected encoding/decoding scheme, use the first byte to determine which function to call and the second byte as argument to the function. The result of calling the function is then to be sent back to Erlang:</source>
          <target state="translated">En la funci&amp;oacute;n &lt;code&gt;main&lt;/code&gt; , el programa C es escuchar un mensaje de Erlang y, de acuerdo con el esquema de codificaci&amp;oacute;n / decodificaci&amp;oacute;n seleccionado, usa el primer byte para determinar qu&amp;eacute; funci&amp;oacute;n llamar y el segundo byte como argumento para la funci&amp;oacute;n. El resultado de llamar a la funci&amp;oacute;n se enviar&amp;aacute; de vuelta a Erlang:</target>
        </trans-unit>
        <trans-unit id="a69877ecee07d6d60ef5a7f12b95eb172cfc8ddd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;option&lt;/code&gt; info tuple are only the options included that differs from the default values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="925920f982694555a077da19c74dabd56f931884" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ready_async&lt;/code&gt; function the output is sent back to the emulator. We use the driver term format instead of &lt;code&gt;ei&lt;/code&gt;. This is the only way to send Erlang terms directly to a driver, without having the Erlang code to call &lt;code&gt;binary_to_term/1&lt;/code&gt;. In the simple example this works well, and we do not need to use &lt;code&gt;ei&lt;/code&gt; to handle the binary term format.</source>
          <target state="translated">En la funci&amp;oacute;n &lt;code&gt;ready_async&lt;/code&gt; , la salida se env&amp;iacute;a de vuelta al emulador. Usamos el formato de t&amp;eacute;rmino del controlador en lugar de &lt;code&gt;ei&lt;/code&gt; . Esta es la &amp;uacute;nica forma de enviar t&amp;eacute;rminos de Erlang directamente a un controlador, sin tener el c&amp;oacute;digo Erlang para llamar a &lt;code&gt;binary_to_term/1&lt;/code&gt; . En el ejemplo simple, esto funciona bien y no es necesario usar &lt;code&gt;ei&lt;/code&gt; para manejar el formato de t&amp;eacute;rmino binario.</target>
        </trans-unit>
        <trans-unit id="262d5d76fc96e92282d6cd6556cb095d00a57bcd" translate="yes" xml:space="preserve">
          <source>In the &lt;code&gt;ssh.app&lt;/code&gt; file, in the &lt;code&gt;env&lt;/code&gt; part</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b368b60ecb50d01986bb37bad72bc40dc4e4d86a" translate="yes" xml:space="preserve">
          <source>In the API of Megaco, a user may explicitly send action requests, but generation of transaction identifiers, the encoding and actual transport of the message to the remote user is handled automatically by the protocol engine according to the actual connection configuration. Megaco messages are not exposed in the API.</source>
          <target state="translated">En la API de Megaco,un usuario puede enviar explícitamente solicitudes de acción,pero la generación de identificadores de transacción,la codificación y el transporte real del mensaje al usuario remoto se gestiona automáticamente por el motor de protocolo según la configuración real de la conexión.Los mensajes de Megaco no están expuestos en la API.</target>
        </trans-unit>
        <trans-unit id="298b6692a18a71c353c5cf532d8e68a0d659e314" translate="yes" xml:space="preserve">
          <source>In the Erlang Run-time System entities are only run in parallel when there are multiple schedulers. Therefore &lt;code&gt;lcnt&lt;/code&gt; will show more contention points (and thus be more useful) on systems using many schedulers on many cores.</source>
          <target state="translated">En Erlang Run-time System, las entidades solo se ejecutan en paralelo cuando hay varios programadores. Por &lt;code&gt;lcnt&lt;/code&gt; tanto, lcnt mostrar&amp;aacute; m&amp;aacute;s puntos de contenci&amp;oacute;n (y por lo tanto ser&amp;aacute; m&amp;aacute;s &amp;uacute;til) en sistemas que usan muchos programadores en muchos n&amp;uacute;cleos.</target>
        </trans-unit>
        <trans-unit id="23d80f2c0541f925401a28d1d9dadf53dc345fcf" translate="yes" xml:space="preserve">
          <source>In the Kernel application:</source>
          <target state="translated">En la aplicación del núcleo:</target>
        </trans-unit>
        <trans-unit id="b82356bcf2624a74da6a8c951ecd46a6c4f7a6d9" translate="yes" xml:space="preserve">
          <source>In the Mnesia tables, the two key columns are stored as a tuple with two elements. Therefore, the arity of the table is 3.</source>
          <target state="translated">En las tablas de Mnesia,las dos columnas clave se almacenan como una tupla con dos elementos.Por lo tanto,la aridez de la tabla es 3.</target>
        </trans-unit>
        <trans-unit id="ebfbe0fc7007783959fb235364ad702572537213" translate="yes" xml:space="preserve">
          <source>In the POSIX.2 compliant library that was included in 4.4BSD Unix, the ugly syntax [[:&amp;lt;:]] and [[:&amp;gt;:]] is used for matching &quot;start of word&quot; and &quot;end of word&quot;. PCRE treats these items as follows:</source>
          <target state="translated">En la biblioteca compatible con POSIX.2 que se incluy&amp;oacute; en 4.4BSD Unix, la sintaxis fea [[: &amp;lt;:]] y [[:&amp;gt;:]] se usa para hacer coincidir &quot;inicio de palabra&quot; y &quot;final de palabra&quot;. PCRE trata estos elementos de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="989093a9ff881dd98b2952b19cfa00d3c661d058" translate="yes" xml:space="preserve">
          <source>In the PRF (pseud-random function) to generate keying materials in cipher suites not using PFS.</source>
          <target state="translated">En el PRF (función pseudo-aleatoria)para generar materiales de tecleado en suites de cifrado que no usan PFS.</target>
        </trans-unit>
        <trans-unit id="a4c5b7bf87ece22cd2bc2e60bd8ae9d3bd13b0c4" translate="yes" xml:space="preserve">
          <source>In the SSL application, an extra distribution module, &lt;code&gt;inet_tls_dist&lt;/code&gt;, can be used as an alternative. All distribution connections will use TLS and all participating Erlang nodes in a distributed system must use this distribution module.</source>
          <target state="translated">En la aplicaci&amp;oacute;n SSL , se puede utilizar como alternativa un m&amp;oacute;dulo de distribuci&amp;oacute;n adicional, &lt;code&gt;inet_tls_dist&lt;/code&gt; . Todas las conexiones de distribuci&amp;oacute;n usar&amp;aacute;n TLS y todos los nodos Erlang participantes en un sistema distribuido deben usar este m&amp;oacute;dulo de distribuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="84201f881a1979b920fa1a6166421647fdc90516" translate="yes" xml:space="preserve">
          <source>In the STDLIB application:</source>
          <target state="translated">En la aplicación STDLIB:</target>
        </trans-unit>
        <trans-unit id="52bac5408693eade80ce363b1a7a4df7f8aaf59f" translate="yes" xml:space="preserve">
          <source>In the above example, &quot;pong&quot; was first created to be able to give the identity of &quot;pong&quot; when &quot;ping&quot; was started. That is, in some way &quot;ping&quot; must be able to know the identity of &quot;pong&quot; to be able to send a message to it. Sometimes processes which need to know each other's identities are started independently of each other. Erlang thus provides a mechanism for processes to be given names so that these names can be used as identities instead of pids. This is done by using the &lt;code&gt;register&lt;/code&gt; BIF:</source>
          <target state="translated">En el ejemplo anterior, &quot;pong&quot; se cre&amp;oacute; primero para poder dar la identidad de &quot;pong&quot; cuando se inici&amp;oacute; &quot;ping&quot;. Es decir, de alguna manera &quot;ping&quot; debe poder conocer la identidad de &quot;pong&quot; para poder enviarle un mensaje. A veces, los procesos que necesitan conocer las identidades de los dem&amp;aacute;s se inician independientemente unos de otros. Erlang proporciona as&amp;iacute; un mecanismo para que los procesos reciban nombres de modo que estos nombres puedan usarse como identidades en lugar de pids. Esto se hace utilizando el &lt;code&gt;register&lt;/code&gt; BIF:</target>
        </trans-unit>
        <trans-unit id="e32e6dd34c52e0e8f5c4ffcf8e60b4a055b8ae5e" translate="yes" xml:space="preserve">
          <source>In the above example, the small binary &lt;code&gt;B&lt;/code&gt; was copied while the larger binary &lt;code&gt;C&lt;/code&gt; references binary &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd30adfebd9b33e07add4e9cc9b71db937dd48cf" translate="yes" xml:space="preserve">
          <source>In the absence of spawn operation failures, atomically sets up a monitor to the newly created process. That is, as if the calling process had called &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor(process, Pid)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Pid&lt;/code&gt; is the process identifier of the newly created process. The &lt;code&gt;ReqId&lt;/code&gt; returned by &lt;code&gt;spawn_request()&lt;/code&gt; is also used as monitor reference as if it was returned from &lt;code&gt;monitor(process, Pid)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57dd227aa1b46ca58edc64f34bfe2c72905f27d3" translate="yes" xml:space="preserve">
          <source>In the basic scenario, each user loads the driver before starting to use it and unloads the driver when done. The reference counting keeps track of processes and the number of loads by each process. This way the driver is only unloaded when no one wants it (it has no user). The driver also keeps track of ports that are opened to it. This enables delay of unloading until all ports are closed, or killing of all ports that use the driver when it is unloaded.</source>
          <target state="translated">En el escenario básico,cada usuario carga el conductor antes de empezar a usarlo y lo descarga cuando termina.El recuento de referencia lleva un registro de los procesos y el número de cargas por cada proceso.De esta manera el conductor sólo se descarga cuando nadie lo quiere (no tiene usuario).El conductor también lleva un registro de los puertos que se le abren.Esto permite retrasar la descarga hasta que todos los puertos estén cerrados,o matar a todos los puertos que utilizan el conductor cuando se descarga.</target>
        </trans-unit>
        <trans-unit id="df529efdc563ccb1cce8f88844c159e25b52362e" translate="yes" xml:space="preserve">
          <source>In the case above the file is fetched from the same directory as all the other files in the messenger example. (*manual*).</source>
          <target state="translated">En el caso anterior,el archivo se obtiene del mismo directorio que todos los demás archivos del ejemplo del mensajero.(*manual*).</target>
        </trans-unit>
        <trans-unit id="90e65d7cbc556bc107498d3f0738eba580fff797" translate="yes" xml:space="preserve">
          <source>In the case of an upgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;Vsn&lt;/code&gt;, and in the case of a downgrade, &lt;code&gt;OldVsn&lt;/code&gt; is &lt;code&gt;{down,Vsn}&lt;/code&gt;. &lt;code&gt;Vsn&lt;/code&gt; is defined by the &lt;code&gt;vsn&lt;/code&gt; attribute(s) of the old version of the callback module &lt;code&gt;Module&lt;/code&gt;. If no such attribute is defined, the version is the checksum of the BEAM file.</source>
          <target state="translated">En el caso de una actualizaci&amp;oacute;n, &lt;code&gt;OldVsn&lt;/code&gt; es &lt;code&gt;Vsn&lt;/code&gt; , y en el caso de una degradaci&amp;oacute;n, &lt;code&gt;OldVsn&lt;/code&gt; es &lt;code&gt;{down,Vsn}&lt;/code&gt; . &lt;code&gt;Vsn&lt;/code&gt; est&amp;aacute; definido por los atributos &lt;code&gt;vsn&lt;/code&gt; de la versi&amp;oacute;n anterior del m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada &lt;code&gt;Module&lt;/code&gt; . Si no se define tal atributo, la versi&amp;oacute;n es la suma de comprobaci&amp;oacute;n del archivo BEAM.</target>
        </trans-unit>
        <trans-unit id="7d0cc696cff1dc6d55003eac20e57212616d1c53" translate="yes" xml:space="preserve">
          <source>In the case of reply, megaco will cancel the reply and information of this will be returned to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En el caso de respuesta, megaco cancelar&amp;aacute; la respuesta y la informaci&amp;oacute;n de esta ser&amp;aacute; devuelta al usuario mediante una llamada a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;&lt;a href=&quot;megaco_user#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a023129e0eddda980464097d8136ae978852b44a" translate="yes" xml:space="preserve">
          <source>In the case of requests, megaco will cancel the message in much the same way as if &lt;code&gt;megaco:cancel&lt;/code&gt; had been called (after a successfull send). The information will be propagated back to the user differently depending on how the request(s) where issued: For requests issued using &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt;, the info will be delivered in the return value. For requests issued using &lt;code&gt;megaco:cast&lt;/code&gt; the info will be delivered via a call to the callback function &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En el caso de las solicitudes, megaco cancelar&amp;aacute; el mensaje de la misma manera que si se hubiera llamado a &lt;code&gt;megaco:cancel&lt;/code&gt; (despu&amp;eacute;s de un env&amp;iacute;o exitoso). La informaci&amp;oacute;n se propagar&amp;aacute; de regreso al usuario de manera diferente dependiendo de c&amp;oacute;mo se emitieron las solicitudes: Para las solicitudes emitidas usando &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;megaco:call&lt;/a&gt;&lt;/code&gt; , la informaci&amp;oacute;n se entregar&amp;aacute; en el valor de devoluci&amp;oacute;n. Para solicitudes emitidas con &lt;code&gt;megaco:cast&lt;/code&gt; , la informaci&amp;oacute;n se entregar&amp;aacute; mediante una llamada a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="21b9a12bb9f423b38a3470e9cb22b9a9da365cf3" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;File&lt;/code&gt;, the printable megaco trace events will be printed to the file &lt;code&gt;File&lt;/code&gt; using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">En el caso de que &lt;code&gt;Destination&lt;/code&gt; sea &lt;code&gt;File&lt;/code&gt; , los eventos de seguimiento de megaco imprimibles se imprimir&amp;aacute;n en el archivo &lt;code&gt;File&lt;/code&gt; usando &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8cfb3597ea67b1de6cbbe1cc8f574a9fb6b0be7" translate="yes" xml:space="preserve">
          <source>In the case when &lt;code&gt;Destination&lt;/code&gt; is &lt;code&gt;io&lt;/code&gt;, the printable megaco trace events will be printed on stdout using plain &lt;code&gt;io:format/2&lt;/code&gt;.</source>
          <target state="translated">En el caso de que &lt;code&gt;Destination&lt;/code&gt; sea &lt;code&gt;io&lt;/code&gt; , los eventos de seguimiento de megaco imprimibles se imprimir&amp;aacute;n en la salida est&amp;aacute;ndar usando &lt;code&gt;io:format/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3e58c5c2505dec49b18b9e8525ca602801333f" translate="yes" xml:space="preserve">
          <source>In the case when its not possible to immediately establish a connection, the function will return with the &lt;code&gt;&lt;a href=&quot;#type-select_info&quot;&gt;SelectInfo&lt;/a&gt;&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;, a subsequent call to connect will then establish the connection).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c8b3e1fd01d3f8565818024d0b3a52c9cf2017" translate="yes" xml:space="preserve">
          <source>In the case when the pdu type is &lt;code&gt;report&lt;/code&gt;, &lt;code&gt;MsgData&lt;/code&gt; is either &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt;.</source>
          <target state="translated">En el caso de que el tipo pdu sea &lt;code&gt;report&lt;/code&gt; , &lt;code&gt;MsgData&lt;/code&gt; est&amp;aacute; &lt;code&gt;ok&lt;/code&gt; o &lt;code&gt;{error, ReqId, Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42c6fc4cd12daba8d11cdd4982445015e66db822" translate="yes" xml:space="preserve">
          <source>In the case when there is no connections waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when a client connects (a subsequent call to accept will then return the socket).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b308070b86e9f2f5cfb71e46c5c56ad9f43c5a" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recv will then return the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c310b42286356d0fc14eede396b80bde97e8a3eb" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvfrom will then return the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79a9e35d675f34065de5084906faf62c1cb4d28b" translate="yes" xml:space="preserve">
          <source>In the case when there is no data waiting, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when data has arrived (a subsequent call to recvmsg will then return the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79128b360c469ba004c95bafdca01e1b34773296" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to send will then send the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8a00bf019c9ad7cc3ae0aa6563d03144ab91886" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendmsg will then send the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67338ab252943970a15e1afbfd3aa9bc7bd17164" translate="yes" xml:space="preserve">
          <source>In the case when there is no room in the (system-) buffers, the function will return with the &lt;code&gt;SelectInfo&lt;/code&gt;. The caller can then await a select message, &lt;code&gt;{'$socket', Socket, select, Info}&lt;/code&gt; (where &lt;code&gt;Info&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;socket#type-select_ref&quot;&gt;ref&lt;/a&gt;&lt;/code&gt; field from the &lt;code&gt;SelectInfo&lt;/code&gt;), when there is room for more data (a subsequent call to sendto will then send the data).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ee63650ddd58f0ca509c96964f035623c7960f3" translate="yes" xml:space="preserve">
          <source>In the code fragment in the beginning of this section, appending to &lt;code&gt;Bin&lt;/code&gt; will be cheap, while appending to &lt;code&gt;Bin0&lt;/code&gt; will force the creation of a new binary and copying of the contents of &lt;code&gt;Bin0&lt;/code&gt;.</source>
          <target state="translated">En el fragmento de c&amp;oacute;digo al comienzo de esta secci&amp;oacute;n, agregar a &lt;code&gt;Bin&lt;/code&gt; ser&amp;aacute; barato, mientras que &lt;code&gt;Bin0&lt;/code&gt; a Bin0 forzar&amp;aacute; la creaci&amp;oacute;n de un nuevo binario y la copia del contenido de &lt;code&gt;Bin0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="245dbc6eca2c173af60f0ff749e12a7fd20aabc1" translate="yes" xml:space="preserve">
          <source>In the configuration above we first raise the primary log level to max in order for the debug log events to get to the handlers. Then we configure the default handler to only log notice and below events, the default log level for a handler is &lt;code&gt;all&lt;/code&gt;. Then the debug handler is configured with a filter to stop any log message that is not a debug level message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70fe2afb28a7f768680b296f55f18eec13083414" translate="yes" xml:space="preserve">
          <source>In the cover specification file you can also specify your required level of the code coverage analysis; &lt;code&gt;details&lt;/code&gt; or &lt;code&gt;overview&lt;/code&gt;. In detailed mode, you get a coverage overview page, showing per module and total coverage percentages. You also get an HTML file printed for each module included in the analysis showing exactly what parts of the code have been executed during the test. In overview mode, only the code coverage overview page is printed.</source>
          <target state="translated">En el archivo de especificaciones de portada tambi&amp;eacute;n puede especificar el nivel requerido de an&amp;aacute;lisis de cobertura de c&amp;oacute;digo; &lt;code&gt;details&lt;/code&gt; o &lt;code&gt;overview&lt;/code&gt; . En el modo detallado, obtiene una p&amp;aacute;gina de descripci&amp;oacute;n general de la cobertura, que muestra los porcentajes de cobertura total y por m&amp;oacute;dulo. Tambi&amp;eacute;n obtiene un archivo HTML impreso para cada m&amp;oacute;dulo incluido en el an&amp;aacute;lisis que muestra exactamente qu&amp;eacute; partes del c&amp;oacute;digo se han ejecutado durante la prueba. En el modo de descripci&amp;oacute;n general, solo se imprime la p&amp;aacute;gina de descripci&amp;oacute;n general de la cobertura del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="efa59b939ca7fccac1b4966896f1376a9f0ecc3d" translate="yes" xml:space="preserve">
          <source>In the current &lt;code&gt;Common Test&lt;/code&gt; version, the &lt;code&gt;silent_connections&lt;/code&gt; feature only works for Telnet and SSH connections. Support for other connection types can be added in future &lt;code&gt;Common Test&lt;/code&gt; versions.</source>
          <target state="translated">En la versi&amp;oacute;n actual de &lt;code&gt;Common Test&lt;/code&gt; , la funci&amp;oacute;n &lt;code&gt;silent_connections&lt;/code&gt; solo funciona para conexiones Telnet y SSH. Se puede agregar soporte para otros tipos de conexi&amp;oacute;n en futuras versiones de &lt;code&gt;Common Test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f73dc5c892d68a89b94a3b2e5ccad17a219943e" translate="yes" xml:space="preserve">
          <source>In the current implementation of the Erlang/SCTP binding, this event is internally converted into an &lt;code&gt;error&lt;/code&gt; term returned by &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En la implementaci&amp;oacute;n actual del enlace Erlang / SCTP, este evento se convierte internamente en un t&amp;eacute;rmino de &lt;code&gt;error&lt;/code&gt; devuelto por &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv/*&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15e2dc3213e7a3c0466f5bd2cdaed33bfcb2675a" translate="yes" xml:space="preserve">
          <source>In the current implementation, every object insert and look-up operation results in a copy of the object.</source>
          <target state="translated">En la implementación actual,cada operación de inserción y búsqueda de objetos da como resultado una copia del objeto.</target>
        </trans-unit>
        <trans-unit id="791527ae8adb388933b027054a83b83e825d6a65" translate="yes" xml:space="preserve">
          <source>In the current version &lt;code&gt;CurVsn&lt;/code&gt; of a release, the application directory of &lt;code&gt;myapp&lt;/code&gt; is &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt;. A new version &lt;code&gt;NewVsn&lt;/code&gt; is unpacked outside the release handler and the release handler is informed about this with a call as follows:</source>
          <target state="translated">En la versi&amp;oacute;n actual &lt;code&gt;CurVsn&lt;/code&gt; de un lanzamiento, el directorio de aplicaciones de &lt;code&gt;myapp&lt;/code&gt; es &lt;code&gt;$ROOT/lib/myapp-1.0&lt;/code&gt; . Una nueva versi&amp;oacute;n &lt;code&gt;NewVsn&lt;/code&gt; se desempaqueta fuera del controlador de versiones y se informa al controlador de versiones sobre esto con una llamada de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="126027e83a4fcabb438ac0508be585805261c9aa" translate="yes" xml:space="preserve">
          <source>In the data directory, &lt;code&gt;data_dir&lt;/code&gt;, the test module has its own files needed for the testing. The name of &lt;code&gt;data_dir&lt;/code&gt; is the the name of the test suite followed by &lt;code&gt;&quot;_data&quot;&lt;/code&gt;. For example, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; has the data directory &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt;. Use this directory for portability, that is, to avoid hardcoding directory names in your suite. As the data directory is stored in the same directory as your test suite, you can rely on its existence at runtime, even if the path to your test suite directory has changed between test suite implementation and execution.</source>
          <target state="translated">En el directorio de datos, &lt;code&gt;data_dir&lt;/code&gt; , el m&amp;oacute;dulo de prueba tiene sus propios archivos necesarios para la prueba. El nombre de &lt;code&gt;data_dir&lt;/code&gt; es el nombre del conjunto de pruebas seguido de &lt;code&gt;&quot;_data&quot;&lt;/code&gt; . Por ejemplo, &lt;code&gt;&quot;some_path/foo_SUITE.beam&quot;&lt;/code&gt; tiene el directorio de datos &lt;code&gt;&quot;some_path/foo_SUITE_data/&quot;&lt;/code&gt; . Utilice este directorio para la portabilidad, es decir, para evitar codificar nombres de directorio en su suite. Como el directorio de datos se almacena en el mismo directorio que su suite de pruebas, puede confiar en su existencia en tiempo de ejecuci&amp;oacute;n, incluso si la ruta al directorio de su suite de pruebas ha cambiado entre la implementaci&amp;oacute;n y la ejecuci&amp;oacute;n de la suite de pruebas.</target>
        </trans-unit>
        <trans-unit id="1c079a4d60468994ef72384e15125e8d93afdf37" translate="yes" xml:space="preserve">
          <source>In the descriptions that follow, the form that is used to change the default value are listed.</source>
          <target state="translated">En las descripciones que siguen,se enumeran los formularios que se utilizan para cambiar el valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="4e06544c66c34c090ef2dd2b38c431c2b495f098" translate="yes" xml:space="preserve">
          <source>In the detailed information window for a node, any existing links and monitors between processes on the originating node and the connected node are displayed. &lt;strong&gt;Extra Info&lt;/strong&gt; can contain debug information (that is, special information written if the emulator is debug-compiled) or error information.</source>
          <target state="translated">En la ventana de informaci&amp;oacute;n detallada de un nodo, se muestran los enlaces y monitores existentes entre los procesos del nodo de origen y el nodo conectado. &lt;strong&gt;Informaci&amp;oacute;n adicional&lt;/strong&gt; puede contener informaci&amp;oacute;n de depuraci&amp;oacute;n (es decir, informaci&amp;oacute;n especial escrita si el emulador est&amp;aacute; compilado para depuraci&amp;oacute;n) o informaci&amp;oacute;n de error.</target>
        </trans-unit>
        <trans-unit id="8ba5880443f43a3af428d4fbb8404826ac0d26fd" translate="yes" xml:space="preserve">
          <source>In the end, the C compiler will probably optimize this code to the same native code as the first version, but the first version is certainly much easier to read for human readers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14e4ef55ecc440a106bcf9a15acab47c72a79a18" translate="yes" xml:space="preserve">
          <source>In the erl command line:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe10364408e4f6b1e20c24b12efb18fb322cbcc9" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period are to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4da5bd1aa9e79875ba613d02238e60ec877667a6" translate="yes" xml:space="preserve">
          <source>In the event manager, zero, one, or many &lt;strong&gt;event handlers&lt;/strong&gt; are installed. When the event manager is notified about an event, the event is processed by all the installed event handlers. For example, an event manager for handling errors can by default have a handler installed, which writes error messages to the terminal. If the error messages during a certain period is to be saved to a file as well, the user adds another event handler that does this. When logging to the file is no longer necessary, this event handler is deleted.</source>
          <target state="translated">En el administrador de eventos, se instalan cero, uno o muchos &lt;strong&gt;controladores de eventos&lt;/strong&gt; . Cuando el administrador de eventos recibe una notificaci&amp;oacute;n sobre un evento, todos los controladores de eventos instalados procesan el evento. Por ejemplo, un administrador de eventos para el manejo de errores puede tener instalado un controlador de manera predeterminada, que escribe mensajes de error en el terminal. Si los mensajes de error durante un per&amp;iacute;odo determinado tambi&amp;eacute;n se van a guardar en un archivo, el usuario agrega otro controlador de eventos que hace esto. Cuando ya no es necesario iniciar sesi&amp;oacute;n en el archivo, se elimina este controlador de eventos.</target>
        </trans-unit>
        <trans-unit id="8841b315d1e28c3d331ee376f7a7d69baa5c6c9d" translate="yes" xml:space="preserve">
          <source>In the example above the &lt;code&gt; &lt;strong&gt;on_load&lt;/strong&gt;&lt;/code&gt; directive is used get function &lt;code&gt;init&lt;/code&gt; called automatically when the module is loaded. Function &lt;code&gt;init&lt;/code&gt; in turn calls &lt;code&gt;&lt;a href=&quot;erlang#load_nif-2&quot;&gt;erlang:load_nif/2&lt;/a&gt;&lt;/code&gt; which loads the NIF library and replaces the &lt;code&gt;hello&lt;/code&gt; function with its native implementation in C. Once loaded, a NIF library is persistent. It will not be unloaded until the module code version that it belongs to is purged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="053d93ad21874bd7646e0f9e5ec91996c0b105b7" translate="yes" xml:space="preserve">
          <source>In the example above, valid &lt;code&gt;keys&lt;/code&gt; could be &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; and &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt;, whereas &lt;code&gt;&quot;hi&quot;&lt;/code&gt;, &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; and &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; would be invalid.</source>
          <target state="translated">En el ejemplo anterior, las &lt;code&gt;keys&lt;/code&gt; v&amp;aacute;lidas podr&amp;iacute;an ser &lt;code&gt;{&quot;hi&quot;, &quot;mom&quot;}&lt;/code&gt; y &lt;code&gt;{&quot;no&quot;, &quot;thanks&quot;}&lt;/code&gt; , mientras que &lt;code&gt;&quot;hi&quot;&lt;/code&gt; , &lt;code&gt;{&quot;hi&quot;, 42}&lt;/code&gt; y &lt;code&gt;{&quot;hello&quot;, &quot;there&quot;}&lt;/code&gt; no ser&amp;iacute;a v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="2fc7b559b47ea8932c9a1025d16c15176231ffae" translate="yes" xml:space="preserve">
          <source>In the example below, lines number 2,4,6,8 and 11 are executable lines:</source>
          <target state="translated">En el siguiente ejemplo,las líneas 2,4,6,8 y 11 son líneas ejecutables:</target>
        </trans-unit>
        <trans-unit id="194d855c8237df6928638ceec954bb4deb7ecf5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_server&lt;/code&gt; is started by calling &lt;code&gt;ch3:start_link()&lt;/code&gt;:</source>
          <target state="translated">En el ejemplo de la secci&amp;oacute;n anterior, &lt;code&gt;gen_server&lt;/code&gt; se inicia llamando a &lt;code&gt;ch3:start_link()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b9a0b9dbd81dc16f4bbd6ea7b8db17b1ce28ef5b" translate="yes" xml:space="preserve">
          <source>In the example in the previous section, &lt;code&gt;gen_statem&lt;/code&gt; is started by calling &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt;:</source>
          <target state="translated">En el ejemplo de la secci&amp;oacute;n anterior, &lt;code&gt;gen_statem&lt;/code&gt; se inicia llamando a &lt;code&gt;code_lock:start_link(Code)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4b4a36b06eda88b8723feb14b4b4c62ed1f4fdaf" translate="yes" xml:space="preserve">
          <source>In the example the Presented IDs are &lt;code&gt;example.com&lt;/code&gt; as well as hostnames matching &lt;code&gt;*.example.com&lt;/code&gt;. For example &lt;code&gt;foo.example.com&lt;/code&gt; and &lt;code&gt;bar.example.com&lt;/code&gt; both matches but not &lt;code&gt;foo.bar.example.com&lt;/code&gt;. The name &lt;code&gt;erlang.org&lt;/code&gt; matches neither since it is not a CN.</source>
          <target state="translated">En el ejemplo, los ID presentados son &lt;code&gt;example.com&lt;/code&gt; , as&amp;iacute; como los nombres de host que coinciden con &lt;code&gt;*.example.com&lt;/code&gt; . Por ejemplo, &lt;code&gt;foo.example.com&lt;/code&gt; y &lt;code&gt;bar.example.com&lt;/code&gt; coinciden, pero no &lt;code&gt;foo.bar.example.com&lt;/code&gt; . El nombre &lt;code&gt;erlang.org&lt;/code&gt; no coincide con ninguno ya que no es un CN.</target>
        </trans-unit>
        <trans-unit id="7bfbaeffabf4dcd6ae7bae0878c51517112f0368" translate="yes" xml:space="preserve">
          <source>In the example, &lt;code&gt;handle_debug&lt;/code&gt; is called for each incoming and outgoing message. The format function &lt;code&gt;Func&lt;/code&gt; is the function &lt;code&gt;ch4:write_debug/3&lt;/code&gt;, which prints the message using &lt;code&gt;io:format/3&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo, se llama a &lt;code&gt;handle_debug&lt;/code&gt; para cada mensaje entrante y saliente. La funci&amp;oacute;n de formato &lt;code&gt;Func&lt;/code&gt; es la funci&amp;oacute;n &lt;code&gt;ch4:write_debug/3&lt;/code&gt; , que imprime el mensaje usando &lt;code&gt;io:format/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ac68bd607f8264f012241fcc414c2e661fd6689b" translate="yes" xml:space="preserve">
          <source>In the example, component &lt;code&gt;number&lt;/code&gt; of the first of the encoded elements in the &lt;code&gt;SEQUENCE OF&lt;/code&gt;&lt;code&gt;buttonList&lt;/code&gt; is selected. This applies on the ASN.1 specification in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo, se selecciona el &lt;code&gt;number&lt;/code&gt; de componente del primero de los elementos codificados en &lt;code&gt;SEQUENCE OF&lt;/code&gt; &lt;code&gt;buttonList&lt;/code&gt; . Esto se aplica a la especificaci&amp;oacute;n ASN.1 en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5530f78486b7d29f24a47eae49f0d8075dda6924" translate="yes" xml:space="preserve">
          <source>In the example, operator &lt;code&gt;==/2&lt;/code&gt; has been handled exactly as &lt;code&gt;=:=/2&lt;/code&gt; would have been handled. However, if it cannot be determined at compile time that some constant is free of integers, and the table uses &lt;code&gt;=:=/2&lt;/code&gt; when comparing keys for equality (see option &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt;), then the &lt;code&gt;qlc&lt;/code&gt; module does not try to look up the constant. The reason is that there is in the general case no upper limit on the number of key values that can compare equal to such a constant; every combination of integers and floats must be looked up:</source>
          <target state="translated">En el ejemplo, el operador &lt;code&gt;==/2&lt;/code&gt; se ha manejado exactamente como se habr&amp;iacute;a manejado &lt;code&gt;=:=/2&lt;/code&gt; . Sin embargo, si no se puede determinar en tiempo de compilaci&amp;oacute;n que alguna constante est&amp;aacute; libre de enteros, y la tabla usa &lt;code&gt;=:=/2&lt;/code&gt; al comparar claves para la igualdad (ver opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#key_equality&quot;&gt;key_equality&lt;/a&gt;&lt;/code&gt; ), entonces el m&amp;oacute;dulo &lt;code&gt;qlc&lt;/code&gt; no intenta buscar la constante . La raz&amp;oacute;n es que, en el caso general, no existe un l&amp;iacute;mite superior en el n&amp;uacute;mero de valores clave que se pueden comparar igual a dicha constante; cada combinaci&amp;oacute;n de n&amp;uacute;meros enteros y flotantes debe buscarse:</target>
        </trans-unit>
        <trans-unit id="5d4ade845da9cf61c7c17decc1f4b425ce968a4b" translate="yes" xml:space="preserve">
          <source>In the example, synchronous start is used. The process starts by calling &lt;code&gt;ch4:start_link()&lt;/code&gt;:</source>
          <target state="translated">En el ejemplo, se utiliza el inicio s&amp;iacute;ncrono. El proceso comienza llamando a &lt;code&gt;ch4:start_link()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4bd7e62d6b3c0db60fe6d59696b8717a4d0ca575" translate="yes" xml:space="preserve">
          <source>In the example, the plain node name is &lt;code&gt;c1&lt;/code&gt;.</source>
          <target state="translated">En el ejemplo, el nombre del nodo simple es &lt;code&gt;c1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c6e7a22eaacfa776abf6442cc14a2f231bbabc9" translate="yes" xml:space="preserve">
          <source>In the example:</source>
          <target state="translated">En el ejemplo:</target>
        </trans-unit>
        <trans-unit id="c137f104119ba8c9533a7a6a7d789c35c273096b" translate="yes" xml:space="preserve">
          <source>In the examples, you can see that the default Erlang shell interprets only characters from the ISO Latin1 range as printable and only detects lists or binaries with those &quot;printable&quot; characters as containing string data. The valid UTF-8 binary containing the Russian word &quot;Юникод&quot;, is not printed as a string. When started with all Unicode characters printable (&lt;code&gt;+pc unicode&lt;/code&gt;), the shell outputs anything containing printable Unicode data (in binaries, either UTF-8 or bytewise encoded) as string data.</source>
          <target state="translated">En los ejemplos, puede ver que el shell Erlang predeterminado interpreta solo los caracteres del rango ISO Latin1 como imprimibles y solo detecta listas o binarios con esos caracteres &quot;imprimibles&quot; que contienen datos de cadena. El binario UTF-8 v&amp;aacute;lido que contiene la palabra rusa &quot;Юникод&quot; no se imprime como una cadena. Cuando se inicia con todos los caracteres Unicode imprimibles ( &lt;code&gt;+pc unicode&lt;/code&gt; ), el shell genera cualquier cosa que contenga datos Unicode imprimibles (en binarios, ya sea UTF-8 o codificados por bytes) como datos de cadena.</target>
        </trans-unit>
        <trans-unit id="357a42f4e90c9f66d20838b1568c32edad86596f" translate="yes" xml:space="preserve">
          <source>In the exchange of DH parameters in cipher suites providing non-anonymous PFS (perfect forward secrecy).</source>
          <target state="translated">En el intercambio de los parámetros DH en las suites de cifrado que proporcionan PFS no anónimos (perfecto secreto de avance).</target>
        </trans-unit>
        <trans-unit id="43ef791e4bc1073452a5e9418b88d2ae576f87d3" translate="yes" xml:space="preserve">
          <source>In the first form of function calls, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt;, each of &lt;code&gt;ExprM&lt;/code&gt; and &lt;code&gt;ExprF&lt;/code&gt; must be an atom or an expression that evaluates to an atom. The function is said to be called by using the &lt;strong&gt;fully qualified function name&lt;/strong&gt;. This is often referred to as a &lt;strong&gt;remote&lt;/strong&gt; or &lt;strong&gt;external function call&lt;/strong&gt;.</source>
          <target state="translated">En la primera forma de llamadas a funciones, &lt;code&gt;ExprM:ExprF(Expr1,...,ExprN)&lt;/code&gt; , cada uno de &lt;code&gt;ExprM&lt;/code&gt; y &lt;code&gt;ExprF&lt;/code&gt; debe ser un &amp;aacute;tomo o una expresi&amp;oacute;n que se eval&amp;uacute;e como un &amp;aacute;tomo. Se dice que la funci&amp;oacute;n se llama utilizando el &lt;strong&gt;nombre de funci&amp;oacute;n completo&lt;/strong&gt; . Esto a menudo se denomina &lt;strong&gt;llamada de funci&amp;oacute;n &lt;/strong&gt;&lt;strong&gt;remota&lt;/strong&gt; o &lt;strong&gt;externa&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f6d99757df807bd06e120fa43c0767f20375e1c3" translate="yes" xml:space="preserve">
          <source>In the first section (&lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt;), actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that &lt;strong&gt;callback module&lt;/strong&gt;&lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0855a6f8ea31ce47315705d1ba7c199b9582a1fd" translate="yes" xml:space="preserve">
          <source>In the first section &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; actions were mentioned as a part of the general state machine model. These general actions are implemented with the code that callback module &lt;code&gt;gen_statem&lt;/code&gt; executes in an event-handling callback function before returning to the &lt;code&gt;gen_statem&lt;/code&gt; engine.</source>
          <target state="translated">En la primera secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#Event-Driven%20State%20Machines&quot;&gt;Event-Driven State Machines&lt;/a&gt;&lt;/code&gt; acciones de M&amp;aacute;quinas de estado controladas por eventos se mencionaron como parte del modelo de m&amp;aacute;quina de estado general. Estas acciones generales se implementan con el c&amp;oacute;digo que el m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada &lt;code&gt;gen_statem&lt;/code&gt; ejecuta en una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada de manejo de eventos antes de regresar al motor &lt;code&gt;gen_statem&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66f43d3184fba6cdf7fdff11b421851146670c0d" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest are to be 0. In &lt;code&gt;Creation&lt;/code&gt;, only two bits are significant, the rest are to be 0.</source>
          <target state="translated">En la primera palabra (4 bytes) de &lt;code&gt;ID&lt;/code&gt; , solo 18 bits son significativos, el resto debe ser 0. En &lt;code&gt;Creation&lt;/code&gt; , solo dos bits son significativos, el resto debe ser 0.</target>
        </trans-unit>
        <trans-unit id="5e047fa558c6b3687797900dae4cc1f9d07908ea" translate="yes" xml:space="preserve">
          <source>In the first word (4 bytes) of &lt;code&gt;ID&lt;/code&gt;, only 18 bits are significant, the rest must be 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a896f5f2e336921d68f534c573e7c4a11187dc7" translate="yes" xml:space="preserve">
          <source>In the following descriptions the use of the word &lt;strong&gt;Point&lt;/strong&gt; means: &quot;Point can be seen as the position of the cursor. More precisely, the point is the position between two characters while the cursor is drawn over the character following the point&quot;.</source>
          <target state="translated">En las siguientes descripciones, el uso de la palabra &lt;strong&gt;Point&lt;/strong&gt; significa: &quot;El punto puede verse como la posici&amp;oacute;n del cursor. M&amp;aacute;s precisamente, el punto es la posici&amp;oacute;n entre dos caracteres mientras el cursor se dibuja sobre el car&amp;aacute;cter que sigue al punto&quot;.</target>
        </trans-unit>
        <trans-unit id="58edff9fe9daaff2e76b914cd8a32390c2924ba9" translate="yes" xml:space="preserve">
          <source>In the following descriptions, a &lt;strong&gt;group node&lt;/strong&gt; is a node belonging to the same global group as the local node.</source>
          <target state="translated">En las siguientes descripciones, un &lt;strong&gt;nodo de grupo&lt;/strong&gt; es un nodo que pertenece al mismo grupo global que el nodo local.</target>
        </trans-unit>
        <trans-unit id="e55f234f9ae533df0bfe915b6749a10bc4217ff2" translate="yes" xml:space="preserve">
          <source>In the following descriptions, all functions fail with reason &lt;code&gt;badarg&lt;/code&gt; if &lt;code&gt;heart&lt;/code&gt; is not started.</source>
          <target state="translated">En las siguientes descripciones, todas las funciones fallan con motivo de &lt;code&gt;badarg&lt;/code&gt; si no se inicia el &lt;code&gt;heart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68f124a8843620b9753fc32d51bbb85f7300a1d2" translate="yes" xml:space="preserve">
          <source>In the following example QLC &lt;code&gt;V2&lt;/code&gt; has been inserted to show the joined generators and the join method chosen. A convention is used for lookup join: the first generator (&lt;code&gt;G2&lt;/code&gt;) is the one traversed, the second (&lt;code&gt;G1&lt;/code&gt;) is the table where constants are looked up.</source>
          <target state="translated">En el siguiente ejemplo, se ha insertado QLC &lt;code&gt;V2&lt;/code&gt; para mostrar los generadores unidos y el m&amp;eacute;todo de uni&amp;oacute;n elegido. Se usa una convenci&amp;oacute;n para la combinaci&amp;oacute;n de b&amp;uacute;squeda: el primer generador ( &lt;code&gt;G2&lt;/code&gt; ) es el que se atraviesa, el segundo ( &lt;code&gt;G1&lt;/code&gt; ) es la tabla donde se buscan las constantes.</target>
        </trans-unit>
        <trans-unit id="2d50c8a2eb999244e04ab8a6f262c9e2e6443db3" translate="yes" xml:space="preserve">
          <source>In the following example the cached results of the merge join are traversed for each value of &lt;code&gt;A&lt;/code&gt;. Notice that without option &lt;code&gt;cache&lt;/code&gt; the join would have been carried out three times, once for each value of &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">En el siguiente ejemplo de los resultados en cach&amp;eacute; de la combinaci&amp;oacute;n de mezcla est&amp;aacute;n atravesados para cada valor de &lt;code&gt;A&lt;/code&gt; . Tenga en cuenta que sin la opci&amp;oacute;n de &lt;code&gt;cache&lt;/code&gt; la uni&amp;oacute;n se habr&amp;iacute;a llevado a cabo tres veces, una para cada valor de &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="260a8dfa6e31c2145458e7a7056ce3363d755407" translate="yes" xml:space="preserve">
          <source>In the following example two processes are created and they send messages to each other a number of times.</source>
          <target state="translated">En el siguiente ejemplo se crean dos procesos que se envían mensajes entre sí varias veces.</target>
        </trans-unit>
        <trans-unit id="486ff704c9f58f71f4584cc309e9153505629a15" translate="yes" xml:space="preserve">
          <source>In the following example two simple QLCs are inserted only to hold option &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt;:</source>
          <target state="translated">En el siguiente ejemplo, se insertan dos QLC simples solo para contener la opci&amp;oacute;n &lt;code&gt;{unique,&amp;nbsp;true}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="069932958b3334f12d9e43060017f62f9f5a1fe0" translate="yes" xml:space="preserve">
          <source>In the following example using this program, nodes are started on four different computers. If you do not have that many machines available on your network, you can start several nodes on the same machine.</source>
          <target state="translated">En el siguiente ejemplo usando este programa,los nodos se inician en cuatro ordenadores diferentes.Si no tiene tantas máquinas disponibles en su red,puede iniciar varios nodos en la misma máquina.</target>
        </trans-unit>
        <trans-unit id="02724734c231edad2b6c90b6ad85a686c74a1bd4" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;Common Test&lt;/code&gt; finds and executes two tests, one for the path from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub21&lt;/code&gt;, and one from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; through &lt;code&gt;sub22&lt;/code&gt;:</source>
          <target state="translated">En el siguiente ejemplo, &lt;code&gt;Common Test&lt;/code&gt; encuentra y ejecuta dos pruebas, una para la ruta de &lt;code&gt;top2&lt;/code&gt; a &lt;code&gt;sub2X2&lt;/code&gt; a trav&amp;eacute;s de &lt;code&gt;sub21&lt;/code&gt; , y otra de &lt;code&gt;top2&lt;/code&gt; a &lt;code&gt;sub2X2&lt;/code&gt; a &lt;code&gt;sub22&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2f8fe7428e9b6fba7b913b17290b372522a768bd" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;. The message is encoded by &lt;code&gt;erl_send()&lt;/code&gt;:</source>
          <target state="translated">En el siguiente ejemplo, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; se env&amp;iacute;a a un proceso registrado &lt;code&gt;my_server&lt;/code&gt; . El mensaje est&amp;aacute; codificado por &lt;code&gt;erl_send()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0b55abcde93dfcf59993923892aaa3fe74b62110" translate="yes" xml:space="preserve">
          <source>In the following example, &lt;code&gt;{Pid, hello_world}&lt;/code&gt; is sent to a registered process &lt;code&gt;my_server&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e87829810ad78056f565335e48937b1227a1b55a" translate="yes" xml:space="preserve">
          <source>In the following example, by specifying the unique path &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt;, only one test is executed. The second possible path, from &lt;code&gt;top2&lt;/code&gt; to &lt;code&gt;sub2X2&lt;/code&gt; (from the former example) is discarded:</source>
          <target state="translated">En el siguiente ejemplo, al especificar la ruta &amp;uacute;nica &lt;code&gt;top2 -&amp;gt; sub21 -&amp;gt; sub2X2&lt;/code&gt; , solo se ejecuta una prueba. La segunda ruta posible, de &lt;code&gt;top2&lt;/code&gt; a &lt;code&gt;sub2X2&lt;/code&gt; (del ejemplo anterior) se descarta:</target>
        </trans-unit>
        <trans-unit id="d0cef84143c9c72b0e2d6136f433352bbf267b98" translate="yes" xml:space="preserve">
          <source>In the following example, function &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; is used as trigger for sequential tracing:</source>
          <target state="translated">En el siguiente ejemplo, la funci&amp;oacute;n &lt;code&gt;dbg:get_tracer/0&lt;/code&gt; se utiliza como desencadenante para el rastreo secuencial:</target>
        </trans-unit>
        <trans-unit id="e10f21b2e3aef85bbfe3ce9d0d87c1a9e3d0bb5a" translate="yes" xml:space="preserve">
          <source>In the following example, lines 2, 4, 6, 8, and 11 are executable lines:</source>
          <target state="translated">En el siguiente ejemplo,las líneas 2,4,6,8 y 11 son líneas ejecutables:</target>
        </trans-unit>
        <trans-unit id="ec7e7bea0a8acebe642deb025a0a656aa8b0599d" translate="yes" xml:space="preserve">
          <source>In the following example, modules &lt;code&gt;foo&lt;/code&gt; and &lt;code&gt;bar&lt;/code&gt; are used:</source>
          <target state="translated">En el siguiente ejemplo, se utilizan los m&amp;oacute;dulos &lt;code&gt;foo&lt;/code&gt; y &lt;code&gt;bar&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b174caeefec04ac55e06d8f3b6476035f46aeb21" translate="yes" xml:space="preserve">
          <source>In the following example, the BIF &lt;code&gt;self()&lt;/code&gt; returns the pid of the calling process:</source>
          <target state="translated">En el siguiente ejemplo, el BIF &lt;code&gt;self()&lt;/code&gt; devuelve el pid del proceso de llamada:</target>
        </trans-unit>
        <trans-unit id="5409dc0e8a019858263b90292ca1f90716b01a8e" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies as Erlang messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ce80e1521f6fcf4a9ffbad8c36f531e99dceb7f" translate="yes" xml:space="preserve">
          <source>In the following example, the Erlang shell is the client process that receives the channel replies.</source>
          <target state="translated">En el siguiente ejemplo,el shell de Erlang es el proceso cliente que recibe las respuestas del canal.</target>
        </trans-unit>
        <trans-unit id="cfc2a057978208f3e231a6ca3795b61b50bf66e8" translate="yes" xml:space="preserve">
          <source>In the following example, this ASN.1 specification is used:</source>
          <target state="translated">En el siguiente ejemplo,se utiliza esta especificación ASN.1:</target>
        </trans-unit>
        <trans-unit id="f502d38db7db19f5a8116d52d78b40fbb3f26ca6" translate="yes" xml:space="preserve">
          <source>In the following example, two event handlers for the &lt;code&gt;my_SUITE&lt;/code&gt; test are installed:</source>
          <target state="translated">En el siguiente ejemplo, se instalan dos controladores de eventos para la prueba &lt;code&gt;my_SUITE&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c99802972b16068431483b2dc762f303df3c8e55" translate="yes" xml:space="preserve">
          <source>In the following example, using the &lt;code&gt;gb_table&lt;/code&gt; module from section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, there are six keys to look up: &lt;code&gt;{1,a}&lt;/code&gt;, &lt;code&gt;{1,b}&lt;/code&gt;, &lt;code&gt;{1,c}&lt;/code&gt;, &lt;code&gt;{2,a}&lt;/code&gt;, &lt;code&gt;{2,b}&lt;/code&gt;, and &lt;code&gt;{2,c}&lt;/code&gt;. The reason is that the two elements of key &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; are compared separately.</source>
          <target state="translated">En el siguiente ejemplo, utilizando el m&amp;oacute;dulo &lt;code&gt;gb_table&lt;/code&gt; de la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; , hay seis claves para buscar: &lt;code&gt;{1,a}&lt;/code&gt; , &lt;code&gt;{1,b}&lt;/code&gt; , &lt;code&gt;{1,c}&lt;/code&gt; , &lt;code&gt;{2,a}&lt;/code&gt; , &lt;code&gt;{2,b}&lt;/code&gt; y &lt;code&gt;{2,c}&lt;/code&gt; . La raz&amp;oacute;n es que los dos elementos de la clave &lt;code&gt;{X,&amp;nbsp;Y}&lt;/code&gt; se comparan por separado.</target>
        </trans-unit>
        <trans-unit id="d124bbc7f859ed1a5ddec67afc96d8bbbbad9429" translate="yes" xml:space="preserve">
          <source>In the following examples we use the XML file &quot;motorcycles.xml&quot; and the corresponding DTD &quot;motorcycles.dtd&quot;. motorcycles.xml looks like:</source>
          <target state="translated">En los siguientes ejemplos utilizamos el archivo XML &quot;motos.xml&quot; y el correspondiente DTD &quot;motos.dtd&quot;.motos.xml se parece:</target>
        </trans-unit>
        <trans-unit id="54c1ac0436f87ef143bfc77676125c65125284d3" translate="yes" xml:space="preserve">
          <source>In the following figure, only the marked element is decoded by &lt;code&gt;selected_decode_Window2&lt;/code&gt;:</source>
          <target state="translated">En la siguiente figura, s&amp;oacute;lo el elemento marcado es decodificado por &lt;code&gt;selected_decode_Window2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0c1dae61c9ea7eeeb091e362a88deed9b63e97d4" translate="yes" xml:space="preserve">
          <source>In the following figure, square boxes represents supervisors and circles represent workers:</source>
          <target state="translated">En la siguiente figura,los cuadrados representan a los supervisores y los círculos a los trabajadores:</target>
        </trans-unit>
        <trans-unit id="209a1f0310434ec6333f0a98add95c288369e4f6" translate="yes" xml:space="preserve">
          <source>In the following list, init flags are marked &quot;(init flag)&quot;. Unless otherwise specified, all other flags are user flags, for which the values can be retrieved by calling &lt;code&gt;init:get_argument/1&lt;/code&gt;. Notice that the list of user flags is not exhaustive, there can be more application-specific flags that instead are described in the corresponding application documentation.</source>
          <target state="translated">En la siguiente lista, los indicadores de inicio est&amp;aacute;n marcados como &quot;(indicador de inicio)&quot;. A menos que se especifique lo contrario, todos los dem&amp;aacute;s indicadores son indicadores de usuario, cuyos valores se pueden recuperar llamando a &lt;code&gt;init:get_argument/1&lt;/code&gt; . Tenga en cuenta que la lista de indicadores de usuario no es exhaustiva, puede haber m&amp;aacute;s indicadores espec&amp;iacute;ficos de la aplicaci&amp;oacute;n que, en cambio, se describen en la documentaci&amp;oacute;n de la aplicaci&amp;oacute;n correspondiente.</target>
        </trans-unit>
        <trans-unit id="f8c81236f8fbf95dbe539a4a6fcdb86c4472d944" translate="yes" xml:space="preserve">
          <source>In the following sections, these topics are described:</source>
          <target state="translated">En las siguientes secciones se describen estos temas:</target>
        </trans-unit>
        <trans-unit id="43ab0d842bde8340d1582f777849f8b8cfc4d0b4" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. Cygwin/MSYS/MSYS2 is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="translated">En las siguientes secciones,hemos descrito todo lo que pudimos sobre la instalación de las herramientas necesarias.Una vez que las herramientas están instaladas,la construcción es bastante fácil.También hemos tratado de hacer estas instrucciones comprensibles para las personas con experiencia limitada en Unix.Cygwin/MSYS/MSYS2 es un entorno completamente nuevo para algunos usuarios de Windows,por lo que la explicación cuidadosa de las variables de entorno,etc.,parecía estar en su lugar.</target>
        </trans-unit>
        <trans-unit id="1fd2193cd39cfac6403a706b39a45fed6722ffda" translate="yes" xml:space="preserve">
          <source>In the following sections, we've described as much as we could about the installation of the tools needed. Once the tools are installed, building is quite easy. We have also tried to make these instructions understandable for people with limited Unix experience. WSL is a whole new environment to some Windows users, why careful explanation of environment variables etc seemed to be in place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a18adb25fa4d203ef4dc10b4df54df585b5037d2" translate="yes" xml:space="preserve">
          <source>In the following situations, you can easily avoid calling &lt;code&gt;lists:flatten/1&lt;/code&gt;:</source>
          <target state="translated">En las siguientes situaciones, puede evitar f&amp;aacute;cilmente &lt;code&gt;lists:flatten/1&lt;/code&gt; llamadas : aplanar / 1 :</target>
        </trans-unit>
        <trans-unit id="95df25c253f6cf034d9de8bd86d0112fd600064e" translate="yes" xml:space="preserve">
          <source>In the following tables of examples, &lt;code&gt;Data&lt;/code&gt; must be an I/O list. An I/O list is a binary or a (possibly deep) list of binaries or integers in the range 0..255:</source>
          <target state="translated">En las siguientes tablas de ejemplos, los &lt;code&gt;Data&lt;/code&gt; deben ser una lista de E / S. Una lista de E / S es una lista binaria o (posiblemente profunda) de binarios o enteros en el rango 0..255:</target>
        </trans-unit>
        <trans-unit id="cded6a813afbe8a22f1a0d31c8b7cd61b0e5883b" translate="yes" xml:space="preserve">
          <source>In the following terms that may cause confusion are explained.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="969dff5637554c154992258cc999ceb5dbf066be" translate="yes" xml:space="preserve">
          <source>In the functions defined below, the following types are used:</source>
          <target state="translated">En las funciones que se definen a continuación se utilizan los siguientes tipos:</target>
        </trans-unit>
        <trans-unit id="eb8417214d7ef7c1c16243855a2cbc54cd750318" translate="yes" xml:space="preserve">
          <source>In the future, debug functionality will probably be integrated with the Erlang driver thread API. All functions that create entities take a &lt;code&gt;name&lt;/code&gt; argument. Currently the &lt;code&gt;name&lt;/code&gt; argument is unused, but it will be used when the debug functionality is implemented. If you name all entities created well, the debug functionality will be able to give you better error reports.</source>
          <target state="translated">En el futuro, la funcionalidad de depuraci&amp;oacute;n probablemente se integrar&amp;aacute; con la API de subprocesos del controlador Erlang. Todas las funciones que crean entidades toman un argumento de &lt;code&gt;name&lt;/code&gt; . Actualmente, el argumento del &lt;code&gt;name&lt;/code&gt; no se utiliza, pero se utilizar&amp;aacute; cuando se implemente la funci&amp;oacute;n de depuraci&amp;oacute;n. Si nombra bien todas las entidades creadas, la funcionalidad de depuraci&amp;oacute;n podr&amp;aacute; brindarle mejores informes de errores.</target>
        </trans-unit>
        <trans-unit id="60a72bba166a7e938efa7cb1218d2bae46312c9d" translate="yes" xml:space="preserve">
          <source>In the generated boot script all application directories are structured as &lt;code&gt;App-Vsn/ebin&lt;/code&gt;. They are assumed to be located in &lt;code&gt;$ROOT/lib&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the root directory of the installed release. If option &lt;code&gt;local&lt;/code&gt; is specified, the actual directories where the applications were found are used instead. This is a useful way to test a generated boot script locally.</source>
          <target state="translated">En el script de arranque generado, todos los directorios de aplicaciones est&amp;aacute;n estructurados como &lt;code&gt;App-Vsn/ebin&lt;/code&gt; . Se supone que est&amp;aacute;n ubicados en &lt;code&gt;$ROOT/lib&lt;/code&gt; , donde &lt;code&gt;$ROOT&lt;/code&gt; es el directorio ra&amp;iacute;z de la versi&amp;oacute;n instalada. Si se especifica la opci&amp;oacute;n &lt;code&gt;local&lt;/code&gt; , en su lugar se utilizan los directorios reales donde se encontraron las aplicaciones. Esta es una forma &amp;uacute;til de probar localmente un script de arranque generado.</target>
        </trans-unit>
        <trans-unit id="8357564b87a53bc03f3e072c2affa02b3f338254" translate="yes" xml:space="preserve">
          <source>In the last example the module to analyze was given as an argument to &lt;code&gt;m/1&lt;/code&gt;, and the code path was (implicitly) used as &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt;. In this example an &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; will be used, which makes it possible to analyze applications and releases, and also to select the library path explicitly.</source>
          <target state="translated">En el &amp;uacute;ltimo ejemplo, el m&amp;oacute;dulo a analizar se proporcion&amp;oacute; como argumento a &lt;code&gt;m/1&lt;/code&gt; , y la ruta del c&amp;oacute;digo se us&amp;oacute; (impl&amp;iacute;citamente) como &lt;code&gt;&lt;a href=&quot;xref#library_path&quot;&gt;library path&lt;/a&gt;&lt;/code&gt; . En este ejemplo se utilizar&amp;aacute; un &lt;code&gt;&lt;a href=&quot;xref#xref_server&quot;&gt;xref server&lt;/a&gt;&lt;/code&gt; , que permite analizar aplicaciones y versiones, y tambi&amp;eacute;n seleccionar la ruta de la biblioteca de forma expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="53bf7f90f102c21f6ff33e9b95147ea6befa4500" translate="yes" xml:space="preserve">
          <source>In the last line, notice that the tuple {256,10,-2} is the real number 2.56 in a special notation, which encodes faster than simply stating the number as &lt;code&gt;&quot;2.56&quot;&lt;/code&gt;. The arity three tuple is &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt;, that is, Mantissa * Base^Exponent.</source>
          <target state="translated">En la &amp;uacute;ltima l&amp;iacute;nea, observe que la tupla {256,10, -2} es el n&amp;uacute;mero real 2.56 en una notaci&amp;oacute;n especial, que codifica m&amp;aacute;s r&amp;aacute;pido que simplemente indicar el n&amp;uacute;mero como &lt;code&gt;&quot;2.56&quot;&lt;/code&gt; . La tupla arity tres es &lt;code&gt;{Mantissa,Base,Exponent}&lt;/code&gt; , es decir, Mantisa * Base ^ Exponente.</target>
        </trans-unit>
        <trans-unit id="f93bba552275aa89bdb5e765c9d14d6ea2d7aaa2" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change both directions at once:</source>
          <target state="translated">En las listas que se dividen en dos para las dos direcciones (cf &lt;code&gt;cipher&lt;/code&gt; ) es posible cambiar ambas direcciones a la vez:</target>
        </trans-unit>
        <trans-unit id="00675dbb48a26b0a91eca4f2bc6b8535be7bd247" translate="yes" xml:space="preserve">
          <source>In the lists that are divided in two for the two directions (c.f &lt;code&gt;cipher&lt;/code&gt;) it is possible to change only one of the directions:</source>
          <target state="translated">En las listas que se dividen en dos para las dos direcciones (cf &lt;code&gt;cipher&lt;/code&gt; ) es posible cambiar solo una de las direcciones:</target>
        </trans-unit>
        <trans-unit id="9467c0d9e7e0679d7e286a3e84f7825f450479dd" translate="yes" xml:space="preserve">
          <source>In the loop where requests are handled, send time-outs can now be detected:</source>
          <target state="translated">En el bucle en el que se manejan las solicitudes,ahora se pueden detectar los tiempos muertos de envío:</target>
        </trans-unit>
        <trans-unit id="9da6cdcd2464f9aa69d41b9520dcbcf709d10ca9" translate="yes" xml:space="preserve">
          <source>In the messenger example, no assumptions have been made about what the message being sent is. It can be any valid Erlang term.</source>
          <target state="translated">En el ejemplo del mensajero,no se han hecho suposiciones sobre cuál es el mensaje que se está enviando.Puede ser cualquier término Erlang válido.</target>
        </trans-unit>
        <trans-unit id="8edc784c5711aef4324569d61cb733c3b77cb091" translate="yes" xml:space="preserve">
          <source>In the modified lock free version of this approach we more or less do it the same way, but with some important modifications trying to avoid unnecessary contention when multiple schedulers create processes simultaneously. Since multiple threads might be trying to search for the next free slot at the same time from the same starting point we want subsequent slots to be located in different cache lines. Multiple schedulers simultaneously writing new pointers into the table are therefore very likely to write into adjacent slots. If adjacent slots are located in the same cache line all modification of this cache line needs to be communicated between all involved processors which will be very expensive and scale very poor. By locating adjacent slots in different cache lines only true conflicts will trigger communication between involved processors, i.e., avoiding false sharing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb3b53f608800b09e4b113953e980be25982bcf7" translate="yes" xml:space="preserve">
          <source>In the monitor message &lt;code&gt;MonitorRef&lt;/code&gt; and &lt;code&gt;Type&lt;/code&gt; are the same as described earlier, and:</source>
          <target state="translated">En el mensaje del monitor, &lt;code&gt;MonitorRef&lt;/code&gt; y &lt;code&gt;Type&lt;/code&gt; son los mismos que los descritos anteriormente, y:</target>
        </trans-unit>
        <trans-unit id="6af58c3bd490620b572e86c6ee20f0568469a3cc" translate="yes" xml:space="preserve">
          <source>In the new design the old wheel was dropped and instead replaced by one struct (&lt;code&gt;GenericBp&lt;/code&gt;) to hold the data for all types of breakpoints for each instrumented function. A bit-flag field is used to indicate what different type of break actions that are enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a775ef8f9dc8be5c9fdaee0cab605f0e25c280e" translate="yes" xml:space="preserve">
          <source>In the next garbage collection, any pointers to the old heap will be ignored and not scanned. This way the garbage collector does not have to scan the long-lived terms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d0c33ad0d8698789ff1ce734a374e0b8dc46cb" translate="yes" xml:space="preserve">
          <source>In the next word the tagged atom &lt;code&gt;id&lt;/code&gt; is stored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440342ee163fa2a69d1ae77fbeb319e6027a604d" translate="yes" xml:space="preserve">
          <source>In the normal case, a version is constructed as &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt;, where &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; is the most significant part.</source>
          <target state="translated">En el caso normal, una versi&amp;oacute;n se construye como &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; , donde &lt;code&gt;&amp;lt;Major&amp;gt;&lt;/code&gt; es la parte m&amp;aacute;s significativa.</target>
        </trans-unit>
        <trans-unit id="eef10fd45d5bc3efdc8a361eb2983aa877e3b993" translate="yes" xml:space="preserve">
          <source>In the presence of initial values for fields, the type must be declared after the initialization, as follows:</source>
          <target state="translated">En presencia de valores iniciales para los campos,el tipo debe ser declarado después de la inicialización,de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="85f68555c1cd1c300b04b62bde8ff2ba3511a30a" translate="yes" xml:space="preserve">
          <source>In the previous example there is no indication of which protocols are expected. So a client has no indication of whether it is a web server, an ldap server or maybe a sip server it is connected to. There are fields in the certificate that can indicate this. To be more exact, the rfc introduces the usage of the &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; in the &lt;code&gt;X509v3 extensions&lt;/code&gt; field:</source>
          <target state="translated">En el ejemplo anterior, no hay ninguna indicaci&amp;oacute;n de qu&amp;eacute; protocolos se esperan. Entonces, un cliente no tiene ninguna indicaci&amp;oacute;n de si es un servidor web, un servidor ldap o tal vez un servidor sip al que est&amp;aacute; conectado. Hay campos en el certificado que pueden indicar esto. Para ser m&amp;aacute;s exactos, el rfc introduce el uso del &lt;code&gt;X509v3 Subject Alternative Name&lt;/code&gt; en el campo de &lt;code&gt;X509v3 extensions&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="540597900320cac0101d153b777e3c96ce5dbf16" translate="yes" xml:space="preserve">
          <source>In the previous example, &quot;ping&quot; and &quot;pong&quot; were started from the shells of two separate Erlang nodes. &lt;code&gt;spawn&lt;/code&gt; can also be used to start processes in other nodes.</source>
          <target state="translated">En el ejemplo anterior, &quot;ping&quot; y &quot;pong&quot; se iniciaron desde los shells de dos nodos Erlang separados. &lt;code&gt;spawn&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para iniciar procesos en otros nodos.</target>
        </trans-unit>
        <trans-unit id="b18cd2f860e67d545dd4ad1005cc630df953632b" translate="yes" xml:space="preserve">
          <source>In the previous example, if &lt;code&gt;all/0&lt;/code&gt; returns group name references in the order &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt;, the order of the configuration functions and test cases becomes the following (notice that &lt;code&gt;init_per_testcase/2&lt;/code&gt; and &lt;code&gt;end_per_testcase/2:&lt;/code&gt; are also always called, but not included in this example for simplification):</source>
          <target state="translated">En el ejemplo anterior, si &lt;code&gt;all/0&lt;/code&gt; devuelve referencias de nombre de grupo en el orden &lt;code&gt;[{group,group1},{group,group3}]&lt;/code&gt; , el orden de las funciones de configuraci&amp;oacute;n y los casos de prueba es el siguiente (observe que &lt;code&gt;init_per_testcase/2&lt;/code&gt; y &lt;code&gt;end_per_testcase/2:&lt;/code&gt; tambi&amp;eacute;n se llaman siempre, pero no se incluyen en este ejemplo para simplificar):</target>
        </trans-unit>
        <trans-unit id="d05bdeaa2197b362b108ffe823ac50e3ee94a479" translate="yes" xml:space="preserve">
          <source>In the previous example, the supervisor is started by calling &lt;code&gt;ch_sup:start_link()&lt;/code&gt;:</source>
          <target state="translated">En el ejemplo anterior, el supervisor se inicia llamando a &lt;code&gt;ch_sup:start_link()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="05d2378639fa9498426915ef27016e468d81ee73" translate="yes" xml:space="preserve">
          <source>In the previous examples, new variable names are used, instead of reusing the old ones: &lt;code&gt;First&lt;/code&gt;, &lt;code&gt;TheRest&lt;/code&gt;, &lt;code&gt;E1&lt;/code&gt;, &lt;code&gt;E2&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, &lt;code&gt;B&lt;/code&gt;, and &lt;code&gt;C&lt;/code&gt;. The reason for this is that a variable can only be given a value once in its context (scope). More about this later.</source>
          <target state="translated">En los ejemplos anteriores, se utilizan nuevos nombres de variables, en lugar de reutilizar los viejos: &lt;code&gt;First&lt;/code&gt; , &lt;code&gt;TheRest&lt;/code&gt; , &lt;code&gt;E1&lt;/code&gt; , &lt;code&gt;E2&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , &lt;code&gt;B&lt;/code&gt; , y &lt;code&gt;C&lt;/code&gt; . La raz&amp;oacute;n de esto es que a una variable solo se le puede dar un valor una vez en su contexto (alcance). M&amp;aacute;s sobre esto m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="9db752d6e6f2fd68cc464e93f5288f571d158e54" translate="yes" xml:space="preserve">
          <source>In the runtime system with SMP support, drivers are locked either on driver level or port level (driver instance level). By default driver level locking will be used, that is, only one emulator thread will execute code in the driver at a time. If port level locking is used, multiple emulator threads can execute code in the driver at the same time. Only one thread at a time will call driver callbacks corresponding to the same port, though. To enable port level locking, set the &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; in the &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; used by the driver. When port level locking is used, the driver writer is responsible for synchronizing all accesses to data shared by the ports (driver instances).</source>
          <target state="translated">En el sistema de tiempo de ejecuci&amp;oacute;n con soporte SMP, los controladores se bloquean en el nivel del controlador o en el nivel del puerto (nivel de instancia del controlador). Por defecto, se utilizar&amp;aacute; el bloqueo a nivel de controlador, es decir, solo un subproceso del emulador ejecutar&amp;aacute; c&amp;oacute;digo en el controlador a la vez. Si se utiliza el bloqueo de nivel de puerto, varios subprocesos del emulador pueden ejecutar c&amp;oacute;digo en el controlador al mismo tiempo. Sin embargo, solo un hilo a la vez llamar&amp;aacute; a las devoluciones de llamada del controlador correspondientes al mismo puerto. Para habilitar el bloqueo a nivel de puerto, configure el &lt;code id=&quot;smp_support&quot;&gt;ERL_DRV_FLAG_USE_PORT_LOCKING&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver flag&lt;/a&gt;&lt;/code&gt; ERL_DRV_FLAG_USE_PORT_LOCKING en la &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; del controlador que utiliza el controlador. Cuando se utiliza el bloqueo de nivel de puerto, el escritor del controlador es responsable de sincronizar todos los accesos a los datos compartidos por los puertos (instancias de controlador).</target>
        </trans-unit>
        <trans-unit id="45c47bc5d9c1563d221339ce4f4f3726200c6a90" translate="yes" xml:space="preserve">
          <source>In the second example we use the default trace handler function. This handler prints to tty by sending IO requests to the &lt;code&gt;user&lt;/code&gt; process. When Erlang is started in oldshell mode, the shell process will have &lt;code&gt;user&lt;/code&gt; as its group leader and so will the tracer process in this example. Since &lt;code&gt;user&lt;/code&gt; calls functions in &lt;code&gt;lists&lt;/code&gt; we end up in a deadlock as soon as the first IO request is sent.</source>
          <target state="translated">En el segundo ejemplo usamos la funci&amp;oacute;n de controlador de seguimiento predeterminada. Este controlador imprime en tty enviando solicitudes de E / S al proceso de &lt;code&gt;user&lt;/code&gt; . Cuando Erlang se inicia en modo oldshell, el proceso de shell tendr&amp;aacute; al &lt;code&gt;user&lt;/code&gt; como l&amp;iacute;der de grupo y tambi&amp;eacute;n lo tendr&amp;aacute; el proceso de seguimiento en este ejemplo. Dado que el &lt;code&gt;user&lt;/code&gt; llama a funciones en &lt;code&gt;lists&lt;/code&gt; , terminamos en un punto muerto tan pronto como se env&amp;iacute;a la primera solicitud de E / S.</target>
        </trans-unit>
        <trans-unit id="c04391cfdd5ab08da1a538b9e9e445cf468e3b94" translate="yes" xml:space="preserve">
          <source>In the second form of function calls, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt;, &lt;code&gt;ExprF&lt;/code&gt; must be an atom or evaluate to a fun.</source>
          <target state="translated">En la segunda forma de llamadas a funciones, &lt;code&gt;ExprF(Expr1,...,ExprN)&lt;/code&gt; , &lt;code&gt;ExprF&lt;/code&gt; debe ser un &amp;aacute;tomo o evaluar como divertido.</target>
        </trans-unit>
        <trans-unit id="739f1313c2f241e229ecba15f499a06fac9e9ec7" translate="yes" xml:space="preserve">
          <source>In the sequence chart, the actors (which symbolically has performed the &lt;code&gt;Event&lt;/code&gt;) are shown as named vertical bars. The order of the actors may be altered by dragging (hold mouse button 1 pressed during the operation) the name tag of an actor and drop it elsewhere:</source>
          <target state="translated">En el diagrama de secuencia, los actores (que simb&amp;oacute;licamente han realizado el &lt;code&gt;Event&lt;/code&gt; o ) se muestran como barras verticales con nombre. El orden de los actores se puede alterar arrastrando (mantenga presionado el bot&amp;oacute;n 1 del mouse durante la operaci&amp;oacute;n) la etiqueta de nombre de un actor y su&amp;eacute;ltela en otro lugar:</target>
        </trans-unit>
        <trans-unit id="7823fdfa2d6e99d8afc1d184adab525e34685552" translate="yes" xml:space="preserve">
          <source>In the setup of the SSH connection a secret cipher key is generated by co-operation of the client and the server. Keeping this key secret is crucial for keeping the communication secret. As time passes and encrypted messages are exchanged, the probability that a listener could guess that key increases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2624ef8dfa305150cd47498ba182bfff4991d99a" translate="yes" xml:space="preserve">
          <source>In the shell, if using a Unicode input device, or in source code stored in UTF-8, &lt;code&gt;$&lt;/code&gt; can be followed directly by a Unicode character producing an integer. In the following example, the code point of a Cyrillic &lt;code&gt;с&lt;/code&gt; is output:</source>
          <target state="translated">En el shell, si se usa un dispositivo de entrada Unicode, o en el c&amp;oacute;digo fuente almacenado en UTF-8, &lt;code&gt;$&lt;/code&gt; puede ir seguido directamente por un car&amp;aacute;cter Unicode que produce un n&amp;uacute;mero entero. En el siguiente ejemplo, se emite el punto de c&amp;oacute;digo de un cir&amp;iacute;lico &lt;code&gt;с&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a13f065991e8e14b6a7d0e85181fc27a2c686176" translate="yes" xml:space="preserve">
          <source>In the situation where a node has lost its connections to other nodes in its global group, but has connections to nodes in other global groups, a request from another global group can produce an incorrect or misleading result. For example, the isolated node can have inaccurate information about registered names in its global group.</source>
          <target state="translated">En la situación en que un nodo ha perdido sus conexiones con otros nodos de su grupo global,pero tiene conexiones con nodos de otros grupos globales,una solicitud de otro grupo global puede producir un resultado incorrecto o engañoso.Por ejemplo,el nodo aislado puede tener información inexacta sobre los nombres registrados en su grupo global.</target>
        </trans-unit>
        <trans-unit id="45354ca6d5ea2475e4f281fd6c145d031cdf7187" translate="yes" xml:space="preserve">
          <source>In the supervisor &lt;code&gt;child specification&lt;/code&gt; there is a list of modules which is recommended to contain only the callback module. For a &lt;code&gt;gen_statem&lt;/code&gt; with multiple callback modules there is no real need to list all of them, it may not even be possible since the list could change after code upgrade. If this list would contain only the start callback module, as recommended, what is important is to upgrade &lt;strong&gt;that&lt;/strong&gt; module whenever a &lt;strong&gt;synchronized code replacement&lt;/strong&gt; is done. Then the release handler concludes that an upgrade that upgrades &lt;strong&gt;that&lt;/strong&gt; module needs to suspend, code change, and resume any server whose child specification declares that it is using &lt;strong&gt;that&lt;/strong&gt; module. And again; the &lt;strong&gt;current&lt;/strong&gt; callback module will get the &lt;code&gt;Module:code_change/4&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34787be2516bd25bc51ccdee0b0ac4c6d7eba78b" translate="yes" xml:space="preserve">
          <source>In the tail part of the data structure we find a pointer to the last element of the list, or at least something that is near the end of the list. In the uncontended case it will point to the end of the list, but when simultaneous insert operations are performed it will point to something near the end of the list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1acddb6beb61278fbb0d6fbae558f662971ab57" translate="yes" xml:space="preserve">
          <source>In the target directory reads the file &lt;code&gt;releases/start_erl.data&lt;/code&gt; to find the Erlang runtime system version (&quot;5.10.4&quot;).</source>
          <target state="translated">En el directorio de destino lee el archivo &lt;code&gt;releases/start_erl.data&lt;/code&gt; para encontrar la versi&amp;oacute;n del sistema en tiempo de ejecuci&amp;oacute;n de Erlang (&quot;5.10.4&quot;).</target>
        </trans-unit>
        <trans-unit id="8519783e0474dbe47084ba06a2c57f937aceddd6" translate="yes" xml:space="preserve">
          <source>In the text encoding, implementors have the choice of using a mix of short and long keywords. It is also possible to add white spaces to improve readability. We use the term compact for text messages with the shortest possible keywords and no optional white spaces, and the term pretty for a well indented text format using long keywords and an indentation style like the text examples in the Megaco/H.248 specification).</source>
          <target state="translated">En la codificación de texto,los implementadores tienen la opción de usar una mezcla de palabras clave cortas y largas.También es posible añadir espacios en blanco para mejorar la legibilidad.Utilizamos el término compacto para los mensajes de texto con las palabras clave más cortas posibles y sin espacios en blanco opcionales,y el término bonito para un formato de texto bien indentado utilizando palabras clave largas y un estilo de indentación como los ejemplos de texto en la especificación Megaco/H.248).</target>
        </trans-unit>
        <trans-unit id="a5c95ea342ee7c08382d8806e33a6d11792130c7" translate="yes" xml:space="preserve">
          <source>In the traditional transport entries, when the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8436cdbd307ab8656dafbbaa0b4535513613e69" translate="yes" xml:space="preserve">
          <source>In the wake of this the function &lt;code&gt;sys:get_debug/3&lt;/code&gt; that returns data with undocumented and internal format (and therefore is practically useless) has been deprecated, and a new function &lt;code&gt;sys:get_log/1&lt;/code&gt; has been added, that hopefully does what the deprecated function was intended for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f97637d135e2db9b66d48ef02e3dc2bf1b27bf1" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="translated">En las funciones xmerl_xs, puede proporcionar una llamada select (String), que es una funcionalidad &lt;code&gt;&lt;a href=&quot;http://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; . Para obtener m&amp;aacute;s detalles, consulte el &lt;code&gt;tutorial&lt;/code&gt; xmerl_xs .</target>
        </trans-unit>
        <trans-unit id="19dcfcc4ae578c29ecc97aa13bb8ee0b043f878a" translate="yes" xml:space="preserve">
          <source>In the xmerl_xs functions you can provide a select(String) call, which is an &lt;code&gt;&lt;a href=&quot;https://www.w3.org/TR/xpath&quot;&gt;XPath&lt;/a&gt;&lt;/code&gt; functionality. For more details see the xmerl_xs &lt;code&gt;tutorial&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dac4b7f84924719cb25f1773bfbe993e383c0c1" translate="yes" xml:space="preserve">
          <source>In these cases, the ProtocolVersion default version is obtained from the static connection configuration:</source>
          <target state="translated">En estos casos,la versión por defecto de ProtocolVersion se obtiene de la configuración de la conexión estática:</target>
        </trans-unit>
        <trans-unit id="d38f971f169182ffed875b881c3f302c1291f57c" translate="yes" xml:space="preserve">
          <source>In this agent system, there are two ways to dynamically install management information. The most common way is to load an MIB into an agent. The other way is to use a sub-agent, which is controlled by the application and is able to register and unregister itself. A sub-agent can register itself for managing a sub-tree (not to be mixed up with &lt;code&gt;erlang:register&lt;/code&gt;). The sub-tree is identified by an Object Identifier. When a sub-agent is registered, it receives all requests for this particular sub-tree and it is responsible for answering them. It should also be noted that a sub-agent can be started and stopped at any time.</source>
          <target state="translated">En este sistema de agentes, hay dos formas de instalar din&amp;aacute;micamente la informaci&amp;oacute;n de gesti&amp;oacute;n. La forma m&amp;aacute;s com&amp;uacute;n es cargar una MIB en un agente. La otra forma es utilizar un sub-agente, que es controlado por la aplicaci&amp;oacute;n y puede registrarse y darse de baja. Un &lt;code&gt;erlang:register&lt;/code&gt; puede registrarse para administrar un sub&amp;aacute;rbol (no debe confundirse con erlang: register ). El sub&amp;aacute;rbol se identifica mediante un identificador de objeto. Cuando un sub-agente est&amp;aacute; registrado, recibe todas las solicitudes de este sub&amp;aacute;rbol en particular y es responsable de responderlas. Tambi&amp;eacute;n debe tenerse en cuenta que un subagente puede iniciarse y detenerse en cualquier momento.</target>
        </trans-unit>
        <trans-unit id="539e0564531c6d44cbeae350dfc80c3176291ed6" translate="yes" xml:space="preserve">
          <source>In this call, &lt;code&gt;[1, 1]&lt;/code&gt; is the &lt;code&gt;RowIndex&lt;/code&gt;, where key 1 has value 1, and key 2 has value 1, and &lt;code&gt;[3, 5]&lt;/code&gt; is the list of requested columns. The function should now return the lexicographically next elements:</source>
          <target state="translated">En esta llamada, &lt;code&gt;[1, 1]&lt;/code&gt; es el &lt;code&gt;RowIndex&lt;/code&gt; , donde la clave 1 tiene el valor 1 y la clave 2 tiene el valor 1 y &lt;code&gt;[3, 5]&lt;/code&gt; es la lista de columnas solicitadas. La funci&amp;oacute;n ahora deber&amp;iacute;a devolver los siguientes elementos lexicogr&amp;aacute;ficamente:</target>
        </trans-unit>
        <trans-unit id="6f444892327372c0083d6cd41d371bb581f5034e" translate="yes" xml:space="preserve">
          <source>In this case it has got a new component &lt;code&gt;b&lt;/code&gt;. Thus, incoming messages that are decoded can have more or fever components than this one.</source>
          <target state="translated">En este caso tiene un nuevo componente &lt;code&gt;b&lt;/code&gt; . Por lo tanto, los mensajes entrantes que se decodifican pueden tener m&amp;aacute;s componentes de fiebre que este.</target>
        </trans-unit>
        <trans-unit id="81909444a643000153b2965fd71e17cdec12149b" translate="yes" xml:space="preserve">
          <source>In this case the &lt;code&gt;ct_hooks&lt;/code&gt; statement in the test suite can look as follows:</source>
          <target state="translated">En este caso, la declaraci&amp;oacute;n &lt;code&gt;ct_hooks&lt;/code&gt; en el conjunto de pruebas puede tener el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="4a51ade1b4e89205ca9bc9b111738c60e7a1c022" translate="yes" xml:space="preserve">
          <source>In this case the configuration file must at least contain:</source>
          <target state="translated">En este caso el archivo de configuración debe contener al menos:</target>
        </trans-unit>
        <trans-unit id="1d7088cf673c6d087bf2c25d65e3c008f7960123" translate="yes" xml:space="preserve">
          <source>In this case the filter is applied to every possible pair of answers to &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt;, one at a time. If there are M answers to &lt;code&gt;QH1&lt;/code&gt; and N answers to &lt;code&gt;QH2&lt;/code&gt;, the filter is run M*N times.</source>
          <target state="translated">En este caso, el filtro se aplica a cada par posible de respuestas a &lt;code&gt;QH1&lt;/code&gt; y &lt;code&gt;QH2&lt;/code&gt; , una a la vez. Si hay M respuestas a &lt;code&gt;QH1&lt;/code&gt; y N respuestas a &lt;code&gt;QH2&lt;/code&gt; , el filtro se ejecuta M * N veces.</target>
        </trans-unit>
        <trans-unit id="28983b21b0ad9b5b9935ebfc53758651c434ba12" translate="yes" xml:space="preserve">
          <source>In this case, &lt;code&gt;CTH&lt;/code&gt; can either be only the module name of the CTH or a tuple with the module name and the initial arguments, and optionally the hook priority of the CTH. For example, one of the following:</source>
          <target state="translated">En este caso, &lt;code&gt;CTH&lt;/code&gt; puede ser solo el nombre del m&amp;oacute;dulo de CTH o una tupla con el nombre del m&amp;oacute;dulo y los argumentos iniciales y, opcionalmente, la prioridad de enlace de CTH. Por ejemplo, uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="2a423ae0801e37198bf3643c083306bae6ec09bd" translate="yes" xml:space="preserve">
          <source>In this case, Compiler option &lt;code&gt;encrypt_debug_info&lt;/code&gt; can be used, see &lt;code&gt;compile(3)&lt;/code&gt;.</source>
          <target state="translated">En este caso, se puede utilizar la opci&amp;oacute;n del compilador &lt;code&gt;encrypt_debug_info&lt;/code&gt; , consulte &lt;code&gt;compile(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5039f2c8ff05131bbbf56345b582c1ca63c2cd6b" translate="yes" xml:space="preserve">
          <source>In this case, all arguments but the first are ignored and the function simply returns the internal state again. This is enough if the code only has been extended. If instead the internal state is changed (similar to the example in &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt;), this is done in this function and &lt;code&gt;{ok,Chs2}&lt;/code&gt; returned.</source>
          <target state="translated">En este caso, todos los argumentos excepto el primero se ignoran y la funci&amp;oacute;n simplemente devuelve el estado interno nuevamente. Esto es suficiente si el c&amp;oacute;digo solo se ha extendido. Si, en cambio, se cambia el estado interno (similar al ejemplo de &lt;code&gt;&lt;a href=&quot;#int_state&quot;&gt;Changing Internal State&lt;/a&gt;&lt;/code&gt; ), esto se hace en esta funci&amp;oacute;n y se &lt;code&gt;{ok,Chs2}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f725a21c435f46ea81fa484e58d3d41f8bd72bbc" translate="yes" xml:space="preserve">
          <source>In this case, one or more of &lt;code&gt;Expr1&lt;/code&gt;...&lt;code&gt;ExprK&lt;/code&gt; can be unbound variables.</source>
          <target state="translated">En este caso, uno o m&amp;aacute;s de &lt;code&gt;Expr1&lt;/code&gt; ... &lt;code&gt;ExprK&lt;/code&gt; pueden ser variables independientes .</target>
        </trans-unit>
        <trans-unit id="bac5d4d9afdbed7a919ecd5845595a514ce50f9a" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. The process must explicitly transform its state using the callback function &lt;code&gt;code_change&lt;/code&gt; before switching to the new version of the callback module. Thus, synchronized code replacement is used.</source>
          <target state="translated">En este caso, el simple reemplazo de c&amp;oacute;digo no es suficiente. El proceso debe transformar expl&amp;iacute;citamente su estado utilizando la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;code_change&lt;/code&gt; antes de cambiar a la nueva versi&amp;oacute;n del m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada. Por tanto, se utiliza el reemplazo de c&amp;oacute;digo sincronizado.</target>
        </trans-unit>
        <trans-unit id="4ec09095fe4b3a08fa08b2d3c7632c3ad498721e" translate="yes" xml:space="preserve">
          <source>In this case, simple code replacement is not sufficient. When a new version of a residence module for a special process is loaded, the process must make a fully qualified call to its loop function to switch to the new code. Thus, synchronized code replacement must be used.</source>
          <target state="translated">En este caso,la simple sustitución del código no es suficiente.Cuando se carga una nueva versión de un módulo de residencia para un proceso especial,el proceso debe hacer una llamada totalmente cualificada a su función de bucle para cambiar al nuevo código.Por lo tanto,debe utilizarse el reemplazo sincronizado del código.</target>
        </trans-unit>
        <trans-unit id="bbe74749660d0039c0abd21e49290ce19c250a20" translate="yes" xml:space="preserve">
          <source>In this case, the calling process is the shell, so the following result is received:</source>
          <target state="translated">En este caso,el proceso de llamada es la cáscara,por lo que se recibe el siguiente resultado:</target>
        </trans-unit>
        <trans-unit id="2cd85caaa1a6987f2340faefbd7babc9b4009f1f" translate="yes" xml:space="preserve">
          <source>In this case, the function must be exported from the module in question.</source>
          <target state="translated">En este caso,la función debe ser exportada desde el módulo en cuestión.</target>
        </trans-unit>
        <trans-unit id="84ecff76d3518039bed69b56be3f5fe9f91bdb0c" translate="yes" xml:space="preserve">
          <source>In this case, the key &lt;code&gt;Key&lt;/code&gt; is returned, which can be used in a subsequent call to &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; to retrieve the value of evaluating &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; on node &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">En este caso, se devuelve la clave &lt;code&gt;Key&lt;/code&gt; , que se puede usar en una llamada posterior a &lt;code&gt;&lt;a href=&quot;#yield-1&quot;&gt;yield/1&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#nb_yield-1&quot;&gt;nb_yield/1,2&lt;/a&gt;&lt;/code&gt; para recuperar el valor de evaluar &lt;code&gt;apply(Module, Function, Args)&lt;/code&gt; en el nodo &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2ea0870da5814abd9a73cf1fe490942611b71d5e" translate="yes" xml:space="preserve">
          <source>In this case, the new state is the updated list of available channels &lt;code&gt;Chs2&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; is now ready for new requests.</source>
          <target state="translated">En este caso, el nuevo estado es la lista actualizada de canales disponibles &lt;code&gt;Chs2&lt;/code&gt; . El &lt;code&gt;gen_server&lt;/code&gt; ya est&amp;aacute; lista para nuevas solicitudes.</target>
        </trans-unit>
        <trans-unit id="5aee58fc810702815e51808a51b2ab85c081aa01" translate="yes" xml:space="preserve">
          <source>In this case, the release handler framework with automatic packing and unpacking of release packages, automatic path updates, and so on, can be used without having to specify &lt;code&gt;.appup&lt;/code&gt; files.</source>
          <target state="translated">En este caso, el marco del controlador de versiones con empaque y desempaquetado autom&amp;aacute;tico de paquetes de versiones, actualizaciones de rutas autom&amp;aacute;ticas, etc., se puede utilizar sin tener que especificar archivos &lt;code&gt;.appup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0046cd0df3cac4eb3b95dc96fc37ec106f64638" translate="yes" xml:space="preserve">
          <source>In this case, the reply is the allocated channel &lt;code&gt;Ch&lt;/code&gt; and the new state is the set of remaining available channels &lt;code&gt;Chs2&lt;/code&gt;.</source>
          <target state="translated">En este caso, la respuesta es el canal asignado &lt;code&gt;Ch&lt;/code&gt; y el nuevo estado es el conjunto de canales disponibles restantes &lt;code&gt;Chs2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9574675a8f9e5418ebb839c426e998489f14ad76" translate="yes" xml:space="preserve">
          <source>In this case, the supervisor is not registered. Instead its pid must be used. A name can be specified by calling &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; or &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt;.</source>
          <target state="translated">En este caso, el supervisor no est&amp;aacute; registrado. En su lugar, debe usarse su pid. Se puede especificar un nombre llamando al &lt;code&gt;supervisor:start_link({local, Name}, Module, Args)&lt;/code&gt; o &lt;code&gt;supervisor:start_link({global, Name}, Module, Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6603f0a6951b192542ceb666e2c7f72b121f614" translate="yes" xml:space="preserve">
          <source>In this case, you free the two terms independently. The order in which you free the terms &lt;code&gt;ep&lt;/code&gt; and &lt;code&gt;ep2&lt;/code&gt; is not important, because the &lt;code&gt;Erl_Interface&lt;/code&gt; library uses reference counting to determine when it is safe to remove objects.</source>
          <target state="translated">En este caso, libera los dos t&amp;eacute;rminos de forma independiente. El orden en el que libera los t&amp;eacute;rminos &lt;code&gt;ep&lt;/code&gt; y &lt;code&gt;ep2&lt;/code&gt; no es importante, porque la biblioteca &lt;code&gt;Erl_Interface&lt;/code&gt; utiliza el recuento de referencias para determinar cu&amp;aacute;ndo es seguro eliminar objetos.</target>
        </trans-unit>
        <trans-unit id="b0020e2468bc67c671f498f4e4e7457122f890ee" translate="yes" xml:space="preserve">
          <source>In this example consider the situation where you want to examine a particular data in the XML file. For instance, you want to check for how long each motorcycle have been recorded.</source>
          <target state="translated">En este ejemplo,considere la situación en la que desea examinar un dato concreto del archivo XML.Por ejemplo,quieres comprobar cuánto tiempo se ha registrado cada motocicleta.</target>
        </trans-unit>
        <trans-unit id="46a429a85cf2eee81ebe05e357ca0f926abafe9d" translate="yes" xml:space="preserve">
          <source>In this example the Pea application has been changed, and so are the applications ERTS, Kernel, STDLIB and SASL.</source>
          <target state="translated">En este ejemplo,la aplicación Guisante ha sido modificada,así como las aplicaciones ERTS,Kernel,STDLIB y SASL.</target>
        </trans-unit>
        <trans-unit id="4298d6ba95bb1281780cd67a70e648391534cd1f" translate="yes" xml:space="preserve">
          <source>In this example the numbers are integers and the arguments in the functions in the code &lt;code&gt;N&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt;, and &lt;code&gt;Y&lt;/code&gt; are called variables. Variables must start with a capital letter (see &lt;code&gt;Variables&lt;/code&gt;). Examples of variables are &lt;code&gt;Number&lt;/code&gt;, &lt;code&gt;ShoeSize&lt;/code&gt;, and &lt;code&gt;Age&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, los n&amp;uacute;meros son n&amp;uacute;meros enteros y los argumentos de las funciones del c&amp;oacute;digo &lt;code&gt;N&lt;/code&gt; , &lt;code&gt;X&lt;/code&gt; e &lt;code&gt;Y&lt;/code&gt; se denominan variables. Las variables deben comenzar con una letra may&amp;uacute;scula (ver &lt;code&gt;Variables&lt;/code&gt; ). Ejemplos de variables son &lt;code&gt;Number&lt;/code&gt; , &lt;code&gt;ShoeSize&lt;/code&gt; y &lt;code&gt;Age&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00141d9820384d0fe96047499c682c85df54a263" translate="yes" xml:space="preserve">
          <source>In this example we first create a new cons cell with an integer and a tuple with some text. Then a tuple of size three wrapping the other values with an atom tag is created and returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f86bfad372e7bf0f313f5d6b081512cd31ba5a67" translate="yes" xml:space="preserve">
          <source>In this example you walk through a list &quot;carrying&quot; a value, in this case &lt;code&gt;Result_so_far&lt;/code&gt;. &lt;code&gt;list_max/1&lt;/code&gt; simply assumes that the max value of the list is the head of the list and calls &lt;code&gt;list_max/2&lt;/code&gt; with the rest of the list and the value of the head of the list. In the above this would be &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt;. If you tried to use &lt;code&gt;list_max/1&lt;/code&gt; with an empty list or tried to use it with something that is not a list at all, you would cause an error. Notice that the Erlang philosophy is not to handle errors of this type in the function they occur, but to do so elsewhere. More about this later.</source>
          <target state="translated">En este ejemplo, recorre una lista que &quot;lleva&quot; un valor, en este caso &lt;code&gt;Result_so_far&lt;/code&gt; . &lt;code&gt;list_max/1&lt;/code&gt; simplemente asume que el valor m&amp;aacute;ximo de la lista es el encabezado de la lista y llama a &lt;code&gt;list_max/2&lt;/code&gt; con el resto de la lista y el valor del encabezado de la lista. En lo anterior, esto ser&amp;iacute;a &lt;code&gt;list_max([2,3,4,5,7,4,3,2,1],1)&lt;/code&gt; . Si intenta usar &lt;code&gt;list_max/1&lt;/code&gt; con una lista vac&amp;iacute;a o intenta usarlo con algo que no es una lista en absoluto, causar&amp;iacute;a un error. Tenga en cuenta que la filosof&amp;iacute;a de Erlang no es manejar errores de este tipo en la funci&amp;oacute;n en que ocurren, sino hacerlo en otro lugar. M&amp;aacute;s sobre esto m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="56448ac7090741dff16bd4c666efd111e9722e23" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;suite/0&lt;/code&gt; tells &lt;code&gt;Common Test&lt;/code&gt; to suppress printouts from Telnet and SSH connections. This is valid for all test cases. However, &lt;code&gt;my_testcase1/0&lt;/code&gt; specifies that for this test case, only SSH is to be silent. The result is that &lt;code&gt;my_testcase1&lt;/code&gt; gets Telnet information (if any) printed in the log, but not SSH information. &lt;code&gt;my_testcase2&lt;/code&gt; gets no information from either connection printed.</source>
          <target state="translated">En este ejemplo, &lt;code&gt;suite/0&lt;/code&gt; le dice a &lt;code&gt;Common Test&lt;/code&gt; que suprima las impresiones de las conexiones Telnet y SSH. Esto es v&amp;aacute;lido para todos los casos de prueba. Sin embargo, &lt;code&gt;my_testcase1/0&lt;/code&gt; especifica que para este caso de prueba, solo SSH debe permanecer en silencio. El resultado es que &lt;code&gt;my_testcase1&lt;/code&gt; obtiene la informaci&amp;oacute;n de Telnet (si existe) impresa en el registro, pero no la informaci&amp;oacute;n de SSH. &lt;code&gt;my_testcase2&lt;/code&gt; no obtiene informaci&amp;oacute;n de ninguna de las conexiones impresas.</target>
        </trans-unit>
        <trans-unit id="f2f906325545f1417f1e6e7ea85883ce6305f126" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9978d9c124f3a9ceaa1001295460a53442590274" translate="yes" xml:space="preserve">
          <source>In this example, &lt;code&gt;{Pid, Something}&lt;/code&gt; is received. The received pid is then used to return &lt;code&gt;{goodbye,Pid}&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, se recibe &lt;code&gt;{Pid, Something}&lt;/code&gt; . El pid recibido se utiliza para devolver &lt;code&gt;{goodbye,Pid}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8cca447955be1a950232a8170dee175e96b1885" translate="yes" xml:space="preserve">
          <source>In this example, a series of bytes is received from an external source and the bytes are then decoded into a valid Erlang term. This was achieved with the call &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt;, which returned an Erlang value of the ASN.1 type &lt;code&gt;Person&lt;/code&gt;. Then an answer was constructed and encoded using &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt;, which takes an instance of a defined ASN.1 type and transforms it to a binary according to the BER or PER encoding rules.</source>
          <target state="translated">En este ejemplo, se recibe una serie de bytes de una fuente externa y luego los bytes se decodifican en un t&amp;eacute;rmino Erlang v&amp;aacute;lido. Esto se logr&amp;oacute; con la llamada &lt;code&gt;'People':decode('Person',Bytes)&lt;/code&gt; , que devolvi&amp;oacute; un valor Erlang del tipo &lt;code&gt;Person&lt;/code&gt; a ASN.1 . Luego, se construy&amp;oacute; y codific&amp;oacute; una respuesta usando &lt;code&gt;'People':encode('Person',Answer)&lt;/code&gt; , que toma una instancia de un tipo ASN.1 definido y la transforma en un binario de acuerdo con las reglas de codificaci&amp;oacute;n BER o PER.</target>
        </trans-unit>
        <trans-unit id="5e2e0fa61e63c35e50233a9616eb00e4ea0cac5e" translate="yes" xml:space="preserve">
          <source>In this example, a tracer module with a NIF back end sends a message for each &lt;code&gt;send&lt;/code&gt; trace tag containing only the sender and receiver. Using this tracer module, a much more lightweight message tracer is used, which only records who sent messages to who.</source>
          <target state="translated">En este ejemplo, un m&amp;oacute;dulo de seguimiento con un back-end NIF env&amp;iacute;a un mensaje por cada etiqueta de seguimiento de &lt;code&gt;send&lt;/code&gt; contiene solo el remitente y el receptor. Con este m&amp;oacute;dulo de seguimiento, se utiliza un seguimiento de mensajes mucho m&amp;aacute;s ligero, que solo registra qui&amp;eacute;n envi&amp;oacute; mensajes a qui&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="6d8dde7ce6106260a6067f905d420de2cd6f2ca5" translate="yes" xml:space="preserve">
          <source>In this example, an Erlang runtime system is started with environment variable &lt;code&gt;DISPLAY&lt;/code&gt; set to &lt;code&gt;gin:0&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, un sistema en tiempo de ejecuci&amp;oacute;n de Erlang se inicia con la variable de entorno &lt;code&gt;DISPLAY&lt;/code&gt; establecida en &lt;code&gt;gin:0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c3b7e2dc3ec86592b2c4fe3d4be281594efc1a2e" translate="yes" xml:space="preserve">
          <source>In this example, an attempt was made to output the single character 65 with the aid of the string formatting directive &lt;code&gt;&quot;~s&quot;&lt;/code&gt;.</source>
          <target state="translated">En este ejemplo, se intent&amp;oacute; dar salida al car&amp;aacute;cter &amp;uacute;nico 65 con la ayuda de la directiva de formato de cadena &lt;code&gt;&quot;~s&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43586affa45b8e696e51f04b01e7960b0c11c14b" translate="yes" xml:space="preserve">
          <source>In this example, any user tag set in the calling process will be spread to the I/O-server when the io:format call is done.</source>
          <target state="translated">En este ejemplo,cualquier etiqueta de usuario establecida en el proceso de llamada se extenderá al servidor de E/S cuando se haga la llamada io:format.</target>
        </trans-unit>
        <trans-unit id="66bc53b66445d9e9e48935dda092b0ae0570b399" translate="yes" xml:space="preserve">
          <source>In this example, each runtime system have two schedulers each online, and all schedulers online will run on different cores. If we change to one scheduler online on one runtime system, and three schedulers online on the other, all schedulers online will still run on different cores.</source>
          <target state="translated">En este ejemplo,cada sistema de tiempo de ejecución tiene dos planificadores en línea,y todos los planificadores en línea se ejecutarán en núcleos diferentes.Si cambiamos a un programador en línea en un sistema de tiempo de ejecución y a tres programadores en línea en el otro,todos los programadores en línea seguirán funcionando en núcleos diferentes.</target>
        </trans-unit>
        <trans-unit id="7ecf9ae27bd24989b3021f8b4c4bfca0ad2ceaf5" translate="yes" xml:space="preserve">
          <source>In this example, function &lt;code&gt;terminate/3&lt;/code&gt; locks the door if it is open, so we do not accidentally leave the door open when the supervision tree terminates:</source>
          <target state="translated">En este ejemplo, la funci&amp;oacute;n &lt;code&gt;terminate/3&lt;/code&gt; bloquea la puerta si est&amp;aacute; abierta, por lo que no dejamos la puerta abierta accidentalmente cuando finaliza el &amp;aacute;rbol de supervisi&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="960ac5061c7b8584acad2089c9295c51aa2f8869" translate="yes" xml:space="preserve">
          <source>In this example, if the first element had been the key, it is much more efficient to match that key in the &lt;code&gt;MatchHead&lt;/code&gt; part than in the &lt;code&gt;MatchConditions&lt;/code&gt; part. The search space of the tables is restricted with regards to the &lt;code&gt;MatchHead&lt;/code&gt; so that only objects with the matching key are searched.</source>
          <target state="translated">En este ejemplo, si el primer elemento hubiera sido la clave, es mucho m&amp;aacute;s eficiente hacer coincidir esa clave en la parte &lt;code&gt;MatchHead&lt;/code&gt; que en la parte &lt;code&gt;MatchConditions&lt;/code&gt; . El espacio de b&amp;uacute;squeda de las tablas est&amp;aacute; restringido con respecto al &lt;code&gt;MatchHead&lt;/code&gt; para que solo se busquen los objetos con la clave correspondiente.</target>
        </trans-unit>
        <trans-unit id="434bd6540f3c6df5778ba2e32f9a39db0be5e9d8" translate="yes" xml:space="preserve">
          <source>In this example, instead of ignoring button events while in the &lt;code&gt;open&lt;/code&gt; state, we can postpone them and they are queued and later handled in the &lt;code&gt;locked&lt;/code&gt; state:</source>
          <target state="translated">En este ejemplo, en lugar de ignorar los eventos de bot&amp;oacute;n mientras est&amp;aacute;n en estado &lt;code&gt;open&lt;/code&gt; , podemos posponerlos y se ponen en cola y luego se manejan en el estado &lt;code&gt;locked&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bf50f8222a786a9423d6bbc25bbbef0a7253d10d" translate="yes" xml:space="preserve">
          <source>In this example, the following actions are performed:</source>
          <target state="translated">En este ejemplo,se realizan las siguientes acciones:</target>
        </trans-unit>
        <trans-unit id="dfa0e603f6362ff9bd3405f39acb715fb921e826" translate="yes" xml:space="preserve">
          <source>In this example, the same ASN.1 specification as in Section &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; is used. The following is a valid selective decode instruction:</source>
          <target state="translated">En este ejemplo, se utiliza la misma especificaci&amp;oacute;n ASN.1 que en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#Asn1spec&quot;&gt;Writing an Exclusive Decode Instruction&lt;/a&gt;&lt;/code&gt; . La siguiente es una instrucci&amp;oacute;n de decodificaci&amp;oacute;n selectiva v&amp;aacute;lida:</target>
        </trans-unit>
        <trans-unit id="e3527cbb7e8c4dd557e4aee1d0751b68ffeeff64" translate="yes" xml:space="preserve">
          <source>In this example, the test terms defined in files &quot;b.spec&quot; and &quot;c.spec&quot; are joined with the terms in source specification &quot;a.spec&quot; (if any). The inclusion of specifications &quot;d.spec&quot; and &quot;e.spec&quot; results in two separate, and independent, test runs (one for each included specification).</source>
          <target state="translated">En este ejemplo,los términos de prueba definidos en los archivos &quot;b.spec&quot; y &quot;c.spec&quot; se unen a los términos de la especificación de origen &quot;a.spec&quot; (si existe).La inclusión de las especificaciones &quot;d.spec&quot; y &quot;e.spec&quot; da lugar a dos pruebas separadas e independientes (una para cada especificación incluida).</target>
        </trans-unit>
        <trans-unit id="591e558504b589362aa8ec521cf9d41254ba089c" translate="yes" xml:space="preserve">
          <source>In this example, we chose to copy the binary content before inserting it in &lt;code&gt;gb_sets:set()&lt;/code&gt; if it references a binary more than twice the data size we want to keep. Of course, different rules apply when copying to different programs.</source>
          <target state="translated">En este ejemplo, elegimos copiar el contenido binario antes de insertarlo en &lt;code&gt;gb_sets:set()&lt;/code&gt; si hace referencia a un binario m&amp;aacute;s del doble del tama&amp;ntilde;o de datos que queremos mantener. Por supuesto, se aplican diferentes reglas al copiar a diferentes programas.</target>
        </trans-unit>
        <trans-unit id="dc86ae4cb1275e535c2e78420e2da7f468d13800" translate="yes" xml:space="preserve">
          <source>In this example, we in put the 'diffie-hellman-group1-sha1' first and also move the &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; to the end in the kex list, that is, &lt;code&gt;append&lt;/code&gt; it.</source>
          <target state="translated">En este ejemplo, nos ponemos en el 'Diffie-Hellman-grupo1-sha1' primeramente, y tambi&amp;eacute;n mover el &lt;code&gt;'ecdh-sha2-nistp521'&lt;/code&gt; hasta el final de la lista KEX, es decir, &lt;code&gt;append&lt;/code&gt; ella.</target>
        </trans-unit>
        <trans-unit id="0bbaf70ab3110bc7a5e89c28c21c815ba1de5783" translate="yes" xml:space="preserve">
          <source>In this example, we use both options (&lt;code&gt;preferred_algorithms&lt;/code&gt; and &lt;code&gt;modify_algorithms&lt;/code&gt;) and also try to prepend an unsupported algorithm. Any unsupported algorithm is quietly removed.</source>
          <target state="translated">En este ejemplo, usamos ambas opciones ( &lt;code&gt;preferred_algorithms&lt;/code&gt; y &lt;code&gt;modify_algorithms&lt;/code&gt; ) y tambi&amp;eacute;n intentamos anteponer un algoritmo no compatible. Cualquier algoritmo no compatible se elimina silenciosamente.</target>
        </trans-unit>
        <trans-unit id="ee5453691e19483eb4be3db95d70cb64c5c4684a" translate="yes" xml:space="preserve">
          <source>In this examples, the definitions from the following ASN.1 specification are used:</source>
          <target state="translated">En estos ejemplos se utilizan las definiciones de la siguiente especificación ASN.1:</target>
        </trans-unit>
        <trans-unit id="3b6a8f84b986da01a683c86c723aa87e5db42995" translate="yes" xml:space="preserve">
          <source>In this following example, the password is &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt;:</source>
          <target state="translated">En el siguiente ejemplo, la contrase&amp;ntilde;a es &lt;code&gt;&quot;abcd1234&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ef1f632c9246a97f789f4334b5d6c5e381fbdc5d" translate="yes" xml:space="preserve">
          <source>In this mode the following can be done:</source>
          <target state="translated">En este modo se puede hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="994fd4fb79d55c888264214dbe057f79d04e488e" translate="yes" xml:space="preserve">
          <source>In this module, V is allowed to be empty. The so obtained unique digraph is called the &lt;strong id=&quot;empty_digraph&quot;&gt;empty digraph&lt;/strong&gt;. Both vertices and edges are represented by unique Erlang terms.</source>
          <target state="translated">En este m&amp;oacute;dulo, se permite que V est&amp;eacute; vac&amp;iacute;o. El d&amp;iacute;grafo &amp;uacute;nico as&amp;iacute; obtenido se llama &lt;strong id=&quot;empty_digraph&quot;&gt;d&amp;iacute;grafo vac&amp;iacute;o&lt;/strong&gt; . Tanto los v&amp;eacute;rtices como las aristas est&amp;aacute;n representados por t&amp;eacute;rminos &amp;uacute;nicos de Erlang.</target>
        </trans-unit>
        <trans-unit id="712d363aaa0e39c08276d452dd321570bc580bff" translate="yes" xml:space="preserve">
          <source>In this module, the only families that are considered are families of subsets of some set X; in the following, the word &quot;family&quot; is used for such families of subsets.</source>
          <target state="translated">En este módulo,las únicas familias que se consideran son las familias de subconjuntos de algún conjunto X;a continuación se utiliza la palabra &quot;familia&quot; para esas familias de subconjuntos.</target>
        </trans-unit>
        <trans-unit id="9df8795a77ab5095acba5e23497d16dae8d5c2f4" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the time-out since the time-out event is the only possible reason to do a &lt;strong&gt;state change&lt;/strong&gt; from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e66b7cabeee4a12f3d6c96b7b3841a688c3bd15c" translate="yes" xml:space="preserve">
          <source>In this particular case we do not need to cancel the timeout since the timeout event is the only possible reason to change the state from &lt;code&gt;open&lt;/code&gt; to &lt;code&gt;locked&lt;/code&gt;.</source>
          <target state="translated">En este caso particular, no es necesario cancelar el tiempo de espera, ya que el evento de tiempo de espera es la &amp;uacute;nica raz&amp;oacute;n posible para cambiar el estado de &lt;code&gt;open&lt;/code&gt; a &lt;code&gt;locked&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6554cfbd72e76e1ac3cdf9960a6f08456669452" translate="yes" xml:space="preserve">
          <source>In this particular case, command &lt;code&gt;i&lt;/code&gt; (&quot;interrupt&quot;) terminates the looping program, and command &lt;code&gt;c&lt;/code&gt; connects to the shell again. As the process was running in the background before we killed it, more printouts occur before message &quot;&lt;code&gt;** exception exit: killed&lt;/code&gt;&quot; is shown.</source>
          <target state="translated">En este caso particular, el comando &lt;code&gt;i&lt;/code&gt; (&quot;interrumpir&quot;) finaliza el programa en bucle y el comando &lt;code&gt;c&lt;/code&gt; se conecta de nuevo al shell. Como el proceso se estaba ejecutando en segundo plano antes de que lo elimin&amp;aacute;ramos, se producen m&amp;aacute;s impresiones antes de que se muestre el mensaje &quot; &lt;code&gt;** exception exit: killed&lt;/code&gt; &quot;.</target>
        </trans-unit>
        <trans-unit id="a202e49451669337a36807112b38f9adf4744b69" translate="yes" xml:space="preserve">
          <source>In this scenario the lock that protects ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; has spent most of its waiting for. That is 1.8 seconds in a test that run for 60 seconds. The time is also spread on eight different scheduler threads.</source>
          <target state="translated">En este escenario, el bloqueo que protege ets-table &lt;code&gt;mnesia_transient_decision&lt;/code&gt; ha pasado la mayor parte de su espera. Eso es 1.8 segundos en una prueba que dura 60 segundos. El tiempo tambi&amp;eacute;n se distribuye en ocho subprocesos de programaci&amp;oacute;n diferentes.</target>
        </trans-unit>
        <trans-unit id="861466576140ad1635f300aa485a4cde311c192e" translate="yes" xml:space="preserve">
          <source>In this section a &lt;code&gt;Domain&lt;/code&gt; field is the transport domain i.e one of &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt;, and an &lt;code&gt;Addr&lt;/code&gt; field is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">En esta secci&amp;oacute;n un &lt;code&gt;Domain&lt;/code&gt; campo es el dominio de transporte es decir, uno de &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; o &lt;code&gt;transportDomainUdpIpv6&lt;/code&gt; , y un &lt;code&gt;Addr&lt;/code&gt; campo es un &lt;code&gt;{&lt;/code&gt; &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;,IpPort}&lt;/code&gt; tupla.</target>
        </trans-unit>
        <trans-unit id="8408871bf44d5f19fd252aea95c29bc2e768f170" translate="yes" xml:space="preserve">
          <source>In this section an &lt;code&gt;Address&lt;/code&gt; field is a &lt;code&gt;{Domain, Addr}&lt;/code&gt; tuple where &lt;code&gt;Domain&lt;/code&gt; is &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; or &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt;, and &lt;code&gt;Addr&lt;/code&gt; is an &lt;code&gt;{&lt;/code&gt;&lt;code&gt;IpAddr&lt;/code&gt;&lt;code&gt;,IpPort}&lt;/code&gt; tuple.</source>
          <target state="translated">En esta secci&amp;oacute;n, un campo de &lt;code&gt;Address&lt;/code&gt; es una tupla &lt;code&gt;{Domain, Addr}&lt;/code&gt; donde &lt;code&gt;Domain&lt;/code&gt; es &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; o &lt;code&gt;transportDomainUdpIpv4&lt;/code&gt; , y &lt;code&gt;Addr&lt;/code&gt; es una &lt;code&gt;IpAddr&lt;/code&gt; &lt;code&gt;{&lt;/code&gt; IpAddr &lt;code&gt;,IpPort}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99f63d92bf0f7c0a3f35d120e4d7baace3952b21" translate="yes" xml:space="preserve">
          <source>In this section, all valid Erlang expressions are listed. When writing Erlang programs, it is also allowed to use macro- and record expressions. However, these expressions are expanded during compilation and are in that sense not true Erlang expressions. Macro- and record expressions are covered in separate sections:</source>
          <target state="translated">En esta sección,se enumeran todas las expresiones Erlang válidas.Cuando se escriben programas Erlang,también se permite usar expresiones de macro y de registro.Sin embargo,estas expresiones se amplían durante la compilación y en ese sentido no son verdaderas expresiones Erlang.Las expresiones de macros y registros se tratan en secciones separadas:</target>
        </trans-unit>
        <trans-unit id="7b4d3e5b6a78745c8c43082e99a7d0df32dc4509" translate="yes" xml:space="preserve">
          <source>In this section, it is assumed that the username is &lt;code&gt;otpuser&lt;/code&gt; and that the home directory of that user is:</source>
          <target state="translated">En esta secci&amp;oacute;n, se asume que el nombre de usuario es &lt;code&gt;otpuser&lt;/code&gt; y que el directorio de inicio de ese usuario es:</target>
        </trans-unit>
        <trans-unit id="d8badf52dbf4567555546e910013615a3db3a8dd" translate="yes" xml:space="preserve">
          <source>In this section, the following terminology is used:</source>
          <target state="translated">En esta sección se utiliza la siguiente terminología:</target>
        </trans-unit>
        <trans-unit id="7a8d09dba986cc4a1cce2aa142a6efb735508b29" translate="yes" xml:space="preserve">
          <source>In this simple case, the former expression is probably preferable in terms of readability.</source>
          <target state="translated">En este simple caso,la primera expresión es probablemente preferible en términos de legibilidad.</target>
        </trans-unit>
        <trans-unit id="26a9a0725bf356efe21e2e59d7c4c0fd0009aece" translate="yes" xml:space="preserve">
          <source>In this way you can connect all processes in a transaction together using links. If one of the processes exits abnormally, all the processes in the transaction are killed. As it is often wanted to create a process and link to it at the same time, there is a special BIF, &lt;code&gt;spawn_link&lt;/code&gt; that does the same as &lt;code&gt;spawn&lt;/code&gt;, but also creates a link to the spawned process.</source>
          <target state="translated">De esta forma, puede conectar todos los procesos de una transacci&amp;oacute;n mediante enlaces. Si uno de los procesos sale de forma anormal, todos los procesos de la transacci&amp;oacute;n se eliminan. Como a menudo se desea crear un proceso y vincularlo a &amp;eacute;l al mismo tiempo, hay un BIF especial, &lt;code&gt;spawn_link&lt;/code&gt; que hace lo mismo que &lt;code&gt;spawn&lt;/code&gt; , pero tambi&amp;eacute;n crea un enlace al proceso generado.</target>
        </trans-unit>
        <trans-unit id="04cd30a6181cf29b11e39620fc1e71c03e622ab5" translate="yes" xml:space="preserve">
          <source>In those circumstances, &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; must be invoked to set up the pointer again. &lt;strong&gt;beam_makeops&lt;/strong&gt; will notice if there is a call to a function that does a garbage collection and &lt;code&gt;$REFRESH_GEN_DEST()&lt;/code&gt; is not called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12987c6a024d031823b3213c0fb06e759b8cd0bf" translate="yes" xml:space="preserve">
          <source>In those functions the internal crypto state is first created and initialized with the cipher type, the key and possibly other data. Then the single binary is encrypted or decrypted, the crypto state is de-allocated and the result of the crypto operation is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101b35ccce64e2d00c7201dde3bdfc7472ddac0c" translate="yes" xml:space="preserve">
          <source>In traditional relational database terminology, this operation is called a selection, followed by a projection.</source>
          <target state="translated">En la terminología tradicional de las bases de datos relacionales,esta operación se denomina selección,seguida de proyección.</target>
        </trans-unit>
        <trans-unit id="1ec3c1eab704912540b1a90c690dfcb4bdf6cc6e" translate="yes" xml:space="preserve">
          <source>In type &lt;code&gt;StartMessage&lt;/code&gt;, the constraint following field &lt;code&gt;content&lt;/code&gt; tells that in a value of type &lt;code&gt;StartMessage&lt;/code&gt; the value in field &lt;code&gt;content&lt;/code&gt; must come from the same object that is chosen by field &lt;code&gt;msgId&lt;/code&gt;.</source>
          <target state="translated">En el tipo &lt;code&gt;StartMessage&lt;/code&gt; , la restricci&amp;oacute;n que sigue al &lt;code&gt;content&lt;/code&gt; campo indica que en un valor de tipo &lt;code&gt;StartMessage&lt;/code&gt; , el valor del &lt;code&gt;content&lt;/code&gt; campo debe provenir del mismo objeto que se elige en el campo &lt;code&gt;msgId&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3258ab5defec1c2d9288e54d368e065797c6dfc5" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard the Segmentation package was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En la versi&amp;oacute;n 3 del est&amp;aacute;ndar megaco se introdujo el paquete de segmentaci&amp;oacute;n. Simplemente, este paquete define un procedimiento para segmentar los mensajes megaco (respuestas de transacciones) cuando se usa un transporte que no lo hace autom&amp;aacute;ticamente (por ejemplo, UDP). Consulte tambi&amp;eacute;n la &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63b6f2d5cd37bdba6df81460e958046ee197cfa0" translate="yes" xml:space="preserve">
          <source>In version 3 of the megaco standard, the concept of &lt;code&gt;segmentation package&lt;/code&gt; was introduced. Simply, this package defines a procedure to segment megaco messages (transaction replies) when using a transport that does not automatically do this (e.g. UDP). See also &lt;code&gt;&lt;a href=&quot;megaco_encode#handling_versions&quot;&gt;version3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61a1a66fb7d34cc42d2ce16b8d6f94cde6e973d3" translate="yes" xml:space="preserve">
          <source>In which OTP version was &lt;code&gt;kernel-3.0&lt;/code&gt; introduced?</source>
          <target state="translated">&amp;iquest;En qu&amp;eacute; versi&amp;oacute;n de OTP se introdujo el &lt;code&gt;kernel-3.0&lt;/code&gt; ?</target>
        </trans-unit>
        <trans-unit id="8c5125d1b5f67d94423a5e620a14a0a6f8eab1be" translate="yes" xml:space="preserve">
          <source>In your own trace handler function, call &lt;code&gt;erlang:display/1&lt;/code&gt; instead of an &lt;code&gt;io&lt;/code&gt; function or, if &lt;code&gt;user&lt;/code&gt; is not used as group leader, print to &lt;code&gt;user&lt;/code&gt; instead of the default group leader. Example: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt;.</source>
          <target state="translated">En su propia funci&amp;oacute;n de controlador de seguimiento, llame a &lt;code&gt;erlang:display/1&lt;/code&gt; en lugar de una funci&amp;oacute;n &lt;code&gt;io&lt;/code&gt; o, si el &lt;code&gt;user&lt;/code&gt; no se usa como l&amp;iacute;der de grupo, imprima al &lt;code&gt;user&lt;/code&gt; lugar del l&amp;iacute;der de grupo predeterminado. Ejemplo: &lt;code&gt;io:format(user,Str,Args)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd3623c7af3873c7365b3e9ecec792ba6339bafc" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP</source>
          <target state="translated">Inband-Security-Id AVP</target>
        </trans-unit>
        <trans-unit id="1fcccda86c3d18620423152a36c25cd6e0ea26b2" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id AVP (code 299)</source>
          <target state="translated">Inband-Security-Id AVP (código 299)</target>
        </trans-unit>
        <trans-unit id="bc29841cf89dc194cd8a81695be51412c487f1e5" translate="yes" xml:space="preserve">
          <source>Inband-Security-Id defaults to the empty list, which is equivalent to a list containing only 0 (NO_INBAND_SECURITY). If 1 (TLS) is specified then TLS is selected if the CER/CEA received from the peer offers it.</source>
          <target state="translated">En Inband-Security-Id se utiliza por defecto la lista vacía,que equivale a una lista que contiene sólo 0 (NO_INBAND_SECURITY).Si se especifica 1 (TLS),entonces se selecciona TLS si el CER/CEA recibido del par lo ofrece.</target>
        </trans-unit>
        <trans-unit id="68aefeb8f958a940e3df275c2e8ab565491e5d57" translate="yes" xml:space="preserve">
          <source>Inbound binary encoding in binaries</source>
          <target state="translated">Codificación binaria entrante en binarios</target>
        </trans-unit>
        <trans-unit id="d56147eef88de9f893558ccd93afaeb646d97eb3" translate="yes" xml:space="preserve">
          <source>Inbound percent-encoding in lists and binaries</source>
          <target state="translated">Porcentaje de entrada-codificación en listas y binarios</target>
        </trans-unit>
        <trans-unit id="4299e563cfdb9c828cf33fe283405a0895b02723" translate="yes" xml:space="preserve">
          <source>Incidentally, when the test case is corrected a bug in &lt;code&gt;channel&lt;/code&gt; should indeed be discovered.</source>
          <target state="translated">Por cierto, cuando se corrige el caso de prueba &lt;code&gt;channel&lt;/code&gt; deber&amp;iacute;a descubrirse un error en el canal .</target>
        </trans-unit>
        <trans-unit id="8d1177bed65615f7e3e96bb2bc20a45bf85a59a4" translate="yes" xml:space="preserve">
          <source>Include &lt;code&gt;dir&lt;/code&gt; in the path for Erlang. This is useful when analyzing files that have &lt;code&gt;-include_lib()&lt;/code&gt; directives.</source>
          <target state="translated">Incluya &lt;code&gt;dir&lt;/code&gt; en la ruta de Erlang. Esto es &amp;uacute;til al analizar archivos que tienen directivas &lt;code&gt;-include_lib()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cae53151741eb56a1003fee69921d65824bcd040" translate="yes" xml:space="preserve">
          <source>Include Directories and Macro Definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9d42f8b8c943f9e74d7049cab7a4c9266e260a" translate="yes" xml:space="preserve">
          <source>Include directories can also be specified in test specifications, see &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los directorios incluidos tambi&amp;eacute;n se pueden especificar en las especificaciones de prueba, consulte &lt;code&gt;&lt;a href=&quot;#test_specifications&quot;&gt;Test Specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc0da023e49fc7b9722125176291007176551c43" translate="yes" xml:space="preserve">
          <source>Include file</source>
          <target state="translated">Incluya el archivo</target>
        </trans-unit>
        <trans-unit id="1be005482133f6ba0ad7a717822aee960ab1bc89" translate="yes" xml:space="preserve">
          <source>Include files are typically used for record and macro definitions that are shared by several modules. It is recommended to use the file name extension &lt;code&gt;.hrl&lt;/code&gt; for include files.</source>
          <target state="translated">Los archivos de inclusi&amp;oacute;n se utilizan normalmente para las definiciones de registros y macros que comparten varios m&amp;oacute;dulos. Se recomienda utilizar la extensi&amp;oacute;n de nombre de archivo &lt;code&gt;.hrl&lt;/code&gt; para incluir archivos.</target>
        </trans-unit>
        <trans-unit id="6ec71a4f09bb1029d3d4fb8244b9d00627d2bcc0" translate="yes" xml:space="preserve">
          <source>Include the correct tool's include file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44d2f9132c06fd784b8209fba5bb20aa3ee8c4fa" translate="yes" xml:space="preserve">
          <source>Include the token text in the token annotation. The text is the part of the input corresponding to the token.</source>
          <target state="translated">Incluya el texto de la ficha en la anotación de la ficha.El texto es la parte de la entrada correspondiente a la ficha.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
