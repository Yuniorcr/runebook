<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="713d45f85233ed9eece81ff1efd22a57b2efbd58" translate="yes" xml:space="preserve">
          <source>Here we check the result from postgres. If it is data, we encode it as lists of lists with column data. Everything from postgres is C strings, so we use &lt;code&gt;ei_x_encode_string&lt;/code&gt; to send the result as strings to Erlang. (The head of the list contains the column names.)</source>
          <target state="translated">Aqu&amp;iacute; verificamos el resultado de postgres. Si son datos, los codificamos como listas de listas con datos de columna. Todo desde postgres son cadenas de C, por lo que usamos &lt;code&gt;ei_x_encode_string&lt;/code&gt; para enviar el resultado como cadenas a Erlang. (El encabezado de la lista contiene los nombres de las columnas).</target>
        </trans-unit>
        <trans-unit id="8cf9c63e747cf336dd3ef22dd8cb27c624c36fc6" translate="yes" xml:space="preserve">
          <source>Here we create an archive script containing both Erlang code and Beam code, then we iterate over all files in the archive and collect their contents and some information about them:</source>
          <target state="translated">Aquí creamos un script de archivo que contiene tanto el código Erlang como el código Beam,luego iteramos sobre todos los archivos del archivo y recogemos su contenido y alguna información sobre ellos:</target>
        </trans-unit>
        <trans-unit id="1a6714f5fe50c9a6bae77694ae3f43b0dac16cb9" translate="yes" xml:space="preserve">
          <source>Here we create file named &lt;code&gt;TAGS&lt;/code&gt; placed it in the directory &lt;code&gt;../projectdir&lt;/code&gt;. The file contains information about the functions, records, and macro definitions of the three files.</source>
          <target state="translated">Aqu&amp;iacute; creamos un archivo llamado &lt;code&gt;TAGS&lt;/code&gt; y lo colocamos en el directorio &lt;code&gt;../projectdir&lt;/code&gt; . El archivo contiene informaci&amp;oacute;n sobre las funciones, registros y definiciones de macros de los tres archivos.</target>
        </trans-unit>
        <trans-unit id="9874d5ad87ce020d9aa6aeca71513d4b4236fc2e" translate="yes" xml:space="preserve">
          <source>Here we have cheated a little by more or less only implementing &lt;code&gt;get_until&lt;/code&gt; and using internal helpers to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt;. In production code, this can be inefficient, but that depends on the frequency of the different requests. Before we start implementing functions &lt;code&gt;put_chars/2&lt;/code&gt; and &lt;code&gt;get_until/5&lt;/code&gt;, we examine the few remaining requests:</source>
          <target state="translated">Aqu&amp;iacute; hemos hecho un poco de trampa al implementar m&amp;aacute;s o menos solo &lt;code&gt;get_until&lt;/code&gt; y usar ayudantes internos para implementar &lt;code&gt;get_chars&lt;/code&gt; y &lt;code&gt;get_line&lt;/code&gt; . En el c&amp;oacute;digo de producci&amp;oacute;n, esto puede ser ineficiente, pero eso depende de la frecuencia de las diferentes solicitudes. Antes de comenzar a implementar las funciones &lt;code&gt;put_chars/2&lt;/code&gt; y &lt;code&gt;get_until/5&lt;/code&gt; , examinamos las pocas solicitudes restantes:</target>
        </trans-unit>
        <trans-unit id="6510718f8630e547e008ebde09d2abc7f3c89e66" translate="yes" xml:space="preserve">
          <source>Here we see that no function distinguishes itself considerably, which is very normal.</source>
          <target state="translated">Aquí vemos que ninguna función se distingue considerablemente,lo cual es muy normal.</target>
        </trans-unit>
        <trans-unit id="eaf2aac2ad0fe378997e3d3e60e43ee8d81edf6f" translate="yes" xml:space="preserve">
          <source>Here you see the use of &lt;code&gt;|&lt;/code&gt; to get the first two elements from the list. If you try to get more elements from the list than there are elements in the list, an error is returned. Notice also the special case of the list with no elements, []:</source>
          <target state="translated">Aqu&amp;iacute; ves el uso de &lt;code&gt;|&lt;/code&gt; para obtener los dos primeros elementos de la lista. Si intenta obtener m&amp;aacute;s elementos de la lista que elementos en la lista, se devuelve un error. Observe tambi&amp;eacute;n el caso especial de la lista sin elementos, []:</target>
        </trans-unit>
        <trans-unit id="08b89fd2c7d9c7d70984a33c283c54baceee4244" translate="yes" xml:space="preserve">
          <source>Here's another example:</source>
          <target state="translated">Aquí hay otro ejemplo:</target>
        </trans-unit>
        <trans-unit id="7996ce3c70bc2e6c31030c0947978923388510ef" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are any expressions and &lt;code&gt;M0&lt;/code&gt; through &lt;code&gt;M4&lt;/code&gt; are the resulting map terms.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; son cualquier expresi&amp;oacute;n y &lt;code&gt;M0&lt;/code&gt; a &lt;code&gt;M4&lt;/code&gt; son los t&amp;eacute;rminos del mapa resultantes.</target>
        </trans-unit>
        <trans-unit id="c7c0f63e6feeafed42e889764b5df7fa6ae6b07c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Arguments&lt;/code&gt; is a list of zero or more arguments. The &lt;code&gt;-callback&lt;/code&gt; attribute is to be preferred since the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;Arguments&lt;/code&gt; es una lista de cero o m&amp;aacute;s argumentos. Se &lt;code&gt;-callback&lt;/code&gt; atributo -callback ya que las herramientas pueden utilizar la informaci&amp;oacute;n de tipo adicional para producir documentaci&amp;oacute;n o encontrar discrepancias.</target>
        </trans-unit>
        <trans-unit id="2f63ec204ef51669a64a9412596d13bb3d314da9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Bin&lt;/code&gt; is bound and the elements are bound or unbound, as in any match.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;Bin&lt;/code&gt; est&amp;aacute; vinculado y los elementos est&amp;aacute;n vinculados o no, como en cualquier partido.</target>
        </trans-unit>
        <trans-unit id="973cdf584bee5b3aebaf02a66418e8e39a601f3c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Expr&lt;/code&gt; is an arbitrary expression, and each &lt;code&gt;Qualifier&lt;/code&gt; is either a generator or a filter.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;Expr&lt;/code&gt; es una expresi&amp;oacute;n arbitraria y cada &lt;code&gt;Qualifier&lt;/code&gt; es un generador o un filtro.</target>
        </trans-unit>
        <trans-unit id="bfa551fd993d5a7e252540038e550aefce8b5242" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Fd&lt;/code&gt; is the file descriptor for the destination file, or the atom &lt;code&gt;standard_io&lt;/code&gt;. &lt;code&gt;_TraceInfo&lt;/code&gt; contains information from the trace information file (see section &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;State&lt;/code&gt; is a state variable for the format handler fun. The initial value of variable &lt;code&gt;State&lt;/code&gt; is specified with the handler option, for example:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;Fd&lt;/code&gt; es el descriptor de archivo para el archivo de destino, o el atom &lt;code&gt;standard_io&lt;/code&gt; . &lt;code&gt;_TraceInfo&lt;/code&gt; contiene informaci&amp;oacute;n del archivo de informaci&amp;oacute;n de seguimiento (consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;State&lt;/code&gt; es una variable de estado para la diversi&amp;oacute;n del controlador de formato. El valor inicial de la variable &lt;code&gt;State&lt;/code&gt; se especifica con la opci&amp;oacute;n del controlador, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="034cc33bbe80f01fd04e26b576b575b1176dd3da" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;File&lt;/code&gt; is used as the new variable instead of &lt;code&gt;X&lt;/code&gt;. This is not so wise because code in the fun body cannot refer to the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside of the fun. Compiling this example gives the following diagnostic:</source>
          <target state="translated">A continuaci&amp;oacute;n, &lt;code&gt;File&lt;/code&gt; se utiliza como la nueva variable en lugar de &lt;code&gt;X&lt;/code&gt; . Esto no es tan sabio porque el c&amp;oacute;digo en el cuerpo de la diversi&amp;oacute;n no puede hacer referencia a la variable &lt;code&gt;File&lt;/code&gt; , que se define fuera de la diversi&amp;oacute;n. La compilaci&amp;oacute;n de este ejemplo proporciona el siguiente diagn&amp;oacute;stico:</target>
        </trans-unit>
        <trans-unit id="5adef5db9dcd73f5eebe767f23b82b503f930844" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S1LogDir&lt;/code&gt; and &lt;code&gt;S2LogDir&lt;/code&gt; are the directories named &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; for each test respectively.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;S1LogDir&lt;/code&gt; y &lt;code&gt;S2LogDir&lt;/code&gt; son los directorios denominados &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; para cada prueba respectivamente.</target>
        </trans-unit>
        <trans-unit id="eb55d7bcff03863047df1e0e245a8ad25b9600d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;conn_types&lt;/code&gt; specifies SSH, Telnet, FTP, RPC, and/or SNMP.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;conn_types&lt;/code&gt; especifica SSH, Telnet, FTP, RPC y / o SNMP.</target>
        </trans-unit>
        <trans-unit id="4daf6d3bc463f7669637809f88efe649c2ac2625" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo()&lt;/code&gt; evaluates to &lt;code&gt;&quot;Robert&quot;&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;demo()&lt;/code&gt; eval&amp;uacute;a como &lt;code&gt;&quot;Robert&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fefc36dd07702f1db04b9023b0ea8fdf578263c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;init&lt;/code&gt; does not need any input data and ignores its argument. For &lt;code&gt;terminal_logger&lt;/code&gt;, the internal state is not used. For &lt;code&gt;file_logger&lt;/code&gt;, the internal state is used to save the open file descriptor.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;init&lt;/code&gt; no necesita ning&amp;uacute;n dato de entrada e ignora su argumento. Para &lt;code&gt;terminal_logger&lt;/code&gt; , no se usa el estado interno. Para &lt;code&gt;file_logger&lt;/code&gt; , el estado interno se usa para guardar el descriptor de archivo abierto.</target>
        </trans-unit>
        <trans-unit id="aba5e0fd19010e47f153b1c0f6d8f4209d232205" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tuplep&lt;/code&gt; points to an &lt;code&gt;ETERM&lt;/code&gt; struct representing a tuple with two elements; the function name (atom) and the argument (integer). Using the function &lt;code&gt;erl_element()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;, these elements can be extracted, but they must also be declared as pointers to an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;tuplep&lt;/code&gt; apunta a una estructura &lt;code&gt;ETERM&lt;/code&gt; que representa una tupla con dos elementos; el nombre de la funci&amp;oacute;n (&amp;aacute;tomo) y el argumento (entero). Usando la funci&amp;oacute;n &lt;code&gt;erl_element()&lt;/code&gt; de &lt;code&gt;erl_eterm&lt;/code&gt; , estos elementos se pueden extraer, pero tambi&amp;eacute;n deben declararse como punteros a una estructura &lt;code&gt;ETERM&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3c764964387488a9567355a791b642a791153d46" translate="yes" xml:space="preserve">
          <source>Here, the communication with C is hidden in the implementation of &lt;code&gt;complex.erl&lt;/code&gt;. In the following sections, it is shown how this module can be implemented using the different interoperability mechanisms.</source>
          <target state="translated">Aqu&amp;iacute;, la comunicaci&amp;oacute;n con C est&amp;aacute; oculta en la implementaci&amp;oacute;n de &lt;code&gt;complex.erl&lt;/code&gt; . En los siguientes apartados se muestra c&amp;oacute;mo se puede implementar este m&amp;oacute;dulo utilizando los diferentes mecanismos de interoperabilidad.</target>
        </trans-unit>
        <trans-unit id="a9363a371565a254c5f940c661f77bc4aea0306a" translate="yes" xml:space="preserve">
          <source>Here, the data type &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; is represented as the following Erlang record:</source>
          <target state="translated">Aqu&amp;iacute;, el tipo de datos &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; se representa como el siguiente registro Erlang:</target>
        </trans-unit>
        <trans-unit id="27fe64fbf8e84fafc5f91f9a5e3d6acc46a097cf" translate="yes" xml:space="preserve">
          <source>Here, the directive &lt;code&gt;on_load&lt;/code&gt; is used to get function &lt;code&gt;init&lt;/code&gt; to be automatically called when the module is loaded. If &lt;code&gt;init&lt;/code&gt; returns anything other than &lt;code&gt;ok&lt;/code&gt;, such when the loading of the NIF library fails in this example, the module is unloaded and calls to functions within it, fail.</source>
          <target state="translated">Aqu&amp;iacute;, la directiva &lt;code&gt;on_load&lt;/code&gt; se usa para hacer que la funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; sea ​​llamada autom&amp;aacute;ticamente cuando se carga el m&amp;oacute;dulo. Si &lt;code&gt;init&lt;/code&gt; devuelve algo diferente a &lt;code&gt;ok&lt;/code&gt; , como cuando la carga de la biblioteca NIF falla en este ejemplo, el m&amp;oacute;dulo se descarga y las llamadas a funciones dentro de &amp;eacute;l fallan.</target>
        </trans-unit>
        <trans-unit id="6256ecd948c793aa1993c3c12236863caa0abcfe" translate="yes" xml:space="preserve">
          <source>Here, the handler also provides for dynamically reloading of configuration variables. If &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; is called from the test case function, all variables loaded with &lt;code&gt;config_driver:read_config/1&lt;/code&gt; are updated with their latest values, and the new value for variable &lt;code&gt;localtime&lt;/code&gt; is returned.</source>
          <target state="translated">Aqu&amp;iacute;, el controlador tambi&amp;eacute;n proporciona la recarga din&amp;aacute;mica de variables de configuraci&amp;oacute;n. Si se llama a &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; desde la funci&amp;oacute;n de caso de prueba, todas las variables cargadas con &lt;code&gt;config_driver:read_config/1&lt;/code&gt; se actualizan con sus &amp;uacute;ltimos valores y se devuelve el nuevo valor de la variable &lt;code&gt;localtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9736652812b2b809017435f7a09559dc888bc0b" translate="yes" xml:space="preserve">
          <source>Here, the same test run as in the previous examples are executed (and possibly repeated). However, when the time-out occurs, after 1 hour, &lt;code&gt;Common Test&lt;/code&gt; finishes the entire test run before stopping (that is, both &lt;code&gt;to1&lt;/code&gt; and &lt;code&gt;to2&lt;/code&gt; are always executed in the same test run).</source>
          <target state="translated">Aqu&amp;iacute;, se ejecuta la misma ejecuci&amp;oacute;n de prueba que en los ejemplos anteriores (y posiblemente se repite). Sin embargo, cuando se agota el tiempo de espera, despu&amp;eacute;s de 1 hora, &lt;code&gt;Common Test&lt;/code&gt; finaliza toda la ejecuci&amp;oacute;n de la prueba antes de detenerse (es decir, tanto &lt;code&gt;to1&lt;/code&gt; como &lt;code&gt;to2&lt;/code&gt; se ejecutan siempre en la misma ejecuci&amp;oacute;n de prueba).</target>
        </trans-unit>
        <trans-unit id="3cf47ffc88aa174995add08f4cbe16924d5664a9" translate="yes" xml:space="preserve">
          <source>Here, the same tests as in Example 1 are run, but with flag &lt;code&gt;force_stop&lt;/code&gt; set to &lt;code&gt;skip_rest&lt;/code&gt;. If time-out occurs while executing tests in directory &lt;code&gt;to1&lt;/code&gt;, the remaining test cases in &lt;code&gt;to1&lt;/code&gt; are skipped and the test is aborted without running the tests in &lt;code&gt;to2&lt;/code&gt; another time. If time-out occurs while executing tests in directory &lt;code&gt;to2&lt;/code&gt;, the remaining test cases in &lt;code&gt;to2&lt;/code&gt; are skipped and the test is aborted.</source>
          <target state="translated">Aqu&amp;iacute;, se ejecutan las mismas pruebas que en el Ejemplo 1, pero con el indicador &lt;code&gt;force_stop&lt;/code&gt; establecido en &lt;code&gt;skip_rest&lt;/code&gt; . Si se agota el tiempo de espera mientras se ejecutan las pruebas en el directorio &lt;code&gt;to1&lt;/code&gt; , los casos de prueba restantes en &lt;code&gt;to1&lt;/code&gt; se omiten y la prueba se aborta sin ejecutar las pruebas en &lt;code&gt;to2&lt;/code&gt; en otro momento. Si se agota el tiempo de espera mientras se ejecutan las pruebas en el directorio &lt;code&gt;to2&lt;/code&gt; , se omiten los casos de prueba restantes en &lt;code&gt;to2&lt;/code&gt; y se cancela la prueba.</target>
        </trans-unit>
        <trans-unit id="8725eccd38a40d0e24f360a6bca5f39b565b9081" translate="yes" xml:space="preserve">
          <source>Here, the segment corresponding to the &lt;code&gt;Opts&lt;/code&gt; variable has a &lt;strong&gt;type modifier&lt;/strong&gt;, specifying that &lt;code&gt;Opts&lt;/code&gt; is to bind to a binary. All other variables have the default type equal to unsigned integer.</source>
          <target state="translated">Aqu&amp;iacute;, el segmento correspondiente a la variable &lt;code&gt;Opts&lt;/code&gt; tiene un &lt;strong&gt;modificador de tipo&lt;/strong&gt; , que especifica que &lt;code&gt;Opts&lt;/code&gt; se enlaza a un binario. Todas las dem&amp;aacute;s variables tienen el tipo predeterminado igual a entero sin signo.</target>
        </trans-unit>
        <trans-unit id="38c740b102d15d34f934831a4b2e6f07729ae300" translate="yes" xml:space="preserve">
          <source>Here, the suites in test directory &lt;code&gt;to1&lt;/code&gt;, followed by the suites in &lt;code&gt;to2&lt;/code&gt;, are executed in one test run. A time-out event occurs after 10 minutes. As long as there is time left, &lt;code&gt;Common Test&lt;/code&gt; repeats the test run (that is, starting over with test &lt;code&gt;to1&lt;/code&gt;). After time-out, &lt;code&gt;Common Test&lt;/code&gt; stops when the current job is finished (because of flag &lt;code&gt;force_stop&lt;/code&gt;). As a result, the specified test run can be aborted after test &lt;code&gt;to1&lt;/code&gt; and before test &lt;code&gt;to2&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, los conjuntos en el directorio de prueba &lt;code&gt;to1&lt;/code&gt; , seguidos por los conjuntos en &lt;code&gt;to2&lt;/code&gt; , se ejecutan en una ejecuci&amp;oacute;n de prueba. Un evento de tiempo muerto ocurre despu&amp;eacute;s de 10 minutos. Siempre que quede tiempo, &lt;code&gt;Common Test&lt;/code&gt; repite la ejecuci&amp;oacute;n de la prueba (es decir, comienza de nuevo con la prueba &lt;code&gt;to1&lt;/code&gt; ). Despu&amp;eacute;s del tiempo de espera, &lt;code&gt;Common Test&lt;/code&gt; detiene cuando finaliza el trabajo actual (debido al indicador &lt;code&gt;force_stop&lt;/code&gt; ). Como resultado, la ejecuci&amp;oacute;n de prueba especificada se puede cancelar despu&amp;eacute;s de la prueba &lt;code&gt;to1&lt;/code&gt; y antes de la prueba &lt;code&gt;to2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1fe1239da690637d154f58466f31d750de5a7b" translate="yes" xml:space="preserve">
          <source>Here, the test run, including both the &lt;code&gt;to1&lt;/code&gt; and the &lt;code&gt;to2&lt;/code&gt; test, is repeated five times.</source>
          <target state="translated">Aqu&amp;iacute;, la ejecuci&amp;oacute;n de la prueba, incluidas las pruebas &lt;code&gt;to1&lt;/code&gt; y &lt;code&gt;to2&lt;/code&gt; , se repite cinco veces.</target>
        </trans-unit>
        <trans-unit id="52a7e5fe849b80f2c39e4eb11c178f9187a0c7ff" translate="yes" xml:space="preserve">
          <source>Here, the tests specified by &quot;ts1&quot; run first, then the tests specified by &quot;ts2&quot;, and finally the tests specified by both &quot;ts3&quot; and &quot;ts4&quot;.</source>
          <target state="translated">Aquí se ejecutan primero las pruebas especificadas por &quot;ts1&quot;,luego las pruebas especificadas por &quot;ts2&quot;,y finalmente las pruebas especificadas tanto por &quot;ts3&quot; como por &quot;ts4&quot;.</target>
        </trans-unit>
        <trans-unit id="872d6af667b9983eb38e96eba5f3443d21c88017" translate="yes" xml:space="preserve">
          <source>Here, the variable &lt;code&gt;X&lt;/code&gt;, defined in the head of the fun, is a new variable. The variable &lt;code&gt;Stream&lt;/code&gt;, which is used within the fun, gets its value from the &lt;code&gt;file:open&lt;/code&gt; line.</source>
          <target state="translated">Aqu&amp;iacute;, la variable &lt;code&gt;X&lt;/code&gt; , definida en el encabezado de la diversi&amp;oacute;n, es una nueva variable. La variable &lt;code&gt;Stream&lt;/code&gt; , que se utiliza dentro de la diversi&amp;oacute;n, obtiene su valor del &lt;code&gt;file:open&lt;/code&gt; l&amp;iacute;nea abierta .</target>
        </trans-unit>
        <trans-unit id="7e0c04fa994ff203608b787f3eac3297ddf1fb91" translate="yes" xml:space="preserve">
          <source>Here, white text is used instead of the default black for &lt;code&gt;div.error&lt;/code&gt; printouts (and no other attribute settings for &lt;code&gt;pre&lt;/code&gt; are affected).</source>
          <target state="translated">Aqu&amp;iacute;, se usa texto blanco en lugar del negro predeterminado para &lt;code&gt;div.error&lt;/code&gt; impresiones de error div (y no se ven afectadas otras configuraciones de atributos para &lt;code&gt;pre&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="714626a23a6977a3ba1a4332c0cb63aa0f04303b" translate="yes" xml:space="preserve">
          <source>Here,&lt;code&gt;ERL_NIF_INIT&lt;/code&gt; has the following arguments:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; tiene los siguientes argumentos:</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="9e6e39c49e52c38684133449dae27a843c8c9f66" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits</source>
          <target state="translated">Hexadecimal digits</target>
        </trans-unit>
        <trans-unit id="01a101ab62a2560ab10ccb525aa4aba316d01a17" translate="yes" xml:space="preserve">
          <source>HiPE is automatically enabled on the following systems:</source>
          <target state="translated">El HiPE se activa automáticamente en los siguientes sistemas:</target>
        </trans-unit>
        <trans-unit id="49e76954bbaf300a103840561af720f16c024018" translate="yes" xml:space="preserve">
          <source>HiPE supports the following system configurations:</source>
          <target state="translated">El HiPE soporta las siguientes configuraciones del sistema:</target>
        </trans-unit>
        <trans-unit id="c5263066d763fc26b746c69fd8481a0f61325e1a" translate="yes" xml:space="preserve">
          <source>Hide menu:</source>
          <target state="translated">Ocultar el menú:</target>
        </trans-unit>
        <trans-unit id="a02b1f8d870b852383550616297df9f10e5bc8ba" translate="yes" xml:space="preserve">
          <source>High fault tolerance</source>
          <target state="translated">Alta tolerancia a las fallas</target>
        </trans-unit>
        <trans-unit id="fb49d95db3dc9749450850f23cb259dfa334590a" translate="yes" xml:space="preserve">
          <source>High-Level Instructions</source>
          <target state="translated">Instrucciones de alto nivel</target>
        </trans-unit>
        <trans-unit id="322a5670551101a31a0c53538057253089ee212f" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; m&amp;aacute;s alta posible de la fuente de tiempo mon&amp;oacute;tona del sistema operativo actual como partes por segundo. Si no se puede recuperar informaci&amp;oacute;n de resoluci&amp;oacute;n del sistema operativo, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; se establece en la resoluci&amp;oacute;n de la unidad de tiempo del valor de retorno de la &lt;code&gt;Function&lt;/code&gt; . Es decir, la resoluci&amp;oacute;n real puede ser menor que &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; . Tenga en cuenta que la resoluci&amp;oacute;n no dice nada sobre la &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; o si la &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; alinea con la resoluci&amp;oacute;n. Sin embargo, sabe que la precisi&amp;oacute;n no es mejor que &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fab9cfbcb573ef66eead85a0dd57991922c30f3e" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; m&amp;aacute;s alta posible de la fuente de tiempo del sistema operativo actual en partes por segundo. Si no se puede recuperar informaci&amp;oacute;n de resoluci&amp;oacute;n del sistema operativo, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; se establece en la resoluci&amp;oacute;n de la unidad de tiempo del valor de retorno de la &lt;code&gt;Function&lt;/code&gt; . Es decir, la resoluci&amp;oacute;n real puede ser menor que &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; . Tenga en cuenta que la resoluci&amp;oacute;n no dice nada sobre la &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; o si la &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; alinea con la resoluci&amp;oacute;n. Sin embargo, sabe que la precisi&amp;oacute;n no es mejor que &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="b5e5ac0463ba83ccbf0cfb19cb8721b646cc77b2" translate="yes" xml:space="preserve">
          <source>Hmac functions - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Funciones de Hmac: codificaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="e62704259a03fb1bde2c8d41669196ad51d0310c" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; can be used to change the &lt;code&gt;cth_conn_log&lt;/code&gt; behavior. The default value of this option is &lt;code&gt;raw&lt;/code&gt;, which results in the behavior described above. If the value is set to &lt;code&gt;html&lt;/code&gt;, all Telnet communication is printed to the test case HTML log instead.</source>
          <target state="translated">La opci&amp;oacute;n de gancho &lt;code&gt;log_type&lt;/code&gt; se puede utilizar para cambiar el comportamiento de &lt;code&gt;cth_conn_log&lt;/code&gt; . El valor predeterminado de esta opci&amp;oacute;n es sin &lt;code&gt;raw&lt;/code&gt; , lo que da como resultado el comportamiento descrito anteriormente. Si el valor se establece en &lt;code&gt;html&lt;/code&gt; , toda la comunicaci&amp;oacute;n Telnet se imprime en el registro HTML del caso de prueba.</target>
        </trans-unit>
        <trans-unit id="e16590a1a84c1baec0f43c0dcc1d470ab6fb6020" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; specifies the type of logging:</source>
          <target state="translated">La opci&amp;oacute;n de gancho &lt;code&gt;log_type&lt;/code&gt; especifica el tipo de registro:</target>
        </trans-unit>
        <trans-unit id="2b7ba976df46f73b2bc0332579201ada04d174eb" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite any hard-coded hook options in the test suite.</source>
          <target state="translated">Las opciones de gancho especificadas en un archivo de configuración sobrescriben cualquier opción de gancho codificada en el paquete de pruebas.</target>
        </trans-unit>
        <trans-unit id="e5130a72c3ee4bac41361eafe24a09e720b6ee4d" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite the hard-coded hook options in the test suite.</source>
          <target state="translated">Las opciones de gancho especificadas en un archivo de configuración sobrescriben las opciones de gancho codificadas en el paquete de pruebas.</target>
        </trans-unit>
        <trans-unit id="5699a47d64ec5afff9a00f44aa11f36f6b5577a8" translate="yes" xml:space="preserve">
          <source>Hop-by-Hop and End-to-End Identifiers are set by diameter when sending outgoing requests.</source>
          <target state="translated">Los identificadores &quot;Hop-by-Hop&quot; y &quot;End-to-End&quot; se fijan por el diámetro al enviar las solicitudes salientes.</target>
        </trans-unit>
        <trans-unit id="b856160c3f11849f763958bfca750f4da4f8b030" translate="yes" xml:space="preserve">
          <source>Horizontal tab (HT)</source>
          <target state="translated">Pestaña horizontal (HT)</target>
        </trans-unit>
        <trans-unit id="288369442ce4af9ee861578e5997944104806d11" translate="yes" xml:space="preserve">
          <source>Host = &lt;code&gt;string() | ip_address()&lt;/code&gt;</source>
          <target state="translated">Anfitri&amp;oacute;n = &lt;code&gt;string() | ip_address()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0506d8d8a9c994a9c2061822e71fa219eaa60fb" translate="yes" xml:space="preserve">
          <source>Host is not found, FTP server is not found, or connection is rejected by FTP server.</source>
          <target state="translated">No se encuentra el host,no se encuentra el servidor FTP o la conexión es rechazada por el servidor FTP.</target>
        </trans-unit>
        <trans-unit id="19cf18d3bb45fb6c52bc7c972db763badac874f9" translate="yes" xml:space="preserve">
          <source>Host key algorithm.</source>
          <target state="translated">Algoritmo de la clave del anfitrión.</target>
        </trans-unit>
        <trans-unit id="072282c1e2f294945717832e050c84248cb48a99" translate="yes" xml:space="preserve">
          <source>Host key(s)</source>
          <target state="translated">Clave(s)de anfitrión</target>
        </trans-unit>
        <trans-unit id="addc5b9c7be01cab649badaad9fe245dd85b99a6" translate="yes" xml:space="preserve">
          <source>Host public key(s)</source>
          <target state="translated">Clave(s)pública(s)del anfitrión</target>
        </trans-unit>
        <trans-unit id="22d5d7183ae1bff52681fe92c469a1efdf2db570" translate="yes" xml:space="preserve">
          <source>Host-IP-Address AVP</source>
          <target state="translated">Dirección IP del anfitrión AVP</target>
        </trans-unit>
        <trans-unit id="1db3d3092adcf5851af85b54fd2dcaa3d13b20b7" translate="yes" xml:space="preserve">
          <source>Hostname extraction</source>
          <target state="translated">Extracción del nombre del anfitrión</target>
        </trans-unit>
        <trans-unit id="cc902a2f4f94e0590cff3fb32bacd18c59026842" translate="yes" xml:space="preserve">
          <source>Hostname is the result of calling net_adm:localhost() in the Erlang node where this funcion is called.</source>
          <target state="translated">El nombre del host es el resultado de llamar a net_adm:localhost()en el nodo Erlang donde se llama esta función.</target>
        </trans-unit>
        <trans-unit id="e41e038a1831d791d3fb46209bc95e438998e2ba" translate="yes" xml:space="preserve">
          <source>Hostname of the node, &lt;code&gt;host&lt;/code&gt;</source>
          <target state="translated">Nombre de host del nodo, &lt;code&gt;host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abd2f083d046f4cdd3824b5ac6815216f33f9d44" translate="yes" xml:space="preserve">
          <source>Hostnames and host addresses</source>
          <target state="translated">Nombres y direcciones de hospedaje</target>
        </trans-unit>
        <trans-unit id="acf387fac0d70500029ecc75aef45e78a2439ddf" translate="yes" xml:space="preserve">
          <source>How categories can be mapped to CSS tags is documented in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">La forma en que las categor&amp;iacute;as se pueden asignar a las etiquetas CSS se documenta en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; en la secci&amp;oacute;n Ejecuci&amp;oacute;n de pruebas y an&amp;aacute;lisis de resultados.</target>
        </trans-unit>
        <trans-unit id="4591aaae8b0152f47a2818f3eda6105fd1deb44b" translate="yes" xml:space="preserve">
          <source>How code is compiled and loaded is not a language issue, but is system-dependent. This section describes compilation and code loading in Erlang/OTP with references to relevant parts of the documentation.</source>
          <target state="translated">La forma en que se compila y se carga el código no es una cuestión de lenguaje,sino que depende del sistema.Esta sección describe la compilación y la carga del código en Erlang/OTP con referencias a las partes relevantes de la documentación.</target>
        </trans-unit>
        <trans-unit id="15c87cc7450111c7682bfcb2fe07b8147a9660ab" translate="yes" xml:space="preserve">
          <source>How long Erlang needs to be inactive before output is preceded with a time stamp. Defaults to &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt;, minimum is 1.</source>
          <target state="translated">Cu&amp;aacute;nto tiempo Erlang debe estar inactivo antes de que la salida est&amp;eacute; precedida por una marca de tiempo. El valor predeterminado es &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt; , el m&amp;iacute;nimo es 1.</target>
        </trans-unit>
        <trans-unit id="f7148ef82d3951a0ef8aeff5732b56bd65e5d5a7" translate="yes" xml:space="preserve">
          <source>How long to wait for output (in minutes) before writing an &quot;ALIVE&quot; message to the log. Defaults to 15, minimum is 1.</source>
          <target state="translated">Cuánto tiempo hay que esperar a la salida (en minutos)antes de escribir un mensaje &quot;VIVO&quot; en el registro.Por defecto es 15,el mínimo es 1.</target>
        </trans-unit>
        <trans-unit id="1a8eccc781fb3d6e08ed9cc46cafd132607b31bb" translate="yes" xml:space="preserve">
          <source>How many bytes that are read (received) from the socket, used in similar ways as &lt;code&gt;sent&lt;/code&gt;.</source>
          <target state="translated">Cu&amp;aacute;ntos bytes que se leen (reciben) desde el socket, usados ​​de manera similar a como se &lt;code&gt;sent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f341bd6607eedd11420fecb92a331dcfda1889" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="translated">Cu&amp;aacute;ntos bytes se han enviado a trav&amp;eacute;s del socket. Esto se puede ajustar, pero eso no es un problema para la distribuci&amp;oacute;n, ya que a la distribuci&amp;oacute;n de Erlang solo le interesa si este valor ha cambiado. (El &lt;code&gt;ticker&lt;/code&gt; de Erlang &lt;code&gt;net_kernel&lt;/code&gt; usa este valor llamando al controlador para buscarlo, lo cual se hace a trav&amp;eacute;s de la &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f7085d139029fad5626d71df4a69c37165c0004" translate="yes" xml:space="preserve">
          <source>How schedulers are bound matters. For example, in situations when there are fewer running processes than schedulers online, the runtime system tries to migrate processes to schedulers with low scheduler identifiers. The more the schedulers are spread over the hardware, the more resources are available to the runtime system in such situations.</source>
          <target state="translated">La forma en que los planificadores están vinculados es importante.Por ejemplo,en situaciones en las que hay menos procesos en ejecución que programadores en línea,el sistema en tiempo de ejecución intenta migrar los procesos a los programadores con bajos identificadores de programador.Cuanto más se distribuyan los programadores por el hardware,más recursos estarán disponibles para el sistema en tiempo de ejecución en tales situaciones.</target>
        </trans-unit>
        <trans-unit id="20136af8c4b0c2e0978139eaccb368f03d6d08f3" translate="yes" xml:space="preserve">
          <source>How to Build a Debug Enabled Erlang RunTime System</source>
          <target state="translated">Cómo construir un sistema de tiempo de ejecución Erlang habilitado para depuración</target>
        </trans-unit>
        <trans-unit id="a4c1dadaae2a29663af54cb6cd0c08758049e535" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt;Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="translated">C&amp;oacute;mo comunicarse con el mundo exterior y software escrito en otros idiomas (puertos); esto se describe en el &lt;code&gt;Interoperability Tutorial&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c10a361408710884679a3441fc66b438898423" translate="yes" xml:space="preserve">
          <source>How to deal with errors in the Message Length field of the Diameter Header in an incoming message. An error in this context is that the length is not at least 20 bytes (the length of a Header), is not a multiple of 4 (a valid length) or is not the length of the message in question, as received over the transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C&amp;oacute;mo tratar los errores en el campo Longitud del mensaje del Encabezado de di&amp;aacute;metro en un mensaje entrante. Un error en este contexto es que la longitud no es de al menos 20 bytes (la longitud de un encabezado), no es un m&amp;uacute;ltiplo de 4 (una longitud v&amp;aacute;lida) o no es la longitud del mensaje en cuesti&amp;oacute;n, tal como se recibe a trav&amp;eacute;s del transporte. interfaz documentada en &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccbdf00e07b9b9e2844d8c343abd36e9a64cbb60" translate="yes" xml:space="preserve">
          <source>How to install a release in a target environment is described in the section about target systems in Section 2 System Principles.</source>
          <target state="translated">La forma de instalar una liberación en un entorno de destino se describe en la sección sobre sistemas de destino de la Sección 2 Principios del sistema.</target>
        </trans-unit>
        <trans-unit id="a8aa9d6c524adcbf7e604a1f12ced88b214a5951" translate="yes" xml:space="preserve">
          <source>How to program applications is described in &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La forma de programar aplicaciones se describe en &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276dc4ca7f730347d6af07741689ad055269eecd" translate="yes" xml:space="preserve">
          <source>How to program releases is described in &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La forma de programar lanzamientos se describe en &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b4b3d991be0d0efdd7895d65ece3d2af255f1d4" translate="yes" xml:space="preserve">
          <source>How to send a trap by sending the &lt;code&gt;fTrap&lt;/code&gt; from the master agent is shown in this section. The master agent has the MIB &lt;code&gt;EX1-MIB&lt;/code&gt; loaded, where the trap is defined. This trap specifies that two variables should be sent along with the trap, &lt;code&gt;myName&lt;/code&gt; and &lt;code&gt;fIndex&lt;/code&gt;. &lt;code&gt;fIndex&lt;/code&gt; is a table column, so we must provide its value and the index for the row in the call to &lt;code&gt;snmpa:send_trap/4&lt;/code&gt;. In the example below, we assume that the row in question is indexed by 2 (the row with &lt;code&gt;fIndex&lt;/code&gt; 2).</source>
          <target state="translated">En esta secci&amp;oacute;n se muestra c&amp;oacute;mo enviar una trampa enviando el &lt;code&gt;fTrap&lt;/code&gt; desde el agente maestro. El agente maestro tiene el MIB &lt;code&gt;EX1-MIB&lt;/code&gt; cargado, donde se define la trampa. Esta trampa especifica que se deben enviar dos variables junto con la trampa, &lt;code&gt;myName&lt;/code&gt; y &lt;code&gt;fIndex&lt;/code&gt; . &lt;code&gt;fIndex&lt;/code&gt; es una columna de tabla, por lo que debemos proporcionar su valor y el &amp;iacute;ndice de la fila en la llamada a &lt;code&gt;snmpa:send_trap/4&lt;/code&gt; . En el siguiente ejemplo, asumimos que la fila en cuesti&amp;oacute;n est&amp;aacute; indexada por 2 (la fila con &lt;code&gt;fIndex&lt;/code&gt; 2).</target>
        </trans-unit>
        <trans-unit id="cd51a27fca892f8fff8444cd28b8146e7bbe5364" translate="yes" xml:space="preserve">
          <source>How to start and stop the code for the application, that is, the supervision tree, is described by two callback functions:</source>
          <target state="translated">La forma de iniciar y detener el código de la aplicación,es decir,el árbol de supervisión,se describe mediante dos funciones de devolución de llamada:</target>
        </trans-unit>
        <trans-unit id="41bdc386e84c42a60e9c78fd7063eb79494fd670" translate="yes" xml:space="preserve">
          <source>How to write &lt;code&gt;d&lt;/code&gt; programs or &lt;code&gt;systemtap&lt;/code&gt; scripts can be learned from books and from a lot of pages on the Internet. This manual page does not include any documentation about using the dynamic trace tools of respective platform. The &lt;code&gt;examples&lt;/code&gt; directory of the &lt;code&gt;runtime_tools&lt;/code&gt; application however contains comprehensive examples of both &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;systemtap&lt;/code&gt; programs that will help you get started. Another source of information is the &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; chapters in the Runtime Tools Users' Guide.</source>
          <target state="translated">Se puede aprender a escribir programas &lt;code&gt;d&lt;/code&gt; o scripts &lt;code&gt;systemtap&lt;/code&gt; en libros y en muchas p&amp;aacute;ginas de Internet. Esta p&amp;aacute;gina de manual no incluye ninguna documentaci&amp;oacute;n sobre el uso de las herramientas de seguimiento din&amp;aacute;mico de la plataforma respectiva. La &lt;code&gt;examples&lt;/code&gt; directorio del &lt;code&gt;runtime_tools&lt;/code&gt; aplicaci&amp;oacute;n embargo contiene ejemplos completos de ambos &lt;code&gt;d&lt;/code&gt; e &lt;code&gt;systemtap&lt;/code&gt; programas que le ayudar&amp;aacute;n a empezar. Otra fuente de informaci&amp;oacute;n son los cap&amp;iacute;tulos &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; en la Gu&amp;iacute;a del usuario de Runtime Tools.</target>
        </trans-unit>
        <trans-unit id="0838c6817793504aa13c17409bac1788b9b01886" translate="yes" xml:space="preserve">
          <source>However, NTP is not fail-safe. The NTP server can be unavailable, &lt;code&gt;ntp.conf&lt;/code&gt; can be wrongly configured, or your computer can sometimes be disconnected from Internet. Furthermore, you can have a user (or even system administrator) who thinks the correct way to handle Daylight Saving Time is to adjust the clock one hour two times a year (which is the incorrect way to do it). To complicate things further, this user fetched your software from Internet and has not considered what the correct time is as perceived by a computer. The user does not care about keeping the wall clock in sync with the correct time. The user expects your program to have unlimited knowledge about the time.</source>
          <target state="translated">Sin embargo, NTP no es seguro. El servidor NTP puede no estar disponible, &lt;code&gt;ntp.conf&lt;/code&gt; puede estar configurado incorrectamente o su computadora a veces puede desconectarse de Internet. Adem&amp;aacute;s, puede tener un usuario (o incluso un administrador del sistema) que piense que la forma correcta de manejar el horario de verano es ajustar el reloj una hora dos veces al a&amp;ntilde;o (que es la forma incorrecta de hacerlo). Para complicar a&amp;uacute;n m&amp;aacute;s las cosas, este usuario obtuvo su software de Internet y no ha considerado cu&amp;aacute;l es la hora correcta seg&amp;uacute;n la percibe una computadora. Al usuario no le importa mantener el reloj de pared sincronizado con la hora correcta. El usuario espera que su programa tenga un conocimiento ilimitado sobre la hora.</target>
        </trans-unit>
        <trans-unit id="1d1ccf19c7bc531f33d5809c585dc1826e4637e4" translate="yes" xml:space="preserve">
          <source>However, a node started in this way refuses to talk to other nodes, as no TLS parameters are supplied (see the next section).</source>
          <target state="translated">Sin embargo,un nodo iniciado de esta manera se niega a hablar con otros nodos,ya que no se suministran parámetros TLS (véase la siguiente sección).</target>
        </trans-unit>
        <trans-unit id="b227076a401b39e896ee55916a33ca73c07f48da" translate="yes" xml:space="preserve">
          <source>However, bit strings that are not whole bytes are not allowed, so a UTF character must be split along 8-bit boundaries to ever be decoded.</source>
          <target state="translated">Sin embargo,las cadenas de bits que no son bytes enteros no están permitidas,por lo que un carácter UTF debe ser dividido a lo largo de los límites de 8 bits para poder ser decodificado.</target>
        </trans-unit>
        <trans-unit id="8ea8d93f3410c8633f2cc78f1bbe03d8844b4ed7" translate="yes" xml:space="preserve">
          <source>However, certificates can also be decoded using &lt;code&gt;pkix_decode_cert/2&lt;/code&gt;, which can customize and recursively decode standard parts of a certificate:</source>
          <target state="translated">Sin embargo, los certificados tambi&amp;eacute;n se pueden decodificar usando &lt;code&gt;pkix_decode_cert/2&lt;/code&gt; , que puede personalizar y decodificar de forma recursiva partes est&amp;aacute;ndar de un certificado:</target>
        </trans-unit>
        <trans-unit id="0c4ccce2e74bd8ac8ec245b1dfb747183f0ffc13" translate="yes" xml:space="preserve">
          <source>However, escaping other non-alphanumeric characters does no harm.</source>
          <target state="translated">Sin embargo,escapar de otros personajes no alfanuméricos no hace daño.</target>
        </trans-unit>
        <trans-unit id="46e5131246ec14a5499a18be55e9b7179d7c9b66" translate="yes" xml:space="preserve">
          <source>However, for a value of type &lt;code&gt;SET OF&lt;/code&gt;, the DER encoding format requires the elements to be sent in ascending order of their encoding, which implies an expensive sorting procedure in runtime. Therefore it is recommended to use &lt;code&gt;SEQUENCE OF&lt;/code&gt; instead of &lt;code&gt;SET OF&lt;/code&gt; if possible.</source>
          <target state="translated">Sin embargo, para un valor de tipo &lt;code&gt;SET OF&lt;/code&gt; , el formato de codificaci&amp;oacute;n DER requiere que los elementos se env&amp;iacute;en en orden ascendente de su codificaci&amp;oacute;n, lo que implica un costoso procedimiento de clasificaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n. Por lo tanto, se recomienda utilizar &lt;code&gt;SEQUENCE OF&lt;/code&gt; en lugar de &lt;code&gt;SET OF&lt;/code&gt; si es posible.</target>
        </trans-unit>
        <trans-unit id="bc244468b711f7696ac604f858e8d4fc9b46e19b" translate="yes" xml:space="preserve">
          <source>However, here you will find some examples of how to use and to what you can use xmerl. A detailed description of the user interface can be found in the reference manual.</source>
          <target state="translated">Sin embargo,aquí encontrará algunos ejemplos de cómo y a qué puede recurrir xmerl.Una descripción detallada de la interfaz de usuario se puede encontrar en el manual de referencia.</target>
        </trans-unit>
        <trans-unit id="0b9d56ea76c3544f39f6889a33eb80d1c637ad55" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;cp1&lt;/code&gt; also restarts, the function &lt;code&gt;application:takeover/2&lt;/code&gt; moves &lt;code&gt;myapp&lt;/code&gt; to &lt;code&gt;cp1&lt;/code&gt;, as &lt;code&gt;cp1&lt;/code&gt; has a higher priority than &lt;code&gt;cp3&lt;/code&gt; for this application. In this case, &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; is executed at &lt;code&gt;cp1&lt;/code&gt; to start the application.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;cp1&lt;/code&gt; tambi&amp;eacute;n se reinicia, la &lt;code&gt;application:takeover/2&lt;/code&gt; funci&amp;oacute;n : takeover / 2 mueve &lt;code&gt;myapp&lt;/code&gt; a &lt;code&gt;cp1&lt;/code&gt; , ya que &lt;code&gt;cp1&lt;/code&gt; tiene una prioridad m&amp;aacute;s alta que &lt;code&gt;cp3&lt;/code&gt; para esta aplicaci&amp;oacute;n. En este caso, &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; se ejecuta en &lt;code&gt;cp1&lt;/code&gt; para iniciar la aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d56d68a6f8912b74bb9d4335dc57800fe8ebb077" translate="yes" xml:space="preserve">
          <source>However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the following pattern does the right thing with the C comments:</source>
          <target state="translated">Sin embargo,si un cuantificador va seguido de un signo de interrogación,deja de ser codicioso y,en cambio,coincide con el mínimo número de veces posible,por lo que el siguiente patrón hace lo correcto con los comentarios de la C:</target>
        </trans-unit>
        <trans-unit id="263a65ad8dda64685d084610e95a9d4761d42dff" translate="yes" xml:space="preserve">
          <source>However, if another process has the driver loaded, calling &lt;code&gt;reload_driver&lt;/code&gt; returns error code &lt;code&gt;pending_process&lt;/code&gt;. As stated earlier, the recommended design is to not allow other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; than the &quot;driver reloader&quot; to demand loading of the driver in question.</source>
          <target state="translated">Sin embargo, si otro proceso tiene el controlador cargado, llamar a &lt;code&gt;reload_driver&lt;/code&gt; devuelve un c&amp;oacute;digo de error &lt;code&gt;pending_process&lt;/code&gt; . Como se indic&amp;oacute; anteriormente, el dise&amp;ntilde;o recomendado es no permitir que otros &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; que no sean el &quot;cargador de controladores&quot; exijan la carga del controlador en cuesti&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fdd9ab210aada3daba577507d301fd6bfe3e97ab" translate="yes" xml:space="preserve">
          <source>However, if the decimal number following the backslash is &amp;lt; 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. That is, the parentheses that are referenced do need not be to the left of the reference for numbers &amp;lt; 10. A &quot;forward back reference&quot; of this type can make sense when a repetition is involved and the subpattern to the right has participated in an earlier iteration.</source>
          <target state="translated">Sin embargo, si el n&amp;uacute;mero decimal que sigue a la barra invertida es &amp;lt;10, siempre se toma como una referencia inversa y provoca un error solo si no hay tantos par&amp;eacute;ntesis izquierdos de captura en todo el patr&amp;oacute;n. Es decir, los par&amp;eacute;ntesis a los que se hace referencia no necesitan estar a la izquierda de la referencia para los n&amp;uacute;meros &amp;lt;10. Una &quot;referencia hacia adelante y hacia atr&amp;aacute;s&quot; de este tipo puede tener sentido cuando se trata de una repetici&amp;oacute;n y el subpatr&amp;oacute;n de la derecha ha participado en una iteraci&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="2a812868f08ecc593ae34f24cb42a6aa95624434" translate="yes" xml:space="preserve">
          <source>However, if the first pattern does not match, the second pattern is tested. If this matches, the message is removed from the queue and the actions corresponding to the second pattern are executed. If the second pattern does not match, the third is tried and so on until there are no more patterns to test. If there are no more patterns to test, the first message is kept in the queue and the second message is tried instead. If this matches any pattern, the appropriate actions are executed and the second message is removed from the queue (keeping the first message and any other messages in the queue). If the second message does not match, the third message is tried, and so on, until the end of the queue is reached. If the end of the queue is reached, the process blocks (stops execution) and waits until a new message is received and this procedure is repeated.</source>
          <target state="translated">Sin embargo,si el primer patrón no coincide,se prueba el segundo patrón.Si coincide,se elimina el mensaje de la cola y se ejecutan las acciones correspondientes al segundo patrón.Si el segundo patrón no coincide,se prueba el tercero y así sucesivamente hasta que no haya más patrones que probar.Si no hay más patrones que probar,el primer mensaje se mantiene en la cola y en su lugar se prueba el segundo mensaje.Si esto coincide con algún patrón,se ejecutan las acciones apropiadas y se elimina el segundo mensaje de la cola (manteniendo el primer mensaje y cualquier otro mensaje en la cola).Si el segundo mensaje no coincide,se intenta con el tercer mensaje,y así sucesivamente,hasta llegar al final de la cola.Si se llega al final de la cola,el proceso se bloquea (detiene la ejecución)y espera hasta que se recibe un nuevo mensaje y se repite este procedimiento.</target>
        </trans-unit>
        <trans-unit id="24786ae2162520de2c90e9e1d62681cc611c7770" translate="yes" xml:space="preserve">
          <source>However, if the input &lt;code&gt;Data&lt;/code&gt; is a pure binary, the third part of the error tuple is guaranteed to be a binary as well.</source>
          <target state="translated">Sin embargo, si los &lt;code&gt;Data&lt;/code&gt; entrada son binarios puros, se garantiza que la tercera parte de la tupla de error tambi&amp;eacute;n ser&amp;aacute; binaria.</target>
        </trans-unit>
        <trans-unit id="16d0a6fc945512ce80fc9d4797b016ad95bcce03" translate="yes" xml:space="preserve">
          <source>However, if the table is created with an explicit record name as argument, as shown in the following example, subscriber records can be stored in both of the tables regardless of the table names:</source>
          <target state="translated">Sin embargo,si la tabla se crea con un nombre de registro explícito como argumento,como se muestra en el siguiente ejemplo,los registros de los abonados pueden almacenarse en ambas tablas independientemente de los nombres de las mismas:</target>
        </trans-unit>
        <trans-unit id="1b7421b4ed5e29d178756408b1fb811393c80202" translate="yes" xml:space="preserve">
          <source>However, if this is done and a &lt;code&gt;relup&lt;/code&gt; file is generated, not only would it contain instructions for restarting (that is, removing and adding) &lt;code&gt;prim_app&lt;/code&gt;, it would also contain instructions for starting &lt;code&gt;ch_app&lt;/code&gt; (and stopping it, in the case of downgrade). This is because &lt;code&gt;ch_app&lt;/code&gt; is included in the new &lt;code&gt;.rel&lt;/code&gt; file, but not in the old one.</source>
          <target state="translated">Sin embargo, si se hace esto y se genera un archivo de &lt;code&gt;relup&lt;/code&gt; , no solo contendr&amp;iacute;a instrucciones para reiniciar (es decir, eliminar y agregar) &lt;code&gt;prim_app&lt;/code&gt; , sino que tambi&amp;eacute;n contendr&amp;iacute;a instrucciones para iniciar &lt;code&gt;ch_app&lt;/code&gt; (y detenerlo, en el caso de degradaci&amp;oacute;n) . Esto se debe a que &lt;code&gt;ch_app&lt;/code&gt; est&amp;aacute; incluido en el nuevo archivo &lt;code&gt;.rel&lt;/code&gt; , pero no en el anterior.</target>
        </trans-unit>
        <trans-unit id="671dba1e8a971cf15a413c5af3f46c832eef8168" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line does not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="translated">Sin embargo, si invoca el &lt;code&gt;escript&lt;/code&gt; de la siguiente manera, el contenido de la primera l&amp;iacute;nea no importa, pero no puede contener c&amp;oacute;digo Erlang, ya que se ignorar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="733932a016243e1521c912130b4ad01ef9fa9412" translate="yes" xml:space="preserve">
          <source>However, it can also be convenient to replace variables in within a &lt;code&gt;sys.config&lt;/code&gt; on the target after unpacking but before running the release. If you have a &lt;code&gt;sys.config.src&lt;/code&gt; it will be included and is not required to be a valid Erlang term file like &lt;code&gt;sys.config&lt;/code&gt;. Before running the release you must have a valid &lt;code&gt;sys.config&lt;/code&gt; in the same directory, so using &lt;code&gt;sys.config.src&lt;/code&gt; requires having some tool to populate what is needed and write &lt;code&gt;sys.config&lt;/code&gt; to disk before booting the release.</source>
          <target state="translated">Sin embargo, tambi&amp;eacute;n puede ser conveniente reemplazar las variables dentro de un &lt;code&gt;sys.config&lt;/code&gt; en el destino despu&amp;eacute;s de desempaquetar pero antes de ejecutar la versi&amp;oacute;n. Si tiene un &lt;code&gt;sys.config.src&lt;/code&gt; , se incluir&amp;aacute; y no es necesario que sea un archivo de t&amp;eacute;rmino Erlang v&amp;aacute;lido como &lt;code&gt;sys.config&lt;/code&gt; . Antes de ejecutar la versi&amp;oacute;n, debe tener un &lt;code&gt;sys.config&lt;/code&gt; v&amp;aacute;lido en el mismo directorio, por lo que el uso de &lt;code&gt;sys.config.src&lt;/code&gt; requiere tener alguna herramienta para completar lo que se necesita y escribir &lt;code&gt;sys.config&lt;/code&gt; en el disco antes de iniciar la versi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e2548bff9e540af4d0fb0d83f010b390353ac3c3" translate="yes" xml:space="preserve">
          <source>However, it is acceptable to PCRE if rewritten to use two top-level branches:</source>
          <target state="translated">Sin embargo,es aceptable para el PCRE si se reescribe para usar dos ramas de alto nivel:</target>
        </trans-unit>
        <trans-unit id="fb5d7ab90418502bf4a66c357b3062b87e79e461" translate="yes" xml:space="preserve">
          <source>However, it is up to the tools that process the specifications to choose whether to take this extra information into account or not.</source>
          <target state="translated">Sin embargo,corresponde a las herramientas que procesan las especificaciones elegir si se tiene en cuenta o no esta información adicional.</target>
        </trans-unit>
        <trans-unit id="bfce5f1fc516ae2dd7d55f261e0b8f21a3259164" translate="yes" xml:space="preserve">
          <source>However, more dot-separated parts than this can exist. The dot-separated parts consist of non-negative integers. If all parts less significant than &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; equals &lt;code&gt;0&lt;/code&gt;, they are omitted. The three normal parts &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; are changed as follows:</source>
          <target state="translated">Sin embargo, pueden existir m&amp;aacute;s partes separadas por puntos. Las partes separadas por puntos consisten en n&amp;uacute;meros enteros no negativos. Si todas las partes menos significativas que &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; son iguales a &lt;code&gt;0&lt;/code&gt; , se omiten. Las tres partes normales &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; se cambian de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="7df44a8a1e1ba914a7e56b28dc0791a84d52cf6e" translate="yes" xml:space="preserve">
          <source>However, no expansion is done in the following call because &lt;code&gt;{foo, false}&lt;/code&gt; shadows &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">Sin embargo, no se realiza ninguna expansi&amp;oacute;n en la siguiente llamada porque &lt;code&gt;{foo, false}&lt;/code&gt; sombra a &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d572d552eed7e268241fcd56330d5bd074e5ab5" translate="yes" xml:space="preserve">
          <source>However, notice that there is a risk that the database can be left in an inconsistent state if dirty operations are used to update it. Dirty operations are only to be used for performance reasons when it is absolutely necessary.</source>
          <target state="translated">Sin embargo,observe que existe el riesgo de que la base de datos se deje en un estado inconsistente si se utilizan operaciones sucias para actualizarla.Las operaciones sucias sólo se utilizarán por razones de rendimiento cuando sea absolutamente necesario.</target>
        </trans-unit>
        <trans-unit id="a529ad494df4a251bbb90b6a1eb0a32b4600b075" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes or act as a proxy filter, which sends some packets to a proxy agent and some packets to the master agent.</source>
          <target state="translated">Sin embargo,ese simple comportamiento puede ser modificado de numerosas maneras.Por ejemplo,el proceso Net if puede aplicar algún tipo de esquema de cifrado/descifrado en los bytes o actuar como un filtro proxy,que envía algunos paquetes a un agente proxy y otros paquetes al agente maestro.</target>
        </trans-unit>
        <trans-unit id="d14e5363806cde8cb157cc5a01dc9d77816a23da" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes.</source>
          <target state="translated">Sin embargo,ese simple comportamiento puede ser modificado de numerosas maneras.Por ejemplo,el proceso Net if puede aplicar algún tipo de esquema de encriptación/desencriptación en los bytes.</target>
        </trans-unit>
        <trans-unit id="bb8e8fcb075fb17e39be5eb5b27fd3315e7094ac" translate="yes" xml:space="preserve">
          <source>However, there are some cases where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a back reference elsewhere in the pattern, a match at the start can fail where a later one succeeds. Consider, for example:</source>
          <target state="translated">Sin embargo,hay algunos casos en los que no se puede utilizar la optimización.Cuando .*está dentro capturando paréntesis que son objeto de una referencia trasera en otra parte del patrón,una coincidencia al principio puede fallar donde una posterior tiene éxito.Consideremos,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="eb1d42158bbcefd3e41b94056683aaeb566a73aa" translate="yes" xml:space="preserve">
          <source>However, this procedure can be time-consuming, the shortcut function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; loads all the tables from disc at a faster rate. The function forces tables to be loaded from disc regardless of the network situation.</source>
          <target state="translated">Sin embargo, este procedimiento puede llevar mucho tiempo, la funci&amp;oacute;n de acceso directo &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; carga todas las tablas del disco a un ritmo m&amp;aacute;s r&amp;aacute;pido. La funci&amp;oacute;n obliga a que las tablas se carguen desde el disco independientemente de la situaci&amp;oacute;n de la red.</target>
        </trans-unit>
        <trans-unit id="7ec657f07edbe2adca75ca4efe20bdbbe6a76973" translate="yes" xml:space="preserve">
          <source>However, to avoid that old (pre R14) code changed its behavior when compiled with OTP version R14A or later, the following restriction applies: If you override the name of a BIF that was auto-imported in OTP versions prior to R14A (ERTS version 5.8) and have an implicitly qualified call to that function in your code, you either need to explicitly remove the auto-import using a compiler directive, or replace the call with a fully qualified function call. Otherwise you get a compilation error. See the following example:</source>
          <target state="translated">Sin embargo,para evitar que ese viejo código (pre R14)cambie su comportamiento cuando se compila con la versión OTP R14A o posterior,se aplica la siguiente restricción:Si anula el nombre de un BIF que fue autoimportado en las versiones OTP anteriores a la R14A (ERTS versión 5.8)y tiene una llamada implícitamente cualificada a esa función en su código,necesita eliminar explícitamente la autoimportación usando una directiva del compilador,o reemplazar la llamada con una llamada a una función totalmente cualificada.De lo contrario,obtendrá un error de compilación.Vea el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="75b9c43d3cdd19de7c3638848d794e6192e00af7" translate="yes" xml:space="preserve">
          <source>However, when using, for example, IA5String (which closely resembles ASCII), byte 65 (in decimal notation) &lt;strong&gt;means&lt;/strong&gt; character 'A'.</source>
          <target state="translated">Sin embargo, cuando se usa, por ejemplo, IA5String (que se parece mucho a ASCII), el byte 65 (en notaci&amp;oacute;n decimal) &lt;strong&gt;significa el&lt;/strong&gt; car&amp;aacute;cter 'A'.</target>
        </trans-unit>
        <trans-unit id="8f5f28cc9ea54e0ce758adaa70edd19d2c7df7a4" translate="yes" xml:space="preserve">
          <source>Http client service start/stop</source>
          <target state="translated">Inicio y parada del servicio de atención al cliente Http</target>
        </trans-unit>
        <trans-unit id="2a4e8cc587ce6e7e113504c978e34c1e185e42f2" translate="yes" xml:space="preserve">
          <source>Http data types</source>
          <target state="translated">Tipos de datos Http</target>
        </trans-unit>
        <trans-unit id="421eac8e9d0f0d4fccaca857739a0c79fd890424" translate="yes" xml:space="preserve">
          <source>Hyphen (only where it can be interpreted as specifying a range)</source>
          <target state="translated">Guión (sólo cuando se puede interpretar que especifica un rango)</target>
        </trans-unit>
        <trans-unit id="df1da1414681b4aaf7b9dd8c935cd29628d37ea7" translate="yes" xml:space="preserve">
          <source>Hyphens are allowed in SMIv2 (a pragmatic approach). The reason for this is that according to SMIv2, hyphens are allowed for objects converted from SMIv1, but not for others. This is impossible to check for the compiler.</source>
          <target state="translated">Los guiones están permitidos en el SMIv2 (un enfoque pragmático).La razón de esto es que según el SMIv2,se permiten los guiones para los objetos convertidos a partir del SMIv1,pero no para los demás.Esto es imposible de comprobar para el compilador.</target>
        </trans-unit>
        <trans-unit id="317126fec2c76144e4651e497f8a410a786df087" translate="yes" xml:space="preserve">
          <source>I/O error.</source>
          <target state="translated">Error de E/S.</target>
        </trans-unit>
        <trans-unit id="7e0868350648287b8190bf9c980b2ea9c46ef7d5" translate="yes" xml:space="preserve">
          <source>I/O is by far the most problematic area for Unicode. A file is an entity where bytes are stored, and the lore of programming has been to treat characters and bytes as interchangeable. With Unicode characters, you must decide on an encoding when you want to store the data in a file. In Erlang, you can open a text file with an encoding option, so that you can read characters from it rather than bytes, but you can also open a file for bytewise I/O.</source>
          <target state="translated">La E/S es de lejos el área más problemática para Unicode.Un archivo es una entidad en la que se almacenan bytes,y la tradición de la programación ha sido tratar los caracteres y los bytes como intercambiables.Con los caracteres de Unicode,debes decidir sobre una codificación cuando quieres almacenar los datos en un archivo.En Erlang,se puede abrir un archivo de texto con una opción de codificación,de modo que se puedan leer los caracteres de éste en lugar de los bytes,pero también se puede abrir un archivo para E/S bytewise.</target>
        </trans-unit>
        <trans-unit id="1fb1f4a96f553bd9d56bd14c304eff4f10d68c9d" translate="yes" xml:space="preserve">
          <source>I/O library functions.</source>
          <target state="translated">Funciones de biblioteca de E/S.</target>
        </trans-unit>
        <trans-unit id="e689b6630f1d0a364819fdd2b5731bcddd521358" translate="yes" xml:space="preserve">
          <source>I/O servers behave a little differently. The I/O servers connected to terminals (or &lt;code&gt;stdout&lt;/code&gt;) can usually cope with Unicode data regardless of the encoding option. This is convenient when one expects a modern environment but do not want to crash when writing to an archaic terminal or pipe.</source>
          <target state="translated">Los servidores de E / S se comportan de forma un poco diferente. Los servidores de E / S conectados a terminales (o &lt;code&gt;stdout&lt;/code&gt; ) generalmente pueden manejar datos Unicode independientemente de la opci&amp;oacute;n de codificaci&amp;oacute;n. Esto es conveniente cuando uno espera un entorno moderno pero no quiere fallar al escribir en una terminal o tuber&amp;iacute;a arcaica.</target>
        </trans-unit>
        <trans-unit id="8fc86a2ee6eb5947817dfe748e38a27770d8f566" translate="yes" xml:space="preserve">
          <source>I/O-servers throughout the system can handle Unicode data and have options for converting data upon output or input to/from the device. As shown earlier, the &lt;code&gt;shell&lt;/code&gt; module has support for Unicode terminals and the &lt;code&gt;file&lt;/code&gt; module allows for translation to and from various Unicode formats on disk.</source>
          <target state="translated">Los servidores de E / S en todo el sistema pueden manejar datos Unicode y tienen opciones para convertir datos en la salida o entrada hacia / desde el dispositivo. Como se mostr&amp;oacute; anteriormente, el m&amp;oacute;dulo de &lt;code&gt;shell&lt;/code&gt; tiene soporte para terminales Unicode y el m&amp;oacute;dulo de &lt;code&gt;file&lt;/code&gt; permite la traducci&amp;oacute;n hacia y desde varios formatos Unicode en el disco.</target>
        </trans-unit>
        <trans-unit id="bcfd9b9aeb407171a7e2324b4088b3abd516b2fd" translate="yes" xml:space="preserve">
          <source>IANA Considerations</source>
          <target state="translated">Consideraciones de la IANA</target>
        </trans-unit>
        <trans-unit id="3e38df6d2fac16695ca12a7c20a2020653e3dafb" translate="yes" xml:space="preserve">
          <source>IC (Erlang IDL Compiler) is an interface generator that, given an IDL interface specification, automatically generates stub code in Erlang, C, or Java. See the IC User's Guide and IC Reference Manual.</source>
          <target state="translated">IC (Erlang IDL Compiler)es un generador de interfaces que,dada una especificación de interfaz IDL,genera automáticamente un código de colilla en Erlang,C o Java.Vea la Guía del usuario del IC y el Manual de referencia del IC.</target>
        </trans-unit>
        <trans-unit id="0bf03f10d1813cb5d0b794bb41322a916930011c" translate="yes" xml:space="preserve">
          <source>IC file. It runs the IDL compiler.</source>
          <target state="translated">Archivo IC.Ejecuta el compilador de IDL.</target>
        </trans-unit>
        <trans-unit id="c51d7c7db41d3c06e8b204e1bc79bfc7925a9210" translate="yes" xml:space="preserve">
          <source>IETF - which calls the protocol Megaco</source>
          <target state="translated">IETF-que llama al protocolo Megaco</target>
        </trans-unit>
        <trans-unit id="7d26936a60ddb99baf38e0efb1e3118fc3bedbec" translate="yes" xml:space="preserve">
          <source>IG (Interface Generator) automatically generated code for port or socket communication between an Erlang program and a C program, given a C header file with certain keywords.</source>
          <target state="translated">IG (Generador de Interfaz)generó automáticamente el código para la comunicación de puerto o socket entre un programa Erlang y un programa C,dado un archivo de encabezamiento C con ciertas palabras clave.</target>
        </trans-unit>
        <trans-unit id="02cd32b9b05d3968d24a31f2968a004c733872e9" translate="yes" xml:space="preserve">
          <source>IG - Removed from Erlang/OTP R6B.</source>
          <target state="translated">IG-Removido de Erlang/OTP R6B.</target>
        </trans-unit>
        <trans-unit id="67d2109a8b5d8e4bb7b9df8f8ac917b156dee2f0" translate="yes" xml:space="preserve">
          <source>IIOP (CORBA)</source>
          <target state="translated">IIOP (CORBA)</target>
        </trans-unit>
        <trans-unit id="e11de130ad140b3de05ef1e6704f79955721f5c1" translate="yes" xml:space="preserve">
          <source>INTEGER, INT, SMALLINT</source>
          <target state="translated">INTEGER,INT,SMALLINT</target>
        </trans-unit>
        <trans-unit id="46a2b346d175bbcf022a9a889eb0d86d5bfeb44a" translate="yes" xml:space="preserve">
          <source>IOString</source>
          <target state="translated">IOString</target>
        </trans-unit>
        <trans-unit id="d191822111684cb0a3235f7ff4be7401211b5c9d" translate="yes" xml:space="preserve">
          <source>IP address, &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="translated">Direcci&amp;oacute;n IP, &lt;code&gt;addr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5b376f791ddb908dfa5eec43b3c5893ba79b006b" translate="yes" xml:space="preserve">
          <source>IP version to use when the host address is specified as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Versi&amp;oacute;n de IP para usar cuando la direcci&amp;oacute;n de host se especifica como &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96a0cbf4fd8e6bbadf81a2623591ae93a5fab7c6" translate="yes" xml:space="preserve">
          <source>IPsec is transparent to diameter.</source>
          <target state="translated">El IPsec es transparente al diámetro.</target>
        </trans-unit>
        <trans-unit id="18ab43ebeda307979a5cae1e044580f0b576b6b9" translate="yes" xml:space="preserve">
          <source>ISO Latin-1 (0-255, one character per byte). Here, case parameter &lt;code&gt;InEncoding&lt;/code&gt; is to be specified as &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">ISO Latin-1 (0-255, un car&amp;aacute;cter por byte). Aqu&amp;iacute;, el par&amp;aacute;metro de caso &lt;code&gt;InEncoding&lt;/code&gt; debe especificarse como &lt;code&gt;latin1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e544629e4d17007bac72590a9cae9dd3b4b775" translate="yes" xml:space="preserve">
          <source>ITU - which calls the protocol H.248</source>
          <target state="translated">UIT-que llama al protocolo H.248</target>
        </trans-unit>
        <trans-unit id="c633b237421559cb6821152c0d77a40227baef6f" translate="yes" xml:space="preserve">
          <source>Id of the &lt;code&gt;ssh&lt;/code&gt; channel as returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Id del canal &lt;code&gt;ssh&lt;/code&gt; devuelto por &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee9bf2e79695b73d87e005e3af0acf3c8bf8e02" translate="yes" xml:space="preserve">
          <source>Ideally, your code only contains the first type of efficient code. If that turns out to be too slow, profile the application to find out where the performance bottlenecks are and optimize only the bottlenecks. Let other code stay as clean as possible.</source>
          <target state="translated">Idealmente,su código sólo contiene el primer tipo de código eficiente.Si resulta ser demasiado lento,haz un perfil de la aplicación para averiguar dónde están los cuellos de botella de rendimiento y optimiza sólo los cuellos de botella.Deja que el resto del código se mantenga lo más limpio posible.</target>
        </trans-unit>
        <trans-unit id="c30e59972c073691c1e830409d7104410fccdf7c" translate="yes" xml:space="preserve">
          <source>Identified processor states may be different on different operating systems and may change between different versions of &lt;code&gt;cpu_sup&lt;/code&gt; on the same operating system. The sum of the percentage shares of the CPU cycles spent in all busy and all non-busy processor states will always add up to 100%, though.</source>
          <target state="translated">Los estados de procesador identificados pueden ser diferentes en diferentes sistemas operativos y pueden cambiar entre diferentes versiones de &lt;code&gt;cpu_sup&lt;/code&gt; en el mismo sistema operativo. Sin embargo, la suma de los porcentajes de los ciclos de CPU gastados en todos los estados de procesador ocupado y no ocupado siempre sumar&amp;aacute; el 100%.</target>
        </trans-unit>
        <trans-unit id="b46580854e82988aa9e6377bc948b9ced562fe4b" translate="yes" xml:space="preserve">
          <source>Identifiers.</source>
          <target state="translated">Identifiers.</target>
        </trans-unit>
        <trans-unit id="cc1aea5ef7b08c4fe2e094b55f89ec9a27cc6266" translate="yes" xml:space="preserve">
          <source>Identifies and returns the type of Erlang term encoded in a buffer. It skips a trailing &lt;strong&gt;magic&lt;/strong&gt; identifier.</source>
          <target state="translated">Identifica y devuelve el tipo de t&amp;eacute;rmino Erlang codificado en un b&amp;uacute;fer. Omite un identificador &lt;strong&gt;m&amp;aacute;gico&lt;/strong&gt; final .</target>
        </trans-unit>
        <trans-unit id="d4286448984448b29096cfc37d85e421cb0b828a" translate="yes" xml:space="preserve">
          <source>Identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">Identifica el sistema de archivos donde se encuentra el archivo.En Windows,el número indica una unidad de disco de la siguiente manera:0 significa A:,1 significa B:,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="a78e241d75b4386f5966c1f03850bc25044aab1e" translate="yes" xml:space="preserve">
          <source>Identifies the key to be used. The format depends on the loaded engine. It is passed to the &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; functions in libcrypto.</source>
          <target state="translated">Identifica la clave que se utilizar&amp;aacute;. El formato depende del motor cargado. Se pasa a las &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; en libcrypto.</target>
        </trans-unit>
        <trans-unit id="5c6a3f5a562e2ce595bdeeb857c4ae74f4eb3a1c" translate="yes" xml:space="preserve">
          <source>Identifies what information to sort by.</source>
          <target state="translated">Identifica la información por la que hay que clasificar.</target>
        </trans-unit>
        <trans-unit id="4c35819884b50461c098d94e30fb5a14c994b48c" translate="yes" xml:space="preserve">
          <source>Identifying capturing parentheses by number is simple, but it can be hard to keep track of the numbers in complicated regular expressions. Also, if an expression is modified, the numbers can change. To help with this difficulty, PCRE supports the naming of subpatterns. This feature was not added to Perl until release 5.10. Python had the feature earlier, and PCRE introduced it at release 4.0, using the Python syntax. PCRE now supports both the Perl and the Python syntax. Perl allows identically numbered subpatterns to have different names, but PCRE does not.</source>
          <target state="translated">Identificar la captura de paréntesis por número es simple,pero puede ser difícil seguir el rastro de los números en complicadas expresiones regulares.Además,si se modifica una expresión,los números pueden cambiar.Para ayudar con esta dificultad,PCRE apoya la denominación de subpatrones.Esta característica no se añadió a Perl hasta la versión 5.10.Python tenía la característica antes,y PCRE la introdujo en la versión 4.0,usando la sintaxis de Python.PCRE ahora soporta tanto la sintaxis de Perl como la de Python.Perl permite que subpatrones idénticamente numerados tengan nombres diferentes,pero PCRE no.</target>
        </trans-unit>
        <trans-unit id="dee66e066bf8a35e6b819408cf3275f475346209" translate="yes" xml:space="preserve">
          <source>Ideographic space</source>
          <target state="translated">Espacio ideográfico</target>
        </trans-unit>
        <trans-unit id="772dd6d712cea08023a9c33b5e08bad4fba86f2b" translate="yes" xml:space="preserve">
          <source>Idle.</source>
          <target state="translated">Idle.</target>
        </trans-unit>
        <trans-unit id="d71d2a6296b765e49d14ea0b96f03799b0b788cf" translate="yes" xml:space="preserve">
          <source>If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For example, the following matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;. When it matches &quot;AB&quot;, &quot;B&quot; is captured by the outer parentheses.</source>
          <target state="translated">Si (*ACCEPT)está dentro capturando paréntesis,los datos hasta ahora son capturados.Por ejemplo,lo siguiente coincide con &quot;AB&quot;,&quot;AAD&quot; o &quot;ACD&quot;.Cuando coincide con &quot;AB&quot;,&quot;B&quot; es capturado por el paréntesis exterior.</target>
        </trans-unit>
        <trans-unit id="17049b973641f08ec5c309099cc30f3f32903038" translate="yes" xml:space="preserve">
          <source>If (*COMMIT) is the only backtracking verb that is encountered, once it has been passed, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; is committed to find a match at the current starting point, or not at all, for example:</source>
          <target state="translated">Si (* COMMIT) es el &amp;uacute;nico verbo de retroceso que se encuentra, una vez que se ha pasado, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; se compromete a encontrar una coincidencia en el punto de inicio actual, o no encontrar una coincidencia, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d780bbcc021b00d62054ba34ee21d203ad8580fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is returned that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el m&amp;oacute;dulo &lt;code&gt;global&lt;/code&gt; en &lt;code&gt;Kernel&lt;/code&gt; conoce &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; , se devuelve un pid Erlang que se puede usar para enviar mensajes al servicio de horario. Adem&amp;aacute;s, el &lt;code&gt;node&lt;/code&gt; se inicializa para contener el nombre del nodo donde est&amp;aacute; registrado el servicio, de modo que pueda hacer una conexi&amp;oacute;n con &amp;eacute;l simplemente pasando la variable a &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6005483687ef9ab80b3590fb0cf13631ca631c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="translated">Si se usa el &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; llamada handle_event_function , todos los eventos se manejan en el &lt;code&gt;Module:handle_event/4&lt;/code&gt; y podemos (pero no es necesario) usar un enfoque centrado en eventos donde primero nos ramificamos dependiendo del evento y luego dependiendo del estado:</target>
        </trans-unit>
        <trans-unit id="ca5cadc65f5f231df3ce6310110d1f4f33d8f4c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no state enter calls are done.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; no devuelve dicha lista, no se realizan llamadas de entrada de estado.</target>
        </trans-unit>
        <trans-unit id="acdd1ca7763b0bdfa6212efd72aad6a1d16e6bec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every state change, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt;. This may look like an event but is really a call performed after the previous state callback returned and before any event is delivered to the new state callback. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; tuple from the state callback.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; devuelve una lista que contiene &lt;code&gt;state_enter&lt;/code&gt; , el motor &lt;code&gt;gen_statem&lt;/code&gt; , en cada cambio de estado, llamar&amp;aacute; a la &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; llamada del estado con argumentos &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; . Esto puede parecer un evento, pero en realidad es una llamada realizada despu&amp;eacute;s de que se devolvi&amp;oacute; la devoluci&amp;oacute;n de llamada del estado anterior y antes de que cualquier evento se env&amp;iacute;e a la devoluci&amp;oacute;n de llamada del nuevo estado. Consulte &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; . Esta llamada se puede repetir devolviendo una tupla &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; de la devoluci&amp;oacute;n de llamada del estado.</target>
        </trans-unit>
        <trans-unit id="d69858e99b09a6a2285a4ba103a8f8d3c928ade9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a state change, which will not cause a state enter call.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; debe transformar el estado, se considera un cambio de nombre de estado y no un cambio de estado, lo que no provocar&amp;aacute; una llamada de entrada de estado.</target>
        </trans-unit>
        <trans-unit id="c3e9d1ef03578b7d4de76213b44cdc398818f9bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current event is postponed.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el evento actual se pospone.</target>
        </trans-unit>
        <trans-unit id="e210051c1bffc48ec6b9fc364560332e7094f3fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are used, and either: the state changes, it is the initial state, or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; is used; the &lt;code&gt;gen_statem&lt;/code&gt; calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se utilizan &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; y: el estado cambia, es el estado inicial, o se utiliza uno de los resultados de devoluci&amp;oacute;n de llamada &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; ; la &lt;code&gt;gen_statem&lt;/code&gt; llama el nuevo estado de devoluci&amp;oacute;n de llamada con argumentos &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16fb9d916c4a4fe6d38e2fad03d1c0057e0a3ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; is used, exactly one system configuration file is to be used and that file is to be called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">Si se usa el &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; se usar&amp;aacute; exactamente un archivo de configuraci&amp;oacute;n del sistema y ese archivo se llamar&amp;aacute; &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f6115cbb4f02f28f406dcce7ea93217a4c99b305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt;erlang:start_timer/4&lt;/code&gt; for details.</source>
          <target state="translated">Si &lt;code&gt;Abs&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; se inicia un temporizador absoluto, y si es &lt;code&gt;false&lt;/code&gt; un relativo, que es el predeterminado. Consulte &lt;code&gt;erlang:start_timer/4&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d0a20b01d494121fa23ac0f013c356e2645f0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt;, &lt;code&gt;Suspendee&lt;/code&gt; is currently in the suspended state.</source>
          <target state="translated">Si &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt; , &lt;code&gt;Suspendee&lt;/code&gt; se encuentra actualmente en estado suspendido.</target>
        </trans-unit>
        <trans-unit id="10d7f30204e89013efcda3ea67f9618ecad92260" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto&lt;/code&gt; this function behaves exactly like &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Alg&lt;/code&gt; es &lt;code&gt;crypto&lt;/code&gt; esta funci&amp;oacute;n se comporta exactamente como &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3833f82acaa575d2a76a8a6ea669ec6336dec8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto_cache&lt;/code&gt; this function fetches random data with OpenSSL's &lt;code&gt;RAND_bytes&lt;/code&gt; and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines.</source>
          <target state="translated">Si &lt;code&gt;Alg&lt;/code&gt; es &lt;code&gt;crypto_cache&lt;/code&gt; , esta funci&amp;oacute;n obtiene datos aleatorios con &lt;code&gt;RAND_bytes&lt;/code&gt; de OpenSSL y los almacena en cach&amp;eacute; para mayor velocidad utilizando un tama&amp;ntilde;o de palabra interna de 56 bits que agiliza los c&amp;aacute;lculos en m&amp;aacute;quinas de 64 bits.</target>
        </trans-unit>
        <trans-unit id="540115359cf8a83ae29b77cf40e5db9ee30403e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1module&lt;/code&gt; is a filename without extension, first &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; is assumed, then &lt;code&gt;&quot;.asn&quot;&lt;/code&gt;, and finally &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (to be compatible with the old ASN.1 compiler). &lt;code&gt;Asn1module&lt;/code&gt; can be a full pathname (relative or absolute) including filename with (or without) extension.</source>
          <target state="translated">Si &lt;code&gt;Asn1module&lt;/code&gt; es un nombre de archivo sin extensi&amp;oacute;n, primero se asume &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; , luego &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; y finalmente &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (para que sea compatible con el antiguo compilador ASN.1). &lt;code&gt;Asn1module&lt;/code&gt; puede ser un nombre de ruta completo (relativo o absoluto), incluido el nombre de archivo con (o sin) extensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9fdaeedafeeda6ab32c9d50b3c97381ca731e512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bin&lt;/code&gt; does not contain the entire packet, &lt;code&gt;{more,Length}&lt;/code&gt; is returned. &lt;code&gt;Length&lt;/code&gt; is either the expected &lt;strong&gt;total size&lt;/strong&gt; of the packet, or &lt;code&gt;undefined&lt;/code&gt; if the expected packet size is unknown. &lt;code&gt;decode_packet&lt;/code&gt; can then be called again with more data added.</source>
          <target state="translated">Si &lt;code&gt;Bin&lt;/code&gt; no contiene el paquete completo, se devuelve &lt;code&gt;{more,Length}&lt;/code&gt; . &lt;code&gt;Length&lt;/code&gt; es el &lt;strong&gt;tama&amp;ntilde;o total&lt;/strong&gt; esperado del paquete o &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definida si se desconoce el tama&amp;ntilde;o esperado del paquete. &lt;code&gt;decode_packet&lt;/code&gt; se puede volver a llamar con m&amp;aacute;s datos agregados.</target>
        </trans-unit>
        <trans-unit id="f95f96eeb6722b14446ed74c5ef5dfae744b890d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BinRel1&lt;/code&gt; is omitted, the relation of equality between the elements of the &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; of the ranges of R[i], range R[1] &amp;times; ... &amp;times; range R[n], is used instead (intuitively, nothing is &quot;lost&quot;).</source>
          <target state="translated">Si se omite &lt;code&gt;BinRel1&lt;/code&gt; , la relaci&amp;oacute;n de igualdad entre los elementos del &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; de los rangos de R [i], rango R [1] &amp;times; ... &amp;times; rango R [n], se usa en su lugar (intuitivamente, nada es &quot; perdi&amp;oacute;&quot;).</target>
        </trans-unit>
        <trans-unit id="ab7b5f7a351be014914684701b08694a59a8d0bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binaries&lt;/code&gt; is not a flat list of binaries, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si &lt;code&gt;Binaries&lt;/code&gt; no es una lista plana de binarios, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="aec03c703d777c73a4a57e3a4befcb0a209f3691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binary&lt;/code&gt; contains the object code for module &lt;code&gt;Module&lt;/code&gt;, this BIF loads that object code. If the code for module &lt;code&gt;Module&lt;/code&gt; already exists, all export references are replaced so they point to the newly loaded code. The previously loaded code is kept in the system as old code, as there can still be processes executing that code.</source>
          <target state="translated">Si &lt;code&gt;Binary&lt;/code&gt; contiene el c&amp;oacute;digo objeto para el m&amp;oacute;dulo &lt;code&gt;Module&lt;/code&gt; , este BIF carga ese c&amp;oacute;digo objeto. Si el c&amp;oacute;digo del m&amp;oacute;dulo &lt;code&gt;Module&lt;/code&gt; ya existe, todas las referencias de exportaci&amp;oacute;n se reemplazan para que apunten al c&amp;oacute;digo reci&amp;eacute;n cargado. El c&amp;oacute;digo previamente cargado se mantiene en el sistema como c&amp;oacute;digo antiguo, ya que todav&amp;iacute;a puede haber procesos que ejecuten ese c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="bf1ea3c8c99142091a2f51c1e81be7adb284b19c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block&lt;/code&gt;, multi-scheduling is blocked. That is, one and only one scheduler thread will execute. If &lt;code&gt;BlockState =:= unblock&lt;/code&gt; and no one else blocks multi-scheduling, and this process has blocked only once, multi-scheduling is unblocked.</source>
          <target state="translated">Si &lt;code&gt;BlockState =:= block&lt;/code&gt; , la programaci&amp;oacute;n m&amp;uacute;ltiple est&amp;aacute; bloqueada. Es decir, se ejecutar&amp;aacute; uno y solo un subproceso del planificador. Si &lt;code&gt;BlockState =:= unblock&lt;/code&gt; y nadie m&amp;aacute;s bloquea la programaci&amp;oacute;n m&amp;uacute;ltiple, y este proceso se ha bloqueado solo una vez, la programaci&amp;oacute;n m&amp;uacute;ltiple se desbloquea.</target>
        </trans-unit>
        <trans-unit id="39adb796c018ce57c270103c3c52ab7a2219f00b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block_normal&lt;/code&gt;, normal multi-scheduling is blocked. That is, only one normal scheduler thread will execute, but multiple dirty schedulers can execute. If &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; and no one else blocks normal multi-scheduling, and this process has blocked only once, normal multi-scheduling is unblocked.</source>
          <target state="translated">Si &lt;code&gt;BlockState =:= block_normal&lt;/code&gt; , la programaci&amp;oacute;n m&amp;uacute;ltiple normal est&amp;aacute; bloqueada. Es decir, solo se ejecutar&amp;aacute; un subproceso del programador normal, pero se pueden ejecutar varios programadores sucios. Si &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; y nadie m&amp;aacute;s bloquea la programaci&amp;oacute;n m&amp;uacute;ltiple normal, y este proceso se ha bloqueado solo una vez, la programaci&amp;oacute;n m&amp;uacute;ltiple normal se desbloquea.</target>
        </trans-unit>
        <trans-unit id="4eabdce3dc316d89d6448638269f7e3485875fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Body&lt;/code&gt; is returned and equal to &lt;code&gt;{Fun,Arg}&lt;/code&gt;, the web server tries &lt;code&gt;apply/2&lt;/code&gt; on &lt;code&gt;Fun&lt;/code&gt; with &lt;code&gt;Arg&lt;/code&gt; as argument. The web server expects that the fun either returns a list &lt;code&gt;(Body)&lt;/code&gt; that is an HTTP repsonse, or the atom &lt;code&gt;sent&lt;/code&gt; if the HTTP response is sent back to the client. If &lt;code&gt;close&lt;/code&gt; is returned from the fun, something has gone wrong and the server signals this to the client by closing the connection.</source>
          <target state="translated">Si se devuelve &lt;code&gt;Body&lt;/code&gt; y es igual a &lt;code&gt;{Fun,Arg}&lt;/code&gt; , el servidor web intenta &lt;code&gt;apply/2&lt;/code&gt; en &lt;code&gt;Fun&lt;/code&gt; con &lt;code&gt;Arg&lt;/code&gt; como argumento. El servidor web espera que la diversi&amp;oacute;n devuelva una lista &lt;code&gt;(Body)&lt;/code&gt; que es una respuesta HTTP, o el &amp;aacute;tomo &lt;code&gt;sent&lt;/code&gt; si la respuesta HTTP se env&amp;iacute;a de vuelta al cliente. Si se devuelve un &lt;code&gt;close&lt;/code&gt; de la diversi&amp;oacute;n, algo sali&amp;oacute; mal y el servidor se lo indica al cliente cerrando la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="501ba76048afe6c06b0d19442d6fa569952e8089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default value), &lt;code&gt;rb&lt;/code&gt; prints an error message to &lt;code&gt;stdout&lt;/code&gt; for every bad report it encounters, but the logging process is never ended. All printable reports are written. If logging to file is enabled, &lt;code&gt;rb&lt;/code&gt; prints &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; in the log file at the location of an unprintable report.</source>
          <target state="translated">Si &lt;code&gt;Bool&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; (el valor predeterminado), &lt;code&gt;rb&lt;/code&gt; imprime un mensaje de error en &lt;code&gt;stdout&lt;/code&gt; por cada informe incorrecto que encuentra, pero el proceso de registro nunca termina. Todos los informes imprimibles est&amp;aacute;n escritos. Si el registro en archivo est&amp;aacute; habilitado, &lt;code&gt;rb&lt;/code&gt; imprime &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; en el archivo de registro en la ubicaci&amp;oacute;n de un informe no imprimible.</target>
        </trans-unit>
        <trans-unit id="adf90318c831c61cd69b483b3f045a3d3bf9c68f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;rb&lt;/code&gt; stops logging (and prints an error message to &lt;code&gt;stdout&lt;/code&gt;) if it encounters a badly formatted report. If logging to file is enabled, an error message is appended to the log file as well.</source>
          <target state="translated">Si &lt;code&gt;Bool&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;rb&lt;/code&gt; deja de registrar (e imprime un mensaje de error en &lt;code&gt;stdout&lt;/code&gt; ) si encuentra un informe mal formateado. Si el registro en archivo est&amp;aacute; habilitado, tambi&amp;eacute;n se agrega un mensaje de error al archivo de registro.</target>
        </trans-unit>
        <trans-unit id="f4e4245f2e5400c897f04314650c4ae5a083dc43" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, option &lt;code&gt;TCP_NODELAY&lt;/code&gt; is turned on for the socket, which means that also small amounts of data are sent immediately.</source>
          <target state="translated">Si &lt;code&gt;Boolean == true&lt;/code&gt; , la opci&amp;oacute;n &lt;code&gt;TCP_NODELAY&lt;/code&gt; est&amp;aacute; activada para el socket, lo que significa que tambi&amp;eacute;n se env&amp;iacute;an peque&amp;ntilde;as cantidades de datos inmediatamente.</target>
        </trans-unit>
        <trans-unit id="81aeea37b05ee5c673682e9fcc0d5b3b90b2fd57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Button&lt;/code&gt; is a top type and it is needed to exclude component &lt;code&gt;number&lt;/code&gt; from decode, &lt;code&gt;Type_List&lt;/code&gt; in the instruction in the configuration file is &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt;. If you call the decode function &lt;code&gt;decode_Button_exclusive&lt;/code&gt;, &lt;code&gt;Decode_Instruction&lt;/code&gt; is &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Button&lt;/code&gt; es un tipo superior y es necesario excluir el &lt;code&gt;number&lt;/code&gt; componente de la decodificaci&amp;oacute;n, &lt;code&gt;Type_List&lt;/code&gt; en la instrucci&amp;oacute;n en el archivo de configuraci&amp;oacute;n es &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt; . Si llama a la funci&amp;oacute;n de decodificaci&amp;oacute;n &lt;code&gt;decode_Button_exclusive&lt;/code&gt; , &lt;code&gt;Decode_Instruction&lt;/code&gt; es &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a8d1dadfc486d1483799d20461767cefd8ed40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Common Test&lt;/code&gt; Master fails initially to connect to any of the test nodes specified in a test specification or in the &lt;code&gt;InclNodes&lt;/code&gt; list, the operator is prompted with the option to either start over again (after manually checking the status of the nodes in question), to run without the missing nodes, or to abort the operation.</source>
          <target state="translated">Si &lt;code&gt;Common Test&lt;/code&gt; Master no se conecta inicialmente a cualquiera de los nodos de prueba especificados en una especificaci&amp;oacute;n de prueba o en la lista &lt;code&gt;InclNodes&lt;/code&gt; , se le solicita al operador la opci&amp;oacute;n de comenzar de nuevo (despu&amp;eacute;s de verificar manualmente el estado de los nodos en cuesti&amp;oacute;n), para ejecutar sin los nodos faltantes, o para abortar la operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7f9aad828bfbe4d21e5a879fcef15f035543f64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CurrentIndentation&lt;/code&gt; is negative, there are no line breaks and only a space is used as a separator.</source>
          <target state="translated">Si &lt;code&gt;CurrentIndentation&lt;/code&gt; es negativo, no hay saltos de l&amp;iacute;nea y solo se usa un espacio como separador.</target>
        </trans-unit>
        <trans-unit id="5c9db23221c4effc6df13f53f295b1b05c8bade4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Data&lt;/code&gt; is an invalid I/O list.</source>
          <target state="translated">Si los &lt;code&gt;Data&lt;/code&gt; son una lista de E / S no v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="d49ad8995eb2ed767b688b2071df0c58e2d5482e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateTo, to}&lt;/code&gt;, reports that occurred before &lt;code&gt;DateTo&lt;/code&gt; are displayed.</source>
          <target state="translated">Si &lt;code&gt;Dates&lt;/code&gt; tiene el formato &lt;code&gt;{DateTo, to}&lt;/code&gt; , se muestran los informes que ocurrieron antes de &lt;code&gt;DateTo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a74df3b45fff783ce83be5e48dd039ecedaba02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, it must be a &lt;code&gt;pid()&lt;/code&gt; of a process created on the current runtime system instance. This process has either terminated or not. If &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;, it is interpreted as the name of a locally registered process. The process referred to by the name is looked up at the time of timer expiration. No error is returned if the name does not refer to a process.</source>
          <target state="translated">Si &lt;code&gt;Dest&lt;/code&gt; es un &lt;code&gt;pid()&lt;/code&gt; , debe ser un &lt;code&gt;pid()&lt;/code&gt; de un proceso creado en la instancia actual del sistema en tiempo de ejecuci&amp;oacute;n. Este proceso ha terminado o no. Si &lt;code&gt;Dest&lt;/code&gt; es un &lt;code&gt;atom()&lt;/code&gt; , se interpreta como el nombre de un proceso registrado localmente. El proceso al que se hace referencia por el nombre se busca en el momento de la expiraci&amp;oacute;n del temporizador. No se devuelve ning&amp;uacute;n error si el nombre no se refiere a un proceso.</target>
        </trans-unit>
        <trans-unit id="815563aae4c2a11f4a34513e2da4caef9eb431be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, the timer is automatically canceled if the process referred to by the &lt;code&gt;pid()&lt;/code&gt; is not alive, or if the process exits. This feature was introduced in ERTS 5.4.11. Notice that timers are not automatically canceled when &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Dest&lt;/code&gt; es un &lt;code&gt;pid()&lt;/code&gt; , el temporizador se cancela autom&amp;aacute;ticamente si el proceso al que hace referencia el &lt;code&gt;pid()&lt;/code&gt; no est&amp;aacute; activo o si el proceso se cierra. Esta funci&amp;oacute;n se introdujo en ERTS 5.4.11. Tenga en cuenta que los temporizadores no se cancelan autom&amp;aacute;ticamente cuando &lt;code&gt;Dest&lt;/code&gt; es un &lt;code&gt;atom()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="444e6101a0cf1c543819e121052f438f584a1b39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Destination&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;write&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">Si &lt;code&gt;Destination&lt;/code&gt; refiere a un nombre de archivo, se abre con el modo de &lt;code&gt;write&lt;/code&gt; antepuesto a la lista de modos antes de la copia y se cierra cuando termina.</target>
        </trans-unit>
        <trans-unit id="4f4e05199aa0bb385a948469feaaa5b970e7e3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dir&lt;/code&gt; does not exist</source>
          <target state="translated">Si &lt;code&gt;Dir&lt;/code&gt; no existe</target>
        </trans-unit>
        <trans-unit id="ee2b254fd6abe2a90dfea4382f11c9cb30169e97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == default&lt;/code&gt;, the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt; is used.</source>
          <target state="translated">Si &lt;code&gt;Distributed == default&lt;/code&gt; , se utiliza el valor de la aplicaci&amp;oacute;n en el par&amp;aacute;metro de configuraci&amp;oacute;n del n&amp;uacute;cleo &lt;code&gt;distributed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49d3ece08d6530837a1ab0ddc7b321c040846a53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt;, the application becomes distributed. The argument overrides the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt;. &lt;code&gt;Application&lt;/code&gt; must be the application name (same as in the first argument). If a node crashes and &lt;code&gt;Time&lt;/code&gt; is specified, the application controller waits for &lt;code&gt;Time&lt;/code&gt; milliseconds before attempting to restart the application on another node. If &lt;code&gt;Time&lt;/code&gt; is not specified, it defaults to &lt;code&gt;0&lt;/code&gt; and the application is restarted immediately.</source>
          <target state="translated">Si &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt; , la aplicaci&amp;oacute;n se distribuye. El argumento anula el valor de la aplicaci&amp;oacute;n en el par&amp;aacute;metro de configuraci&amp;oacute;n del n&amp;uacute;cleo &lt;code&gt;distributed&lt;/code&gt; . &lt;code&gt;Application&lt;/code&gt; debe ser el nombre de la aplicaci&amp;oacute;n (igual que en el primer argumento). Si un nodo falla y &lt;code&gt;Time&lt;/code&gt; se especifica, el controlador espera la aplicaci&amp;oacute;n para &lt;code&gt;Time&lt;/code&gt; milisegundos antes de intentar reiniciar la aplicaci&amp;oacute;n en otro nodo. Si no se especifica &lt;code&gt;Time&lt;/code&gt; , el valor predeterminado es &lt;code&gt;0&lt;/code&gt; y la aplicaci&amp;oacute;n se reinicia inmediatamente.</target>
        </trans-unit>
        <trans-unit id="4152fae1a454be09c28651bdb166f8066323431a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, lists of integers &lt;code&gt;0..255&lt;/code&gt; or binaries containing plain bytes are sent back to the client when possible. If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;, lists with integers in the whole Unicode range or binaries encoded in UTF-8 are sent to the client. The user-supplied function always sees lists of integers, never binaries, but the list can contain numbers &amp;gt; 255 if &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Encoding&lt;/code&gt; es &lt;code&gt;latin1&lt;/code&gt; , las listas de enteros &lt;code&gt;0..255&lt;/code&gt; o binarios que contienen bytes sin formato se env&amp;iacute;an al cliente cuando es posible. Si la &lt;code&gt;Encoding&lt;/code&gt; es &lt;code&gt;unicode&lt;/code&gt; , se env&amp;iacute;an al cliente listas con n&amp;uacute;meros enteros en todo el rango Unicode o binarios codificados en UTF-8. La funci&amp;oacute;n proporcionada por el usuario siempre ve listas de enteros, nunca binarios, pero la lista puede contener n&amp;uacute;meros&amp;gt; 255 si la &lt;code&gt;Encoding&lt;/code&gt; es &lt;code&gt;unicode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="795ff54ae5d53c3fcba2e08602c3c1f2e9df291a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == close&lt;/code&gt;, data is returned to the caller when the channel is closed by the server. If a time-out occurs before this happens, the function returns &lt;code&gt;{timeout,Data}&lt;/code&gt; (where &lt;code&gt;Data&lt;/code&gt; is the data received so far).</source>
          <target state="translated">Si &lt;code&gt;End == close&lt;/code&gt; , los datos se devuelven a la persona que llama cuando el servidor cierra el canal. Si ocurre un tiempo de espera antes de que esto suceda, la funci&amp;oacute;n devuelve &lt;code&gt;{timeout,Data}&lt;/code&gt; (donde &lt;code&gt;Data&lt;/code&gt; son los datos recibidos hasta el momento).</target>
        </trans-unit>
        <trans-unit id="4c405ae6dd72ff067086a677208e5abd694be786" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == timeout&lt;/code&gt;, a time-out is expected and &lt;code&gt;{ok,Data}&lt;/code&gt; is returned both in the case of a time-out and when the channel is closed.</source>
          <target state="translated">Si &lt;code&gt;End == timeout&lt;/code&gt; , se espera un time-out y se devuelve &lt;code&gt;{ok,Data}&lt;/code&gt; tanto en el caso de un time-out como cuando el canal est&amp;aacute; cerrado.</target>
        </trans-unit>
        <trans-unit id="9a4d4ab4678c1a0d9f4a6cd0d0cd26eccd4b8374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End&lt;/code&gt; is a fun, this fun is called with one argument, the data value in a received &lt;code&gt;ssh_cm&lt;/code&gt; message (see &lt;code&gt;ssh_connection(3)&lt;/code&gt;. The fun is to return either &lt;code&gt;true&lt;/code&gt; to end the receiving operation (and have the so far collected data returned) or &lt;code&gt;false&lt;/code&gt; to wait for more data from the server. Even if a fun is supplied, the function returns immediately if the server closes the channel).</source>
          <target state="translated">Si &lt;code&gt;End&lt;/code&gt; es una diversi&amp;oacute;n, esta diversi&amp;oacute;n se llama con un argumento, el valor de los datos en un mensaje &lt;code&gt;ssh_cm&lt;/code&gt; recibido (consulte &lt;code&gt;ssh_connection(3)&lt;/code&gt; . La diversi&amp;oacute;n es devolver &lt;code&gt;true&lt;/code&gt; para finalizar la operaci&amp;oacute;n de recepci&amp;oacute;n (y que se devuelvan los datos recopilados hasta ahora ) o &lt;code&gt;false&lt;/code&gt; para esperar m&amp;aacute;s datos del servidor. Incluso si se proporciona una diversi&amp;oacute;n, la funci&amp;oacute;n regresa inmediatamente si el servidor cierra el canal).</target>
        </trans-unit>
        <trans-unit id="91045bcf979078e315cc68ac468e5a360ddec33a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EnumTypeName&lt;/code&gt; does not exist in the ASN.1 specification, the compilation stops with an error code.</source>
          <target state="translated">Si &lt;code&gt;EnumTypeName&lt;/code&gt; no existe en la especificaci&amp;oacute;n ASN.1, la compilaci&amp;oacute;n se detiene con un c&amp;oacute;digo de error.</target>
        </trans-unit>
        <trans-unit id="d6ac5b0475b7a71717a3a976c82dd686c7a2b338" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="translated">Si &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt; , el administrador de eventos se registra globalmente como &lt;code&gt;GlobalName&lt;/code&gt; usando &lt;code&gt;global:register_name/2&lt;/code&gt; . Si no se proporciona un nombre, el administrador de eventos no est&amp;aacute; registrado.</target>
        </trans-unit>
        <trans-unit id="145008a8fe8d11833ffba04465b46c305eac398a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt;, the event manager is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt; , el administrador de eventos se registra localmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d48cb710ca1d3e34d2637a454ccf4af2333759" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt;, the event manager registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave as the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Si &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt; , el administrador de eventos se registra en el registro representado por &lt;code&gt;Module&lt;/code&gt; . La devoluci&amp;oacute;n de llamada del &lt;code&gt;Module&lt;/code&gt; es para exportar las funciones &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; y &lt;code&gt;send/2&lt;/code&gt; , que se comportar&amp;aacute;n como las funciones correspondientes en &lt;code&gt;global&lt;/code&gt; . Por lo tanto, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; es una referencia v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="0e635b8f737737ba5a05f0c993e3dfac9ac242c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;EventType&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; , la persona que llama espera una respuesta. La respuesta se puede enviar desde este o desde cualquier otro &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; de llamada regresando con &lt;code&gt;{reply,From,Reply}&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; , en &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt; o llamando a &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83ef91cec4b18110476efaead7f796da1eca29a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Expr1&lt;/code&gt; evaluates to a name, but this name is not registered, a &lt;code&gt;badarg&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Si &lt;code&gt;Expr1&lt;/code&gt; se eval&amp;uacute;a como un nombre, pero este nombre no est&amp;aacute; registrado, se produce un error de tiempo de ejecuci&amp;oacute;n &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abad608745399cb2e4372968eab18b8ca631a3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExprF&lt;/code&gt; is an atom, the function is said to be called by using the &lt;strong&gt;implicitly qualified function name&lt;/strong&gt;. If the function &lt;code&gt;ExprF&lt;/code&gt; is locally defined, it is called. Alternatively, if &lt;code&gt;ExprF&lt;/code&gt; is explicitly imported from the &lt;code&gt;M&lt;/code&gt; module, &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; is called. If &lt;code&gt;ExprF&lt;/code&gt; is neither declared locally nor explicitly imported, &lt;code&gt;ExprF&lt;/code&gt; must be the name of an automatically imported BIF.</source>
          <target state="translated">Si &lt;code&gt;ExprF&lt;/code&gt; es un &amp;aacute;tomo, se dice que la funci&amp;oacute;n se llama utilizando el &lt;strong&gt;nombre de funci&amp;oacute;n calificado impl&amp;iacute;citamente&lt;/strong&gt; . Si la funci&amp;oacute;n &lt;code&gt;ExprF&lt;/code&gt; est&amp;aacute; definida localmente, se llama. Alternativamente, si &lt;code&gt;ExprF&lt;/code&gt; se importa expl&amp;iacute;citamente desde el m&amp;oacute;dulo &lt;code&gt;M&lt;/code&gt; , se &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; . Si &lt;code&gt;ExprF&lt;/code&gt; no se declara localmente ni se importa expl&amp;iacute;citamente, &lt;code&gt;ExprF&lt;/code&gt; debe ser el nombre de un BIF importado autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="292de33996b21603ce18c953090ce4d3bb28c1aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the matching events are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the matching events are stopped.</source>
          <target state="translated">Si &lt;code&gt;Extra&lt;/code&gt; es &lt;code&gt;log&lt;/code&gt; , se permiten los eventos coincidentes. Si &lt;code&gt;Extra&lt;/code&gt; se &lt;code&gt;stop&lt;/code&gt; , los eventos coincidentes se detienen.</target>
        </trans-unit>
        <trans-unit id="0c63a514bfa0d0eec024a84c5585b4db685eb8d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the progress reports are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the progress reports are stopped.</source>
          <target state="translated">Si &lt;code&gt;Extra&lt;/code&gt; es &lt;code&gt;log&lt;/code&gt; , se permiten los informes de progreso. Si &lt;code&gt;Extra&lt;/code&gt; se &lt;code&gt;stop&lt;/code&gt; , los informes de progreso se detienen.</target>
        </trans-unit>
        <trans-unit id="676697b8c810137bc5f3cbd3dba9cf47ed56934a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, or &lt;code&gt;Pad&lt;/code&gt; is a &lt;code&gt;*&lt;/code&gt; character, the next argument in &lt;code&gt;Data&lt;/code&gt; is used as the value. For example:</source>
          <target state="translated">Si &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; o &lt;code&gt;Pad&lt;/code&gt; es un car&amp;aacute;cter &lt;code&gt;*&lt;/code&gt; , el siguiente argumento en &lt;code&gt;Data&lt;/code&gt; se usa como valor. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="58d27e8ccd9fb7397c53540d079879af93136abc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FIPS_mode_set&lt;/code&gt; returns &lt;code&gt;no&lt;/code&gt; the OpenSSL library is not FIPS enabled and crypto won't support FIPS mode either.</source>
          <target state="translated">Si &lt;code&gt;FIPS_mode_set&lt;/code&gt; devuelve &lt;code&gt;no&lt;/code&gt; , la biblioteca OpenSSL no est&amp;aacute; habilitada para FIPS y el cifrado tampoco admitir&amp;aacute; el modo FIPS.</target>
        </trans-unit>
        <trans-unit id="03e0cd5df5f6d73de87e5cdb82e5a381f90cc69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is equal to the index set of &lt;code&gt;Family1&lt;/code&gt;, and &lt;code&gt;Family3&lt;/code&gt;[i] is the difference between &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if &lt;code&gt;Family2&lt;/code&gt; maps i, otherwise &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; y &lt;code&gt;Family2&lt;/code&gt; son &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;Family3&lt;/code&gt; es la familia de modo que el conjunto de &amp;iacute;ndices es igual al conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 y &lt;code&gt;Family3&lt;/code&gt; [i] es la diferencia entre &lt;code&gt;Family1&lt;/code&gt; [i] y &lt;code&gt;Family2&lt;/code&gt; [i] si &lt;code&gt;Family2&lt;/code&gt; asigna i; de lo contrario &lt;code&gt;Family1[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="707694b53f4e6ff34f03b06100b8fc3bb1a63a00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the intersection of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the intersection of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; y &lt;code&gt;Family2&lt;/code&gt; son &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;Family3&lt;/code&gt; es la familia tal que el conjunto de &amp;iacute;ndices es la intersecci&amp;oacute;n de los &lt;code&gt;Family1&lt;/code&gt; de &amp;iacute;ndices Familia1 : sy &lt;code&gt;Family2&lt;/code&gt; : s, y &lt;code&gt;Family3&lt;/code&gt; [i] es la intersecci&amp;oacute;n de &lt;code&gt;Family1&lt;/code&gt; [i] y &lt;code&gt;Family2&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="c3481789d9f11af86121200c69343c46693c383d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the union of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the union of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if both map i, otherwise &lt;code&gt;Family1&lt;/code&gt;[i] or &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; y &lt;code&gt;Family2&lt;/code&gt; son &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;Family3&lt;/code&gt; es la familia de modo que el conjunto de &amp;iacute;ndices es la uni&amp;oacute;n de los &lt;code&gt;Family1&lt;/code&gt; de &amp;iacute;ndices de Familia1 : sy &lt;code&gt;Family2&lt;/code&gt; : s, y &lt;code&gt;Family3&lt;/code&gt; [i] es la uni&amp;oacute;n de &lt;code&gt;Family1&lt;/code&gt; [i] y &lt;code&gt;Family2&lt;/code&gt; [i] si ambos mapean i, de lo contrario, &lt;code&gt;Family1&lt;/code&gt; [i] o &lt;code&gt;Family2&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="901cb0563eae4ae927b85e3235bb204abe3eeb2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es una relaci&amp;oacute;n binaria para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es el &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10edd17f93cf8b662a14cd64ee029b216f69998c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es una relaci&amp;oacute;n binaria para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es el &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i] .</target>
        </trans-unit>
        <trans-unit id="603f807d85acd930990c4dcffafa135bbe46960c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es una relaci&amp;oacute;n binaria para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es el &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i] .</target>
        </trans-unit>
        <trans-unit id="df7eb7122ac171a82f2f5b7eabda31d098834629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for each i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es un conjunto de conjuntos para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es la &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i ].</target>
        </trans-unit>
        <trans-unit id="9f6dbbe306d7fe1ab285e45f10bed30dc90b32b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es un conjunto de conjuntos para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es la &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i ].</target>
        </trans-unit>
        <trans-unit id="6513fd3da5029f77ec7aae42fce09531984adc2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt; to those elements i of the index set for which &lt;code&gt;Fun&lt;/code&gt; applied to &lt;code&gt;Family1&lt;/code&gt;[i] returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;Fun&lt;/code&gt; is a tuple &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt;, then &lt;code&gt;Fun2&lt;/code&gt; is applied to the &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i], otherwise &lt;code&gt;Fun&lt;/code&gt; is applied to &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;Family2&lt;/code&gt; es la &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; a los elementos i del conjunto de &amp;iacute;ndices para los que &lt;code&gt;Fun&lt;/code&gt; aplicado a &lt;code&gt;Family1&lt;/code&gt; [i] devuelve &lt;code&gt;true&lt;/code&gt; . Si &lt;code&gt;Fun&lt;/code&gt; es una tupla &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt; , &lt;code&gt;Fun2&lt;/code&gt; se aplica al &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i]; de lo contrario, &lt;code&gt;Fun&lt;/code&gt; se aplica a &lt;code&gt;Family1&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="0036be6edcb9af44b23cf453b297b5ff3815e4ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the result of calling &lt;code&gt;SetFun&lt;/code&gt; with &lt;code&gt;Family1&lt;/code&gt;[i] as argument.</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; ,de modo que &lt;code&gt;Family2&lt;/code&gt; [i] es el resultado de llamar a &lt;code&gt;SetFun&lt;/code&gt; con &lt;code&gt;Family1&lt;/code&gt; [i] como argumento.</target>
        </trans-unit>
        <trans-unit id="a3ed4a237eeb2ac6e0edeeca8e08129966f3f00f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt;[i] is an empty set for some i, the process exits with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; [i] es un conjunto vac&amp;iacute;o para alguna i, el proceso sale con un mensaje &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15ab50a2f9b83c85c1bf92e12df53a14b6fa72a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;BinRel&lt;/code&gt; is the binary relation containing all pairs (i, x) such that i belongs to the index set of &lt;code&gt;Family&lt;/code&gt; and x belongs to &lt;code&gt;Family&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;BinRel&lt;/code&gt; es la relaci&amp;oacute;n binaria que contiene todos los pares (i, x) de manera que i pertenece al conjunto de &amp;iacute;ndices de &lt;code&gt;Family&lt;/code&gt; yx pertenece a &lt;code&gt;Family&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="8cca7739eb38698717638b6eb6af393def280970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; is not specified, a file dialog is opened where the crashdump can be selected.</source>
          <target state="translated">Si &lt;code&gt;File&lt;/code&gt; no se especifica, un di&amp;aacute;logo de archivo se abre en el que el volcado de bloqueo puede ser seleccionado.</target>
        </trans-unit>
        <trans-unit id="64e8f8682c5f33b6a09cda03b8458e6523b8dd31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; cannot be run, an error exception is raised, with the POSIX error code as the reason. The error reason can differ between OSs. Typically the error &lt;code&gt;enoent&lt;/code&gt; is raised when an attempt is made to run a program that is not found and &lt;code&gt;eacces&lt;/code&gt; is raised when the specified file is not executable.</source>
          <target state="translated">Si &lt;code&gt;FileName&lt;/code&gt; no se puede ejecutar, se genera una excepci&amp;oacute;n de error, con el c&amp;oacute;digo de error POSIX como motivo. El motivo del error puede diferir entre los sistemas operativos. Normalmente, el error &lt;code&gt;enoent&lt;/code&gt; se genera cuando se intenta ejecutar un programa que no se encuentra y &lt;code&gt;eacces&lt;/code&gt; se genera cuando el archivo especificado no es ejecutable.</target>
        </trans-unit>
        <trans-unit id="d64f4daf12cc430f6c5ecc07bc1247a82079bedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; has a suffix that indicates an object file (&lt;code&gt;.beam&lt;/code&gt;), EUnit will try to reload the module from the specified file and test it. Otherwise, the file is assumed to be a text file containing test specifications, which will be read using the standard library function &lt;code&gt;file:path_consult/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;FileName&lt;/code&gt; tiene un sufijo que indica un archivo de objeto ( &lt;code&gt;.beam&lt;/code&gt; ), EUnit intentar&amp;aacute; recargar el m&amp;oacute;dulo desde el archivo especificado y probarlo. De lo contrario, se supone que el archivo es un archivo de texto que contiene especificaciones de prueba, que se leer&amp;aacute;n utilizando el &lt;code&gt;file:path_consult/2&lt;/code&gt; funci&amp;oacute;n de biblioteca est&amp;aacute;ndar : path_consult / 2 .</target>
        </trans-unit>
        <trans-unit id="f69d9680f0ea2ac6663d58bccc19bea7f9110950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is a &lt;code&gt;string()&lt;/code&gt;, &lt;code&gt;make_config/1&lt;/code&gt; will use &lt;code&gt;FileNameOrIODev&lt;/code&gt; as a filename. A file named &lt;code&gt;FileNameOrIODev&lt;/code&gt; is created and the configuration will be written to that file. If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is an &lt;code&gt;io_device()&lt;/code&gt; (see the documentation of the module &lt;code&gt;io&lt;/code&gt;), the configuration will be written to the io device.</source>
          <target state="translated">Si &lt;code&gt;FileNameOrIODev&lt;/code&gt; es una &lt;code&gt;string()&lt;/code&gt; , &lt;code&gt;make_config/1&lt;/code&gt; usar&amp;aacute; &lt;code&gt;FileNameOrIODev&lt;/code&gt; como nombre de archivo. Se crea un archivo llamado &lt;code&gt;FileNameOrIODev&lt;/code&gt; y la configuraci&amp;oacute;n se escribir&amp;aacute; en ese archivo. Si &lt;code&gt;FileNameOrIODev&lt;/code&gt; es un &lt;code&gt;io_device()&lt;/code&gt; (consulte la documentaci&amp;oacute;n del m&amp;oacute;dulo &lt;code&gt;io&lt;/code&gt; ), la configuraci&amp;oacute;n se escribir&amp;aacute; en el dispositivo io.</target>
        </trans-unit>
        <trans-unit id="abe7ea2e6f95f6e74b291e53017c69e3872b70e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Filename&lt;/code&gt; is not a symbolic link, this function returns exactly the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Filename&lt;/code&gt; no es un enlace simb&amp;oacute;lico, esta funci&amp;oacute;n devuelve exactamente el mismo resultado que &lt;code&gt;read_file_info/1&lt;/code&gt; . En plataformas que no admiten enlaces simb&amp;oacute;licos, esta funci&amp;oacute;n siempre es equivalente a &lt;code&gt;read_file_info/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb890f105737b8f693a0a5c7d392809221b9ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fix&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, table &lt;code&gt;Name&lt;/code&gt; is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates.</source>
          <target state="translated">Si &lt;code&gt;Fix&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el &lt;code&gt;Name&lt;/code&gt; tabla se fija (una vez m&amp;aacute;s) por el proceso de llamada; de lo contrario, la tabla se libera. La tabla tambi&amp;eacute;n se libera cuando finaliza un proceso de reparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="35e7f62cf2a411f7548edbc78f5bda5268f86881" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;get&lt;/code&gt;, a list of all logged events is returned.</source>
          <target state="translated">Si se &lt;code&gt;get&lt;/code&gt; &lt;code&gt;Flag&lt;/code&gt; , se devuelve una lista de todos los eventos registrados.</target>
        </trans-unit>
        <trans-unit id="381028fa2c7469ac85a20d5087b1b0fd8afdf82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;print&lt;/code&gt;, the logged events are printed to &lt;code&gt;standard_io&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;print&lt;/code&gt; &lt;code&gt;Flag&lt;/code&gt; , los eventos registrados se imprimen en &lt;code&gt;standard_io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b722fce5cc319fa08cae29348ebef98f92c444d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a new subscription is started. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, all previous subscriptions started with the same &lt;code&gt;Options&lt;/code&gt; are stopped. Two option lists are considered the same if they contain the same set of options.</source>
          <target state="translated">Si &lt;code&gt;Flag&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , se inicia una nueva suscripci&amp;oacute;n. Si &lt;code&gt;Flag&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , se detienen todas las suscripciones anteriores iniciadas con las mismas &lt;code&gt;Options&lt;/code&gt; . Dos listas de opciones se consideran iguales si contienen el mismo conjunto de opciones.</target>
        </trans-unit>
        <trans-unit id="7ca78e84b760984f52335bac15cc8a1e618b6c52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flags = all&lt;/code&gt;, all possible flags are set.</source>
          <target state="translated">Si &lt;code&gt;Flags = all&lt;/code&gt; , se establecen todos los indicadores posibles.</target>
        </trans-unit>
        <trans-unit id="2613d68b6d252e8fa327001ad657894c48452d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;finish&lt;/code&gt;, pending input is processed, pending output is flushed, and &lt;code&gt;deflate/3&lt;/code&gt; returns. Afterwards the only possible operations on the stream are &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Flush&lt;/code&gt; est&amp;aacute; configurado para &lt;code&gt;finish&lt;/code&gt; , la entrada pendiente se procesa, la salida pendiente se vac&amp;iacute;a y se &lt;code&gt;deflate/3&lt;/code&gt; . Posteriormente, las &amp;uacute;nicas operaciones posibles en la secuencia son &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a28ee970d5c9d1771957ed2098a6a9bd614a23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;full&lt;/code&gt;, all output is flushed as with &lt;code&gt;sync&lt;/code&gt;, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using &lt;code&gt;full&lt;/code&gt; too often can seriously degrade the compression.</source>
          <target state="translated">Si &lt;code&gt;Flush&lt;/code&gt; se establece en &lt;code&gt;full&lt;/code&gt; , toda la salida se vac&amp;iacute;a como con la &lt;code&gt;sync&lt;/code&gt; , y el estado de compresi&amp;oacute;n se restablece para que la descompresi&amp;oacute;n pueda reiniciarse desde este punto si los datos comprimidos anteriores se han da&amp;ntilde;ado o si se desea un acceso aleatorio. El uso &lt;code&gt;full&lt;/code&gt; demasiada frecuencia puede degradar seriamente la compresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5b162b87236f918abd12b2632484cedd86b7642d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;sync&lt;/code&gt;, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. Flushing can degrade compression for some compression algorithms; thus, use it only when necessary.</source>
          <target state="translated">Si &lt;code&gt;Flush&lt;/code&gt; est&amp;aacute; configurado para &lt;code&gt;sync&lt;/code&gt; , toda la salida pendiente se vac&amp;iacute;a en el b&amp;uacute;fer de salida y la salida se alinea en un l&amp;iacute;mite de bytes, de modo que el descompresor pueda obtener todos los datos de entrada disponibles hasta el momento. El lavado puede degradar la compresi&amp;oacute;n de algunos algoritmos de compresi&amp;oacute;n; por lo tanto, util&amp;iacute;celo solo cuando sea necesario.</target>
        </trans-unit>
        <trans-unit id="3748c496d0aee0e31ef9623ffe6c9c459e673128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to load each mib even after failing to load a previous mib. Use with care.</source>
          <target state="translated">Si &lt;code&gt;Force = true&lt;/code&gt; , el agente seguir&amp;aacute; intentando cargar cada mib incluso despu&amp;eacute;s de no poder cargar un mib anterior. &amp;Uacute;selo con cuidado.</target>
        </trans-unit>
        <trans-unit id="2cad12b8139e1623aaeb8a5ccd722b61cea66f96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to unload each mib even after failing to unload a previous mib. Use with care.</source>
          <target state="translated">Si &lt;code&gt;Force = true&lt;/code&gt; , el agente seguir&amp;aacute; intentando descargar cada mib incluso despu&amp;eacute;s de no poder descargar un mib anterior. &amp;Uacute;selo con cuidado.</target>
        </trans-unit>
        <trans-unit id="7d0a736a5ea9ae64f8bc28b164008b5e41f8db91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt;, &lt;code&gt;et_viewer&lt;/code&gt; in application ET is used for presenting the trace log graphically. &lt;code&gt;ttb&lt;/code&gt; provides a few different filters that can be selected from menu &lt;strong&gt;Filters and scaling&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt; , &lt;code&gt;et_viewer&lt;/code&gt; en la aplicaci&amp;oacute;n ET se utiliza para presentar el registro de seguimiento de forma gr&amp;aacute;fica. &lt;code&gt;ttb&lt;/code&gt; proporciona algunos filtros diferentes que se pueden seleccionar en el men&amp;uacute; &lt;strong&gt;Filtros y escalado&lt;/strong&gt; en &lt;code&gt;et_viewer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="754c4ebe3c963dad574555e13a437f625208b390" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; is called for each trace message.</source>
          <target state="translated">Si &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt; , se llama a la &lt;code&gt;Function&lt;/code&gt; para cada mensaje de seguimiento.</target>
        </trans-unit>
        <trans-unit id="e464e53752a8478fcd48d7d7806a6c052a202fab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler&lt;/code&gt; is not specified, a default handler is used presenting each trace message as a text line.</source>
          <target state="translated">Si no se especifica &lt;code&gt;FormatHandler&lt;/code&gt; , se utiliza un controlador predeterminado que presenta cada mensaje de seguimiento como una l&amp;iacute;nea de texto.</target>
        </trans-unit>
        <trans-unit id="52add321b909cb81e422136ee5da910496779dbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Forms&lt;/code&gt; is a syntax tree of some other type than &lt;code&gt;form_list&lt;/code&gt;, the comments will be inserted directly using &lt;code&gt;recomment_tree/2&lt;/code&gt;, and any comments left over from that process are added as postcomments on the result.</source>
          <target state="translated">Si &lt;code&gt;Forms&lt;/code&gt; es un &amp;aacute;rbol de sintaxis de alg&amp;uacute;n otro tipo que &lt;code&gt;form_list&lt;/code&gt; sea form_list , los comentarios se insertar&amp;aacute;n directamente usando &lt;code&gt;recomment_tree/2&lt;/code&gt; , y cualquier comentario que quede de ese proceso se agregar&amp;aacute; como comentarios posteriores al resultado.</target>
        </trans-unit>
        <trans-unit id="c4eba9b5275105788875dd801e1636ad9a4cb30f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun(Item)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is copied to the result queue. If it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is not copied. If it returns a list, the list elements are inserted instead of &lt;code&gt;Item&lt;/code&gt; in the result queue.</source>
          <target state="translated">Si &lt;code&gt;Fun(Item)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , el &lt;code&gt;Item&lt;/code&gt; se copia a la cola de resultados. Si devuelve &lt;code&gt;false&lt;/code&gt; , el &lt;code&gt;Item&lt;/code&gt; no se copia. Si devuelve una lista, los elementos de la lista se insertan en lugar del &lt;code&gt;Item&lt;/code&gt; en la cola de resultados.</target>
        </trans-unit>
        <trans-unit id="366fc356581d7fe3b943ae954f2a4d6cf716ab8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Module&lt;/code&gt; is the module in which the fun is defined.</source>
          <target state="translated">Si la &lt;code&gt;Fun&lt;/code&gt; es una diversi&amp;oacute;n local, el &lt;code&gt;Module&lt;/code&gt; es el m&amp;oacute;dulo en el que se define la diversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1842cf53be67683035afaacc37fa7bea8be6bb1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Name&lt;/code&gt; is the name of the local function that implements the fun. (This name was generated by the compiler, and is only of informational use. As it is a local function, it cannot be called directly.) If no code is currently loaded for the fun, &lt;code&gt;[]&lt;/code&gt; is returned instead of an atom.</source>
          <target state="translated">Si &lt;code&gt;Fun&lt;/code&gt; es una diversi&amp;oacute;n local, &lt;code&gt;Name&lt;/code&gt; es el nombre de la funci&amp;oacute;n local que implementa la diversi&amp;oacute;n. (Este nombre fue generado por el compilador y es solo para uso informativo. Como es una funci&amp;oacute;n local, no se puede llamar directamente). Si no hay ning&amp;uacute;n c&amp;oacute;digo cargado actualmente para la diversi&amp;oacute;n, se devuelve &lt;code&gt;[]&lt;/code&gt; en lugar de un &amp;aacute;tomo.</target>
        </trans-unit>
        <trans-unit id="5f28f2ecd1a2a78b09a1a1bba86bfe7cd1e5abac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Module&lt;/code&gt; is the module that the fun refers to.</source>
          <target state="translated">Si la &lt;code&gt;Fun&lt;/code&gt; es una diversi&amp;oacute;n externa, el &lt;code&gt;Module&lt;/code&gt; es el m&amp;oacute;dulo al que se refiere la diversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7a891fa1f8c1fc67f4bfac48d75e87475a7bea29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Name&lt;/code&gt; is the name of the exported function that the fun refers to.</source>
          <target state="translated">Si &lt;code&gt;Fun&lt;/code&gt; es una diversi&amp;oacute;n externa, &lt;code&gt;Name&lt;/code&gt; es el nombre de la funci&amp;oacute;n exportada a la que se refiere la diversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c30588de4c7f0612e073a3883c335ac9373ebde3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Function&lt;/code&gt; inserts objects into the table, or another process inserts objects into the table, those objects &lt;strong&gt;can&lt;/strong&gt; (depending on key ordering) be included in the traversal.</source>
          <target state="translated">Si &lt;code&gt;Function&lt;/code&gt; inserta objetos en la tabla, u otro proceso inserta objetos en la tabla, esos objetos &lt;strong&gt;pueden&lt;/strong&gt; (seg&amp;uacute;n el orden de las teclas) incluirse en el recorrido.</target>
        </trans-unit>
        <trans-unit id="8903d3c31d338fd3102b10a98c169c7def053e70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;HandlerId&lt;/code&gt; is &lt;code&gt;default&lt;/code&gt;, then this entry modifies the default handler, equivalent to calling</source>
          <target state="translated">Si &lt;code&gt;HandlerId&lt;/code&gt; es el &lt;code&gt;default&lt;/code&gt; , esta entrada modifica el controlador predeterminado, equivalente a llamar</target>
        </trans-unit>
        <trans-unit id="900d11629569ab220c3331823293a0c6bc8ed798" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How == read&lt;/code&gt; or there is no outgoing data buffered in the &lt;code&gt;Socket&lt;/code&gt; port, the socket is shut down immediately and any error encountered is returned in &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;How == read&lt;/code&gt; o no hay datos salientes almacenados en b&amp;uacute;fer en el puerto de &lt;code&gt;Socket&lt;/code&gt; , el socket se apaga inmediatamente y cualquier error encontrado se devuelve en &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c71e7f1f85187ddc4b81962dde74a95d9e96b0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How&lt;/code&gt; is not one of the documented alternatives.</source>
          <target state="translated">Si &lt;code&gt;How&lt;/code&gt; no es una de las alternativas documentadas.</target>
        </trans-unit>
        <trans-unit id="37742d0df7de57a88343a93bbae5c582e200b4bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I&lt;/code&gt; is not a non-negative integer, or if the array has fixed size and &lt;code&gt;I&lt;/code&gt; is larger than the maximum index, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;; compare &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;I&lt;/code&gt; no es un n&amp;uacute;mero entero no negativo, o si la matriz tiene un tama&amp;ntilde;o fijo y &lt;code&gt;I&lt;/code&gt; es mayor que el &amp;iacute;ndice m&amp;aacute;ximo, la llamada falla con el motivo &lt;code&gt;badarg&lt;/code&gt; ; comparar &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff9833c3a956d76bfddbabd05552d4c92a4ea96e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="translated">Si &lt;code&gt;IgnoreCase&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; la funci&amp;oacute;n realiza el &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; de casos sobre la marcha antes de la prueba de igualdad.</target>
        </trans-unit>
        <trans-unit id="816e7270d9b2f0ac993fa2ef79b1a16b6e25ce74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, an error occurs whenever an integer &amp;gt; 255 is found in the lists.</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es &lt;code&gt;latin1&lt;/code&gt; , un error se produce siempre un n&amp;uacute;mero entero&amp;gt; 255 se encuentra en las listas.</target>
        </trans-unit>
        <trans-unit id="4425120ccc2526ec06a49a423343d05e8207c756" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO Latin-1 range.</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es &lt;code&gt;latin1&lt;/code&gt; , binarios son siempre v&amp;aacute;lidos, siempre que contienen bytes completos, ya que cada byte cae en el rango v&amp;aacute;lido ISO Latin-1.</target>
        </trans-unit>
        <trans-unit id="ff1d0ed37f6966c578d637dcaf03e020ca40d09f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; corresponds to the &lt;code&gt;iodata()&lt;/code&gt; type, but for &lt;code&gt;unicode&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; can contain integers &amp;gt; 255 (Unicode characters beyond the ISO Latin-1 range), which makes it invalid as &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es &lt;code&gt;latin1&lt;/code&gt; , par&amp;aacute;metros &lt;code&gt;Data&lt;/code&gt; corresponde a la &lt;code&gt;iodata()&lt;/code&gt; tipo, pero para &lt;code&gt;unicode&lt;/code&gt; , el par&amp;aacute;metro &lt;code&gt;Data&lt;/code&gt; puede contener enteros&amp;gt; 255 (caracteres Unicode m&amp;aacute;s all&amp;aacute; de la gama ISO Latin-1), lo que lo hace inv&amp;aacute;lido como &lt;code&gt;iodata()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84c8391d802fddc5ccbafb2a99174fde559e23a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is of a Unicode type, an error occurs whenever either of the following is found:</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es de tipo Unicode, se produce un error siempre que se encuentra alguno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="476e00e23216a072f0d4f2055cfb67b48c128bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is one of the UTF types, the bytes in any binaries must be valid in that encoding.</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es uno de los tipos UTF, los bytes de los binarios deben ser v&amp;aacute;lidos en esa codificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="22f3829c6bb886763ec35ffd0a67a42f39f5713e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Incr =:= 0&lt;/code&gt; and &lt;code&gt;From =/= To&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Incr =:= 0&lt;/code&gt; y &lt;code&gt;From =/= To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12b35d113bc1f0b8b177b00f244bbbf3e4ac06f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IpPort&lt;/code&gt; is omitted &lt;code&gt;162&lt;/code&gt; is used.</source>
          <target state="translated">Si se omite &lt;code&gt;IpPort&lt;/code&gt; , se utiliza &lt;code&gt;162&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57bfc33f769c9b0a788a08b107a1cedbd213bce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IsDst == true&lt;/code&gt;, &lt;code&gt;Localtime&lt;/code&gt; is during Daylight Saving Time, if &lt;code&gt;IsDst == false&lt;/code&gt; it is not. If &lt;code&gt;IsDst == undefined&lt;/code&gt;, the underlying OS can guess, which is the same as calling &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;IsDst == true&lt;/code&gt; , &lt;code&gt;Localtime&lt;/code&gt; es durante el horario de verano, si &lt;code&gt;IsDst == false&lt;/code&gt; no lo es. Si &lt;code&gt;IsDst == undefined&lt;/code&gt; , el sistema operativo subyacente puede adivinar, que es lo mismo que llamar a &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d88ab1af3b32ccae8c47bc290fd76139417148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Item&lt;/code&gt; is an invalid item.</source>
          <target state="translated">Si el &lt;code&gt;Item&lt;/code&gt; es un art&amp;iacute;culo no v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="0ff6e5e0312fb6570b28f21e065635f71bd160e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ItemList&lt;/code&gt; is specified, the result is &lt;code&gt;InfoTupleList&lt;/code&gt;. The &lt;code&gt;InfoTuple&lt;/code&gt;s in &lt;code&gt;InfoTupleList&lt;/code&gt; are included with the corresponding &lt;code&gt;Item&lt;/code&gt;s in the same order as the &lt;code&gt;Item&lt;/code&gt;s were included in &lt;code&gt;ItemList&lt;/code&gt;. Valid &lt;code&gt;Item&lt;/code&gt;s can be included multiple times in &lt;code&gt;ItemList&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ItemList&lt;/code&gt; se especifica, el resultado es &lt;code&gt;InfoTupleList&lt;/code&gt; . El &lt;code&gt;InfoTuple&lt;/code&gt; s en &lt;code&gt;InfoTupleList&lt;/code&gt; est&amp;aacute;n incluidos con el correspondiente &lt;code&gt;Item&lt;/code&gt; s en el mismo orden que el &lt;code&gt;Item&lt;/code&gt; s fueron incluidos en &lt;code&gt;ItemList&lt;/code&gt; . Los &lt;code&gt;Item&lt;/code&gt; v&amp;aacute;lidos se pueden incluir varias veces en &lt;code&gt;ItemList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af422b91ec82e2dd9338132983b67650395edbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; do not exists, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="translated">Si la &lt;code&gt;Key&lt;/code&gt; no existe, se crea un nuevo registro con el valor &lt;code&gt;Incr&lt;/code&gt; si es mayor que 0; de lo contrario, se establece en 0.</target>
        </trans-unit>
        <trans-unit id="6283720a87b385d954928cf8467ee97a261a260e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; exists in &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new associated value.</source>
          <target state="translated">Si la &lt;code&gt;Key&lt;/code&gt; existe en &lt;code&gt;Map1&lt;/code&gt; , el antiguo valor asociado se reemplaza por el valor &lt;code&gt;Value&lt;/code&gt; . La funci&amp;oacute;n devuelve un nuevo mapa &lt;code&gt;Map2&lt;/code&gt; que contiene el nuevo valor asociado.</target>
        </trans-unit>
        <trans-unit id="1dc230226eb63b450b632e9c874a80bd2fe8c24b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;KeyOrName&lt;/code&gt; is a configured &lt;code&gt;server_id()&lt;/code&gt; or a &lt;code&gt;target_name()&lt;/code&gt; associated with such an Id, then the options for this server are fetched from the configuration file.</source>
          <target state="translated">Si &lt;code&gt;KeyOrName&lt;/code&gt; es un &lt;code&gt;server_id()&lt;/code&gt; configurado o un &lt;code&gt;target_name()&lt;/code&gt; asociado con dicho Id, las opciones para este servidor se obtienen del archivo de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="caeb4bb064b11f2b7bb8eeb778050c5ea54186c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LinkTo&lt;/code&gt; is a pid, it becomes an owner of the log. If &lt;code&gt;LinkTo&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, the log records that it is used anonymously by some process by incrementing the &lt;code&gt;users&lt;/code&gt; counter. By default, the process that calls &lt;code&gt;open/1&lt;/code&gt; owns the log.</source>
          <target state="translated">Si &lt;code&gt;LinkTo&lt;/code&gt; es un pid, se convierte en propietario del registro. Si &lt;code&gt;LinkTo&lt;/code&gt; es &lt;code&gt;none&lt;/code&gt; , el registro registra que alg&amp;uacute;n proceso lo usa de forma an&amp;oacute;nima aumentando el contador de &lt;code&gt;users&lt;/code&gt; . De forma predeterminada, el proceso que llama a &lt;code&gt;open/1&lt;/code&gt; es el propietario del registro.</target>
        </trans-unit>
        <trans-unit id="9888882ab2a6e6b491af7cf81626c46b51b8c093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ListOfBinRels&lt;/code&gt; is a non-empty list [R[1], ..., R[n]] of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ListOfBinRels&lt;/code&gt; es una lista no vac&amp;iacute;a [R [1], ..., R [n]] de relaciones binarias y &lt;code&gt;BinRel1&lt;/code&gt; es una relaci&amp;oacute;n binaria, entonces &lt;code&gt;BinRel2&lt;/code&gt; es el &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; del conjunto ordenado (R [i] ,. .., R [n]) y &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6668fcef53284c1666f849594130ecb9a9e9189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Loader&lt;/code&gt; is something else, the user-supplied &lt;code&gt;Loader&lt;/code&gt; port program is started.</source>
          <target state="translated">Si &lt;code&gt;Loader&lt;/code&gt; es otra cosa, se inicia el programa de puerto &lt;code&gt;Loader&lt;/code&gt; proporcionado por el usuario .</target>
        </trans-unit>
        <trans-unit id="4902233d819e3e7d17b192cdb14eea6c3a8ffc0d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a binary, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es un binario, &lt;code&gt;tftp_binary&lt;/code&gt; se usa como m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada. El binario se transfiere bloque por bloque y el n&amp;uacute;mero de bytes transferidos se devuelve en &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="514092af0b1076e970f978d5d6c41dea98a0f33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It reads the file named &lt;code&gt;LocalFilename&lt;/code&gt; block by block and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es una cadena y no hay m&amp;oacute;dulos de devoluci&amp;oacute;n de llamada registrados, &lt;code&gt;tftp_file&lt;/code&gt; se utiliza como m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada. Lee el archivo llamado &lt;code&gt;LocalFilename&lt;/code&gt; bloque por bloque y devuelve el n&amp;uacute;mero de bytes transferidos en &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172a77adcec95a2025499b6cae24513646d7c3be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It writes each transferred block to the file named &lt;code&gt;LocalFilename&lt;/code&gt; and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es una cadena y no hay m&amp;oacute;dulos de devoluci&amp;oacute;n de llamada registrados, &lt;code&gt;tftp_file&lt;/code&gt; se utiliza como m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada. Escribe cada bloque transferido en el archivo llamado &lt;code&gt;LocalFilename&lt;/code&gt; y devuelve el n&amp;uacute;mero de bytes transferidos en &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd17776ebe8291ef5b56762e6914f21f0e371fb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are registered callback modules, &lt;code&gt;LocalFilename&lt;/code&gt; is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es una cadena y hay m&amp;oacute;dulos de devoluci&amp;oacute;n de llamada registrados, &lt;code&gt;LocalFilename&lt;/code&gt; se prueba con las expresiones regulares de estos y se usa el m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada correspondiente a la primera coincidencia, o se devuelve una tupla de error si no se encuentra una expresi&amp;oacute;n regular coincidente.</target>
        </trans-unit>
        <trans-unit id="e10f4bb7329e24a46f5a2fd1d389f1d3eaa1ef41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is the atom &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. It concatenates all transferred blocks and returns them as one single binary in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es el &lt;code&gt;binary&lt;/code&gt; del &amp;aacute;tomo , &lt;code&gt;tftp_binary&lt;/code&gt; se usa como m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada. Concatena todos los bloques transferidos y los devuelve como un solo binario en &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f45f2e11d4c10074cfecd5aefc75c9eeb1e623" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; is not of type map, an exception of type &lt;code&gt;badmap&lt;/code&gt; is thrown.</source>
          <target state="translated">Si &lt;code&gt;M&lt;/code&gt; no es de tipo map, se lanza una excepci&amp;oacute;n de tipo &lt;code&gt;badmap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687a37c16da4f8deeaf271a8bf79963858a6f256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; in a key exchange, it will fail with a disconnect.</source>
          <target state="translated">Si &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; en un intercambio de claves, fallar&amp;aacute; con una desconexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fec574cad80dd815a39ff074fa450bce09ec6bf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Minutes&lt;/code&gt; is set to &lt;code&gt;infinity&lt;/code&gt;, no rekeying will ever occur due to that max time has passed. Setting &lt;code&gt;Bytes&lt;/code&gt; to &lt;code&gt;infinity&lt;/code&gt; will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to &lt;code&gt;{infinity, infinity}&lt;/code&gt;, no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.</source>
          <target state="translated">Si &lt;code&gt;Minutes&lt;/code&gt; se establece en &lt;code&gt;infinity&lt;/code&gt; , no se volver&amp;aacute; a introducir nunca debido a que ha transcurrido el tiempo m&amp;aacute;ximo. Establecer &lt;code&gt;Bytes&lt;/code&gt; en &lt;code&gt;infinity&lt;/code&gt; inhibir&amp;aacute; la repetici&amp;oacute;n de claves despu&amp;eacute;s de que se haya transferido una cierta cantidad de datos. Si el valor de la opci&amp;oacute;n se establece en &lt;code&gt;{infinity, infinity}&lt;/code&gt; , no se iniciar&amp;aacute; ninguna modificaci&amp;oacute;n. Tenga en cuenta que se seguir&amp;aacute; realizando el cambio de claves iniciado por el par.</target>
        </trans-unit>
        <trans-unit id="a9f8b097c0197afbf6ad454085a81f83c68dd174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects an inconsistent transaction decision, an &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; system event is generated to give the application a chance to install a fallback or other appropriate measures to resolve the inconsistency. The default behavior of the &lt;code&gt;Mnesia&lt;/code&gt; event handler is the same as if the database became inconsistent as a result of partitioned network (as described earlier).</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; detecta una decisi&amp;oacute;n de transacci&amp;oacute;n &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; se genera un evento del sistema {inconsistent_database, bad_decision, Node} para darle a la aplicaci&amp;oacute;n la oportunidad de instalar un respaldo u otras medidas apropiadas para resolver la inconsistencia. El comportamiento predeterminado del controlador de eventos de &lt;code&gt;Mnesia&lt;/code&gt; es el mismo que si la base de datos se volviera inconsistente como resultado de una red particionada (como se describi&amp;oacute; anteriormente).</target>
        </trans-unit>
        <trans-unit id="5ca626a4154bdde85262a0b351b9ffb8e56064dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects at startup that both the local node and another node received &lt;code&gt;mnesia_down&lt;/code&gt; from each other, &lt;code&gt;Mnesia&lt;/code&gt; generates an &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; system event and acts as described in the previous item.</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; detecta al inicio que tanto el nodo local como otro nodo recibieron &lt;code&gt;mnesia_down&lt;/code&gt; entre s&amp;iacute;, &lt;code&gt;Mnesia&lt;/code&gt; genera un evento de sistema &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; starts_partitioned_network , Node} y act&amp;uacute;a como se describe en el elemento anterior.</target>
        </trans-unit>
        <trans-unit id="8a5aa5b6bb0338ccad2dd9a24afe157f5c87240b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects that a file has not been properly closed, possibly as a result of a power failure, it tries to repair the bad file in a similar manner. Data can be lost, but &lt;code&gt;Mnesia&lt;/code&gt; can be restarted even if the data is inconsistent. Configuration parameter &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; can be used to control the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; tries to repair the file. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; does not restart if it detects a suspect file. This configuration parameter affects the repair behavior of log files, &lt;code&gt;DAT&lt;/code&gt; files, and the default backup media.</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; detecta que un archivo no se ha cerrado correctamente, posiblemente como resultado de un corte de energ&amp;iacute;a, intenta reparar el archivo defectuoso de manera similar. Los datos se pueden perder, pero &lt;code&gt;Mnesia&lt;/code&gt; se puede reiniciar incluso si los datos son inconsistentes. El par&amp;aacute;metro de configuraci&amp;oacute;n &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; se puede utilizar para controlar el comportamiento de &lt;code&gt;Mnesia&lt;/code&gt; al inicio. Si &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; tiene el valor &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; intenta reparar el archivo. Si &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; tiene el valor &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; no se reinicia si detecta un archivo sospechoso. Este par&amp;aacute;metro de configuraci&amp;oacute;n afecta el comportamiento de reparaci&amp;oacute;n de los archivos de registro, &lt;code&gt;DAT&lt;/code&gt; archivos y el medio de copia de seguridad predeterminado.</target>
        </trans-unit>
        <trans-unit id="29d3fae27e18aeedb269f53e1a8f041e114e54d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; has not started on some of the nodes that are involved in the transaction &lt;strong&gt;and&lt;/strong&gt; neither the local node nor any of the already running nodes know the outcome of the transaction, &lt;code&gt;Mnesia&lt;/code&gt; waits for one, by default. In the worst case scenario, all other involved nodes must start before &lt;code&gt;Mnesia&lt;/code&gt; can make the correct decision about the transaction and finish its startup.</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; no se ha iniciado en algunos de los nodos que est&amp;aacute;n involucrados en la transacci&amp;oacute;n &lt;strong&gt;y&lt;/strong&gt; ni el nodo local ni ninguno de los nodos que ya est&amp;aacute;n en ejecuci&amp;oacute;n conocen el resultado de la transacci&amp;oacute;n, &lt;code&gt;Mnesia&lt;/code&gt; espera uno, de forma predeterminada. En el peor de los casos, todos los dem&amp;aacute;s nodos involucrados deben comenzar antes de que &lt;code&gt;Mnesia&lt;/code&gt; pueda tomar la decisi&amp;oacute;n correcta sobre la transacci&amp;oacute;n y finalizar su inicio.</target>
        </trans-unit>
        <trans-unit id="dd38ec2de0e096904bd79c96261fe3dfca545808" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; malfunctions, system information is dumped to file &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt;. The type of system information contained in this file can also be generated with the function &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt;. If a &lt;code&gt;Mnesia&lt;/code&gt; system behaves strangely, it is recommended that a &lt;code&gt;Mnesia&lt;/code&gt; core dump file is included in the bug report.</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; no funciona correctamente, la informaci&amp;oacute;n del sistema se descarga al archivo &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt; . El tipo de informaci&amp;oacute;n del sistema contenida en este archivo tambi&amp;eacute;n se puede generar con la funci&amp;oacute;n &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt; . Si un sistema &lt;code&gt;Mnesia&lt;/code&gt; se comporta de manera extra&amp;ntilde;a, se recomienda que se &lt;code&gt;Mnesia&lt;/code&gt; un archivo de volcado del n&amp;uacute;cleo de Mnesia en el informe de error.</target>
        </trans-unit>
        <trans-unit id="78d126042be1f1bd5d152bedd102bc2c27a70a3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module2:init/1&lt;/code&gt; returns a correct value, this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module2:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">Si &lt;code&gt;Module2:init/1&lt;/code&gt; devuelve un valor correcto, esta funci&amp;oacute;n devuelve &lt;code&gt;ok&lt;/code&gt; . Si &lt;code&gt;Module2:init/1&lt;/code&gt; falla con &lt;code&gt;Reason&lt;/code&gt; o devuelve un valor inesperado &lt;code&gt;Term&lt;/code&gt; , esta funci&amp;oacute;n devuelve &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; o &lt;code&gt;{error,Term}&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="2800f17b5a7a3294a30bce9d692cce033e777bbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an error tuple or an incorrect value, this function returns &lt;code&gt;{error,Errorr}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term with information about the error, and the supervisor bridge terminates with reason &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; falla o devuelve una tupla de error o un valor incorrecto, esta funci&amp;oacute;n devuelve &lt;code&gt;{error,Errorr}&lt;/code&gt; , donde &lt;code&gt;Error&lt;/code&gt; es un t&amp;eacute;rmino con informaci&amp;oacute;n sobre el error, y el puente supervisor termina con el motivo &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd9e3be966d4953b313f0b3139d9921bb88d0b55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an incorrect value, this function returns &lt;code&gt;{error,Term}&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;Term&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; falla o devuelve un valor incorrecto, esta funci&amp;oacute;n devuelve &lt;code&gt;{error,Term}&lt;/code&gt; , donde &lt;code&gt;Term&lt;/code&gt; es un t&amp;eacute;rmino con informaci&amp;oacute;n sobre el error, y el supervisor termina con el motivo &lt;code&gt;Term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06a79b06d12276baeba24803b1a67f3a90f7af4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;{stop,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, the process is terminated and the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; falla con &lt;code&gt;Reason&lt;/code&gt; , la funci&amp;oacute;n devuelve &lt;code&gt;{error,Reason}&lt;/code&gt; . Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve &lt;code&gt;{stop,Reason}&lt;/code&gt; o &lt;code&gt;ignore&lt;/code&gt; , el proceso finaliza y la funci&amp;oacute;n devuelve &lt;code&gt;{error,Reason}&lt;/code&gt; o &lt;code&gt;ignore&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="08a85009b7d63daa3876ac0bbe64563be6e4667a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; falla con &lt;code&gt;Reason&lt;/code&gt; , esta funci&amp;oacute;n devuelve &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; . Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; , el proceso finaliza y esta funci&amp;oacute;n devuelve &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="b964744cac9c86474eba0929df72fddd8367b88f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well and the supervisor bridge terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve &lt;code&gt;ignore&lt;/code&gt; , esta funci&amp;oacute;n tambi&amp;eacute;n devuelve &lt;code&gt;ignore&lt;/code&gt; y el puente supervisor termina con una raz&amp;oacute;n &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2bd739756c272b047be065f7e266ff83f96304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well, and the supervisor terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve &lt;code&gt;ignore&lt;/code&gt; , esta funci&amp;oacute;n tambi&amp;eacute;n devuelve &lt;code&gt;ignore&lt;/code&gt; y el supervisor finaliza con una raz&amp;oacute;n &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a0e47ea971ab5cb4ee104b3ddf1785be6b28da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns a correct value indicating successful completion, the event manager adds the event handler and this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the event handler is ignored and this function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;, respectively.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve un valor correcto que indica una finalizaci&amp;oacute;n exitosa, el administrador de eventos agrega el controlador de eventos y esta funci&amp;oacute;n devuelve &lt;code&gt;ok&lt;/code&gt; . Si &lt;code&gt;Module:init/1&lt;/code&gt; falla con &lt;code&gt;Reason&lt;/code&gt; o devuelve &lt;code&gt;{error,Reason}&lt;/code&gt; , el controlador de eventos se ignora y esta funci&amp;oacute;n devuelve &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; o &lt;code&gt;{error,Reason}&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="09a967e619be6af84ec5d9fcc2d540f2231d235c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si no se exporta el &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; , common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="dd0d2fb7d1f38864cd0e105f7caff1a473b3f495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si no se exporta el &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; , common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="6e0f9d357b53cd19411dbd2755262448109533a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="c30a59478d9813033d5db1ba6eb7b720e1f8a281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="8b31af596bd3564305ac89780dcd5037ca72eed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si el &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="3389cc7f2c4854aa000a5dc7cbbbd118b6386a3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si no se exporta &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; , common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="fa0c6abab53f3a1832ad70236445abe23313c949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="4220e81587ad22a96ae86a7cc023800c3211a2ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="827b0497b91b5175e901d63a74e9ca29d1d28466" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si no se exporta &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; , common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="547d2d680c102fd734e63aee60c0764a91aca79d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si el &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="21fb0625232bdf7d33e9683b493cf013dd5244be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is an atom and is not the path of a source file, then the code path is searched to locate the object file for the module and extract its original compiler options and source path. If the source file is not found in the original location, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; is used to search for it relative to the directory of the object file.</source>
          <target state="translated">Si &lt;code&gt;Module&lt;/code&gt; es un &amp;aacute;tomo y no es la ruta de un archivo fuente, entonces se busca la ruta del c&amp;oacute;digo para ubicar el archivo objeto del m&amp;oacute;dulo y extraer sus opciones del compilador original y ruta fuente. Si el archivo de origen no se encuentra en la ubicaci&amp;oacute;n original, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; se utiliza para buscarlo en relaci&amp;oacute;n con el directorio del archivo de objeto.</target>
        </trans-unit>
        <trans-unit id="2f35893e15d66156fbf46d4e4af24041aed07f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is interpreted, the interpreter is invoked and the return value of the interpreted &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; call is returned.</source>
          <target state="translated">Si se interpreta &lt;code&gt;Module&lt;/code&gt; , se invoca al int&amp;eacute;rprete y se devuelve el valor de retorno de la &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67c2474f76236eb774fc89b2d1d56a6f0f7c3f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded and the object file exists and contains the same code.</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; est&amp;aacute; cargado y el archivo de objeto existe y contiene el mismo c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="8e3e08e194bdd0bde8a181db6a7f4ea876ef7dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but does not have native code</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; est&amp;aacute; cargado pero no tiene c&amp;oacute;digo nativo</target>
        </trans-unit>
        <trans-unit id="6ed685bf101eabc82b65e519e9da522892714f39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but no corresponding object file can be found in the code path.</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; est&amp;aacute; cargado pero no se puede encontrar el archivo de objeto correspondiente en la ruta del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="a3d8ad064c879fd2b635248fe4428064d2c2287b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but the object file contains code with a different MD5 checksum.</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; est&amp;aacute; cargado pero el archivo de objeto contiene c&amp;oacute;digo con una suma de comprobaci&amp;oacute;n MD5 diferente.</target>
        </trans-unit>
        <trans-unit id="0d66cbf854873559817431ac8657e00f31894e65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not Cover compiled, the function returns &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module&lt;/code&gt; no est&amp;aacute; compilado Cover, la funci&amp;oacute;n devuelve &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35affc64e4462796f41658b1b89a47205a5418f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not an atom.</source>
          <target state="translated">Si &lt;code&gt;Module&lt;/code&gt; no es un &amp;aacute;tomo.</target>
        </trans-unit>
        <trans-unit id="28eaadbc7b4906a161654ae8a696f70005c80dff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not currently loaded.</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; no est&amp;aacute; cargado actualmente.</target>
        </trans-unit>
        <trans-unit id="2f4aff325466dff627c5e688d76bc4df8a1246e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not given, data for all Cover compiled or earlier imported modules is exported.</source>
          <target state="translated">Si no se proporciona &lt;code&gt;Module&lt;/code&gt; , se exportan los datos de todos los m&amp;oacute;dulos Cover compilados o importados anteriormente.</target>
        </trans-unit>
        <trans-unit id="4388daad92dd73ddcb6294d3f0538fdaca71514b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not loaded</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; no est&amp;aacute; cargado</target>
        </trans-unit>
        <trans-unit id="3de1d5c36e26d7596ce7561b07882f4daa22a030" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is the name of a loaded module that has native code loaded</source>
          <target state="translated">Si &lt;code&gt;Module&lt;/code&gt; es el nombre de un m&amp;oacute;dulo cargado que tiene cargado c&amp;oacute;digo nativo</target>
        </trans-unit>
        <trans-unit id="dc068e6c6fb49a84acb5b9f82ce4f1b82380c161" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;Answer&lt;/code&gt;, else the return will be a list, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Modules&lt;/code&gt; es un &amp;aacute;tomo (un m&amp;oacute;dulo), la devoluci&amp;oacute;n ser&amp;aacute; &lt;code&gt;Answer&lt;/code&gt; , de lo contrario, la devoluci&amp;oacute;n ser&amp;aacute; una lista, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2129780e47085f58784cab38168e42cd913f8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;OneResult&lt;/code&gt;, else the return will be &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Modules&lt;/code&gt; es un &amp;aacute;tomo (un m&amp;oacute;dulo), la devoluci&amp;oacute;n ser&amp;aacute; &lt;code&gt;OneResult&lt;/code&gt; , de lo contrario, la devoluci&amp;oacute;n ser&amp;aacute; &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c5660afecaaa6ae9b7c2e1dd31118d79f4a48c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is not given, all modules that have data in the cover data table, are analysed. Note that this includes both cover compiled modules and imported modules.</source>
          <target state="translated">Si &lt;code&gt;Modules&lt;/code&gt; no se da, todos los m&amp;oacute;dulos que tienen datos en la tabla de datos de presentaci&amp;oacute;n, se analizan. Tenga en cuenta que esto incluye tanto los m&amp;oacute;dulos compilados de la cubierta como los m&amp;oacute;dulos importados.</target>
        </trans-unit>
        <trans-unit id="8a375b70a231e530df5647867765137b186f5486" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules=dynamic&lt;/code&gt;, which is the case for event managers, the event manager process informs the release handler about the list of currently installed event handlers (&lt;code&gt;gen_event&lt;/code&gt;), and it is checked if the module name is in this list instead.</source>
          <target state="translated">Si &lt;code&gt;Modules=dynamic&lt;/code&gt; , que es el caso de los administradores de eventos, el proceso del administrador de eventos informa al administrador de versiones sobre la lista de controladores de eventos instalados actualmente ( &lt;code&gt;gen_event&lt;/code&gt; ), y se verifica si el nombre del m&amp;oacute;dulo est&amp;aacute; en esta lista.</target>
        </trans-unit>
        <trans-unit id="e8cecedc28fd848e48458244703056a1ac1a339f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; does not exist.</source>
          <target state="translated">Si &lt;code&gt;MonitorPid&lt;/code&gt; no existe.</target>
        </trans-unit>
        <trans-unit id="373a002dc9620bdf865a5b5e6f260b3dd1f5301f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; is not a local process.</source>
          <target state="translated">Si &lt;code&gt;MonitorPid&lt;/code&gt; no es un proceso local.</target>
        </trans-unit>
        <trans-unit id="89660705a87398108d22c38f81698b872c41d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorRef&lt;/code&gt; is a reference that the calling process obtained by calling &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">Si &lt;code&gt;MonitorRef&lt;/code&gt; es una referencia que el proceso de llamada obtuvo llamando a &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; , esta monitorizaci&amp;oacute;n est&amp;aacute; desactivada. Si la monitorizaci&amp;oacute;n ya est&amp;aacute; desactivada, no pasa nada.</target>
        </trans-unit>
        <trans-unit id="4fd962484b4478493735ba1be0d09ca7b30e44ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt; , se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="790d7222607fd455375f3a15db7f9612e76c7d20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; = 0, call saving is disabled for the process, which is the default. Whenever the size of the call saving list is set, its contents are reset.</source>
          <target state="translated">Si &lt;code&gt;N&lt;/code&gt; = 0, el guardado de llamadas est&amp;aacute; deshabilitado para el proceso, que es el valor predeterminado. Siempre que se establece el tama&amp;ntilde;o de la lista de guardado de llamadas, se restablece su contenido.</target>
        </trans-unit>
        <trans-unit id="917defb768e26d53c01d843240d1452bda349978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; (an alias name for &lt;code&gt;Key&lt;/code&gt;) is used to identify the connection, this name can be used as connection reference for subsequent calls. Only one open connection at a time associated with &lt;code&gt;Name&lt;/code&gt; is possible. If &lt;code&gt;Key&lt;/code&gt; is used, the returned handle must be used for subsequent calls (multiple connections can be opened using the configuration data specified by &lt;code&gt;Key&lt;/code&gt;).</source>
          <target state="translated">Si se usa &lt;code&gt;Name&lt;/code&gt; (un nombre de alias para la &lt;code&gt;Key&lt;/code&gt; ) para identificar la conexi&amp;oacute;n, este nombre se puede usar como referencia de conexi&amp;oacute;n para llamadas posteriores. Solo es posible una conexi&amp;oacute;n abierta a la vez asociada con el &lt;code&gt;Name&lt;/code&gt; . Si se usa &lt;code&gt;Key&lt;/code&gt; , el identificador devuelto debe usarse para llamadas posteriores (se pueden abrir m&amp;uacute;ltiples conexiones usando los datos de configuraci&amp;oacute;n especificados por &lt;code&gt;Key&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="656dd80cf80ca49ab5d3f335d4b4b338f312a58e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, the code from that module will occur at the top of the resulting code, and no extra &quot;header&quot; comments will be added. In other words, the look of that module will be preserved.</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; es tambi&amp;eacute;n el nombre de uno de los m&amp;oacute;dulos de entrada, el c&amp;oacute;digo de ese m&amp;oacute;dulo aparecer&amp;aacute; en la parte superior del c&amp;oacute;digo resultante y no se agregar&amp;aacute;n comentarios de &quot;encabezado&quot; adicionales. En otras palabras, se conservar&amp;aacute; el aspecto de ese m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="ce802579fca60cdc1ea685ad322c443678165ff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is an &lt;code&gt;ip_address()&lt;/code&gt;, the domain name to query for is generated as the standard reverse &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; name for an IPv4 address, or the &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; name for an IPv6 address. In this case, you most probably want to use &lt;code&gt;Class = in&lt;/code&gt; and &lt;code&gt;Type = ptr&lt;/code&gt;, but it is not done automatically.</source>
          <target state="translated">Si el &lt;code&gt;Name&lt;/code&gt; es una &lt;code&gt;ip_address()&lt;/code&gt; , el nombre de dominio para consultar se genera como el reverso est&amp;aacute;ndar &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; nombre para una direcci&amp;oacute;n IPv4, o el &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; nombre para una direcci&amp;oacute;n IPv6. En este caso, lo m&amp;aacute;s probable es que desee utilizar &lt;code&gt;Class = in&lt;/code&gt; y &lt;code&gt;Type = ptr&lt;/code&gt; , pero no se hace autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="a8688d593066763d843262dfe2006d94c1dcdd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, message &lt;code&gt;Msg&lt;/code&gt; is sent to the corresponding pid. The pid is also the return value of the function. If the name is not found, the function returns &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; se encuentra, el mensaje &lt;code&gt;Msg&lt;/code&gt; se env&amp;iacute;a al PID correspondiente. El pid es tambi&amp;eacute;n el valor de retorno de la funci&amp;oacute;n. Si no se encuentra el nombre, la funci&amp;oacute;n devuelve &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e52354c073c213988ffe84ec279249d3ad68b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, the corresponding pid is returned. If the name is not found, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra &lt;code&gt;Name&lt;/code&gt; , se devuelve el pid correspondiente. Si no se encuentra el nombre, la funci&amp;oacute;n devuelve &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b00a3532b853c4357137d1d6716fd7be18c249ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a globally registered name, the calling function exits with reason &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; no es un nombre registrado globalmente, la funci&amp;oacute;n de llamada &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; con motivo {badarg, {Nombre, Msg}} .</target>
        </trans-unit>
        <trans-unit id="db414ecce81f54e0e73f62d5d1f1d7174a6bde93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a symbolic link, this function returns the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; no es un enlace simb&amp;oacute;lico, esta funci&amp;oacute;n devuelve el mismo resultado que &lt;code&gt;read_file_info/1&lt;/code&gt; . En plataformas que no admiten enlaces simb&amp;oacute;licos, esta funci&amp;oacute;n siempre es equivalente a &lt;code&gt;read_file_info/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8984feb7e9675020b1675cc50fa02225487141b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not found</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; no se encuentra</target>
        </trans-unit>
        <trans-unit id="3d520edb0115ce9349b43d81a86232f4def5a898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Dir&lt;/code&gt; is invalid</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; o &lt;code&gt;Dir&lt;/code&gt; no es v&amp;aacute;lido</target>
        </trans-unit>
        <trans-unit id="f315d1f10b092b6fd3887d5883429c8b05c69dd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt;, the &lt;code&gt;net_ticktime&lt;/code&gt; change is done at the end of the transition period; otherwise at the beginning. During the transition period, &lt;code&gt;net_kernel&lt;/code&gt; ensures that there is outgoing traffic on all connections at least every &lt;code&gt;MTTI&lt;/code&gt; millisecond.</source>
          <target state="translated">Si &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt; , el cambio de &lt;code&gt;net_ticktime&lt;/code&gt; se realiza al final del per&amp;iacute;odo de transici&amp;oacute;n; de lo contrario al principio. Durante el per&amp;iacute;odo de transici&amp;oacute;n, &lt;code&gt;net_kernel&lt;/code&gt; asegura que haya tr&amp;aacute;fico saliente en todas las conexiones al menos cada milisegundo &lt;code&gt;MTTI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3470b5ebd8e369aa1cfb7ac34ffa140b95c20443" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NewVsn&lt;/code&gt; is installed with option &lt;code&gt;{update_paths,true}&lt;/code&gt;, then &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; returns &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;NewVsn&lt;/code&gt; est&amp;aacute; instalado con la opci&amp;oacute;n &lt;code&gt;{update_paths,true}&lt;/code&gt; , entonces el &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; devuelve &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7547eeec41488135afba55363382ea4a68e45c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; the state machine changes to a new state. A &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed if enabled and all &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; are retried.</source>
          <target state="translated">Si &lt;code&gt;NextState =/= State&lt;/code&gt; la m&amp;aacute;quina de estado cambia a un nuevo estado. Se realiza una &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; si est&amp;aacute; habilitada y se reintentan todos los &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="192634e65d22edbbba862eb9814d7d7d08c39bad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; fails or does not exist, the message &lt;code&gt;{nodedown, Node}&lt;/code&gt; is delivered to the process. If a process has made two calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt; terminates, two &lt;code&gt;nodedown&lt;/code&gt; messages are delivered to the process. If there is no connection to &lt;code&gt;Node&lt;/code&gt;, an attempt is made to create one. If this fails, a &lt;code&gt;nodedown&lt;/code&gt; message is delivered.</source>
          <target state="translated">Si &lt;code&gt;Node&lt;/code&gt; falla o no existe, el mensaje &lt;code&gt;{nodedown, Node}&lt;/code&gt; se env&amp;iacute;a al proceso. Si un proceso ha realizado dos llamadas a &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; y &lt;code&gt;Node&lt;/code&gt; termina, se &lt;code&gt;nodedown&lt;/code&gt; dos mensajes de nodedown al proceso. Si no hay conexi&amp;oacute;n con &lt;code&gt;Node&lt;/code&gt; , se intenta crear una. Si esto falla, se &lt;code&gt;nodedown&lt;/code&gt; un mensaje de nodos .</target>
        </trans-unit>
        <trans-unit id="68714d151c87dc360bf98fc14620b6c335f0dd18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;Options&lt;/code&gt; will then also be added to kernel configration parameters &lt;code&gt;inet_dist_listen_options&lt;/code&gt; and &lt;code&gt;inet_dist_connect_options&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Node&lt;/code&gt; es &lt;code&gt;new&lt;/code&gt; las &lt;code&gt;Options&lt;/code&gt; tambi&amp;eacute;n se agregar&amp;aacute;n a los par&amp;aacute;metros de &lt;code&gt;inet_dist_listen_options&lt;/code&gt; kernel inet_dist_listen_options e &lt;code&gt;inet_dist_connect_options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a374c5564c071bca33b827b4d05f4d121d56e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is a connected node the return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Sock&lt;/code&gt; is the distribution socket for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Node&lt;/code&gt; es un nodo conectado, el valor de retorno es el mismo que el de &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; donde &lt;code&gt;Sock&lt;/code&gt; es el conector de distribuci&amp;oacute;n para &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a745393bc7f4f706da8daca8a06958d92906e5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;all_nodes&lt;/code&gt;, the operation or test is performed on all specified test nodes. (Declaring a term without a &lt;code&gt;NodeRefs&lt;/code&gt; element has the same effect). If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;master&lt;/code&gt;, the operation is only performed on the &lt;code&gt;Common Test&lt;/code&gt; Master node (namely set the log directory or install an event handler).</source>
          <target state="translated">Si &lt;code&gt;NodeRefs&lt;/code&gt; tiene el valor &lt;code&gt;all_nodes&lt;/code&gt; , la operaci&amp;oacute;n o prueba se realiza en todos los nodos de prueba especificados. (Declarar un t&amp;eacute;rmino sin un elemento &lt;code&gt;NodeRefs&lt;/code&gt; tiene el mismo efecto). Si &lt;code&gt;NodeRefs&lt;/code&gt; tiene el valor &lt;code&gt;master&lt;/code&gt; , la operaci&amp;oacute;n solo se realiza en el nodo &lt;code&gt;Common Test&lt;/code&gt; Master (es decir, establecer el directorio de registro o instalar un controlador de eventos).</target>
        </trans-unit>
        <trans-unit id="0a2bb885a5c6676f0b55789e9e3cebe681cef1a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Nodename&lt;/code&gt; is the local node, the error reason &lt;code&gt;cant_add_local_node&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;Nodename&lt;/code&gt; es el nodo local, se devuelve el motivo del error &lt;code&gt;cant_add_local_node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8cd44685473bdc36e9c30c5fd35ef39651321ff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Norm&lt;/code&gt; no es &lt;code&gt;none&lt;/code&gt; , la funci&amp;oacute;n aplica la normalizaci&amp;oacute;n sobre la marcha antes de la prueba de igualdad. Hay cuatro formas de normalizaci&amp;oacute;n disponibles: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e6781b735fbde5662ff5d701d6df3c8fc8b882" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ObjectOrObjects&lt;/code&gt; is a list, the function checks &lt;strong&gt;every&lt;/strong&gt; key before inserting anything. Nothing is inserted unless &lt;strong&gt;all&lt;/strong&gt; keys present in the list are absent from the table. Like &lt;code&gt;insert/2&lt;/code&gt;, the entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ObjectOrObjects&lt;/code&gt; es una lista, la funci&amp;oacute;n verifica &lt;strong&gt;cada&lt;/strong&gt; tecla antes de insertar algo. No se inserta nada a menos que &lt;strong&gt;todas las&lt;/strong&gt; claves presentes en la lista est&amp;eacute;n ausentes de la tabla. Como &lt;code&gt;insert/2&lt;/code&gt; , se garantiza que toda la operaci&amp;oacute;n ser&amp;aacute; &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea049099ad2942c413fff09669264ab1e5dd87b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; cannot fit in a 32-bit integer.</source>
          <target state="translated">Si &lt;code&gt;Operation&lt;/code&gt; no cabe en un entero de 32 bits.</target>
        </trans-unit>
        <trans-unit id="9a2af5fb3189d023dbe0c347471fbf3afbf37fe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; does not fit in a 32-bit integer.</source>
          <target state="translated">Si &lt;code&gt;Operation&lt;/code&gt; no cabe en un entero de 32 bits.</target>
        </trans-unit>
        <trans-unit id="2ef59a44cc7221066ae352f1c66be399d1a45ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opt&lt;/code&gt; is any atom, it is interpreted as &lt;code&gt;{Opt,true}&lt;/code&gt; unless the atom string starts with &lt;code&gt;&quot;no&quot;&lt;/code&gt;, making the interpretation &lt;code&gt;{Opt,false}&lt;/code&gt;. For example, &lt;code&gt;usevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,true}&lt;/code&gt; and &lt;code&gt;nousevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,false}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Opt&lt;/code&gt; es cualquier &amp;aacute;tomo, se interpreta como &lt;code&gt;{Opt,true}&lt;/code&gt; a menos que la cadena del &amp;aacute;tomo comience con &lt;code&gt;&quot;no&quot;&lt;/code&gt; , lo que hace que la interpretaci&amp;oacute;n sea &lt;code&gt;{Opt,false}&lt;/code&gt; . Por ejemplo, &lt;code&gt;usevc&lt;/code&gt; es un alias para &lt;code&gt;{usevc,true}&lt;/code&gt; y &lt;code&gt;nousevc&lt;/code&gt; es un alias para &lt;code&gt;{usevc,false}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31127aa2062d718c77d7a07ba00f404218c5e042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptList&lt;/code&gt; is not a proper list of valid &lt;code&gt;Opt&lt;/code&gt;s.</source>
          <target state="translated">Si &lt;code&gt;OptList&lt;/code&gt; no es una lista adecuada de &lt;code&gt;Opt&lt;/code&gt; s v&amp;aacute;lidas .</target>
        </trans-unit>
        <trans-unit id="7b4363da74d53cb9c45989d6ac83b5d6bbd19064" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptParams&lt;/code&gt; is not given, the default value &lt;code&gt;[]&lt;/code&gt; is used.</source>
          <target state="translated">Si no se proporciona &lt;code&gt;OptParams&lt;/code&gt; , se utiliza el valor predeterminado &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a510b4980f05110bb42f2051f210307d0b27183c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Option&lt;/code&gt; is an invalid option.</source>
          <target state="translated">Si &lt;code&gt;Option&lt;/code&gt; es una opci&amp;oacute;n inv&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="12e88c8f64ffe2e4621e2429aa9df040b6734c5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid list of options.</source>
          <target state="translated">Si &lt;code&gt;OptionList&lt;/code&gt; es una lista de opciones no v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="28172abefdf60c0ffbe1b8a62b1fc04dc23fb874" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid option list.</source>
          <target state="translated">Si &lt;code&gt;OptionList&lt;/code&gt; es una lista de opciones no v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="93bbd7b2e7d83031f59c92a0c8ccb1cc60d19148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is not a list.</source>
          <target state="translated">Si &lt;code&gt;OptionList&lt;/code&gt; no es una lista.</target>
        </trans-unit>
        <trans-unit id="b6133e7ac28cc0038bd62a0b0ae71e4da87c1eca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Options&lt;/code&gt; es &lt;code&gt;[]&lt;/code&gt; , la funci&amp;oacute;n se comporta como &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7730b5d34ec1da622c3e568e7e8a64ba1d2bd89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is a list, this is equivalent to &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt;, otherwise it is equivalent to &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt;. However, using this function directly is more efficient.</source>
          <target state="translated">Si &lt;code&gt;Options&lt;/code&gt; es una lista, esto es equivalente a &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt; , de lo contrario es equivalente a &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt; . Sin embargo, usar esta funci&amp;oacute;n directamente es m&amp;aacute;s eficiente .</target>
        </trans-unit>
        <trans-unit id="9fde3e06c0c33f9a7645abc8b6b8f5e2ebe7f59a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, the format is as follows:</source>
          <target state="translated">Si &lt;code&gt;Options&lt;/code&gt; no es &lt;code&gt;[]&lt;/code&gt; , el formato es el siguiente:</target>
        </trans-unit>
        <trans-unit id="30be8f5cb2762ca72a34cc75e497114c5814d418" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opts&lt;/code&gt; is not specified or if it is &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is deleted and a new file is created. If &lt;code&gt;Opts = [append]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is not deleted. The new information is appended at the end of the file.</source>
          <target state="translated">Si no se especifica &lt;code&gt;Opts&lt;/code&gt; o si es &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; se elimina y se crea un nuevo archivo. Si &lt;code&gt;Opts = [append]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; no se elimina. La nueva informaci&amp;oacute;n se adjunta al final del archivo.</target>
        </trans-unit>
        <trans-unit id="373e624d641069009ec67c8a54cd85bd2a2d72ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Out&lt;/code&gt; is specified, &lt;code&gt;FormatHandler&lt;/code&gt; gets the file descriptor to &lt;code&gt;Out&lt;/code&gt; as the first parameter.</source>
          <target state="translated">Si se especifica &lt;code&gt;Out&lt;/code&gt; , &lt;code&gt;FormatHandler&lt;/code&gt; obtiene el descriptor de archivo en &lt;code&gt;Out&lt;/code&gt; como primer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="fad332308463a8263339bd3390b05cbefc19f3b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt;, option &lt;code&gt;asynchronous&lt;/code&gt; of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; has been used and the suspendee has not yet been suspended by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt; , se ha utilizado la opci&amp;oacute;n &lt;code&gt;asynchronous&lt;/code&gt; de &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; y &lt;code&gt;Pid&lt;/code&gt; a&amp;uacute;n no ha suspendido el suspendee .</target>
        </trans-unit>
        <trans-unit id="3bbfc8cfc7a6d48dbab3e59b020a0ba36f02f8cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Path&lt;/code&gt; is a directory, &lt;code&gt;default_index/2&lt;/code&gt;, it starts searching for resources or files that are specified in the config directive &lt;code&gt;DirectoryIndex&lt;/code&gt;. If an appropriate resource or file is found, it is appended to the end of &lt;code&gt;Path&lt;/code&gt; and then returned. &lt;code&gt;Path&lt;/code&gt; is returned unaltered if no appropriate file is found or if &lt;code&gt;Path&lt;/code&gt; is not a directory. &lt;code&gt;config_db()&lt;/code&gt; is the server config file in ETS table format as described in &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Path&lt;/code&gt; es un directorio, &lt;code&gt;default_index/2&lt;/code&gt; , comienza a buscar recursos o archivos que se especifican en la directiva de configuraci&amp;oacute;n &lt;code&gt;DirectoryIndex&lt;/code&gt; . Si se encuentra un recurso o archivo apropiado, se agrega al final de la &lt;code&gt;Path&lt;/code&gt; y luego se devuelve. &lt;code&gt;Path&lt;/code&gt; se devuelve inalterada si no se encuentra el archivo apropiado o si la &lt;code&gt;Path&lt;/code&gt; no es un directorio. &lt;code&gt;config_db()&lt;/code&gt; es el archivo de configuraci&amp;oacute;n del servidor en formato de tabla ETS como se describe en &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beefd85af55dff03d967de6fd4d575f5153ffe35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are valid patterns, the following is also a valid pattern:</source>
          <target state="translated">Si &lt;code&gt;Pattern1&lt;/code&gt; y &lt;code&gt;Pattern2&lt;/code&gt; son patrones v&amp;aacute;lidos, el siguiente tambi&amp;eacute;n es un patr&amp;oacute;n v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="92bd28fe3699fc72ccf1ee88565e6cbd3a896278" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern&lt;/code&gt; is not a binary or a flat proper list of binaries with length &amp;gt; 0, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si &lt;code&gt;Pattern&lt;/code&gt; no es un binario o una lista plana adecuada de binarios con longitud&amp;gt; 0, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="e7fc7f98492ea4c007c2957660a86f1f0df53bcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; does not exist, the 'DOWN' message is sent immediately with &lt;code&gt;Reason&lt;/code&gt; set to &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Pid2&lt;/code&gt; no existe, el mensaje 'DOWN' se env&amp;iacute;a inmediatamente con el &lt;code&gt;Reason&lt;/code&gt; establecido en &lt;code&gt;noproc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4791446d4ac7a4577450d1706f57f608bc60d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; terminates with exit reason &lt;code&gt;Reason&lt;/code&gt;, a 'DOWN' message is sent to &lt;code&gt;Pid1&lt;/code&gt;:</source>
          <target state="translated">Si &lt;code&gt;Pid2&lt;/code&gt; termina con el motivo de salida &lt;code&gt;Reason&lt;/code&gt; , se env&amp;iacute;a un mensaje 'DOWN' a &lt;code&gt;Pid1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0d4ad4270f00a30d3a004edfbf6bb0907bb89e24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; es igual a &lt;code&gt;self()&lt;/code&gt; y no se ha pasado ninguna opci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; , la recolecci&amp;oacute;n de basura se realiza de una vez, es decir, lo mismo que llamar a &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; . De lo contrario, se env&amp;iacute;a una solicitud de recolecci&amp;oacute;n de basura al proceso identificado por &lt;code&gt;Pid&lt;/code&gt; , y se manejar&amp;aacute; cuando corresponda. Si no se ha pasado ninguna opci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; , la persona que llama se bloquea hasta que &lt;code&gt;GCResult&lt;/code&gt; est&amp;eacute; disponible y pueda devolverse.</target>
        </trans-unit>
        <trans-unit id="e39d7c1dcb4424a9d8e01705e3e21bd11e62c069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the operation is performed at once. Otherwise a request for the operation is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and is handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;CheckResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; es igual a &lt;code&gt;self()&lt;/code&gt; y no se ha pasado ninguna opci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; , la operaci&amp;oacute;n se realiza de inmediato. De lo contrario, se env&amp;iacute;a una solicitud para la operaci&amp;oacute;n al proceso identificado por &lt;code&gt;Pid&lt;/code&gt; y se maneja cuando corresponde. Si no se ha pasado ninguna opci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; , la persona que llama se bloquea hasta que &lt;code&gt;CheckResult&lt;/code&gt; est&amp;eacute; disponible y pueda devolverse.</target>
        </trans-unit>
        <trans-unit id="9a5e58475adf385dca728b097c7c732d60714c40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is an I/O device, that is, a pid returned from &lt;code&gt;open/2&lt;/code&gt;, this function returns the filename, or rather:</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; es un dispositivo de E / S, es decir, un pid devuelto por &lt;code&gt;open/2&lt;/code&gt; , esta funci&amp;oacute;n devuelve el nombre del archivo, o mejor dicho:</target>
        </trans-unit>
        <trans-unit id="2c88872158412481d4632dbb6c4d0828fafd3ef7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; no es un proceso local.</target>
        </trans-unit>
        <trans-unit id="0c4258af24e0c809dc0bd9d32eeea697ff1e2cb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a node local process identifier.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; no es un identificador de proceso local de nodo.</target>
        </trans-unit>
        <trans-unit id="a85548fa2767eaff370c38aaf90f8964627aa367" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not trapping exits, &lt;code&gt;Pid&lt;/code&gt; itself exits with exit reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; no est&amp;aacute; atrapando salidas, el propio &lt;code&gt;Pid&lt;/code&gt; sale con el motivo de salida &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="981b0f8c411a07f7ef682ac79981f9ce74ca69e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; est&amp;aacute; capturando salidas, la se&amp;ntilde;al de salida se transforma en un mensaje &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; y se env&amp;iacute;a a la cola de mensajes de &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e139aa51e35a6da6edcc143ed04c057990132602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist, the behavior of the BIF depends on if the calling process is trapping exits or not (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">Si &lt;code&gt;PidOrPort&lt;/code&gt; no existe, el comportamiento del BIF depende de si el proceso de llamada est&amp;aacute; atrapando salidas o no (ver &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="266b9e9cd253c4e1b334cac8528b2a62708531c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; is not an existing local process or port.</source>
          <target state="translated">Si &lt;code&gt;PidOrPort&lt;/code&gt; no es un proceso o puerto local existente.</target>
        </trans-unit>
        <trans-unit id="ea3c1727e46c2f29d355231a14b993fe9ee7f045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns a free UDP port, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">Si &lt;code&gt;Port == 0&lt;/code&gt; , el SO subyacente asigna un puerto UDP libre, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; para recuperarlo.</target>
        </trans-unit>
        <trans-unit id="d7fa31d4ca670522aa140145b3a60537cc2e5b54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns an available port number, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">Si &lt;code&gt;Port == 0&lt;/code&gt; , el sistema operativo subyacente asigna un n&amp;uacute;mero de puerto disponible, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; para recuperarlo.</target>
        </trans-unit>
        <trans-unit id="fb219559d25b9731f030a5d6d757dbdd7db890b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before this &lt;code&gt;badarg&lt;/code&gt; exception occurs.</source>
          <target state="translated">Si &lt;code&gt;Port&lt;/code&gt; no es un identificador de un puerto abierto o el nombre registrado de un puerto abierto. Si el proceso de llamada se vincul&amp;oacute; previamente al puerto cerrado, identificado por &lt;code&gt;Port&lt;/code&gt; , se garantiza que la se&amp;ntilde;al de salida del puerto se entregar&amp;aacute; antes de que &lt;code&gt;badarg&lt;/code&gt; esta excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="0702a363d6583ab49124103adeca84fa54bd565c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an open port or the registered name of an open port.</source>
          <target state="translated">Si &lt;code&gt;Port&lt;/code&gt; no es un puerto abierto o el nombre registrado de un puerto abierto.</target>
        </trans-unit>
        <trans-unit id="ad97fac62d783a4932985f8dd89585d539b9ba38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PosLen&lt;/code&gt; in any way references outside the binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si &lt;code&gt;PosLen&lt;/code&gt; de alguna manera hace referencia fuera del binario, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n badarg .</target>
        </trans-unit>
        <trans-unit id="5fa9284a8e57969389fe13ab25086a491ce7496c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is the prefix of &lt;code&gt;String&lt;/code&gt;, removes it and returns the remainder of &lt;code&gt;String&lt;/code&gt;, otherwise returns &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Prefix&lt;/code&gt; es el prefijo de &lt;code&gt;String&lt;/code&gt; , lo elimina y devuelve el resto de &lt;code&gt;String&lt;/code&gt; ; de lo contrario, devuelve &lt;code&gt;nomatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4e6b8924461855959440e4adc224de1af86a752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QH2&lt;/code&gt; is a call to the function for &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt;, as defined in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;gb_table:table/1&lt;/code&gt;, the iterator for the gb-tree is initiated for each answer to &lt;code&gt;QH1&lt;/code&gt;. The objects of the gb-tree are then returned one by one. This is probably the most efficient way of traversing the table in that case, as it takes minimal computational power to get the following object. But if &lt;code&gt;QH2&lt;/code&gt; is not a table but a more complicated QLC, it can be more efficient to use some RAM memory for collecting the answers in a cache, particularly if there are only a few answers. It must then be assumed that evaluating &lt;code&gt;QH2&lt;/code&gt; has no side effects so that the meaning of the query does not change if &lt;code&gt;QH2&lt;/code&gt; is evaluated only once. One way of caching the answers is to evaluate &lt;code&gt;QH2&lt;/code&gt; first of all and substitute the list of answers for &lt;code&gt;QH2&lt;/code&gt; in the query. Another way is to use option &lt;code&gt;cache&lt;/code&gt;. It is expressed like this:</source>
          <target state="translated">Si &lt;code&gt;QH2&lt;/code&gt; es una llamada a la funci&amp;oacute;n para &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; , como se define en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;gb_table:table/1&lt;/code&gt; , el iterador para el &amp;aacute;rbol gb se inicia para cada respuesta a &lt;code&gt;QH1&lt;/code&gt; . Los objetos del &amp;aacute;rbol gb se devuelven uno por uno. Esta es probablemente la forma m&amp;aacute;s eficiente de recorrer la tabla en ese caso, ya que se necesita un poder de c&amp;aacute;lculo m&amp;iacute;nimo para obtener el siguiente objeto. Pero si &lt;code&gt;QH2&lt;/code&gt; no es una tabla sino un QLC m&amp;aacute;s complicado, puede ser m&amp;aacute;s eficiente usar algo de memoria RAM para recopilar las respuestas en un cach&amp;eacute;, particularmente si solo hay unas pocas respuestas. Entonces debe asumirse que la evaluaci&amp;oacute;n de &lt;code&gt;QH2&lt;/code&gt; no tiene efectos secundarios, por lo que el significado de la consulta no cambia si &lt;code&gt;QH2&lt;/code&gt; se eval&amp;uacute;a solo una vez. Una forma de almacenar en cach&amp;eacute; las respuestas es evaluar &lt;code&gt;QH2&lt;/code&gt; en primer lugar y sustituir la lista de respuestas por &lt;code&gt;QH2&lt;/code&gt; en la consulta. Otra forma es utilizar la &lt;code&gt;cache&lt;/code&gt; opciones . Se expresa as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="491d904b6ae249fbebb7daf8bc786e22605cc650" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;kill&lt;/code&gt;, that is, if &lt;code&gt;exit(Pid, kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;Pid&lt;/code&gt;, which unconditionally exits with exit reason &lt;code&gt;killed&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Reason&lt;/code&gt; es la &lt;code&gt;kill&lt;/code&gt; del &amp;aacute;tomo , es decir, si se llama a &lt;code&gt;exit(Pid, kill)&lt;/code&gt; , se env&amp;iacute;a una se&amp;ntilde;al de salida que no se puede atrapar a &lt;code&gt;Pid&lt;/code&gt; , que sale incondicionalmente con la raz&amp;oacute;n de salida &lt;code&gt;killed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35fbbe7923611fc3677c5eb123690517ee7e8658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;Pid&lt;/code&gt; does not exit. If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">Si &lt;code&gt;Reason&lt;/code&gt; es el &amp;aacute;tomo &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;Pid&lt;/code&gt; no sale. Si est&amp;aacute; capturando salidas, la se&amp;ntilde;al de salida se transforma en un mensaje &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; y se env&amp;iacute;a a su cola de mensajes.</target>
        </trans-unit>
        <trans-unit id="cd196dac154540858e61e812e21e07f3f0b754dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; has the value &lt;code&gt;{Tag, Recv}&lt;/code&gt;, the delivery is done according to &lt;code&gt;Recv&lt;/code&gt;:</source>
          <target state="translated">Si &lt;code&gt;Receiver&lt;/code&gt; tiene el valor &lt;code&gt;{Tag, Recv}&lt;/code&gt; , la entrega se realiza de acuerdo con &lt;code&gt;Recv&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="868986f0a85c44f9afa64f0b61bdc67eb57beed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; is a &lt;code&gt;notification_delivery_info()&lt;/code&gt; record, then the information about the notification delivery will be delivered to the &lt;code&gt;receiver&lt;/code&gt; via the callback functions defined by the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour according to the content of the &lt;code&gt;notification_delivery_info()&lt;/code&gt; record.</source>
          <target state="translated">Si &lt;code&gt;Receiver&lt;/code&gt; es un registro &lt;code&gt;notification_delivery_info()&lt;/code&gt; , entonces la informaci&amp;oacute;n sobre la entrega de la notificaci&amp;oacute;n se entregar&amp;aacute; al &lt;code&gt;receiver&lt;/code&gt; trav&amp;eacute;s de las funciones de devoluci&amp;oacute;n de llamada definidas por el comportamiento &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; de acuerdo con el contenido del registro &lt;code&gt;notification_delivery_info()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="508d6986d5eeb87f61b9a5f9d5b4f17fa77bcfb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is already in use.</source>
          <target state="translated">Si &lt;code&gt;RegName&lt;/code&gt; ya est&amp;aacute; en uso.</target>
        </trans-unit>
        <trans-unit id="ae95dfac53a373131ac9010b1c1e1134c4182f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;RegName&lt;/code&gt; es el &amp;aacute;tomo &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0f5e564e5fd5ab3c1d7b8ad071d580aac2f45e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Repair&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current log file is repaired, if needed. As the restoration is initiated, a message is output on the error log. If &lt;code&gt;false&lt;/code&gt; is specified, no automatic repair is attempted. Instead, the tuple &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; is returned if an attempt is made to open a corrupt log file. If &lt;code&gt;truncate&lt;/code&gt; is specified, the log file becomes truncated, creating an empty log. Defaults to &lt;code&gt;true&lt;/code&gt;, which has no effect on logs opened in read-only mode.</source>
          <target state="translated">Si &lt;code&gt;Repair&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el archivo de registro actual se repara, si es necesario. Cuando se inicia la restauraci&amp;oacute;n, se genera un mensaje en el registro de errores. Si se especifica &lt;code&gt;false&lt;/code&gt; , no se intentar&amp;aacute; ninguna reparaci&amp;oacute;n autom&amp;aacute;tica. En su lugar, se devuelve la tupla &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; si se intenta abrir un archivo de registro corrupto. Si se especifica &lt;code&gt;truncate&lt;/code&gt; , el archivo de registro se trunca, creando un registro vac&amp;iacute;o. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; , que no tiene ning&amp;uacute;n efecto en los registros abiertos en modo de solo lectura.</target>
        </trans-unit>
        <trans-unit id="fba0a2d131df8af1eeb91211c8b8a8dde41e75fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Report&lt;/code&gt; is a map, it is converted to a key-value list before formatting as such.</source>
          <target state="translated">Si &lt;code&gt;Report&lt;/code&gt; es un mapa, se convierte en una lista de valores-clave antes de formatearlo como tal.</target>
        </trans-unit>
        <trans-unit id="15d8d66582408c3486d2e25500d0a72b68b8cb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ReqId&lt;/code&gt; is less then 0, it means that this information was not available to the manager (that info was never retrieved before the message was discarded).</source>
          <target state="translated">Si &lt;code&gt;ReqId&lt;/code&gt; es menor que 0, significa que esta informaci&amp;oacute;n no estaba disponible para el administrador (esa informaci&amp;oacute;n nunca se recuper&amp;oacute; antes de que se descartara el mensaje).</target>
        </trans-unit>
        <trans-unit id="0dee047b2dfd5610136ab93118e486cde7422df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, the packet only consists of &lt;code&gt;[119, Result]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; ado &amp;gt; 0, el paquete solo consta de &lt;code&gt;[119, Result]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c802495174a415d0a94a21a32d111d68231fb125" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This because the timer had expired, or been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never has corresponded to a timer. Even if the timer has expired, it does not tell you whether or not the time-out message has arrived at its destination yet.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , no se pudo encontrar un temporizador correspondiente a &lt;code&gt;TimerRef&lt;/code&gt; . Esto se debe a que el temporizador ha expirado o se ha cancelado, o porque &lt;code&gt;TimerRef&lt;/code&gt; nunca ha correspondido a un temporizador. Incluso si el temporizador ha expirado, no le dice si el mensaje de tiempo de espera ha llegado a su destino o no.</target>
        </trans-unit>
        <trans-unit id="c0a8cfe624c240dfdb507f48e9d219914e2f948e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This can be either because the timer had expired, already had been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never corresponded to a timer. Even if the timer had expired, it does not tell you if the time-out message has arrived at its destination yet.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , no se pudo encontrar un temporizador correspondiente a &lt;code&gt;TimerRef&lt;/code&gt; . Esto puede deberse a que el temporizador hab&amp;iacute;a expirado, ya se hab&amp;iacute;a cancelado o porque &lt;code&gt;TimerRef&lt;/code&gt; nunca correspondi&amp;oacute; a un temporizador. Incluso si el temporizador ha expirado, no le indica si el mensaje de tiempo de espera ha llegado a su destino.</target>
        </trans-unit>
        <trans-unit id="bd4390894559b806475261afd409260099fb0615" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the canceled timer would have expired.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; es un n&amp;uacute;mero entero, representa el tiempo en milisegundos que queda hasta que el temporizador cancelado haya expirado.</target>
        </trans-unit>
        <trans-unit id="8b2e483082bcb6a7c95be17d5564ab01e1806263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the timer expires.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; es un n&amp;uacute;mero entero, representa el tiempo en milisegundos que queda hasta que expira el temporizador.</target>
        </trans-unit>
        <trans-unit id="996c07f00aef0bf25f1adad8d4b5c2f0b7da6aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Rules&lt;/code&gt; is left out or is an empty list, the default system rules are used. See also the Kernel application parameter &lt;code&gt;source_search_rules&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Rules&lt;/code&gt; se omite o es una lista vac&amp;iacute;a, se utilizan las reglas del sistema predeterminadas. Consulte tambi&amp;eacute;n el par&amp;aacute;metro de la aplicaci&amp;oacute;n Kernel &lt;code&gt;source_search_rules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="914c10ab17b1be80fb703c7a051a9650d90020cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Schedulers&lt;/code&gt; or &lt;code&gt;SchedulersOnline&lt;/code&gt; is specified as a negative number, the value is subtracted from the default number of logical processors configured or logical processors available, respectively.</source>
          <target state="translated">Si &lt;code&gt;Schedulers&lt;/code&gt; o &lt;code&gt;SchedulersOnline&lt;/code&gt; se especifica como un n&amp;uacute;mero negativo, el valor se resta del n&amp;uacute;mero predeterminado de procesadores l&amp;oacute;gicos configurados o procesadores l&amp;oacute;gicos disponibles, respectivamente.</target>
        </trans-unit>
        <trans-unit id="1d347e571bfea9b8b89077684381b3f15fcd946f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Scope&lt;/code&gt; of the operation is &lt;code&gt;local&lt;/code&gt;, the fallback is only installed on the local node.</source>
          <target state="translated">Si el &lt;code&gt;Scope&lt;/code&gt; de la operaci&amp;oacute;n es &lt;code&gt;local&lt;/code&gt; , la reserva solo se instala en el nodo local.</target>
        </trans-unit>
        <trans-unit id="998a85ab406edc34895d37ac87304bcc5cc05937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="translated">Si el &lt;code&gt;Server&lt;/code&gt; es &lt;code&gt;self()&lt;/code&gt; se crea un servidor an&amp;oacute;nimo al igual que cuando se usa &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt; . Si el &lt;code&gt;Server&lt;/code&gt; es un &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; se crea un servidor con nombre como cuando se usa &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt; . Sin embargo, el nombre &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; debe haberse registrado en consecuencia &lt;strong&gt;antes de&lt;/strong&gt; llamar a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="49ccf350dd38e4a46c92e05cf1457282aa2a2b57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="translated">Si &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt; , la &lt;code&gt;gen_server&lt;/code&gt; proceso gen_server se registr&amp;oacute; globalmente como &lt;code&gt;GlobalName&lt;/code&gt; usando &lt;code&gt;global:register_name/2&lt;/code&gt; Si no se proporciona ning&amp;uacute;n nombre, el proceso &lt;code&gt;gen_server&lt;/code&gt; no est&amp;aacute; registrado.</target>
        </trans-unit>
        <trans-unit id="c99d7d2ec0751d55a79f6c64ef86b68f3b33366c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={local,Name}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ServerName={local,Name}&lt;/code&gt; , el proceso &lt;code&gt;gen_server&lt;/code&gt; se registra localmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4471e49d4ac17a2da6d90db02e958498fd4eca78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Si &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt; , el proceso &lt;code&gt;gen_server&lt;/code&gt; se registra en el registro representado por &lt;code&gt;Module&lt;/code&gt; . La devoluci&amp;oacute;n de llamada del &lt;code&gt;Module&lt;/code&gt; es para exportar las funciones &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; y &lt;code&gt;send/2&lt;/code&gt; , que deben comportarse como las funciones correspondientes en &lt;code&gt;global&lt;/code&gt; . Por lo tanto, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; es una referencia v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="1a7d3d4777e0d9530a017faf5e5e71aeba400cf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server_or_Actions&lt;/code&gt; is a &lt;code&gt;list()&lt;/code&gt;, the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered and &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt;. This creates an anonymous server.</source>
          <target state="translated">Si &lt;code&gt;Server_or_Actions&lt;/code&gt; es una &lt;code&gt;list()&lt;/code&gt; , lo mismo que &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; excepto que no se debe haber registrado ning&amp;uacute;n &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt; . Esto crea un servidor an&amp;oacute;nimo.</target>
        </trans-unit>
        <trans-unit id="0cc5ba33de3003e688f8911d6e6894d616033d12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SetFun&lt;/code&gt; is a number i &amp;gt;= 1 and &lt;code&gt;Set1&lt;/code&gt; is a relation, then the returned set is the &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set1&lt;/code&gt; onto coordinate i.</source>
          <target state="translated">Si &lt;code&gt;SetFun&lt;/code&gt; es un n&amp;uacute;mero i&amp;gt; = 1 y &lt;code&gt;Set1&lt;/code&gt; es una relaci&amp;oacute;n, entonces el conjunto devuelto es la &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Set1&lt;/code&gt; sobre la coordenada i.</target>
        </trans-unit>
        <trans-unit id="fa9d9044e1d8e367fe63682c042ce5ba7e21718e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the SSL/TLS server-side handshake and returns a TLS socket.</source>
          <target state="translated">Si &lt;code&gt;Socket&lt;/code&gt; es un &lt;code&gt;socket()&lt;/code&gt; normal () : actualiza un &lt;code&gt;gen_tcp&lt;/code&gt; , o equivalente, a un socket SSL, es decir, realiza el protocolo de enlace del lado del servidor SSL / TLS y devuelve un socket TLS.</target>
        </trans-unit>
        <trans-unit id="da7fd7fd2a8598b74434eb489d432414fe4daa4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;sslsocket()&lt;/code&gt;: provides extra SSL/TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the SSL/TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="translated">Si &lt;code&gt;Socket&lt;/code&gt; es un &lt;code&gt;sslsocket()&lt;/code&gt; : proporciona opciones adicionales SSL / TLS / DTLS a las especificadas en &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; y luego realiza el protocolo de enlace SSL / TLS / DTLS. Devuelve un nuevo socket TLS / DTLS si el protocolo de enlace es exitoso.</target>
        </trans-unit>
        <trans-unit id="4841c9f7a71e862586a5146811fbbbda9e0a5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;read&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">Si &lt;code&gt;Source&lt;/code&gt; refiere a un nombre de archivo, se abre con el modo de &lt;code&gt;read&lt;/code&gt; antepuesto a la lista de modos antes de la copia y se cierra cuando termina.</target>
        </trans-unit>
        <trans-unit id="b32d5c9aabdee11f000c96e5dc5cd00d32eea8d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt;, separate tests will be created per specification. If &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt;, all specifications will be merge into one test.</source>
          <target state="translated">Si &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt; , se crear&amp;aacute;n pruebas independientes por especificaci&amp;oacute;n. Si &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt; , todas las especificaciones se fusionar&amp;aacute;n en una sola prueba.</target>
        </trans-unit>
        <trans-unit id="64318942ad99e2a283846e85b41c1a1a90a245d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Streams&lt;/code&gt; is an empty list, &lt;strong&gt;all&lt;/strong&gt; streams are requested by sending the following filter:</source>
          <target state="translated">Si &lt;code&gt;Streams&lt;/code&gt; es una lista vac&amp;iacute;a, &lt;strong&gt;todos los&lt;/strong&gt; streams se solicitan enviando el siguiente filtro:</target>
        </trans-unit>
        <trans-unit id="d0bddbecc2df41f591669985046f32e7a92f59d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt; , el puente supervisor se registra globalmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55b58db32cac80b6fba959bc6eb9beb456afa271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt;, the supervisor bridge is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt; , el puente supervisor se registra localmente como &lt;code&gt;Name&lt;/code&gt; usando el &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72424d21ee1e4f64401815083aa13a425812c98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt;, the supervisor bridge is registered as &lt;code&gt;Name&lt;/code&gt; using a registry represented by Module. The &lt;code&gt;Module&lt;/code&gt; callback is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Si &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt; , el puente supervisor se registra como &lt;code&gt;Name&lt;/code&gt; usando un registro representado por Module. La devoluci&amp;oacute;n de llamada del &lt;code&gt;Module&lt;/code&gt; es para exportar las funciones &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; y &lt;code&gt;send/2&lt;/code&gt; , que deben comportarse como las funciones correspondientes en &lt;code&gt;global&lt;/code&gt; . Por lo tanto, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; es una referencia v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="5e7b2fcdf9c47fb2dceee651299ffa41113ce50c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;SupName={global,Name}&lt;/code&gt; , el supervisor se registra globalmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94898f62db8e0366c9e39384d40e7b1aeef50e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={local,Name}&lt;/code&gt;, the supervisor is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;SupName={local,Name}&lt;/code&gt; , el supervisor se registra localmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="302a4ec0f93e1a3b85f4525fc68100cb7ea134fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt;, the supervisor is registered as &lt;code&gt;Name&lt;/code&gt; using the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback must export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which must behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,Name}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Si &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt; , el supervisor se registra como &lt;code&gt;Name&lt;/code&gt; usando el registro representado por &lt;code&gt;Module&lt;/code&gt; . La devoluci&amp;oacute;n de llamada del &lt;code&gt;Module&lt;/code&gt; debe exportar las funciones &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; y &lt;code&gt;send/2&lt;/code&gt; , que deben comportarse como las funciones correspondientes en &lt;code&gt;global&lt;/code&gt; . Por lo tanto, &lt;code&gt;{via,global,Name}&lt;/code&gt; es una referencia v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="e19abc8d0154d9b15c235deec3229c13afe0bfd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Suspendee&lt;/code&gt; is not a process identifier.</source>
          <target state="translated">Si &lt;code&gt;Suspendee&lt;/code&gt; no es un identificador de proceso.</target>
        </trans-unit>
        <trans-unit id="c9f3eb71690e00c625f528d1a166e4c2803c3742" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; can be matched, the function returns a non-zero value and binds any unbound variables in &lt;code&gt;Pattern&lt;/code&gt;. If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; do not match, &lt;code&gt;0&lt;/code&gt; is returned. For example:</source>
          <target state="translated">Si se pueden hacer coincidir &lt;code&gt;Term&lt;/code&gt; y &lt;code&gt;Pattern&lt;/code&gt; , la funci&amp;oacute;n devuelve un valor distinto de cero y vincula las variables no vinculadas en &lt;code&gt;Pattern&lt;/code&gt; . Si el &lt;code&gt;Term&lt;/code&gt; y el &lt;code&gt;Pattern&lt;/code&gt; no coinciden, se devuelve &lt;code&gt;0&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c379e61ba098c472d84880da68787d8cf49e4a92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;, no timer is started, as it never would expire anyway.</source>
          <target state="translated">Si el &lt;code&gt;Time&lt;/code&gt; es &lt;code&gt;infinity&lt;/code&gt; , no se inicia ning&amp;uacute;n temporizador, ya que nunca caducar&amp;iacute;a de todos modos.</target>
        </trans-unit>
        <trans-unit id="361b493363d47b76898e36a3b534cb11d8d0b1ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events.</source>
          <target state="translated">Si el &lt;code&gt;Time&lt;/code&gt; es relativo y &lt;code&gt;0&lt;/code&gt; no se inicia realmente ning&amp;uacute;n temporizador, en su lugar, el evento de tiempo de espera se pone en cola para garantizar que se procese antes de cualquier evento externo a&amp;uacute;n no recibido, pero despu&amp;eacute;s de los eventos ya en cola.</target>
        </trans-unit>
        <trans-unit id="53be15db077d9f7386a9212d414b5bbc5efc8b98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event.</source>
          <target state="translated">Si el &lt;code&gt;Time&lt;/code&gt; es relativo y &lt;code&gt;0&lt;/code&gt; no se inicia realmente ning&amp;uacute;n temporizador, el evento de tiempo de espera se pone en cola para garantizar que se procese antes de cualquier evento externo a&amp;uacute;n no recibido.</target>
        </trans-unit>
        <trans-unit id="df42bd176e1545f79c00a2e65e652086e9d32d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;{error, timeout}&lt;/code&gt; is returned, and the process is killed.</source>
          <target state="translated">Si &lt;code&gt;Time&lt;/code&gt; se especifica como un n&amp;uacute;mero entero, esta funci&amp;oacute;n espera milisegundos de &lt;code&gt;Time&lt;/code&gt; para que el nuevo proceso llame a &lt;code&gt;init_ack&lt;/code&gt; , o se devuelve &lt;code&gt;{error, timeout}&lt;/code&gt; y el proceso se mata.</target>
        </trans-unit>
        <trans-unit id="4be60462090656e0a73c06a85dd1300e3f12ecfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Timeout&lt;/code&gt; is set to an integer value in milliseconds, Mnesia forces &quot;heavyweight transactions&quot; to be finished, even if the outcome of the transaction for the moment is unclear. After &lt;code&gt;Timeout&lt;/code&gt; milliseconds, Mnesia commits or terminates the transaction and continues with the startup. This can lead to a situation where the transaction is committed on some nodes and terminated on other nodes. If the transaction is a schema transaction, the inconsistency can be fatal.</source>
          <target state="translated">Si &lt;code&gt;Timeout&lt;/code&gt; se establece en un valor entero en milisegundos, Mnesia fuerza la finalizaci&amp;oacute;n de las &quot;transacciones de peso pesado&quot;, incluso si el resultado de la transacci&amp;oacute;n por el momento no est&amp;aacute; claro. Despu&amp;eacute;s de milisegundos de &lt;code&gt;Timeout&lt;/code&gt; , Mnesia confirma o termina la transacci&amp;oacute;n y contin&amp;uacute;a con el inicio. Esto puede llevar a una situaci&amp;oacute;n en la que la transacci&amp;oacute;n se confirma en algunos nodos y finaliza en otros nodos. Si la transacci&amp;oacute;n es una transacci&amp;oacute;n de esquema, la inconsistencia puede ser fatal.</target>
        </trans-unit>
        <trans-unit id="714a8fc4e60ac83febb0eba6e2e43aa29c1e43cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; e &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="116f28b654e1b2114f084ce63da092181669b950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54f93f73769a89bfaa867aaa2f8894d3965b6413" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TupleOfBinRels&lt;/code&gt; is a non-empty tuple {R[1], ..., R[n]} of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;TupleOfBinRels&lt;/code&gt; es una tupla no vac&amp;iacute;a {R [1], ..., R [n]} de relaciones binarias y &lt;code&gt;BinRel1&lt;/code&gt; es una relaci&amp;oacute;n binaria, entonces &lt;code&gt;BinRel2&lt;/code&gt; es el &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; del conjunto ordenado (R [i], ..., R [n]) y &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c970d03f8f213aa54cea6a63852543e1427736a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = load&lt;/code&gt;, the application is only loaded.</source>
          <target state="translated">Si &lt;code&gt;Type = load&lt;/code&gt; , la aplicaci&amp;oacute;n solo se carga.</target>
        </trans-unit>
        <trans-unit id="ef46ddc91155f5582e897510a78e384c324f3ca3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = none&lt;/code&gt;, the application is not loaded and not started, although the code for its modules is loaded.</source>
          <target state="translated">Si &lt;code&gt;Type = none&lt;/code&gt; , la aplicaci&amp;oacute;n no se carga ni se inicia, aunque se carga el c&amp;oacute;digo de sus m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="ee9c99386deae4cad26ab6d667423f3c8e7d9d82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt;, the application is loaded and started in the corresponding way, see &lt;code&gt;application(3)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt; , la aplicaci&amp;oacute;n se carga y se inicia de la forma correspondiente, ver &lt;code&gt;application(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80d0f32ad447a0f124722ae3ffd089ea15b0187a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;file&lt;/code&gt;, the client reads all trace messages stored in the file named &lt;code&gt;Filename&lt;/code&gt; or specified by &lt;code&gt;WrapFilesSpec&lt;/code&gt; (must be the same as used when creating the trace, see trace_port/2) and let's the default handler function format the messages on the console. This is one way to interpret the data stored in a file by the file trace port driver.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;file&lt;/code&gt; , el cliente lee todos los mensajes de seguimiento almacenados en el archivo llamado &lt;code&gt;Filename&lt;/code&gt; o especificado por &lt;code&gt;WrapFilesSpec&lt;/code&gt; (debe ser el mismo que se us&amp;oacute; al crear el seguimiento, ver trace_port / 2) y deja que la funci&amp;oacute;n del controlador predeterminado formatee los mensajes en la consola . Esta es una forma de interpretar los datos almacenados en un archivo por el controlador del puerto de rastreo de archivos.</target>
        </trans-unit>
        <trans-unit id="a4858c659d369e53d254b355df46af5fbf4c16d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;follow_file&lt;/code&gt;, the client behaves as in the &lt;code&gt;file&lt;/code&gt; case, but keeps trying to read (and process) more data from the file until stopped by &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;WrapFilesSpec&lt;/code&gt; is not allowed as second argument for this &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;follow_file&lt;/code&gt; , el cliente se comporta como en el caso del &lt;code&gt;file&lt;/code&gt; , pero sigue intentando leer (y procesar) m&amp;aacute;s datos del archivo hasta que &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt; lo detiene . &lt;code&gt;WrapFilesSpec&lt;/code&gt; no se permite como segundo argumento para este &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="180a1fd075134b1e3a57e62da41207ab78634934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ip&lt;/code&gt;, the client connects to the TCP/IP port &lt;code&gt;PortNumber&lt;/code&gt; on the host &lt;code&gt;Hostname&lt;/code&gt;, from where it reads trace messages until the TCP/IP connection is closed. If no &lt;code&gt;Hostname&lt;/code&gt; is specified, the local host is assumed.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;ip&lt;/code&gt; , el cliente se conecta al puerto TCP / IP &lt;code&gt;PortNumber&lt;/code&gt; en el host &lt;code&gt;Hostname&lt;/code&gt; , desde donde lee los mensajes de seguimiento hasta que se cierra la conexi&amp;oacute;n TCP / IP. Si no se especifica ning&amp;uacute;n nombre de &lt;code&gt;Hostname&lt;/code&gt; , se asume el host local.</target>
        </trans-unit>
        <trans-unit id="e7f9b8934106158303967177ea69d38323fb0f5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;port&lt;/code&gt;, then the second parameter should be a &lt;strong&gt;fun&lt;/strong&gt; which takes no arguments and returns a newly opened trace port when called. Such a &lt;strong&gt;fun&lt;/strong&gt; is preferably generated by calling &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;port&lt;/code&gt; , entonces el segundo par&amp;aacute;metro deber&amp;iacute;a ser &lt;strong&gt;divertido&lt;/strong&gt; que no toma argumentos y devuelve un puerto de rastreo reci&amp;eacute;n abierto cuando se llama. Esta &lt;strong&gt;diversi&amp;oacute;n&lt;/strong&gt; se genera preferiblemente llamando a &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcff9f93e9e05e724456b0bced8193fb3bde0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;process&lt;/code&gt;, a message handler function can be specified (&lt;code&gt;HandlerSpec&lt;/code&gt;). The handler function, which should be a &lt;code&gt;fun&lt;/code&gt; taking two arguments, will be called for each trace message, with the first argument containing the message as it is and the second argument containing the return value from the last invocation of the fun. The initial value of the second parameter is specified in the &lt;code&gt;InitialData&lt;/code&gt; part of the &lt;code&gt;HandlerSpec&lt;/code&gt;. The &lt;code&gt;HandlerFun&lt;/code&gt; may choose any appropriate action to take when invoked, and can save a state for the next invocation by returning it.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;process&lt;/code&gt; , se puede especificar una funci&amp;oacute;n de controlador de mensajes ( &lt;code&gt;HandlerSpec&lt;/code&gt; ). La funci&amp;oacute;n del controlador, que deber&amp;iacute;a ser &lt;code&gt;fun&lt;/code&gt; tomando dos argumentos, se llamar&amp;aacute; para cada mensaje de seguimiento, con el primer argumento que contiene el mensaje tal como est&amp;aacute; y el segundo argumento contiene el valor de retorno de la &amp;uacute;ltima invocaci&amp;oacute;n de la diversi&amp;oacute;n. El valor inicial del segundo par&amp;aacute;metro se especifica en la parte &lt;code&gt;InitialData&lt;/code&gt; de &lt;code&gt;HandlerSpec&lt;/code&gt; . El &lt;code&gt;HandlerFun&lt;/code&gt; puede elegir cualquier acci&amp;oacute;n apropiada a tomar cuando se invoca, y puede ahorrar un estado para la siguiente invocaci&amp;oacute;n por devolverlo.</target>
        </trans-unit>
        <trans-unit id="25a5ca48186c13c4c06e74ef1db2027011e4bcd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;table&lt;/code&gt;, the object to match against is to be a tuple. The function then returns &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;ets:select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match the object tuple.</source>
          <target state="translated">Si el &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;table&lt;/code&gt; , el objeto con el que comparar es una tupla. La funci&amp;oacute;n luego devuelve &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt; , donde &lt;code&gt;Result&lt;/code&gt; es lo que habr&amp;iacute;a sido el resultado en una llamada &lt;code&gt;ets:select/2&lt;/code&gt; real , o &lt;code&gt;false&lt;/code&gt; si la especificaci&amp;oacute;n de coincidencia no coincide con la tupla del objeto.</target>
        </trans-unit>
        <trans-unit id="79b1b01424133793a9f87e15e6618830f393c840" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;trace&lt;/code&gt;, the object to match against is to be a list. The function returns &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is one of the following:</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;trace&lt;/code&gt; , el objeto con el que comparar ser&amp;aacute; una lista. La funci&amp;oacute;n devuelve &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt; , donde &lt;code&gt;Result&lt;/code&gt; es uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="55c96c3e31c21901d76762cfc3c55a1a75e182d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is not one of the memory types listed in the description of &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; no es uno de los tipos de memoria enumerados en la descripci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09015d085c4ba86f35f77e160ea74ab1cc97841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[]&lt;/code&gt; is returned, no OS monotonic time is available. The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order of these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">Si se devuelve &lt;code&gt;[]&lt;/code&gt; , no hay tiempo monot&amp;oacute;nico de SO disponible. La lista contiene dos tuplas con &lt;code&gt;Key&lt;/code&gt; s como primer elemento y &lt;code&gt;Value&lt;/code&gt; s como segundo elemento. El orden de estas tuplas no est&amp;aacute; definido. Las siguientes tuplas pueden formar parte de la lista, pero se pueden introducir m&amp;aacute;s tuplas en el futuro:</target>
        </trans-unit>
        <trans-unit id="0dab6e7436a7ad654f072804193938c789548d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[node()]&lt;/code&gt; then a connection is rejected if another already exists on any of the specified nodes. Types &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;nodes&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;[node()]&lt;/code&gt;, &lt;code&gt;[node()|nodes()]&lt;/code&gt; and the evaluated value respectively, evaluation of each expression taking place whenever a new connection is to be established. Note that &lt;code&gt;false&lt;/code&gt; allows an unlimited number of connections to be established with the same peer.</source>
          <target state="translated">Si &lt;code&gt;[node()]&lt;/code&gt; , se rechaza una conexi&amp;oacute;n si ya existe otra en cualquiera de los nodos especificados. Los tipos &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;node&lt;/code&gt; , &lt;code&gt;nodes&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; son equivalentes a &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;[node()]&lt;/code&gt; , &lt;code&gt;[node()|nodes()]&lt;/code&gt; y el valor evaluado respectivamente, la evaluaci&amp;oacute;n de cada expresi&amp;oacute;n tiene lugar cada vez que se va a realizar una nueva conexi&amp;oacute;n establecido. Tenga en cuenta que &lt;code&gt;false&lt;/code&gt; permite establecer un n&amp;uacute;mero ilimitado de conexiones con el mismo par.</target>
        </trans-unit>
        <trans-unit id="295d7333eb893d35be93e144e1767e5d9b639f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;active&lt;/code&gt; is specified as an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), that number is added to the socket's counting of data messages to be delivered to the controlling process. If the result of the addition is negative, the count is set to &lt;code&gt;0&lt;/code&gt;. Once the count reaches &lt;code&gt;0&lt;/code&gt;, either through the delivery of messages or by being explicitly set with &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, the socket mode is automatically reset to passive (&lt;code&gt;{active, false}&lt;/code&gt;). When a socket in this active mode transitions to passive mode, the message &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; is sent to the controlling process to notify it that if it wants to receive more data messages from the socket, it must call &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; to set the socket back into an active mode.</source>
          <target state="translated">Si &lt;code&gt;active&lt;/code&gt; se especifica como un n&amp;uacute;mero entero &lt;code&gt;N&lt;/code&gt; en el rango -32768 a 32767 (inclusive), ese n&amp;uacute;mero se agrega al conteo de mensajes de datos del socket que se entregar&amp;aacute;n al proceso de control. Si el resultado de la suma es negativo, el recuento se establece en &lt;code&gt;0&lt;/code&gt; . Una vez que el recuento llega a &lt;code&gt;0&lt;/code&gt; , ya sea a trav&amp;eacute;s de la entrega de mensajes o al establecerse expl&amp;iacute;citamente con &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; , el modo de socket se restablece autom&amp;aacute;ticamente a pasivo ( &lt;code&gt;{active, false}&lt;/code&gt; ). Cuando un conector en este modo activo &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; al modo pasivo, el mensaje {sctp_passive, Socket} se env&amp;iacute;a al proceso de control para notificarle que si desea recibir m&amp;aacute;s mensajes de datos del conector, debe llamar &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; para volver a poner el socket en modo activo.</target>
        </trans-unit>
        <trans-unit id="03b183ed01691db59614d150f25d033d938031cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alloc&lt;/code&gt; succeeds, &lt;code&gt;dealloc&lt;/code&gt; is also executed. If &lt;code&gt;alloc&lt;/code&gt; fails however, &lt;code&gt;dealloc&lt;/code&gt; is not executed but marked as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log. &lt;code&gt;get_resource_status&lt;/code&gt; runs no matter what happens to the &lt;code&gt;alloc_and_dealloc&lt;/code&gt; cases.</source>
          <target state="translated">Si &lt;code&gt;alloc&lt;/code&gt; tiene &amp;eacute;xito, tambi&amp;eacute;n se ejecuta &lt;code&gt;dealloc&lt;/code&gt; . &lt;code&gt;alloc&lt;/code&gt; embargo, si alloc falla, &lt;code&gt;dealloc&lt;/code&gt; no se ejecuta pero se marca como &lt;code&gt;SKIPPED&lt;/code&gt; en el registro HTML. &lt;code&gt;get_resource_status&lt;/code&gt; se ejecuta sin importar lo que suceda con los casos &lt;code&gt;alloc_and_dealloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="352b5321f6cc2147596cc6f32fa64b28aba14c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;answer_3xxx&lt;/code&gt; then requests are answered without a &lt;code&gt;handle_request/3&lt;/code&gt; callback taking place. If &lt;code&gt;answer&lt;/code&gt; then even 5xxx errors are answered without a callback unless the connection in question has configured the RFC 3588 common dictionary as noted below. If &lt;code&gt;callback&lt;/code&gt; then a &lt;code&gt;handle_request/3&lt;/code&gt; callback always takes place and its return value determines the answer sent to the peer, if any.</source>
          <target state="translated">Si &lt;code&gt;answer_3xxx&lt;/code&gt; , las solicitudes se responden sin que se &lt;code&gt;handle_request/3&lt;/code&gt; una devoluci&amp;oacute;n de llamada handle_request / 3 . Si &lt;code&gt;answer&lt;/code&gt; , incluso los errores 5xxx se responden sin una devoluci&amp;oacute;n de llamada, a menos que la conexi&amp;oacute;n en cuesti&amp;oacute;n haya configurado el diccionario com&amp;uacute;n RFC 3588 como se indica a continuaci&amp;oacute;n. Si &lt;code&gt;callback&lt;/code&gt; y luego una &lt;code&gt;handle_request/3&lt;/code&gt; de devoluci&amp;oacute;n de llamada se realiza siempre y su valor de retorno determina la respuesta enviada a los pares, en su caso.</target>
        </trans-unit>
        <trans-unit id="cdb44b71a12e090bedfcba4386a9f7329590c298" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;audit_trail_log&lt;/code&gt; specifies that logging should take place, this parameter &lt;strong&gt;must&lt;/strong&gt; be defined.</source>
          <target state="translated">Si &lt;code&gt;audit_trail_log&lt;/code&gt; especifica que se debe realizar el registro, este par&amp;aacute;metro &lt;strong&gt;debe&lt;/strong&gt; definirse.</target>
        </trans-unit>
        <trans-unit id="5c3452c6586d61bda15fc59fe771d58878ac0b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;auto_ack&lt;/code&gt; is true, then if &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, ack's will be sent immediately. If &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then ack's will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;auto_ack&lt;/code&gt; es verdadero, entonces si &lt;code&gt;trans_ack&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , los ack se enviar&amp;aacute;n inmediatamente. Si &lt;code&gt;trans_ack&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces los ack se enviar&amp;aacute;n al proceso del remitente de la transacci&amp;oacute;n para su acumulaci&amp;oacute;n y env&amp;iacute;o posterior (consulte &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; y &lt;code&gt;trans_timer&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f3ff30c8bf2c3590c81efa740a7d601076daf88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; then errors result in a &lt;code&gt;handle_answer/4&lt;/code&gt; callback in the same fashion as for &lt;code&gt;handle_request/3&lt;/code&gt;, with errors communicated in the &lt;code&gt;errors&lt;/code&gt; field of the &lt;code&gt;#diameter_packet{}&lt;/code&gt; passed to the callback. If &lt;code&gt;report&lt;/code&gt; then an answer containing errors is discarded without a callback and a warning report is written to the log. If &lt;code&gt;discard&lt;/code&gt; then an answer containing errors is silently discarded without a callback. In both the &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; cases the return value for the &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; invocation in question is as if a callback had taken place and returned &lt;code&gt;{error, failure}&lt;/code&gt;.</source>
          <target state="translated">Si la &lt;code&gt;callback&lt;/code&gt; , los errores dan como resultado una devoluci&amp;oacute;n &lt;code&gt;handle_answer/4&lt;/code&gt; llamada handle_answer / 4 de la misma manera que para &lt;code&gt;handle_request/3&lt;/code&gt; , con errores comunicados en el campo de &lt;code&gt;errors&lt;/code&gt; del &lt;code&gt;#diameter_packet{}&lt;/code&gt; pasado a la devoluci&amp;oacute;n de llamada. Si &lt;code&gt;report&lt;/code&gt; , una respuesta que contiene errores se descarta sin una devoluci&amp;oacute;n de llamada y se escribe un informe de advertencia en el registro. Si se &lt;code&gt;discard&lt;/code&gt; , una respuesta que contenga errores se descarta silenciosamente sin una devoluci&amp;oacute;n de llamada. Tanto en el caso de &lt;code&gt;report&lt;/code&gt; como en el de &lt;code&gt;discard&lt;/code&gt; , el valor de retorno de la invocaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; en cuesti&amp;oacute;n es como si se hubiera realizado una devoluci&amp;oacute;n de llamada y se hubiera devuelto &lt;code&gt;{error, failure}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62c065b9fb27488b0e771951e56438f1b6383335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch4&lt;/code&gt; is part of the application &lt;code&gt;sp_app&lt;/code&gt; and a new version of the module is to be loaded when upgrading from version &quot;1&quot; to &quot;2&quot; of this application, &lt;code&gt;sp_app.appup&lt;/code&gt; can look as follows:</source>
          <target state="translated">Si &lt;code&gt;ch4&lt;/code&gt; es parte de la aplicaci&amp;oacute;n &lt;code&gt;sp_app&lt;/code&gt; y se va a cargar una nueva versi&amp;oacute;n del m&amp;oacute;dulo al actualizar de la versi&amp;oacute;n &quot;1&quot; a la &quot;2&quot; de esta aplicaci&amp;oacute;n, &lt;code&gt;sp_app.appup&lt;/code&gt; puede tener el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="704192b50b25e6b4c8a4a69ec853e8732712c9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cp1&lt;/code&gt; goes down, the system checks which one of the other nodes, &lt;code&gt;cp2&lt;/code&gt; or &lt;code&gt;cp3&lt;/code&gt;, has the least number of running applications, but waits for 5 seconds for &lt;code&gt;cp1&lt;/code&gt; to restart. If &lt;code&gt;cp1&lt;/code&gt; does not restart and &lt;code&gt;cp2&lt;/code&gt; runs fewer applications than &lt;code&gt;cp3&lt;/code&gt;, &lt;code&gt;myapp&lt;/code&gt; is restarted on &lt;code&gt;cp2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;cp1&lt;/code&gt; deja de funcionar , el sistema verifica cu&amp;aacute;l de los otros nodos, &lt;code&gt;cp2&lt;/code&gt; o &lt;code&gt;cp3&lt;/code&gt; , tiene la menor cantidad de aplicaciones en ejecuci&amp;oacute;n, pero espera 5 segundos para que &lt;code&gt;cp1&lt;/code&gt; se reinicie. Si &lt;code&gt;cp1&lt;/code&gt; no se reinicia y &lt;code&gt;cp2&lt;/code&gt; ejecuta menos aplicaciones que &lt;code&gt;cp3&lt;/code&gt; , &lt;code&gt;myapp&lt;/code&gt; se reinicia en &lt;code&gt;cp2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b17771800350279f555431c07bc7909375d85a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ct_run&lt;/code&gt; is called with option &lt;code&gt;-help&lt;/code&gt;, it prints all valid start flags to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">Si se llama a &lt;code&gt;ct_run&lt;/code&gt; con la opci&amp;oacute;n &lt;code&gt;-help&lt;/code&gt; , imprime todos los indicadores de inicio v&amp;aacute;lidos en &lt;code&gt;stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d7ad1711ae125314f622ecddd1f476bedaa098f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;drop_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;flush_qlen&lt;/code&gt;, drop mode is disabled and can never occur.</source>
          <target state="translated">Si &lt;code&gt;drop_mode_qlen&lt;/code&gt; se establece en el mismo valor que &lt;code&gt;flush_qlen&lt;/code&gt; , el modo de ca&amp;iacute;da est&amp;aacute; deshabilitado y nunca puede ocurrir.</target>
        </trans-unit>
        <trans-unit id="173618b78a011b048e525d9c552841f6185552f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_call/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_call/3&lt;/code&gt; no est&amp;aacute; definido, se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="585b6dae1b75f75f6d17ff008d7c715232f527c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b7353e255834b234c18ea03d27108e34a19f8a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_ports/3&lt;/code&gt; no est&amp;aacute; definido, se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="7d175b45d5ebd8073a81917e2e671529596546a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_procs/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ebe9ceea886c3c6d1719971aa43295e9c7ed38b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_receive/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_receive/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10f4f080f33a6c7add14620c4ce363f7b8950eec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_running_ports/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c4a84bb3f76762c65d3520facf2a72bcfc1f2ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_running_procs/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b251834b95dc454e5654dddcf65d7d5d05abbdf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_send/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_send/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48960527f8e8df817720dc59ec79a9e715127fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, the &lt;code&gt;read_line/1&lt;/code&gt; call fails if the data contains characters larger than 255, why module &lt;code&gt;io(3)&lt;/code&gt; is to be preferred when reading such a file.</source>
          <target state="translated">Si la &lt;code&gt;encoding&lt;/code&gt; se establece en algo diferente a &lt;code&gt;latin1&lt;/code&gt; , la llamada &lt;code&gt;read_line/1&lt;/code&gt; falla si los datos contienen caracteres mayores que 255, por qu&amp;eacute; se prefiere el m&amp;oacute;dulo &lt;code&gt;io(3)&lt;/code&gt; al leer dicho archivo.</target>
        </trans-unit>
        <trans-unit id="02ece68d22a0388d64a0607adb76ac441dd5ca33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the (unfortunately undocumented) &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="translated">Si se va a usar &lt;code&gt;epmd&lt;/code&gt; para el descubrimiento de nodos, normalmente querr&amp;aacute; usar el m&amp;oacute;dulo &lt;code&gt;erl_epmd&lt;/code&gt; (desafortunadamente no documentado) (parte de la aplicaci&amp;oacute;n del &lt;code&gt;kernel&lt;/code&gt; ) para registrar el puerto de escucha con &lt;code&gt;epmd&lt;/code&gt; y recuperar la &lt;code&gt;Creation&lt;/code&gt; para usar.</target>
        </trans-unit>
        <trans-unit id="e48eb5a7215dde7b0dc8037cba2427a3618b189d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the server adds HTTP header fields preventing proxies from caching the page. This is generally a good idea for dynamic content, as the content often varies between each request. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;erl_script_nocache&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , el servidor agrega campos de encabezado HTTP evitando que los proxies almacenen la p&amp;aacute;gina en cach&amp;eacute;. En general, esta es una buena idea para el contenido din&amp;aacute;mico, ya que el contenido suele variar entre cada solicitud. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74b3b9e997b2f242f5469345dd4b6f37734c75d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_timeout&lt;/code&gt; sets the time in seconds the server waits between each chunk of data to be delivered through &lt;code&gt;mod_esi:deliver/2&lt;/code&gt;. Default is &lt;code&gt;15&lt;/code&gt;. This is only relevant for scripts that use the erl scheme.</source>
          <target state="translated">Si &lt;code&gt;erl_script_timeout&lt;/code&gt; establece el tiempo en segundos, el servidor espera entre cada fragmento de datos que se entregar&amp;aacute; a trav&amp;eacute;s de &lt;code&gt;mod_esi:deliver/2&lt;/code&gt; . El valor predeterminado es &lt;code&gt;15&lt;/code&gt; . Esto solo es relevante para los scripts que usan el esquema erl.</target>
        </trans-unit>
        <trans-unit id="a7c49f84d1938c55d129db8f559247ec6ced174b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;error_logger&lt;/code&gt; no est&amp;aacute; definido en el mapa, se usa el sistema predeterminado. El valor predeterminado del sistema es &lt;code&gt;true&lt;/code&gt; . Se puede cambiar con la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1f0b5e86017500297a623ccd787481972405c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ev&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, all ones that is &lt;code&gt;-1&lt;/code&gt; type cast to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; are returned.</source>
          <target state="translated">Si &lt;code&gt;ev&lt;/code&gt; es &lt;code&gt;NULL&lt;/code&gt; , se devuelven todos los que son de tipo &lt;code&gt;-1&lt;/code&gt; convertidos a &lt;code&gt;ErlDrvSizeT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20a523dc7e77a84691bbad3e5ffc300c86d69172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit&lt;/code&gt; then the transport process in question exits. If &lt;code&gt;handle&lt;/code&gt; then the message is processed as usual, a resulting &lt;code&gt;handle_request/3&lt;/code&gt; or &lt;code&gt;handle_answer/4&lt;/code&gt; callback (if one takes place) indicating the &lt;code&gt;5015&lt;/code&gt; error (DIAMETER_INVALID_MESSAGE_LENGTH). If &lt;code&gt;discard&lt;/code&gt; then the message in question is silently discarded.</source>
          <target state="translated">Si &lt;code&gt;exit&lt;/code&gt; se cierra el proceso de transporte en cuesti&amp;oacute;n. Si &lt;code&gt;handle&lt;/code&gt; , el mensaje se procesa como de costumbre, una devoluci&amp;oacute;n &lt;code&gt;handle_answer/4&lt;/code&gt; llamada &lt;code&gt;handle_request/3&lt;/code&gt; o handle_answer / 4 resultante (si se produce una) que indica el error &lt;code&gt;5015&lt;/code&gt; (DIAMETER_INVALID_MESSAGE_LENGTH). Si se &lt;code&gt;discard&lt;/code&gt; , el mensaje en cuesti&amp;oacute;n se descarta silenciosamente.</target>
        </trans-unit>
        <trans-unit id="ca99bf6a729fabb69715993d01ee3f7329b5f3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, Epp}&lt;/code&gt;.</source>
          <target state="translated">Si se especifica &lt;code&gt;extra&lt;/code&gt; en &lt;code&gt;Options&lt;/code&gt; , el valor de retorno es &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; lugar de &lt;code&gt;{ok, Epp}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="621b05f8dd3dbf24d54370fe9dfbe14fc856ec52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, [Form]}&lt;/code&gt;.</source>
          <target state="translated">Si se especifica &lt;code&gt;extra&lt;/code&gt; en &lt;code&gt;Options&lt;/code&gt; , el valor de retorno es &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; lugar de &lt;code&gt;{ok, [Form]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3047d3a672144cba0e123255c2c3997f12bb72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; (passive mode, the default), the caller must do an explicit &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; call to retrieve the available data from the socket.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; (modo pasivo, el predeterminado), la persona que llama debe hacer una llamada expl&amp;iacute;cita de &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; para recuperar los datos disponibles del socket.</target>
        </trans-unit>
        <trans-unit id="56e3643f360d9383768007f097296d7135ef22f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then peers are not shared. If &lt;code&gt;[node()]&lt;/code&gt; then peers are shared with the specified list of nodes. If &lt;code&gt;eval()&lt;/code&gt; then peers are shared with the nodes returned by the specified function, evaluated whenever a peer connection becomes available or a remote service requests information about local connections. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored, so a collection of services can all be configured to share with the same list of nodes.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , los pares no se comparten. Si &lt;code&gt;[node()]&lt;/code&gt; , los pares se comparten con la lista de nodos especificada. Si &lt;code&gt;eval()&lt;/code&gt; , los pares se comparten con los nodos devueltos por la funci&amp;oacute;n especificada, se eval&amp;uacute;an siempre que una conexi&amp;oacute;n de pares est&amp;aacute; disponible o un servicio remoto solicita informaci&amp;oacute;n sobre las conexiones locales. El valor &lt;code&gt;true&lt;/code&gt; es equivalente a &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; . El valor &lt;code&gt;node()&lt;/code&gt; en una lista se ignora, por lo que una colecci&amp;oacute;n de servicios se puede configurar para compartir con la misma lista de nodos.</target>
        </trans-unit>
        <trans-unit id="61331cf5138ed4df60722b0902d831feeb5514c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then remote peers are not used. If &lt;code&gt;[node()]&lt;/code&gt; then only peers from the specified list of nodes are used. If &lt;code&gt;eval()&lt;/code&gt; then only peers returned by the specified function are used, evaluated whenever a remote service communicates information about an available peer connection. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , no se utilizan pares remotos. Si &lt;code&gt;[node()]&lt;/code&gt; , solo se utilizan los pares de la lista de nodos especificada. Si &lt;code&gt;eval()&lt;/code&gt; , solo se utilizan los pares devueltos por la funci&amp;oacute;n especificada, evaluados siempre que un servicio remoto comunica informaci&amp;oacute;n sobre una conexi&amp;oacute;n de pares disponible. El valor &lt;code&gt;true&lt;/code&gt; es equivalente a &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; . Se ignora el valor &lt;code&gt;node()&lt;/code&gt; en una lista.</target>
        </trans-unit>
        <trans-unit id="515f5f660b2b6a5321a3301134d45702f7c8d34e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the &lt;code&gt;known_hosts&lt;/code&gt; file, or supplying a password.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , inhabilita al cliente para que se conecte al servidor si se necesita alguna interacci&amp;oacute;n del usuario, como aceptar que el servidor se agregue al archivo &lt;code&gt;known_hosts&lt;/code&gt; o proporcionar una contrase&amp;ntilde;a.</target>
        </trans-unit>
        <trans-unit id="2f21ed8efde9cbba7a84e9561d2bee32978fafa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, the key is not saved and the key will still be unknown at the next access of the same host.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , la clave no se guarda y la clave seguir&amp;aacute; siendo desconocida en el pr&amp;oacute;ximo acceso del mismo host.</target>
        </trans-unit>
        <trans-unit id="6c171a334054ea3d178b695378164bb4717dbc73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="translated">Si &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; devuelve &lt;code&gt;latin1&lt;/code&gt; , no se realiza ninguna traducci&amp;oacute;n de los nombres de las rutas.</target>
        </trans-unit>
        <trans-unit id="174e5b29f214dbcb97eabc33b079cdd65ed3ff4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="translated">Si &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; devuelve &lt;code&gt;utf8&lt;/code&gt; , los nombres de ruta se codifican en UTF-8 cuando se crean archivos tar y se supone que los nombres de ruta est&amp;aacute;n codificados en UTF-8 cuando se extraen archivos tar.</target>
        </trans-unit>
        <trans-unit id="53f00d54c4cf2784d07f86c8a1f69d22126e8edd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;final&lt;/code&gt; is returned, the time offset was already in the final state. This either because another &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; call or because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Si se devuelve &lt;code&gt;final&lt;/code&gt; , el desplazamiento de tiempo ya estaba en el estado final. Esto se debe a otra &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; o porque &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; se usa el modo time warp .</target>
        </trans-unit>
        <trans-unit id="7d84ff72a66a5f1dc4702c44281724bb233b3cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, the backup includes only those objects that have been created, modified, or deleted since the last backup or restore (that is, an incremental backup). After the backup, any objects that were marked dirty are now clean, and any objects that had been marked for deletion are deleted.</source>
          <target state="translated">Si &lt;code&gt;flags&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; , la copia de seguridad incluye solo aquellos objetos que se han creado, modificado o eliminado desde la &amp;uacute;ltima copia de seguridad o restauraci&amp;oacute;n (es decir, una copia de seguridad incremental). Despu&amp;eacute;s de la copia de seguridad, todos los objetos que se marcaron como sucios ahora est&amp;aacute;n limpios y todos los objetos que se marcaron para su eliminaci&amp;oacute;n se eliminan.</target>
        </trans-unit>
        <trans-unit id="1b22e611455eedf00229374381cf3ded5d86286d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;int *size&lt;/code&gt; is required, so that the size of the object can be returned.</source>
          <target state="translated">Si &lt;code&gt;flags&lt;/code&gt; es &lt;code&gt;EI_BIN&lt;/code&gt; , se requiere un quinto argumento &lt;code&gt;int *size&lt;/code&gt; , de modo que se pueda devolver el tama&amp;ntilde;o del objeto.</target>
        </trans-unit>
        <trans-unit id="5d03c462ed0e1501d3ca648701da33656f727855" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;size&lt;/code&gt; is required, indicating the size in bytes of the object pointed to by &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;flags&lt;/code&gt; es &lt;code&gt;EI_BIN&lt;/code&gt; , se requiere un quinto &lt;code&gt;size&lt;/code&gt; argumento , que indica el tama&amp;ntilde;o en bytes del objeto al que apunta &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="07a12847c8010acaf74585bb590e3d2d2892d7bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Si se especifica &lt;code&gt;hibernate&lt;/code&gt; lugar de un valor de tiempo de espera, el proceso entra en hibernaci&amp;oacute;n cuando espera que llegue el siguiente mensaje (llamando a &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="81060f399c0748631583d69217b03e975ffd94c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_group&lt;/code&gt; is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se omite &lt;code&gt;init_per_group&lt;/code&gt; , esta funci&amp;oacute;n se llama despu&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a09af08638c9468193e1b25b2f9c1bcc8d0b0d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; exists, it is called initially before the test cases are executed. It typically contains initializations common for all test cases in the suite, which are only to be performed once. &lt;code&gt;init_per_suite&lt;/code&gt; is recommended for setting up and verifying state and environment on the System Under Test (SUT) or the &lt;code&gt;Common Test&lt;/code&gt; host node, or both, so that the test cases in the suite executes correctly. The following are examples of initial configuration operations:</source>
          <target state="translated">Si &lt;code&gt;init_per_suite&lt;/code&gt; existe, se llama inicialmente antes de que se ejecuten los casos de prueba. Por lo general, contiene inicializaciones comunes para todos los casos de prueba de la suite, que solo deben realizarse una vez. &lt;code&gt;init_per_suite&lt;/code&gt; se recomienda para configurar y verificar el estado y el entorno en el sistema bajo prueba (SUT) o el nodo host de &lt;code&gt;Common Test&lt;/code&gt; , o ambos, para que los casos de prueba de la suite se ejecuten correctamente. Los siguientes son ejemplos de operaciones de configuraci&amp;oacute;n inicial:</target>
        </trans-unit>
        <trans-unit id="e3cc6a46f9d6f7424ecfecec26999fd0b60da6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, all test cases in the test suite are skipped automatically (so called &lt;strong&gt;auto skipped&lt;/strong&gt;), including &lt;code&gt;end_per_suite&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;init_per_suite&lt;/code&gt; falla, todos los casos de prueba en el conjunto de pruebas se omiten autom&amp;aacute;ticamente (lo que se denomina &lt;strong&gt;auto omitido&lt;/strong&gt; ), incluido &lt;code&gt;end_per_suite&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894e342a0e85afde6f3b96340c645a2b4dd22b1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;init_per_suite&lt;/code&gt; falla, esta funci&amp;oacute;n se llama despu&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe02f751dfef43151df61c0738ad37b3fb27d99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes (called &lt;strong&gt;auto skipped&lt;/strong&gt;).</source>
          <target state="translated">Si &lt;code&gt;init_per_testcase&lt;/code&gt; falla (lo que se denomina &lt;strong&gt;auto omitido&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="7150a88f54c0b7881134625da98b5bed12371c8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes, or returns &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt;, function &lt;code&gt;end_per_testcase&lt;/code&gt; is not called.</source>
          <target state="translated">Si &lt;code&gt;init_per_testcase&lt;/code&gt; falla o devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; o &lt;code&gt;{fail,Reason}&lt;/code&gt; , no se llama a la funci&amp;oacute;n &lt;code&gt;end_per_testcase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89e72fa5ab521b91a322a6c022357a5ac272ea72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; exists, it is called before each test case in the suite. It typically contains initialization that must be done for each test case (analog to &lt;code&gt;init_per_suite&lt;/code&gt; for the suite).</source>
          <target state="translated">Si existe &lt;code&gt;init_per_testcase&lt;/code&gt; , se llama antes de cada caso de prueba en la suite. Por lo general, contiene una inicializaci&amp;oacute;n que debe realizarse para cada caso de prueba (an&amp;aacute;logo a &lt;code&gt;init_per_suite&lt;/code&gt; para la suite).</target>
        </trans-unit>
        <trans-unit id="72f622c1b041a5f9b4ffb1e9a77eb43b9ec5d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; returns a tuple &lt;code&gt;{skip,Reason}&lt;/code&gt; (called &lt;strong&gt;user skipped&lt;/strong&gt;).</source>
          <target state="translated">Si &lt;code&gt;init_per_testcase&lt;/code&gt; devuelve una tupla &lt;code&gt;{skip,Reason}&lt;/code&gt; (llamado &lt;strong&gt;usuario omitido&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="d395c2bde7c4e5cd016e96c83e2790c6164bde6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt; are implemented similarly, we could write a &lt;code&gt;generic_access&lt;/code&gt; function using the &lt;code&gt;ListOfExtraArguments&lt;/code&gt;:</source>
          <target state="translated">Si &lt;code&gt;ip_access&lt;/code&gt; y &lt;code&gt;name_access&lt;/code&gt; se implementan de manera similar, podr&amp;iacute;amos escribir una funci&amp;oacute;n &lt;code&gt;generic_access&lt;/code&gt; usando &lt;code&gt;ListOfExtraArguments&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab359c8b6df991113724100b5a067f71b56dbab9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns the atom &lt;code&gt;false&lt;/code&gt;, some error has occurred and the server sends back the message:</source>
          <target state="translated">Si la &lt;code&gt;keysearch&lt;/code&gt; devuelve el &amp;aacute;tomo &lt;code&gt;false&lt;/code&gt; , se ha producido alg&amp;uacute;n error y el servidor devuelve el mensaje:</target>
        </trans-unit>
        <trans-unit id="471dd07d8c17d433b665f7f28142ddb0c9a5ccb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns:</source>
          <target state="translated">Si la &lt;code&gt;keysearch&lt;/code&gt; regresa:</target>
        </trans-unit>
        <trans-unit id="8473687ede2e043c5626f2dc6d081f3c7f8c834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;kill&lt;/code&gt; no est&amp;aacute; definido en el mapa, se usar&amp;aacute; el sistema predeterminado. El valor predeterminado del sistema es &lt;code&gt;true&lt;/code&gt; . Se puede cambiar con la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;erl(1)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bce3cc2e82b9a6fd5502ccdd6aead42b567ec06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;local&lt;/code&gt; is specified as argument, Debugger interprets code only at the current node. If &lt;code&gt;global&lt;/code&gt; is specified as argument, Debugger interprets code at all known nodes, this is the default.</source>
          <target state="translated">Si se especifica &lt;code&gt;local&lt;/code&gt; como argumento, Debugger interpreta el c&amp;oacute;digo solo en el nodo actual. Si se especifica &lt;code&gt;global&lt;/code&gt; como argumento, Debugger interpreta el c&amp;oacute;digo en todos los nodos conocidos, este es el valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="f7b7e2ac7280eca021f5062e79e83b7222745d33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m:fact/1&lt;/code&gt; is called with a negative number as argument, no clause head matches. A &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">Si se llama a &lt;code&gt;m:fact/1&lt;/code&gt; con un n&amp;uacute;mero negativo como argumento, ning&amp;uacute;n encabezado de cl&amp;aacute;usula coincide. Se produce un error de tiempo de ejecuci&amp;oacute;n de &lt;code&gt;function_clause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78902773cd5b20b28d3f472a6d23e48932225627" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;master&lt;/code&gt;, one master agent is started. Otherwise, no agents are started.</source>
          <target state="translated">Si es &lt;code&gt;master&lt;/code&gt; , se inicia un agente maestro. De lo contrario, no se inicia ning&amp;uacute;n agente.</target>
        </trans-unit>
        <trans-unit id="ababfa264cf2c0471a517629bda5d420f24412f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maximum&lt;/code&gt; is passed as &lt;code&gt;Type&lt;/code&gt; and the emulator is not run in instrumented mode.</source>
          <target state="translated">Si el &lt;code&gt;maximum&lt;/code&gt; se pasa como &lt;code&gt;Type&lt;/code&gt; y el emulador no se ejecuta en modo instrumentado.</target>
        </trans-unit>
        <trans-unit id="fb16ce380eb14a73a96ecf98dda7ccaebbde8485" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mon&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, a successful call stores the identity of the monitor in the &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; struct pointed to by &lt;code&gt;mon&lt;/code&gt;. This identifier is used to refer to the monitor for later removal with &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; or compare with &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt;. A monitor is automatically removed when it triggers or when the resource is deallocated.</source>
          <target state="translated">Si &lt;code&gt;mon&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , una llamada exitosa almacena la identidad del monitor en la estructura &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; apuntada por &lt;code&gt;mon&lt;/code&gt; . Este identificador se utiliza para hacer referencia al monitor para su posterior eliminaci&amp;oacute;n con &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; o comparar con &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; . Un monitor se elimina autom&amp;aacute;ticamente cuando se activa o cuando se desasigna el recurso.</target>
        </trans-unit>
        <trans-unit id="e7557ef34e7c482b82151565597fe49987e4f520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg_env&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;msg&lt;/code&gt; term is copied and the original term and its environment is still valid after the call.</source>
          <target state="translated">Si &lt;code&gt;msg_env&lt;/code&gt; se establece en &lt;code&gt;NULL&lt;/code&gt; , el t&amp;eacute;rmino &lt;code&gt;msg&lt;/code&gt; se copia y el t&amp;eacute;rmino original y su entorno siguen siendo v&amp;aacute;lidos despu&amp;eacute;s de la llamada.</target>
        </trans-unit>
        <trans-unit id="3324f7db747bf81fb1767f13442861504e9e2dd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;myapp&lt;/code&gt; is running at &lt;code&gt;cp3&lt;/code&gt;, and if &lt;code&gt;cp2&lt;/code&gt; now restarts, it does not restart &lt;code&gt;myapp&lt;/code&gt;, as the order between the &lt;code&gt;cp2&lt;/code&gt; and &lt;code&gt;cp3&lt;/code&gt; nodes is undefined.</source>
          <target state="translated">Si &lt;code&gt;myapp&lt;/code&gt; se est&amp;aacute; ejecutando en &lt;code&gt;cp3&lt;/code&gt; , y si &lt;code&gt;cp2&lt;/code&gt; ahora se reinicia, no reinicia &lt;code&gt;myapp&lt;/code&gt; , ya que el orden entre los nodos &lt;code&gt;cp2&lt;/code&gt; y &lt;code&gt;cp3&lt;/code&gt; no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="410c990db3f3097c54b66efc65b17fbe9e2bad60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nc&lt;/code&gt; is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carrier allocated by this allocator is roughly &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; when &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt;, and &lt;code&gt;lmbcs&lt;/code&gt; when &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt;. If the value of parameter &lt;code&gt;sbct&lt;/code&gt; is larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, the allocator may have to create multiblock carriers that are larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, though. Singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; are sized to whole pages.</source>
          <target state="translated">Si &lt;code&gt;nc&lt;/code&gt; es el n&amp;uacute;mero actual de portadoras multibloque (excluida la portadora multibloque principal) gestionada por un asignador, el tama&amp;ntilde;o de la siguiente &lt;code&gt;mseg_alloc&lt;/code&gt; multibloque mseg_alloc asignada por este asignador es aproximadamente &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; cuando &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt; y &lt;code&gt;lmbcs&lt;/code&gt; cuando &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt; . Sin embargo, si el valor del par&amp;aacute;metro &lt;code&gt;sbct&lt;/code&gt; es mayor que el valor del par&amp;aacute;metro &lt;code&gt;lmbcs&lt;/code&gt; , el asignador puede tener que crear portadoras multibloque que sean mayores que el valor del par&amp;aacute;metro &lt;code&gt;lmbcs&lt;/code&gt; . Los portadores de bloque &amp;uacute;nico asignados a trav&amp;eacute;s de &lt;code&gt;mseg_alloc&lt;/code&gt; tienen el tama&amp;ntilde;o de p&amp;aacute;ginas enteras.</target>
        </trans-unit>
        <trans-unit id="00a9d4efd00c94ba68d6320fea95c0909f36f665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated file sync operation is disabled, and it is the operating system settings that determine how quickly or slowly data is written to disk. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a file sync.</source>
          <target state="translated">Si &lt;code&gt;no_repeat&lt;/code&gt; se establece como valor, la operaci&amp;oacute;n de sincronizaci&amp;oacute;n de archivos repetida se deshabilita y son las configuraciones del sistema operativo las que determinan qu&amp;eacute; tan r&amp;aacute;pido o lento se escriben los datos en el disco. El usuario tambi&amp;eacute;n puede llamar a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; para realizar una sincronizaci&amp;oacute;n de archivos.</target>
        </trans-unit>
        <trans-unit id="960e9f5afba10edf0b60921b0e8e69fa2c34179d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="translated">Si &lt;code&gt;no_repeat&lt;/code&gt; se establece como valor, la operaci&amp;oacute;n de sincronizaci&amp;oacute;n repetida se deshabilita. El usuario tambi&amp;eacute;n puede llamar a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; para realizar una sincronizaci&amp;oacute;n disk_log.</target>
        </trans-unit>
        <trans-unit id="92fc938fa7cba74ec1f9bb43ffd7daba5627a4cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;erl_connect()&lt;/code&gt; if necessary.</source>
          <target state="translated">Si el &lt;code&gt;node&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , es un puntero a un b&amp;uacute;fer donde la funci&amp;oacute;n puede completar el nombre del nodo donde se encuentra el &lt;code&gt;name&lt;/code&gt; . &lt;code&gt;node&lt;/code&gt; se puede pasar directamente a &lt;code&gt;erl_connect()&lt;/code&gt; si es necesario.</target>
        </trans-unit>
        <trans-unit id="8bcb0ecfc7e63283704c689b708fb3722abb28bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;once&lt;/code&gt;, only one message is automatically placed in the message queue, and after that the mode is automatically reset to passive. This provides flow control and the possibility for the receiver to listen for its incoming SCTP data interleaved with other inter-process messages.</source>
          <target state="translated">Si es &lt;code&gt;once&lt;/code&gt; , solo un mensaje se coloca autom&amp;aacute;ticamente en la cola de mensajes, y luego el modo se restablece autom&amp;aacute;ticamente a pasivo. Esto proporciona control de flujo y la posibilidad de que el receptor escuche sus datos SCTP entrantes intercalados con otros mensajes entre procesos.</target>
        </trans-unit>
        <trans-unit id="ef8342250cfaa0e36ec9bd08880c6f82e62cfce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;after&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is stopped. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;os_sup_enable&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , esta funci&amp;oacute;n se debe llamar &lt;strong&gt;despu&amp;eacute;s de que&lt;/strong&gt; OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; se detenga. &lt;code&gt;Dir&lt;/code&gt; define el directorio que contiene la copia de seguridad y los archivos de configuraci&amp;oacute;n espec&amp;iacute;ficos de Erlang para &lt;code&gt;syslogd&lt;/code&gt; , y una canalizaci&amp;oacute;n con nombre para recibir los mensajes de &lt;code&gt;syslogd&lt;/code&gt; . El valor predeterminado es &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; . &lt;code&gt;Conf&lt;/code&gt; define el nombre completo del archivo de configuraci&amp;oacute;n para &lt;code&gt;syslogd&lt;/code&gt; . El valor predeterminado es &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a700fd6dad9f4c64ccd4666632fae200f7d79bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;before&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is started. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;os_sup_enable&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , esta funci&amp;oacute;n se debe llamar &lt;strong&gt;antes de que se&lt;/strong&gt; inicie OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; . &lt;code&gt;Dir&lt;/code&gt; define el directorio que contiene la copia de seguridad y los archivos de configuraci&amp;oacute;n espec&amp;iacute;ficos de Erlang para &lt;code&gt;syslogd&lt;/code&gt; , y una canalizaci&amp;oacute;n con nombre para recibir los mensajes de &lt;code&gt;syslogd&lt;/code&gt; . El valor predeterminado es &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; . &lt;code&gt;Conf&lt;/code&gt; define el nombre completo del archivo de configuraci&amp;oacute;n para &lt;code&gt;syslogd&lt;/code&gt; . El valor predeterminado es &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77f7d7d94477bf710f75a97f120cb44318c86bb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preliminary&lt;/code&gt; is returned, finalization was performed and the time offset is now final.</source>
          <target state="translated">Si se devuelve &lt;code&gt;preliminary&lt;/code&gt; , se realiz&amp;oacute; la finalizaci&amp;oacute;n y la compensaci&amp;oacute;n de tiempo ahora es definitiva.</target>
        </trans-unit>
        <trans-unit id="31a44d264c5bd3a087ba168aa0cf5ef541ffc19d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read/2&lt;/code&gt; calls are for sizes not significantly less than, or even greater than &lt;code&gt;Size&lt;/code&gt; bytes, no performance gain can be expected.</source>
          <target state="translated">Si las llamadas de &lt;code&gt;read/2&lt;/code&gt; son para tama&amp;ntilde;os que no sean significativamente menores o incluso mayores que los bytes de &lt;code&gt;Size&lt;/code&gt; , no se puede esperar una ganancia de rendimiento.</target>
        </trans-unit>
        <trans-unit id="3f7ab732c2a40901f7be417a921a39c57a4d5b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only get requests are logged.</source>
          <target state="translated">Si se especifica &lt;code&gt;read&lt;/code&gt; , solo se registran las solicitudes de obtenci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3b544ab09dc82eacf7049bd88c54823547cf046b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only received messages are logged.</source>
          <target state="translated">Si se especifica &lt;code&gt;read&lt;/code&gt; , solo se registran los mensajes recibidos.</target>
        </trans-unit>
        <trans-unit id="4b7ba5f30d6fa892ea1037782ff4251339643dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">Si &lt;code&gt;read_concurrency&lt;/code&gt; estaba habilitado para la tabla.</target>
        </trans-unit>
        <trans-unit id="b29a25b884982cf8d002411e5810c5627d5ba822" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, all requests are logged.</source>
          <target state="translated">Si es &lt;code&gt;read_write&lt;/code&gt; , se registran todas las solicitudes.</target>
        </trans-unit>
        <trans-unit id="015bb54da55bcc930a4cbf6d43e9056cf7cdedf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, both outgoing and incoming messages are logged.</source>
          <target state="translated">Si es &lt;code&gt;read_write&lt;/code&gt; , se registran tanto los mensajes salientes como los entrantes.</target>
        </trans-unit>
        <trans-unit id="b1376e2f35266b87691b21e50d6085d572b9fcbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;registered_name&lt;/code&gt; is part of &lt;code&gt;ItemList&lt;/code&gt; and the process has no name registered, a &lt;code&gt;{registered_name, []}&lt;/code&gt;, &lt;code&gt;InfoTuple&lt;/code&gt;&lt;strong&gt;will&lt;/strong&gt; be included in the resulting &lt;code&gt;InfoTupleList&lt;/code&gt;. This behavior is different when a single &lt;code&gt;Item =:= registered_name&lt;/code&gt; is specified, and when &lt;code&gt;process_info/1&lt;/code&gt; is used.</source>
          <target state="translated">Si &lt;code&gt;registered_name&lt;/code&gt; es parte de &lt;code&gt;ItemList&lt;/code&gt; y el proceso no tiene nombre registrado, un &lt;code&gt;{registered_name, []}&lt;/code&gt; , &lt;code&gt;InfoTuple&lt;/code&gt; &lt;strong&gt;ser&amp;aacute;&lt;/strong&gt; ser incluido en la resultante &lt;code&gt;InfoTupleList&lt;/code&gt; . Este comportamiento es diferente cuando se especifica un solo &lt;code&gt;Item =:= registered_name&lt;/code&gt; y cuando se usa &lt;code&gt;process_info/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5b2b100f53895b2b8688baa94d7b9678f28feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;remove_handler&lt;/code&gt; is returned, the event handler is deleted by calling &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt;.</source>
          <target state="translated">Si se devuelve &lt;code&gt;remove_handler&lt;/code&gt; , el controlador de eventos se elimina llamando a &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="068df812b1be7a5c6fb7ba1d84c59687bbec92c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the HTTP server by default adds the header fields necessary to prevent proxies from caching the page. Generally this is preferred. Default to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;script_nocache&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , el servidor HTTP agrega de forma predeterminada los campos de encabezado necesarios para evitar que los servidores proxy almacenen la p&amp;aacute;gina en cach&amp;eacute;. Generalmente se prefiere esto. Predeterminado a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d372c1d474f731f0f4b202ab8bda7211457e68a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_env/4&lt;/code&gt; is called before the application is loaded, the application environment values specified in file &lt;code&gt;Application.app&lt;/code&gt; override the ones previously set. This is also true for application reloads.</source>
          <target state="translated">Si se llama a &lt;code&gt;set_env/4&lt;/code&gt; antes de que se cargue la aplicaci&amp;oacute;n, los valores del entorno de la aplicaci&amp;oacute;n especificados en el archivo &lt;code&gt;Application.app&lt;/code&gt; anulan los establecidos anteriormente. Esto tambi&amp;eacute;n es cierto para las recargas de aplicaciones.</target>
        </trans-unit>
        <trans-unit id="82d435019a14ecf65737ecf3db3bfd456332513c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the size of the head is placed there.</source>
          <target state="translated">Si el &lt;code&gt;size&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , el tama&amp;ntilde;o de la cabeza se coloca all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="4feb70b4204ade06d5e528b8d52ed62d294cf47b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stop&lt;/code&gt; is returned, the log event is immediately discarded. If the filter is primary, no handler filters or callbacks are called. If it is a handler filter, the corresponding handler callback is not called, but the log event is forwarded to filters attached to the next handler, if any.</source>
          <target state="translated">Si se devuelve &lt;code&gt;stop&lt;/code&gt; , el evento de registro se descarta inmediatamente. Si el filtro es primario, no se llaman filtros de controlador ni devoluciones de llamada. Si se trata de un filtro de controlador, no se llama a la devoluci&amp;oacute;n de llamada del controlador correspondiente, pero el evento de registro se reenv&amp;iacute;a a los filtros adjuntos al siguiente controlador, si corresponde.</target>
        </trans-unit>
        <trans-unit id="4b0fd3902aab568d673cab668aeb876afecb3d16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, all log events are handled synchronously. That is, asynchronous logging is disabled.</source>
          <target state="translated">Si &lt;code&gt;sync_mode_qlen&lt;/code&gt; se establece en &lt;code&gt;0&lt;/code&gt; , todos los eventos de registro se manejan sincr&amp;oacute;nicamente. Es decir, el registro asincr&amp;oacute;nico est&amp;aacute; deshabilitado.</target>
        </trans-unit>
        <trans-unit id="fe26b781dc9f18c574b4f5cea83e1dc7a0898036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;drop_mode_qlen&lt;/code&gt;, synchronous mode is disabled. That is, the handler always runs in asynchronous mode, unless dropping or flushing is invoked.</source>
          <target state="translated">Si &lt;code&gt;sync_mode_qlen&lt;/code&gt; se establece en el mismo valor que &lt;code&gt;drop_mode_qlen&lt;/code&gt; , el modo s&amp;iacute;ncrono est&amp;aacute; deshabilitado. Es decir, el controlador siempre se ejecuta en modo asincr&amp;oacute;nico, a menos que se invoque la eliminaci&amp;oacute;n o el vaciado.</target>
        </trans-unit>
        <trans-unit id="df2d416ddedf4f1525642d418b4917eca16a89fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; identifies a node local port, this function initializes the port variable &lt;code&gt;*port_id&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the port is alive.</source>
          <target state="translated">Si &lt;code&gt;term&lt;/code&gt; identifica un puerto local de nodo, esta funci&amp;oacute;n inicializa la variable de puerto &lt;code&gt;*port_id&lt;/code&gt; y devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;false&lt;/code&gt; . No se realiza ninguna comprobaci&amp;oacute;n para ver si el puerto est&amp;aacute; activo.</target>
        </trans-unit>
        <trans-unit id="bb931f96868f0894c3ee44964627cb220396fbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is a tuple, this function sets &lt;code&gt;*array&lt;/code&gt; to point to an array containing the elements of the tuple, and sets &lt;code&gt;*arity&lt;/code&gt; to the number of elements. Notice that the array is read-only and &lt;code&gt;(*array)[N-1]&lt;/code&gt; is the Nth element of the tuple. &lt;code&gt;*array&lt;/code&gt; is undefined if the arity of the tuple is zero.</source>
          <target state="translated">Si &lt;code&gt;term&lt;/code&gt; es una tupla, esta funci&amp;oacute;n establece &lt;code&gt;*array&lt;/code&gt; para que apunte a una matriz que contiene los elementos de la tupla, y establece &lt;code&gt;*arity&lt;/code&gt; en el n&amp;uacute;mero de elementos. Observe que la matriz es de solo lectura y &lt;code&gt;(*array)[N-1]&lt;/code&gt; es el en&amp;eacute;simo elemento de la tupla. &lt;code&gt;*array&lt;/code&gt; no est&amp;aacute; definida si la aridad de la tupla es cero.</target>
        </trans-unit>
        <trans-unit id="99ce7d95b89f5e150dfbf95c1a3d757a096ea716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is the pid of a node local process, this function initializes the pid variable &lt;code&gt;*pid&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the process is alive.</source>
          <target state="translated">Si &lt;code&gt;term&lt;/code&gt; es el pid de un proceso local de nodo, esta funci&amp;oacute;n inicializa la variable &lt;code&gt;*pid&lt;/code&gt; y devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;false&lt;/code&gt; . No se realiza ninguna comprobaci&amp;oacute;n para ver si el proceso est&amp;aacute; activo.</target>
        </trans-unit>
        <trans-unit id="335749543c3f3f2a3a67c44896ae9fd2f2a9abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;throw/1&lt;/code&gt; is not evaluated within a catch, a &lt;code&gt;nocatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Si &lt;code&gt;throw/1&lt;/code&gt; no se eval&amp;uacute;a dentro de un ret&amp;eacute;n, un &lt;code&gt;nocatch&lt;/code&gt; se produce un error en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="531f47b8f34afb9e971187a621871b405723e46a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="translated">Si no se establece &lt;code&gt;timetrap&lt;/code&gt; o &lt;code&gt;require&lt;/code&gt; , se utilizan los valores predeterminados especificados por &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (o &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="976ebeb2288ae33fa6c9a2ec2a28980aa636376c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="translated">Si &lt;code&gt;timetrap&lt;/code&gt; o &lt;code&gt;require&lt;/code&gt; , o ambos, no se configuran espec&amp;iacute;ficamente para un caso de prueba en particular, se utilizan los valores predeterminados especificados por el &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; funciones / 0 .</target>
        </trans-unit>
        <trans-unit id="744ac3e017c02db9473330a8d4a2dec44a7e8e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_call/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_call/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="9e1c20b572719c3331469687919f2defd8437750" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6da64932aab510304a9e86727b1e2bcbdfe8f0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_ports/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="50d620a56eb39b36411e41b4bc5a97c7bbafbd69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_procs/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="9603bcd32c947b80ea34517cb4f3a01b71d378ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_receive/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_receive/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="df75f373657f0f91332cb47e91e892abb9c113a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_running_ports/5&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama al &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5559d0a97110b67775d63df3a3e94529bc745fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_running_procs/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="93b8b767ba992ffc91ebcedb4793839177d0df72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_send/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_send/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="901bf723e7561c2418b0b1c71d7584f891124177" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then request(s) will be sent immediately (in its own message).</source>
          <target state="translated">Si &lt;code&gt;trans_req&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , las solicitudes se enviar&amp;aacute;n inmediatamente (en su propio mensaje).</target>
        </trans-unit>
        <trans-unit id="680ea9ebc8cd511dd23a5a2d9935ba441ee109e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is true, then request(s) will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;trans_req&lt;/code&gt; es verdadero, las solicitudes se enviar&amp;aacute;n en su lugar al proceso del remitente de la transacci&amp;oacute;n para su acumulaci&amp;oacute;n y env&amp;iacute;o posterior (consulte &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; y &lt;code&gt;trans_timer&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="e48e65bf83526cb9dd2dcc5eaa66577b4aa53e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode), the pending data or events are sent to the owning process.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; (modo activo completo), los datos o eventos pendientes se env&amp;iacute;an al proceso propietario.</target>
        </trans-unit>
        <trans-unit id="f6d949864e0ff9ac2295f12de502f8af44fe5554" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the configuration files are re-read during start-up, and the contents of the configuration database ignored. Thus, if &lt;code&gt;true&lt;/code&gt;, changes to the configuration database are lost upon reboot of the agent.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; los archivos de configuraci&amp;oacute;n se vuelven a leer durante el inicio y se ignora el contenido de la base de datos de configuraci&amp;oacute;n. Por lo tanto, si es &lt;code&gt;true&lt;/code&gt; , los cambios en la base de datos de configuraci&amp;oacute;n se pierden al reiniciar el agente.</target>
        </trans-unit>
        <trans-unit id="5742f9a48f2a77c8abfa93b7448bf87101200ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, hibernates the &lt;code&gt;gen_statem&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; before going into &lt;code&gt;receive&lt;/code&gt; to wait for a new external event.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , hiberna &lt;code&gt;gen_statem&lt;/code&gt; llamando a &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; antes de entrar en &lt;code&gt;receive&lt;/code&gt; para esperar un nuevo evento externo.</target>
        </trans-unit>
        <trans-unit id="1c34bbe208e229e88b9cf884fe83c6e4487267fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, induces an error on an attempt to send a message larger than the current PMTU size (which would require fragmentation/reassembling). Notice that message fragmentation does not affect the logical atomicity of its delivery; this option is provided for performance reasons only.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , induce un error al intentar enviar un mensaje m&amp;aacute;s grande que el tama&amp;ntilde;o actual de PMTU (que requerir&amp;iacute;a fragmentaci&amp;oacute;n / reensamblaje). Observe que la fragmentaci&amp;oacute;n del mensaje no afecta la atomicidad l&amp;oacute;gica de su entrega; esta opci&amp;oacute;n se proporciona &amp;uacute;nicamente por motivos de rendimiento.</target>
        </trans-unit>
        <trans-unit id="14dea9808b1f89c089706dd845be50b4ae8f0440" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if binds to the IP address. If &lt;code&gt;false&lt;/code&gt;, net_if listens on any IP address on the host where it is running.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , net_if se une a la direcci&amp;oacute;n IP. Si es &lt;code&gt;false&lt;/code&gt; , net_if escucha cualquier direcci&amp;oacute;n IP en el host donde se est&amp;aacute; ejecutando.</target>
        </trans-unit>
        <trans-unit id="1a887d631ac5987f669427d5f352faeefbf326b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if does not specify that the IP and port address should be reusable. If &lt;code&gt;false&lt;/code&gt;, the address is set to reusable.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , net_if no especifica que la IP y la direcci&amp;oacute;n del puerto deben ser reutilizables. Si es &lt;code&gt;false&lt;/code&gt; , la direcci&amp;oacute;n se configura como reutilizable.</target>
        </trans-unit>
        <trans-unit id="5cd4ac0f7d30d624066e424ed5179bc26eafc35f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it when the state changes (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , pospone el evento actual y vuelve a &lt;code&gt;NextState =/= State&lt;/code&gt; cuando cambia el estado ( NextState = / = State ).</target>
        </trans-unit>
        <trans-unit id="520af4aded931229fa7189fca614aa3fa7995a83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the agent is multi-threaded, with one thread for each get request.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , el agente tiene varios subprocesos, con un subproceso para cada solicitud de obtenci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="89015f594d36423a0e641bd12c827ea801ee5cfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client does not print anything on authorization.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , el cliente no imprime nada en la autorizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="23b8e026fd6aadff53ba83122b74ea4391419aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , el cliente guarda una clave de host aceptada para evitar la pregunta de aceptaci&amp;oacute;n la pr&amp;oacute;xima vez que se conecte el mismo host. Si la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; no est&amp;aacute; presente, la clave se guarda en el archivo &quot;known_hosts&quot;. Consulte la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; para conocer la ubicaci&amp;oacute;n de ese archivo.</target>
        </trans-unit>
        <trans-unit id="b356ac942be95783b518ac898149e69ff7f29e06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the execution time and reductions are accumulated.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , se acumulan el tiempo de ejecuci&amp;oacute;n y las reducciones.</target>
        </trans-unit>
        <trans-unit id="a2c9b567f4306cd17d762c08a52cc878115d08b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the log owners are notified when certain log events occur. Defaults to &lt;code&gt;false&lt;/code&gt;. The owners are sent one of the following messages when an event occurs:</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , se notifica a los propietarios del registro cuando se producen determinados eventos del registro. Por defecto es &lt;code&gt;false&lt;/code&gt; . A los propietarios se les env&amp;iacute;a uno de los siguientes mensajes cuando ocurre un evento:</target>
        </trans-unit>
        <trans-unit id="dac3885367e9c29a28f95ee9e91f474fd1b0d8a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; replace any program forms that could not be parsed with nodes of type &lt;code&gt;text&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt;), representing the raw token sequence of the form, instead of reporting a parse error. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , esto hace que &lt;code&gt;epp_dodger&lt;/code&gt; reemplace cualquier formulario de programa que no pueda ser analizado con nodos de tipo &lt;code&gt;text&lt;/code&gt; o (ver &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt; ), que representa la secuencia de token sin formato del formulario, en lugar de informar un error de an&amp;aacute;lisis. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78d87db40121a7b6b4e4f2f28996811db47d8d7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, or &lt;code&gt;T&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="translated">Si se usa &lt;code&gt;u&lt;/code&gt; como identificador de subsistema (es decir, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt; ), se efect&amp;uacute;an todos los asignadores basados ​​en &lt;code&gt;alloc_util&lt;/code&gt; . Si se usa &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; o &lt;code&gt;T&lt;/code&gt; como identificador de subsistema, solo se efect&amp;uacute;a el identificador de asignador espec&amp;iacute;fico.</target>
        </trans-unit>
        <trans-unit id="784b625fc8171fa4983940bde7848ec14a3e23bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;volatile&lt;/code&gt; is returned, the time offset cannot be finalized because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Si se devuelve &lt;code&gt;volatile&lt;/code&gt; , el desplazamiento de tiempo no se puede finalizar porque se utiliza el &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20c03db910bef2b3379b92930db1f3ebc527788d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only sent messages are logged.</source>
          <target state="translated">Si se especifica &lt;code&gt;write&lt;/code&gt; , solo se registran los mensajes enviados.</target>
        </trans-unit>
        <trans-unit id="a95ad12798c19a97f99824236c8f188c8076b6b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only set requests are logged.</source>
          <target state="translated">Si se especifica &lt;code&gt;write&lt;/code&gt; , solo se registran las solicitudes de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b0db310b8af51df282663eafc88eec4c7003919f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">Si se habilit&amp;oacute; &lt;code&gt;write_concurrency&lt;/code&gt; para la tabla.</target>
        </trans-unit>
        <trans-unit id="d130e60ef67783037417bccce56bcf5768c8e099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; is returned, the emulator is restarted before the upgrade instructions are executed. This occurs if the emulator or any of the applications Kernel, STDLIB, or SASL are updated. The new emulator version and these core applications execute after the restart. For all other applications the old versions are started and the upgrade is performed as normal by executing the upgrade instructions.</source>
          <target state="translated">Si se &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; , el emulador se reinicia antes de que se ejecuten las instrucciones de actualizaci&amp;oacute;n. Esto ocurre si se actualiza el emulador o cualquiera de las aplicaciones Kernel, STDLIB o SASL. La nueva versi&amp;oacute;n del emulador y estas aplicaciones principales se ejecutan despu&amp;eacute;s del reinicio. Para todas las dem&amp;aacute;s aplicaciones, se inician las versiones anteriores y la actualizaci&amp;oacute;n se realiza normalmente mediante la ejecuci&amp;oacute;n de las instrucciones de actualizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="320cf62f527c030692a3479a90eabc62ad79a175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned immediately, the call to &lt;code&gt;parse_and_scan/1&lt;/code&gt; returns &lt;code&gt;{ok, eof}&lt;/code&gt;. If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned before the parser expects end of input, &lt;code&gt;parse_and_scan/1&lt;/code&gt; will, of course, return an error message (see above). Otherwise &lt;code&gt;{ok, Result}&lt;/code&gt; is returned.</source>
          <target state="translated">Si se &lt;code&gt;{eof, Endline}&lt;/code&gt; inmediatamente, la llamada a &lt;code&gt;parse_and_scan/1&lt;/code&gt; devuelve &lt;code&gt;{ok, eof}&lt;/code&gt; . Si se &lt;code&gt;{eof, Endline}&lt;/code&gt; antes de que el analizador espere el final de la entrada, &lt;code&gt;parse_and_scan/1&lt;/code&gt; , por supuesto, devolver&amp;aacute; un mensaje de error (ver arriba). De lo contrario &lt;code&gt;{ok, Result}&lt;/code&gt; se devuelve {ok, Result} .</target>
        </trans-unit>
        <trans-unit id="dedb9788552103a1f455c74f781f00865ba7c935" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{merge_tests,true}&lt;/code&gt; is set in the source specification (which is the default setting), terms in joined specifications are merged with terms in the source specification (according to the description of &lt;code&gt;merge_tests&lt;/code&gt; earlier).</source>
          <target state="translated">Si se establece &lt;code&gt;{merge_tests,true}&lt;/code&gt; en la especificaci&amp;oacute;n de origen (que es la configuraci&amp;oacute;n predeterminada), los t&amp;eacute;rminos de las especificaciones unidas se fusionan con los t&amp;eacute;rminos de la especificaci&amp;oacute;n de origen (seg&amp;uacute;n la descripci&amp;oacute;n de &lt;code&gt;merge_tests&lt;/code&gt; anterior).</target>
        </trans-unit>
        <trans-unit id="e19028ea4203966a6e00632a19c4871950b28ef8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{noreply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt;, or &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process continues executing with &lt;code&gt;NewState&lt;/code&gt;. Any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;{noreply,NewState}&lt;/code&gt; , &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt; o &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt; , el proceso &lt;code&gt;gen_server&lt;/code&gt; contin&amp;uacute;a ejecut&amp;aacute;ndose con &lt;code&gt;NewState&lt;/code&gt; . Cualquier respuesta a &lt;code&gt;From&lt;/code&gt; debe especificarse expl&amp;iacute;citamente usando &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e1637361f321011df9f0024cdad416df7e559bbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="translated">Si se &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; , el administrador de eventos tambi&amp;eacute;n entra en hibernaci&amp;oacute;n (llamando a &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ), esperando que ocurra el siguiente evento. Es suficiente que uno de los controladores de eventos devuelva &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; para que todo el proceso del administrador de eventos hiberne .</target>
        </trans-unit>
        <trans-unit id="7bf6373c4c4feb0b7b12ba83feca28174cdeeb31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState}&lt;/code&gt; or &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event handler remains in the event manager with the possible updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;{ok,NewState}&lt;/code&gt; o &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; , el controlador de eventos permanece en el administrador de eventos con el posible estado interno actualizado &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="622b2b9487b410e4b5c3a44646686c10053b1e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; is returned, the event manager goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; , el administrador de eventos entra en hibernaci&amp;oacute;n (llamando a &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ), esperando que ocurra el pr&amp;oacute;ximo evento.</target>
        </trans-unit>
        <trans-unit id="4733cd19b2819c31e3b9d228b0a9153e3ac1bda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; or &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt;, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt; as the return value of &lt;code&gt;call/2,3&lt;/code&gt; or included in the return value of &lt;code&gt;multi_call/2,3,4&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then continues executing with the possibly updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; , {responder, Responder, Nuevo estado, Tiempo de espera} o &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt; , &lt;code&gt;Reply&lt;/code&gt; se devuelve a &lt;code&gt;From&lt;/code&gt; como el valor de retorno de la &lt;code&gt;call/2,3&lt;/code&gt; o se incluye en el valor de retorno de &lt;code&gt;multi_call/2,3,4&lt;/code&gt; . El proceso &lt;code&gt;gen_server&lt;/code&gt; contin&amp;uacute;a ejecut&amp;aacute;ndose con el estado interno posiblemente actualizado &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf8d1c1849381a9a2934c0c67001278a230ee2f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{save_calls,N}&lt;/code&gt; has been set for the process, no function calls are saved to the call saving list. (The call saving list is not cleared. Also, send, receive, and time-out events are still added to the list.)</source>
          <target state="translated">Si se ha configurado &lt;code&gt;{save_calls,N}&lt;/code&gt; para el proceso, no se guardan llamadas de funci&amp;oacute;n en la lista de guardado de llamadas. (La lista para guardar llamadas no se borra. Adem&amp;aacute;s, los eventos de env&amp;iacute;o, recepci&amp;oacute;n y tiempo de espera a&amp;uacute;n se agregan a la lista).</target>
        </trans-unit>
        <trans-unit id="bfb24986f0a70731e0b63f3291fa396e2f3c519f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start + Length&lt;/code&gt; is &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si se especifica &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; en las opciones tales que &lt;code&gt;Start&lt;/code&gt; &amp;gt; tama&amp;ntilde;o del &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt;0 o &lt;code&gt;Start + Length&lt;/code&gt; es&amp;gt; tama&amp;ntilde;o del &lt;code&gt;Subject&lt;/code&gt; , se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="de6994202966362118bb8cacc9efab5d034d0b7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si se especifica &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; en las opciones tales como &lt;code&gt;Start&lt;/code&gt; &amp;gt; tama&amp;ntilde;o del &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt;0 o &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; tama&amp;ntilde;o del &lt;code&gt;Subject&lt;/code&gt; , se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="2eb02f05292552a7ce9695f8e039ca2486be0efc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; , se omiten todos los casos de prueba del grupo y el &lt;code&gt;Reason&lt;/code&gt; se imprime en el registro general del grupo.</target>
        </trans-unit>
        <trans-unit id="07c6e6c33ab904cab102b2ef7313020f30f3b33b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; , se omiten todos los casos de prueba del m&amp;oacute;dulo y el &lt;code&gt;Reason&lt;/code&gt; se imprime en la p&amp;aacute;gina de resultados HTML.</target>
        </trans-unit>
        <trans-unit id="7176131e2ab61dc6ca1a310323b87e804a6b01fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; , se omiten todos los casos de prueba de la suite y la &lt;code&gt;Reason&lt;/code&gt; se imprime en el registro general de la suite.</target>
        </trans-unit>
        <trans-unit id="1d2a5b747d22c7eede603eddd2e58170ad2ad7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; , el caso de prueba se salta y el &lt;code&gt;Reason&lt;/code&gt; se imprime en el registro general de la suite.</target>
        </trans-unit>
        <trans-unit id="43c5190e594ca77d2bcd9761108619b8160ca730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; is returned, any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then calls &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; and terminates.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; , cualquier respuesta a &lt;code&gt;From&lt;/code&gt; debe especificarse expl&amp;iacute;citamente usando &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; . El proceso &lt;code&gt;gen_server&lt;/code&gt; luego llama a &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; y termina.</target>
        </trans-unit>
        <trans-unit id="555db6a996a08647cb4789219558187a695b3e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt;.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; , se devuelve la &lt;code&gt;Reply&lt;/code&gt; a &lt;code&gt;From&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f07068ef6474408f3b2f01c567a6aa9dc31fae9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; is returned, the event handler is replaced by &lt;code&gt;Handler2&lt;/code&gt; by first calling &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; and then &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; , el controlador de eventos se reemplaza por &lt;code&gt;Handler2&lt;/code&gt; llamando primero a &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; y luego a &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; , donde &lt;code&gt;Term&lt;/code&gt; es el valor de retorno del &lt;code&gt;Module:terminate/2&lt;/code&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54e845975dbb16c88ec10ada23488e780175ae56" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;any&lt;/strong&gt; of the &lt;strong&gt;other&lt;/strong&gt; callback functions crashes (exit, throw or a plain crash) or return an invalid result (if a valid return has been specified), this function is called. The purpose is to allow the user handle this error (for instance to issue an error report).</source>
          <target state="translated">Si &lt;strong&gt;alguna&lt;/strong&gt; de las &lt;strong&gt;otras&lt;/strong&gt; funciones de devoluci&amp;oacute;n de llamada falla (salir, lanzar o un bloqueo simple) o devuelve un resultado no v&amp;aacute;lido (si se ha especificado una devoluci&amp;oacute;n v&amp;aacute;lida), se llama a esta funci&amp;oacute;n. El prop&amp;oacute;sito es permitir que el usuario maneje este error (por ejemplo, emitir un informe de error).</target>
        </trans-unit>
        <trans-unit id="937ff2e79e3364cc35a718607a325fdce946f46d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Si es &lt;strong&gt;falso&lt;/strong&gt; , los mensajes megaco se env&amp;iacute;an mediante la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a26b3170e7ada86a34e6bf52ec13abf6a58d809" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Si es &lt;strong&gt;falso&lt;/strong&gt; , los mensajes megaco se env&amp;iacute;an mediante la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d618248269dc3ffbf51a67242f81007c8e747d1d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;true&lt;/strong&gt;, megaco message &lt;strong&gt;re-sends&lt;/strong&gt; are made using the &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; function. The initial message send is still done using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Si &lt;strong&gt;cierto&lt;/strong&gt; , Megaco mensaje &lt;strong&gt;vuelve a enviar&lt;/strong&gt; se realizan utilizando el &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; funci&amp;oacute;n. El env&amp;iacute;o del mensaje inicial a&amp;uacute;n se realiza mediante la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6705ceafbe769b2ce43385b2299973a524847817" translate="yes" xml:space="preserve">
          <source>If A and B are matched, but there is a failure in C, matching does not backtrack into A; instead it moves to the next alternative, that is, D. However, if the subpattern containing (*THEN) is given an alternative, it behaves differently:</source>
          <target state="translated">Si A y B se emparejan,pero hay un fallo en C,el emparejamiento no retrocede a A,sino que pasa a la siguiente alternativa,es decir,a D.Sin embargo,si se da una alternativa al subpatrón que contiene (*THEN),se comporta de forma diferente:</target>
        </trans-unit>
        <trans-unit id="c0f5376ef787219224d7bfc3d76505fad1f25c03" translate="yes" xml:space="preserve">
          <source>If A is a subset of X, the &lt;strong id=&quot;image&quot;&gt;image&lt;/strong&gt; of A under R is the set {y : x R y for some x in A}. If B is a subset of Y, the &lt;strong id=&quot;inverse_image&quot;&gt;inverse image&lt;/strong&gt; of B is the set {x : x R y for some y in B}.</source>
          <target state="translated">Si A es un subconjunto de X, la &lt;strong id=&quot;image&quot;&gt;imagen&lt;/strong&gt; de A debajo de R es el conjunto {y: x R y para alguna x en A}. Si B es un subconjunto de Y, la &lt;strong id=&quot;inverse_image&quot;&gt;imagen inversa&lt;/strong&gt; de B es el conjunto {x: x R y para alguna y en B}.</target>
        </trans-unit>
        <trans-unit id="c7b4fe5ddbf9a00d696a1d76a1917c8c5d2aeb3e" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">Si A es una asociaci&amp;oacute;n &lt;code&gt;K := V&lt;/code&gt; , entonces Rep (A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="930fd81e91ccd105d16e4034de1e01640fca7bc6" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">Si A es una asociaci&amp;oacute;n &lt;code&gt;K =&amp;gt; V&lt;/code&gt; , entonces Rep (A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4e632ebc019048443e5c38c3f2b726fe623c1461" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">Si A es un tipo de asociaci&amp;oacute;n &lt;code&gt;K := V&lt;/code&gt; , donde &lt;code&gt;K&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; son tipos, entonces Rep (A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe916dba3dfcc9f9ef483ef2b2560b99a4239b84" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">Si A es un tipo de asociaci&amp;oacute;n &lt;code&gt;K =&amp;gt; V&lt;/code&gt; , donde &lt;code&gt;K&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; son tipos, entonces Rep (A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a746c5a2ff985d711d5a7f13e4e14806e0e62f7d" translate="yes" xml:space="preserve">
          <source>If A matches but B fails, the backtrack to (*COMMIT) causes the entire match to fail. However, if A and B match, but C fails, the backtrack to (*THEN) causes the next alternative (ABD) to be tried. This behavior is consistent, but is not always the same as in Perl. It means that if two or more backtracking verbs appear in succession, the last of them has no effect. Consider the following example:</source>
          <target state="translated">Si A coincide pero B falla,el retroceso a (*COMMIT)hace que todo el partido falle.Sin embargo,si A y B coinciden,pero C falla,el retroceso a (*ENTONCES)causa que se intente la siguiente alternativa (ABD).Este comportamiento es consistente,pero no siempre es el mismo que en Perl.Significa que si dos o más verbos de retroceso aparecen en sucesión,el último de ellos no tiene efecto.Considere el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="c2a144a893fd5d00844284a1c4ab07c469c50d04" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula de caso &lt;code&gt;P -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1982d0d507cac2d94792ff43eb098cbb5c7b07ff" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula de caso &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5272c27438c02673801bf9383134101b74af201b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;P -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt; , es decir, una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita &lt;code&gt;throw&lt;/code&gt; y con o sin una variable de seguimiento de pila expl&amp;iacute;cita &lt;code&gt;_&lt;/code&gt; no se puede distinguir de una cl&amp;aacute;usula de captura sin una clase de excepci&amp;oacute;n expl&amp;iacute;cita y sin una variable de seguimiento de pila expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="66083733733867d178cfdf05fa2ebeeb26e587ba" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; , es decir, una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita &lt;code&gt;throw&lt;/code&gt; y con o sin una variable de seguimiento de pila expl&amp;iacute;cita &lt;code&gt;_&lt;/code&gt; no se puede distinguir de una cl&amp;aacute;usula catch sin una clase de excepci&amp;oacute;n expl&amp;iacute;cita y sin una variable de seguimiento de pila expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="33763f19a17cfabb0fc3a9334e69f568d0598981" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;X&lt;/code&gt; es un literal at&amp;oacute;mico o un patr&amp;oacute;n variable, &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt; , es decir, una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita y con una variable stacktrace expl&amp;iacute;cita &lt;code&gt;_&lt;/code&gt; no se puede distinguir de una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita y sin una variable de seguimiento de pila expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="54e98e1e13987f32a2240be5fce9eca6126a89ed" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;X&lt;/code&gt; es un literal at&amp;oacute;mico o un patr&amp;oacute;n variable, &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;S&lt;/code&gt; es una variable y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ae0f4c55ba607c0c1ac95c07e874e6880664ec9" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;X&lt;/code&gt; es un literal at&amp;oacute;mico o un patr&amp;oacute;n variable, &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda, &lt;code&gt;S&lt;/code&gt; es una variable y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd09edeb30671bd8912819376a2a0342249cf516" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;X&lt;/code&gt; es un literal at&amp;oacute;mico o un patr&amp;oacute;n variable, &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; , es decir, una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita y con una variable de seguimiento de pila expl&amp;iacute;cita &lt;code&gt;_&lt;/code&gt; no se puede distinguir de una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita y sin una variable de seguimiento de pila expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="df5fe92f62215d00d030e5a7bada64a7329d2d85" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="translated">Si C es una restricci&amp;oacute;n &lt;code&gt;V :: T&lt;/code&gt; , donde &lt;code&gt;V&lt;/code&gt; es una variable de tipo y &lt;code&gt;T&lt;/code&gt; es un tipo, entonces Rep (C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17326d4fa4e4dd923f6996f5fc5f5d27a9e90bfb" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula de funci&amp;oacute;n &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;Ps&lt;/code&gt; es una secuencia de patr&amp;oacute;n y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b58b02b2d6778f5c78bfa5c91aec26b39e9b26e2" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula de funci&amp;oacute;n &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;Ps&lt;/code&gt; es una secuencia de patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bac3b590133c72b3e697e259f15ddfcb5136d5c1" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula if &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cbfab94d790c9f8ddb1d5350bddeee9c6d6348c" translate="yes" xml:space="preserve">
          <source>If CPU topology information is unavailable.</source>
          <target state="translated">Si la información de la topología de la CPU no está disponible.</target>
        </trans-unit>
        <trans-unit id="a5c3ae58fb5f8a860fea2ef9b561020e0407c0fd" translate="yes" xml:space="preserve">
          <source>If D is a module declaration consisting of the forms &lt;code&gt;F_1&lt;/code&gt;, ..., &lt;code&gt;F_k&lt;/code&gt;, then Rep(D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt;.</source>
          <target state="translated">Si D es una declaraci&amp;oacute;n de m&amp;oacute;dulo que consta de las formas &lt;code&gt;F_1&lt;/code&gt; , ..., &lt;code&gt;F_k&lt;/code&gt; , entonces Rep (D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="385f7db6a01f80887d7150e7f3e7bdd257de0fb5" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">Si E es una comprensi&amp;oacute;n de cadenas de bits &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt; , donde cada &lt;code&gt;Q_i&lt;/code&gt; es un calificador, entonces Rep (E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; . Para Rep (Q), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a58b032de54c4d5d1f61a79ea10904e5176012ef" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Si E es un constructor de cadenas de bits &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; , donde cada &lt;code&gt;Size_i&lt;/code&gt; es una expresi&amp;oacute;n y cada &lt;code&gt;TSL_i&lt;/code&gt; es una lista de tipos espec&amp;iacute;ficos, entonces Rep (E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Para Rep (TSL), consulte a continuaci&amp;oacute;n. Un &lt;code&gt;Size_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; . Un &lt;code&gt;TSL_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff0400ff578820209af4c6bca75270b191887cfe" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de bloque &lt;code&gt;begin B end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61d85721a2f8e94ee818ecc0cbe514b22d9b6e5" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt; , donde &lt;code&gt;E_0&lt;/code&gt; es una expresi&amp;oacute;n y cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula case, entonces Rep (E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20926c71a541ebeeb5a5ce9236741b97b74ee9ee" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;catch E_0&lt;/code&gt; , captura E_0 , entonces Rep (E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d685232ba5f2805f2661aa4dca2a66de454be03" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="translated">Si E es un esqueleto de contras &lt;code&gt;[E_h | E_t]&lt;/code&gt; , luego Rep (E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00326b0fd36dc640e6ce203654ecdb5f5319afc6" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt; , donde cada &lt;code&gt;Fc_i&lt;/code&gt; es una cl&amp;aacute;usula de funci&amp;oacute;n, entonces Rep (E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25e7ad524342503c66fff38de3f9fd9620fdced2" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;fun Module:Name/Arity&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt; . (Antes de Erlang / OTP R15: Rep (E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="508f3673ffdf47d28232744927849cd0723a0e7f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt; , donde &lt;code&gt;Name&lt;/code&gt; es una variable y cada &lt;code&gt;Fc_i&lt;/code&gt; es una cl&amp;aacute;usula de funci&amp;oacute;n, luego Rep (E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c55128cd4494aabe3305a25ed372470c6cb1e94" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;fun Name/Arity&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae431171a9a508e70cab829bfde9130d74f3b08a" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una llamada de funci&amp;oacute;n &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a930c4f44f20684a46e411dc14a24535a2814f3b" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una llamada de funci&amp;oacute;n &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d0a9ba22f768bf25ed619e9861b8a15d7cd9192c" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">Si E es una lista de comprensi&amp;oacute;n &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt; , donde cada &lt;code&gt;Q_i&lt;/code&gt; es un calificador, entonces Rep (E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; . Para Rep (Q), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="39c06772c585b4d5e9af41e11c7fa823e87a3781" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Si E es una creaci&amp;oacute;n de mapa &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="800dae600f3ee86ffec1de1f210ed80d17fd2b9b" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Si E es una actualizaci&amp;oacute;n de mapa &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; o &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="98ecb06f9387738ad9c4608934528d6d6501def9" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de operador de coincidencia &lt;code&gt;P = E_0&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, entonces Rep (E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="690ad831c8e62316c71be505eb989a5f5da834db" translate="yes" xml:space="preserve">
          <source>If E is a parenthesized expression &lt;code&gt;( E_0 )&lt;/code&gt;, then Rep(E) = &lt;code&gt;Rep(E_0)&lt;/code&gt;, that is, parenthesized expressions cannot be distinguished from their bodies.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n entre par&amp;eacute;ntesis &lt;code&gt;( E_0 )&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;Rep(E_0)&lt;/code&gt; , es decir, las expresiones entre par&amp;eacute;ntesis no se pueden distinguir de sus cuerpos.</target>
        </trans-unit>
        <trans-unit id="03e50f32be6fa18564dc0f97ac6d17895199c4c5" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt; , donde cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula de caso, &lt;code&gt;E_0&lt;/code&gt; es una expresi&amp;oacute;n y &lt;code&gt;B_t&lt;/code&gt; es un cuerpo, entonces Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81d96409c6d75213915ef6028c674bf71b947761" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt; , donde cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula de caso, entonces Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="769c6455ce5fde46b459e44a8ec3bffa7196d158" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una creaci&amp;oacute;n de registro &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; , donde cada &lt;code&gt;Field_i&lt;/code&gt; es un &amp;aacute;tomo o &lt;code&gt;_&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="571a72b7ca82dcb7bd3dbc0550c43c731464ee91" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Si E es un campo de registro, acceda a &lt;code&gt;E_0#Name.Field&lt;/code&gt; , donde &lt;code&gt;Field&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41585c3fb51f7eca9a3e6945efca3d137bddef8d" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Si E es un &amp;iacute;ndice de campo de registro &lt;code&gt;#Name.Field&lt;/code&gt; , donde &lt;code&gt;Field&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c141b24fbc5240a27271026022f8b84cc1c46ec" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una actualizaci&amp;oacute;n de registro &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; , donde cada &lt;code&gt;Field_i&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5433ba0e7386d18ba29df013a33a3bd71eec1de4" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B after A end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; son cuerpos, entonces Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bb0c9fd33084b3aa2b6298f495d8933521120111" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; son cuerpos, y cada &lt;code&gt;Tc_i&lt;/code&gt; es una cl&amp;aacute;usula catch, entonces Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0174ae0ac371a20fa8346b5c98865a86bb0973f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; es un cuerpo y cada &lt;code&gt;Tc_i&lt;/code&gt; es una cl&amp;aacute;usula catch, entonces Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17896fd4f3f657c1acca030c3b7c2477fd7ea070" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; son cuerpos, y cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula de caso, entonces Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f8fa527e6b0ee33c16b21df17493bd713be90d3" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; son cuerpos, cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula case, y cada &lt;code&gt;Tc_j&lt;/code&gt; es una cl&amp;aacute;usula catch, luego Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32741bd8aaa39a55dc66b9c017671086d64dc49f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; es un cuerpo, cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula case, y cada &lt;code&gt;Tc_j&lt;/code&gt; es una cl&amp;aacute;usula catch, luego Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff91a87e5952e2ad6d9b444216166d09d3ca77eb" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es un esqueleto de tupla &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1cebb18271309572b378e6bac693d831da6a5de6" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Si E es una variable &lt;code&gt;V&lt;/code&gt; , a continuaci&amp;oacute;n, Rep (E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es un &amp;aacute;tomo con un printname que consiste en los mismos caracteres que &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5399bc470d1e24b61c04135abc6ec1c48ce12a53" translate="yes" xml:space="preserve">
          <source>If E is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(E) = Rep(L).</source>
          <target state="translated">Si E es un literal at&amp;oacute;mico &lt;code&gt;L&lt;/code&gt; , entonces Rep (E) = Rep (L).</target>
        </trans-unit>
        <trans-unit id="591459a3195bdb1721ecc29118a41cd9ecf5ad76" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt; , donde cada &lt;code&gt;Ic_i&lt;/code&gt; es una cl&amp;aacute;usula if, entonces Rep (E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74042cb0d91ea528b8846bce8407c4c94e7828f3" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de operador &lt;code&gt;E_1 Op E_2&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador binario distinto del operador de coincidencia &lt;code&gt;=&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22209cbc466369d61322ba8f94065874c289f3f5" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de operador &lt;code&gt;Op E_0&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador unario, entonces Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aecc39e30213c6bf99c4212c4aeafe719ce7ed08" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Si E es nulo, &lt;code&gt;[]&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{nil,LINE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e80045470a896b7cf38c6a0866ea3eab2424863f" translate="yes" xml:space="preserve">
          <source>If Erlang is started in long name distributed mode, it needs to get the domain name from somewhere and reads system &lt;code&gt;inet&lt;/code&gt; configuration files for this information. Any hosts and resolver information found is also recorded, but not used as long as Erlang is configured for native lookups. The information becomes useful if the lookup method is changed to &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt;, see below.</source>
          <target state="translated">Si Erlang se inicia en modo distribuido de nombre largo, necesita obtener el nombre de dominio de alg&amp;uacute;n lugar y lee los archivos de configuraci&amp;oacute;n &lt;code&gt;inet&lt;/code&gt; del sistema para obtener esta informaci&amp;oacute;n. Toda la informaci&amp;oacute;n de hosts y resolutores que se encuentre tambi&amp;eacute;n se registra, pero no se utiliza siempre que Erlang est&amp;eacute; configurado para b&amp;uacute;squedas nativas. La informaci&amp;oacute;n se vuelve &amp;uacute;til si el m&amp;eacute;todo de b&amp;uacute;squeda se cambia a &lt;code&gt;'file'&lt;/code&gt; o &lt;code&gt;'dns'&lt;/code&gt; , ver m&amp;aacute;s abajo.</target>
        </trans-unit>
        <trans-unit id="8ba99b579cb5dc5d83148e021817ebf4a31439e9" translate="yes" xml:space="preserve">
          <source>If Erlang sends, for example, the list &lt;code&gt;[$a,$b,$c]&lt;/code&gt; to the port, the &lt;code&gt;bufflen&lt;/code&gt; variable is &lt;code&gt;3&lt;/code&gt; and the &lt;code&gt;buff&lt;/code&gt; variable contains &lt;code&gt;{'a','b','c'}&lt;/code&gt; (no &lt;code&gt;NULL&lt;/code&gt; termination). Usually the first byte is used as an opcode, which is the case in this driver too (at least when the port is in &lt;code&gt;command&lt;/code&gt; mode). The opcodes are defined as follows:</source>
          <target state="translated">Si Erlang env&amp;iacute;a, por ejemplo, la lista &lt;code&gt;[$a,$b,$c]&lt;/code&gt; al puerto, la variable &lt;code&gt;bufflen&lt;/code&gt; es &lt;code&gt;3&lt;/code&gt; y la variable &lt;code&gt;buff&lt;/code&gt; contiene &lt;code&gt;{'a','b','c'}&lt;/code&gt; (sin terminaci&amp;oacute;n &lt;code&gt;NULL&lt;/code&gt; ). Por lo general, el primer byte se utiliza como c&amp;oacute;digo de operaci&amp;oacute;n, que tambi&amp;eacute;n es el caso en este controlador (al menos cuando el puerto est&amp;aacute; en modo de &lt;code&gt;command&lt;/code&gt; ). Los c&amp;oacute;digos de operaci&amp;oacute;n se definen de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="914c013be868be9b46633a3fae8ef36377ee34a1" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si F es una declaraci&amp;oacute;n de funci&amp;oacute;n &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt; , donde cada &lt;code&gt;Fc_i&lt;/code&gt; es una cl&amp;aacute;usula de funci&amp;oacute;n con una secuencia de patr&amp;oacute;n de la misma longitud &lt;code&gt;Arity&lt;/code&gt; , luego Rep (F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="839e0427c2712f13a30277505b79b3f3678e27bc" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Si F es una especificaci&amp;oacute;n de funci&amp;oacute;n &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt; , donde &lt;code&gt;Spec&lt;/code&gt; es la &lt;code&gt;spec&lt;/code&gt; del &amp;aacute;tomo o la &lt;code&gt;callback&lt;/code&gt; del &amp;aacute;tomo , y cada &lt;code&gt;Ft_i&lt;/code&gt; es un tipo de funci&amp;oacute;n posiblemente restringido con una secuencia de argumentos de la misma longitud &lt;code&gt;Arity&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17271a999b9344b2a590ac6ed7fcd19ea7837c3a" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Si F es una especificaci&amp;oacute;n de funci&amp;oacute;n &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt; , donde cada &lt;code&gt;Ft_i&lt;/code&gt; es un tipo de funci&amp;oacute;n posiblemente restringido con una secuencia de argumentos de la misma longitud &lt;code&gt;Arity&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd91f9ee512189a9782c72f858106c81c42eb39a" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="translated">Si F es una declaraci&amp;oacute;n de registro &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt; , donde cada &lt;code&gt;V_i&lt;/code&gt; es un campo de registro, entonces Rep (F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; . Para Rep (V), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="eab32c665244fb293fe17fe26c52469e41031dd4" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="translated">Si F es un tipo de campo de registro &lt;code&gt;Name :: Type&lt;/code&gt; , donde &lt;code&gt;Type&lt;/code&gt; es un tipo, entonces Rep (F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31cc499e6743611a48be1c32ba0e0814b6fa811f" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Si F es una declaraci&amp;oacute;n de tipo &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt; , donde &lt;code&gt;Type&lt;/code&gt; es el &lt;code&gt;type&lt;/code&gt; &amp;aacute;tomo o el &amp;aacute;tomo &lt;code&gt;opaque&lt;/code&gt; , cada &lt;code&gt;V_i&lt;/code&gt; es una variable y &lt;code&gt;T&lt;/code&gt; es un tipo, entonces Rep (F ) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c81677bfb1fe791cbe449f2226181f612e7d5741" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo salvaje &lt;code&gt;-A(T)&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c092236a8dd4b964a8de640c01239a90a1e7a1ac" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3859e84d13f06a07d526a9d0610934ed80fd58d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo &lt;code&gt;-file(File,Line)&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bb3ff8ec37dad7da6fb624ff1aa1f2defef3f1c" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="740887309045a225d9cb600109651a0966db65e3" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo &lt;code&gt;-module(Mod)&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be0d9740980dc9bb7d3b497c88ac52e3e4ae32a4" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="translated">Si Ft es un tipo de funci&amp;oacute;n restringida &lt;code&gt;Ft_1 when Fc&lt;/code&gt; , donde &lt;code&gt;Ft_1&lt;/code&gt; es un tipo de funci&amp;oacute;n y &lt;code&gt;Fc&lt;/code&gt; es una restricci&amp;oacute;n de funci&amp;oacute;n, entonces Rep (T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt; . Para Rep (Fc), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ad272ac4cee50fc07993902e12ff74bb1a162f57" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Si Ft es un tipo de funci&amp;oacute;n &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt; , donde cada &lt;code&gt;T_i&lt;/code&gt; es un tipo, entonces Rep (Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956fa8f47f1bcedade9724b256d1fe2c59b770a8" translate="yes" xml:space="preserve">
          <source>If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt;.</source>
          <target state="translated">Si G es un grafo dirigido, sostiene que los v&amp;eacute;rtices y aristas de G son los mismos que los v&amp;eacute;rtices y aristas de &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7c4c1f8a634a58d8cf6efc770bf44b8e01c62ed" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un constructor de cadenas de bits &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; , donde cada &lt;code&gt;Size_i&lt;/code&gt; es una prueba de protecci&amp;oacute;n y cada &lt;code&gt;TSL_i&lt;/code&gt; es una lista de tipos espec&amp;iacute;ficos, entonces Rep (Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Para Rep (TSL), consulte m&amp;aacute;s arriba. Un &lt;code&gt;Size_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; . Un &lt;code&gt;TSL_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84104d736902648592238a7aed481c0fca8a1b02" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un esqueleto de contras &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt; , luego Rep (Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="155c34327c1aac1242765939018d40572e3ece41" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es una funci&amp;oacute;n llamada &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8fe106be5e00c62f004b81ec1a1e00fa0b616f14" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es una llamada de funci&amp;oacute;n &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt; , donde &lt;code&gt;A_m&lt;/code&gt; es el &amp;aacute;tomo &lt;code&gt;erlang&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; es un &amp;aacute;tomo o un operador, entonces Rep (Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da3cc863263c90fe7c570740ba4eda5e38a4f773" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Si Gt es una creaci&amp;oacute;n de mapa &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), vea arriba.</target>
        </trans-unit>
        <trans-unit id="8b68b45a396309326113e63efb931d56c934f4e8" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Si Gt es una actualizaci&amp;oacute;n de mapa &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; o &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), vea arriba.</target>
        </trans-unit>
        <trans-unit id="c71638db3891d8e47094eaea5193942aba235460" translate="yes" xml:space="preserve">
          <source>If Gt is a parenthesized guard test &lt;code&gt;( Gt_0 )&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt;, that is, parenthesized guard tests cannot be distinguished from their bodies.</source>
          <target state="translated">Si Gt es una prueba de guardia entre par&amp;eacute;ntesis &lt;code&gt;( Gt_0 )&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt; , es decir, las pruebas de guardia entre par&amp;eacute;ntesis no se pueden distinguir de sus cuerpos.</target>
        </trans-unit>
        <trans-unit id="95bc9c3e2bbe4154125f8e83e7d1dec9ccf69c3a" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es una creaci&amp;oacute;n de registro &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt; , donde cada &lt;code&gt;Field_i&lt;/code&gt; es un &amp;aacute;tomo o &lt;code&gt;_&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f5219d21b74d303638f0d998d1a523861cfd8ed" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un campo de registro, acceda a &lt;code&gt;Gt_0#Name.Field&lt;/code&gt; , donde &lt;code&gt;Field&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a706262c44fbdd9118d527a47e94cc7e8f43cf92" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un &amp;iacute;ndice de campo de registro &lt;code&gt;#Name.Field&lt;/code&gt; , donde &lt;code&gt;Field&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f481667ce91658bcad558a1af4b78b60f7692744" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un esqueleto de tupla &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f06988b89d180cb11b8982908198902c04bcea42" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un patr&amp;oacute;n variable &lt;code&gt;V&lt;/code&gt; , a continuaci&amp;oacute;n, Rep (Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , donde A es un &amp;aacute;tomo con un printname que consiste en los mismos caracteres que &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b80b2b10f76759502fc592d77587e295e44b6d5" translate="yes" xml:space="preserve">
          <source>If Gt is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(Gt) = Rep(L).</source>
          <target state="translated">Si Gt es un literal at&amp;oacute;mico &lt;code&gt;L&lt;/code&gt; , entonces Rep (Gt) = Rep (L).</target>
        </trans-unit>
        <trans-unit id="d8ecca50d53c2df91c648c581d109d377a56d333" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es una prueba de guardia de operador &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador binario distinto del operador de coincidencia &lt;code&gt;=&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="59964cf24a3c6e579aace4b47998306937171209" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un operador de guardia, prueba &lt;code&gt;Op Gt_0&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador unario, entonces Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="498668c1ce816a52c1e11cee91561fc3f7281cec" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es nulo, &lt;code&gt;[]&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d91f44fbe3739ece99b11544ff08c06f7058b62" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Si L es un car&amp;aacute;cter literal, entonces Rep (L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a70af53d75e256462e24f2a854c77741b9fe2a6" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Si L es un literal flotante, entonces Rep (L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc4e7443f3bff9431f378dad125819933dd7b906" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="translated">Si L es una cadena literal que consta de los caracteres &lt;code&gt;C_1&lt;/code&gt; , ..., &lt;code&gt;C_k&lt;/code&gt; , entonces Rep (L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c151061397c80cc4494386daf911cd7cd3768421" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Si L es un literal de &amp;aacute;tomo, entonces Rep (L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="009d689b146fb6ed54f2471e1d09e781555b973a" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Si L es un literal entero, entonces Rep (L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84cceee508e21c83ef5e5c68f567b7df3c0d24d4" translate="yes" xml:space="preserve">
          <source>If Mnesia is down on the local node, the function returns those other &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; that for the moment are operational.</source>
          <target state="translated">Si Mnesia est&amp;aacute; inactivo en el nodo local, la funci&amp;oacute;n devuelve esos otros &lt;code&gt;db_nodes&lt;/code&gt; y &lt;code&gt;extra_db_nodes&lt;/code&gt; que por el momento est&amp;aacute;n operativos.</target>
        </trans-unit>
        <trans-unit id="d2c7cf7bb11840eda288723b23ff4cc867a91195" translate="yes" xml:space="preserve">
          <source>If Mnesia is started, the function returns those nodes that Mnesia on the local node is fully connected to. Only those nodes that Mnesia has exchanged schema information with are included as &lt;code&gt;running_db_nodes&lt;/code&gt;. After the merge of schemas, the local Mnesia system is fully operable and applications can perform access of remote replicas. Before the schema merge, Mnesia only operates locally. Sometimes there are more nodes included in the &lt;code&gt;running_db_nodes&lt;/code&gt; list than all &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; together.</source>
          <target state="translated">Si se inicia Mnesia, la funci&amp;oacute;n devuelve los nodos a los que Mnesia en el nodo local est&amp;aacute; completamente conectado. Solo aquellos nodos con los que Mnesia ha intercambiado informaci&amp;oacute;n de esquema se incluyen como &lt;code&gt;running_db_nodes&lt;/code&gt; . Despu&amp;eacute;s de la fusi&amp;oacute;n de esquemas, el sistema local de Mnesia est&amp;aacute; completamente operativo y las aplicaciones pueden realizar el acceso de r&amp;eacute;plicas remotas. Antes de la fusi&amp;oacute;n de esquemas, Mnesia solo opera localmente. A veces, hay m&amp;aacute;s nodos incluidos en la lista &lt;code&gt;running_db_nodes&lt;/code&gt; que todos los &lt;code&gt;db_nodes&lt;/code&gt; y &lt;code&gt;extra_db_nodes&lt;/code&gt; juntos.</target>
        </trans-unit>
        <trans-unit id="1e5a20f661013e882b9b593b517c8c9ba753d645" translate="yes" xml:space="preserve">
          <source>If Mnesia is used as storage method, Mnesia must be started before the HTTP server. The first time Mnesia is started, the schema and the tables must be created before Mnesia is started. A simple example of a module with two functions that creates and start Mnesia is provided here. Function &lt;code&gt;first_start/0&lt;/code&gt; is to be used the first time. It creates the schema and the tables. &lt;code&gt;start/0&lt;/code&gt; is to be used in consecutive startups. &lt;code&gt;start/0&lt;/code&gt; starts Mnesia and waits for the tables to be initiated. This function must only be used when the schema and the tables are already created.</source>
          <target state="translated">Si se utiliza Mnesia como m&amp;eacute;todo de almacenamiento, Mnesia debe iniciarse antes que el servidor HTTP. La primera vez que se inicia Mnesia, el esquema y las tablas deben crearse antes de iniciar Mnesia. Aqu&amp;iacute; se proporciona un ejemplo simple de un m&amp;oacute;dulo con dos funciones que crea e inicia Mnesia. La funci&amp;oacute;n &lt;code&gt;first_start/0&lt;/code&gt; debe utilizarse la primera vez. Crea el esquema y las tablas. &lt;code&gt;start/0&lt;/code&gt; se utilizar&amp;aacute; en arranques consecutivos. &lt;code&gt;start/0&lt;/code&gt; inicia Mnesia y espera a que se inicien las tablas. Esta funci&amp;oacute;n solo debe usarse cuando el esquema y las tablas ya est&amp;aacute;n creadas.</target>
        </trans-unit>
        <trans-unit id="f34211f341486b630397795df16c3df17f3d92d3" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de cadena de bits &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; , donde cada &lt;code&gt;Size_i&lt;/code&gt; es una expresi&amp;oacute;n que se puede evaluar como un n&amp;uacute;mero entero, y cada &lt;code&gt;TSL_i&lt;/code&gt; es una lista de tipos espec&amp;iacute;ficos, entonces Rep (P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Para Rep (TSL), consulte a continuaci&amp;oacute;n. Un &lt;code&gt;Size_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; . Un &lt;code&gt;TSL_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c8c2a2980c64258557d34be973ca8c30e59cc6bc" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n compuesto &lt;code&gt;P_1 = P_2&lt;/code&gt; , entonces Rep (P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3a96a126f33c33dfd4bad3afe04a55374bef41" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de contras &lt;code&gt;[P_h | P_t]&lt;/code&gt; , luego Rep (P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd5a1996d5cee5775413b66baffcba7cfd424d8b" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de mapa &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt; , entonces Rep (P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c7fbdc51ae228be4fbd8c6e7c0ddb45260e0acb0" translate="yes" xml:space="preserve">
          <source>If P is a nil pattern &lt;code&gt;[]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n nulo &lt;code&gt;[]&lt;/code&gt; , entonces Rep (P) = &lt;code&gt;{nil,LINE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72a84ce197dfd951db7868fea8973a6459407137" translate="yes" xml:space="preserve">
          <source>If P is a parenthesized pattern &lt;code&gt;( P_0 )&lt;/code&gt;, then Rep(P) = &lt;code&gt;Rep(P_0)&lt;/code&gt;, that is, parenthesized patterns cannot be distinguished from their bodies.</source>
          <target state="translated">Si P es un patr&amp;oacute;n entre par&amp;eacute;ntesis &lt;code&gt;( P_0 )&lt;/code&gt; , entonces Rep (P) = &lt;code&gt;Rep(P_0)&lt;/code&gt; , es decir, los patrones entre par&amp;eacute;ntesis no se pueden distinguir de sus cuerpos.</target>
        </trans-unit>
        <trans-unit id="d6dae07160d27f4934f31cae5e6b4f2d04d1afc9" translate="yes" xml:space="preserve">
          <source>If P is a record field index pattern &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de &amp;iacute;ndice de campo de registro &lt;code&gt;#Name.Field&lt;/code&gt; , donde &lt;code&gt;Field&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (P) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c817b814455c0bbd5e19cc0a1e27a932ad7ae3e" translate="yes" xml:space="preserve">
          <source>If P is a record pattern &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de registro &lt;code&gt;#Name{Field_1=P_1, ..., Field_k=P_k}&lt;/code&gt; , donde cada &lt;code&gt;Field_i&lt;/code&gt; es un &amp;aacute;tomo o &lt;code&gt;_&lt;/code&gt; , entonces Rep (P) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(P_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(P_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26f2ebd069093962c3169272794269248d2ef02b" translate="yes" xml:space="preserve">
          <source>If P is a tuple pattern &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt;, then Rep(P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de tupla &lt;code&gt;{P_1, ..., P_k}&lt;/code&gt; , entonces Rep (P) = &lt;code&gt;{tuple,LINE,[Rep(P_1), ..., Rep(P_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1673a195237ed41e2323e9fba0581f25f4bc7a6c" translate="yes" xml:space="preserve">
          <source>If P is a universal pattern &lt;code&gt;_&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n universal &lt;code&gt;_&lt;/code&gt; , entonces Rep (P) = &lt;code&gt;{var,LINE,'_'}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="374e95854b4ce10a9075d7ca4749ba4604e1f66b" translate="yes" xml:space="preserve">
          <source>If P is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(P) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n variable &lt;code&gt;V&lt;/code&gt; , a continuaci&amp;oacute;n, Rep (P) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , donde A es un &amp;aacute;tomo con un printname que consiste en los mismos caracteres que &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="037087e53a14f2b5880a3446fa475c0011fde7f9" translate="yes" xml:space="preserve">
          <source>If P is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(P) = Rep(L).</source>
          <target state="translated">Si P es un literal at&amp;oacute;mico &lt;code&gt;L&lt;/code&gt; , entonces Rep (P) = Rep (L).</target>
        </trans-unit>
        <trans-unit id="3611eec9cbc1948d638f692cb3c204535c40a243" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;Op P_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de operador &lt;code&gt;Op P_0&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador unario (esto es una ocurrencia de una expresi&amp;oacute;n que se puede evaluar a un n&amp;uacute;mero en tiempo de compilaci&amp;oacute;n), entonces Rep (P) = &lt;code&gt;{op,LINE,Op,Rep(P_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c20d57a29a11d3b725da4217b551d072cb2d9645" translate="yes" xml:space="preserve">
          <source>If P is an operator pattern &lt;code&gt;P_1 Op P_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is either an occurrence of &lt;code&gt;++&lt;/code&gt; applied to a literal string or character list, or an occurrence of an expression that can be evaluated to a number at compile time), then Rep(P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de operador &lt;code&gt;P_1 Op P_2&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador binario (esto es una ocurrencia de &lt;code&gt;++&lt;/code&gt; aplicada a una cadena literal o lista de caracteres, o una ocurrencia de una expresi&amp;oacute;n que se puede evaluar a un n&amp;uacute;mero en tiempo de compilaci&amp;oacute;n ), luego Rep (P) = &lt;code&gt;{op,LINE,Op,Rep(P_1),Rep(P_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a50d35a985d1c4853945f370a6dcaf95a405ff8" translate="yes" xml:space="preserve">
          <source>If PER encoding is wanted:</source>
          <target state="translated">Si se quiere la codificación PER:</target>
        </trans-unit>
        <trans-unit id="8e69f891849831d14d1ae17a1a43b56f2f0e1d17" translate="yes" xml:space="preserve">
          <source>If Ps is a sequence of patterns &lt;code&gt;P_1, ..., P_k&lt;/code&gt;, then Rep(Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt;. Such sequences occur as the list of arguments to a function or fun.</source>
          <target state="translated">Si Ps es una secuencia de patrones &lt;code&gt;P_1, ..., P_k&lt;/code&gt; , entonces Rep (Ps) = &lt;code&gt;[Rep(P_1), ..., Rep(P_k)]&lt;/code&gt; . Tales secuencias ocurren como la lista de argumentos para una funci&amp;oacute;n o diversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="db3d9c3be41ff91340aed17068892205b8e19bdf" translate="yes" xml:space="preserve">
          <source>If Q is a bitstring generator &lt;code&gt;P &amp;lt;= E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Si Q es un generador de cadenas de bits &lt;code&gt;P &amp;lt;= E&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n y &lt;code&gt;E&lt;/code&gt; es una expresi&amp;oacute;n, entonces Rep (Q) = &lt;code&gt;{b_generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50623f16fe5c165b35f76e12f8a3d6ba87d05b14" translate="yes" xml:space="preserve">
          <source>If Q is a filter &lt;code&gt;E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;Rep(E)&lt;/code&gt;.</source>
          <target state="translated">Si Q es un filtro &lt;code&gt;E&lt;/code&gt; , donde &lt;code&gt;E&lt;/code&gt; es una expresi&amp;oacute;n, entonces Rep (Q) = &lt;code&gt;Rep(E)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ed7ef1b4d4a36ddad7dd7fceafbd179ffb47f54" translate="yes" xml:space="preserve">
          <source>If Q is a generator &lt;code&gt;P &amp;lt;- E&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Si Q es un generador &lt;code&gt;P &amp;lt;- E&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n y &lt;code&gt;E&lt;/code&gt; es una expresi&amp;oacute;n, entonces Rep (Q) = &lt;code&gt;{generate,LINE,Rep(P),Rep(E)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cee5bb555da8992e2b4f0f92c76f0e2b4698cbd0" translate="yes" xml:space="preserve">
          <source>If R is a relation from X to Y, and S is a relation from Y to Z, the &lt;strong id=&quot;relative_product&quot;&gt;relative product&lt;/strong&gt; of R and S is the relation T from X to Z defined so that x T z if and only if there exists an element y in Y such that x R y and y S z.</source>
          <target state="translated">Si R es una relaci&amp;oacute;n de X a Y, y S es una relaci&amp;oacute;n de Y a Z, el &lt;strong id=&quot;relative_product&quot;&gt;producto relativo&lt;/strong&gt; de R y S es la relaci&amp;oacute;n T de X a Z definida de modo que x T z si y solo si existe un elemento y en Y tal que x R y y y S z.</target>
        </trans-unit>
        <trans-unit id="618098342145de14043b9d049d0e27a0dbe8a5ba" translate="yes" xml:space="preserve">
          <source>If R is a relation in X, and if S is defined so that x S y if x R y and not x = y, then S is the &lt;strong id=&quot;strict_relation&quot;&gt;strict&lt;/strong&gt; relation corresponding to R. Conversely, if S is a relation in X, and if R is defined so that x R y if x S y or x = y, then R is the &lt;strong id=&quot;weak_relation&quot;&gt;weak&lt;/strong&gt; relation corresponding to S.</source>
          <target state="translated">Si R es una relaci&amp;oacute;n en X, y si S se define de modo que x S y si x R y y no x = y, entonces S es la relaci&amp;oacute;n &lt;strong id=&quot;strict_relation&quot;&gt;estricta&lt;/strong&gt; correspondiente a R. A la inversa, si S es una relaci&amp;oacute;n en X, y si R se define de modo que x R y si x S y o x = y, entonces R es la relaci&amp;oacute;n &lt;strong id=&quot;weak_relation&quot;&gt;d&amp;eacute;bil&lt;/strong&gt; correspondiente a S.</target>
        </trans-unit>
        <trans-unit id="6577b63edebfaf6cb114810862f5d1c1f7536b21" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, and x is an element of X, the &lt;strong id=&quot;equivalence_class&quot;&gt;equivalence class&lt;/strong&gt; of x with respect to R is the set of all those elements y of X for which x R y holds. The equivalence classes constitute a partitioning of X. Conversely, if C is a partition of X, the relation that holds for any two elements of X if they belong to the same equivalence class, is an equivalence relation induced by the partition C.</source>
          <target state="translated">Si R es una relaci&amp;oacute;n de equivalencia en X, yx es un elemento de X, la &lt;strong id=&quot;equivalence_class&quot;&gt;clase&lt;/strong&gt; de &lt;strong id=&quot;equivalence_class&quot;&gt;equivalencia&lt;/strong&gt; de x con respecto a R es el conjunto de todos esos elementos y de X para los que x R y se cumple. Las clases de equivalencia constituyen una partici&amp;oacute;n de X. A la inversa, si C es una partici&amp;oacute;n de X, la relaci&amp;oacute;n que se cumple para dos elementos cualesquiera de X si pertenecen a la misma clase de equivalencia, es una relaci&amp;oacute;n de equivalencia inducida por la partici&amp;oacute;n C.</target>
        </trans-unit>
        <trans-unit id="83162ddd20e00fa4a162cbcf127d9c0721481053" translate="yes" xml:space="preserve">
          <source>If R is an equivalence relation in X, the &lt;strong id=&quot;canonical_map&quot;&gt;canonical map&lt;/strong&gt; is the function that maps every element of X onto its equivalence class.</source>
          <target state="translated">Si R es una relaci&amp;oacute;n de equivalencia en X, el &lt;strong id=&quot;canonical_map&quot;&gt;mapa can&amp;oacute;nico&lt;/strong&gt; es la funci&amp;oacute;n que mapea cada elemento de X en su clase de equivalencia.</target>
        </trans-unit>
        <trans-unit id="2e3f4abb96f981c697c50aab79cfafffa5fa7e98" translate="yes" xml:space="preserve">
          <source>If S is a restriction of R to A, then R is an &lt;strong id=&quot;extension&quot;&gt;extension&lt;/strong&gt; of S to X.</source>
          <target state="translated">Si S es una restricci&amp;oacute;n de R a A, entonces R es una &lt;strong id=&quot;extension&quot;&gt;extensi&amp;oacute;n&lt;/strong&gt; de S a X.</target>
        </trans-unit>
        <trans-unit id="59bb1dc7653278e89c3f5020133ebdcc7761c491" translate="yes" xml:space="preserve">
          <source>If S is an element (T, X) of Sets, then T is a &lt;strong id=&quot;valid_type&quot;&gt;valid type&lt;/strong&gt; of X, T is the type of S, and X is the external set of S. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; creates a set from a type and an Erlang term turned into an external set.</source>
          <target state="translated">Si S es un elemento (T, X) de Conjuntos, entonces T es un &lt;strong id=&quot;valid_type&quot;&gt;tipo v&amp;aacute;lido&lt;/strong&gt; de X, T es el tipo de S y X es el conjunto externo de S. &lt;code&gt;&lt;a href=&quot;#from_term-2&quot;&gt;from_term/2&lt;/a&gt;&lt;/code&gt; crea un conjunto a partir de un tipo y un Erlang t&amp;eacute;rmino convertido en un conjunto externo.</target>
        </trans-unit>
        <trans-unit id="d08abf342530f661d47c0b2d46fbf1f0e30add56" translate="yes" xml:space="preserve">
          <source>If SASL is not included as an application in the &lt;code&gt;.rel&lt;/code&gt; file, a warning is issued because such a release cannot be used in an upgrade. To turn off this warning, add option &lt;code&gt;no_warn_sasl&lt;/code&gt;.</source>
          <target state="translated">Si SASL no se incluye como una aplicaci&amp;oacute;n en el archivo &lt;code&gt;.rel&lt;/code&gt; , se emite una advertencia porque dicha versi&amp;oacute;n no se puede utilizar en una actualizaci&amp;oacute;n. Para desactivar esta advertencia, agregue la opci&amp;oacute;n &lt;code&gt;no_warn_sasl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d446165493e24efa50be7a65b22a36a79836aa6" translate="yes" xml:space="preserve">
          <source>If SNMPv3 is used, these MIBs are loaded by default.</source>
          <target state="translated">Si se utiliza SNMPv3,estas MIB se cargan por defecto.</target>
        </trans-unit>
        <trans-unit id="99d068911d44f519900efdb97e0ebd14d390453e" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a fun, the fun is applied to each element of the given set and the return value is assumed to be a set.</source>
          <target state="translated">Si se especifica SetFun como diversión,la diversión se aplica a cada elemento del conjunto dado y se supone que el valor de retorno es un conjunto.</target>
        </trans-unit>
        <trans-unit id="e3976f1f032e302393b8bb08320950e629b9d555" translate="yes" xml:space="preserve">
          <source>If SetFun is specified as a tuple &lt;code&gt;{external, Fun}&lt;/code&gt;, Fun is applied to the external set of each element of the given set and the return value is assumed to be an external set. Selecting the elements of an unordered set as external sets and assembling a new unordered set from a list of external sets is in the present implementation more efficient than modifying each element as a set. However, this optimization can only be used when the elements of the unordered set are atomic or ordered sets. It must also be the case that the type of the elements matches some clause of Fun (the type of the created set is the result of applying Fun to the type of the given set), and that Fun does nothing but selecting, duplicating, or rearranging parts of the elements.</source>
          <target state="translated">Si SetFun se especifica como una tupla &lt;code&gt;{external, Fun}&lt;/code&gt; , Fun se aplica al conjunto externo de cada elemento del conjunto dado y se asume que el valor de retorno es un conjunto externo. Seleccionar los elementos de un conjunto desordenado como conjuntos externos y ensamblar un nuevo conjunto desordenado de una lista de conjuntos externos es, en la presente implementaci&amp;oacute;n, m&amp;aacute;s eficiente que modificar cada elemento como un conjunto. Sin embargo, esta optimizaci&amp;oacute;n solo se puede utilizar cuando los elementos del conjunto desordenado son conjuntos at&amp;oacute;micos u ordenados. Tambi&amp;eacute;n debe darse el caso de que el tipo de los elementos coincida con alguna cl&amp;aacute;usula de Fun (el tipo del conjunto creado es el resultado de aplicar Fun al tipo del conjunto dado), y que Fun no hace m&amp;aacute;s que seleccionar, duplicar o reorganizar partes de los elementos.</target>
        </trans-unit>
        <trans-unit id="43c0a8b3ea81788001f690f7e87c84083499ae45" translate="yes" xml:space="preserve">
          <source>If T is &lt;code&gt;( T_0 )&lt;/code&gt;, then Rep(T) = &lt;code&gt;Rep(T_0)&lt;/code&gt;, that is, parenthesized types cannot be distinguished from their bodies.</source>
          <target state="translated">Si T es &lt;code&gt;( T_0 )&lt;/code&gt; , entonces Rep (T) = &lt;code&gt;Rep(T_0)&lt;/code&gt; , es decir, los tipos entre par&amp;eacute;ntesis no se pueden distinguir de sus cuerpos.</target>
        </trans-unit>
        <trans-unit id="54d59bcb751b787399eaa6216688da1c771a3508" translate="yes" xml:space="preserve">
          <source>If T is a bitstring type &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt;, where &lt;code&gt;M&lt;/code&gt; and &lt;code&gt;N&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo de cadena de bits &lt;code&gt;&amp;lt;&amp;lt;_:M,_:_*N&amp;gt;&amp;gt;&lt;/code&gt; , donde &lt;code&gt;M&lt;/code&gt; y &lt;code&gt;N&lt;/code&gt; son tipos enteros singleton, entonces Rep (T) = &lt;code&gt;{type,LINE,binary,[Rep(M),Rep(N)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bb0862754ffb06068ede8dc817a72eb1519add3" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo &lt;code&gt;fun((...) -&amp;gt; T_0)&lt;/code&gt; , entonces Rep (T) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,any},Rep(T_0)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7f9d5b99a9c22d7dc1e1078c45173c119d328720" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo &lt;code&gt;fun()&lt;/code&gt; , entonces Rep (T) = &lt;code&gt;{type,LINE,'fun',[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b7630c752d5e9079868a01fb10ba5440be40003" translate="yes" xml:space="preserve">
          <source>If T is a fun type &lt;code&gt;fun(Ft)&lt;/code&gt;, where &lt;code&gt;Ft&lt;/code&gt; is a function type, then Rep(T) = &lt;code&gt;Rep(Ft)&lt;/code&gt;. For Rep(Ft), see below.</source>
          <target state="translated">Si T es un tipo de &lt;code&gt;fun(Ft)&lt;/code&gt; , donde &lt;code&gt;Ft&lt;/code&gt; es un tipo de funci&amp;oacute;n, entonces Rep (T) = &lt;code&gt;Rep(Ft)&lt;/code&gt; . Para Rep (Ft), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f6a030c9807953845560f8db0809d5cae00b3b69" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association type, then Rep(T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Si T es un tipo de mapa &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es un tipo de asociaci&amp;oacute;n, entonces Rep (T) = &lt;code&gt;{type,LINE,map,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b831583f902b7b1e825485ae91283de7c5ae12d8" translate="yes" xml:space="preserve">
          <source>If T is a map type &lt;code&gt;map()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo de &lt;code&gt;map()&lt;/code&gt; , entonces Rep (T) = &lt;code&gt;{type,LINE,map,any}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e65f43c9b04c981a0f08dbd4e0efeaf97f33b27e" translate="yes" xml:space="preserve">
          <source>If T is a predefined (or built-in) type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; predefinido (o incorporado) (T_1, ..., T_k) , entonces Rep (T) = &lt;code&gt;{type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81796f903baaa46af3b80b5d8688ebe92b7c0403" translate="yes" xml:space="preserve">
          <source>If T is a record type &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt;, where each &lt;code&gt;F_i&lt;/code&gt; is a record field type, then Rep(T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt;. For Rep(F), see below.</source>
          <target state="translated">Si T es un tipo de registro &lt;code&gt;#Name{F_1, ..., F_k}&lt;/code&gt; , donde cada &lt;code&gt;F_i&lt;/code&gt; es un tipo de campo de registro, entonces Rep (T) = &lt;code&gt;{type,LINE,record,[Rep(Name),Rep(F_1), ..., Rep(F_k)]}&lt;/code&gt; . Para Rep (F), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ee8d572503b5c61f934efe1a703bfabdb6fef560" translate="yes" xml:space="preserve">
          <source>If T is a remote type &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo remoto &lt;code&gt;M:N(T_1, ..., T_k)&lt;/code&gt; , entonces Rep (T) = &lt;code&gt;{remote_type,LINE,[Rep(M),Rep(N),[Rep(T_1), ..., Rep(T_k)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68b1161c8a498bf9c973de5bfb81d671743d9c3d" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;tuple()&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt;.</source>
          <target state="translated">Si T es una tupla de tipo &lt;code&gt;tuple()&lt;/code&gt; , entonces Rep (T) = &lt;code&gt;{type,LINE,tuple,any}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d1e4f6cf136dfa1b7d4b66063686fadb91908818" translate="yes" xml:space="preserve">
          <source>If T is a tuple type &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo de tupla &lt;code&gt;{T_1, ..., T_k}&lt;/code&gt; , entonces Rep (T) = &lt;code&gt;{type,LINE,tuple,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39f7c924bddde4fb82ebc04d0dc2ef68e7d3ec80" translate="yes" xml:space="preserve">
          <source>If T is a type union &lt;code&gt;T_1 | ... | T_k&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si T es una uni&amp;oacute;n de tipo &lt;code&gt;T_1 | ... | T_k&lt;/code&gt; , luego Rep (T) = &lt;code&gt;{type,LINE,union,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04b9ae17be7ca13037caad5b425aea5153523426" translate="yes" xml:space="preserve">
          <source>If T is a type variable &lt;code&gt;V&lt;/code&gt;, then Rep(T) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;. A type variable is any variable except underscore (&lt;code&gt;_&lt;/code&gt;).</source>
          <target state="translated">Si T es un tipo de variable &lt;code&gt;V&lt;/code&gt; , a continuaci&amp;oacute;n, Rep (T) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es un &amp;aacute;tomo con un printname que consiste en los mismos caracteres que &lt;code&gt;V&lt;/code&gt; . Una variable de tipo es cualquier variable excepto el subrayado ( &lt;code&gt;_&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11ece75db2c93e58198cc536b47ac3b68361a0ca" translate="yes" xml:space="preserve">
          <source>If T is a user-defined type &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt;, then Rep(T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo &lt;code&gt;N(T_1, ..., T_k)&lt;/code&gt; definido por el usuario (T_1, ..., T_k) , entonces Rep (T) = &lt;code&gt;{user_type,LINE,N,[Rep(T_1), ..., Rep(T_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="308a5eeab7204b0380423b04a4f96b78a2bb9a71" translate="yes" xml:space="preserve">
          <source>If T is an annotated type &lt;code&gt;A :: T_0&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is a variable, then Rep(T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo anotado &lt;code&gt;A :: T_0&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es una variable, entonces Rep (T) = &lt;code&gt;{ann_type,LINE,[Rep(A),Rep(T_0)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a9ca5d4370f68ffd4aacee2420b758f185ae7c5" translate="yes" xml:space="preserve">
          <source>If T is an atom or integer literal L, then Rep(T) = Rep(L).</source>
          <target state="translated">Si T es un átomo o un entero literal L,entonces Rep(T)=Rep(L).</target>
        </trans-unit>
        <trans-unit id="ad797cc1858fce32e5e441213921861198714eb2" translate="yes" xml:space="preserve">
          <source>If T is an integer range type &lt;code&gt;L .. H&lt;/code&gt;, where &lt;code&gt;L&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; are singleton integer types, then Rep(T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo de rango entero &lt;code&gt;L .. H&lt;/code&gt; , donde &lt;code&gt;L&lt;/code&gt; y &lt;code&gt;H&lt;/code&gt; son tipos enteros singleton, entonces Rep (T) = &lt;code&gt;{type,LINE,range,[Rep(L),Rep(H)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb40c0e15c57779039c33cac1f747c5810dbf6ac" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;Op T_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo de operador &lt;code&gt;Op T_0&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador unario (esto es una ocurrencia de una expresi&amp;oacute;n que se puede evaluar como un n&amp;uacute;mero entero en tiempo de compilaci&amp;oacute;n), entonces Rep (T) = &lt;code&gt;{op,LINE,Op,Rep(T_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff8ff3216bb70a3e5574e4f729d37b4404373ced" translate="yes" xml:space="preserve">
          <source>If T is an operator type &lt;code&gt;T_1 Op T_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator (this is an occurrence of an expression that can be evaluated to an integer at compile time), then Rep(T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt;.</source>
          <target state="translated">Si T es un tipo de operador &lt;code&gt;T_1 Op T_2&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador binario (esto es una ocurrencia de una expresi&amp;oacute;n que se puede evaluar a un n&amp;uacute;mero entero en tiempo de compilaci&amp;oacute;n), entonces Rep (T) = &lt;code&gt;{op,LINE,Op,Rep(T_1),Rep(T_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50ad15b3d0471bd3faa5be48d2ae0de7d86566a4" translate="yes" xml:space="preserve">
          <source>If T is the empty list type &lt;code&gt;[]&lt;/code&gt;, then Rep(T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt;.</source>
          <target state="translated">Si T es el tipo de lista vac&amp;iacute;a &lt;code&gt;[]&lt;/code&gt; , entonces Rep (T) = &lt;code&gt;{type,Line,nil,[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4fd606c5ec8d6d6bb3851df48abcb81b06d7a38" translate="yes" xml:space="preserve">
          <source>If TLS is requested (&lt;code&gt;Bool=true&lt;/code&gt;) then a connecting process should initiate a TLS handshake with the peer and an accepting process should prepare to accept a handshake. A successful handshake should be followed by a &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; message to the parent process. A failed handshake should cause the process to exit.</source>
          <target state="translated">Si se solicita TLS ( &lt;code&gt;Bool=true&lt;/code&gt; ), entonces un proceso de conexi&amp;oacute;n debe iniciar un protocolo de enlace TLS con el par y un proceso de aceptaci&amp;oacute;n debe prepararse para aceptar un protocolo de enlace. Un apret&amp;oacute;n de manos exitoso debe ir seguido de un mensaje &lt;code&gt;{diameter, {tls, Ref}}&lt;/code&gt; al proceso padre. Un apret&amp;oacute;n de manos fallido deber&amp;iacute;a hacer que el proceso se cierre.</target>
        </trans-unit>
        <trans-unit id="fdc7d15812f21bafb9f2d4f973c0a1f450ecf989" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A:Value&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom and &lt;code&gt;Value&lt;/code&gt; is an integer, then Rep(TS) = &lt;code&gt;{A,Value}&lt;/code&gt;.</source>
          <target state="translated">Si TS es un especificador de tipo &lt;code&gt;A:Value&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es un &amp;aacute;tomo y &lt;code&gt;Value&lt;/code&gt; es un n&amp;uacute;mero entero, entonces Rep (TS) = &lt;code&gt;{A,Value}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0e7b2ba399cca51e247046ccdbff7d00ba5b8ab" translate="yes" xml:space="preserve">
          <source>If TS is a type specifier &lt;code&gt;A&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(TS) = &lt;code&gt;A&lt;/code&gt;.</source>
          <target state="translated">Si TS es un especificador de tipo &lt;code&gt;A&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es un &amp;aacute;tomo, a continuaci&amp;oacute;n, Rep (TS) = &lt;code&gt;A&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cffa66b34c2d2e22ea4103aaa24ab719e89c2fec" translate="yes" xml:space="preserve">
          <source>If Trace Tool Builder is to be used against a remote node, it is highly recommended to start the trace control node as &lt;strong&gt;hidden&lt;/strong&gt;. This way it can connect to the traced node without being &quot;seen&quot; by it, that is, if the &lt;code&gt;nodes()&lt;/code&gt; BIF is called on the traced node, the trace control node does not show. To start a hidden node, add option &lt;code&gt;-hidden&lt;/code&gt; to the &lt;code&gt;erl&lt;/code&gt; command, for example:</source>
          <target state="translated">Si el Generador de herramientas de seguimiento se va a utilizar en un nodo remoto, se recomienda encarecidamente iniciar el nodo de control de seguimiento como &lt;strong&gt;oculto&lt;/strong&gt; . De esta manera puede conectarse al nodo rastreado sin ser &quot;visto&quot; por &amp;eacute;l, es decir, si se llama al nodo &lt;code&gt;nodes()&lt;/code&gt; BIF en el nodo rastreado, el nodo de control de rastreo no se muestra. Para iniciar un nodo oculto, agregue la opci&amp;oacute;n &lt;code&gt;-hidden&lt;/code&gt; al comando &lt;code&gt;erl&lt;/code&gt; , por ejemplo:</target>
        </trans-unit>
        <trans-unit id="1ab68d3d8a84e8ac67ee4631fedf30ccfba50dcc" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the string &lt;code&gt;VarName&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">Si la codificaci&amp;oacute;n de nombre de archivo Unicode est&amp;aacute; en vigor (consulte la &lt;code&gt;erlmanual page&lt;/code&gt; ), la cadena &lt;code&gt;VarName&lt;/code&gt; puede contener caracteres con puntos de c&amp;oacute;digo&amp;gt; 255.</target>
        </trans-unit>
        <trans-unit id="349a1b5c23c6400e11f34baaeede22206381d4e8" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings &lt;code&gt;VarName&lt;/code&gt; and &lt;code&gt;Value&lt;/code&gt; can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">Si la codificaci&amp;oacute;n de nombre de archivo Unicode est&amp;aacute; en vigor (consulte la &lt;code&gt;erlmanual page&lt;/code&gt; del manual erl ), las cadenas &lt;code&gt;VarName&lt;/code&gt; y &lt;code&gt;Value&lt;/code&gt; pueden contener caracteres con puntos de c&amp;oacute;digo&amp;gt; 255.</target>
        </trans-unit>
        <trans-unit id="8063f0dff7c5946dc972277dda605fd528422b32" translate="yes" xml:space="preserve">
          <source>If Unicode filename encoding is in effect (see the &lt;code&gt;erlmanual page&lt;/code&gt;), the strings can contain characters with codepoints &amp;gt; 255.</source>
          <target state="translated">Si la codificaci&amp;oacute;n de nombre de archivo Unicode est&amp;aacute; en vigor (consulte la &lt;code&gt;erlmanual page&lt;/code&gt; ), las cadenas pueden contener caracteres con puntos de c&amp;oacute;digo&amp;gt; 255.</target>
        </trans-unit>
        <trans-unit id="50def98f37f2942e5e50a32fd6672fe00221e237" translate="yes" xml:space="preserve">
          <source>If Unicode filename translation is in effect and the file system is transparent, filenames that cannot be interpreted as Unicode can be encountered, in which case the &lt;code&gt;fun()&lt;/code&gt; must be prepared to handle raw filenames (that is, binaries). If the regular expression contains codepoints &amp;gt; 255, it does not match filenames that do not conform to the expected character encoding (that is, are not encoded in valid UTF-8).</source>
          <target state="translated">Si la traducci&amp;oacute;n del nombre de archivo Unicode est&amp;aacute; en efecto y el sistema de archivos es transparente, se pueden encontrar nombres de archivo que no se pueden interpretar como Unicode, en cuyo caso el &lt;code&gt;fun()&lt;/code&gt; debe estar preparado para manejar nombres de archivo sin formato (es decir, binarios). Si la expresi&amp;oacute;n regular contiene puntos de c&amp;oacute;digo&amp;gt; 255, no coincide con los nombres de archivo que no se ajustan a la codificaci&amp;oacute;n de caracteres esperada (es decir, no est&amp;aacute;n codificados en UTF-8 v&amp;aacute;lido).</target>
        </trans-unit>
        <trans-unit id="27d8be04dca27e76e1518b6381c78e6ba0f1228a" translate="yes" xml:space="preserve">
          <source>If Unicode filenames are enabled, the calls to &lt;code&gt;os:getenv/0,1&lt;/code&gt;, &lt;code&gt;os:putenv/2&lt;/code&gt;, and &lt;code&gt;os:unsetenv/1&lt;/code&gt; handle Unicode strings. On Unix-like platforms, the built-in functions translate environment variables in UTF-8 to/from Unicode strings, possibly with code points &amp;gt; 255. On Windows, the Unicode versions of the environment system API are used, and code points &amp;gt; 255 are allowed.</source>
          <target state="translated">Si los nombres de archivo Unicode est&amp;aacute;n habilitados, las llamadas a &lt;code&gt;os:getenv/0,1&lt;/code&gt; , &lt;code&gt;os:putenv/2&lt;/code&gt; y &lt;code&gt;os:unsetenv/1&lt;/code&gt; manejan cadenas Unicode. En plataformas similares a Unix, las funciones integradas traducen variables de entorno en UTF-8 a / desde cadenas Unicode, posiblemente con puntos de c&amp;oacute;digo&amp;gt; 255. En Windows, se utilizan las versiones Unicode de la API del sistema de entorno y puntos de c&amp;oacute;digo&amp;gt; 255 est&amp;aacute;n permitidos.</target>
        </trans-unit>
        <trans-unit id="7fd5167b3902c5e1022270db7b7037a7e5ba7572" translate="yes" xml:space="preserve">
          <source>If Unicode translation is in effect (&lt;code&gt;~ts&lt;/code&gt;), characters &amp;gt; 255 are accepted, otherwise not. With the translation modifier, the returned list can as a consequence also contain integers &amp;gt; 255:</source>
          <target state="translated">Si la traducci&amp;oacute;n Unicode est&amp;aacute; en vigor ( &lt;code&gt;~ts&lt;/code&gt; ), se aceptan caracteres&amp;gt; 255; de lo contrario, no. Con el modificador de traducci&amp;oacute;n, la lista devuelta puede, como consecuencia, contener tambi&amp;eacute;n enteros&amp;gt; 255:</target>
        </trans-unit>
        <trans-unit id="8109397071948c43826e0713ed25b859b8a44c79" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A :: T&lt;/code&gt;, where &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">Si V es &lt;code&gt;A :: T&lt;/code&gt; , donde &lt;code&gt;T&lt;/code&gt; es un tipo, entonces Rep (V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A)},Rep(T)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a7f32a52c794ffe7684b6b2810c41e4682238d59" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E :: T&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt;.</source>
          <target state="translated">Si V es &lt;code&gt;A = E :: T&lt;/code&gt; , donde &lt;code&gt;E&lt;/code&gt; es una expresi&amp;oacute;n y &lt;code&gt;T&lt;/code&gt; es un tipo, entonces Rep (V) = &lt;code&gt;{typed_record_field,{record_field,LINE,Rep(A),Rep(E)},Rep(T)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f396f938bddcba478f3de3dee1d32cdd215e7c9" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A = E&lt;/code&gt;, where &lt;code&gt;E&lt;/code&gt; is an expression, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt;.</source>
          <target state="translated">Si V es &lt;code&gt;A = E&lt;/code&gt; , donde &lt;code&gt;E&lt;/code&gt; es una expresi&amp;oacute;n, entonces Rep (V) = &lt;code&gt;{record_field,LINE,Rep(A),Rep(E)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46feb36a0599dccd153195f0bebe327e41e1d422" translate="yes" xml:space="preserve">
          <source>If V is &lt;code&gt;A&lt;/code&gt;, then Rep(V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Si V es &lt;code&gt;A&lt;/code&gt; , entonces Rep (V) = &lt;code&gt;{record_field,LINE,Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="be88adeac37e6ad073f87c039fc9ee408a3d9604" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, &lt;code&gt;string()&lt;/code&gt; and &lt;code&gt;char()&lt;/code&gt; are allowed to be &amp;gt; 255. See also the documentation of the &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; type.</source>
          <target state="translated">Si VM est&amp;aacute; en el modo de nombre de archivo Unicode, se permite que &lt;code&gt;string()&lt;/code&gt; y &lt;code&gt;char()&lt;/code&gt; sean&amp;gt; 255. Consulte tambi&amp;eacute;n la documentaci&amp;oacute;n del tipo &lt;code&gt;&lt;a href=&quot;#type-name_all&quot;&gt;name_all()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf04572355facf77510f6eb707d8bddd39905f32" translate="yes" xml:space="preserve">
          <source>If VM is in Unicode filename mode, characters are allowed to be &amp;gt; 255. &lt;code&gt;RawFilename&lt;/code&gt; is a filename not subject to Unicode translation, meaning that it can contain characters not conforming to the Unicode encoding expected from the file system (that is, non-UTF-8 characters although the VM is started in Unicode filename mode). Null characters (integer value zero) are &lt;strong&gt;not&lt;/strong&gt; allowed in filenames (not even at the end).</source>
          <target state="translated">Si VM est&amp;aacute; en el modo de nombre de archivo Unicode, los caracteres pueden ser&amp;gt; 255. &lt;code&gt;RawFilename&lt;/code&gt; es un nombre de archivo que no est&amp;aacute; sujeto a la traducci&amp;oacute;n Unicode, lo que significa que puede contener caracteres que no se ajustan a la codificaci&amp;oacute;n Unicode esperada del sistema de archivos (es decir, no UTF -8 caracteres aunque la m&amp;aacute;quina virtual se inicia en modo de nombre de archivo Unicode). Los caracteres nulos (valor entero cero) &lt;strong&gt;no se&lt;/strong&gt; permiten en los nombres de archivo (ni siquiera al final).</target>
        </trans-unit>
        <trans-unit id="c6fa19e3c49a3ba084dbfa57062e1a1ae9c3810d" translate="yes" xml:space="preserve">
          <source>If X = Y, then R is called a relation &lt;strong&gt;in&lt;/strong&gt; X.</source>
          <target state="translated">Si X = Y, entonces R se llama relaci&amp;oacute;n &lt;strong&gt;en&lt;/strong&gt; X.</target>
        </trans-unit>
        <trans-unit id="a5da42cb98de8f66497fcf02d854f52ee32aab90" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; of length two or more exists through vertex &lt;code&gt;V&lt;/code&gt;, the cycle is returned as a list &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; of vertices. If a &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; through &lt;code&gt;V&lt;/code&gt; exists, the loop is returned as a list &lt;code&gt;[V]&lt;/code&gt;. If no cycles through &lt;code&gt;V&lt;/code&gt; exist, &lt;code&gt;false&lt;/code&gt; is returned.</source>
          <target state="translated">Si existe un &lt;code&gt;&lt;a href=&quot;#simple_cycle&quot;&gt;simple cycle&lt;/a&gt;&lt;/code&gt; de longitud dos o m&amp;aacute;s a trav&amp;eacute;s del v&amp;eacute;rtice &lt;code&gt;V&lt;/code&gt; , el ciclo se devuelve como una lista &lt;code&gt;[V,&amp;nbsp;...,&amp;nbsp;V]&lt;/code&gt; de v&amp;eacute;rtices. Si existe un &lt;code&gt;&lt;a href=&quot;#loop&quot;&gt;loop&lt;/a&gt;&lt;/code&gt; trav&amp;eacute;s de &lt;code&gt;V&lt;/code&gt; , el bucle se devuelve como una lista &lt;code&gt;[V]&lt;/code&gt; . Si no existen ciclos a trav&amp;eacute;s de &lt;code&gt;V&lt;/code&gt; , se devuelve &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4c540f1bcb01b8107384c4ecb40a93c9ff68733" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Dir&lt;/code&gt; already exists in the code path, it is removed from the old position.</source>
          <target state="translated">Si ya existe un &lt;code&gt;Dir&lt;/code&gt; en la ruta del c&amp;oacute;digo, se elimina de la posici&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="74a148d16947689b4aa97fa5371e271e751763f1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function crashes or throws an exception, the original state of the process is unchanged for &lt;code&gt;gen_server&lt;/code&gt;, and &lt;code&gt;gen_statem&lt;/code&gt; processes. For &lt;code&gt;gen_event&lt;/code&gt; processes, a crashing or failing &lt;code&gt;StateFun&lt;/code&gt; function means that only the state of the particular event handler it was working on when it failed or crashed is unchanged; it can still succeed in changing the states of other event handlers registered in the same &lt;code&gt;gen_event&lt;/code&gt; process.</source>
          <target state="translated">Si un &lt;code&gt;StateFun&lt;/code&gt; funci&amp;oacute;n se bloquea o se produce una excepci&amp;oacute;n, el estado original del proceso no se ha modificado para &lt;code&gt;gen_server&lt;/code&gt; y &lt;code&gt;gen_statem&lt;/code&gt; procesos. Para los procesos &lt;code&gt;gen_event&lt;/code&gt; , una funci&amp;oacute;n &lt;code&gt;StateFun&lt;/code&gt; que falla o falla significa que solo el estado del controlador de eventos en particular en el que estaba trabajando cuando fall&amp;oacute; o se bloque&amp;oacute; no cambia; a&amp;uacute;n puede cambiar los estados de otros controladores de eventos registrados en el mismo proceso &lt;code&gt;gen_event&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f16194ae42169305df9c2ac40e5f3bc5d8ab5294" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;StateFun&lt;/code&gt; function decides not to effect any change in process state, then regardless of process type, it can return its &lt;code&gt;State&lt;/code&gt; argument.</source>
          <target state="translated">Si una funci&amp;oacute;n &lt;code&gt;StateFun&lt;/code&gt; decide no efectuar ning&amp;uacute;n cambio en el estado del proceso, independientemente del tipo de proceso, puede devolver su argumento &lt;code&gt;State&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71a0319e49e50710f02ee82c0914b94ac22dbba1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Tag&lt;/code&gt; is speciifed, the returned &lt;code&gt;Match&lt;/code&gt; also includes the matched &lt;code&gt;Tag&lt;/code&gt;. Otherwise, only &lt;code&gt;RxMatch&lt;/code&gt; is returned.</source>
          <target state="translated">Si se especifica una &lt;code&gt;Tag&lt;/code&gt; , la &lt;code&gt;Match&lt;/code&gt; devuelta tambi&amp;eacute;n incluye la &lt;code&gt;Tag&lt;/code&gt; coincidente . De lo contrario, solo se devuelve &lt;code&gt;RxMatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a7555617310e8eeba0e7553e2392a16068784c6" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;Threshold&lt;/code&gt; is specified, the counter is reset to value &lt;code&gt;SetValue&lt;/code&gt; if the following conditions occur:</source>
          <target state="translated">Si se especifica un &lt;code&gt;Threshold&lt;/code&gt; , el contador se restablece al valor &lt;code&gt;SetValue&lt;/code&gt; si ocurren las siguientes condiciones:</target>
        </trans-unit>
        <trans-unit id="a5a595a63e0041392424b473cbdb427fc8601eee" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;pid()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt;, &lt;code&gt;{in, Location}&lt;/code&gt;, and &lt;code&gt;{out, Location}&lt;/code&gt; are present, where &lt;code&gt;Location&lt;/code&gt; is either an MFA (&lt;code&gt;{Module, Function, Arity}&lt;/code&gt;) describing the function where the process was scheduled in/out, or the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Si hay un &lt;code&gt;pid()&lt;/code&gt; , las tuplas &lt;code&gt;{timeout, Millis}&lt;/code&gt; , &lt;code&gt;{in, Location}&lt;/code&gt; y &lt;code&gt;{out, Location}&lt;/code&gt; est&amp;aacute;n presentes, donde &lt;code&gt;Location&lt;/code&gt; es un MFA ( &lt;code&gt;{Module, Function, Arity}&lt;/code&gt; ) que describe la funci&amp;oacute;n donde el proceso se program&amp;oacute; entrada / salida, o el &amp;aacute;tomo &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="68177e2c897ada3a2210fd2fd1b8bee05a073d3a" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;port()&lt;/code&gt;, the tuples &lt;code&gt;{timeout, Millis}&lt;/code&gt; and &lt;code&gt;{port_op,Op}&lt;/code&gt; are present. &lt;code&gt;Op&lt;/code&gt; is one of &lt;code&gt;proc_sig&lt;/code&gt;, &lt;code&gt;timeout&lt;/code&gt;, &lt;code&gt;input&lt;/code&gt;, &lt;code&gt;output&lt;/code&gt;, &lt;code&gt;event&lt;/code&gt;, or &lt;code&gt;dist_cmd&lt;/code&gt;, depending on which driver callback was executing.</source>
          <target state="translated">Si hay un &lt;code&gt;port()&lt;/code&gt; , las tuplas &lt;code&gt;{timeout, Millis}&lt;/code&gt; y &lt;code&gt;{port_op,Op}&lt;/code&gt; est&amp;aacute;n presentes. &lt;code&gt;Op&lt;/code&gt; es uno de &lt;code&gt;proc_sig&lt;/code&gt; , &lt;code&gt;timeout&lt;/code&gt; , &lt;code&gt;input&lt;/code&gt; , &lt;code&gt;output&lt;/code&gt; , &lt;code&gt;event&lt;/code&gt; o &lt;code&gt;dist_cmd&lt;/code&gt; , seg&amp;uacute;n la devoluci&amp;oacute;n de llamada del controlador que se estaba ejecutando.</target>
        </trans-unit>
        <trans-unit id="793f68726c5cebcf04eed2e69bb996595dba56b1" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;property_parm()&lt;/code&gt; is found as part of the input (&lt;code&gt;SDP&lt;/code&gt;) then it is left unchanged.</source>
          <target state="translated">Si se encuentra un &lt;code&gt;property_parm()&lt;/code&gt; como parte de la entrada ( &lt;code&gt;SDP&lt;/code&gt; ), no se modifica.</target>
        </trans-unit>
        <trans-unit id="64a1cdf79545c23e02941821b867906efcc046dd" translate="yes" xml:space="preserve">
          <source>If a &lt;code&gt;relup&lt;/code&gt; file and/or a system configuration file called &lt;code&gt;sys.config&lt;/code&gt;, or a &lt;code&gt;sys.config.src&lt;/code&gt;, is found, these files are also included in the release package. See &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra un archivo de &lt;code&gt;relup&lt;/code&gt; y / o un archivo de configuraci&amp;oacute;n del sistema llamado &lt;code&gt;sys.config&lt;/code&gt; , o &lt;code&gt;sys.config.src&lt;/code&gt; , estos archivos tambi&amp;eacute;n se incluyen en el paquete de lanzamiento. Consulte &lt;code&gt;&lt;a href=&quot;release_handling#req&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90bab5222409642ed3e9b025afcf25e28ff5080e" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; and no message is placed in the buffer. Also, &lt;code&gt;erl_errno&lt;/code&gt; is set to &lt;code&gt;EAGAIN&lt;/code&gt;.</source>
          <target state="translated">Si ocurre un &lt;strong&gt;tic&lt;/strong&gt; , es decir, el nodo Erlang en el otro extremo de la conexi&amp;oacute;n ha sondeado este nodo para ver si todav&amp;iacute;a est&amp;aacute; vivo, la funci&amp;oacute;n devuelve &lt;code&gt;ERL_TICK&lt;/code&gt; y no se coloca ning&amp;uacute;n mensaje en el b&amp;uacute;fer. Adem&amp;aacute;s, &lt;code&gt;erl_errno&lt;/code&gt; se establece en &lt;code&gt;EAGAIN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20a48a4a5f7af813214b4a1f7a53e0d6d083deb2" translate="yes" xml:space="preserve">
          <source>If a &lt;strong&gt;tick&lt;/strong&gt; occurs, that is, the Erlang node on the other end of the connection has polled this node to see if it is still alive, the function returns &lt;code&gt;ERL_TICK&lt;/code&gt; indicating that the tick has been received and responded to, but no message is placed in the buffer. In this case you are to call &lt;code&gt;erl_receive_msg()&lt;/code&gt; again.</source>
          <target state="translated">Si ocurre un &lt;strong&gt;tick&lt;/strong&gt; , es decir, el nodo Erlang en el otro extremo de la conexi&amp;oacute;n ha sondeado este nodo para ver si todav&amp;iacute;a est&amp;aacute; vivo, la funci&amp;oacute;n devuelve &lt;code&gt;ERL_TICK&lt;/code&gt; indicando que el tick ha sido recibido y respondido, pero no se coloca ning&amp;uacute;n mensaje. en el b&amp;uacute;fer. En este caso, debe llamar a &lt;code&gt;erl_receive_msg()&lt;/code&gt; nuevamente.</target>
        </trans-unit>
        <trans-unit id="f4364cbd8c0d3d620c728241f3c91ca9a0df5663" translate="yes" xml:space="preserve">
          <source>If a binary is sent as a message to a process or port, the binary will be shrunk and any further append operation will copy the binary data into a new binary. For example, in the following code fragment &lt;code&gt;Bin1&lt;/code&gt; will be copied in the third line:</source>
          <target state="translated">Si un binario se env&amp;iacute;a como un mensaje a un proceso o puerto, el binario se reducir&amp;aacute; y cualquier operaci&amp;oacute;n de adici&amp;oacute;n adicional copiar&amp;aacute; los datos binarios en un nuevo binario. Por ejemplo, en el siguiente fragmento de c&amp;oacute;digo, &lt;code&gt;Bin1&lt;/code&gt; se copiar&amp;aacute; en la tercera l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="5090ad34e0febaa291c69020c02b54e9b3cafd88" translate="yes" xml:space="preserve">
          <source>If a binary references a larger binary (often described as being a subbinary), it can be useful to get the size of the referenced binary. This function can be used in a program to trigger the use of &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt;. By copying a binary, one can dereference the original, possibly large, binary that a smaller binary is a reference to.</source>
          <target state="translated">Si un binario hace referencia a un binario m&amp;aacute;s grande (a menudo descrito como subbinario), puede ser &amp;uacute;til obtener el tama&amp;ntilde;o del binario al que se hace referencia. Esta funci&amp;oacute;n se puede utilizar en un programa para activar el uso de &lt;code&gt;&lt;a href=&quot;#copy-1&quot;&gt;copy/1&lt;/a&gt;&lt;/code&gt; . Al copiar un binario, se puede eliminar la referencia al binario original, posiblemente grande, al que hace referencia un binario m&amp;aacute;s peque&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="bcde4e46ca8a493fcb199170b76f962a5fc5534f" translate="yes" xml:space="preserve">
          <source>If a call is added to this function, say in module &lt;code&gt;m1&lt;/code&gt;, a runtime error could can occur during release upgrade if the new version of &lt;code&gt;m1&lt;/code&gt; is loaded first and calls &lt;code&gt;ch3:available/0&lt;/code&gt; before the new version of &lt;code&gt;ch3&lt;/code&gt; is loaded.</source>
          <target state="translated">Si se agrega una llamada a esta funci&amp;oacute;n, digamos en el m&amp;oacute;dulo &lt;code&gt;m1&lt;/code&gt; , puede ocurrir un error de tiempo de ejecuci&amp;oacute;n durante la actualizaci&amp;oacute;n de la versi&amp;oacute;n si la nueva versi&amp;oacute;n de &lt;code&gt;m1&lt;/code&gt; se carga primero y llama a &lt;code&gt;ch3:available/0&lt;/code&gt; antes de que se cargue la nueva versi&amp;oacute;n de &lt;code&gt;ch3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d672e9be794bb20d13fca259b638d9872ca48c52" translate="yes" xml:space="preserve">
          <source>If a callback (performing the file access in the TFTP server) takes too long time (more than the double TFTP time-out), the server aborts the connection and sends an error reply to the client. This implies that the server releases resources attached to the connection faster than before. The server simply assumes that the client has given up.</source>
          <target state="translated">Si una devolución de llamada (realizando el acceso al archivo en el servidor TFTP)toma demasiado tiempo (más del doble del tiempo de espera de TFTP),el servidor aborta la conexión y envía una respuesta de error al cliente.Esto implica que el servidor libera los recursos adjuntos a la conexión más rápido que antes.El servidor simplemente asume que el cliente se ha dado por vencido.</target>
        </trans-unit>
        <trans-unit id="b5299cdbeb0a91fc95e90dba08d8ca1a2663ba62" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_server&lt;/code&gt; process terminates.</source>
          <target state="translated">Si una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada falla o devuelve un valor incorrecto, el proceso &lt;code&gt;gen_server&lt;/code&gt; termina.</target>
        </trans-unit>
        <trans-unit id="e4e015fa7495e24f93ba1b6d6271a425520bd035" translate="yes" xml:space="preserve">
          <source>If a callback function fails or returns a bad value, the &lt;code&gt;gen_statem&lt;/code&gt; terminates, unless otherwise stated. However, an exception of class &lt;code&gt;throw&lt;/code&gt; is not regarded as an error but as a valid return from all callback functions.</source>
          <target state="translated">Si una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada falla o devuelve un valor incorrecto, &lt;code&gt;gen_statem&lt;/code&gt; termina, a menos que se indique lo contrario. Sin embargo, una excepci&amp;oacute;n de &lt;code&gt;throw&lt;/code&gt; de clase no se considera un error sino un retorno v&amp;aacute;lido de todas las funciones de devoluci&amp;oacute;n de llamada.</target>
        </trans-unit>
        <trans-unit id="d2220ee07a02652209f14bbc36c9099d4b6fe0ac" translate="yes" xml:space="preserve">
          <source>If a child process terminates, all other child processes are terminated, and then all child processes, including the terminated one, are restarted.</source>
          <target state="translated">Si se termina un proceso hijo,se terminan todos los demás procesos hijos y luego se reinician todos los procesos hijos,incluido el terminado.</target>
        </trans-unit>
        <trans-unit id="c9c437f353a175442240ea2029595a8633f65dff" translate="yes" xml:space="preserve">
          <source>If a child process terminates, only that process is restarted.</source>
          <target state="translated">Si el proceso de un niño termina,sólo se reinicia ese proceso.</target>
        </trans-unit>
        <trans-unit id="7507b23dc1b78f0736fa82a074e0d7da39372d83" translate="yes" xml:space="preserve">
          <source>If a child process terminates, the rest of the child processes (that is, the child processes after the terminated process in start order) are terminated. Then the terminated child process and the rest of the child processes are restarted.</source>
          <target state="translated">Si un proceso hijo termina,el resto de los procesos hijos (es decir,los procesos hijos después del proceso terminado en orden de inicio)terminan.Entonces el proceso hijo terminado y el resto de los procesos hijo se reinician.</target>
        </trans-unit>
        <trans-unit id="30f0124339350cc4e352e860e84fd95007fc0287" translate="yes" xml:space="preserve">
          <source>If a client and a server wants to use an upgrade mechanism, such as defined by RFC 2817, to upgrade a regular TCP/IP connection to an TLS connection, this is supported by the Erlang SSL application API. This can be useful for, for example, supporting HTTP and HTTPS on the same port and implementing virtual hosting. Note this is a TLS feature only.</source>
          <target state="translated">Si un cliente y un servidor quieren utilizar un mecanismo de actualización,como el definido por la RFC 2817,para actualizar una conexión TCP/IP normal a una conexión TLS,esto es compatible con la API de aplicaciones SSL de Erlang.Esto puede ser útil para,por ejemplo,soportar HTTP y HTTPS en el mismo puerto e implementar el alojamiento virtual.Tenga en cuenta que esta es una función de TLS solamente.</target>
        </trans-unit>
        <trans-unit id="5cf674d6f811a6898fedc16a08be96658f66f44f" translate="yes" xml:space="preserve">
          <source>If a client sends more than one of the header fields that restricts the servers right to respond, the standard does not specify how this is to be handled. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; controls each field in the following order and if one of the fields does not match the current state, the request is rejected with a proper response:</source>
          <target state="translated">Si un cliente env&amp;iacute;a m&amp;aacute;s de uno de los campos de encabezado que restringe el derecho del servidor a responder, el est&amp;aacute;ndar no especifica c&amp;oacute;mo se debe manejar. &lt;code&gt;&lt;a href=&quot;httpd&quot;&gt;httpd(3)&lt;/a&gt;&lt;/code&gt; controla cada campo en el siguiente orden y si uno de los campos no coincide con el estado actual, la solicitud se rechaza con una respuesta adecuada:</target>
        </trans-unit>
        <trans-unit id="e27ccd3f361e3a3fbab2cff1701eede9199b66b3" translate="yes" xml:space="preserve">
          <source>If a command (local function call) is not recognized by the shell, an attempt is first made to find the function in module &lt;code&gt;user_default&lt;/code&gt;, where customized local commands can be placed. If found, the function is evaluated, otherwise an attempt is made to evaluate the function in module &lt;code&gt;shell_default&lt;/code&gt;. Module &lt;code&gt;user_default&lt;/code&gt; must be explicitly loaded.</source>
          <target state="translated">Si el shell no reconoce un comando (llamada de funci&amp;oacute;n local), primero se intenta encontrar la funci&amp;oacute;n en el m&amp;oacute;dulo &lt;code&gt;user_default&lt;/code&gt; , donde se pueden colocar los comandos locales personalizados. Si se encuentra, la funci&amp;oacute;n se eval&amp;uacute;a; de lo contrario, se intenta evaluar la funci&amp;oacute;n en el m&amp;oacute;dulo &lt;code&gt;shell_default&lt;/code&gt; . El m&amp;oacute;dulo &lt;code&gt;user_default&lt;/code&gt; debe cargarse expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="c36c504c5a55c7d3e1004baa209d8df31f96a326" translate="yes" xml:space="preserve">
          <source>If a comment selecting the &lt;code&gt;encoding&lt;/code&gt; exists, it can be located on the second line.</source>
          <target state="translated">Si existe un comentario que selecciona la &lt;code&gt;encoding&lt;/code&gt; , se puede ubicar en la segunda l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="81cca8ba4d8e6db9b3078f3494bdf4b64a21625a" translate="yes" xml:space="preserve">
          <source>If a complete system consists of disk-less and/or read-only client nodes, a &lt;code&gt;clients&lt;/code&gt; directory is to be added to the &lt;code&gt;$ROOT&lt;/code&gt; directory. A read-only node is a node with a read-only file system.</source>
          <target state="translated">Si un sistema completo consta de nodos cliente sin disco y / o de solo lectura, se debe agregar un directorio de &lt;code&gt;clients&lt;/code&gt; directorio &lt;code&gt;$ROOT&lt;/code&gt; . Un nodo de solo lectura es un nodo con un sistema de archivos de solo lectura.</target>
        </trans-unit>
        <trans-unit id="114507e06ec8251c1f8b58a05d6e95c9f0294db1" translate="yes" xml:space="preserve">
          <source>If a compressed stream with a larger window size is specified as input, &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; throws the &lt;code&gt;data_error&lt;/code&gt; exception.</source>
          <target state="translated">Si se especifica como entrada una secuencia comprimida con un tama&amp;ntilde;o de ventana m&amp;aacute;s grande, &lt;code&gt;&lt;a href=&quot;#inflate-2&quot;&gt;inflate/2&lt;/a&gt;&lt;/code&gt; lanza la excepci&amp;oacute;n &lt;code&gt;data_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5d1665dab7973da2ee300d7146a8bea80f54e0b" translate="yes" xml:space="preserve">
          <source>If a condition test for a subpattern having matched refers to a non-unique number, the test is true if any of the subpatterns of that number have matched.</source>
          <target state="translated">Si una prueba de condición para un subpatrón que ha coincidido se refiere a un número no único,la prueba es verdadera si alguno de los subpatrones de ese número ha coincidido.</target>
        </trans-unit>
        <trans-unit id="54dcbb12cbe33c06847716fee8fa5d710e5db085" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files and you want to access all possible values, use function &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; and specify &lt;code&gt;all&lt;/code&gt; in the options list. The values are then returned in a list and the order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">Si una variable de configuraci&amp;oacute;n est&amp;aacute; definida en varios archivos y desea acceder a todos los valores posibles, use la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ct#get_config-3&quot;&gt;ct:get_config/3&lt;/a&gt;&lt;/code&gt; y especifique &lt;code&gt;all&lt;/code&gt; en la lista de opciones. A continuaci&amp;oacute;n, los valores se devuelven en una lista y el orden de los elementos corresponde al orden en que se especificaron los archivos de configuraci&amp;oacute;n al inicio.</target>
        </trans-unit>
        <trans-unit id="0feca975d542bb0cc969b217767e215cd1ff5ce8" translate="yes" xml:space="preserve">
          <source>If a configuration variable is defined in multiple files, use option &lt;code&gt;all&lt;/code&gt; to access all possible values. The values are returned in a list. The order of the elements corresponds to the order that the configuration files were specified at startup.</source>
          <target state="translated">Si una variable de configuraci&amp;oacute;n est&amp;aacute; definida en varios archivos, use la opci&amp;oacute;n &lt;code&gt;all&lt;/code&gt; para acceder a todos los valores posibles. Los valores se devuelven en una lista. El orden de los elementos corresponde al orden en que se especificaron los archivos de configuraci&amp;oacute;n al inicio.</target>
        </trans-unit>
        <trans-unit id="1b9661fe7033eba3fb41e53ee1dcb7e1bb7fe5b9" translate="yes" xml:space="preserve">
          <source>If a configuration variable key has been associated with a name (by &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; or a &lt;code&gt;require&lt;/code&gt; statement), the name can be used instead of the key to read the value:</source>
          <target state="translated">Si una clave de variable de configuraci&amp;oacute;n se ha asociado con un nombre (por &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; o una declaraci&amp;oacute;n &lt;code&gt;require&lt;/code&gt; ), el nombre se puede usar en lugar de la clave para leer el valor:</target>
        </trans-unit>
        <trans-unit id="9a3f8db667e8bd436b47dbf9ca11fe7bcf52f5e1" translate="yes" xml:space="preserve">
          <source>If a connection attempt fails, the following can be checked:</source>
          <target state="translated">Si un intento de conexión falla,se puede comprobar lo siguiente:</target>
        </trans-unit>
        <trans-unit id="64f616a997808c9474daa0409579dbb91fef959e" translate="yes" xml:space="preserve">
          <source>If a crash occurs after this instruction, the system cannot recover and is restarted from the old release version. The instruction must only occur once in a script. It is to be placed after all &lt;code&gt;load_object_code&lt;/code&gt; instructions.</source>
          <target state="translated">Si se produce un bloqueo despu&amp;eacute;s de esta instrucci&amp;oacute;n, el sistema no se puede recuperar y se reinicia desde la versi&amp;oacute;n anterior. La instrucci&amp;oacute;n solo debe ocurrir una vez en un script. Debe colocarse despu&amp;eacute;s de todas &lt;code&gt;load_object_code&lt;/code&gt; instrucciones load_object_code .</target>
        </trans-unit>
        <trans-unit id="a2df1e7bdcf4b38219e76db42a7407ed6f3a44c6" translate="yes" xml:space="preserve">
          <source>If a crash occurs, an &lt;code&gt;erl_crash.dump&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; written unless environment variable &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; is set:</source>
          <target state="translated">Si se produce un accidente, un &lt;code&gt;erl_crash.dump&lt;/code&gt; es &lt;strong&gt;no&lt;/strong&gt; escrito, a menos variable de entorno &lt;code&gt;ERL_CRASH_DUMP_SECONDS&lt;/code&gt; Se establece:</target>
        </trans-unit>
        <trans-unit id="990352c71d728a05d2ecb284bad93c6958f6c7e3" translate="yes" xml:space="preserve">
          <source>If a custom CLI is installed (see the option &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt;) the rules above are replaced by thoose implied by the custom CLI.</source>
          <target state="translated">Si se instala una CLI personalizada (consulte la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#type-ssh_cli_daemon_option&quot;&gt;ssh_cli&lt;/a&gt;&lt;/code&gt; ), las reglas anteriores se reemplazan por las impl&amp;iacute;citas en la CLI personalizada.</target>
        </trans-unit>
        <trans-unit id="a77a173e95ad2269f4f246fd4ce1b5864fc76ada" translate="yes" xml:space="preserve">
          <source>If a default object &lt;code&gt;Default&lt;/code&gt; is specified, it is used as the object to be updated if the key is missing from the table. The value in place of the key is ignored and replaced by the proper key value. The return value is as if the default object had not been used, that is, a single updated element or a list of them.</source>
          <target state="translated">Si se especifica un objeto predeterminado &lt;code&gt;Default&lt;/code&gt; , se utiliza como el objeto que se actualizar&amp;aacute; si falta la clave en la tabla. El valor en lugar de la clave se ignora y se reemplaza por el valor de clave adecuado. El valor de retorno es como si no se hubiera utilizado el objeto predeterminado, es decir, un solo elemento actualizado o una lista de ellos.</target>
        </trans-unit>
        <trans-unit id="fedf7b02f05498afd04860368d31fbddefe371d5" translate="yes" xml:space="preserve">
          <source>If a directory is limited both by authentication directives in the HTTP server configuration file and by the &lt;code&gt;htaccess&lt;/code&gt; files, the user must be allowed to get access to the file by both methods for the request to succeed.</source>
          <target state="translated">Si un directorio est&amp;aacute; limitado tanto por las directivas de autenticaci&amp;oacute;n en el archivo de configuraci&amp;oacute;n del servidor HTTP como por los archivos &lt;code&gt;htaccess&lt;/code&gt; , el usuario debe tener acceso al archivo por ambos m&amp;eacute;todos para que la solicitud sea exitosa.</target>
        </trans-unit>
        <trans-unit id="06b77a14a9631e3efe172824e4438ea9844c1c57" translate="yes" xml:space="preserve">
          <source>If a disaster occurs and the &lt;code&gt;Mnesia&lt;/code&gt; database is corrupted, it can be reconstructed from a backup. Regard this as a last resort, as the backup contains old data. The data is hopefully consistent, but data is definitely lost when an old backup is used to restore the database.</source>
          <target state="translated">Si ocurre un desastre y la &lt;code&gt;Mnesia&lt;/code&gt; datos de Mnesia est&amp;aacute; da&amp;ntilde;ada, se puede reconstruir a partir de una copia de seguridad. Consid&amp;eacute;relo como &amp;uacute;ltimo recurso, ya que la copia de seguridad contiene datos antiguos. Es de esperar que los datos sean consistentes, pero definitivamente se pierden cuando se utiliza una copia de seguridad anterior para restaurar la base de datos.</target>
        </trans-unit>
        <trans-unit id="5f3cf29891ec99694dc2c7c6253ad367ac7a3461" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node is about to start, file &lt;code&gt;start_erl.data&lt;/code&gt; is located in the client directory at the master node. Thus, the &lt;code&gt;START_ERL_DATA&lt;/code&gt; line is to look like:</source>
          <target state="translated">Si un nodo cliente sin disco y / o de solo lectura est&amp;aacute; a punto de iniciarse, el archivo &lt;code&gt;start_erl.data&lt;/code&gt; se encuentra en el directorio del cliente en el nodo principal. Por lo tanto, la l&amp;iacute;nea &lt;code&gt;START_ERL_DATA&lt;/code&gt; se ver&amp;aacute; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="82a0e287fdd1e5f6d5eb37393a55caeaa8bd420e" translate="yes" xml:space="preserve">
          <source>If a diskless and/or read-only client node with the SASL configuration parameter &lt;code&gt;static_emulator&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; is about to start, the &lt;code&gt;-boot&lt;/code&gt; and &lt;code&gt;-config&lt;/code&gt; flags must be changed.</source>
          <target state="translated">Si un nodo cliente sin disco y / o de solo lectura con el par&amp;aacute;metro de configuraci&amp;oacute;n SASL &lt;code&gt;static_emulator&lt;/code&gt; establecido en &lt;code&gt;true&lt;/code&gt; est&amp;aacute; a punto de iniciarse, se deben cambiar los indicadores &lt;code&gt;-boot&lt;/code&gt; y &lt;code&gt;-config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="727df7ab6749918e93887b82b12046b24dcb7655" translate="yes" xml:space="preserve">
          <source>If a driver is used in a functional way (that is, holds no state, but only does some heavy calculation and returns a result), several ports with registered names can be opened beforehand, and the port to be used can be chosen based on the scheduler ID as follows:</source>
          <target state="translated">Si se utiliza un controlador de manera funcional (es decir,no tiene ningún estado,sino que sólo hace algunos cálculos pesados y devuelve un resultado),se pueden abrir de antemano varios puertos con nombres registrados y se puede elegir el puerto que se va a utilizar en función de la identificación del programador de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="3f6d6f3cd21444705a34e8bba2dffb954001faed" translate="yes" xml:space="preserve">
          <source>If a feature has been added in R13A or later, this is mentioned in the text.</source>
          <target state="translated">Si se ha añadido una característica en el R13A o más tarde,se menciona en el texto.</target>
        </trans-unit>
        <trans-unit id="34f202d62579e4feee1dfdcda9ab5acaef776ff3" translate="yes" xml:space="preserve">
          <source>If a filename is specified as argument, Debugger tries to load its settings from this file. For details about settings, see the User's Guide.</source>
          <target state="translated">Si se especifica un nombre de archivo como argumento,el Depurador intenta cargar su configuración desde este archivo.Para obtener más detalles sobre la configuración,consulte el Manual del usuario.</target>
        </trans-unit>
        <trans-unit id="ea25cbb8b26670068e8ad47b07d6ef15d55f99f4" translate="yes" xml:space="preserve">
          <source>If a filter or handler still crashes, Logger will remove the filter or handler in question from the configuration, and print a short error message to the terminal. A debug event containing the crash reason and other details is also issued.</source>
          <target state="translated">Si un filtro o manejador sigue fallando,Logger eliminará el filtro o manejador en cuestión de la configuración e imprimirá un breve mensaje de error en la terminal.También se emite un evento de depuración que contiene el motivo del bloqueo y otros detalles.</target>
        </trans-unit>
        <trans-unit id="cceb2b6f7ec210d1178bfcad319491366c2280e9" translate="yes" xml:space="preserve">
          <source>If a fun is already registered when attempting to register a fun, &lt;code&gt;{error, exists}&lt;/code&gt; is returned.</source>
          <target state="translated">Si ya se registr&amp;oacute; una diversi&amp;oacute;n al intentar registrar una diversi&amp;oacute;n, se devuelve &lt;code&gt;{error, exists}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="369b66436bacc61b5a02e5467b68ce2d193e98ed" translate="yes" xml:space="preserve">
          <source>If a function is specified as input and the last input function returns &lt;code&gt;{end_of_input, Value}&lt;/code&gt;, the function specified as output is called with argument &lt;code&gt;{value, Value}&lt;/code&gt;. This makes it easy to initiate the sequence of output functions with a value calculated by the input functions.</source>
          <target state="translated">Si se especifica una funci&amp;oacute;n como entrada y la &amp;uacute;ltima funci&amp;oacute;n de entrada devuelve &lt;code&gt;{end_of_input, Value}&lt;/code&gt; , la funci&amp;oacute;n especificada como salida se llama con el argumento &lt;code&gt;{value, Value}&lt;/code&gt; . Esto facilita el inicio de la secuencia de funciones de salida con un valor calculado por las funciones de entrada.</target>
        </trans-unit>
        <trans-unit id="6ebc3e92f35620a8a503c6277f4b94fd5dcf6d25" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system results in the allocated size of a heap being at least &lt;code&gt;Size&lt;/code&gt; words, a message &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; and &lt;code&gt;Info&lt;/code&gt; are the same as for &lt;code&gt;long_gc&lt;/code&gt; earlier, except that the tuple tagged with &lt;code&gt;timeout&lt;/code&gt; is not present.</source>
          <target state="translated">Si una recolecci&amp;oacute;n de basura en el sistema da como resultado que el tama&amp;ntilde;o asignado de un mont&amp;oacute;n sea al menos palabras de &lt;code&gt;Size&lt;/code&gt; , se env&amp;iacute;a un mensaje &lt;code&gt;{monitor, GcPid, large_heap, Info}&lt;/code&gt; a &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;GcPid&lt;/code&gt; e &lt;code&gt;Info&lt;/code&gt; son los mismos que para &lt;code&gt;long_gc&lt;/code&gt; anteriormente, excepto que la tupla etiquetada con &lt;code&gt;timeout&lt;/code&gt; no est&amp;aacute; presente.</target>
        </trans-unit>
        <trans-unit id="0fa572748a61109872681b645add693c92c91ac0" translate="yes" xml:space="preserve">
          <source>If a garbage collection in the system takes at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;GcPid&lt;/code&gt; is the pid that was garbage collected. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the result of the garbage collection.</source>
          <target state="translated">Si una recolecci&amp;oacute;n de basura en el sistema toma al menos milisegundos del reloj de pared de &lt;code&gt;Time&lt;/code&gt; &lt;code&gt;{monitor, GcPid, long_gc, Info}&lt;/code&gt; un mensaje {monitor, GcPid, long_gc, Info} a &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;GcPid&lt;/code&gt; es el pid que se recogi&amp;oacute; como basura. &lt;code&gt;Info&lt;/code&gt; rmaci&amp;oacute;n es una lista de tuplas de dos elementos que describen el resultado de la recolecci&amp;oacute;n de basura.</target>
        </trans-unit>
        <trans-unit id="9fc0db6a6ffa20f6ce91fac40d2bed50efc41760" translate="yes" xml:space="preserve">
          <source>If a given module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">Si un m&amp;oacute;dulo determinado no est&amp;aacute; compilado Cover, esto se indica mediante el motivo del error &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1fd4da11cbcec24fe617e2cfb21bda9700c3ceef" translate="yes" xml:space="preserve">
          <source>If a group contains subgroups, the execution properties for these can also be specified in the group tuple: &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; Where, &lt;code&gt;SubGroups&lt;/code&gt; is a list of tuples, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; or &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; representing the subgroups. Any subgroups defined in &lt;code&gt;group/0&lt;/code&gt; for a group, that are not specified in the &lt;code&gt;SubGroups&lt;/code&gt; list, executes with their predefined properties.</source>
          <target state="translated">Si un grupo contiene subgrupos, las propiedades de ejecuci&amp;oacute;n para estos tambi&amp;eacute;n se pueden especificar en la tupla de grupo: &lt;code&gt;{group,GroupName,Properties,SubGroups}&lt;/code&gt; donde, &lt;code&gt;SubGroups&lt;/code&gt; es una lista de tuplas, &lt;code&gt;{GroupName,Properties}&lt;/code&gt; o &lt;code&gt;{GroupName,Properties,SubGroups}&lt;/code&gt; representa los subgrupos. Cualquier subgrupo definido en el &lt;code&gt;group/0&lt;/code&gt; para un grupo, que no est&amp;eacute; especificado en la lista de &lt;code&gt;SubGroups&lt;/code&gt; , se ejecuta con sus propiedades predefinidas.</target>
        </trans-unit>
        <trans-unit id="2666a5da5f12edc23c65da1ead81b4fae39f0c6b" translate="yes" xml:space="preserve">
          <source>If a group has a parallel property, its test cases are spawned simultaneously and get executed in parallel. However, a test case is not allowed to execute in parallel with &lt;code&gt;end_per_group/2&lt;/code&gt;, which means that the time to execute a parallel group is equal to the execution time of the slowest test case in the group. A negative side effect of running test cases in parallel is that the HTML summary pages are not updated with links to the individual test case logs until function &lt;code&gt;end_per_group/2&lt;/code&gt; for the group has finished.</source>
          <target state="translated">Si un grupo tiene una propiedad paralela, sus casos de prueba se generan simult&amp;aacute;neamente y se ejecutan en paralelo. Sin embargo, no se permite que un caso de prueba se ejecute en paralelo con &lt;code&gt;end_per_group/2&lt;/code&gt; , lo que significa que el tiempo para ejecutar un grupo paralelo es igual al tiempo de ejecuci&amp;oacute;n del caso de prueba m&amp;aacute;s lento del grupo. Un efecto secundario negativo de ejecutar casos de prueba en paralelo es que las p&amp;aacute;ginas de resumen HTML no se actualizan con enlaces a los registros de casos de prueba individuales hasta que la funci&amp;oacute;n &lt;code&gt;end_per_group/2&lt;/code&gt; para el grupo haya finalizado.</target>
        </trans-unit>
        <trans-unit id="8bb7010fa14d24ee8209de3626a77d1e0f85e457" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, and the key is known by Logger, the default value is used. If it is a custom key, then it is up to the handler implementation if the value is removed or a default value is inserted.</source>
          <target state="translated">Si se elimina una clave en comparación con la configuración actual,y la clave es conocida por Logger,se utiliza el valor por defecto.Si se trata de una clave personalizada,entonces depende de la implementación del manejador si se elimina el valor o se inserta un valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="11708959f85882a0251af3731723c98e8ebf01ea" translate="yes" xml:space="preserve">
          <source>If a key is removed compared to the current configuration, the default value is used.</source>
          <target state="translated">Si se elimina una tecla en comparación con la configuración actual,se utiliza el valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="5dfcb13b302f0d14decac13131536de1d6f9c84b" translate="yes" xml:space="preserve">
          <source>If a list of &lt;code&gt;ModFiles&lt;/code&gt; is given as input, a list of &lt;code&gt;Result&lt;/code&gt; will be returned. The order of the returned list is undefined.</source>
          <target state="translated">Si se proporciona una lista de &lt;code&gt;ModFiles&lt;/code&gt; como entrada, se devolver&amp;aacute; una lista de &lt;code&gt;Result&lt;/code&gt; ados . El orden de la lista devuelta no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="f8890c3d642a5caba2f616485052ab5bd181a9ec" translate="yes" xml:space="preserve">
          <source>If a list of identifiers is used in an &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Si se utiliza una lista de identificadores en un &lt;code&gt;&amp;lt;IdDefs&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="69f7917cc57f0edf963801bba057a225f78af5d2" translate="yes" xml:space="preserve">
          <source>If a local function has the same name as an auto-imported BIF, the semantics is that implicitly qualified function calls are directed to the locally defined function, not to the BIF. To avoid confusion, there is a compiler directive available, &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt;, that makes a BIF not being auto-imported. In certain situations, such a compile-directive is mandatory.</source>
          <target state="translated">Si una funci&amp;oacute;n local tiene el mismo nombre que un BIF importado autom&amp;aacute;ticamente, la sem&amp;aacute;ntica es que las llamadas de funci&amp;oacute;n calificadas impl&amp;iacute;citamente se dirigen a la funci&amp;oacute;n definida localmente, no al BIF. Para evitar confusiones, hay una directiva de compilaci&amp;oacute;n disponible, &lt;code&gt;-compile({no_auto_import,[F/A]})&lt;/code&gt; , que hace que un BIF no se importe autom&amp;aacute;ticamente. En determinadas situaciones, dicha directiva de compilaci&amp;oacute;n es obligatoria.</target>
        </trans-unit>
        <trans-unit id="6f9bef85716e3a896ddd92ef48c5bf0c2c758aee" translate="yes" xml:space="preserve">
          <source>If a log event passes through all primary filters and all handler filters for a specific handler, Logger forwards the event to the &lt;strong&gt;handler callback&lt;/strong&gt;. The handler formats and prints the event to its destination. See section &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; for more details.</source>
          <target state="translated">Si un evento de registro pasa por todos los filtros primarios y todos los filtros de controlador para un controlador espec&amp;iacute;fico, Logger reenv&amp;iacute;a el evento a la &lt;strong&gt;devoluci&amp;oacute;n de llamada del controlador&lt;/strong&gt; . El controlador formatea e imprime el evento en su destino. Consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#handlers&quot;&gt;Handlers&lt;/a&gt;&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="e96f947dd13a984704288142af512a8f72e3acc3" translate="yes" xml:space="preserve">
          <source>If a log is configured to be distributed, it is possible that all items are not logged on all nodes. &lt;code&gt;wrap_log_reader&lt;/code&gt; only reads the log on the called node; it is up to the user to be sure that all items are read.</source>
          <target state="translated">Si un registro est&amp;aacute; configurado para distribuirse, es posible que no todos los elementos se registren en todos los nodos. &lt;code&gt;wrap_log_reader&lt;/code&gt; solo lee el registro en el nodo llamado; Depende del usuario asegurarse de que se lean todos los elementos.</target>
        </trans-unit>
        <trans-unit id="5666e4e832cec3f259cd26eabc4f7091a56c83aa" translate="yes" xml:space="preserve">
          <source>If a log with a specified name is local on some node, and one tries to open the log distributed on the same node, the tuple &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; is returned. The same tuple is returned if the log is distributed on some node, and one tries to open the log locally on the same node. Opening individual distributed disk logs for the first time adds those logs to a (possibly empty) distributed disk log. The supplied option values are used on all nodes mentioned by option &lt;code&gt;distributed&lt;/code&gt;. Individual distributed logs know nothing about each other's option values, so each node can be given unique option values by creating a distributed log with many calls to &lt;code&gt;open/1&lt;/code&gt;.</source>
          <target state="translated">Si un registro con un nombre especificado es local en alg&amp;uacute;n nodo y se intenta abrir el registro distribuido en el mismo nodo, se devuelve la tupla &lt;code&gt;{error, {node_already_open, Log}}&lt;/code&gt; . Se devuelve la misma tupla si el registro se distribuye en alg&amp;uacute;n nodo y se intenta abrir el registro localmente en el mismo nodo. La apertura de registros de disco distribuidos individuales por primera vez agrega esos registros a un registro de disco distribuido (posiblemente vac&amp;iacute;o). Los valores de opci&amp;oacute;n proporcionados se utilizan en todos los nodos mencionados por opci&amp;oacute;n &lt;code&gt;distributed&lt;/code&gt; . Los registros distribuidos individuales no saben nada sobre los valores de las opciones de los dem&amp;aacute;s, por lo que a cada nodo se le pueden asignar valores de opci&amp;oacute;n &amp;uacute;nicos mediante la creaci&amp;oacute;n de un registro distribuido con muchas llamadas a &lt;code&gt;open/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b469c9bb8a16915f90eba775ff31e5fe6d62248d" translate="yes" xml:space="preserve">
          <source>If a macro is used in several modules, it is recommended that the macro definition is placed in an include file.</source>
          <target state="translated">Si una macro se utiliza en varios módulos,se recomienda que la definición de la macro se coloque en un archivo de inclusión.</target>
        </trans-unit>
        <trans-unit id="f532881cad197bff88db03f3d5191a830d7bf595" translate="yes" xml:space="preserve">
          <source>If a matching fails, there could be circumstances when the certificate should be accepted anyway. Think for example of a web browser where you choose to accept an outdated certificate. This option enables implementation of such a function. This &lt;code&gt;fun/1&lt;/code&gt; is called when no &lt;code&gt;ReferenceID&lt;/code&gt; matches. The return value of the fun (a &lt;code&gt;boolean()&lt;/code&gt;) decides the outcome. If &lt;code&gt;true&lt;/code&gt; the the certificate is accepted otherwise it is rejected. See &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Si una coincidencia falla, puede haber circunstancias en las que el certificado deba aceptarse de todos modos. Piense, por ejemplo, en un navegador web en el que elige aceptar un certificado desactualizado. Esta opci&amp;oacute;n permite la implementaci&amp;oacute;n de dicha funci&amp;oacute;n. Este &lt;code&gt;fun/1&lt;/code&gt; se llama cuando no coincide &lt;code&gt;ReferenceID&lt;/code&gt; . El valor de retorno de la diversi&amp;oacute;n (un &lt;code&gt;boolean()&lt;/code&gt; ) decide el resultado. Si es &lt;code&gt;true&lt;/code&gt; el certificado se acepta; de lo contrario, se rechaza. Consulte &lt;code&gt;&lt;a href=&quot;using_public_key#-pinning--a-certificate&quot;&gt;&quot;Pinning&quot; a Certificate&lt;/a&gt;&lt;/code&gt; en la Gu&amp;iacute;a del usuario.</target>
        </trans-unit>
        <trans-unit id="4aba75283b25dadf865010d69b6030de96baf1b7" translate="yes" xml:space="preserve">
          <source>If a member terminates, it is automatically removed from the group.</source>
          <target state="translated">Si un miembro se da de baja,es automáticamente eliminado del grupo.</target>
        </trans-unit>
        <trans-unit id="1162149be57c33d9e6fc9573f2f1305c9430528f" translate="yes" xml:space="preserve">
          <source>If a message is received before the &quot;virtual&quot; connection has been established, the connection will be setup automatically. An MGC may be real open minded and dynamically decide which encoding and transport service to use depending on how the transport layer contact is performed. For IP transports two ports are standardized, one for textual encoding and one for binary encoding. If for example an UDP packet was received on the text port it would be possible to decide encoding and transport on the fly.</source>
          <target state="translated">Si se recibe un mensaje antes de que se haya establecido la conexión &quot;virtual&quot;,la conexión se establecerá automáticamente.Un MGC puede ser real de mente abierta y decidir dinámicamente qué servicio de codificación y transporte utilizar dependiendo de cómo se realice el contacto de la capa de transporte.Para los transportes IP se estandarizan dos puertos,uno para la codificación textual y otro para la codificación binaria.Si,por ejemplo,se recibiera un paquete UDP en el puerto de texto,sería posible decidir la codificación y el transporte sobre la marcha.</target>
        </trans-unit>
        <trans-unit id="b24fb0bcd517815519471545f5c58487dce8e63f" translate="yes" xml:space="preserve">
          <source>If a module is not Cover compiled, this is indicated by the error reason &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt;.</source>
          <target state="translated">Si un m&amp;oacute;dulo no est&amp;aacute; compilado en Cover, esto se indica mediante el motivo de error &lt;code&gt;{not_cover_compiled,Module}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7967640d362f8afe4a91bac33b7793d78de475b7" translate="yes" xml:space="preserve">
          <source>If a module was cover compiled from the &lt;code&gt;.beam&lt;/code&gt; file, i.e. using &lt;code&gt;compile_beam/1&lt;/code&gt; or &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt;, it is assumed that the source code can be found in the same directory as the &lt;code&gt;.beam&lt;/code&gt; file, in &lt;code&gt;../src&lt;/code&gt; relative to that directory, or using the source path in &lt;code&gt;Module:module_info(compile)&lt;/code&gt;. When using the latter, two paths are examined: first the one constructed by joining &lt;code&gt;../src&lt;/code&gt; and the tail of the compiled path below a trailing &lt;code&gt;src&lt;/code&gt; component, then the compiled path itself. If no source code is found, this is indicated by the error reason &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt;.</source>
          <target state="translated">Si un m&amp;oacute;dulo se compil&amp;oacute; a partir del archivo &lt;code&gt;.beam&lt;/code&gt; , es decir, utilizando &lt;code&gt;compile_beam/1&lt;/code&gt; o &lt;code&gt;compile_beam_directory/0,1&lt;/code&gt; , se asume que el c&amp;oacute;digo fuente se puede encontrar en el mismo directorio que el archivo &lt;code&gt;.beam&lt;/code&gt; , en &lt;code&gt;../src&lt;/code&gt; relativo a ese directorio, o usando la ruta de origen en &lt;code&gt;Module:module_info(compile)&lt;/code&gt; . Cuando se utiliza este &amp;uacute;ltimo, se examinan dos rutas: primero la construida uniendo &lt;code&gt;../src&lt;/code&gt; y la cola de la ruta compilada debajo de un componente &lt;code&gt;src&lt;/code&gt; final , luego la ruta compilada en s&amp;iacute;. Si no se encuentra el c&amp;oacute;digo fuente, esto se indica mediante el motivo del error &lt;code&gt;{no_source_code_found,Module}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22f56a79590fe78f12a072ad074e3e889605db4d" translate="yes" xml:space="preserve">
          <source>If a monitoring process gets so large that it itself starts to cause system monitor messages when garbage collecting, the messages enlarge the process message queue and probably make the problem worse.</source>
          <target state="translated">Si un proceso de monitoreo se hace tan grande que él mismo comienza a causar mensajes de monitoreo del sistema cuando se recoge la basura,los mensajes amplían la cola de mensajes del proceso y probablemente empeoran el problema.</target>
        </trans-unit>
        <trans-unit id="0f2d8b6af86eed1a143439cc301064ec94ca2bef" translate="yes" xml:space="preserve">
          <source>If a more complex change has been made, for example, a change to the format of the internal state of a &lt;code&gt;gen_server&lt;/code&gt;, simple code replacement is not sufficient. Instead, it is necessary to:</source>
          <target state="translated">Si se ha realizado un cambio m&amp;aacute;s complejo, por ejemplo, un cambio en el formato del estado interno de un &lt;code&gt;gen_server&lt;/code&gt; , el simple reemplazo de c&amp;oacute;digo no es suficiente. En cambio, es necesario:</target>
        </trans-unit>
        <trans-unit id="9709ba0c2dc81a1b8284809a6f8a81abf726c6a5" translate="yes" xml:space="preserve">
          <source>If a name collision occurs, the compiler reports a &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; message that tells if a definition was renamed, and the new name that must be used to encode/decode data.</source>
          <target state="translated">Si se produce una colisi&amp;oacute;n de nombres, el compilador informa un mensaje &lt;code&gt;&quot;NOTICE: ...&quot;&lt;/code&gt; que indica si se cambi&amp;oacute; el nombre de una definici&amp;oacute;n y el nuevo nombre que se debe usar para codificar / decodificar datos.</target>
        </trans-unit>
        <trans-unit id="cd783a31aebc8e052e7a2e8a344df67638bdfe57" translate="yes" xml:space="preserve">
          <source>If a name in &lt;code&gt;Files&lt;/code&gt; is not the name of an existing file, Igor assumes it represents a module name, and tries to locate and read the corresponding source file. The parsed files are appended to &lt;code&gt;Sources&lt;/code&gt; and passed on to &lt;code&gt;merge_sources/3&lt;/code&gt;, i.e., entries in &lt;code&gt;Sources&lt;/code&gt; are listed before entries read from files.</source>
          <target state="translated">Si un nombre en &lt;code&gt;Files&lt;/code&gt; no es el nombre de un archivo existente, Igor asume que representa un nombre de m&amp;oacute;dulo e intenta localizar y leer el archivo fuente correspondiente. Los archivos analizados se a&amp;ntilde;aden a las &lt;code&gt;Sources&lt;/code&gt; y se pasan a &lt;code&gt;merge_sources/3&lt;/code&gt; , es decir, las entradas en las &lt;code&gt;Sources&lt;/code&gt; se enumeran antes que las entradas le&amp;iacute;das de los archivos.</target>
        </trans-unit>
        <trans-unit id="dfb3773364e26824edee6292b7366b7013d08419" translate="yes" xml:space="preserve">
          <source>If a new item is inserted with the same key as an existing record, the old record is overwritten. However, if a table is of type &lt;code&gt;bag&lt;/code&gt;, each key can map to several records. All records in type &lt;code&gt;bag&lt;/code&gt; tables are unique, only the keys can be duplicated.</source>
          <target state="translated">Si se inserta un nuevo elemento con la misma clave que un registro existente, se sobrescribe el registro antiguo. Sin embargo, si una tabla es de tipo &lt;code&gt;bag&lt;/code&gt; , cada clave se puede asignar a varios registros. Todos los registros en las tablas de tipo &lt;code&gt;bag&lt;/code&gt; son &amp;uacute;nicos, solo las claves se pueden duplicar.</target>
        </trans-unit>
        <trans-unit id="105d061d00a8d9f92d43b213988e0acb45e2f7f6" translate="yes" xml:space="preserve">
          <source>If a new module is introduced, the following instruction is used:</source>
          <target state="translated">Si se introduce un nuevo módulo,se utiliza la siguiente instrucción:</target>
        </trans-unit>
        <trans-unit id="5f35aad99efc30cb9fc4c6453834ff14def063cf" translate="yes" xml:space="preserve">
          <source>If a node goes down in the middle of a dirty operation, the table load mechanism ensures that the update is performed on all replicas, or none. Both asynchronous dirty updates and synchronous dirty updates use the same recovery principle as lightweight transactions.</source>
          <target state="translated">Si un nodo se cae en medio de una operación sucia,el mecanismo de carga de la mesa asegura que la actualización se realice en todas las réplicas,o en ninguna.Tanto las actualizaciones sucias asincrónicas como las actualizaciones sucias síncronas utilizan el mismo principio de recuperación que las transacciones ligeras.</target>
        </trans-unit>
        <trans-unit id="327048d2049523b0f127e33e21231e0e526e41f3" translate="yes" xml:space="preserve">
          <source>If a node goes down, all connections to that node are removed. Calling &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; forces disconnection of a node.</source>
          <target state="translated">Si un nodo deja de funcionar, se eliminan todas las conexiones a ese nodo. Llamar a &lt;code&gt;erlang:disconnect_node(Node)&lt;/code&gt; fuerza la desconexi&amp;oacute;n de un nodo.</target>
        </trans-unit>
        <trans-unit id="b4217b58d768f80a1045777fccb8ca8bcb03c9aa" translate="yes" xml:space="preserve">
          <source>If a node is started, which has higher priority according to &lt;code&gt;distributed&lt;/code&gt; than the node where a distributed application is running, the application is restarted at the new node and stopped at the old node. This is called a &lt;strong&gt;takeover&lt;/strong&gt;.</source>
          <target state="translated">Si se inicia un nodo, que tiene mayor prioridad seg&amp;uacute;n &lt;code&gt;distributed&lt;/code&gt; que el nodo donde se ejecuta una aplicaci&amp;oacute;n distribuida, la aplicaci&amp;oacute;n se reinicia en el nuevo nodo y se detiene en el antiguo. A esto se le llama &lt;strong&gt;adquisici&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f888cd8bd0f80a569dfdaa82a2f031133a869106" translate="yes" xml:space="preserve">
          <source>If a pattern is compiled with option &lt;code&gt;extended&lt;/code&gt;, whitespace in the pattern (other than in a character class) and characters between a # outside a character class and the next newline are ignored. An escaping backslash can be used to include a whitespace or # character as part of the pattern.</source>
          <target state="translated">Si un patr&amp;oacute;n se compila con la opci&amp;oacute;n &lt;code&gt;extended&lt;/code&gt; , se ignoran los espacios en blanco en el patr&amp;oacute;n (que no sean en una clase de car&amp;aacute;cter) y los caracteres entre un # fuera de una clase de car&amp;aacute;cter y la siguiente l&amp;iacute;nea nueva. Se puede usar una barra invertida de escape para incluir un espacio en blanco o un car&amp;aacute;cter # como parte del patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9e8b4db27222acc7892ee1eda43334910e96e198" translate="yes" xml:space="preserve">
          <source>If a pattern starts with .* or .{0,} and option &lt;code&gt;dotall&lt;/code&gt; (equivalent to Perl option &lt;code&gt;/s&lt;/code&gt;) is set, thus allowing the dot to match newlines, the pattern is implicitly anchored, because whatever follows is tried against every character position in the subject string. So, there is no point in retrying the overall match at any position after the first. PCRE normally treats such a pattern as if it was preceded by \A.</source>
          <target state="translated">Si un patr&amp;oacute;n comienza con. * &lt;code&gt;dotall&lt;/code&gt; {0,} y se establece la opci&amp;oacute;n dotall (equivalente a la &lt;code&gt;/s&lt;/code&gt; opci&amp;oacute;n / s de Perl ), lo que permite que el punto coincida con las nuevas l&amp;iacute;neas, el patr&amp;oacute;n est&amp;aacute; impl&amp;iacute;citamente anclado, porque lo que sigue se prueba contra cada posici&amp;oacute;n de car&amp;aacute;cter en la cadena de asunto. Por lo tanto, no tiene sentido volver a intentar el partido general en cualquier posici&amp;oacute;n despu&amp;eacute;s del primero. PCRE normalmente trata este patr&amp;oacute;n como si estuviera precedido por \ A.</target>
        </trans-unit>
        <trans-unit id="b87ae6dafb0124e6e46c837d4958c2fa1f2a81db" translate="yes" xml:space="preserve">
          <source>If a pattern starts with &lt;code&gt;(*NO_START_OPT)&lt;/code&gt;, it has the same effect as setting option &lt;code&gt;no_start_optimize&lt;/code&gt; at compile time.</source>
          <target state="translated">Si un patr&amp;oacute;n comienza con &lt;code&gt;(*NO_START_OPT)&lt;/code&gt; , tiene el mismo efecto que configurar la opci&amp;oacute;n &lt;code&gt;no_start_optimize&lt;/code&gt; en tiempo de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9510cfbb42b2f63e8d24764760322df07deba921" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">Si una aplicación permanente termina,todas las demás aplicaciones y todo el nodo Erlang también terminan.</target>
        </trans-unit>
        <trans-unit id="ae39c8a4064e4c9103a84535d6791f3c2355574b" translate="yes" xml:space="preserve">
          <source>If a permanent application terminates, all other applications and the runtime system are also terminated.</source>
          <target state="translated">Si una aplicación permanente termina,todas las demás aplicaciones y el sistema en tiempo de ejecución también terminan.</target>
        </trans-unit>
        <trans-unit id="7d39ec2ef37ef98a358722319b34017d061d33a4" translate="yes" xml:space="preserve">
          <source>If a port is put into or removed from the run queue, a message, &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">Si un puerto se coloca o se elimina de la cola de ejecuci&amp;oacute;n , se env&amp;iacute;a un mensaje, &lt;code&gt;{profile, Port, State, 0, Ts}&lt;/code&gt; , a &lt;code&gt;ProfilerPid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0081080fd8645d025c38129c1f724e4dbeb1f5a" translate="yes" xml:space="preserve">
          <source>If a positive assertion containing one or more capturing subpatterns succeeds, but failure to match later in the pattern causes backtracking over this assertion, the captures within the assertion are reset only if no higher numbered captures are already set. This is, unfortunately, a fundamental limitation of the current implementation, and as PCRE1 is now in maintenance-only status, it is unlikely ever to change.</source>
          <target state="translated">Si una afirmación positiva que contiene uno o más subpatrones de captura tiene éxito,pero el hecho de no coincidir más tarde en el patrón provoca un retroceso sobre esta afirmación,las capturas dentro de la afirmación se reajustan sólo si no se han establecido ya capturas de mayor número.Lamentablemente,esta es una limitación fundamental de la aplicación actual,y como el PCRE1 se encuentra ahora en estado de sólo mantenimiento,es poco probable que cambie nunca.</target>
        </trans-unit>
        <trans-unit id="93a3a5bfdb59e73fc8a0334b43ff4eba1a20ef35" translate="yes" xml:space="preserve">
          <source>If a preset dictionary is required for further decompression, this function returns a &lt;code&gt;need_dictionary&lt;/code&gt; tuple. See &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt;) for details.</source>
          <target state="translated">Si se requiere un diccionario preestablecido para una mayor descompresi&amp;oacute;n, esta funci&amp;oacute;n devuelve una tupla &lt;code&gt;need_dictionary&lt;/code&gt; . Consulte &lt;code&gt;&lt;a href=&quot;#inflateSetDictionary-2&quot;&gt;inflateSetDictionary/2&lt;/a&gt;&lt;/code&gt; ) para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="83f7f43de6aead79d3e988b3241d9856a34d875b" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; is called automatically.</source>
          <target state="translated">Si un proceso llama &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; sin establecer una semilla primero, &lt;code&gt;&lt;a href=&quot;#seed-0&quot;&gt;seed/0&lt;/a&gt;&lt;/code&gt; se llama autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="a36c70330162b05d5a32dea8c99f296dd07fa13f" translate="yes" xml:space="preserve">
          <source>If a process calls &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; without setting a seed first, &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; is called automatically with the default algorithm and creates a non-constant seed.</source>
          <target state="translated">Si un proceso llama a &lt;code&gt;&lt;a href=&quot;#uniform-0&quot;&gt;uniform/0&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#uniform-1&quot;&gt;uniform/1&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#uniform_real-0&quot;&gt;uniform_real/0&lt;/a&gt;&lt;/code&gt; sin establecer una semilla primero, la &lt;code&gt;&lt;a href=&quot;#seed-1&quot;&gt;seed/1&lt;/a&gt;&lt;/code&gt; se llama autom&amp;aacute;ticamente con el algoritmo predeterminado y crea una semilla no constante.</target>
        </trans-unit>
        <trans-unit id="ee2bd61bda12e84b2a6d621165135cd3817f20fe" translate="yes" xml:space="preserve">
          <source>If a process having the driver loaded dies, it has the same effect as if unloading is done.</source>
          <target state="translated">Si un proceso que tiene al conductor cargado muere,tiene el mismo efecto que si se hace la descarga.</target>
        </trans-unit>
        <trans-unit id="15014d5a4ff0f8066241b0151c8891a216ed87df" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a busy port, a message &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending to &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">Si un proceso en el sistema se suspende porque env&amp;iacute;a a un puerto ocupado, se env&amp;iacute;a un mensaje &lt;code&gt;{monitor, SusPid, busy_port, Port}&lt;/code&gt; a &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;SusPid&lt;/code&gt; es el pid que se suspendi&amp;oacute; al enviar a &lt;code&gt;Port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d68a1d07888243eae02b4e13f79a1936bb61d64" translate="yes" xml:space="preserve">
          <source>If a process in the system gets suspended because it sends to a process on a remote node whose inter-node communication was handled by a busy port, a message &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;SusPid&lt;/code&gt; is the pid that got suspended when sending through the inter-node communication port &lt;code&gt;Port&lt;/code&gt;.</source>
          <target state="translated">Si un proceso en el sistema se suspende porque env&amp;iacute;a a un proceso en un nodo remoto cuya comunicaci&amp;oacute;n entre nodos fue manejada por un puerto ocupado, se env&amp;iacute;a un mensaje &lt;code&gt;{monitor, SusPid, busy_dist_port, Port}&lt;/code&gt; a &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;SusPid&lt;/code&gt; es el pid que se suspendi&amp;oacute; al enviar a trav&amp;eacute;s del puerto de comunicaci&amp;oacute;n entre nodos &lt;code&gt;Port&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c045c61e4349e5f89593c090cba3d3de09bd27de" translate="yes" xml:space="preserve">
          <source>If a process is put into or removed from the run queue, a message, &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;. Running processes that are reinserted into the run queue after having been pre-empted do not trigger this message.</source>
          <target state="translated">Si un proceso se coloca o se elimina de la cola de ejecuci&amp;oacute;n , se env&amp;iacute;a un mensaje, &lt;code&gt;{profile, Pid, State, Mfa, Ts}&lt;/code&gt; , a &lt;code&gt;ProfilerPid&lt;/code&gt; . Los procesos en ejecuci&amp;oacute;n que se reinsertan en la cola de ejecuci&amp;oacute;n despu&amp;eacute;s de haber sido reemplazados no desencadenan este mensaje.</target>
        </trans-unit>
        <trans-unit id="4105e92988b9e0273b2afe1380f53a0c26000be5" translate="yes" xml:space="preserve">
          <source>If a process or port in the system runs uninterrupted for at least &lt;code&gt;Time&lt;/code&gt; wall clock milliseconds, a message &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; is sent to &lt;code&gt;MonitorPid&lt;/code&gt;. &lt;code&gt;PidOrPort&lt;/code&gt; is the process or port that was running. &lt;code&gt;Info&lt;/code&gt; is a list of two-element tuples describing the event.</source>
          <target state="translated">Si un proceso o puerto en el sistema se ejecuta ininterrumpidamente durante al menos milisegundos de reloj de pared de &lt;code&gt;Time&lt;/code&gt; &lt;code&gt;{monitor, PidOrPort, long_schedule, Info}&lt;/code&gt; un mensaje {monitor, PidOrPort, long_schedule, Info} a &lt;code&gt;MonitorPid&lt;/code&gt; . &lt;code&gt;PidOrPort&lt;/code&gt; es el proceso o puerto que se estaba ejecutando. &lt;code&gt;Info&lt;/code&gt; es una lista de tuplas de dos elementos que describen el evento.</target>
        </trans-unit>
        <trans-unit id="4369b22f5f2ff0b202004df9cfaa90a8b5c4a981" translate="yes" xml:space="preserve">
          <source>If a process simply keeps binaries (either in &quot;loop data&quot; or in the process dictionary), the garbage collector can eventually shrink the binaries. If only one such binary is kept, it will not be shrunk. If the process later appends to a binary that has been shrunk, the binary object will be reallocated to make place for the data to be appended.</source>
          <target state="translated">Si un proceso simplemente guarda binarios (ya sea en &quot;datos de bucle&quot; o en el diccionario de procesos),el recolector de basura puede eventualmente encoger los binarios.Si sólo se guarda un binario de este tipo,no se encogerá.Si el proceso se añade posteriormente a un binario que se ha reducido,el objeto binario se reasignará para hacer lugar a los datos que se añadan.</target>
        </trans-unit>
        <trans-unit id="f775d4e54bbee2d9dbda35be5042e4e186972f7c" translate="yes" xml:space="preserve">
          <source>If a process that holds a lock dies, or the node goes down, the locks held by the process are deleted.</source>
          <target state="translated">Si un proceso que mantiene un bloqueo muere,o el nodo se cae,los bloqueos mantenidos por el proceso se eliminan.</target>
        </trans-unit>
        <trans-unit id="349bb33896dc8851d34347287725d343380e07fb" translate="yes" xml:space="preserve">
          <source>If a process with a registered name dies, or the node goes down, the name is unregistered on all nodes.</source>
          <target state="translated">Si un proceso con un nombre registrado muere,o el nodo se cae,el nombre no está registrado en todos los nodos.</target>
        </trans-unit>
        <trans-unit id="17f27468045dfd75afeb4d681d13f4dbea90b34b" translate="yes" xml:space="preserve">
          <source>If a process, &lt;code&gt;P&lt;/code&gt;, is spawned during execution of, for example, &lt;code&gt;init_per_suite/1&lt;/code&gt;, it inherits the group leader of the &lt;code&gt;init_per_suite&lt;/code&gt; process. This group leader is the central I/O server process mentioned earlier. If, at a later time, &lt;strong&gt;during parallel test case execution&lt;/strong&gt;, some event triggers process &lt;code&gt;P&lt;/code&gt; to call &lt;code&gt;io:format/1/2&lt;/code&gt;, that call never returns (as the group leader is in a non-responsive state) and causes &lt;code&gt;P&lt;/code&gt; to hang.</source>
          <target state="translated">Si un proceso, &lt;code&gt;P&lt;/code&gt; , se genera durante la ejecuci&amp;oacute;n de, por ejemplo, &lt;code&gt;init_per_suite/1&lt;/code&gt; , hereda el l&amp;iacute;der de grupo del proceso &lt;code&gt;init_per_suite&lt;/code&gt; . Este l&amp;iacute;der de grupo es el proceso del servidor de E / S central mencionado anteriormente. Si, en un momento posterior, &lt;strong&gt;durante la ejecuci&amp;oacute;n del caso de prueba en paralelo&lt;/strong&gt; , alg&amp;uacute;n evento activa el proceso &lt;code&gt;P&lt;/code&gt; para llamar a &lt;code&gt;io:format/1/2&lt;/code&gt; , esa llamada nunca regresa (ya que el l&amp;iacute;der del grupo est&amp;aacute; en un estado de no respuesta) y hace que &lt;code&gt;P&lt;/code&gt; se cuelgue .</target>
        </trans-unit>
        <trans-unit id="ff1cac2bbd83699ad97f93b747512a76b2a8a979" translate="yes" xml:space="preserve">
          <source>If a range that includes letters is used when caseless matching is set, it matches the letters in either case. For example, [W-c] is equivalent to [][\\^_`wxyzabc], matched caselessly. In a non-UTF mode, if character tables for a French locale are in use, [\xc8-\xcb] matches accented E characters in both cases. In UTF modes, PCRE supports the concept of case for characters with values &amp;gt; 255 only when it is compiled with Unicode property support.</source>
          <target state="translated">Si se utiliza un rango que incluye letras cuando se establece la coincidencia sin may&amp;uacute;sculas, coincidir&amp;aacute; con las letras en cualquier caso. Por ejemplo, [Wc] es equivalente a [] [\\ ^ _ `wxyzabc], emparejado sin may&amp;uacute;sculas. En un modo no UTF, si se utilizan tablas de caracteres para una configuraci&amp;oacute;n regional francesa, [\ xc8- \ xcb] coincide con los caracteres E acentuados en ambos casos. En los modos UTF, PCRE admite el concepto de may&amp;uacute;sculas y min&amp;uacute;sculas para caracteres con valores&amp;gt; 255 solo cuando se compila con soporte de propiedad Unicode.</target>
        </trans-unit>
        <trans-unit id="cefcc947210800042f579f6706da18141c734c3a" translate="yes" xml:space="preserve">
          <source>If a received message contains several transaction requests, this option indicates whether the requests should be handled sequentially in the same process (&lt;code&gt;false&lt;/code&gt;), or if each request should be handled by its own process (&lt;code&gt;true&lt;/code&gt; i.e. a separate process is spawned for each request).</source>
          <target state="translated">Si un mensaje recibido contiene varias solicitudes de transacci&amp;oacute;n, esta opci&amp;oacute;n indica si las solicitudes deben manejarse secuencialmente en el mismo proceso ( &lt;code&gt;false&lt;/code&gt; ), o si cada solicitud debe ser manejada por su propio proceso ( &lt;code&gt;true&lt;/code&gt; es decir, se genera un proceso separado para cada solicitud) .</target>
        </trans-unit>
        <trans-unit id="b2fc74a5a7f43f310bc65da23c24d79b44a52f9d" translate="yes" xml:space="preserve">
          <source>If a record is stuck at node &lt;code&gt;N1&lt;/code&gt; and you try to set a sticky lock for the record on node &lt;code&gt;N2&lt;/code&gt;, the record must be unstuck. This operation is expensive and reduces performance. The unsticking is done automatically if you issue &lt;code&gt;s_write/1&lt;/code&gt; requests at &lt;code&gt;N2&lt;/code&gt;.</source>
          <target state="translated">Si un registro est&amp;aacute; atascado en el nodo &lt;code&gt;N1&lt;/code&gt; e intenta establecer un bloqueo fijo para el registro en el nodo &lt;code&gt;N2&lt;/code&gt; , el registro debe despegarse. Esta operaci&amp;oacute;n es cara y reduce el rendimiento. El despegue se realiza autom&amp;aacute;ticamente si emite solicitudes &lt;code&gt;s_write/1&lt;/code&gt; en &lt;code&gt;N2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7bbe2237d0bda60b504f73886161206ea6b2f204" translate="yes" xml:space="preserve">
          <source>If a record is used in several modules, it is recommended that the record definition is placed in an include file.</source>
          <target state="translated">Si un registro se utiliza en varios módulos,se recomienda que la definición del registro se coloque en un archivo de inclusión.</target>
        </trans-unit>
        <trans-unit id="e2be8cb7a69f1955706c91f4c83ac23caeea40af" translate="yes" xml:space="preserve">
          <source>If a recoverable error occurs, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; and the original application specifications are restored. If a non-recoverable error occurs, the system is restarted.</source>
          <target state="translated">Si ocurre un error recuperable, la funci&amp;oacute;n devuelve &lt;code&gt;{error,Reason}&lt;/code&gt; y se restauran las especificaciones originales de la aplicaci&amp;oacute;n. Si se produce un error no recuperable, se reinicia el sistema.</target>
        </trans-unit>
        <trans-unit id="22cf54ba81d8faabf766e624c3e7d1674171bb89" translate="yes" xml:space="preserve">
          <source>If a regular core dump is wanted, let &lt;code&gt;heart&lt;/code&gt; know by setting the kill signal to abort using environment variable &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt;. If unset, or not set to &lt;code&gt;SIGABRT&lt;/code&gt;, the default behavior is a kill signal using &lt;code&gt;SIGKILL&lt;/code&gt;:</source>
          <target state="translated">Si se desea un volcado de n&amp;uacute;cleo regular, av&amp;iacute;sele al &lt;code&gt;heart&lt;/code&gt; configurando la se&amp;ntilde;al de interrupci&amp;oacute;n para abortar usando la variable de entorno &lt;code&gt;HEART_KILL_SIGNAL=SIGABRT&lt;/code&gt; . Si no se establece, o no se establece en &lt;code&gt;SIGABRT&lt;/code&gt; , el comportamiento predeterminado es una se&amp;ntilde;al de &lt;code&gt;SIGKILL&lt;/code&gt; mediante SIGKILL :</target>
        </trans-unit>
        <trans-unit id="cc4cda006faf8c5c4a357b487a51055ca7991742" translate="yes" xml:space="preserve">
          <source>If a regular directory called &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Name-Vsn&lt;/code&gt; exists in the code path with an &lt;code&gt;ebin&lt;/code&gt; subdirectory, the path to this directory is returned (not the &lt;code&gt;ebin&lt;/code&gt; directory).</source>
          <target state="translated">Si existe un directorio normal llamado &lt;code&gt;Name&lt;/code&gt; o &lt;code&gt;Name-Vsn&lt;/code&gt; en la ruta del c&amp;oacute;digo con un subdirectorio &lt;code&gt;ebin&lt;/code&gt; , se devuelve la ruta a este directorio (no el directorio &lt;code&gt;ebin&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5d41dbfbe2ec7024dcb9b99c3ee2932c5b54d378" translate="yes" xml:space="preserve">
          <source>If a reply to a request is not received in time, the megaco stack removes all info about the request from its tables. If a reply should arrive after this has been done the app has no way of knowing where to send this message. The message is delivered to the &quot;user&quot; by calling this function on the local node (the node which has the link).</source>
          <target state="translated">Si no se recibe una respuesta a tiempo a una solicitud,la pila de megaco retira toda la información sobre la solicitud de sus mesas.Si una respuesta llegara después de esto,la aplicación no tiene forma de saber dónde enviar este mensaje.El mensaje se entrega al &quot;usuario&quot; llamando a esta función en el nodo local (el nodo que tiene el enlace).</target>
        </trans-unit>
        <trans-unit id="98d501fda955c0480d302e83623ef7940c95c989" translate="yes" xml:space="preserve">
          <source>If a row is created, we always set the internal column to &lt;code&gt;&quot;internal&quot;&lt;/code&gt;.</source>
          <target state="translated">Si se crea una fila, siempre establecemos la columna interna en &lt;code&gt;&quot;internal&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1ebc1546b581fe9ec3e1aa902afae9065bac8290" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, an error event is logged. To verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si un planificador no se puede vincular, esto a menudo se ignora en silencio, ya que no siempre es posible verificar identificadores de procesador l&amp;oacute;gico v&amp;aacute;lidos. Si se informa un error, se registra un evento de error. Para verificar que los planificadores se hayan enlazado seg&amp;uacute;n lo solicitado, llame a &lt;code&gt;&lt;a href=&quot;#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95196719288c8a4037a8712bcbf85254190e9568" translate="yes" xml:space="preserve">
          <source>If a scheduler fails to bind, this is often silently ignored, as it is not always possible to verify valid logical processor identifiers. If an error is reported, it is reported to the &lt;code&gt;error_logger&lt;/code&gt;. If you want to verify that the schedulers have bound as requested, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si un planificador no se puede vincular, esto a menudo se ignora en silencio, ya que no siempre es posible verificar identificadores de procesador l&amp;oacute;gico v&amp;aacute;lidos. Si se informa de un error, se informa al &lt;code&gt;error_logger&lt;/code&gt; . Si desea verificar que los planificadores se hayan enlazado seg&amp;uacute;n lo solicitado, llame a &lt;code&gt;&lt;a href=&quot;erlang#system_info_scheduler_bindings&quot;&gt;erlang:system_info(scheduler_bindings)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70c51b792a482c1acceec2498ed07a15eeff4e4d" translate="yes" xml:space="preserve">
          <source>If a scheduler is put to sleep or awoken, a message, &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt;, is sent to &lt;code&gt;ProfilerPid&lt;/code&gt;.</source>
          <target state="translated">Si un programador se pone en suspensi&amp;oacute;n o se &lt;code&gt;{profile, scheduler, Id, State, NoScheds, Ts}&lt;/code&gt; , se env&amp;iacute;a un mensaje, {perfil, programador, Id, Estado, NoScheds, Ts} , a &lt;code&gt;ProfilerPid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c83d78ce9bb009d70f32a1197570bf9131a81777" translate="yes" xml:space="preserve">
          <source>If a scheduler thread create a new reference each nano second, references will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">Si un hilo del programador crea una nueva referencia cada nano segundo,las referencias se reutilizarán como mínimo después de más de 584 años.Es decir,en el futuro previsible son lo suficientemente únicas.</target>
        </trans-unit>
        <trans-unit id="4907dacbb20e81759e0cdf9eb1879f2ddefb0697" translate="yes" xml:space="preserve">
          <source>If a script is found, the first thing that happens is that the application specifications are updated according to the &lt;code&gt;.app&lt;/code&gt; files and &lt;code&gt;sys.config&lt;/code&gt; belonging to the release version &lt;code&gt;Vsn&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra una secuencia de comandos, lo primero que sucede es que las especificaciones de la aplicaci&amp;oacute;n se actualizan de acuerdo con las &lt;code&gt;.app&lt;/code&gt; archivos y &lt;code&gt;sys.config&lt;/code&gt; perteneciente a la versi&amp;oacute;n de lanzamiento &lt;code&gt;Vsn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84d4a6395eb04a368d97e3a781384bca1f8ac150" translate="yes" xml:space="preserve">
          <source>If a shuffled test case group is repeated, the seed is not reset between turns.</source>
          <target state="translated">Si se repite un grupo de casos de prueba barajado,la semilla no se reajusta entre los turnos.</target>
        </trans-unit>
        <trans-unit id="f211a4f0b3b5f8149bc67ba0e458b150aec8e31c" translate="yes" xml:space="preserve">
          <source>If a simple extension has been made to a functional module, it is sufficient to load the new version of the module into the system, and remove the old version. This is called &lt;strong&gt;simple code replacement&lt;/strong&gt; and for this the following instruction is used:</source>
          <target state="translated">Si se ha realizado una extensi&amp;oacute;n simple a un m&amp;oacute;dulo funcional, es suficiente cargar la nueva versi&amp;oacute;n del m&amp;oacute;dulo en el sistema y eliminar la versi&amp;oacute;n anterior. Esto se denomina &lt;strong&gt;reemplazo de c&amp;oacute;digo simple&lt;/strong&gt; y para esto se usa la siguiente instrucci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="820e1f62550d2d1dc4b7d5110225b45b02793e4e" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it.</source>
          <target state="translated">Si un socket se ha conectado de alguna manera sin usar &lt;code&gt;gen_tcp&lt;/code&gt; , use esta opci&amp;oacute;n para pasarle el descriptor de archivo.</target>
        </trans-unit>
        <trans-unit id="bf685931edb5e2ee94fb5c82e823cca317fe8b98" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been connected without using &lt;code&gt;gen_tcp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;{ip, Address}&lt;/code&gt; and/or &lt;code&gt;{port, port_number()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port before connecting. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">Si un socket se ha conectado de alguna manera sin usar &lt;code&gt;gen_tcp&lt;/code&gt; , use esta opci&amp;oacute;n para pasarle el descriptor de archivo. Si &lt;code&gt;{ip, Address}&lt;/code&gt; y / o &lt;code&gt;{port, port_number()}&lt;/code&gt; se combinan con esta opci&amp;oacute;n, el &lt;code&gt;fd&lt;/code&gt; est&amp;aacute; vinculado a la interfaz y al puerto especificados antes de conectarse. Si no se especifican estas opciones, se supone que el &lt;code&gt;fd&lt;/code&gt; ya est&amp;aacute; vinculado de forma adecuada.</target>
        </trans-unit>
        <trans-unit id="88d20f7afcab3c9941388d26759eb43e0f494eda" translate="yes" xml:space="preserve">
          <source>If a socket has somehow been opened without using &lt;code&gt;gen_udp&lt;/code&gt;, use this option to pass the file descriptor for it. If &lt;code&gt;Port&lt;/code&gt; is not set to &lt;code&gt;0&lt;/code&gt; and/or &lt;code&gt;{ip, ip_address()}&lt;/code&gt; is combined with this option, the &lt;code&gt;fd&lt;/code&gt; is bound to the specified interface and port after it is being opened. If these options are not specified, it is assumed that the &lt;code&gt;fd&lt;/code&gt; is already bound appropriately.</source>
          <target state="translated">Si un socket se ha abierto de alguna manera sin usar &lt;code&gt;gen_udp&lt;/code&gt; , use esta opci&amp;oacute;n para pasarle el descriptor de archivo. Si &lt;code&gt;Port&lt;/code&gt; no se establece en &lt;code&gt;0&lt;/code&gt; y / o &lt;code&gt;{ip, ip_address()}&lt;/code&gt; se combina con esta opci&amp;oacute;n, el &lt;code&gt;fd&lt;/code&gt; se vincula a la interfaz y al puerto especificados despu&amp;eacute;s de que se abre. Si no se especifican estas opciones, se supone que el &lt;code&gt;fd&lt;/code&gt; ya est&amp;aacute; vinculado de forma adecuada.</target>
        </trans-unit>
        <trans-unit id="c3d4cd539d93fb17b915657f42699b04d0414500" translate="yes" xml:space="preserve">
          <source>If a socket is connected already, option &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; can be used to pass the open file descriptor to &lt;code&gt;gen_udp&lt;/code&gt;. This can be automated by using a command-line argument stating the prebound file descriptor number. For example, if the port is 69 and file descriptor 22 is opened by &lt;code&gt;setuid_socket_wrap&lt;/code&gt;, the command-line argument &quot;-tftpd_69 22&quot; triggers the prebound file descriptor 22 to be used instead of opening port 69. The UDP option &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; is automatically added. See &lt;code&gt;init:get_argument/&lt;/code&gt; about command-line arguments and &lt;code&gt;gen_udp:open/2&lt;/code&gt; about UDP options.</source>
          <target state="translated">Si un conector ya est&amp;aacute; conectado, la opci&amp;oacute;n &lt;code&gt;{udp, [{fd, integer()}]}&lt;/code&gt; se puede usar para pasar el descriptor de archivo abierto a &lt;code&gt;gen_udp&lt;/code&gt; . Esto se puede automatizar mediante el uso de un argumento de l&amp;iacute;nea de comandos que indique el n&amp;uacute;mero de descriptor de archivo predefinido. Por ejemplo, si el puerto es 69 y &lt;code&gt;setuid_socket_wrap&lt;/code&gt; abre el descriptor de archivo 22 , el argumento de la l&amp;iacute;nea de comandos &quot;-tftpd_69 22&quot; activa el descriptor de archivo 22 preenlazado que se utilizar&amp;aacute; en lugar de abrir el puerto 69. La opci&amp;oacute;n UDP &lt;code&gt;{udp, [{fd, 22}]}&lt;/code&gt; se agrega autom&amp;aacute;ticamente. Consulte &lt;code&gt;init:get_argument/&lt;/code&gt; sobre los argumentos de la l&amp;iacute;nea de comandos y &lt;code&gt;gen_udp:open/2&lt;/code&gt; sobre las opciones de UDP.</target>
        </trans-unit>
        <trans-unit id="8adda14107128cbabef9332c232b6afdafabc519" translate="yes" xml:space="preserve">
          <source>If a subgroup is specified in a group with a &lt;code&gt;shuffle&lt;/code&gt; property, the execution order of this subgroup in relation to the test cases (and other subgroups) in the group, is random. The order of the test cases in the subgroup is however not random (unless the subgroup has a &lt;code&gt;shuffle&lt;/code&gt; property).</source>
          <target state="translated">Si se especifica un subgrupo en un grupo con una propiedad de &lt;code&gt;shuffle&lt;/code&gt; , el orden de ejecuci&amp;oacute;n de este subgrupo en relaci&amp;oacute;n con los casos de prueba (y otros subgrupos) del grupo es aleatorio. Sin embargo, el orden de los casos de prueba en el subgrupo no es aleatorio (a menos que el subgrupo tenga una propiedad de &lt;code&gt;shuffle&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f8f9318070c1a0b76966d2350817b608770dbd93" translate="yes" xml:space="preserve">
          <source>If a synchronous call to a port from a process is done, the calling process is considered not runnable during the call runtime to the port. The calling process is notified as &lt;code&gt;inactive&lt;/code&gt;, and later &lt;code&gt;active&lt;/code&gt; when the port callback returns.</source>
          <target state="translated">Si se realiza una llamada s&amp;iacute;ncrona a un puerto desde un proceso, el proceso de llamada se considera no ejecutable durante el tiempo de ejecuci&amp;oacute;n de la llamada al puerto. El proceso de llamada se notifica como &lt;code&gt;inactive&lt;/code&gt; y luego &lt;code&gt;active&lt;/code&gt; cuando vuelve la devoluci&amp;oacute;n de llamada del puerto.</target>
        </trans-unit>
        <trans-unit id="03163668ea38b2448adbb495833cb5c9d2fb18c2" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;bag&lt;/code&gt;, it can sometimes be needed to delete only some of the records with a certain key. This can be done with the function &lt;code&gt;delete_object/3&lt;/code&gt;. A complete record must be supplied to this function.</source>
          <target state="translated">Si una tabla es de tipo &lt;code&gt;bag&lt;/code&gt; , a veces puede ser necesario borrar solo algunos de los registros con una determinada clave. Esto se puede hacer con la funci&amp;oacute;n &lt;code&gt;delete_object/3&lt;/code&gt; . Se debe proporcionar un registro completo para esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d6399fd24f009cc3e3ffb42705ab75b017db16fb" translate="yes" xml:space="preserve">
          <source>If a table is of type &lt;code&gt;set&lt;/code&gt;, each key leads to either one or zero records.</source>
          <target state="translated">Si una tabla es de tipo &lt;code&gt;set&lt;/code&gt; , cada clave conduce a uno o cero registros.</target>
        </trans-unit>
        <trans-unit id="cc60ddbc56bced221eb285cedf24eccba7391477" translate="yes" xml:space="preserve">
          <source>If a temporary application terminates, this is reported but no other applications are terminated.</source>
          <target state="translated">Si una aplicación temporal termina,se informa de ello pero no se terminan otras aplicaciones.</target>
        </trans-unit>
        <trans-unit id="1c78c30e29b702d609a635a08cca518cae737159" translate="yes" xml:space="preserve">
          <source>If a terminal symbol is the only member of a category, and the symbol name is identical to the category name, the token format may be &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt;.</source>
          <target state="translated">Si un s&amp;iacute;mbolo de terminal es el &amp;uacute;nico miembro de una categor&amp;iacute;a y el nombre del s&amp;iacute;mbolo es id&amp;eacute;ntico al nombre de la categor&amp;iacute;a, el formato del token puede ser &lt;code&gt;{Symbol, LineNumber}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39831a6256c96762c2da58783be93b30bfb60bf0" translate="yes" xml:space="preserve">
          <source>If a test case belonging to a group (according to the group definition) is executed without a group specification, that is, simply by (using the command line):</source>
          <target state="translated">Si un caso de prueba perteneciente a un grupo (según la definición de grupo)se ejecuta sin una especificación de grupo,es decir,simplemente (utilizando la línea de comandos):</target>
        </trans-unit>
        <trans-unit id="502798b518aba9797ae119aec810b4ce5b5d0729" translate="yes" xml:space="preserve">
          <source>If a test case fails, this funcion is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si falla un caso de prueba, esta funci&amp;oacute;n se llama despu&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="335080793d3bf721193087f47f63eafaac01cbbd" translate="yes" xml:space="preserve">
          <source>If a test case is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se omite un caso de prueba, esta funci&amp;oacute;n se llama despu&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;#Module:post_end_per_testcase-5&quot;&gt;post_end_per_testcase&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6a471993c391b1bd64637c48e80cd9c14d7854c" translate="yes" xml:space="preserve">
          <source>If a test case needs to suspend itself for a time that also gets multipled by &lt;code&gt;multiply_timetraps&lt;/code&gt; (and possibly also scaled up if &lt;code&gt;scale_timetraps&lt;/code&gt; is enabled), the function &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; can be used (instead of, for example, &lt;code&gt;timer:sleep/1&lt;/code&gt;).</source>
          <target state="translated">Si un caso de prueba necesita suspenderse por un tiempo que tambi&amp;eacute;n se &lt;code&gt;multiply_timetraps&lt;/code&gt; por multiply_timetraps (y posiblemente tambi&amp;eacute;n se escala si &lt;code&gt;scale_timetraps&lt;/code&gt; est&amp;aacute; habilitado), se puede usar la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ct#sleep-1&quot;&gt;ct:sleep/1&lt;/a&gt;&lt;/code&gt; (en lugar de, por ejemplo, &lt;code&gt;timer:sleep/1&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5226c324f9ac4409e33361c519af1aca1d4d0288" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it are terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">Si se carga una tercera instancia del módulo,el servidor de códigos elimina (purga)el código antiguo y se terminan todos los procesos que persisten en él.Entonces la tercera instancia se convierte en &quot;actual&quot; y el código previamente actual se convierte en &quot;antiguo&quot;.</target>
        </trans-unit>
        <trans-unit id="4b71ff8bf7808e50acef36bf51fec54b753b169f" translate="yes" xml:space="preserve">
          <source>If a third instance of the module is loaded, the code server removes (purges) the old code and any processes lingering in it is terminated. Then the third instance becomes 'current' and the previously current code becomes 'old'.</source>
          <target state="translated">Si se carga una tercera instancia del módulo,el servidor de códigos elimina (purga)el código antiguo y se termina cualquier proceso que quede en él.Entonces la tercera instancia se convierte en &quot;actual&quot; y el código previamente actual se convierte en &quot;antiguo&quot;.</target>
        </trans-unit>
        <trans-unit id="9b209316ada835a355f0bceb58d85107e4df7fa7" translate="yes" xml:space="preserve">
          <source>If a thread is already working, the calls are queued up and executed in order. Using the same thread for each driver instance ensures that the calls are made in sequence.</source>
          <target state="translated">Si un hilo ya funciona,las llamadas se ponen en cola y se ejecutan en orden.Usar el mismo hilo para cada instancia del controlador asegura que las llamadas se hagan en secuencia.</target>
        </trans-unit>
        <trans-unit id="f81497c9931883554b1a22b52663496f9755cc27" translate="yes" xml:space="preserve">
          <source>If a thread pool is available, a thread is used. If argument &lt;code&gt;key&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, the threads from the pool are used in a round-robin way, each call to &lt;code&gt;driver_async&lt;/code&gt; uses the next thread in the pool. With argument &lt;code&gt;key&lt;/code&gt; set, this behavior is changed. The two same values of &lt;code&gt;*key&lt;/code&gt; always get the same thread.</source>
          <target state="translated">Si hay un grupo de subprocesos disponible, se utiliza un subproceso. Si la &lt;code&gt;key&lt;/code&gt; argumento es &lt;code&gt;NULL&lt;/code&gt; , los subprocesos del grupo se utilizan de forma &lt;code&gt;driver_async&lt;/code&gt; , cada llamada a driver_async utiliza el siguiente subproceso del grupo. Con la &lt;code&gt;key&lt;/code&gt; argumento establecida, este comportamiento cambia. Los dos mismos valores de &lt;code&gt;*key&lt;/code&gt; siempre obtienen el mismo hilo.</target>
        </trans-unit>
        <trans-unit id="4f35f3c6d4b31e8b5610fe46bbb2c396d6dec610" translate="yes" xml:space="preserve">
          <source>If a trace port (see &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;) is running on the local node, remote nodes can not be traced with a tracer process. The error reason &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; is returned. A trace port can however be started on the remote node with the &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Si un puerto de rastreo (consulte &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; ) se est&amp;aacute; ejecutando en el nodo local, los nodos remotos no se pueden rastrear con un proceso de rastreo. Se &lt;code&gt;cant_trace_remote_pid_to_local_port&lt;/code&gt; motivo del error cant_trace_remote_pid_to_local_port . Sin embargo, se puede iniciar un puerto de rastreo en el nodo remoto con la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="763b6ed1f9356f6927dce6575fc162a00e017c98" translate="yes" xml:space="preserve">
          <source>If a tracer is specified in both lists, the tracer in the enable list takes precedence. If no tracer is specified, the same tracer as the process executing the match specification is used (not the meta tracer). If that process doesn't have tracer either, then trace flags are ignored.</source>
          <target state="translated">Si se especifica un trazador en ambas listas,el trazador de la lista de activación tiene prioridad.Si no se especifica un trazador,se utiliza el mismo trazador que el proceso que ejecuta la especificación de coincidencia (no el meta trazador).Si ese proceso tampoco tiene trazador,entonces se ignoran las marcas de trazador.</target>
        </trans-unit>
        <trans-unit id="b082e683a06ac559acb1ef17f3dfa0a3a24bd825" translate="yes" xml:space="preserve">
          <source>If a transaction involves updates of asymmetrically replicated tables or updates of the schema table, a heavyweight commit protocol is used. This protocol can finish the transaction regardless of how the tables are replicated. The typical use of a heavyweight transaction is when a replica is to be moved from one node to another. Then ensure that the replica either is entirely moved or left as it was. Do never end up in a situation with replicas on both nodes, or on no node at all. Even if a node crashes in the middle of the commit protocol, the transaction must be guaranteed to be atomic. The heavyweight commit protocol involves more messages between the transaction coordinator and its participants than a lightweight protocol, and it performs recovery work at startup to finish the terminating or commit work.</source>
          <target state="translated">Si una transacción implica actualizaciones de tablas reproducidas asimétricamente o actualizaciones de la tabla de esquema,se utiliza un protocolo de confirmación de peso pesado.Este protocolo puede finalizar la transacción independientemente de cómo se repliquen las tablas.El uso típico de una transacción de peso pesado es cuando una réplica debe ser movida de un nodo a otro.Entonces,asegúrese de que la réplica se mueve completamente o se deja como estaba.Nunca termines en una situación con réplicas en ambos nodos,o en ningún nodo en absoluto.Incluso si un nodo se bloquea en medio del protocolo de confirmación,la transacción debe garantizarse que sea atómica.El protocolo de confirmación de peso pesado implica más mensajes entre el coordinador de la transacción y sus participantes que un protocolo de peso ligero,y realiza un trabajo de recuperación al inicio para terminar el trabajo de terminación o de confirmación.</target>
        </trans-unit>
        <trans-unit id="be9ed32b4b23ddaaa7542c4292ca46e3b1d16e3a" translate="yes" xml:space="preserve">
          <source>If a transaction terminates abnormally, &lt;code&gt;Mnesia&lt;/code&gt; automatically releases the locks held by the transaction.</source>
          <target state="translated">Si una transacci&amp;oacute;n finaliza de forma anormal, &lt;code&gt;Mnesia&lt;/code&gt; libera autom&amp;aacute;ticamente los bloqueos retenidos por la transacci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d768f6b886e49430d7bcd0e5e091ee1cc5e44534" translate="yes" xml:space="preserve">
          <source>If a transient application terminates abnormally, all other applications and the entire Erlang node are also terminated.</source>
          <target state="translated">Si una aplicación transitoria termina de forma anormal,todas las demás aplicaciones y todo el nodo Erlang también terminan.</target>
        </trans-unit>
        <trans-unit id="1b042eac1f57ab6a81bbf8b7e159e1151ec77d9d" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with &lt;code&gt;Reason == normal&lt;/code&gt;, this is reported but no other applications are terminated.</source>
          <target state="translated">Si una aplicaci&amp;oacute;n transitoria termina con &lt;code&gt;Reason == normal&lt;/code&gt; , esto se informa pero no se terminan otras aplicaciones.</target>
        </trans-unit>
        <trans-unit id="7d851ba83013456de4862df5a0550756dd9ddcb5" translate="yes" xml:space="preserve">
          <source>If a transient application terminates with reason &lt;code&gt;normal&lt;/code&gt;, this is reported but no other applications are terminated. If a transient application terminates abnormally, that is with any other reason than &lt;code&gt;normal&lt;/code&gt;, all other applications and the runtime system are also terminated.</source>
          <target state="translated">Si una aplicaci&amp;oacute;n transitoria finaliza con un motivo &lt;code&gt;normal&lt;/code&gt; , se informa, pero no se finaliza ninguna otra aplicaci&amp;oacute;n. Si una aplicaci&amp;oacute;n transitoria termina de forma anormal, es decir, por cualquier otra raz&amp;oacute;n que no sea la &lt;code&gt;normal&lt;/code&gt; , todas las dem&amp;aacute;s aplicaciones y el sistema de tiempo de ejecuci&amp;oacute;n tambi&amp;eacute;n se terminan.</target>
        </trans-unit>
        <trans-unit id="2a6dabddba08d7663fc55e59a178732b34a37ab9" translate="yes" xml:space="preserve">
          <source>If a unique integer is created each nano second, unique integers will at earliest be reused after more than 584 years. That is, for the foreseeable future they are unique enough.</source>
          <target state="translated">Si se crea un número entero único cada nano segundo,los números enteros únicos se reutilizarán como mínimo después de más de 584 años.Es decir,para el futuro previsible son lo suficientemente únicos.</target>
        </trans-unit>
        <trans-unit id="8212ea9be32c0602ffe0b39d535c8ff1c3704caf" translate="yes" xml:space="preserve">
          <source>If a user wants to run only a subset of a test suite, there is no way one test case could successfully depend on another.</source>
          <target state="translated">Si un usuario quiere ejecutar sólo un subconjunto de un conjunto de pruebas,no hay manera de que un caso de prueba pueda depender exitosamente de otro.</target>
        </trans-unit>
        <trans-unit id="7a2111f1ccabd04661a065f18bb26413e12a43cc" translate="yes" xml:space="preserve">
          <source>If a value for an object is not given to the &lt;code&gt;send_notification&lt;/code&gt; function, the sub-agent will perform a get-operation to retrieve it. If the object is not implemented in this sub-agent, its parent agent tries to perform a get-operation to retrieve it. If the object is not implemented in this agent either, it forwards the object to its parent, and so on. Eventually the Master Agent is reached and at this point all unknown object values must be resolved. If some object is unknown even to the Master Agent, this is regarded as an error and is reported with a call to &lt;code&gt;user_err/2&lt;/code&gt; of the error report module. No notifications are sent in this case.</source>
          <target state="translated">Si no se le da un valor para un objeto a la funci&amp;oacute;n &lt;code&gt;send_notification&lt;/code&gt; , el subagente realizar&amp;aacute; una operaci&amp;oacute;n de obtenci&amp;oacute;n para recuperarlo. Si el objeto no est&amp;aacute; implementado en este agente secundario, su agente principal intenta realizar una operaci&amp;oacute;n de obtenci&amp;oacute;n para recuperarlo. Si el objeto tampoco est&amp;aacute; implementado en este agente, reenv&amp;iacute;a el objeto a su padre, y as&amp;iacute; sucesivamente. Finalmente, se llega al Agente Maestro y en este punto se deben resolver todos los valores de objetos desconocidos. Si alg&amp;uacute;n objeto es desconocido incluso para el agente maestro, esto se considera un error y se informa con una llamada a &lt;code&gt;user_err/2&lt;/code&gt; del m&amp;oacute;dulo de informe de errores. En este caso, no se env&amp;iacute;an notificaciones.</target>
        </trans-unit>
        <trans-unit id="7f05ffe858a8cb96ed8902253d604666829ad99b" translate="yes" xml:space="preserve">
          <source>If a variable in the notification is a table element, the &lt;code&gt;RowIndex&lt;/code&gt; for the element must be given in the &lt;code&gt;Varbinds&lt;/code&gt; list. In this case, the OBJECT IDENTIFIER sent in the notification is the OBJECT IDENTIFIER that identifies this element. This OBJECT IDENTIFIER could be used in a get operation later.</source>
          <target state="translated">Si una variable en la notificaci&amp;oacute;n es un elemento de la tabla, el &lt;code&gt;RowIndex&lt;/code&gt; para el elemento se debe proporcionar en la lista &lt;code&gt;Varbinds&lt;/code&gt; . En este caso, el OBJECT IDENTIFIER enviado en la notificaci&amp;oacute;n es el OBJECT IDENTIFIER que identifica este elemento. Este IDENTIFICADOR DE OBJETO podr&amp;iacute;a usarse en una operaci&amp;oacute;n de obtenci&amp;oacute;n m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="efa23222c6a2a3e5338c7520ab1388a99a7dfcaa" translate="yes" xml:space="preserve">
          <source>If a verb with a name is encountered in a positive assertion that is true, the name is recorded and passed back if it is the last encountered. This does not occur for negative assertions or failing positive assertions.</source>
          <target state="translated">Si se encuentra un verbo con un nombre en una afirmación positiva que es verdadera,el nombre se registra y se pasa de nuevo si es el último encontrado.Esto no ocurre en el caso de afirmaciones negativas o afirmaciones positivas fallidas.</target>
        </trans-unit>
        <trans-unit id="3c078e743c8ad3031e0b9776799a11e94ca09596" translate="yes" xml:space="preserve">
          <source>If a word is a keyword in any of SMIv1 or SMIv2, it is a keyword in the compiler (deviates from SMIv1 only).</source>
          <target state="translated">Si una palabra es una palabra clave en cualquiera de los SMIv1 o SMIv2,es una palabra clave en el compilador (se desvía de SMIv1 solamente).</target>
        </trans-unit>
        <trans-unit id="1149a0ac86645906ae73725e9fb076d1a22fe0f5" translate="yes" xml:space="preserve">
          <source>If all is going well, &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; is returned, where &lt;code&gt;ResultOfFun&lt;/code&gt; is the value of the last expression in &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">Si todo va bien, se devuelve &lt;code&gt;{atomic, ResultOfFun}&lt;/code&gt; , donde &lt;code&gt;ResultOfFun&lt;/code&gt; es el valor de la &amp;uacute;ltima expresi&amp;oacute;n en &lt;code&gt;Fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b01530d249514addedfdbdbbd983e4e8a11a58ae" translate="yes" xml:space="preserve">
          <source>If all the alternatives of a pattern begin with \G, the expression is anchored to the starting match position, and the &quot;anchored&quot; flag is set in the compiled regular expression.</source>
          <target state="translated">Si todas las alternativas de un patrón comienzan con \G,la expresión se ancla en la posición inicial del partido,y la bandera &quot;anclada&quot; se establece en la expresión regular compilada.</target>
        </trans-unit>
        <trans-unit id="e1594cd6a4b2cab6cb92767668a0eff338a52692" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;.erlang&lt;/code&gt; file is found, it is assumed to contain valid Erlang expressions. These expressions are evaluated as if they were input to the shell.</source>
          <target state="translated">Si se encuentra un archivo &lt;code&gt;.erlang&lt;/code&gt; , se supone que contiene expresiones Erlang v&amp;aacute;lidas. Estas expresiones se eval&amp;uacute;an como si fueran entradas al shell.</target>
        </trans-unit>
        <trans-unit id="af472d7bbaa2fc6a0ea1097c69c14756e497ac62" translate="yes" xml:space="preserve">
          <source>If an &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocator has been disabled.</source>
          <target state="translated">Si un &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; se ha desactivado.</target>
        </trans-unit>
        <trans-unit id="b0fe7f6a7a0b539b5749a7e1d2f251c0f18f21ac" translate="yes" xml:space="preserve">
          <source>If an I/O device is set in binary mode, functions &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; can return binaries instead of lists. The binaries are, as from Erlang/OTP R13A, encoded in UTF-8.</source>
          <target state="translated">Si un dispositivo de E / S est&amp;aacute; configurado en modo binario, las funciones &lt;code&gt;&lt;a href=&quot;#get_chars-2&quot;&gt;get_chars/2,3&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#get_line-1&quot;&gt;get_line/1,2&lt;/a&gt;&lt;/code&gt; pueden devolver binarios en lugar de listas. Los binarios, a partir de Erlang / OTP R13A, est&amp;aacute;n codificados en UTF-8.</target>
        </trans-unit>
        <trans-unit id="950a5eee2a6c7e7d5ca333de354cd42eaef1ad34" translate="yes" xml:space="preserve">
          <source>If an I/O server encounters a request that it does not recognize (that is, the &lt;code&gt;io_request&lt;/code&gt; tuple has the expected format, but the &lt;code&gt;Request&lt;/code&gt; is unknown), the I/O server is to send a valid reply with the error tuple:</source>
          <target state="translated">Si un servidor de E / S encuentra una solicitud que no reconoce (es decir, la tupla &lt;code&gt;io_request&lt;/code&gt; tiene el formato esperado, pero la &lt;code&gt;Request&lt;/code&gt; es desconocida), el servidor de E / S debe enviar una respuesta v&amp;aacute;lida con la tupla de error:</target>
        </trans-unit>
        <trans-unit id="a4f36f7aa69d8f80d8d7146716c4e8049b3bf51a" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to exactly one sub-tree, then the instance is included in, or excluded from, the relevant MIB view according to the type of that entry.</source>
          <target state="translated">Si una instancia de un objeto MIB pertenece exactamente a un subárbol,entonces la instancia se incluye o excluye de la vista MIB correspondiente según el tipo de esa entrada.</target>
        </trans-unit>
        <trans-unit id="a99df1ec1c1a80894724865e2ce569291af72e66" translate="yes" xml:space="preserve">
          <source>If an MIB object instance belongs to more than one sub-tree, then the sub-tree which comprises the greatest number of sub-identifiers, and is the lexicographically greatest, is used.</source>
          <target state="translated">Si una instancia de objeto MIB pertenece a más de un subárbol,entonces se utiliza el subárbol que comprende el mayor número de subidentificadores,y es el mayor lexicográficamente.</target>
        </trans-unit>
        <trans-unit id="e6bdb8ad60adae512c56f4674456a5be529864a3" translate="yes" xml:space="preserve">
          <source>If an MIB object instance does not belong to any of the relevant sub-trees, then the instance is not in the MIB view.</source>
          <target state="translated">Si una instancia de un objeto MIB no pertenece a ninguno de los subárboles relevantes,entonces la instancia no está en la vista MIB.</target>
        </trans-unit>
        <trans-unit id="705cdb188be71ada04fc74b872d92dbacc75dd7e" translate="yes" xml:space="preserve">
          <source>If an alg_entry() is missing in the algs_list(), the default value is used for that entry.</source>
          <target state="translated">Si falta una alg_entrada()en la algs_list(),se utiliza el valor por defecto para esa entrada.</target>
        </trans-unit>
        <trans-unit id="5c83f6426a048bc4d7852aaa3ae581e49a373491" translate="yes" xml:space="preserve">
          <source>If an algorithm name occurs more than once in a list, the behaviour is undefined. The tags in the property lists are also assumed to occur at most one time.</source>
          <target state="translated">Si el nombre de un algoritmo aparece más de una vez en una lista,el comportamiento es indefinido.También se supone que las etiquetas de las listas de propiedades ocurren como máximo una vez.</target>
        </trans-unit>
        <trans-unit id="ce7071090130d498a0f2639cfbfd5be9f3e8c347" translate="yes" xml:space="preserve">
          <source>If an application callback made in processing the request fails (pick_peer, prepare_request, prepare_retransmit, handle_answer or handle_error) then either &lt;code&gt;{error,encode}&lt;/code&gt; or &lt;code&gt;{error,failure}&lt;/code&gt; is returned depending on whether or not there has been an attempt to send the request over the transport.</source>
          <target state="translated">Si una devoluci&amp;oacute;n de llamada de la aplicaci&amp;oacute;n realizada al procesar la solicitud falla (pick_peer, prepare_request, prepare_retransmit, handle_answer o handle_error), se devuelve &lt;code&gt;{error,encode}&lt;/code&gt; o &lt;code&gt;{error,failure}&lt;/code&gt; dependiendo de si ha habido un intento de enviar la solicitud. sobre el transporte.</target>
        </trans-unit>
        <trans-unit id="8620de6a5aec3c030672b28f6a7fdb90f2fa4d64" translate="yes" xml:space="preserve">
          <source>If an arithmetic expression, a Boolean expression, a short-circuit expression, or a call to a guard BIF fails (because of invalid arguments), the entire guard fails. If the guard was part of a guard sequence, the next guard in the sequence (that is, the guard following the next semicolon) is evaluated.</source>
          <target state="translated">Si una expresión aritmética,una expresión booleana,una expresión de cortocircuito,o una llamada a un guardia BIF falla (debido a argumentos inválidos),todo el guardia falla.Si la guardia era parte de una secuencia de guardia,se evalúa la siguiente guardia de la secuencia (es decir,la guardia que sigue al siguiente punto y coma).</target>
        </trans-unit>
        <trans-unit id="ee90b274af3aff2cc9d248f74e9b5167e0839059" translate="yes" xml:space="preserve">
          <source>If an attempt to open a log file for the first time fails, the disk log process terminates with the EXIT message &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt;. The function returns &lt;code&gt;{error, Reason}&lt;/code&gt; for all other errors.</source>
          <target state="translated">Si falla el intento de abrir un archivo de registro por primera vez, el proceso de registro del disco termina con el mensaje EXIT &lt;code&gt;{{failed,Reason},[{disk_log,open,1}]}&lt;/code&gt; error , motivo}, [{disk_log, open, 1}]} . La funci&amp;oacute;n devuelve &lt;code&gt;{error, Reason}&lt;/code&gt; para todos los dem&amp;aacute;s errores.</target>
        </trans-unit>
        <trans-unit id="6c78e44d2f2d9461d5a0cc6159a7d3b1775f8cf6" translate="yes" xml:space="preserve">
          <source>If an attempt to reopen or truncate a log fails (see &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt;) the disk log process terminates immediately. Before the process terminates, links to owners and blocking processes (see &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt;) are removed. The effect is that the links work in one direction only. Any process using a disk log must check for error message &lt;code&gt;no_such_log&lt;/code&gt; if some other process truncates or reopens the log simultaneously.</source>
          <target state="translated">Si falla un intento de reabrir o truncar un registro (consulte &lt;code&gt;&lt;a href=&quot;#reopen-2&quot;&gt;reopen/2,3&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#truncate-1&quot;&gt;truncate/1,2&lt;/a&gt;&lt;/code&gt; ), el proceso de registro del disco finaliza inmediatamente. Antes de que finalice el proceso, se eliminan los enlaces a los propietarios y los procesos de bloqueo (ver &lt;code&gt;&lt;a href=&quot;#block-1&quot;&gt;block/1,2&lt;/a&gt;&lt;/code&gt; ). El efecto es que los enlaces funcionan en una sola direcci&amp;oacute;n. Cualquier proceso que utilice un registro de disco debe buscar el mensaje de error &lt;code&gt;no_such_log&lt;/code&gt; si alg&amp;uacute;n otro proceso trunca o vuelve a abrir el registro simult&amp;aacute;neamente.</target>
        </trans-unit>
        <trans-unit id="efa1a720322487c68ded0dc02a8c51e5dc94fcf9" translate="yes" xml:space="preserve">
          <source>If an edge is emanating from v and incident on w, then w is said to be an  &lt;strong id=&quot;out_neighbour&quot;&gt;out-neighbor&lt;/strong&gt; of v, and v is said to be an &lt;strong id=&quot;in_neighbour&quot;&gt;in-neighbor&lt;/strong&gt; of w.</source>
          <target state="translated">Si un borde emana de v e incide en w, entonces se dice que w es un &lt;strong id=&quot;out_neighbour&quot;&gt;vecino&lt;/strong&gt; externo de v, y que v es un &lt;strong id=&quot;in_neighbour&quot;&gt;vecino&lt;/strong&gt; interno de w.</target>
        </trans-unit>
        <trans-unit id="a481b829b72ba85ee7ff861e87909f902fa230b7" translate="yes" xml:space="preserve">
          <source>If an employee started 1997 or later, but before 2001, return &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">Si un empleado comenz&amp;oacute; en 1997 o despu&amp;eacute;s, pero antes de 2001, devuelva &lt;code&gt;{rookie, &amp;lt;employee number&amp;gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="267d94e1e64e36b71e95d1e768da8da0ab4dabd6" translate="yes" xml:space="preserve">
          <source>If an employee started before 1997, return the tuple &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt;.</source>
          <target state="translated">Si un empleado comenz&amp;oacute; antes de 1997, devuelva la tupla &lt;code&gt;{inventory, &amp;lt;employee number&amp;gt;}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b9b3a599385dc1e77b6effb7fdcc0ba87017325" translate="yes" xml:space="preserve">
          <source>If an emulator restart is necessary and no upgrade instructions are needed, that is, if the restart itself is enough for the upgraded applications to start running the new versions, a simple &lt;code&gt;relup&lt;/code&gt; file can be created manually:</source>
          <target state="translated">Si es necesario reiniciar el emulador y no se necesitan instrucciones de actualizaci&amp;oacute;n, es decir, si el reinicio en s&amp;iacute; es suficiente para que las aplicaciones actualizadas comiencen a ejecutar las nuevas versiones, se puede crear manualmente un archivo de &lt;code&gt;relup&lt;/code&gt; simple :</target>
        </trans-unit>
        <trans-unit id="0be98b96fbc89792dcc19067b12124fdf6e59e27" translate="yes" xml:space="preserve">
          <source>If an encode error takes place during retransmission then the request process fails and &lt;code&gt;{error,failure}&lt;/code&gt; is returned.</source>
          <target state="translated">Si se produce un error de codificaci&amp;oacute;n durante la retransmisi&amp;oacute;n, el proceso de solicitud falla y se devuelve &lt;code&gt;{error,failure}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d90f4b09c609d55842d57250ea621c86bccd2a5" translate="yes" xml:space="preserve">
          <source>If an entire packet is contained in &lt;code&gt;Bin&lt;/code&gt;, it is returned together with the remainder of the binary as &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt;.</source>
          <target state="translated">Si un paquete completo est&amp;aacute; contenido en &lt;code&gt;Bin&lt;/code&gt; , se devuelve junto con el resto del binario como &lt;code&gt;{ok,Packet,Rest}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="811984ae5951261acbbb238684d0b7c77bf502d9" translate="yes" xml:space="preserve">
          <source>If an error code is returned, the port is not started.</source>
          <target state="translated">Si se devuelve un código de error,el puerto no se inicia.</target>
        </trans-unit>
        <trans-unit id="da4e739db10805f14ff747b7b4e80017ae2c1b09" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra un error en el archivo de configuraci&amp;oacute;n, se informa mediante la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;snmpa_error#config_err&quot;&gt;config_err/2&lt;/a&gt;&lt;/code&gt; del m&amp;oacute;dulo de informe de errores y la funci&amp;oacute;n falla con el motivo &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9669e70dbc35431ddeb5cae9c621269171a463e4" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the , and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra un error en el archivo de configuraci&amp;oacute;n, se informa mediante la funci&amp;oacute;n &lt;code&gt;config_err/2&lt;/code&gt; del, y la funci&amp;oacute;n falla con el motivo &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16106449fe5fc75aadfe943e285574d04cf0155a" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra un error en el archivo de configuraci&amp;oacute;n, se informa mediante la funci&amp;oacute;n &lt;code&gt;config_err/2&lt;/code&gt; del m&amp;oacute;dulo de informe de errores y la funci&amp;oacute;n falla con el motivo &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f27e177a4e1612c45d2451a4b610d2b6a6e50b1" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error report module, and the function fails with the reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra un error en el archivo de configuraci&amp;oacute;n, se informa mediante la funci&amp;oacute;n &lt;code&gt;config_err/2&lt;/code&gt; del m&amp;oacute;dulo de informe de errores y la funci&amp;oacute;n falla con el motivo &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="32a6f97b5644649bdcac70889144dbc30cbf50c8" translate="yes" xml:space="preserve">
          <source>If an error is found in the configuration file, it is reported using the function &lt;code&gt;config_err/2&lt;/code&gt; of the error, report module and the function fails with reason &lt;code&gt;configuration_error&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra un error en el archivo de configuraci&amp;oacute;n, se informa utilizando la funci&amp;oacute;n &lt;code&gt;config_err/2&lt;/code&gt; del error, m&amp;oacute;dulo de informe y la funci&amp;oacute;n falla con el motivo &lt;code&gt;configuration_error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6bbaf85823709f47c63afa4741f86471e008208" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can be due to errors in compilation of the match specification. Such errors are presented as a list of tuples &lt;code&gt;{error, string()}&lt;/code&gt; where the string is a textual explanation of the compilation error. An example:</source>
          <target state="translated">Si se devuelve un error, puede deberse a errores en la compilaci&amp;oacute;n de la especificaci&amp;oacute;n de coincidencia. Estos errores se presentan como una lista de tuplas &lt;code&gt;{error, string()}&lt;/code&gt; donde la cadena es una explicaci&amp;oacute;n textual del error de compilaci&amp;oacute;n. Un ejemplo:</target>
        </trans-unit>
        <trans-unit id="4a4d238b84b9d8f7ce4275d02e1e061ea04cf76d" translate="yes" xml:space="preserve">
          <source>If an error is returned, it can either be due to a tracer server already running (&lt;code&gt;{error,already_started}&lt;/code&gt;) or due to the &lt;code&gt;HandlerFun&lt;/code&gt; throwing an exception.</source>
          <target state="translated">Si se devuelve un error, puede deberse a que un servidor de &lt;code&gt;{error,already_started}&lt;/code&gt; ya se est&amp;aacute; ejecutando ( {error, already_started} ) o a que &lt;code&gt;HandlerFun&lt;/code&gt; ha lanzado una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4e9dbcebd3f214207a33235b48bfaaf49bf5e244" translate="yes" xml:space="preserve">
          <source>If an error occurred, this function is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function is called. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">Si ocurri&amp;oacute; un error, esta funci&amp;oacute;n se llama despu&amp;eacute;s de llamar a la funci&amp;oacute;n &lt;code&gt;is_set_ok&lt;/code&gt; . Si se llama a &lt;code&gt;set&lt;/code&gt; para este objeto, no se llama a &lt;code&gt;undo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4ffdf980152bda82758e93fa5363e955a51a162e" translate="yes" xml:space="preserve">
          <source>If an error occurs during the installation, the system is rebooted using the old version of the release. If installation succeeds, the system is afterwards using the new version of the release, but if anything happens and the system is rebooted, it starts using the previous version again.</source>
          <target state="translated">Si se produce un error durante la instalación,el sistema se reinicia utilizando la versión antigua de la versión.Si la instalación tiene éxito,el sistema utiliza después la nueva versión de la versión,pero si algo sucede y el sistema se reinicia,comienza a utilizar la versión anterior de nuevo.</target>
        </trans-unit>
        <trans-unit id="e3b9183a591452f1c5ebde1eae8e316833b13a50" translate="yes" xml:space="preserve">
          <source>If an error occurs on the socket, the following message is delivered (unless &lt;code&gt;{active, false}&lt;/code&gt; is specified in the option list for the socket, in which case packets are retrieved by calling &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">Si ocurre un error en el socket, se env&amp;iacute;a el siguiente mensaje (a menos que se especifique &lt;code&gt;{active, false}&lt;/code&gt; en la lista de opciones para el socket, en cuyo caso los paquetes se recuperan llamando a &lt;code&gt;&lt;a href=&quot;#recv-2&quot;&gt;recv/2&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="ee097c045f410ae6ef1682702f02130e44879ffb" translate="yes" xml:space="preserve">
          <source>If an error occurs when accessing an open file with module &lt;code&gt;io&lt;/code&gt;, the process handling the file exits. The dead file process can hang if a process tries to access it later. This will be fixed in a future release.</source>
          <target state="translated">Si ocurre un error al acceder a un archivo abierto con el m&amp;oacute;dulo &lt;code&gt;io&lt;/code&gt; , el proceso que maneja el archivo finaliza. El proceso de archivo muerto puede bloquearse si un proceso intenta acceder a &amp;eacute;l m&amp;aacute;s tarde. Este problema se solucionar&amp;aacute; en una versi&amp;oacute;n futura.</target>
        </trans-unit>
        <trans-unit id="1e80b8f25b6627161bccd2087c0375b81e9072e8" translate="yes" xml:space="preserve">
          <source>If an error occurs, The function &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; is called after the &lt;code&gt;is_set_ok&lt;/code&gt; function. If &lt;code&gt;set&lt;/code&gt; is called for this object, &lt;code&gt;undo&lt;/code&gt; is not called.</source>
          <target state="translated">Si ocurre un error, la funci&amp;oacute;n &lt;code&gt;f(undo, RowIndex, Cols [, ExtraArgs])&lt;/code&gt; se llama despu&amp;eacute;s de la funci&amp;oacute;n &lt;code&gt;is_set_ok&lt;/code&gt; . Si se llama a &lt;code&gt;set&lt;/code&gt; para este objeto, no se llama a &lt;code&gt;undo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ae997c53a260dda31bdd5632662979a9e41a9ab0" translate="yes" xml:space="preserve">
          <source>If an error occurs, either in the &lt;code&gt;is_set_ok&lt;/code&gt; phase, or in the &lt;code&gt;set&lt;/code&gt; phase, all functions which were called with &lt;code&gt;is_set_ok&lt;/code&gt; but not &lt;code&gt;set&lt;/code&gt;, are called with &lt;code&gt;undo&lt;/code&gt;.</source>
          <target state="translated">Si ocurre un error, ya sea en la fase &lt;code&gt;is_set_ok&lt;/code&gt; , o en la fase &lt;code&gt;set&lt;/code&gt; , todas las funciones que fueron llamadas con &lt;code&gt;is_set_ok&lt;/code&gt; pero no &lt;code&gt;set&lt;/code&gt; , se llaman con &lt;code&gt;undo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276746b794853efb127f75c7e5ec07717c8d976f" translate="yes" xml:space="preserve">
          <source>If an error occurs, the applications started by the function are stopped to bring the set of running applications back to its initial state.</source>
          <target state="translated">Si se produce un error,las aplicaciones iniciadas por la función se detienen para devolver el conjunto de aplicaciones en ejecución a su estado inicial.</target>
        </trans-unit>
        <trans-unit id="5c1a2d5fdbf25c48c2a0e3dd8bc47d65a9c912ff" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;.</source>
          <target state="translated">Si ocurre un error, se sale del proceso con una tupla de &lt;code&gt;{error, Reason}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="198b396c8242aa281ca2808a3e1fe29feecf86f5" translate="yes" xml:space="preserve">
          <source>If an error occurs, the process is exited with an error tuple &lt;code&gt;{error, Reason}&lt;/code&gt;. The error tuple is not returned, as it cannot be distinguished from a key.</source>
          <target state="translated">Si ocurre un error, se sale del proceso con una tupla de &lt;code&gt;{error, Reason}&lt;/code&gt; . La tupla de error no se devuelve, ya que no se puede distinguir de una clave.</target>
        </trans-unit>
        <trans-unit id="9366b8a06735f2ef6c5bd64e2d4894f28c5e9fd9" translate="yes" xml:space="preserve">
          <source>If an error occurs, the stack trace becomes empty in this case.</source>
          <target state="translated">Si se produce un error,el rastro de la pila se vacía en este caso.</target>
        </trans-unit>
        <trans-unit id="5334f6f487ef5e94e1d3f8d91a903cad1c7ae4ca" translate="yes" xml:space="preserve">
          <source>If an error occurs, there is no output. Example:</source>
          <target state="translated">Si se produce un error,no hay salida.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="eaf4f64d81bc2ecc63f1691d3a8ab14648012ce3" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;AfterBody&lt;/code&gt; itself, it is not caught. So if &lt;code&gt;AfterBody&lt;/code&gt; is evaluated after an exception in &lt;code&gt;Exprs&lt;/code&gt;, &lt;code&gt;Body&lt;/code&gt;, or &lt;code&gt;ExceptionBody&lt;/code&gt;, that exception is lost and masked by the exception in &lt;code&gt;AfterBody&lt;/code&gt;.</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n durante la evaluaci&amp;oacute;n de &lt;code&gt;AfterBody&lt;/code&gt; , no se detecta . Entonces, si &lt;code&gt;AfterBody&lt;/code&gt; se eval&amp;uacute;a despu&amp;eacute;s de una excepci&amp;oacute;n en &lt;code&gt;Exprs&lt;/code&gt; , &lt;code&gt;Body&lt;/code&gt; o &lt;code&gt;ExceptionBody&lt;/code&gt; , esa excepci&amp;oacute;n se pierde y se enmascara mediante la excepci&amp;oacute;n en &lt;code&gt;AfterBody&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="73b3692cd35fbb24365c57783d388c12c52b16ba" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;ExceptionBody&lt;/code&gt;, it is not caught.</source>
          <target state="translated">Si se produce una excepci&amp;oacute;n durante la evaluaci&amp;oacute;n de &lt;code&gt;ExceptionBody&lt;/code&gt; , no se detecta.</target>
        </trans-unit>
        <trans-unit id="15e21c88415fba00ea3b007d2430e70dde7b38c0" translate="yes" xml:space="preserve">
          <source>If an exception occurs during evaluation of &lt;code&gt;Exprs&lt;/code&gt; but there is no matching &lt;code&gt;ExceptionPattern&lt;/code&gt; of the right &lt;code&gt;Class&lt;/code&gt; with a true guard sequence, the exception is passed on as if &lt;code&gt;Exprs&lt;/code&gt; had not been enclosed in a &lt;code&gt;try&lt;/code&gt; expression.</source>
          <target state="translated">Si ocurre una excepci&amp;oacute;n durante la evaluaci&amp;oacute;n de &lt;code&gt;Exprs&lt;/code&gt; pero no hay un &lt;code&gt;ExceptionPattern&lt;/code&gt; coincidente de la &lt;code&gt;Class&lt;/code&gt; correcta con una secuencia de protecci&amp;oacute;n verdadera, la excepci&amp;oacute;n se pasa como si &lt;code&gt;Exprs&lt;/code&gt; no se hubiera incluido en una expresi&amp;oacute;n &lt;code&gt;try&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d16bf5cd6125b26b68df1e48e19c1d35055d07b" translate="yes" xml:space="preserve">
          <source>If an exit signal is received as above, the tuple &lt;code&gt;{From,Name}&lt;/code&gt; is deleted from the servers &lt;code&gt;User_List&lt;/code&gt; using the &lt;code&gt;server_logoff&lt;/code&gt; function. If the node on which the server runs goes down, an exit signal (automatically generated by the system) is sent to all of the client processes: &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; causing all the client processes to terminate.</source>
          <target state="translated">Si se recibe una se&amp;ntilde;al de salida como arriba, la tupla &lt;code&gt;{From,Name}&lt;/code&gt; se elimina de los servidores &lt;code&gt;User_List&lt;/code&gt; usando la funci&amp;oacute;n &lt;code&gt;server_logoff&lt;/code&gt; . Si el nodo en el que se ejecuta el servidor deja de funcionar, se env&amp;iacute;a una se&amp;ntilde;al de salida (generada autom&amp;aacute;ticamente por el sistema) a todos los procesos del cliente: &lt;code&gt;{'EXIT',MessengerPID,noconnection}&lt;/code&gt; provocando la finalizaci&amp;oacute;n de todos los procesos del cliente.</target>
        </trans-unit>
        <trans-unit id="b7e0ea0cc95b3d589060e057229e831ff5a8ff4e" translate="yes" xml:space="preserve">
          <source>If an instrumentation function in the association file for a variable &lt;code&gt;myVar&lt;/code&gt; does not have a name when compiling an MIB, the compiler generates an entry.</source>
          <target state="translated">Si una funci&amp;oacute;n de instrumentaci&amp;oacute;n en el archivo de asociaci&amp;oacute;n para una variable &lt;code&gt;myVar&lt;/code&gt; no tiene un nombre al compilar un MIB, el compilador genera una entrada.</target>
        </trans-unit>
        <trans-unit id="4901f204507135ee6a79147a0e0e1064225a4fc4" translate="yes" xml:space="preserve">
          <source>If an integer time-out value is provided, a time-out occurs unless a request or a message is received within &lt;code&gt;Timeout&lt;/code&gt; milliseconds. A time-out is represented by the atom &lt;code&gt;timeout&lt;/code&gt;, which is to be handled by the &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; callback function. The atom &lt;code&gt;infinity&lt;/code&gt; can be used to wait indefinitely, this is the default value.</source>
          <target state="translated">Si se proporciona un valor de tiempo de espera entero, se produce un tiempo de espera a menos que se reciba una solicitud o un mensaje en milisegundos de tiempo de &lt;code&gt;Timeout&lt;/code&gt; . Un tiempo de espera est&amp;aacute; representado por el &lt;code&gt;timeout&lt;/code&gt; del &amp;aacute;tomo , que ser&amp;aacute; manejado por la funci&amp;oacute;n de devoluci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#Module:handle_info-2&quot;&gt;Module:handle_info/2&lt;/a&gt;&lt;/code&gt; llamada Module: handle_info / 2 . El &amp;aacute;tomo &lt;code&gt;infinity&lt;/code&gt; se puede usar para esperar indefinidamente, este es el valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="c317bf8995de9827a88e47cfa9f960f031966c21" translate="yes" xml:space="preserve">
          <source>If an owner attempts to open a log as owner once again, it is acknowledged with the return value &lt;code&gt;{ok, Log}&lt;/code&gt;, but the state of the disk log is not affected.</source>
          <target state="translated">Si un propietario intenta abrir un registro como propietario una vez m&amp;aacute;s, se reconoce con el valor de retorno &lt;code&gt;{ok, Log}&lt;/code&gt; , pero el estado del registro del disco no se ve afectado.</target>
        </trans-unit>
        <trans-unit id="6d1c8f7e5679322dcbb64d8108251b9319c084c5" translate="yes" xml:space="preserve">
          <source>If an unrecognized type option &lt;code&gt;T&lt;/code&gt; is specified or &lt;code&gt;Type&lt;/code&gt; is not a proper list, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si se especifica una opci&amp;oacute;n de tipo no reconocido &lt;code&gt;T&lt;/code&gt; o el &lt;code&gt;Type&lt;/code&gt; no es una lista adecuada, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="5edd7e14ee514521a82d9d312927e864fd8b6b43" translate="yes" xml:space="preserve">
          <source>If an unsupported algorithm is in the &lt;code&gt;modify_algs_list()&lt;/code&gt;, it will be silently ignored</source>
          <target state="translated">Si un algoritmo no admitido est&amp;aacute; en la lista de &lt;code&gt;modify_algs_list()&lt;/code&gt; , se ignorar&amp;aacute; en silencio</target>
        </trans-unit>
        <trans-unit id="ac90fe515c674df1b687955496c9be8fee6118f2" translate="yes" xml:space="preserve">
          <source>If an upgrade includes a change from an emulator earlier than OTP R15 to OTP R15 or later, the warning &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; is issued. For more information about this, see &lt;code&gt;Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">Si una actualizaci&amp;oacute;n incluye un cambio de un emulador anterior a OTP R15 a OTP R15 o posterior, se emite la advertencia &lt;code&gt;pre_R15_emulator_upgrade&lt;/code&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esto, consulte &lt;code&gt;Design Principles&lt;/code&gt; en la &lt;strong&gt;documentaci&amp;oacute;n del sistema&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="c2bc5a0b1d5c34b06e7086cddd297167569f7462" translate="yes" xml:space="preserve">
          <source>If and how to compress the message. Examples are &lt;code&gt;none&lt;/code&gt;, that is, no compression and &lt;code&gt;zlib&lt;/code&gt;.</source>
          <target state="translated">Si y c&amp;oacute;mo comprimir el mensaje. Los ejemplos son &lt;code&gt;none&lt;/code&gt; , es decir, sin compresi&amp;oacute;n y &lt;code&gt;zlib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e7a133c6b3bee84f3bf4462f30e02bb30fa3e98" translate="yes" xml:space="preserve">
          <source>If and only if the Unicode translation modifier is used in the format string (that is, &lt;code&gt;~ts&lt;/code&gt; or &lt;code&gt;~tc&lt;/code&gt;), the resulting list can contain characters beyond the ISO Latin-1 character range (that is, numbers &amp;gt; 255). If so, the result is still an ordinary Erlang &lt;code&gt;string()&lt;/code&gt;, and can well be used in any context where Unicode data is allowed.</source>
          <target state="translated">Si y solo si se usa el modificador de traducci&amp;oacute;n Unicode en la cadena de formato (es decir, &lt;code&gt;~ts&lt;/code&gt; o &lt;code&gt;~tc&lt;/code&gt; ), la lista resultante puede contener caracteres m&amp;aacute;s all&amp;aacute; del rango de caracteres ISO Latin-1 (es decir, n&amp;uacute;meros&amp;gt; 255). Si es as&amp;iacute;, el resultado sigue siendo una &lt;code&gt;string()&lt;/code&gt; Erlang ordinaria () y se puede utilizar en cualquier contexto en el que se permitan datos Unicode.</target>
        </trans-unit>
        <trans-unit id="8c687f2de4701a7ffef4cc4c42ee7473077335c1" translate="yes" xml:space="preserve">
          <source>If and when you would like to start and manipulate &lt;code&gt;Mnesia&lt;/code&gt;, it is often easier to write the definitions and data into an ordinary text file. Initially, no tables and no data exist, or which tables are required. At the initial stages of prototyping, it is prudent to write all data into one file, process that file, and have the data in the file inserted into the database. &lt;code&gt;Mnesia&lt;/code&gt; can be initialized with data read from a text file. The following two functions can be used to work with text files.</source>
          <target state="translated">Si desea iniciar y manipular &lt;code&gt;Mnesia&lt;/code&gt; , a menudo es m&amp;aacute;s f&amp;aacute;cil escribir las definiciones y los datos en un archivo de texto ordinario. Inicialmente, no existen tablas ni datos, o qu&amp;eacute; tablas son necesarias. En las etapas iniciales de la creaci&amp;oacute;n de prototipos, es prudente escribir todos los datos en un archivo, procesar ese archivo y hacer que los datos del archivo se inserten en la base de datos. &lt;code&gt;Mnesia&lt;/code&gt; se puede inicializar con datos le&amp;iacute;dos de un archivo de texto. Las siguientes dos funciones se pueden utilizar para trabajar con archivos de texto.</target>
        </trans-unit>
        <trans-unit id="80417b144fe2bc5c20d55da668bc56d430c25c36" translate="yes" xml:space="preserve">
          <source>If another implementation of any of these variables is needed, e.g. to store the persistent variables in a Mnesia database, an own implementation of the variables must be made. That MIB will be compiled and loaded instead of the default MIB. The new compiled MIB must have the same name as the original MIB (i.e. STANDARD-MIB or SNMPv2-MIB), and be located in the SNMP configuration directory (see &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt;.)</source>
          <target state="translated">Si se necesita otra implementaci&amp;oacute;n de alguna de estas variables, por ejemplo, para almacenar las variables persistentes en una base de datos de Mnesia, se debe realizar una implementaci&amp;oacute;n propia de las variables. Ese MIB se compilar&amp;aacute; y cargar&amp;aacute; en lugar del MIB predeterminado. La nueva MIB compilada debe tener el mismo nombre que la MIB original (es decir, STANDARD-MIB o SNMPv2-MIB) y estar ubicada en el directorio de configuraci&amp;oacute;n SNMP (consulte &lt;code&gt;&lt;a href=&quot;snmp_config&quot;&gt;Configuration Files&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="80ee411849a587dd3deef8de9d6f9689dcf9ebe0" translate="yes" xml:space="preserve">
          <source>If any &lt;code&gt;Dir&lt;/code&gt; is not a directory name</source>
          <target state="translated">Si alg&amp;uacute;n &lt;code&gt;Dir&lt;/code&gt; no es un nombre de directorio</target>
        </trans-unit>
        <trans-unit id="7226b47ac607cfe4ee033cbac112e9d47878f35b" translate="yes" xml:space="preserve">
          <source>If any Erlang process &lt;code&gt;Pid&lt;/code&gt; in the system has allocated more than a certain amount of total system memory, the alarm &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; is set.</source>
          <target state="translated">Si alg&amp;uacute;n proceso de Erlang &lt;code&gt;Pid&lt;/code&gt; en el sistema ha asignado m&amp;aacute;s de una cierta cantidad de memoria total del sistema, se &lt;code&gt;{process_memory_high_watermark, Pid}&lt;/code&gt; la alarma {process_memory_high_watermark, Pid} .</target>
        </trans-unit>
        <trans-unit id="56bae9cc860914f3d89871e3baff9cb1dcabb640" translate="yes" xml:space="preserve">
          <source>If any HTTP header fields are added by the script, they must be in the first call to &lt;code&gt;deliver/2&lt;/code&gt;, and the data in the call must be a string. Calls after the headers are complete can contain binary data to reduce copying overhead. Do not assume anything about the data type of &lt;code&gt;SessionID&lt;/code&gt;. &lt;code&gt;SessionID&lt;/code&gt; must be the value given as input to the ESI callback function that you implemented.</source>
          <target state="translated">Si la secuencia de comandos agrega alg&amp;uacute;n campo de encabezado HTTP, debe estar en la primera llamada para &lt;code&gt;deliver/2&lt;/code&gt; y los datos de la llamada deben ser una cadena. Las llamadas despu&amp;eacute;s de que los encabezados est&amp;eacute;n completos pueden contener datos binarios para reducir la sobrecarga de copia. No asuma nada sobre el tipo de datos de &lt;code&gt;SessionID&lt;/code&gt; . &lt;code&gt;SessionID&lt;/code&gt; debe ser el valor dado como entrada a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada de ESI que implement&amp;oacute;.</target>
        </trans-unit>
        <trans-unit id="b0b51878bfcad40bdb7c8e819fd02580c5711eff" translate="yes" xml:space="preserve">
          <source>If any child process start function fails or returns an error tuple or an erroneous value, the supervisor first terminates all already started child processes with reason &lt;code&gt;shutdown&lt;/code&gt; and then terminate itself and returns &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt;.</source>
          <target state="translated">Si alguna funci&amp;oacute;n de inicio de proceso hijo falla o devuelve una tupla de error o un valor err&amp;oacute;neo, el supervisor primero termina todos los procesos secundarios ya iniciados con el motivo del &lt;code&gt;shutdown&lt;/code&gt; y luego se termina y devuelve &lt;code&gt;{error, {shutdown, Reason}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebd2be4d8ca214fa53676834f412514083348fde" translate="yes" xml:space="preserve">
          <source>If any functions (for example, Telnet or FTP) using &quot;required configuration data&quot; are to be called from the Erlang shell, configuration data must first be required with &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si cualquier funci&amp;oacute;n (por ejemplo, Telnet o FTP) que usa &quot;datos de configuraci&amp;oacute;n requeridos&quot; debe llamarse desde el shell de Erlang, los datos de configuraci&amp;oacute;n primero deben requerirse con &lt;code&gt;&lt;a href=&quot;#require-2&quot;&gt;ct:require/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7f4af54f6decb45db597b9e963b792ae46e26cb" translate="yes" xml:space="preserve">
          <source>If any functions using &quot;required configuration data&quot; (for example, functions &lt;code&gt;ct_telnet&lt;/code&gt; or &lt;code&gt;ct_ftp&lt;/code&gt;) are to be called from the Erlang shell, first require configuration data with &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt;. This is equivalent to a &lt;code&gt;require&lt;/code&gt; statement in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; or in the &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si alguna funci&amp;oacute;n que usa &quot;datos de configuraci&amp;oacute;n requeridos&quot; (por ejemplo, funciones &lt;code&gt;ct_telnet&lt;/code&gt; o &lt;code&gt;ct_ftp&lt;/code&gt; ) debe llamarse desde el shell de Erlang, primero requiera datos de configuraci&amp;oacute;n con &lt;code&gt;&lt;a href=&quot;ct#require-1&quot;&gt;ct:require/1,2&lt;/a&gt;&lt;/code&gt; . Esto es equivalente a una declaraci&amp;oacute;n &lt;code&gt;require&lt;/code&gt; en la &lt;code&gt;&lt;a href=&quot;write_test_chapter#suite&quot;&gt;Test Suite Information Function&lt;/a&gt;&lt;/code&gt; de la serie de &lt;code&gt;&lt;a href=&quot;write_test_chapter#info_function&quot;&gt;Test Case Information Function&lt;/a&gt;&lt;/code&gt; o en la funci&amp;oacute;n de informaci&amp;oacute;n de casos de prueba .</target>
        </trans-unit>
        <trans-unit id="50c6245e20c77d69a688a02f4c540697d905913f" translate="yes" xml:space="preserve">
          <source>If any of the arguments are invalid, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si alguno de los argumentos no es v&amp;aacute;lido, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n badarg .</target>
        </trans-unit>
        <trans-unit id="692ed4da2eebf1c4f217366a6369dae2f3d80d78" translate="yes" xml:space="preserve">
          <source>If any of the tables does not exist or the Dets table is not open, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si alguna de las tablas no existe o la tabla Dets no est&amp;aacute; abierta, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="570be644a648abf241c9b8dd2548fe13d19dd232" translate="yes" xml:space="preserve">
          <source>If any of these errors occur when &lt;code&gt;+sbt&lt;/code&gt; has been passed, the runtime system prints an error message, and refuses to start. If any of these errors occur when &lt;code&gt;+stbt&lt;/code&gt; has been passed, the runtime system silently ignores the error, and start up using unbound schedulers.</source>
          <target state="translated">Si alguno de estos errores ocurre cuando se &lt;code&gt;+sbt&lt;/code&gt; , el sistema de ejecuci&amp;oacute;n imprime un mensaje de error y se niega a comenzar. Si alguno de estos errores ocurre cuando se &lt;code&gt;+stbt&lt;/code&gt; , el sistema de tiempo de ejecuci&amp;oacute;n ignora silenciosamente el error y se inicia utilizando programadores independientes.</target>
        </trans-unit>
        <trans-unit id="96761e0bc247ac872393ae1bb5eb9df6c975a841" translate="yes" xml:space="preserve">
          <source>If any position specified in &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; size of the replacement binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si alguna posici&amp;oacute;n especificada en &lt;code&gt;InsPos&lt;/code&gt; &amp;gt; tama&amp;ntilde;o del binario de reemplazo, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n badarg .</target>
        </trans-unit>
        <trans-unit id="e3ad0f81da4a204750014fc62764a9cd40b26ee9" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;-daemon&lt;/code&gt; is not specified, &lt;code&gt;epmd&lt;/code&gt; runs as a normal program with the controlling terminal of the shell in which it is started. Normally, it is to be run as a daemon.</source>
          <target state="translated">Si no se especifica el argumento &lt;code&gt;-daemon&lt;/code&gt; , &lt;code&gt;epmd&lt;/code&gt; se ejecuta como un programa normal con la terminal de control del shell en el que se inicia. Normalmente, debe ejecutarse como un demonio.</target>
        </trans-unit>
        <trans-unit id="dca95539f85ceb7c7fbb3f3a95acdd29f703f0c8" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Archive&lt;/code&gt; is specified as a binary, the contents of the binary is assumed to be a zip archive, otherwise a filename.</source>
          <target state="translated">Si el argumento &lt;code&gt;Archive&lt;/code&gt; se especifica como binario, se supone que el contenido del binario es un archivo zip, de lo contrario, un nombre de archivo.</target>
        </trans-unit>
        <trans-unit id="4234f7b924c77e169e97fc3a3a0a5fff439177f4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;MFA&lt;/code&gt; is the atom &lt;code&gt;on_load&lt;/code&gt;, the match specification and flag list are used on all modules that are newly loaded.</source>
          <target state="translated">Si el argumento &lt;code&gt;MFA&lt;/code&gt; es el &amp;aacute;tomo &lt;code&gt;on_load&lt;/code&gt; , la especificaci&amp;oacute;n de coincidencia y la lista de indicadores se utilizan en todos los m&amp;oacute;dulos que se cargan recientemente.</target>
        </trans-unit>
        <trans-unit id="5218de8ae45e50ce943a78eed5b9597b86f9e98a" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{binary,Binary}&lt;/code&gt;, the contents of the binary is assumed to be a tar archive.</source>
          <target state="translated">Si el argumento &lt;code&gt;Name&lt;/code&gt; se especifica como &lt;code&gt;{binary,Binary}&lt;/code&gt; , se supone que el contenido del binario es un archivo tar.</target>
        </trans-unit>
        <trans-unit id="2a16809777595118890feda8207e9529558557f0" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;Name&lt;/code&gt; is specified as &lt;code&gt;{file,Fd}&lt;/code&gt;, &lt;code&gt;Fd&lt;/code&gt; is assumed to be a file descriptor returned from function &lt;code&gt;file:open/2&lt;/code&gt;.</source>
          <target state="translated">Si el argumento &lt;code&gt;Name&lt;/code&gt; se especifica como &lt;code&gt;{file,Fd}&lt;/code&gt; , se asume que &lt;code&gt;Fd&lt;/code&gt; es un descriptor de archivo devuelto por el &lt;code&gt;file:open/2&lt;/code&gt; funci&amp;oacute;n : open / 2 .</target>
        </trans-unit>
        <trans-unit id="8eca364f037b451eb12fd01d43884ccc2a4bd5d4" translate="yes" xml:space="preserve">
          <source>If argument &lt;code&gt;type&lt;/code&gt; is specified, all loaded reports of this type are displayed. If an integer argument is specified, the report with this reference number is displayed. If no argument is specified, all reports are displayed.</source>
          <target state="translated">Si se especifica el &lt;code&gt;type&lt;/code&gt; argumento , se muestran todos los informes cargados de este tipo. Si se especifica un argumento de n&amp;uacute;mero entero, se muestra el informe con este n&amp;uacute;mero de referencia. Si no se especifica ning&amp;uacute;n argumento, se muestran todos los informes.</target>
        </trans-unit>
        <trans-unit id="7d9ccdcf897aa5e543e57f74baa9344de03cc64a" translate="yes" xml:space="preserve">
          <source>If atom &lt;code&gt;start&lt;/code&gt; is specified as continuation, a disk log to read terms from is chosen. A local or distributed disk log on the current node is preferred to an individual distributed log on some other node.</source>
          <target state="translated">Si el &lt;code&gt;start&lt;/code&gt; &amp;aacute;tomo se especifica como continuaci&amp;oacute;n, se elige un registro de disco para leer los t&amp;eacute;rminos. Se prefiere un registro de disco local o distribuido en el nodo actual a un registro distribuido individual en alg&amp;uacute;n otro nodo.</target>
        </trans-unit>
        <trans-unit id="c7c06078653d000d4834d7b538bf165c25d0318c" translate="yes" xml:space="preserve">
          <source>If atomic grouping is used for the previous example, the matcher gives up immediately on failing to match &quot;foo&quot; the first time. The notation is a kind of special parenthesis, starting with &lt;code&gt;(?&amp;gt;&lt;/code&gt; as in the following example:</source>
          <target state="translated">Si se usa la agrupaci&amp;oacute;n at&amp;oacute;mica para el ejemplo anterior, el comparador se da por vencido inmediatamente si no logra hacer coincidir &quot;foo&quot; la primera vez. La notaci&amp;oacute;n es una especie de par&amp;eacute;ntesis especial que comienza con &lt;code&gt;(?&amp;gt;&lt;/code&gt; Como en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="6a9902259e3c589622f30bf01a90d5b7ffcb0cc1" translate="yes" xml:space="preserve">
          <source>If attribute &lt;code&gt;{local_content, true}&lt;/code&gt; is specified when you create the table, the table resides on the nodes where you specify the table to exist, but the write operations on the table are only performed on the local copy.</source>
          <target state="translated">Si se especifica el atributo &lt;code&gt;{local_content, true}&lt;/code&gt; cuando crea la tabla, la tabla reside en los nodos donde especifica que la tabla exista, pero las operaciones de escritura en la tabla solo se realizan en la copia local.</target>
        </trans-unit>
        <trans-unit id="ebd8d24d8a76114c5ed2e0d95e53c4aab5d47e75" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application.</source>
          <target state="translated">Si se utiliza autenticaci&amp;oacute;n o cifrado (solo SNMPv3), inicie la aplicaci&amp;oacute;n de &lt;code&gt;crypto&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b32ca34021019e0bb153a3955d0b724a94e48269" translate="yes" xml:space="preserve">
          <source>If authentication or encryption is used (SNMPv3 only), start the &lt;code&gt;crypto&lt;/code&gt; application. If this step is forgotten, the agent will not start, but report a &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; error.</source>
          <target state="translated">Si se utiliza autenticaci&amp;oacute;n o cifrado (solo SNMPv3), inicie la aplicaci&amp;oacute;n de &lt;code&gt;crypto&lt;/code&gt; . Si se olvida este paso, el agente no se iniciar&amp;aacute;, pero notificar&amp;aacute; un &lt;code&gt;{config_error,{unsupported_crypto,_}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a84fea11161ee2b8221ded08279d7f5da6e7793e" translate="yes" xml:space="preserve">
          <source>If auto-skipped test cases do not affect the exit status. The default behavior can be changed using start flag:</source>
          <target state="translated">Si los casos de prueba salteados automáticamente no afectan el estado de salida.El comportamiento predeterminado puede cambiarse usando la marca de inicio:</target>
        </trans-unit>
        <trans-unit id="a54c92e18be4a676b9c1c2d1749ff8f920d1f0f1" translate="yes" xml:space="preserve">
          <source>If automatic commit mode is turned on, each query will be considered as an individual transaction and will be automatically committed after it has been executed. If you want more than one query to be part of the same transaction the automatic commit mode should be turned off. Then you will have to call commit/3 explicitly to end a transaction.</source>
          <target state="translated">Si se activa el modo de confirmación automática,cada consulta se considerará como una transacción individual y se confirmará automáticamente después de su ejecución.Si se desea que más de una consulta forme parte de la misma transacción,el modo de confirmación automática debe estar desactivado.Entonces tendrá que llamar a commit/3 explícitamente para terminar una transacción.</target>
        </trans-unit>
        <trans-unit id="fe29c622b52d7e166afb8b3558351d082aa789d3" translate="yes" xml:space="preserve">
          <source>If available in the dump, this is the total number of atoms in the atom table. If the size of the atom table is unavailable, the number of atoms visible in the dump is displayed.</source>
          <target state="translated">Si está disponible en el basurero,este es el número total de átomos en la tabla de átomos.Si no se dispone del tamaño de la tabla de átomos,se muestra el número de átomos visibles en el vertedero.</target>
        </trans-unit>
        <trans-unit id="1614181d9da9b94aedfb64164481447f45935dca" translate="yes" xml:space="preserve">
          <source>If binaries that are no longer used are to be thrown away as soon as possible. (Set &lt;code&gt;Number&lt;/code&gt; to zero.)</source>
          <target state="translated">Si los binarios que ya no se utilizan deben desecharse lo antes posible. (Establezca &lt;code&gt;Number&lt;/code&gt; en cero).</target>
        </trans-unit>
        <trans-unit id="88996aec0b15ab1d16ddf824ee8cf7cd32e2a161" translate="yes" xml:space="preserve">
          <source>If binding of schedulers is not supported.</source>
          <target state="translated">Si no se admite la vinculación de los programadores.</target>
        </trans-unit>
        <trans-unit id="90d98aa8f41f34030c7bdee94cac730737033718" translate="yes" xml:space="preserve">
          <source>If both &lt;code&gt;Source&lt;/code&gt; and &lt;code&gt;Destination&lt;/code&gt; refer to filenames, the files are opened with &lt;code&gt;[read, binary]&lt;/code&gt; and &lt;code&gt;[write, binary]&lt;/code&gt; prepended to their mode lists, respectively, to optimize the copy.</source>
          <target state="translated">Si tanto el &lt;code&gt;Source&lt;/code&gt; como el &lt;code&gt;Destination&lt;/code&gt; refieren a nombres de archivo, los archivos se abren con &lt;code&gt;[read, binary]&lt;/code&gt; y &lt;code&gt;[write, binary]&lt;/code&gt; antepuestos a sus listas de modo, respectivamente, para optimizar la copia.</target>
        </trans-unit>
        <trans-unit id="2c3e1b70d92e6d563bb5e9d6c3cd26f59813a13f" translate="yes" xml:space="preserve">
          <source>If call count tracing is started while already running, the count is restarted from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">Si el seguimiento del recuento de llamadas se inicia mientras ya se est&amp;aacute; ejecutando, el recuento se reinicia desde cero. Para pausar los contadores en ejecuci&amp;oacute;n, use &lt;code&gt;MatchSpec == pause&lt;/code&gt; . Los contadores en pausa y en ejecuci&amp;oacute;n se pueden reiniciar desde cero con &lt;code&gt;MatchSpec == restart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3ddb54b87a2d744f4668c0309f8b603f7cbd2a39" translate="yes" xml:space="preserve">
          <source>If call counters are still running while &lt;code&gt;analyse/0..2&lt;/code&gt; is executing, you might get an inconsistent result. This happens if the process executing &lt;code&gt;analyse/0..2&lt;/code&gt; gets scheduled out so some other process can increment the counters that are being analysed, Calling &lt;code&gt;pause()&lt;/code&gt; before analysing takes care of the problem.</source>
          <target state="translated">Si los contadores de llamadas a&amp;uacute;n se est&amp;aacute;n ejecutando mientras se est&amp;aacute; ejecutando el &lt;code&gt;analyse/0..2&lt;/code&gt; , es posible que obtenga un resultado inconsistente. Esto sucede si el proceso que ejecuta &lt;code&gt;analyse/0..2&lt;/code&gt; se programa para que otro proceso pueda incrementar los contadores que se est&amp;aacute;n analizando. Llamar a &lt;code&gt;pause()&lt;/code&gt; antes de analizar se encarga del problema.</target>
        </trans-unit>
        <trans-unit id="ad4325523bd9822e6e53cf121c4e7f2d415527ec" translate="yes" xml:space="preserve">
          <source>If call time tracing is started while already running, the count and time restart from zero. To pause running counters, use &lt;code&gt;MatchSpec == pause&lt;/code&gt;. Paused and running counters can be restarted from zero with &lt;code&gt;MatchSpec == restart&lt;/code&gt;.</source>
          <target state="translated">Si el seguimiento del tiempo de llamada se inicia mientras ya se est&amp;aacute; ejecutando, el recuento y el tiempo se reinician desde cero. Para pausar los contadores en ejecuci&amp;oacute;n, use &lt;code&gt;MatchSpec == pause&lt;/code&gt; . Los contadores en pausa y en ejecuci&amp;oacute;n se pueden reiniciar desde cero con &lt;code&gt;MatchSpec == restart&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8441a1f4ebffc73cdc2dc005353bc55ee1751fa1" translate="yes" xml:space="preserve">
          <source>If called several times, only the last comment is printed. The test case return value &lt;code&gt;{comment,Comment}&lt;/code&gt; overwrites the string set by this function.</source>
          <target state="translated">Si se llama varias veces, solo se imprime el &amp;uacute;ltimo comentario. El valor de retorno del caso de prueba &lt;code&gt;{comment,Comment}&lt;/code&gt; sobrescribe la cadena establecida por esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ada9d2aefe42bda67c41d0801c3618aeb38428b7" translate="yes" xml:space="preserve">
          <source>If called with an extension unknown to the user application, return value &lt;code&gt;{unknown, UserState}&lt;/code&gt; is to be used.</source>
          <target state="translated">Si se llama con una extensi&amp;oacute;n desconocida para la aplicaci&amp;oacute;n del usuario, se utilizar&amp;aacute; el valor de retorno &lt;code&gt;{unknown, UserState}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="610648cf712693e340f20ab9aac63c6b94c019dc" translate="yes" xml:space="preserve">
          <source>If calling &lt;code&gt;FormatFun&lt;/code&gt; with an argument including &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; fails, &lt;code&gt;FormatFun&lt;/code&gt; is called once again with an argument excluding &lt;code&gt;NElements&lt;/code&gt; and &lt;code&gt;DepthFun&lt;/code&gt; (&lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; or &lt;code&gt;all&lt;/code&gt;).</source>
          <target state="translated">Si la llamada a &lt;code&gt;FormatFun&lt;/code&gt; con un argumento que incluye &lt;code&gt;NElements&lt;/code&gt; y &lt;code&gt;DepthFun&lt;/code&gt; falla, se llama a &lt;code&gt;FormatFun&lt;/code&gt; una vez m&amp;aacute;s con un argumento que excluye &lt;code&gt;NElements&lt;/code&gt; y &lt;code&gt;DepthFun&lt;/code&gt; ( &lt;code&gt;{lookup,&amp;nbsp;Position,&amp;nbsp;Keys}&lt;/code&gt; o &lt;code&gt;all&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="77f72ab6f85f6c9d8cbda669ebba998dc661fc5e" translate="yes" xml:space="preserve">
          <source>If caseful matching is in force at the time of the back reference, the case of letters is relevant. For example, the following matches &quot;rah rah&quot; and &quot;RAH RAH&quot;, but not &quot;RAH rah&quot;, although the original capturing subpattern is matched caselessly:</source>
          <target state="translated">Si la coincidencia de casos está vigente en el momento de la referencia retrospectiva,el caso de las cartas es relevante.Por ejemplo,lo siguiente coincide con &quot;rah rah&quot; y &quot;RAH RAH&quot;,pero no con &quot;RAH rah&quot;,aunque el subpatrón de captura original se corresponde sin caso:</target>
        </trans-unit>
        <trans-unit id="e13d741efb191e9fa7c1727072c2302000c01f26" translate="yes" xml:space="preserve">
          <source>If certain port-specific data must be accessed from other threads than those calling the driver callbacks, a port data lock can be used to synchronize the operations on the data. Currently, the only port-specific data that the emulator associates with the port data lock is the driver queue.</source>
          <target state="translated">Si es necesario acceder a determinados datos específicos del puerto desde otros hilos que no sean los que llaman a las devoluciones de llamada del conductor,puede utilizarse un bloqueo de datos del puerto para sincronizar las operaciones en los datos.Actualmente,los únicos datos específicos de los puertos que el emulador asocia al bloqueo de datos de los puertos son la cola de controladores.</target>
        </trans-unit>
        <trans-unit id="f54d5e9e6d2fd31d6eabb83cccb9c261c4f828a5" translate="yes" xml:space="preserve">
          <source>If compilation fails for one or more suites, the compilation errors are printed to tty and the operator is asked if the test run is to proceed without the missing suites, or be aborted. If the operator chooses to proceed, the tests having missing suites are noted in the HTML log. If &lt;code&gt;Common Test&lt;/code&gt; is unable to prompt the user after compilation failure (if &lt;code&gt;Common Test&lt;/code&gt; does not control &lt;code&gt;stdin&lt;/code&gt;), the test run proceeds automatically without the missing suites. This behavior can however be modified with the &lt;code&gt;ct_run&lt;/code&gt; flag &lt;code&gt;-abort_if_missing_suites&lt;/code&gt;, or the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; option &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt;. If &lt;code&gt;abort_if_missing_suites&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the test run stops immediately if some suites fail to compile.</source>
          <target state="translated">Si la compilaci&amp;oacute;n falla para una o m&amp;aacute;s suites, los errores de compilaci&amp;oacute;n se imprimen en tty y se le pregunta al operador si la ejecuci&amp;oacute;n de la prueba debe continuar sin las suites faltantes o si se cancelar&amp;aacute;. Si el operador decide continuar, las pruebas a las que les faltan suites se anotan en el registro HTML. Si &lt;code&gt;Common Test&lt;/code&gt; no puede avisar al usuario despu&amp;eacute;s de un error de compilaci&amp;oacute;n (si &lt;code&gt;Common Test&lt;/code&gt; no controla &lt;code&gt;stdin&lt;/code&gt; ), la ejecuci&amp;oacute;n de la prueba procede autom&amp;aacute;ticamente sin las suites faltantes. Este comportamiento, sin embargo puede ser modificado con las &lt;code&gt;ct_run&lt;/code&gt; bandera &lt;code&gt;-abort_if_missing_suites&lt;/code&gt; , o la &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; opci&amp;oacute;n &lt;code&gt;{abort_if_missing_suites,TrueOrFalse}&lt;/code&gt; . Si &lt;code&gt;abort_if_missing_suites&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , la ejecuci&amp;oacute;n de la prueba se detiene inmediatamente si algunas suites no se compilan.</target>
        </trans-unit>
        <trans-unit id="ddef6fb238c70a7447c7b61165fd491bf02611b6" translate="yes" xml:space="preserve">
          <source>If compiling a NIF for static inclusion through &lt;code&gt;--enable-static-nifs&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; before the &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">Si compila un NIF para la inclusi&amp;oacute;n est&amp;aacute;tica a trav&amp;eacute;s de &lt;code&gt;--enable-static-nifs&lt;/code&gt; , debe definir &lt;code&gt;STATIC_ERLANG_NIF&lt;/code&gt; antes de la declaraci&amp;oacute;n &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9cca373adf442d693560ee904763df365fc27eee" translate="yes" xml:space="preserve">
          <source>If compiling a driver for static inclusion through &lt;code&gt;--enable-static-drivers&lt;/code&gt;, you must define &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; before the &lt;code&gt;DRIVER_INIT&lt;/code&gt; declaration.</source>
          <target state="translated">Si la compilaci&amp;oacute;n de una integraci&amp;oacute;n est&amp;aacute;tica a trav&amp;eacute;s &lt;code&gt;--enable-static-drivers&lt;/code&gt; , debe definir &lt;code&gt;STATIC_ERLANG_DRIVER&lt;/code&gt; antes de la &lt;code&gt;DRIVER_INIT&lt;/code&gt; declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="f7c1f0b07bbf198171947df86c5f80f0e8b91bec" translate="yes" xml:space="preserve">
          <source>If configuration elements (key-value tuples) are to be returned as result instead of values, use option &lt;code&gt;element&lt;/code&gt;. The returned elements are then on the form &lt;code&gt;{Required,Value}&lt;/code&gt;.</source>
          <target state="translated">Si los elementos de configuraci&amp;oacute;n (tuplas clave-valor) deben devolverse como resultado en lugar de valores, utilice el &lt;code&gt;element&lt;/code&gt; o de opci&amp;oacute;n . Los elementos devueltos tienen entonces el formato &lt;code&gt;{Required,Value}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f827f0de33d203f9e3d3e27b4a69d02e3a754313" translate="yes" xml:space="preserve">
          <source>If cross cover analysis is performed, and there are accumulated coverage results for the current test, the link &quot;Coverdata collected over all tests&quot; takes you to these results.</source>
          <target state="translated">Si se realiza un análisis de cobertura cruzada,y hay resultados de cobertura acumulados para la prueba actual,el enlace &quot;Datos de cobertura recogidos sobre todas las pruebas&quot; le lleva a estos resultados.</target>
        </trans-unit>
        <trans-unit id="5d96e5091e8d9707ed005b18c015f0afc06954f5" translate="yes" xml:space="preserve">
          <source>If data is sent to an &lt;code&gt;io_device()&lt;/code&gt; in a format that cannot be converted to the specified encoding, or if data is read by a function that returns data in a format that cannot cope with the character range of the data, an error occurs and the file is closed.</source>
          <target state="translated">Si los datos se env&amp;iacute;an a un &lt;code&gt;io_device()&lt;/code&gt; en un formato que no se puede convertir a la codificaci&amp;oacute;n especificada, o si los datos son le&amp;iacute;dos por una funci&amp;oacute;n que devuelve datos en un formato que no puede hacer frente al rango de caracteres de los datos, se produce un error y el archivo est&amp;aacute; cerrado.</target>
        </trans-unit>
        <trans-unit id="432e1b16af8182ee4323fbba32056a19e755694b" translate="yes" xml:space="preserve">
          <source>If defined, disables input and output flow control for the pty opend by &lt;code&gt;run_erl&lt;/code&gt;. Useful if you want to remove any risk of accidentally blocking the flow control by using Ctrl-S (instead of Ctrl-D to detach), which can result in blocking of the entire Beam process, and in the case of running heart as supervisor even the heart process becomes blocked when writing log message to terminal, leaving the heart process unable to do its work.</source>
          <target state="translated">Si se define, deshabilita el control de flujo de entrada y salida para el pty opend por &lt;code&gt;run_erl&lt;/code&gt; . &amp;Uacute;til si desea eliminar cualquier riesgo de bloquear accidentalmente el control de flujo usando Ctrl-S (en lugar de Ctrl-D para desconectar), lo que puede resultar en el bloqueo de todo el proceso de Beam, y en el caso de ejecutar heart como supervisor incluso el proceso del coraz&amp;oacute;n se bloquea cuando se escribe el mensaje de registro en la terminal, lo que deja al proceso del coraz&amp;oacute;n incapaz de realizar su trabajo.</target>
        </trans-unit>
        <trans-unit id="51ec3e002de949fe36acc63a13c907879ad3bcd0" translate="yes" xml:space="preserve">
          <source>If differentiation between empty matches and non-existing subpatterns is necessary, use the &lt;code&gt;type&lt;/code&gt;&lt;code&gt;index&lt;/code&gt; and do the conversion to the final type in Erlang code.</source>
          <target state="translated">Si es necesaria la diferenciaci&amp;oacute;n entre coincidencias vac&amp;iacute;as y subpatrones no existentes, utilice el &lt;code&gt;index&lt;/code&gt; &lt;code&gt;type&lt;/code&gt; y realice la conversi&amp;oacute;n al tipo final en c&amp;oacute;digo Erlang.</target>
        </trans-unit>
        <trans-unit id="e301f5120b552d4bf6f7613573c8dff6a6c32f8f" translate="yes" xml:space="preserve">
          <source>If empty, the scheduler was doing some work. If not empty, the scheduler is either in some state of sleep, or suspended. This entry is only present in an SMP-enabled emulator.</source>
          <target state="translated">Si estaba vacío,el programador estaba haciendo algún trabajo.Si no está vacío,el programador está en algún estado de sueño,o suspendido.Esta entrada sólo está presente en un emulador habilitado para SMP.</target>
        </trans-unit>
        <trans-unit id="1afa77778077164a71f88c72fb4b32ad3297d31d" translate="yes" xml:space="preserve">
          <source>If enabled and available, shows the process SASL log entries.</source>
          <target state="translated">Si está habilitado y disponible,muestra el proceso de registro de entradas del SASL.</target>
        </trans-unit>
        <trans-unit id="7f6edf3b58ff2519bb720cd88ea08b2b0a6a0946" translate="yes" xml:space="preserve">
          <source>If enabled, a signal will be sent to each scheduler to check its responsiveness. The system check occurs before any heartbeat sent to the port program. If any scheduler is not responsive enough the heart program will not receive its heartbeat and thus eventually terminate the node.</source>
          <target state="translated">Si se activa,se enviará una señal a cada programador para comprobar su respuesta.La comprobación del sistema se produce antes de que se envíe cualquier latido al programa de puertos.Si algún programador no responde lo suficiente,el programa cardíaco no recibirá sus latidos y,por lo tanto,eventualmente terminará el nodo.</target>
        </trans-unit>
        <trans-unit id="148b1ea2e5a9c15263dc8ca4149113489de1e307" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function can add possible default values or internal state values to the configuration, and return the adjusted map in &lt;code&gt;{ok,Config2}&lt;/code&gt;.</source>
          <target state="translated">Si todo tiene &amp;eacute;xito, la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada puede agregar posibles valores predeterminados o valores de estado interno a la configuraci&amp;oacute;n y devolver el mapa ajustado en &lt;code&gt;{ok,Config2}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df38b6fefb42b5ad05d2e66a0fe9a0579def5bda" translate="yes" xml:space="preserve">
          <source>If everything succeeds, the callback function must return a possibly adjusted configuration in &lt;code&gt;{ok,Config3}&lt;/code&gt;.</source>
          <target state="translated">Si todo tiene &amp;eacute;xito, la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada debe devolver una configuraci&amp;oacute;n posiblemente ajustada en &lt;code&gt;{ok,Config3}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="364e140fe39154a26dff03af44ca4298c8c2ac50" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;-loader&lt;/code&gt; is omitted, it defaults to &lt;code&gt;efile&lt;/code&gt;.</source>
          <target state="translated">Si se omite flag &lt;code&gt;-loader&lt;/code&gt; , el valor predeterminado es &lt;code&gt;efile&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1454b961b40da8803e24e93858c630e5ff3bb457" translate="yes" xml:space="preserve">
          <source>If flag &lt;code&gt;timestamp&lt;/code&gt;, &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, or &lt;code&gt;monotonic_timestamp&lt;/code&gt; is specified, the first tuple element is &lt;code&gt;trace_ts&lt;/code&gt; instead, and the time stamp is added as an extra element last in the message tuple. If multiple time stamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt;, which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All time stamp flags are remembered, so if two are passed and the one with highest precedence later is disabled, the other one becomes active.</source>
          <target state="translated">Si se especifica la &lt;code&gt;timestamp&lt;/code&gt; , la marca de tiempo &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; o la marca de tiempo &lt;code&gt;monotonic_timestamp&lt;/code&gt; , el primer elemento de la tupla es &lt;code&gt;trace_ts&lt;/code&gt; y la marca de tiempo se agrega como un elemento adicional al final de la tupla del mensaje. Si se pasan varias &lt;code&gt;timestamp&lt;/code&gt; y hora , la marca de tiempo tiene prioridad sobre la marca de tiempo &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; , que a su vez tiene prioridad sobre la marca de tiempo &lt;code&gt;monotonic_timestamp&lt;/code&gt; . Todos los indicadores de marca de tiempo se recuerdan, por lo que si se pasan dos y se deshabilita el que tiene la prioridad m&amp;aacute;s alta, el otro se activa.</target>
        </trans-unit>
        <trans-unit id="7e5b82748f9af0c18d76e825667a1416cb4f5744" translate="yes" xml:space="preserve">
          <source>If flags &lt;code&gt;-pa&lt;/code&gt; or &lt;code&gt;-pz&lt;/code&gt; are specified in the &lt;code&gt;Common Test&lt;/code&gt; group of options (preceding &lt;code&gt;-erl_args&lt;/code&gt;), relative directories are converted to absolute and reinserted into the code path by &lt;code&gt;Common Test&lt;/code&gt;. This is to avoid problems loading user modules when &lt;code&gt;Common Test&lt;/code&gt; changes working directory during test runs. However, &lt;code&gt;Common Test&lt;/code&gt; ignores flags &lt;code&gt;-pa&lt;/code&gt; and &lt;code&gt;-pz&lt;/code&gt; following &lt;code&gt;-erl_args&lt;/code&gt; on the command line. These directories are added to the code path normally (that is, on specified form).</source>
          <target state="translated">Si se especifican los indicadores &lt;code&gt;-pa&lt;/code&gt; o &lt;code&gt;-pz&lt;/code&gt; en el grupo de opciones de &lt;code&gt;Common Test&lt;/code&gt; (antes de &lt;code&gt;-erl_args&lt;/code&gt; ), los directorios relativos se convierten en absolutos y &lt;code&gt;Common Test&lt;/code&gt; los reinsertan en la ruta del c&amp;oacute;digo . Esto es para evitar problemas al cargar m&amp;oacute;dulos de usuario cuando &lt;code&gt;Common Test&lt;/code&gt; cambia el directorio de trabajo durante la ejecuci&amp;oacute;n de la prueba. Sin embargo, &lt;code&gt;Common Test&lt;/code&gt; ignora los indicadores &lt;code&gt;-pa&lt;/code&gt; y &lt;code&gt;-pz&lt;/code&gt; que siguen a &lt;code&gt;-erl_args&lt;/code&gt; en la l&amp;iacute;nea de comando. Estos directorios se agregan a la ruta del c&amp;oacute;digo normalmente (es decir, en el formulario especificado).</target>
        </trans-unit>
        <trans-unit id="1e378e106e4077ae24d5e6f29ec376f6a4bd3b26" translate="yes" xml:space="preserve">
          <source>If for some reason megaco is unable to deliver the reply, the reason for this will be passed to the user via a call to the callback function &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt;, unless &lt;code&gt;ack_action() = discard_ack&lt;/code&gt;.</source>
          <target state="translated">Si por alguna raz&amp;oacute;n megaco no puede entregar la respuesta, la raz&amp;oacute;n de esto se le pasar&amp;aacute; al usuario mediante una llamada a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;&lt;a href=&quot;#trans_ack&quot;&gt;handle_trans_ack&lt;/a&gt;&lt;/code&gt; , a menos que &lt;code&gt;ack_action() = discard_ack&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17a3144d24e90d3f080c638b20288fd31695b9f8" translate="yes" xml:space="preserve">
          <source>If found, this file is automatically included when a release package is created.</source>
          <target state="translated">Si se encuentra,este archivo se incluye automáticamente cuando se crea un paquete de lanzamiento.</target>
        </trans-unit>
        <trans-unit id="88a8d1bcc6dc202674f35ee136d67e69ecbf0dcd" translate="yes" xml:space="preserve">
          <source>If function &lt;code&gt;start_link/3,4,5&lt;/code&gt; is used and the process crashes before it has called &lt;code&gt;init_ack/1,2&lt;/code&gt;, &lt;code&gt;{error, Reason}&lt;/code&gt; is returned if the calling process traps exits.</source>
          <target state="translated">Si se &lt;code&gt;start_link/3,4,5&lt;/code&gt; funci&amp;oacute;n start_link / 3,4,5 y el proceso falla antes de llamar a &lt;code&gt;init_ack/1,2&lt;/code&gt; , se devuelve &lt;code&gt;{error, Reason}&lt;/code&gt; si el proceso de llamada sale.</target>
        </trans-unit>
        <trans-unit id="fc69364c0ae557a1dbe6b4d9aa1b146e1216ffbd" translate="yes" xml:space="preserve">
          <source>If function calls are traced, trace patterns must be added by clicking button &lt;strong&gt;Add Trace Pattern&lt;/strong&gt;. Select a module, function(s), and a match specification. If no functions are selected, all functions in the module are traced.</source>
          <target state="translated">Si se rastrean las llamadas a funciones, se deben agregar patrones de rastreo haciendo clic en el bot&amp;oacute;n &lt;strong&gt;Agregar patr&amp;oacute;n de rastreo&lt;/strong&gt; . Seleccione un m&amp;oacute;dulo, funci&amp;oacute;n (es) y una especificaci&amp;oacute;n de coincidencia. Si no se selecciona ninguna funci&amp;oacute;n, se rastrean todas las funciones del m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="1f07e18dbc5f57c6c6717a768b0ed4eaba425e5a" translate="yes" xml:space="preserve">
          <source>If given, sets a minimum of bytes per second value for connections.</source>
          <target state="translated">Si se da,establece un valor mínimo de bytes por segundo para las conexiones.</target>
        </trans-unit>
        <trans-unit id="b172d1229983e5a1a9ff5fbcf190541819d75da7" translate="yes" xml:space="preserve">
          <source>If header file &lt;code&gt;ms_transform.hrl&lt;/code&gt; is not included, the fun is not translated, which can result in a &lt;strong&gt;runtime error&lt;/strong&gt; (depending on whether the fun is valid in a pure Erlang context).</source>
          <target state="translated">Si el archivo de encabezado &lt;code&gt;ms_transform.hrl&lt;/code&gt; no est&amp;aacute; incluido, la diversi&amp;oacute;n no se traduce, lo que puede resultar en un &lt;strong&gt;error de tiempo de ejecuci&amp;oacute;n&lt;/strong&gt; (dependiendo de si la diversi&amp;oacute;n es v&amp;aacute;lida en un contexto Erlang puro).</target>
        </trans-unit>
        <trans-unit id="16995098726e7577905f8e4783d07b32252efedf" translate="yes" xml:space="preserve">
          <source>If heart should &lt;strong&gt;not&lt;/strong&gt; kill the Erlang runtime system, this can be indicated using the environment variable &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt;. This can be useful if the command executed by heart takes care of this, for example as part of a specific cleanup sequence. If unset, or not set to &lt;code&gt;TRUE&lt;/code&gt;, the default behaviour will be to kill as described above.</source>
          <target state="translated">Si el coraz&amp;oacute;n &lt;strong&gt;no&lt;/strong&gt; debe matar el sistema de ejecuci&amp;oacute;n de Erlang, esto se puede indicar usando la variable de entorno &lt;code&gt;HEART_NO_KILL=TRUE&lt;/code&gt; . Esto puede ser &amp;uacute;til si el comando ejecutado de memoria se encarga de esto, por ejemplo, como parte de una secuencia de limpieza espec&amp;iacute;fica. Si no se configura, o no se establece en &lt;code&gt;TRUE&lt;/code&gt; , el comportamiento predeterminado ser&amp;aacute; matar como se describe anteriormente.</target>
        </trans-unit>
        <trans-unit id="b95d064b6fe476b33228869a58d35631e292ffa4" translate="yes" xml:space="preserve">
          <source>If instead &lt;code&gt;m1&lt;/code&gt; and &lt;code&gt;ch3&lt;/code&gt; belong to the same application, the &lt;code&gt;.appup&lt;/code&gt; file can look as follows:</source>
          <target state="translated">Si, en cambio, &lt;code&gt;m1&lt;/code&gt; y &lt;code&gt;ch3&lt;/code&gt; pertenecen a la misma aplicaci&amp;oacute;n, el archivo &lt;code&gt;.appup&lt;/code&gt; puede tener el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="dc6d61b4492f1c7e6142a54cbe978ede62016351" translate="yes" xml:space="preserve">
          <source>If instead the cover specification for &lt;code&gt;s2&lt;/code&gt; is like the following:</source>
          <target state="translated">Si, en cambio, la especificaci&amp;oacute;n de la cubierta para &lt;code&gt;s2&lt;/code&gt; es como la siguiente:</target>
        </trans-unit>
        <trans-unit id="0a7e93ff7cf25c1c8178af08584a9eabcf3e9a0a" translate="yes" xml:space="preserve">
          <source>If instead the following pattern is used, it matches &quot;sense and responsibility&quot; and the other two strings:</source>
          <target state="translated">Si en lugar de ello se utiliza el siguiente patrón,coincide con &quot;sentido y responsabilidad&quot; y las otras dos cuerdas:</target>
        </trans-unit>
        <trans-unit id="2cc8cc207fcbebe26bafa392de36c0b0727d0b02" translate="yes" xml:space="preserve">
          <source>If it is determined during execution of &lt;code&gt;end_per_testcase&lt;/code&gt; that the status of a successful test case is to be changed to failed, &lt;code&gt;end_per_testcase&lt;/code&gt; can return the tuple &lt;code&gt;{fail,Reason}&lt;/code&gt; (where &lt;code&gt;Reason&lt;/code&gt; describes why the test case fails).</source>
          <target state="translated">Si se determina durante la ejecuci&amp;oacute;n de &lt;code&gt;end_per_testcase&lt;/code&gt; que el estado de un caso de prueba exitoso debe cambiarse a fallido, &lt;code&gt;end_per_testcase&lt;/code&gt; puede devolver la tupla &lt;code&gt;{fail,Reason}&lt;/code&gt; (donde &lt;code&gt;Reason&lt;/code&gt; describe por qu&amp;eacute; falla el caso de prueba).</target>
        </trans-unit>
        <trans-unit id="7ff18467b22f0114a8805a4726fb2dcc0392ce69" translate="yes" xml:space="preserve">
          <source>If it is important to get similar indentation and newlines as in the original document you have to add #xmlText{} records with space and newline values in appropriate places. It may also be necessary to keep the original prolog where the DTD is referenced. If so, it is possible to pass a RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; to &lt;code&gt;export_simple/3&lt;/code&gt;. The following example code fixes those changes in the previous example:</source>
          <target state="translated">Si es importante obtener una sangr&amp;iacute;a y nuevas l&amp;iacute;neas similares a las del documento original, debe agregar registros #xmlText {} con espacios y valores de nueva l&amp;iacute;nea en los lugares apropiados. Tambi&amp;eacute;n puede ser necesario mantener el pr&amp;oacute;logo original donde se hace referencia a la DTD. Si es as&amp;iacute;, es posible pasar un RootAttribute &lt;code&gt;{prolog,Value}&lt;/code&gt; a &lt;code&gt;export_simple/3&lt;/code&gt; . El siguiente c&amp;oacute;digo de ejemplo corrige esos cambios en el ejemplo anterior:</target>
        </trans-unit>
        <trans-unit id="0edefb6e50405687abd870a868c1bcff5bf5189f" translate="yes" xml:space="preserve">
          <source>If it is important to minimize the time that an application is inactive while changing code, use &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;atomic_load/1&lt;/code&gt;. Here is an example:</source>
          <target state="translated">Si es importante minimizar el tiempo que una aplicaci&amp;oacute;n est&amp;aacute; inactiva mientras se cambia el c&amp;oacute;digo, use &lt;code&gt;&lt;a href=&quot;#prepare_loading-1&quot;&gt;prepare_loading/1&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#finish_loading-1&quot;&gt;finish_loading/1&lt;/a&gt;&lt;/code&gt; en lugar de &lt;code&gt;atomic_load/1&lt;/code&gt; . Aqu&amp;iacute; hay un ejemplo:</target>
        </trans-unit>
        <trans-unit id="04b581ca359dbb5b4e61555833c3a8149c91dfc0" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_server&lt;/code&gt; must be set to trap exit signals in function &lt;code&gt;init&lt;/code&gt;. When ordered to shutdown, the &lt;code&gt;gen_server&lt;/code&gt; then calls the callback function &lt;code&gt;terminate(shutdown, State)&lt;/code&gt;:</source>
          <target state="translated">Si es necesario limpiar antes de la terminaci&amp;oacute;n, la estrategia de apagado debe ser un valor de tiempo de espera y &lt;code&gt;gen_server&lt;/code&gt; debe configurarse para capturar se&amp;ntilde;ales de salida en la funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; . Cuando se le ordena que se apague, &lt;code&gt;gen_server&lt;/code&gt; luego llama a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;terminate(shutdown, State)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e79bb817b263e5ddf9ba4cef4ae14edfb7ff9782" translate="yes" xml:space="preserve">
          <source>If it is necessary to clean up before termination, the shutdown strategy must be a time-out value and the &lt;code&gt;gen_statem&lt;/code&gt; must in function &lt;code&gt;init/1&lt;/code&gt; set itself to trap exit signals by calling &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt;:</source>
          <target state="translated">Si es necesario limpiar antes de la terminaci&amp;oacute;n, la estrategia de apagado debe ser un valor de tiempo de espera y &lt;code&gt;gen_statem&lt;/code&gt; debe configurarse en la funci&amp;oacute;n &lt;code&gt;init/1&lt;/code&gt; para &lt;code&gt;process_flag(trap_exit, true)&lt;/code&gt; se&amp;ntilde;ales de salida llamando a process_flag (trap_exit, true) :</target>
        </trans-unit>
        <trans-unit id="c10551de78ce4c13b76bdcb633906a358226cfc9" translate="yes" xml:space="preserve">
          <source>If it is needed to compile a set of &lt;code&gt;ASN.1&lt;/code&gt; modules into an Erlang file with encode/decode functions, ensure to list all involved files in a configuration file. This configuration file must have a double extension &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; (&lt;code&gt;&quot;.asn&quot;&lt;/code&gt; can alternatively be &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; or &lt;code&gt;&quot;.py&quot;&lt;/code&gt;). List the input file names within quotation marks (&quot;&quot;), one at each row in the file. If the input files are &lt;code&gt;File1.asn&lt;/code&gt;, &lt;code&gt;File2.asn&lt;/code&gt;, and &lt;code&gt;File3.asn&lt;/code&gt;, the configuration file must look as follows:</source>
          <target state="translated">Si es necesario compilar un conjunto de m&amp;oacute;dulos &lt;code&gt;ASN.1&lt;/code&gt; en un archivo Erlang con funciones de codificaci&amp;oacute;n / decodificaci&amp;oacute;n, aseg&amp;uacute;rese de enumerar todos los archivos involucrados en un archivo de configuraci&amp;oacute;n. Este archivo de configuraci&amp;oacute;n debe tener una extensi&amp;oacute;n doble &lt;code&gt;&quot;.set.asn&quot;&lt;/code&gt; ( &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; puede ser alternativamente &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; o &lt;code&gt;&quot;.py&quot;&lt;/code&gt; ). Enumere los nombres de los archivos de entrada entre comillas (&quot;&quot;), uno en cada fila del archivo. Si los archivos de entrada son &lt;code&gt;File1.asn&lt;/code&gt; , &lt;code&gt;File2.asn&lt;/code&gt; y &lt;code&gt;File3.asn&lt;/code&gt; , el archivo de configuraci&amp;oacute;n debe tener el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="5d51fd241eafb95c913d685374e5a264641108ee" translate="yes" xml:space="preserve">
          <source>If it is possible for a manager to create or delete rows in the table, there must be a &lt;code&gt;RowStatus&lt;/code&gt; column for &lt;code&gt;is_set_ok&lt;/code&gt;, &lt;code&gt;set&lt;/code&gt; and &lt;code&gt;undo&lt;/code&gt; to work properly.</source>
          <target state="translated">Si es posible que un administrador para crear o Eliminar filas en la tabla, tiene que haber un &lt;code&gt;RowStatus&lt;/code&gt; columna para &lt;code&gt;is_set_ok&lt;/code&gt; , &lt;code&gt;set&lt;/code&gt; y &lt;code&gt;undo&lt;/code&gt; para que funcione correctamente.</target>
        </trans-unit>
        <trans-unit id="78796728bcb7c7764f0d079115e6608598e07dda" translate="yes" xml:space="preserve">
          <source>If it is possible to load &lt;code&gt;Module&lt;/code&gt; and function &lt;code&gt;Function/N&lt;/code&gt; is exported, it is called.</source>
          <target state="translated">Si es posible cargar el &lt;code&gt;Module&lt;/code&gt; y se exporta la funci&amp;oacute;n &lt;code&gt;Function/N&lt;/code&gt; , se llama.</target>
        </trans-unit>
        <trans-unit id="34f89c49da4f3e679accd5b84c8be09ec8b3341c" translate="yes" xml:space="preserve">
          <source>If it is required that Mnesia must build and maintain an extra index table on attribute &lt;code&gt;address&lt;/code&gt; of all the &lt;code&gt;person&lt;/code&gt; records that are inserted in the table, the following code would be issued:</source>
          <target state="translated">Si se requiere que Mnesia debe construir y mantener una tabla de &amp;iacute;ndice adicional en la &lt;code&gt;address&lt;/code&gt; de atributo de todos los registros de &lt;code&gt;person&lt;/code&gt; as que se insertan en la tabla, se emitir&amp;aacute; el siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="88bfd8938101283cd461120f722bba92f5d433c5" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing key in the map, a new association is created from key &lt;code&gt;K&lt;/code&gt; to value &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Si la clave &lt;code&gt;K&lt;/code&gt; no coincide con ninguna clave existente en el mapa, una nueva asociaci&amp;oacute;n se crea a partir clave &lt;code&gt;K&lt;/code&gt; de valor &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="361674b6db4757a45860f6c0ff467ce229682848" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; does not match any existing keys in map &lt;code&gt;M&lt;/code&gt;, an exception of type &lt;code&gt;badarg&lt;/code&gt; is triggered at runtime. If a matching key &lt;code&gt;K&lt;/code&gt; is present in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;, and the evaluated map expression returns a new map.</source>
          <target state="translated">Si la clave &lt;code&gt;K&lt;/code&gt; no coincide con ninguna clave existente en el mapa &lt;code&gt;M&lt;/code&gt; , se activa una excepci&amp;oacute;n de tipo &lt;code&gt;badarg&lt;/code&gt; en tiempo de ejecuci&amp;oacute;n. Si una clave coincidente &lt;code&gt;K&lt;/code&gt; est&amp;aacute; presente en el mapa &lt;code&gt;M&lt;/code&gt; , su valor asociado se reemplaza por el nuevo valor &lt;code&gt;V&lt;/code&gt; y la expresi&amp;oacute;n de mapa evaluada devuelve un nuevo mapa.</target>
        </trans-unit>
        <trans-unit id="c0a6ddca5224e31c09a05fdd6034a788ec478e89" translate="yes" xml:space="preserve">
          <source>If key &lt;code&gt;K&lt;/code&gt; matches an existing key in map &lt;code&gt;M&lt;/code&gt;, its associated value is replaced by the new value &lt;code&gt;V&lt;/code&gt;. In both cases, the evaluated map expression returns a new map.</source>
          <target state="translated">Si la clave &lt;code&gt;K&lt;/code&gt; coincide con una clave existente en el mapa &lt;code&gt;M&lt;/code&gt; , su valor asociado se sustituye por el nuevo valor &lt;code&gt;V&lt;/code&gt; . En ambos casos, la expresi&amp;oacute;n de mapa evaluada devuelve un nuevo mapa.</target>
        </trans-unit>
        <trans-unit id="42a830a40777cba9136dab78e83126fb44890b72" translate="yes" xml:space="preserve">
          <source>If later &lt;code&gt;Pid&lt;/code&gt; terminates with a reason &lt;code&gt;Reason&lt;/code&gt;, the supervisor bridge terminates with reason &lt;code&gt;Reason&lt;/code&gt; as well. If later the supervisor bridge is stopped by its supervisor with reason &lt;code&gt;Reason&lt;/code&gt;, it calls &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; to terminate.</source>
          <target state="translated">Si un &lt;code&gt;Pid&lt;/code&gt; posterior termina con un motivo &lt;code&gt;Reason&lt;/code&gt; , el puente supervisor tambi&amp;eacute;n termina con un motivo &lt;code&gt;Reason&lt;/code&gt; . Si m&amp;aacute;s tarde, el supervisor detiene el puente supervisor con motivo &lt;code&gt;Reason&lt;/code&gt; , llama al &lt;code&gt;Module:terminate(Reason,State)&lt;/code&gt; para terminar.</target>
        </trans-unit>
        <trans-unit id="3a49b5785a5ebb3a3e817628501985a6f158407e" translate="yes" xml:space="preserve">
          <source>If long node node names are used, initiation is done by calling &lt;code&gt;erl_connect_xinit()&lt;/code&gt;:</source>
          <target state="translated">Si se utilizan nombres de nodo largos, el inicio se realiza llamando a &lt;code&gt;erl_connect_xinit()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="0a0fdc2466475ba354acc0c8a05ce784a5bde5f7" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it (or terminated). A reference counter is kept on a per process basis, and N consecutive fixes requires N releases to release the table.</source>
          <target state="translated">Si muchos procesos fijan una tabla,ésta permanece fija hasta que todos los procesos la hayan liberado (o terminado).Se mantiene un contador de referencia por cada proceso,y N arreglos consecutivos requieren N liberaciones para liberar la tabla.</target>
        </trans-unit>
        <trans-unit id="0c297e380855cf1730e1b5795f833b28141150c8" translate="yes" xml:space="preserve">
          <source>If many processes fix a table, the table remains fixed until all processes have released it or terminated. A reference counter is kept on a per process basis, and N consecutive fixes require N releases to release the table.</source>
          <target state="translated">Si muchos procesos arreglan una tabla,ésta permanece fija hasta que todos los procesos la hayan liberado o terminado.Se mantiene un contador de referencia por cada proceso,y N arreglos consecutivos requieren N liberaciones para liberar la tabla.</target>
        </trans-unit>
        <trans-unit id="53435afc4e831537f2a17e9899dbdd4cb79d80ed" translate="yes" xml:space="preserve">
          <source>If map &lt;code&gt;map_in&lt;/code&gt; contains &lt;code&gt;key&lt;/code&gt;, this function makes a copy of &lt;code&gt;map_in&lt;/code&gt; in &lt;code&gt;*map_out&lt;/code&gt;, and removes &lt;code&gt;key&lt;/code&gt; and the associated value. If map &lt;code&gt;map_in&lt;/code&gt; does not contain &lt;code&gt;key&lt;/code&gt;, &lt;code&gt;*map_out&lt;/code&gt; is set to &lt;code&gt;map_in&lt;/code&gt;.</source>
          <target state="translated">Si map &lt;code&gt;map_in&lt;/code&gt; contiene &lt;code&gt;key&lt;/code&gt; , esta funci&amp;oacute;n hace una copia de &lt;code&gt;map_in&lt;/code&gt; in &lt;code&gt;*map_out&lt;/code&gt; y elimina la &lt;code&gt;key&lt;/code&gt; y el valor asociado. Si el mapa &lt;code&gt;map_in&lt;/code&gt; no contiene la &lt;code&gt;key&lt;/code&gt; , &lt;code&gt;*map_out&lt;/code&gt; se establece en &lt;code&gt;map_in&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6edf0f9b76d8b501d4e816cd9d78be0eb60417a0" translate="yes" xml:space="preserve">
          <source>If mode is disturbing, the server is blocked forcefully, all ongoing requests terminates, and the reload starts immediately. If mode is non-disturbing, no new connections are accepted, but ongoing requests are allowed to complete before the reload is done.</source>
          <target state="translated">Si el modo es perturbador,el servidor se bloquea a la fuerza,todas las solicitudes en curso terminan y la recarga comienza inmediatamente.Si el modo no es perturbador,no se aceptan nuevas conexiones,pero se permite que las solicitudes en curso se completen antes de que se haga la recarga.</target>
        </trans-unit>
        <trans-unit id="e360c70f0d772545e95505fb9d2d98d4f6aab9bb" translate="yes" xml:space="preserve">
          <source>If modules are compiled with inlining, spurious warnings can be emitted. In the &lt;strong&gt;Options&lt;/strong&gt; menu you can choose to ignore inline-compiled modules when analyzing byte code. When starting from source code, this is not a problem because inlining is explicitly turned off by Dialyzer. The option causes Dialyzer to suppress all warnings from inline-compiled modules, as there is currently no way for Dialyzer to find what parts of the code have been produced by inlining.</source>
          <target state="translated">Si los m&amp;oacute;dulos se compilan con inserci&amp;oacute;n, se pueden emitir advertencias falsas. En el men&amp;uacute; &lt;strong&gt;Opciones&lt;/strong&gt; , puede optar por ignorar los m&amp;oacute;dulos compilados en l&amp;iacute;nea al analizar el c&amp;oacute;digo de bytes. Al comenzar desde el c&amp;oacute;digo fuente, esto no es un problema porque el Inlining est&amp;aacute; expl&amp;iacute;citamente desactivado por Dialyzer. La opci&amp;oacute;n hace que Dialyzer suprima todas las advertencias de los m&amp;oacute;dulos compilados en l&amp;iacute;nea, ya que actualmente no hay forma de que Dialyzer encuentre qu&amp;eacute; partes del c&amp;oacute;digo se han producido mediante la inserci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ae716d5d8a33ea589343e3a0fd8de6a8cb8c320e" translate="yes" xml:space="preserve">
          <source>If more complex filtering is needed, use &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; and specify the exact filter according to &quot;XML Schema for Event Notifications&quot; in RFC 5277.</source>
          <target state="translated">Si se necesita un filtrado m&amp;aacute;s complejo, use &lt;code&gt;&lt;a href=&quot;#get-2&quot;&gt;ct_netconfc:get/2,3&lt;/a&gt;&lt;/code&gt; y especifique el filtro exacto de acuerdo con el &quot;Esquema XML para notificaciones de eventos&quot; en RFC 5277.</target>
        </trans-unit>
        <trans-unit id="36a1865d02dfc0df8a1f4e482a94e12100776ba1" translate="yes" xml:space="preserve">
          <source>If more than &lt;code&gt;MaxR&lt;/code&gt; number of restarts occur in the last &lt;code&gt;MaxT&lt;/code&gt; seconds, the supervisor terminates all the child processes and then itself. The termination reason for the supervisor itself in that case will be &lt;code&gt;shutdown&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;MaxR&lt;/code&gt; n&amp;uacute;mero de reinicios superior al MaxR en los &amp;uacute;ltimos &lt;code&gt;MaxT&lt;/code&gt; segundos, el supervisor finaliza todos los procesos secundarios y luego &amp;eacute;l mismo. El motivo de la rescisi&amp;oacute;n del supervisor mismo en ese caso ser&amp;aacute; el &lt;code&gt;shutdown&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4518103e529715a70474c2780a5c3ec980b88617" translate="yes" xml:space="preserve">
          <source>If more than a certain amount of available system memory is allocated, as reported by the underlying operating system, the alarm &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; is set.</source>
          <target state="translated">Si se asigna m&amp;aacute;s de una cierta cantidad de memoria disponible del sistema, seg&amp;uacute;n lo informado por el sistema operativo subyacente, se &lt;code&gt;{system_memory_high_watermark, []}&lt;/code&gt; la alarma {system_memory_high_watermark, []} .</target>
        </trans-unit>
        <trans-unit id="d231020eccfbc66c22211e22df6c7cecb22eb6a5" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb exists in a pattern, a different one that follows (*COMMIT) can be triggered first, so merely passing (*COMMIT) during a match does not always guarantee that a match must be at this starting point.</source>
          <target state="translated">Si existe más de un verbo de retroceso en un patrón,se puede activar primero uno diferente que siga (*COMMIT),por lo que el mero hecho de pasar (*COMMIT)durante un partido no siempre garantiza que un partido debe estar en este punto de partida.</target>
        </trans-unit>
        <trans-unit id="3508e8e529ddb74814eed659592c5affc8d5bd2a" translate="yes" xml:space="preserve">
          <source>If more than one backtracking verb is present in a pattern, the one that is backtracked onto first acts. For example, consider the following pattern, where A, B, and so on, are complex pattern fragments:</source>
          <target state="translated">Si hay más de un verbo de retroceso en un patrón,el que se retrocede a los primeros actos.Por ejemplo,consideremos el siguiente patrón,donde A,B,y así sucesivamente,son fragmentos de patrones complejos:</target>
        </trans-unit>
        <trans-unit id="aeb08026d08e982ee4c93506a7932708091433e1" translate="yes" xml:space="preserve">
          <source>If more than one process tries to load an already loaded driver with the same &lt;code&gt;Path&lt;/code&gt;, or if the same process tries to load it many times, the function returns &lt;code&gt;ok&lt;/code&gt;. The emulator keeps track of the &lt;code&gt;load/2&lt;/code&gt; calls, so that a corresponding number of &lt;code&gt;unload/2&lt;/code&gt; calls must be done from the same process before the driver gets unloaded. It is therefore safe for an application to load a driver that is shared between processes or applications when needed. It can safely be unloaded without causing trouble for other parts of the system.</source>
          <target state="translated">Si m&amp;aacute;s de un proceso intenta cargar un controlador ya cargado con la misma &lt;code&gt;Path&lt;/code&gt; , o si el mismo proceso intenta cargarlo muchas veces, la funci&amp;oacute;n devuelve &lt;code&gt;ok&lt;/code&gt; . El emulador realiza un seguimiento de las llamadas de &lt;code&gt;load/2&lt;/code&gt; , de modo que se debe realizar un n&amp;uacute;mero correspondiente de llamadas de &lt;code&gt;unload/2&lt;/code&gt; desde el mismo proceso antes de que se descargue el controlador. Por lo tanto, es seguro que una aplicaci&amp;oacute;n cargue un controlador que se comparte entre procesos o aplicaciones cuando sea necesario. Puede descargarse de forma segura sin causar problemas a otras partes del sistema.</target>
        </trans-unit>
        <trans-unit id="2967b6a58919e3d3f7de7bef014b85f80942bbf1" translate="yes" xml:space="preserve">
          <source>If multi-scheduling is enabled, more than one scheduler thread is used by the emulator. Multi-scheduling can be blocked in two different ways. Either all schedulers but one is blocked, or all &lt;strong&gt;normal&lt;/strong&gt; schedulers but one is blocked. When only normal schedulers are blocked, dirty schedulers are free to continue to schedule processes.</source>
          <target state="translated">Si la programaci&amp;oacute;n m&amp;uacute;ltiple est&amp;aacute; habilitada, el emulador usa m&amp;aacute;s de un subproceso del programador. La programaci&amp;oacute;n m&amp;uacute;ltiple se puede bloquear de dos formas diferentes. Se bloquean todos &lt;strong&gt;los&lt;/strong&gt; programadores menos uno , o todos &lt;strong&gt;los&lt;/strong&gt; programadores &lt;strong&gt;normales&lt;/strong&gt; , menos uno. Cuando solo se bloquean los programadores normales, los programadores sucios pueden continuar programando procesos.</target>
        </trans-unit>
        <trans-unit id="e264c2c185809d37a3371b5c09778551bfdd2307" translate="yes" xml:space="preserve">
          <source>If multiple &lt;code&gt;-eval&lt;/code&gt; expressions are specified, they are evaluated sequentially in the order specified. &lt;code&gt;-eval&lt;/code&gt; expressions are evaluated sequentially with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt; function calls (this also in the order specified). As with &lt;code&gt;-s&lt;/code&gt; and &lt;code&gt;-run&lt;/code&gt;, an evaluation that does not terminate blocks the system initialization process.</source>
          <target state="translated">Si se especifican varias expresiones &lt;code&gt;-eval&lt;/code&gt; , se eval&amp;uacute;an secuencialmente en el orden especificado. &lt;code&gt;-eval&lt;/code&gt; expresiones -eval se eval&amp;uacute;an secuencialmente con &lt;code&gt;-s&lt;/code&gt; y &lt;code&gt;-run&lt;/code&gt; llamadas de funci&amp;oacute;n (esto tambi&amp;eacute;n en el orden especificado). Al igual que con &lt;code&gt;-s&lt;/code&gt; y &lt;code&gt;-run&lt;/code&gt; , una evaluaci&amp;oacute;n que no termina bloquea el proceso de inicializaci&amp;oacute;n del sistema.</target>
        </trans-unit>
        <trans-unit id="97280216c73ddbe9bd1cfe50f8b9e6e9ba9af2e9" translate="yes" xml:space="preserve">
          <source>If multiple timestamp flags are passed, &lt;code&gt;timestamp&lt;/code&gt; has precedence over &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; which in turn has precedence over &lt;code&gt;monotonic_timestamp&lt;/code&gt;. All timestamp flags are remembered, so if two are passed and the one with highest precedence later is disabled the other one will become active.</source>
          <target state="translated">Si se pasan varias marcas de fecha y &lt;code&gt;timestamp&lt;/code&gt; , la marca de tiempo tiene prioridad sobre la marca de tiempo &lt;code&gt;strict_monotonic_timestamp&lt;/code&gt; que a su vez tiene prioridad sobre la marca de tiempo &lt;code&gt;monotonic_timestamp&lt;/code&gt; . Todos los indicadores de marca de tiempo se recuerdan, por lo que si se pasan dos y se deshabilita el que tiene la prioridad m&amp;aacute;s alta, el otro se activar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="15446137a98bae984b924e92fba150a1dcc2db3c" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_server&lt;/code&gt; process calls the callback function &lt;code&gt;ch3:init([])&lt;/code&gt;. &lt;code&gt;init&lt;/code&gt; is expected to return &lt;code&gt;{ok, State}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the internal state of the &lt;code&gt;gen_server&lt;/code&gt;. In this case, the state is the available channels.</source>
          <target state="translated">Si el registro del nombre tiene &amp;eacute;xito, el nuevo proceso &lt;code&gt;gen_server&lt;/code&gt; llama a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;ch3:init([])&lt;/code&gt; . Se espera que &lt;code&gt;init&lt;/code&gt; devuelva &lt;code&gt;{ok, State}&lt;/code&gt; , donde &lt;code&gt;State&lt;/code&gt; es el estado interno del &lt;code&gt;gen_server&lt;/code&gt; . En este caso, el estado son los canales disponibles.</target>
        </trans-unit>
        <trans-unit id="2fbbe04e09f325bd4aa00a3af49946b86a67830b" translate="yes" xml:space="preserve">
          <source>If name registration succeeds, the new &lt;code&gt;gen_statem&lt;/code&gt; process calls callback function &lt;code&gt;code_lock:init(Code)&lt;/code&gt;. This function is expected to return &lt;code&gt;{ok, State, Data}&lt;/code&gt;, where &lt;code&gt;State&lt;/code&gt; is the initial state of the &lt;code&gt;gen_statem&lt;/code&gt;, in this case &lt;code&gt;locked&lt;/code&gt;; assuming that the door is locked to begin with. &lt;code&gt;Data&lt;/code&gt; is the internal server data of the &lt;code&gt;gen_statem&lt;/code&gt;. Here the server data is a &lt;code&gt;map&lt;/code&gt; with key &lt;code&gt;code&lt;/code&gt; that stores the correct button sequence, key &lt;code&gt;length&lt;/code&gt; store its length, and key &lt;code&gt;buttons&lt;/code&gt; that stores the collected buttons up to the same length.</source>
          <target state="translated">Si el registro del nombre tiene &amp;eacute;xito, el nuevo proceso &lt;code&gt;gen_statem&lt;/code&gt; llama a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;code_lock:init(Code)&lt;/code&gt; . Se espera que esta funci&amp;oacute;n devuelva &lt;code&gt;{ok, State, Data}&lt;/code&gt; , donde &lt;code&gt;State&lt;/code&gt; es el estado inicial del &lt;code&gt;gen_statem&lt;/code&gt; , en este caso &lt;code&gt;locked&lt;/code&gt; ; asumiendo que la puerta est&amp;aacute; cerrada para empezar. &lt;code&gt;Data&lt;/code&gt; son los datos del servidor interno de &lt;code&gt;gen_statem&lt;/code&gt; . Aqu&amp;iacute;, los datos del servidor son un &lt;code&gt;map&lt;/code&gt; a con un &lt;code&gt;code&lt;/code&gt; clave que almacena la secuencia de botones correcta, la &lt;code&gt;length&lt;/code&gt; clave almacena su longitud y los &lt;code&gt;buttons&lt;/code&gt; clave que almacenan los botones recopilados hasta la misma longitud.</target>
        </trans-unit>
        <trans-unit id="7e65163ad8d72d6ee5d80daa0e098b4aadff312b" translate="yes" xml:space="preserve">
          <source>If neither &lt;code&gt;-minimal&lt;/code&gt;, nor &lt;code&gt;-sasl&lt;/code&gt; is passed as argument you will be prompted.</source>
          <target state="translated">Si no se &lt;code&gt;-minimal&lt;/code&gt; ni &lt;code&gt;-sasl&lt;/code&gt; ni -sasl como argumento, se le preguntar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="5532948dc2571760fbfaa0cdce397fe861e00347" translate="yes" xml:space="preserve">
          <source>If neither endpoint is desired you can test and re-try like this:</source>
          <target state="translated">Si no se desea ninguno de los dos puntos finales,se puede probar y volver a probar así:</target>
        </trans-unit>
        <trans-unit id="73bad7222a27717f2f7fdcb509b4a128ed0ea2cf" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;ContextName&lt;/code&gt; is specified, the default &lt;code&gt;&quot;&quot;&lt;/code&gt; context is used.</source>
          <target state="translated">Si no se especifica ning&amp;uacute;n &lt;code&gt;ContextName&lt;/code&gt; , se utiliza el contexto &lt;code&gt;&quot;&quot;&lt;/code&gt; predeterminado .</target>
        </trans-unit>
        <trans-unit id="5f8fa538da1412a2b10a3518391e831a5459dc85" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;NotifyName&lt;/code&gt; is specified (or if it is &lt;code&gt;&quot;&quot;&lt;/code&gt;), the notification is sent to all management targets (&lt;code&gt;Addresses&lt;/code&gt; below).</source>
          <target state="translated">Si no se especifica &lt;code&gt;NotifyName&lt;/code&gt; (o si es &lt;code&gt;&quot;&quot;&lt;/code&gt; ), la notificaci&amp;oacute;n se env&amp;iacute;a a todos los destinos de gesti&amp;oacute;n ( &lt;code&gt;Addresses&lt;/code&gt; continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="80ccb4b7a89fa0c5a71d360eba8cfe0f8b2d5620" translate="yes" xml:space="preserve">
          <source>If no &lt;code&gt;Type&lt;/code&gt; is specified, all reports are listed.</source>
          <target state="translated">Si no se especifica ning&amp;uacute;n &lt;code&gt;Type&lt;/code&gt; , se enumeran todos los informes.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
