<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="00525383d9d58422c948ae43bf89fd05e4f983f1" translate="yes" xml:space="preserve">
          <source>Grouping. It matches &lt;code&gt;r&lt;/code&gt;.</source>
          <target state="translated">Agrupamiento. Coincide con &lt;code&gt;r&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fca2a2d5844ec58a2c24e751f2553b4b5f79d344" translate="yes" xml:space="preserve">
          <source>Groups are automatically created when any process joins, and are removed when all processes leave the group. Non-existing group is considered empty (containing no processes).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a121fa06623a2cf82b642092526102dbfe1e92e" translate="yes" xml:space="preserve">
          <source>Groups together the part of the string with the parts of the string matching the subexpressions of the regular expression.</source>
          <target state="translated">Agrupa la parte de la cadena con las partes de la cadena que coinciden con las subexpresiones de la expresión regular.</target>
        </trans-unit>
        <trans-unit id="52a003ff3b98a10e8f4a8754529d8e0afcb36923" translate="yes" xml:space="preserve">
          <source>Groups: all standard groups supported for the Diffie-Hellman key exchange</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d59dfad8a207c19fb03d23c5fa725918ccbc3d3" translate="yes" xml:space="preserve">
          <source>Guard constraints</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5f29b3c3ec5d955af2fe66cafaa0331a892e76b" translate="yes" xml:space="preserve">
          <source>GuardFunction ::= BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;bit_size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfbfeacdb74b0b04f59a3235c6e9c0ab7f512a3c" translate="yes" xml:space="preserve">
          <source>GuardFunction ::= BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;bit_size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt; | &lt;code&gt;get_tcw&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17f5854029d7445b6d33c8e8357f38846f74074b" translate="yes" xml:space="preserve">
          <source>GuardFunction ::= BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt;</source>
          <target state="translated">GuardFunction :: = BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; o | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; El | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="26ab9f4a7563027538eea5c8069b4656a1e5e814" translate="yes" xml:space="preserve">
          <source>GuardFunction ::= BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt; | &lt;code&gt;get_tcw&lt;/code&gt;</source>
          <target state="translated">GuardFunction :: = BoolFunction | &lt;code&gt;abs&lt;/code&gt; | &lt;code&gt;element&lt;/code&gt; o | &lt;code&gt;hd&lt;/code&gt; | &lt;code&gt;length&lt;/code&gt; | &lt;code&gt;map_get&lt;/code&gt; | &lt;code&gt;map_size&lt;/code&gt; | &lt;code&gt;node&lt;/code&gt; | &lt;code&gt;round&lt;/code&gt; | &lt;code&gt;size&lt;/code&gt; | &lt;code&gt;tl&lt;/code&gt; | &lt;code&gt;trunc&lt;/code&gt; | &lt;code&gt;'+'&lt;/code&gt; | &lt;code&gt;'-'&lt;/code&gt; | &lt;code&gt;'*'&lt;/code&gt; | &lt;code&gt;'div'&lt;/code&gt; | &lt;code&gt;'rem'&lt;/code&gt; | &lt;code&gt;'band'&lt;/code&gt; | &lt;code&gt;'bor'&lt;/code&gt; | &lt;code&gt;'bxor'&lt;/code&gt; | &lt;code&gt;'bnot'&lt;/code&gt; | &lt;code&gt;'bsl'&lt;/code&gt; | &lt;code&gt;'bsr'&lt;/code&gt; | &lt;code&gt;'&amp;gt;'&lt;/code&gt; El | &lt;code&gt;'&amp;gt;='&lt;/code&gt; | &lt;code&gt;'&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=&amp;lt;'&lt;/code&gt; | &lt;code&gt;'=:='&lt;/code&gt; | &lt;code&gt;'=='&lt;/code&gt; | &lt;code&gt;'=/='&lt;/code&gt; | &lt;code&gt;'/='&lt;/code&gt; | &lt;code&gt;self&lt;/code&gt; | &lt;code&gt;get_tcw&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="67de3c63a9bd94b74bfc86944368ab7bcdf6d849" translate="yes" xml:space="preserve">
          <source>Guards</source>
          <target state="translated">Guards</target>
        </trans-unit>
        <trans-unit id="bce8571c4897351cf59857c7ecbf1e4a1a421968" translate="yes" xml:space="preserve">
          <source>Guide: Design principles</source>
          <target state="translated">Guía:Principios de diseño</target>
        </trans-unit>
        <trans-unit id="efdf80231713b1d4e801ca0c584a421f5e8f439b" translate="yes" xml:space="preserve">
          <source>Guide: ERTS</source>
          <target state="translated">Guía:ERTS</target>
        </trans-unit>
        <trans-unit id="665e5b30bae9bb0925493ecb48fee34c2fef01e1" translate="yes" xml:space="preserve">
          <source>Guide: Efficiency guide</source>
          <target state="translated">Guía:Guía de eficiencia</target>
        </trans-unit>
        <trans-unit id="758e398526fc027576517b8abb810d97bc7d1a3e" translate="yes" xml:space="preserve">
          <source>Guide: Embedded</source>
          <target state="translated">Guía:Embedded</target>
        </trans-unit>
        <trans-unit id="f0581c94431aa05c2eb8472879c7cc801044559b" translate="yes" xml:space="preserve">
          <source>Guide: Getting started</source>
          <target state="translated">Guía:Cómo empezar...</target>
        </trans-unit>
        <trans-unit id="f240a19e5c8b7cc00f916b707fbdf32023e21d53" translate="yes" xml:space="preserve">
          <source>Guide: Installation guide</source>
          <target state="translated">Guía:Guía de instalación</target>
        </trans-unit>
        <trans-unit id="d502df217602b5fdaf2f55dc2c547ef0fbf862f7" translate="yes" xml:space="preserve">
          <source>Guide: OAM</source>
          <target state="translated">Guía:OAM</target>
        </trans-unit>
        <trans-unit id="5e2bf177d1d38ced2ec568d128c1257de3a75f5f" translate="yes" xml:space="preserve">
          <source>Guide: Programming examples</source>
          <target state="translated">Guía:Ejemplos de programación</target>
        </trans-unit>
        <trans-unit id="e1e72627945ab63186b7656050547019c49d74d8" translate="yes" xml:space="preserve">
          <source>Guide: Reference manual</source>
          <target state="translated">Guía:Manual de referencia</target>
        </trans-unit>
        <trans-unit id="7a69b32cf3986c2b7ac7acbcdbda8e61534fb840" translate="yes" xml:space="preserve">
          <source>Guide: System principles</source>
          <target state="translated">Guía:Principios del sistema</target>
        </trans-unit>
        <trans-unit id="0e2c2ebdd60572423288c669f8e6a4bab450c3df" translate="yes" xml:space="preserve">
          <source>Guide: Tutorial</source>
          <target state="translated">Guía:Tutorial</target>
        </trans-unit>
        <trans-unit id="c06c55a5bcd005bf56c5234eb953099ffc1de3f1" translate="yes" xml:space="preserve">
          <source>Gujarati</source>
          <target state="translated">Gujarati</target>
        </trans-unit>
        <trans-unit id="265e1c23debf982bad1eb28dbf1fb86580b82eab" translate="yes" xml:space="preserve">
          <source>Gurmukhi</source>
          <target state="translated">Gurmukhi</target>
        </trans-unit>
        <trans-unit id="380eb30f2d5ab1cdac2a8d64b79d28cfa75198ff" translate="yes" xml:space="preserve">
          <source>HMAC</source>
          <target state="translated">HMAC</target>
        </trans-unit>
        <trans-unit id="a82c464d40e8920d0a12d5e2c7fa455ce1ecf101" translate="yes" xml:space="preserve">
          <source>HTML presentation of test suite code</source>
          <target state="translated">Presentación en HTML del código del paquete de pruebas</target>
        </trans-unit>
        <trans-unit id="4994badab8d9e0b3f67ec8c58caac837b4abe642" translate="yes" xml:space="preserve">
          <source>HTML presentation of test suite results</source>
          <target state="translated">Presentación en HTML de los resultados del conjunto de pruebas</target>
        </trans-unit>
        <trans-unit id="f40b27d6b8b9a4fc3827264c1da16a04ecf4d094" translate="yes" xml:space="preserve">
          <source>HTTP</source>
          <target state="translated">HTTP</target>
        </trans-unit>
        <trans-unit id="20305aa9587f9aff479101ecd817e441076f14af" translate="yes" xml:space="preserve">
          <source>HTTP option (&lt;code&gt;http_option()&lt;/code&gt;) details:</source>
          <target state="translated">&lt;code&gt;http_option()&lt;/code&gt; opci&amp;oacute;n HTTP ( http_option () ):</target>
        </trans-unit>
        <trans-unit id="20f1936f4eab83709aee013d0385ff1c94b37fcb" translate="yes" xml:space="preserve">
          <source>HTTP request method.</source>
          <target state="translated">Método de solicitud HTTP.</target>
        </trans-unit>
        <trans-unit id="fcfac1cc550ec5fe8503b865623fd3395d7a477a" translate="yes" xml:space="preserve">
          <source>HTTP server API</source>
          <target state="translated">API del servidor HTTP</target>
        </trans-unit>
        <trans-unit id="b5b6a9832e57f59fa9ba1970b4197664e77906ed" translate="yes" xml:space="preserve">
          <source>HTTP version, currently &quot;HTTP/1.1&quot;</source>
          <target state="translated">Versión HTTP,actualmente &quot;HTTP/1.1&quot;</target>
        </trans-unit>
        <trans-unit id="415221bf4b248b264aa84fda2df240cd373a09c7" translate="yes" xml:space="preserve">
          <source>Hair space</source>
          <target state="translated">Espacio para el cabello</target>
        </trans-unit>
        <trans-unit id="15710324ddc14a3ddc719e414d041bb782d93764" translate="yes" xml:space="preserve">
          <source>Han</source>
          <target state="translated">Han</target>
        </trans-unit>
        <trans-unit id="74c85e2b16d60ea1dcaab2f9e4e25d96c53123be" translate="yes" xml:space="preserve">
          <source>Handle a inform message.</source>
          <target state="translated">Manejar un mensaje de información.</target>
        </trans-unit>
        <trans-unit id="8c78d25f102ef8eda10b5a75012e8b64805bd431" translate="yes" xml:space="preserve">
          <source>Handle a notification to be sent. The filter can either accept the notification as is, return &lt;code&gt;send&lt;/code&gt;, modify the notification, return &lt;code&gt;{send, NewNotif}&lt;/code&gt; or suppress the notification, return &lt;code&gt;dont_send&lt;/code&gt;.</source>
          <target state="translated">Manejar una notificaci&amp;oacute;n para ser enviada. El filtro puede aceptar la notificaci&amp;oacute;n tal cual, devolver &lt;code&gt;send&lt;/code&gt; , modificar la notificaci&amp;oacute;n, devolver &lt;code&gt;{send, NewNotif}&lt;/code&gt; o suprimir la notificaci&amp;oacute;n, devolver &lt;code&gt;dont_send&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b0760030c5c3f38e40c1b890da4d533b3c3fc8c" translate="yes" xml:space="preserve">
          <source>Handle a report message.</source>
          <target state="translated">Manejar un mensaje de informe.</target>
        </trans-unit>
        <trans-unit id="45fa6cc9728ceb60ac0a051db0f488d3202736ce" translate="yes" xml:space="preserve">
          <source>Handle a trap/notification message from an agent.</source>
          <target state="translated">Manejar un mensaje de trampa/notificación de un agente.</target>
        </trans-unit>
        <trans-unit id="f9c7fc7481552d6aff278b1c974d55353318d9fe" translate="yes" xml:space="preserve">
          <source>Handle for a specific FTP connection, see module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Manejar para una conexi&amp;oacute;n FTP espec&amp;iacute;fica, ver m&amp;oacute;dulo &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bbda4bcf7ac58978c155de552f386a7cabd7519e" translate="yes" xml:space="preserve">
          <source>Handle for a specific SSH/SFTP connection, see module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Manejar para una conexi&amp;oacute;n SSH / SFTP espec&amp;iacute;fica, ver m&amp;oacute;dulo &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75e91cbb42fd0e3d90b67be347008953368d932a" translate="yes" xml:space="preserve">
          <source>Handle for a specific Telnet connection, see module &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Manejar para una conexi&amp;oacute;n Telnet espec&amp;iacute;fica, ver m&amp;oacute;dulo &lt;code&gt;&lt;a href=&quot;ct&quot;&gt;ct&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16bec71f169580069c04eb366b2e7edd0709fd66" translate="yes" xml:space="preserve">
          <source>Handle the reply to an asynchronous request, such as &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Maneja la respuesta a una solicitud asincr&amp;oacute;nica, como &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d44a583cd21c337171ab088369294e9f1adf157" translate="yes" xml:space="preserve">
          <source>Handle the reply to an asynchronous request, such as &lt;code&gt;&lt;a href=&quot;snmpm#async_get2&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next2&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;snmpm#async_set2&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fbbec4581856cdf831ad92220e8c0c524192fd1" translate="yes" xml:space="preserve">
          <source>Handle to a NETCONF session, as required by signaling functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b159af3f46722bc08fb303932f585dbf455dbca5" translate="yes" xml:space="preserve">
          <source>Handle to a connection to a NETCONF server as returned by &lt;code&gt;&lt;a href=&quot;#connect-1&quot;&gt;connect/1,2&lt;/a&gt;&lt;/code&gt;, or to a session as returned by &lt;code&gt;&lt;a href=&quot;#session-1&quot;&gt;session/1-3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#only_open-1&quot;&gt;only_open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87b5cbd72ade701ab78a0c66eea3cc365bc59eac" translate="yes" xml:space="preserve">
          <source>Handle to the &lt;code&gt;epp&lt;/code&gt; server.</source>
          <target state="translated">Manejar al servidor &lt;code&gt;epp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e52aaa094b5e8a1137aac218cd0a979749732ffd" translate="yes" xml:space="preserve">
          <source>Handler Callback Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="200f27a9fd62c17ba568575a28f8cc78a29e0aa9" translate="yes" xml:space="preserve">
          <source>Handler configuration data for Logger. The following default values apply:</source>
          <target state="translated">Datos de configuración del manipulador para el Logger.Se aplican los siguientes valores predeterminados:</target>
        </trans-unit>
        <trans-unit id="e767bf13ab13407d576b285180deba35039b9c4c" translate="yes" xml:space="preserve">
          <source>Handler filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;. They can also be specified directly in the configuration when adding a handler with &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt; logger:add_handler/3&lt;/a&gt;&lt;/code&gt; or via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e4e5ac3ff721d07867e9b05c8337ed55ee393d3" translate="yes" xml:space="preserve">
          <source>Handler filters are added with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and removed with &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;. They can also be specified directly in the configuration when adding a handler with &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; or via the Kernel configuration parameter &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los filtros de &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; se agregan con logger: add_handler_filter / 3 y se eliminan con &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; . Tambi&amp;eacute;n se pueden especificar directamente en la configuraci&amp;oacute;n al agregar un controlador con el &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler/3&lt;/a&gt;&lt;/code&gt; o mediante el &lt;code&gt;&lt;a href=&quot;#logger_parameter&quot;&gt;logger&lt;/a&gt;&lt;/code&gt; par&amp;aacute;metros de configuraci&amp;oacute;n del kernel .</target>
        </trans-unit>
        <trans-unit id="a19df29c14bb59d2df47c78d5601e95477f6e53a" translate="yes" xml:space="preserve">
          <source>Handler filters are specified when adding the handler, or added or removed during runtime with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt; logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt; logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa2c83d2d8b95dd0f46137f7539ec6164e318e2" translate="yes" xml:space="preserve">
          <source>Handler filters are specified when adding the handler, or added or removed during runtime with &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Los filtros de controlador se especifican al agregar el controlador, o se agregan o eliminan durante el tiempo de ejecuci&amp;oacute;n con &lt;code&gt;&lt;a href=&quot;logger#add_handler_filter-3&quot;&gt;logger:add_handler_filter/3&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;logger#remove_handler_filter-2&quot;&gt;logger:remove_handler_filter/2&lt;/a&gt;&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="f0065b00d67594d8a62cb8fb9796876e1d8da5ac" translate="yes" xml:space="preserve">
          <source>Handler specific configuration data is inserted by the handler callback itself, in a sub structure associated with the field named &lt;code&gt;config&lt;/code&gt;.</source>
          <target state="translated">Los datos de configuraci&amp;oacute;n espec&amp;iacute;ficos del manejador son insertados por la propia devoluci&amp;oacute;n de llamada del manejador, en una subestructura asociada con el campo llamado &lt;code&gt;config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="17e94ab879668328c0d7f838700deffb10d37fcd" translate="yes" xml:space="preserve">
          <source>Handler specific configuration data is inserted by the handler callback itself, in a sub structure associated with the field named &lt;code&gt;config&lt;/code&gt;. See the &lt;code&gt;&lt;a href=&quot;logger_std_h&quot;&gt;logger_std_h(3)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;logger_disk_log_h&quot;&gt;logger_disk_log_h(3)&lt;/a&gt;&lt;/code&gt; manual pages for information about the specifc configuration for these handlers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9a11f027cd6db3a106cb106c781e7e6546c3308" translate="yes" xml:space="preserve">
          <source>Handler specific configuration, that is, configuration data related to a specific handler implementation.</source>
          <target state="translated">Configuración específica del manipulador,es decir,datos de configuración relacionados con una implementación específica del manipulador.</target>
        </trans-unit>
        <trans-unit id="8dd3565abe30287cdd82dbf04dfe72c3a01322cc" translate="yes" xml:space="preserve">
          <source>Handles SSH Connection Protocol messages that may need service-specific attention. For details, see &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Maneja mensajes de protocolo de conexi&amp;oacute;n SSH que pueden necesitar atenci&amp;oacute;n espec&amp;iacute;fica del servicio. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;code&gt;&lt;a href=&quot;ssh_connection&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="351ea12c7488865cb104522ed06fb519daaf6841" translate="yes" xml:space="preserve">
          <source>Handles SSH Connection Protocol messages that may need service-specific attention. For details, see &lt;code&gt;&lt;a href=&quot;ssh_connection#type-event&quot;&gt;ssh_connection:event()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88c94d64476ed5597f8322dfbff2cf130463d724" translate="yes" xml:space="preserve">
          <source>Handles messages from Erlang. The messages can either be plain data to be sent or more subtle instructions to the driver. This function is here mostly for data pumping.</source>
          <target state="translated">Maneja los mensajes de Erlang.Los mensajes pueden ser datos simples para ser enviados o instrucciones más sutiles para el conductor.Esta función está aquí principalmente para el bombeo de datos.</target>
        </trans-unit>
        <trans-unit id="921a347faf64cd8a16325d957876e1c04d6d75e2" translate="yes" xml:space="preserve">
          <source>Handles messages sent by calling &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Maneja los mensajes enviados por llamada de &lt;code&gt;&lt;a href=&quot;#call-2&quot;&gt;call/[2,3]&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="f1b9f0ea31717ef2e1c8cb50a77717454cf70a8b" translate="yes" xml:space="preserve">
          <source>Handles messages sent by calling &lt;code&gt;cast/2&lt;/code&gt;.</source>
          <target state="translated">Maneja los mensajes enviados llamando a &lt;code&gt;cast/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="26b904f520d22bb388f5046965390b894bfa3594" translate="yes" xml:space="preserve">
          <source>Handles other messages than SSH Connection Protocol, call, or cast messages sent to the channel.</source>
          <target state="translated">Maneja otros mensajes que no sean del protocolo de conexión SSH,llama o lanza mensajes enviados al canal.</target>
        </trans-unit>
        <trans-unit id="2fd2edfd14e358bb3197eb296e3226354fa0bcbd" translate="yes" xml:space="preserve">
          <source>Handles storing of scanner information when parsing.</source>
          <target state="translated">Maneja el almacenamiento de la información del escáner al analizarla.</target>
        </trans-unit>
        <trans-unit id="9787eca8b55e04c46475fed50a4b8ca6fa155b36" translate="yes" xml:space="preserve">
          <source>Handles the OTP-MIB</source>
          <target state="translated">Maneja el OTP-MIB</target>
        </trans-unit>
        <trans-unit id="a6c4fd9a67f6ff85d671fb367281d35a7948d754" translate="yes" xml:space="preserve">
          <source>Handling any other memory management</source>
          <target state="translated">Manejar cualquier otra gestión de la memoria</target>
        </trans-unit>
        <trans-unit id="8aef8f3753bae4ea18f0ce0e73cebcd5d20ccb5d" translate="yes" xml:space="preserve">
          <source>Handling instruction with variable number of operands</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b341e45d0db6d71ec15e4a0de6c3934aeec4ccd4" translate="yes" xml:space="preserve">
          <source>Handling of binary data (binaries / bit syntax).</source>
          <target state="translated">Manejo de datos binarios (binarios/sintaxis de bits).</target>
        </trans-unit>
        <trans-unit id="a2823aadf112ce5f5e68f202feabf8215b84b288" translate="yes" xml:space="preserve">
          <source>Handling of configuration files specifying data related to the System Under Test (SUT) (and any other variable data)</source>
          <target state="translated">Manejo de los archivos de configuración que especifican los datos relacionados con el Sistema Bajo Prueba (SUT)(y cualquier otro dato variable)</target>
        </trans-unit>
        <trans-unit id="33fefddaf63d1b186bf16cc5d6c16046d15037f4" translate="yes" xml:space="preserve">
          <source>Handshake, interchange node name, and authenticate (2)</source>
          <target state="translated">Apretón de manos,intercambiar el nombre del nodo y autentificar (2)</target>
        </trans-unit>
        <trans-unit id="c51f6db8fb76d17c47c7e717ca4c6c5f2b5b4133" translate="yes" xml:space="preserve">
          <source>Handy shortcuts for common tracing settings.</source>
          <target state="translated">Atajos prácticos para configuraciones de rastreo comunes.</target>
        </trans-unit>
        <trans-unit id="bd7d4b95fcd93ad906141f781368bc43c7c7f10a" translate="yes" xml:space="preserve">
          <source>Hangul</source>
          <target state="translated">Hangul</target>
        </trans-unit>
        <trans-unit id="ed413af43425a39818253cc0c5de7394d4a39735" translate="yes" xml:space="preserve">
          <source>Hanunoo</source>
          <target state="translated">Hanunoo</target>
        </trans-unit>
        <trans-unit id="de7ed76e4bc7658794475e0cb1788bf730fb9c21" translate="yes" xml:space="preserve">
          <source>Hard links are not supported on this platform.</source>
          <target state="translated">Los enlaces duros no están soportados en esta plataforma.</target>
        </trans-unit>
        <trans-unit id="e7bcf0ff0ecf672bee67708eac571eebae762e22" translate="yes" xml:space="preserve">
          <source>Hard real-time systems.</source>
          <target state="translated">Sistemas duros en tiempo real.</target>
        </trans-unit>
        <trans-unit id="df63d1ff1b01b407251d0ded52b5cebe7b3b5ed8" translate="yes" xml:space="preserve">
          <source>Hardware Watchdog</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65bebc8f73cff6923a62cf86dbdad6dcd9f3de59" translate="yes" xml:space="preserve">
          <source>Hardware memory barriers or memory fences are instructions that can be used to enforce order between memory accesses. Different hardware architectures provide different memory barriers. Lock free algorithms need to use memory barriers in order to ensure that memory accesses are not reordered in such ways that the algorithm breaks down. Memory barriers are also expensive instructions, so you typically want to minimize the use of these instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f66d0faec5f252a3b8add8ab78a2b77dfef38ca3" translate="yes" xml:space="preserve">
          <source>Hash algorithm to be used for signing the certificate together with the key option. Defaults to sha that is sha1.</source>
          <target state="translated">Algoritmo Hash que se utilizará para firmar el certificado junto con la opción de la llave.Por defecto es sha,que es sha1.</target>
        </trans-unit>
        <trans-unit id="c1abd7377d4f44f416003defcad46c11c4076434" translate="yes" xml:space="preserve">
          <source>Hash functions - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf&quot;&gt; Secure Hash Standard&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; The MD5 Message Digest Algorithm (RFC 1321)&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1320.txt&quot;&gt;The MD4 Message Digest Algorithm (RFC 1320)&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Funciones hash: &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/publications/fips/fips180-4/fips-180-4.pdf&quot;&gt; Secure Hash Standard&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1321.txt&quot;&gt; The MD5 Message Digest Algorithm (RFC 1321)&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc1320.txt&quot;&gt;The MD4 Message Digest Algorithm (RFC 1320)&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="36646a9df5be6ffe4361209dc14cd9eabb8a54c1" translate="yes" xml:space="preserve">
          <source>Hash tables for Erlang terms (ETS).</source>
          <target state="translated">Tablas de hash para los términos de Erlang (ETS).</target>
        </trans-unit>
        <trans-unit id="66d9fc0e303c1db9ac127804366374bdb8ad808d" translate="yes" xml:space="preserve">
          <source>Hashes &lt;code&gt;term&lt;/code&gt; according to the specified &lt;code&gt;&lt;a href=&quot;#ErlNifHash&quot;&gt;ErlNifHash&lt;/a&gt;&lt;/code&gt;&lt;code&gt;type&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;term&lt;/code&gt; hash seg&amp;uacute;n el &lt;code&gt;type&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;#ErlNifHash&quot;&gt;ErlNifHash&lt;/a&gt;&lt;/code&gt; especificado .</target>
        </trans-unit>
        <trans-unit id="93e30adaf0176847ba666855ceca8fa26f1db0ad" translate="yes" xml:space="preserve">
          <source>Having the source code in UTF-8 also allows you to write string literals, function names, and atoms containing Unicode characters with code points &amp;gt; 255. Module names, application names, and node names are still restricted to the ISO Latin-1 range. Binary literals, where you use type &lt;code&gt;/utf8&lt;/code&gt;, can also be expressed using Unicode characters &amp;gt; 255. Having module names or application names using characters other than 7-bit ASCII can cause trouble on operating systems with inconsistent file naming schemes, and can hurt portability, so it is not recommended.</source>
          <target state="translated">Tener el c&amp;oacute;digo fuente en UTF-8 tambi&amp;eacute;n le permite escribir cadenas literales, nombres de funciones y &amp;aacute;tomos que contienen caracteres Unicode con puntos de c&amp;oacute;digo&amp;gt; 255. Los nombres de m&amp;oacute;dulos, aplicaciones y nodos a&amp;uacute;n est&amp;aacute;n restringidos al rango ISO Latin-1. Los literales binarios, donde usa type &lt;code&gt;/utf8&lt;/code&gt; , tambi&amp;eacute;n se pueden expresar usando caracteres Unicode&amp;gt; 255. Tener nombres de m&amp;oacute;dulos o nombres de aplicaciones que usen caracteres que no sean ASCII de 7 bits puede causar problemas en los sistemas operativos con esquemas de nombres de archivos inconsistentes y puede da&amp;ntilde;ar la portabilidad , por lo que no se recomienda.</target>
        </trans-unit>
        <trans-unit id="9f670bf76875dd0a7bbc3b0854cf6973e8fd4fce" translate="yes" xml:space="preserve">
          <source>Having to generate extra random bits for small numbers costs a little performance. This function is about 20% slower than the regular &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Tener que generar bits aleatorios adicionales para n&amp;uacute;meros peque&amp;ntilde;os cuesta un poco de rendimiento. Esta funci&amp;oacute;n es aproximadamente un 20% m&amp;aacute;s lenta que la normal &lt;code&gt;&lt;a href=&quot;#uniform_s-1&quot;&gt;uniform_s/1&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c4449e9b5eb52175eb4e08b8a7330653b852def9" translate="yes" xml:space="preserve">
          <source>Header elements: Module, Author - These commands insert lines on the form &lt;code&gt;-module(&lt;/code&gt;xxx&lt;code&gt;).&lt;/code&gt; and &lt;code&gt;-author('my@home').&lt;/code&gt;. They can be used directly, but are also used as part of the full headers described below.</source>
          <target state="translated">Elementos de encabezado: M&amp;oacute;dulo, Autor: estos comandos insertan l&amp;iacute;neas en el formulario &lt;code&gt;-module(&lt;/code&gt; xxx &lt;code&gt;).&lt;/code&gt; y &lt;code&gt;-author('my@home').&lt;/code&gt; . Se pueden usar directamente, pero tambi&amp;eacute;n se usan como parte de los encabezados completos que se describen a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a6fe09edcf76c414cb39902b06a907d362c636fc" translate="yes" xml:space="preserve">
          <source>Header file for configuration data</source>
          <target state="translated">Archivo de cabecera para los datos de configuración</target>
        </trans-unit>
        <trans-unit id="a12c4113e1bb8f1f4886664bda35d4aa27d7be74" translate="yes" xml:space="preserve">
          <source>Heading for a hidden node. A hidden node is the same as a visible node, except that it is started with the &lt;code&gt;&quot;-hidden&quot;&lt;/code&gt; flag. States the channel number for the node.</source>
          <target state="translated">Rumbo a un nodo oculto. Un nodo oculto es lo mismo que un nodo visible, excepto que se inicia con el &lt;code&gt;&quot;-hidden&quot;&lt;/code&gt; . Indica el n&amp;uacute;mero de canal del nodo.</target>
        </trans-unit>
        <trans-unit id="fed55dc039cca5dcc6f8b46a4f4ace2200d528da" translate="yes" xml:space="preserve">
          <source>Heading for a node that was connected to the crashed node earlier. References (that is, process or port identifiers) to the not connected node existed at the time of the crash. States the channel number for the node.</source>
          <target state="translated">Dirigiéndose a un nodo que estaba conectado al nodo estrellado antes.Las referencias (es decir,los identificadores de procesos o puertos)al nodo no conectado existían en el momento del choque.Indica el número de canal del nodo.</target>
        </trans-unit>
        <trans-unit id="952129998156402241d678235a6162ddb355874b" translate="yes" xml:space="preserve">
          <source>Heading for a visible node, that is, an alive node with a connection to the node that crashed. States the channel number for the node.</source>
          <target state="translated">Dirigiéndose a un nodo visible,es decir,un nodo vivo con una conexión al nodo que se estrelló.Indica el número de canal del nodo.</target>
        </trans-unit>
        <trans-unit id="c243e47447e24ffdd605f179f0a2cab8a40d6b7a" translate="yes" xml:space="preserve">
          <source>Heading.</source>
          <target state="translated">Heading.</target>
        </trans-unit>
        <trans-unit id="4fa5946d7c0314c7ba622549aa822d84deddf1a7" translate="yes" xml:space="preserve">
          <source>Heading. States the module name.</source>
          <target state="translated">De cabeza.Indica el nombre del módulo.</target>
        </trans-unit>
        <trans-unit id="150c7cf2786a06b4ea8a7aed067ae6ad9d638983" translate="yes" xml:space="preserve">
          <source>Heading. States the process identifier.</source>
          <target state="translated">De cabeza.Indica el identificador del proceso.</target>
        </trans-unit>
        <trans-unit id="7145dfcf409c4e094b7363fa76ac09665f29cbd7" translate="yes" xml:space="preserve">
          <source>Heading. States the scheduler identifier.</source>
          <target state="translated">De cabeza.Indica el identificador del programador.</target>
        </trans-unit>
        <trans-unit id="05a03b6ce3444cc92f49fde9b3239e70eade9242" translate="yes" xml:space="preserve">
          <source>Heading. States the table owner (a process identifier).</source>
          <target state="translated">De cabeza.Indica el propietario de la mesa (un identificador del proceso).</target>
        </trans-unit>
        <trans-unit id="410899dc76f34f1fabf6ebe98f9e99757d1588a0" translate="yes" xml:space="preserve">
          <source>Heading. States the timer owner (a process identifier), that is, the process to receive the message when the timer expires.</source>
          <target state="translated">De cabeza.Indica el propietario del temporizador (un identificador de proceso),es decir,el proceso para recibir el mensaje cuando el temporizador expire.</target>
        </trans-unit>
        <trans-unit id="c2d66ec52324213cab485604b51c2b78378fa0a7" translate="yes" xml:space="preserve">
          <source>Heap binaries are small binaries, up to 64 bytes, and are stored directly on the process heap. They are copied when the process is garbage-collected and when they are sent as a message. They do not require any special handling by the garbage collector.</source>
          <target state="translated">Los binarios de pila son binarios pequeños,de hasta 64 bytes,y se almacenan directamente en la pila de proceso.Se copian cuando el proceso se recoge en la basura y cuando se envían como un mensaje.No requieren ninguna manipulación especial por parte del recolector de basura.</target>
        </trans-unit>
        <trans-unit id="21e21ed9381d58c024ca753fbeee40b36f3a6b32" translate="yes" xml:space="preserve">
          <source>Heartbeat interval, in milliseconds</source>
          <target state="translated">Intervalo de latidos del corazón,en milisegundos</target>
        </trans-unit>
        <trans-unit id="4106d21c7ff6614f8b1f5e63e9c6e5e9cdc9e04e" translate="yes" xml:space="preserve">
          <source>Heartbeat monitoring of an Erlang runtime system.</source>
          <target state="translated">Monitoreo de los latidos del corazón de un sistema de tiempo de ejecución Erlang.</target>
        </trans-unit>
        <trans-unit id="348d00693e12bc983bd092677b90434b5a4d869e" translate="yes" xml:space="preserve">
          <source>Hebrew</source>
          <target state="translated">Hebrew</target>
        </trans-unit>
        <trans-unit id="c933a30976c11ef549273b016b878d75f830e3f9" translate="yes" xml:space="preserve">
          <source>HelloRetryRequest</source>
          <target state="translated">HelloRetryRequest</target>
        </trans-unit>
        <trans-unit id="268bfdeda15e6e6a18f731bf9369b4adf0706327" translate="yes" xml:space="preserve">
          <source>Help Menu</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d62999fd30064fd05e82c60b2a94d7ce3e73892c" translate="yes" xml:space="preserve">
          <source>Hence, 1996 is a leap year, 1900 is not, but 2000 is.</source>
          <target state="translated">Por lo tanto,1996 es un año bisiesto,1900 no lo es,pero 2000 sí.</target>
        </trans-unit>
        <trans-unit id="e085c6d848b4c5dcb06ae3d79bc98bb5ed8aaaab" translate="yes" xml:space="preserve">
          <source>Hence, the argument entered as input is doubled as follows:</source>
          <target state="translated">Por lo tanto,el argumento introducido como entrada se duplica de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="42595144f616321737f8b5e7f141df36f0ea93d3" translate="yes" xml:space="preserve">
          <source>Hence, the previous list comprehension demonstrates the formation of the list &lt;code&gt;E#employee.name&lt;/code&gt; such that &lt;code&gt;E&lt;/code&gt; is taken from the table of employees, and attribute &lt;code&gt;sex&lt;/code&gt; of each record is equal to the atom &lt;code&gt;female&lt;/code&gt;.</source>
          <target state="translated">Por lo tanto, la comprensi&amp;oacute;n de la lista anterior demuestra la formaci&amp;oacute;n de la lista &lt;code&gt;E#employee.name&lt;/code&gt; tal que &lt;code&gt;E&lt;/code&gt; se toma de la tabla de empleados, y el atributo &lt;code&gt;sex&lt;/code&gt; o de cada registro es igual al &amp;aacute;tomo &lt;code&gt;female&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0305883084fd7655771a803404eb6b396bb82e43" translate="yes" xml:space="preserve">
          <source>Hence, when a disc-less node needs to find the schema definitions from a remote node on the network, this information must be supplied through application parameter &lt;code&gt;-mnesia extra_db_nodes NodeList&lt;/code&gt;. Without this configuration parameter set, &lt;code&gt;Mnesia&lt;/code&gt; starts as a single node system. Also, the function &lt;code&gt;&lt;a href=&quot;mnesia#change_config-2&quot;&gt;mnesia:change_config/2&lt;/a&gt;&lt;/code&gt; can be used to assign a value to &lt;code&gt;extra_db_nodes&lt;/code&gt; and force a connection after &lt;code&gt;Mnesia&lt;/code&gt; has been started, that is, &lt;code&gt;mnesia:change_config(extra_db_nodes, NodeList)&lt;/code&gt;.</source>
          <target state="translated">Por lo tanto, cuando un nodo sin disco necesita encontrar las definiciones de esquema de un nodo remoto en la red, esta informaci&amp;oacute;n debe proporcionarse a trav&amp;eacute;s del par&amp;aacute;metro de aplicaci&amp;oacute;n &lt;code&gt;-mnesia extra_db_nodes NodeList&lt;/code&gt; . Sin este conjunto de par&amp;aacute;metros de configuraci&amp;oacute;n, &lt;code&gt;Mnesia&lt;/code&gt; comienza como un sistema de nodo &amp;uacute;nico. Adem&amp;aacute;s, la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#change_config-2&quot;&gt;mnesia:change_config/2&lt;/a&gt;&lt;/code&gt; puede utilizarse para asignar un valor a &lt;code&gt;extra_db_nodes&lt;/code&gt; y forzar una conexi&amp;oacute;n despu&amp;eacute;s de &lt;code&gt;Mnesia&lt;/code&gt; se ha iniciado, es decir, &lt;code&gt;mnesia:change_config(extra_db_nodes, NodeList)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f9a6ade28837bafcd59b3b5f9e9096aa0c39c5a" translate="yes" xml:space="preserve">
          <source>Here (?(R) is the start of a conditional subpattern, with two different alternatives for the recursive and non-recursive cases. Item (?R) is the actual recursive call.</source>
          <target state="translated">Aquí (?(R)es el comienzo de un subpatrón condicional,con dos alternativas diferentes para los casos recursivos y no recursivos.El ítem (?R)es la llamada recursiva real.</target>
        </trans-unit>
        <trans-unit id="95eada3e2f0063def4189cbe7e1ac07f33e51ad4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;&quot;mysystem&quot;&lt;/code&gt; is the base release and &lt;code&gt;&quot;mysystem2&quot;&lt;/code&gt; is the release to upgrade to.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;&quot;mysystem&quot;&lt;/code&gt; es la versi&amp;oacute;n base y &lt;code&gt;&quot;mysystem2&quot;&lt;/code&gt; es la versi&amp;oacute;n para actualizar.</target>
        </trans-unit>
        <trans-unit id="c3ae7fc887a9fc509a0c94f1f548abf5e88538b2" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;+W w&lt;/code&gt; and &lt;code&gt;+R 9&lt;/code&gt; are emulator flags. &lt;code&gt;-s my_init&lt;/code&gt; is an init flag, interpreted by &lt;code&gt;init&lt;/code&gt;. &lt;code&gt;-sname arnie&lt;/code&gt; is a user flag, stored by &lt;code&gt;init&lt;/code&gt;. It is read by Kernel and causes the Erlang runtime system to become distributed. Finally, everything after &lt;code&gt;-extra&lt;/code&gt; (that is, &lt;code&gt;+bertie&lt;/code&gt;) is considered as plain arguments.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;+W w&lt;/code&gt; y &lt;code&gt;+R 9&lt;/code&gt; son banderas de emulador. &lt;code&gt;-s my_init&lt;/code&gt; es un indicador de inicio, interpretado por &lt;code&gt;init&lt;/code&gt; . &lt;code&gt;-sname arnie&lt;/code&gt; es un indicador de usuario, almacenado por &lt;code&gt;init&lt;/code&gt; . Kernel lo lee y hace que el sistema de ejecuci&amp;oacute;n de Erlang se distribuya. Finalmente, todo lo que est&amp;eacute; despu&amp;eacute;s de &lt;code&gt;-extra&lt;/code&gt; (es decir, &lt;code&gt;+bertie&lt;/code&gt; ) se considera argumentos simples.</target>
        </trans-unit>
        <trans-unit id="18878a7a47d8170e6d38bdbab2ec1dd97fe93f48" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Binary&lt;/code&gt; is an Erlang binary that contains the encoded data. (If option &lt;code&gt;legacy_erlang_types&lt;/code&gt; has been given, only the binary is returned.)</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;Binary&lt;/code&gt; es un binario Erlang que contiene los datos codificados. (Si se ha proporcionado la opci&amp;oacute;n &lt;code&gt;legacy_erlang_types&lt;/code&gt; , solo se devuelve el binario).</target>
        </trans-unit>
        <trans-unit id="37df4c092f43bb499bc403c1f4e4f375ce537f8f" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;BytesForOpenType&lt;/code&gt; is a list of bytes constituting the encoding of the &quot;unknown&quot; &lt;code&gt;CHOICE&lt;/code&gt; alternative.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;BytesForOpenType&lt;/code&gt; es una lista de bytes que constituyen la codificaci&amp;oacute;n de la alternativa &lt;code&gt;CHOICE&lt;/code&gt; &quot;desconocida&quot; .</target>
        </trans-unit>
        <trans-unit id="46f5f684a77da256af5aa4d76e5b9497068275f5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Fd&lt;/code&gt; was specified to function &lt;code&gt;init/3&lt;/code&gt; as:</source>
          <target state="translated">Aqu&amp;iacute; se especific&amp;oacute; &lt;code&gt;Fd&lt;/code&gt; para que funcione &lt;code&gt;init/3&lt;/code&gt; como:</target>
        </trans-unit>
        <trans-unit id="54d075fd5d42e82f879a36d53b74d7b98bbbfc33" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M0&lt;/code&gt; is any map. It follows that &lt;code&gt;M1 .. M4&lt;/code&gt; are maps as well.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;M0&lt;/code&gt; es cualquier mapa. Se deduce que &lt;code&gt;M1 .. M4&lt;/code&gt; son mapas.</target>
        </trans-unit>
        <trans-unit id="5980443888fa1217e79c3bb79e1e66f80464dd29" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is a term of type map and &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are any expression.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;M&lt;/code&gt; es un t&amp;eacute;rmino de tipo map y &lt;code&gt;K&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; son cualquier expresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b1f20246edf736a721e4d108cf1124970da81a07" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is a term of type map, &lt;code&gt;V&lt;/code&gt; is an expression and &lt;code&gt;K&lt;/code&gt; is an expression that evaluates to an existing key in &lt;code&gt;M&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;M&lt;/code&gt; es un t&amp;eacute;rmino de tipo de mapa, &lt;code&gt;V&lt;/code&gt; es una expresi&amp;oacute;n y &lt;code&gt;K&lt;/code&gt; es una expresi&amp;oacute;n que se eval&amp;uacute;a como una clave existente en &lt;code&gt;M&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0698d19c4d4c3905620eb9ca2f7560cc47809caa" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is any map. The key &lt;code&gt;K&lt;/code&gt; must be a &lt;code&gt;&lt;a href=&quot;#guard_expressions&quot;&gt;guard expression&lt;/a&gt;&lt;/code&gt;, with all variables already bound. &lt;code&gt;V&lt;/code&gt; can be any pattern with either bound or unbound variables.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6105a70c4b87b25ae269fb373351faa4cb7f203" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;M&lt;/code&gt; is any map. The key &lt;code&gt;K&lt;/code&gt; must be an expression with bound variables or literals. &lt;code&gt;V&lt;/code&gt; can be any pattern with either bound or unbound variables.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;M&lt;/code&gt; es cualquier mapa. La clave &lt;code&gt;K&lt;/code&gt; debe ser una expresi&amp;oacute;n con variables ligadas o literales. &lt;code&gt;V&lt;/code&gt; puede ser cualquier patr&amp;oacute;n con variables ligadas o no ligadas.</target>
        </trans-unit>
        <trans-unit id="cfa51aff5e200195c56f9fac50cfa48993ce7499" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Node&lt;/code&gt; is the old node.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;Node&lt;/code&gt; es el nodo antiguo.</target>
        </trans-unit>
        <trans-unit id="40663b6a0bc17a6c5bb5be7fc0a8ec85eb9e5df4" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Node&lt;/code&gt; is the terminated node.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;Node&lt;/code&gt; es el nodo terminado.</target>
        </trans-unit>
        <trans-unit id="3f0cf7c1aa3a9460f5702ed6ce4797a96c09937c" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Sz&lt;/code&gt; is bound to the value in the first byte of the binary. &lt;code&gt;Sz&lt;/code&gt; is then used at the number of bytes to match out as a binary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f5a7de11b2a0f9a883784c833a5e64495abf297" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;Sz&lt;/code&gt; is the combined size of the header and the payload, so we will need to subtract one byte to get the size of the payload.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2aa26917569777b811a459c8edac3b1f6928d1a9" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;X&lt;/code&gt; gets the value &lt;code&gt;paris&lt;/code&gt; and &lt;code&gt;Y&lt;/code&gt;&lt;code&gt;{f,28}&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;X&lt;/code&gt; obtiene el valor &lt;code&gt;paris&lt;/code&gt; e &lt;code&gt;Y&lt;/code&gt; &lt;code&gt;{f,28}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0491a2d3210236bc79073f011f175603cf95e651" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;bin&lt;/code&gt; is a driver binary of length at least 50 and &lt;code&gt;drvport&lt;/code&gt; is a port handle. Notice that &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; comes after the elements of the list, likewise &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;bin&lt;/code&gt; es un controlador binario de al menos 50 de longitud y &lt;code&gt;drvport&lt;/code&gt; es un identificador de puerto. Observe que &lt;code&gt;ERL_DRV_LIST&lt;/code&gt; viene despu&amp;eacute;s de los elementos de la lista, tambi&amp;eacute;n &lt;code&gt;ERL_DRV_TUPLE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="03614fcdf5fd8628354c2dc566e6863e0b8468ca" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;format_temps/1&lt;/code&gt; calls &lt;code&gt;convert_list_to_c/1&lt;/code&gt;. &lt;code&gt;convert_list_to_c/1&lt;/code&gt; takes off the head of the &lt;code&gt;List_of_cities&lt;/code&gt;, converts it to Celsius if needed. The | operator is used to add the (maybe) converted to the converted rest of the list:</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;format_temps/1&lt;/code&gt; llama a &lt;code&gt;convert_list_to_c/1&lt;/code&gt; . &lt;code&gt;convert_list_to_c/1&lt;/code&gt; quita el encabezado de &lt;code&gt;List_of_cities&lt;/code&gt; , lo convierte a Celsius si es necesario. El | El operador se usa para agregar el (quiz&amp;aacute;s) convertido al resto convertido de la lista:</target>
        </trans-unit>
        <trans-unit id="0d41f0b5f278025a79f179eb50cbcf1d17def2de" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;kb.example.org&lt;/code&gt; serves any protocol while &lt;code&gt;www.example.org&lt;/code&gt; presents a secure web server.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;kb.example.org&lt;/code&gt; sirve a cualquier protocolo, mientras que &lt;code&gt;www.example.org&lt;/code&gt; presenta un servidor web seguro.</target>
        </trans-unit>
        <trans-unit id="f36f1eb025a53a1dc6cfb7f8014034366d975093" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;pipe_name&lt;/code&gt; defaults to &lt;code&gt;/tmp/erlang.pipe.N&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;pipe_name&lt;/code&gt; por defecto es &lt;code&gt;/tmp/erlang.pipe.N&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="445ee2128dde70c3cdab895146aba251b7587bf5" translate="yes" xml:space="preserve">
          <source>Here &lt;code&gt;ref&lt;/code&gt; is a &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; and &lt;code&gt;options&lt;/code&gt; the corresponding &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; list passed to &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;watchdog&lt;/code&gt; entry shows the state of a connection's RFC 3539 watchdog state machine. The &lt;code&gt;peer&lt;/code&gt; entry identifies the &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt; for which there will have been &lt;code&gt;peer_up/3&lt;/code&gt; callbacks for the Diameter applications identified by the &lt;code&gt;apps&lt;/code&gt; entry, &lt;code&gt;common&lt;/code&gt; being the &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt;. The &lt;code&gt;caps&lt;/code&gt; entry identifies the capabilities sent by the local node and received from the peer during capabilities exchange. The &lt;code&gt;port&lt;/code&gt; entry displays socket-level information about the transport connection. The &lt;code&gt;statistics&lt;/code&gt; entry presents Diameter-level counters, an entry like &lt;code&gt;{{{0,280,1},recv},2}&lt;/code&gt; saying that the client has received 2 DWR messages: &lt;code&gt;{0,280,1} = {Application_Id, Command_Code, R_Flag}&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; &lt;code&gt;ref&lt;/code&gt; es un &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_ref&quot;&gt;transport_ref()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; y &lt;code&gt;options&lt;/code&gt; la correspondiente lista &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#transport_opt&quot;&gt;transport_opt()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; pasada a &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; . La entrada de &lt;code&gt;watchdog&lt;/code&gt; muestra el estado de la m&amp;aacute;quina de estado de vigilancia RFC 3539 de una conexi&amp;oacute;n. La entrada del &lt;code&gt;peer&lt;/code&gt; identifica el &lt;code&gt;&lt;code&gt;diameter_app:peer_ref()&lt;/code&gt;&lt;/code&gt; para el cual habr&amp;aacute; &lt;code&gt;peer_up/3&lt;/code&gt; devoluciones de llamada para las aplicaciones Diameter identificadas por la entrada de &lt;code&gt;apps&lt;/code&gt; , siendo &lt;code&gt;common&lt;/code&gt; el &lt;code&gt;&lt;code&gt;&lt;a href=&quot;#application_alias&quot;&gt;application_alias()&lt;/a&gt;&lt;/code&gt;&lt;/code&gt; . Las &lt;code&gt;caps&lt;/code&gt; La entrada identifica las capacidades enviadas por el nodo local y recibidas del par durante el intercambio de capacidades. La entrada del &lt;code&gt;port&lt;/code&gt; muestra informaci&amp;oacute;n a nivel de socket sobre la conexi&amp;oacute;n de transporte. La entrada de &lt;code&gt;statistics&lt;/code&gt; presenta contadores de nivel de di&amp;aacute;metro, una entrada como &lt;code&gt;{{{0,280,1},recv},2}&lt;/code&gt; que indica que el cliente ha recibido 2 mensajes DWR: &lt;code&gt;{0,280,1} = {Application_Id, Command_Code, R_Flag}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff06bab188b6989420caf73f4bedde0091d8f752" translate="yes" xml:space="preserve">
          <source>Here a &lt;code&gt;TestDir&lt;/code&gt; can be used to point out the path to a &lt;code&gt;Suite&lt;/code&gt;. Option &lt;code&gt;testcase&lt;/code&gt; corresponds to option &lt;code&gt;-case&lt;/code&gt; in program &lt;code&gt;ct_run&lt;/code&gt;. Configuration files specified in &lt;code&gt;Opts&lt;/code&gt; are installed automatically at startup.</source>
          <target state="translated">Aqu&amp;iacute; se puede utilizar &lt;code&gt;TestDir&lt;/code&gt; para se&amp;ntilde;alar la ruta a una &lt;code&gt;Suite&lt;/code&gt; . La opci&amp;oacute;n &lt;code&gt;testcase&lt;/code&gt; corresponde a la opci&amp;oacute;n &lt;code&gt;-case&lt;/code&gt; en el programa &lt;code&gt;ct_run&lt;/code&gt; . Los archivos de configuraci&amp;oacute;n especificados en &lt;code&gt;Opts&lt;/code&gt; se instalan autom&amp;aacute;ticamente al inicio.</target>
        </trans-unit>
        <trans-unit id="1d215e0a4d1f50aa10db8d5770d81f093532091e" translate="yes" xml:space="preserve">
          <source>Here a system configuration with an MG and MGC residing in one Erlang node each is outlined:</source>
          <target state="translated">Aquí se esboza una configuración de sistema con un MG y un MGC que residen en un nodo de Erlang cada uno:</target>
        </trans-unit>
        <trans-unit id="98f9cd42bd3f2f651c624dd6456d93b42bb7d908" translate="yes" xml:space="preserve">
          <source>Here also the path to the &lt;code&gt;pea-1.0&lt;/code&gt; ebin directory is provided.</source>
          <target state="translated">Aqu&amp;iacute; tambi&amp;eacute;n se proporciona la ruta al directorio ebin &lt;code&gt;pea-1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="37285c244117c11d8428f0cbdceb6d27dd880c01" translate="yes" xml:space="preserve">
          <source>Here are a few suggestions for how to avoid deadlock:</source>
          <target state="translated">Aquí hay algunas sugerencias para evitar el estancamiento:</target>
        </trans-unit>
        <trans-unit id="922875c8c4eca4e656e135b3c76a4d89fd7a3552" translate="yes" xml:space="preserve">
          <source>Here are all type letters that are allowed on the left side of a transformation rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64246a03dadd5871d19e3c38c5d243139b6de281" translate="yes" xml:space="preserve">
          <source>Here d is any number of decimal digits. However, the value of the setting must be less than the value set by the caller of &lt;code&gt;run/3&lt;/code&gt; for it to have any effect. That is, the pattern writer can lower the limit set by the programmer, but not raise it. If there is more than one setting of one of these limits, the lower value is used.</source>
          <target state="translated">Aqu&amp;iacute; d es cualquier n&amp;uacute;mero de d&amp;iacute;gitos decimales. Sin embargo, el valor de la configuraci&amp;oacute;n debe ser menor que el valor establecido por la persona que llama a &lt;code&gt;run/3&lt;/code&gt; para que tenga alg&amp;uacute;n efecto. Es decir, el escritor de patrones puede reducir el l&amp;iacute;mite establecido por el programador, pero no aumentarlo. Si hay m&amp;aacute;s de un ajuste de uno de estos l&amp;iacute;mites, se utiliza el valor m&amp;aacute;s bajo.</target>
        </trans-unit>
        <trans-unit id="50c6e27284216f0fe5f85c8a2e068c1f3dc4d9db" translate="yes" xml:space="preserve">
          <source>Here each &lt;code&gt;ValueI&lt;/code&gt; is the default value for &lt;code&gt;FieldI&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, cada &lt;code&gt;ValueI&lt;/code&gt; es el valor predeterminado para &lt;code&gt;FieldI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42052c3c2c41c15b35977cf7cbb047bcba82e64f" translate="yes" xml:space="preserve">
          <source>Here follows a client side example, divide into several steps for readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cbca54b367e1a4f6983365c6ace0c9e807f6a44" translate="yes" xml:space="preserve">
          <source>Here follows a description of the variables that are defined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4292ce9c08f629230d2ca9c9a4b58e4451d521bd" translate="yes" xml:space="preserve">
          <source>Here follows a series of examples ranging from simple to more complex.</source>
          <target state="translated">Aquí sigue una serie de ejemplos que van desde lo simple a lo más complejo.</target>
        </trans-unit>
        <trans-unit id="7de541520f50013aebeb6484b87ccc69628a3a4f" translate="yes" xml:space="preserve">
          <source>Here follows a simple example of turning a gen_fsm into a &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt;. The example comes from the previous Users Guide for &lt;code&gt;gen_fsm&lt;/code&gt;</source>
          <target state="translated">A continuaci&amp;oacute;n, se muestra un ejemplo sencillo de c&amp;oacute;mo convertir un gen_fsm en un &lt;code&gt;&lt;a href=&quot;gen_statem&quot;&gt;gen_statem&lt;/a&gt;&lt;/code&gt; . El ejemplo proviene de la Gu&amp;iacute;a del usuario anterior para &lt;code&gt;gen_fsm&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="056d3b9258e32cd2a4368560fe9287c17631f021" translate="yes" xml:space="preserve">
          <source>Here follows a simple test specification example:</source>
          <target state="translated">Aquí sigue un simple ejemplo de especificación de prueba:</target>
        </trans-unit>
        <trans-unit id="d1a5f798f4fca1457852fb5ded06b31390f422db" translate="yes" xml:space="preserve">
          <source>Here follows a summary of the settings affecting Unicode:</source>
          <target state="translated">A continuación,un resumen de los ajustes que afectan a Unicode:</target>
        </trans-unit>
        <trans-unit id="e3b0266f7e1ec5f16aeffe2f3cad390ea2d7f486" translate="yes" xml:space="preserve">
          <source>Here follows all types that are allowed to be used in operands for instructions being constructed on the right side of a transformation rule.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36f3b865fe0de9bfe34af31066b4e1fd4775070c" translate="yes" xml:space="preserve">
          <source>Here follows an example of a text message to give a feeling of the difference between the pretty and compact versions of text messages. First the pretty printed, well indented version with long keywords:</source>
          <target state="translated">Aquí sigue un ejemplo de un mensaje de texto para dar una idea de la diferencia entre las versiones bonita y compacta de los mensajes de texto.Primero la versión bien impresa y bien indentada con palabras clave largas:</target>
        </trans-unit>
        <trans-unit id="7f638f5d7f0c6d062a7666cb5822d5e70a90f9fb" translate="yes" xml:space="preserve">
          <source>Here follows an example of a text message to give a feeling of the difference between the pretty and compact versions of text messages. First the pretty, well indented version with long keywords:</source>
          <target state="translated">Aquí sigue un ejemplo de un mensaje de texto para dar una idea de la diferencia entre las versiones bonita y compacta de los mensajes de texto.Primero la versión bonita y bien indentada con palabras clave largas:</target>
        </trans-unit>
        <trans-unit id="63d190124d61370d24019073f53f96c2b39b3a1c" translate="yes" xml:space="preserve">
          <source>Here follows some questions that you might have after reading this section with corresponding tips and links to the answers:</source>
          <target state="translated">A continuación se presentan algunas preguntas que podría tener después de leer esta sección con los correspondientes consejos y enlaces a las respuestas:</target>
        </trans-unit>
        <trans-unit id="bbd3c491062bf2c5eaa657373046fe305f85357c" translate="yes" xml:space="preserve">
          <source>Here follows the details of what exactly is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5e0247c5bebffe1acdce6f9b2820393133d959" translate="yes" xml:space="preserve">
          <source>Here follows the function of the old API. These functions only work on a list of Latin-1 characters.</source>
          <target state="translated">Aquí sigue la función del antiguo API.Estas funciones sólo funcionan en una lista de caracteres del Latín-1.</target>
        </trans-unit>
        <trans-unit id="1e03b2fb11709d9ee5694c2236ecb3d219a8b412" translate="yes" xml:space="preserve">
          <source>Here follows the general configuration terms that are allowed in a cover specification file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7402642ba6204e4b5e86065a76f140fdda43cbe" translate="yes" xml:space="preserve">
          <source>Here follows the type letters that more or less directly corresponds to the types for generic instructions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce3bb36613c3cfade2e1099d8162ab6ab7c75926" translate="yes" xml:space="preserve">
          <source>Here follows type definitions that are used by more than one function in the ODBC API.</source>
          <target state="translated">A continuación se presentan definiciones de tipos que son utilizadas por más de una función en la API de ODBC.</target>
        </trans-unit>
        <trans-unit id="4cdd0b6622fc9da41960fdfdea1968c18c462ed7" translate="yes" xml:space="preserve">
          <source>Here is a bit more complex calculation:</source>
          <target state="translated">Aquí hay un cálculo un poco más complejo:</target>
        </trans-unit>
        <trans-unit id="f4538b53d8767dd2d98b8e1093b19420fc4852f6" translate="yes" xml:space="preserve">
          <source>Here is a complete example. The &lt;code&gt;new_map&lt;/code&gt; instruction is defined like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d349cc2e55bbdec82aca8231149986fa8cec97cd" translate="yes" xml:space="preserve">
          <source>Here is a function call as &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; as the argument to the function &lt;code&gt;print_temp&lt;/code&gt;. When function calls are &lt;strong&gt;nested&lt;/strong&gt; like this, they execute (evaluate) from the inside out. That is, first &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; is evaluated, which gives the value &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; as the temperature is already in Celsius. Then &lt;code&gt;print_temp({moscow,{c,-10}})&lt;/code&gt; is evaluated. The function &lt;code&gt;convert_to_celsius&lt;/code&gt; works in a similar way to the &lt;code&gt;convert_length&lt;/code&gt; function in the previous example.</source>
          <target state="translated">Aqu&amp;iacute; hay una llamada de funci&amp;oacute;n como &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; como argumento de la funci&amp;oacute;n &lt;code&gt;print_temp&lt;/code&gt; . Cuando las llamadas a funciones se &lt;strong&gt;anidan de&lt;/strong&gt; esta manera, se ejecutan (eval&amp;uacute;an) de adentro hacia afuera. Es decir, primero se &lt;code&gt;convert_to_celsius({moscow,{c,-10}})&lt;/code&gt; , lo que da el valor &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; ya que la temperatura ya est&amp;aacute; en grados Celsius. Luego se &lt;code&gt;print_temp({moscow,{c,-10}})&lt;/code&gt; . La funci&amp;oacute;n &lt;code&gt;convert_to_celsius&lt;/code&gt; funciona de manera similar a la funci&amp;oacute;n &lt;code&gt;convert_length&lt;/code&gt; en el ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="7b73ef99e7403f3927ff26a039c6e2a2236690f9" translate="yes" xml:space="preserve">
          <source>Here is a list of some of the MIBs defined in the OTP system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22821c0d8cd96a6861d0a1d65f8c0f8148458395" translate="yes" xml:space="preserve">
          <source>Here is a more complete sequence that contains both adding, updating and removing breakpoints.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f72c798b29ccb529841e5627093d7a56fd4814a8" translate="yes" xml:space="preserve">
          <source>Here is an example how the reserved virtual address space for literals can be raised to 2 GB (2048 MB):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba858455c144cf3056c405c091e7501e673c5076" translate="yes" xml:space="preserve">
          <source>Here is an example of a suitable expression sequence:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00e38b026becd87996568d41fcc3b8f1d79752be" translate="yes" xml:space="preserve">
          <source>Here is an example of this option:</source>
          <target state="translated">He aquí un ejemplo de esta opción:</target>
        </trans-unit>
        <trans-unit id="3f74118ff53b9ac72b1f1d3c138c82f074dbcd87" translate="yes" xml:space="preserve">
          <source>Here is an example showing how values can be specified:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09da04e514cbcbfa274d3aa81a9da1bf964eb8e" translate="yes" xml:space="preserve">
          <source>Here is an example that shows how to count how many times each instruction is executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e17a454a258af8149a5983e38860d0dd63592107" translate="yes" xml:space="preserve">
          <source>Here is an example. The config-file has the following contents:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540ee2aaf7182c6dfc449b18e5accb694e3b0894" translate="yes" xml:space="preserve">
          <source>Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a08ca8184b592a01eaaa55a20f8527f4cca1b8" translate="yes" xml:space="preserve">
          <source>Here is an overview what has been done so far:</source>
          <target state="translated">Aquí hay un resumen de lo que se ha hecho hasta ahora:</target>
        </trans-unit>
        <trans-unit id="368746ba7f8d7397bdc8b79dac1f30fb770a5d1c" translate="yes" xml:space="preserve">
          <source>Here is defined a function that doubles the value of a number and assigned this function to a variable. Thus &lt;code&gt;Xf(5)&lt;/code&gt; returns value 10. Two useful functions when working with lists are &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt;, which are defined as follows:</source>
          <target state="translated">Aqu&amp;iacute; se define una funci&amp;oacute;n que duplica el valor de un n&amp;uacute;mero y se le asigna esta funci&amp;oacute;n a una variable. As&amp;iacute;, &lt;code&gt;Xf(5)&lt;/code&gt; devuelve el valor 10. Dos funciones &amp;uacute;tiles cuando se trabaja con listas son &lt;code&gt;foreach&lt;/code&gt; y &lt;code&gt;map&lt;/code&gt; , que se definen de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="7ce731a790a4205763d05d03b9cf196ef4e9261e" translate="yes" xml:space="preserve">
          <source>Here is how to accomplish the state time-out in the previous example by instead using a generic time-out named for example &lt;code&gt;open&lt;/code&gt;:</source>
          <target state="translated">A continuaci&amp;oacute;n, se explica c&amp;oacute;mo lograr el tiempo de espera del estado en el ejemplo anterior utilizando en su lugar un tiempo de espera gen&amp;eacute;rico llamado, por ejemplo, &lt;code&gt;open&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="a0d2cc3be9345b9bae90d4c70bae158e4ffa9f78" translate="yes" xml:space="preserve">
          <source>Here is how to accomplish the state time-out in the previous example by instead using an Erlang Timer:</source>
          <target state="translated">Aquí está cómo lograr el estado de tiempo muerto en el ejemplo anterior usando en su lugar un Temporizador Erlang:</target>
        </trans-unit>
        <trans-unit id="eaf5ed4c0dabc7f41cc89c5f4a3aa5a863561e75" translate="yes" xml:space="preserve">
          <source>Here is only considered the case when Erlang/OTP is running on a UNIX system.</source>
          <target state="translated">Aquí sólo se considera el caso cuando Erlang/OTP se ejecuta en un sistema UNIX.</target>
        </trans-unit>
        <trans-unit id="5522fd885b43a2eff23d532ec8cfc36c8effcd85" translate="yes" xml:space="preserve">
          <source>Here is the definition of &lt;code&gt;deallocate_return/1&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f17fc708829cfc6fb00458e5b09fdb85b5ef940" translate="yes" xml:space="preserve">
          <source>Here is the ping pong example modified to run on two separate nodes:</source>
          <target state="translated">Aquí está el ejemplo de ping pong modificado para funcionar en dos nodos separados:</target>
        </trans-unit>
        <trans-unit id="36bfcb0b8532e087fad81f46e3b585565729333b" translate="yes" xml:space="preserve">
          <source>Here keys &lt;code&gt;K1 .. Kn&lt;/code&gt; are any expressions with literals or bound variables. If all key expressions evalute successfully and all keys exist in map &lt;code&gt;M&lt;/code&gt;, all variables in &lt;code&gt;V1 .. Vn&lt;/code&gt; is matched to the associated values of their respective keys.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="274b953d352c36df895d0e17f80b41429f1a2865" translate="yes" xml:space="preserve">
          <source>Here keys &lt;code&gt;K1 .. Kn&lt;/code&gt; are any expressions with literals or bound variables. If all keys exist in map &lt;code&gt;M&lt;/code&gt;, all variables in &lt;code&gt;V1 .. Vn&lt;/code&gt; is matched to the associated values of their respective keys.</source>
          <target state="translated">Aqu&amp;iacute; las claves &lt;code&gt;K1 .. Kn&lt;/code&gt; son expresiones con literales o variables ligadas. Si todas las claves existen en el mapa &lt;code&gt;M&lt;/code&gt; , todas las variables en &lt;code&gt;V1 .. Vn&lt;/code&gt; se emparejan con los valores asociados de sus respectivas claves.</target>
        </trans-unit>
        <trans-unit id="69f329541992e8d01a4e5a912d3401c2919e27cf" translate="yes" xml:space="preserve">
          <source>Here more than one list is built. In each iteration step a new list is created that is one element longer than the new previous list.</source>
          <target state="translated">Aquí se construye más de una lista.En cada paso de la iteración se crea una nueva lista que es un elemento más largo que la nueva lista anterior.</target>
        </trans-unit>
        <trans-unit id="4207694f60edbd73e98081488a51ba1699a0f859" translate="yes" xml:space="preserve">
          <source>Here only the Kernel and STDLIB applications are started, that is, the system is started as an ordinary development system. Only two files are needed for all this to work:</source>
          <target state="translated">Aquí sólo se inician las aplicaciones Kernel y STDLIB,es decir,el sistema se inicia como un sistema de desarrollo ordinario.Sólo se necesitan dos archivos para que todo esto funcione:</target>
        </trans-unit>
        <trans-unit id="1a01cbab019a5244984e7111de8ade2f66f53c2f" translate="yes" xml:space="preserve">
          <source>Here some initialization is done, &lt;code&gt;start&lt;/code&gt; is called from &lt;code&gt;open_port&lt;/code&gt;. The data will be passed to &lt;code&gt;control&lt;/code&gt; and &lt;code&gt;stop&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; se realiza una inicializaci&amp;oacute;n, se llama al &lt;code&gt;start&lt;/code&gt; desde &lt;code&gt;open_port&lt;/code&gt; . Los datos se pasar&amp;aacute;n a &lt;code&gt;control&lt;/code&gt; y &lt;code&gt;stop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dd38392b306d639490f3bfdab336a2923914d6c" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;is_eq_exact&lt;/code&gt; instruction is replaced with a specialized instruction that only compares literals, but only if the first operand is a register and the second operand is a literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8285a3adddfb3c22982d47841765517ced8bef67" translate="yes" xml:space="preserve">
          <source>Here the &lt;code&gt;start/0&lt;/code&gt; function,</source>
          <target state="translated">Aqu&amp;iacute; la funci&amp;oacute;n &lt;code&gt;start/0&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="6d1513bbb3276cbd3a38ec95089202ddef094a3d" translate="yes" xml:space="preserve">
          <source>Here the Ti's are atoms (the name of the type) and the Ai's are their arguments</source>
          <target state="translated">Aquí los Ti son átomos (el nombre del tipo)y los Ai son sus argumentos</target>
        </trans-unit>
        <trans-unit id="9acec98c2e5c443462282bed38bd34c514085f2c" translate="yes" xml:space="preserve">
          <source>Here the call to the GC BIF &lt;code&gt;'+'/2&lt;/code&gt; will be replaced with the instruction &lt;code&gt;gen_plus/5&lt;/code&gt;. Note that the same name as used in the C source code must be used for the BIF, which in this case is &lt;code&gt;splus&lt;/code&gt;. It is defined like this in &lt;code&gt;bit.tab&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b79b4c75297735efc429805d3857e3fd989ff1f" translate="yes" xml:space="preserve">
          <source>Here the concept of an &lt;strong&gt;anonymous variable&lt;/strong&gt; &quot;_&quot; is introduced. This is simply shorthand for a variable that gets a value, but the value is ignored. This can be used anywhere suitable, not just in funs. &lt;code&gt;Temp1 &amp;lt; Temp2&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt; if &lt;code&gt;Temp1&lt;/code&gt; is less than &lt;code&gt;Temp2&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; se introduce el concepto de &lt;strong&gt;variable an&amp;oacute;nima&lt;/strong&gt; &quot;_&quot;. Esto es simplemente una abreviatura de una variable que obtiene un valor, pero el valor se ignora. Esto se puede usar en cualquier lugar adecuado, no solo para divertirse. &lt;code&gt;Temp1 &amp;lt; Temp2&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; si &lt;code&gt;Temp1&lt;/code&gt; es menor que &lt;code&gt;Temp2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af3c6eb665702670ccab0184a2424627dfa000a9" translate="yes" xml:space="preserve">
          <source>Here the empty binary (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;) represents the unassigned subpattern. In the &lt;code&gt;binary&lt;/code&gt; case, some information about the matching is therefore lost, as &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; can also be an empty string captured.</source>
          <target state="translated">Aqu&amp;iacute;, el binario vac&amp;iacute;o ( &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ) representa el subpatr&amp;oacute;n no asignado. En el caso &lt;code&gt;binary&lt;/code&gt; , se pierde parte de la informaci&amp;oacute;n sobre la coincidencia, ya que &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; tambi&amp;eacute;n puede ser una cadena vac&amp;iacute;a capturada.</target>
        </trans-unit>
        <trans-unit id="1abd874c2e02ed54ed46fd6eb351fd6b4434ff43" translate="yes" xml:space="preserve">
          <source>Here the file I/O server returns all available options for a file, which are the expected ones, &lt;code&gt;encoding&lt;/code&gt; and &lt;code&gt;binary&lt;/code&gt;. However, the standard shell has some more options:</source>
          <target state="translated">Aqu&amp;iacute; el servidor de E / S de archivos devuelve todas las opciones disponibles para un archivo, que son las esperadas, de &lt;code&gt;encoding&lt;/code&gt; y &lt;code&gt;binary&lt;/code&gt; . Sin embargo, el shell est&amp;aacute;ndar tiene algunas opciones m&amp;aacute;s:</target>
        </trans-unit>
        <trans-unit id="e6b28a4e54bbbd54cef63a1e3115ada96bc39316" translate="yes" xml:space="preserve">
          <source>Here the function &lt;code&gt;fac&amp;gt;&lt;/code&gt; in module &lt;code&gt;tut1&lt;/code&gt; is called with argument &lt;code&gt;4&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute; la funci&amp;oacute;n &lt;code&gt;fac&amp;gt;&lt;/code&gt; en el m&amp;oacute;dulo &lt;code&gt;tut1&lt;/code&gt; se llama con el argumento &lt;code&gt;4&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0d195818a01c51c6fa746b1e3cba1a090681218" translate="yes" xml:space="preserve">
          <source>Here the key to be retrieved is constructed from an expression:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76e0ad7418ef3374cc17d038856a722ae97d8a0c" translate="yes" xml:space="preserve">
          <source>Here the regular expression first matched the &quot;l&quot;, causing &quot;Er&quot; to be the first part in the result. When the regular expression matched, the (only) subexpression was bound to the &quot;l&quot;, so the &quot;l&quot; is inserted in the group together with &quot;Er&quot;. The next match is of the &quot;n&quot;, making &quot;a&quot; the next part to be returned. As the subexpression is bound to substring &quot;n&quot; in this case, the &quot;n&quot; is inserted into this group. The last group consists of the remaining string, as no more matches are found.</source>
          <target state="translated">Aquí la expresión regular coincidió primero con la &quot;l&quot;,causando que &quot;Er&quot; sea la primera parte del resultado.Cuando la expresión regular se emparejó,la (única)subexpresión se unió a la &quot;l&quot;,por lo que la &quot;l&quot; se inserta en el grupo junto con &quot;Er&quot;.La siguiente coincidencia es de la &quot;n&quot;,haciendo que &quot;a&quot; sea la siguiente parte a devolver.Como la subexpresión está ligada a la subcadena &quot;n&quot; en este caso,la &quot;n&quot; se inserta en este grupo.El último grupo consiste en la cadena restante,ya que no se encuentran más coincidencias.</target>
        </trans-unit>
        <trans-unit id="1da2c5952d714e65a29c19457fda0a08e5b2194a" translate="yes" xml:space="preserve">
          <source>Here the return value correspondingly points out all of the string, beginning at index 0, and it is 10 characters long:</source>
          <target state="translated">Aquí el valor de retorno señala correspondientemente toda la cadena,comenzando en el índice 0,y es de 10 caracteres de largo:</target>
        </trans-unit>
        <trans-unit id="8a03dce83b236db4e1a3d7678c31aea14b2cf2d3" translate="yes" xml:space="preserve">
          <source>Here the second operand of &lt;code&gt;move&lt;/code&gt; is constrained to be X register 1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8588926d91ef055e0e752b5cc02d17b611653864" translate="yes" xml:space="preserve">
          <source>Here the shell detects lists containing printable characters or binaries containing printable characters in bytewise or UTF-8 encoding. But what is a printable character? One view is that anything the Unicode standard thinks is printable, is also printable according to the heuristic detection. The result is then that almost any list of integers are deemed a string, and all sorts of characters are printed, maybe also characters that your terminal lacks in its font set (resulting in some unappreciated generic output). Another way is to keep it backward compatible so that only the ISO Latin-1 character set is used to detect a string. A third way is to let the user decide exactly what Unicode ranges that are to be viewed as characters.</source>
          <target state="translated">Aquí el shell detecta listas que contienen caracteres imprimibles o binarios que contienen caracteres imprimibles en codificación bytewise o UTF-8.¿Pero qué es un carácter imprimible? Una opinión es que todo lo que el estándar Unicode cree que es imprimible,también lo es de acuerdo con la detección heurística.El resultado es entonces que casi cualquier lista de números enteros se considera una cadena,y se imprimen todo tipo de caracteres,tal vez también los caracteres de los que carece su terminal en su conjunto de fuentes (lo que da como resultado una salida genérica poco apreciada).Otra forma es mantenerla compatible con la versión anterior de modo que sólo se utilice el conjunto de caracteres ISO Latin-1 para detectar una cadena.Una tercera forma es dejar que el usuario decida exactamente qué rangos de Unicode deben ser vistos como caracteres.</target>
        </trans-unit>
        <trans-unit id="74160bc743886e5a3198a381b4d2136a5e539152" translate="yes" xml:space="preserve">
          <source>Here the signature and message in the last example is verifyed using the public key. The public key is stored in an engine, only to exemplify that it is possible. The public key could of course be handled openly as usual.</source>
          <target state="translated">Aquí la firma y el mensaje del último ejemplo se verifica utilizando la clave pública.La clave pública se almacena en un motor,sólo para ejemplificar que es posible.La clave pública podría,por supuesto,manejarse abiertamente como de costumbre.</target>
        </trans-unit>
        <trans-unit id="d2d4f1fdcedde1498c2f363b018c87e4697de1db" translate="yes" xml:space="preserve">
          <source>Here the user flag &lt;code&gt;-myflag 1&lt;/code&gt; is passed to and stored by the &lt;code&gt;init&lt;/code&gt; process. It is a user-defined flag, presumably used by some user-defined application.</source>
          <target state="translated">Aqu&amp;iacute;, el proceso &lt;code&gt;init&lt;/code&gt; pasa y almacena la bandera de usuario &lt;code&gt;-myflag 1&lt;/code&gt; . Es un indicador definido por el usuario, presumiblemente utilizado por alguna aplicaci&amp;oacute;n definida por el usuario.</target>
        </trans-unit>
        <trans-unit id="402b80a6663c605b1c8ebefde4ea19bbe39ddf28" translate="yes" xml:space="preserve">
          <source>Here we also handle the mode (&lt;code&gt;binary&lt;/code&gt; or &lt;code&gt;list&lt;/code&gt;) that can be set by request &lt;code&gt;setopts&lt;/code&gt;. By default, all OTP I/O servers send data back to the client as lists, but switching mode to &lt;code&gt;binary&lt;/code&gt; can increase efficiency if the I/O server handles it in an appropriate way. The implementation of &lt;code&gt;get_until&lt;/code&gt; is difficult to get efficient, as the supplied function is defined to take lists as arguments, but &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt; can be optimized for binary mode. However, this example does not optimize anything.</source>
          <target state="translated">Aqu&amp;iacute; tambi&amp;eacute;n manejamos el modo ( &lt;code&gt;binary&lt;/code&gt; o de &lt;code&gt;list&lt;/code&gt; a ) que se puede configurar mediante &lt;code&gt;setopts&lt;/code&gt; de solicitud . De forma predeterminada, todos los servidores de E / S de OTP env&amp;iacute;an datos al cliente como listas, pero cambiar el modo a &lt;code&gt;binary&lt;/code&gt; puede aumentar la eficiencia si el servidor de E / S lo maneja de forma adecuada. La implementaci&amp;oacute;n de &lt;code&gt;get_until&lt;/code&gt; es dif&amp;iacute;cil de conseguir eficiente, ya que la funci&amp;oacute;n proporcionada est&amp;aacute; definida para tomar listas como argumentos, pero &lt;code&gt;get_chars&lt;/code&gt; y &lt;code&gt;get_line&lt;/code&gt; se pueden optimizar para el modo binario. Sin embargo, este ejemplo no optimiza nada.</target>
        </trans-unit>
        <trans-unit id="713d45f85233ed9eece81ff1efd22a57b2efbd58" translate="yes" xml:space="preserve">
          <source>Here we check the result from postgres. If it is data, we encode it as lists of lists with column data. Everything from postgres is C strings, so we use &lt;code&gt;ei_x_encode_string&lt;/code&gt; to send the result as strings to Erlang. (The head of the list contains the column names.)</source>
          <target state="translated">Aqu&amp;iacute; verificamos el resultado de postgres. Si son datos, los codificamos como listas de listas con datos de columna. Todo desde postgres son cadenas de C, por lo que usamos &lt;code&gt;ei_x_encode_string&lt;/code&gt; para enviar el resultado como cadenas a Erlang. (El encabezado de la lista contiene los nombres de las columnas).</target>
        </trans-unit>
        <trans-unit id="8cf9c63e747cf336dd3ef22dd8cb27c624c36fc6" translate="yes" xml:space="preserve">
          <source>Here we create an archive script containing both Erlang code and Beam code, then we iterate over all files in the archive and collect their contents and some information about them:</source>
          <target state="translated">Aquí creamos un script de archivo que contiene tanto el código Erlang como el código Beam,luego iteramos sobre todos los archivos del archivo y recogemos su contenido y alguna información sobre ellos:</target>
        </trans-unit>
        <trans-unit id="1a6714f5fe50c9a6bae77694ae3f43b0dac16cb9" translate="yes" xml:space="preserve">
          <source>Here we create file named &lt;code&gt;TAGS&lt;/code&gt; placed it in the directory &lt;code&gt;../projectdir&lt;/code&gt;. The file contains information about the functions, records, and macro definitions of the three files.</source>
          <target state="translated">Aqu&amp;iacute; creamos un archivo llamado &lt;code&gt;TAGS&lt;/code&gt; y lo colocamos en el directorio &lt;code&gt;../projectdir&lt;/code&gt; . El archivo contiene informaci&amp;oacute;n sobre las funciones, registros y definiciones de macros de los tres archivos.</target>
        </trans-unit>
        <trans-unit id="9874d5ad87ce020d9aa6aeca71513d4b4236fc2e" translate="yes" xml:space="preserve">
          <source>Here we have cheated a little by more or less only implementing &lt;code&gt;get_until&lt;/code&gt; and using internal helpers to implement &lt;code&gt;get_chars&lt;/code&gt; and &lt;code&gt;get_line&lt;/code&gt;. In production code, this can be inefficient, but that depends on the frequency of the different requests. Before we start implementing functions &lt;code&gt;put_chars/2&lt;/code&gt; and &lt;code&gt;get_until/5&lt;/code&gt;, we examine the few remaining requests:</source>
          <target state="translated">Aqu&amp;iacute; hemos hecho un poco de trampa al implementar m&amp;aacute;s o menos solo &lt;code&gt;get_until&lt;/code&gt; y usar ayudantes internos para implementar &lt;code&gt;get_chars&lt;/code&gt; y &lt;code&gt;get_line&lt;/code&gt; . En el c&amp;oacute;digo de producci&amp;oacute;n, esto puede ser ineficiente, pero eso depende de la frecuencia de las diferentes solicitudes. Antes de comenzar a implementar las funciones &lt;code&gt;put_chars/2&lt;/code&gt; y &lt;code&gt;get_until/5&lt;/code&gt; , examinamos las pocas solicitudes restantes:</target>
        </trans-unit>
        <trans-unit id="6510718f8630e547e008ebde09d2abc7f3c89e66" translate="yes" xml:space="preserve">
          <source>Here we see that no function distinguishes itself considerably, which is very normal.</source>
          <target state="translated">Aquí vemos que ninguna función se distingue considerablemente,lo cual es muy normal.</target>
        </trans-unit>
        <trans-unit id="465ac4aff2d9132b9905c273ca86662ca9c4c44b" translate="yes" xml:space="preserve">
          <source>Here we will show how &lt;code&gt;i_increment&lt;/code&gt; can be implemented as a combined instruction. We will show each individual fragment first, and then show how to connect them together. First we will need a variable that we can store the value fetched from the register in:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaf2aac2ad0fe378997e3d3e60e43ee8d81edf6f" translate="yes" xml:space="preserve">
          <source>Here you see the use of &lt;code&gt;|&lt;/code&gt; to get the first two elements from the list. If you try to get more elements from the list than there are elements in the list, an error is returned. Notice also the special case of the list with no elements, []:</source>
          <target state="translated">Aqu&amp;iacute; ves el uso de &lt;code&gt;|&lt;/code&gt; para obtener los dos primeros elementos de la lista. Si intenta obtener m&amp;aacute;s elementos de la lista que elementos en la lista, se devuelve un error. Observe tambi&amp;eacute;n el caso especial de la lista sin elementos, []:</target>
        </trans-unit>
        <trans-unit id="08b89fd2c7d9c7d70984a33c283c54baceee4244" translate="yes" xml:space="preserve">
          <source>Here's another example:</source>
          <target state="translated">Aquí hay otro ejemplo:</target>
        </trans-unit>
        <trans-unit id="7996ce3c70bc2e6c31030c0947978923388510ef" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;B&lt;/code&gt; are any expressions and &lt;code&gt;M0&lt;/code&gt; through &lt;code&gt;M4&lt;/code&gt; are the resulting map terms.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;B&lt;/code&gt; son cualquier expresi&amp;oacute;n y &lt;code&gt;M0&lt;/code&gt; a &lt;code&gt;M4&lt;/code&gt; son los t&amp;eacute;rminos del mapa resultantes.</target>
        </trans-unit>
        <trans-unit id="c7c0f63e6feeafed42e889764b5df7fa6ae6b07c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Arguments&lt;/code&gt; is a list of zero or more arguments. The &lt;code&gt;-callback&lt;/code&gt; attribute is to be preferred since the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;Arguments&lt;/code&gt; es una lista de cero o m&amp;aacute;s argumentos. Se &lt;code&gt;-callback&lt;/code&gt; atributo -callback ya que las herramientas pueden utilizar la informaci&amp;oacute;n de tipo adicional para producir documentaci&amp;oacute;n o encontrar discrepancias.</target>
        </trans-unit>
        <trans-unit id="2f63ec204ef51669a64a9412596d13bb3d314da9" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Bin&lt;/code&gt; is bound and the elements are bound or unbound, as in any match.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;Bin&lt;/code&gt; est&amp;aacute; vinculado y los elementos est&amp;aacute;n vinculados o no, como en cualquier partido.</target>
        </trans-unit>
        <trans-unit id="973cdf584bee5b3aebaf02a66418e8e39a601f3c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Expr&lt;/code&gt; is an arbitrary expression, and each &lt;code&gt;Qualifier&lt;/code&gt; is either a generator or a filter.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;Expr&lt;/code&gt; es una expresi&amp;oacute;n arbitraria y cada &lt;code&gt;Qualifier&lt;/code&gt; es un generador o un filtro.</target>
        </trans-unit>
        <trans-unit id="bfa551fd993d5a7e252540038e550aefce8b5242" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;Fd&lt;/code&gt; is the file descriptor for the destination file, or the atom &lt;code&gt;standard_io&lt;/code&gt;. &lt;code&gt;_TraceInfo&lt;/code&gt; contains information from the trace information file (see section &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt;). &lt;code&gt;State&lt;/code&gt; is a state variable for the format handler fun. The initial value of variable &lt;code&gt;State&lt;/code&gt; is specified with the handler option, for example:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;Fd&lt;/code&gt; es el descriptor de archivo para el archivo de destino, o el atom &lt;code&gt;standard_io&lt;/code&gt; . &lt;code&gt;_TraceInfo&lt;/code&gt; contiene informaci&amp;oacute;n del archivo de informaci&amp;oacute;n de seguimiento (consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#trace_info&quot;&gt;Trace Information and File .ti&lt;/a&gt;&lt;/code&gt; ). &lt;code&gt;State&lt;/code&gt; es una variable de estado para la diversi&amp;oacute;n del controlador de formato. El valor inicial de la variable &lt;code&gt;State&lt;/code&gt; se especifica con la opci&amp;oacute;n del controlador, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="034cc33bbe80f01fd04e26b576b575b1176dd3da" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;File&lt;/code&gt; is used as the new variable instead of &lt;code&gt;X&lt;/code&gt;. This is not so wise because code in the fun body cannot refer to the variable &lt;code&gt;File&lt;/code&gt;, which is defined outside of the fun. Compiling this example gives the following diagnostic:</source>
          <target state="translated">A continuaci&amp;oacute;n, &lt;code&gt;File&lt;/code&gt; se utiliza como la nueva variable en lugar de &lt;code&gt;X&lt;/code&gt; . Esto no es tan sabio porque el c&amp;oacute;digo en el cuerpo de la diversi&amp;oacute;n no puede hacer referencia a la variable &lt;code&gt;File&lt;/code&gt; , que se define fuera de la diversi&amp;oacute;n. La compilaci&amp;oacute;n de este ejemplo proporciona el siguiente diagn&amp;oacute;stico:</target>
        </trans-unit>
        <trans-unit id="5adef5db9dcd73f5eebe767f23b82b503f930844" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;S1LogDir&lt;/code&gt; and &lt;code&gt;S2LogDir&lt;/code&gt; are the directories named &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; for each test respectively.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;S1LogDir&lt;/code&gt; y &lt;code&gt;S2LogDir&lt;/code&gt; son los directorios denominados &lt;code&gt;&amp;lt;TestName&amp;gt;.logs&lt;/code&gt; para cada prueba respectivamente.</target>
        </trans-unit>
        <trans-unit id="eb55d7bcff03863047df1e0e245a8ad25b9600d1" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;conn_types&lt;/code&gt; specifies SSH, Telnet, FTP, RPC, and/or SNMP.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;conn_types&lt;/code&gt; especifica SSH, Telnet, FTP, RPC y / o SNMP.</target>
        </trans-unit>
        <trans-unit id="4daf6d3bc463f7669637809f88efe649c2ac2625" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;demo()&lt;/code&gt; evaluates to &lt;code&gt;&quot;Robert&quot;&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;demo()&lt;/code&gt; eval&amp;uacute;a como &lt;code&gt;&quot;Robert&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fefc36dd07702f1db04b9023b0ea8fdf578263c" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;init&lt;/code&gt; does not need any input data and ignores its argument. For &lt;code&gt;terminal_logger&lt;/code&gt;, the internal state is not used. For &lt;code&gt;file_logger&lt;/code&gt;, the internal state is used to save the open file descriptor.</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;init&lt;/code&gt; no necesita ning&amp;uacute;n dato de entrada e ignora su argumento. Para &lt;code&gt;terminal_logger&lt;/code&gt; , no se usa el estado interno. Para &lt;code&gt;file_logger&lt;/code&gt; , el estado interno se usa para guardar el descriptor de archivo abierto.</target>
        </trans-unit>
        <trans-unit id="aba5e0fd19010e47f153b1c0f6d8f4209d232205" translate="yes" xml:space="preserve">
          <source>Here, &lt;code&gt;tuplep&lt;/code&gt; points to an &lt;code&gt;ETERM&lt;/code&gt; struct representing a tuple with two elements; the function name (atom) and the argument (integer). Using the function &lt;code&gt;erl_element()&lt;/code&gt; from &lt;code&gt;erl_eterm&lt;/code&gt;, these elements can be extracted, but they must also be declared as pointers to an &lt;code&gt;ETERM&lt;/code&gt; struct:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;tuplep&lt;/code&gt; apunta a una estructura &lt;code&gt;ETERM&lt;/code&gt; que representa una tupla con dos elementos; el nombre de la funci&amp;oacute;n (&amp;aacute;tomo) y el argumento (entero). Usando la funci&amp;oacute;n &lt;code&gt;erl_element()&lt;/code&gt; de &lt;code&gt;erl_eterm&lt;/code&gt; , estos elementos se pueden extraer, pero tambi&amp;eacute;n deben declararse como punteros a una estructura &lt;code&gt;ETERM&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="3c764964387488a9567355a791b642a791153d46" translate="yes" xml:space="preserve">
          <source>Here, the communication with C is hidden in the implementation of &lt;code&gt;complex.erl&lt;/code&gt;. In the following sections, it is shown how this module can be implemented using the different interoperability mechanisms.</source>
          <target state="translated">Aqu&amp;iacute;, la comunicaci&amp;oacute;n con C est&amp;aacute; oculta en la implementaci&amp;oacute;n de &lt;code&gt;complex.erl&lt;/code&gt; . En los siguientes apartados se muestra c&amp;oacute;mo se puede implementar este m&amp;oacute;dulo utilizando los diferentes mecanismos de interoperabilidad.</target>
        </trans-unit>
        <trans-unit id="a9363a371565a254c5f940c661f77bc4aea0306a" translate="yes" xml:space="preserve">
          <source>Here, the data type &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; is represented as the following Erlang record:</source>
          <target state="translated">Aqu&amp;iacute;, el tipo de datos &lt;code&gt;'IssuingDistributionPoint'&lt;/code&gt; se representa como el siguiente registro Erlang:</target>
        </trans-unit>
        <trans-unit id="27fe64fbf8e84fafc5f91f9a5e3d6acc46a097cf" translate="yes" xml:space="preserve">
          <source>Here, the directive &lt;code&gt;on_load&lt;/code&gt; is used to get function &lt;code&gt;init&lt;/code&gt; to be automatically called when the module is loaded. If &lt;code&gt;init&lt;/code&gt; returns anything other than &lt;code&gt;ok&lt;/code&gt;, such when the loading of the NIF library fails in this example, the module is unloaded and calls to functions within it, fail.</source>
          <target state="translated">Aqu&amp;iacute;, la directiva &lt;code&gt;on_load&lt;/code&gt; se usa para hacer que la funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; sea ​​llamada autom&amp;aacute;ticamente cuando se carga el m&amp;oacute;dulo. Si &lt;code&gt;init&lt;/code&gt; devuelve algo diferente a &lt;code&gt;ok&lt;/code&gt; , como cuando la carga de la biblioteca NIF falla en este ejemplo, el m&amp;oacute;dulo se descarga y las llamadas a funciones dentro de &amp;eacute;l fallan.</target>
        </trans-unit>
        <trans-unit id="6256ecd948c793aa1993c3c12236863caa0abcfe" translate="yes" xml:space="preserve">
          <source>Here, the handler also provides for dynamically reloading of configuration variables. If &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; is called from the test case function, all variables loaded with &lt;code&gt;config_driver:read_config/1&lt;/code&gt; are updated with their latest values, and the new value for variable &lt;code&gt;localtime&lt;/code&gt; is returned.</source>
          <target state="translated">Aqu&amp;iacute;, el controlador tambi&amp;eacute;n proporciona la recarga din&amp;aacute;mica de variables de configuraci&amp;oacute;n. Si se llama a &lt;code&gt;&lt;a href=&quot;ct#reload_config-1&quot;&gt;ct:reload_config(localtime)&lt;/a&gt;&lt;/code&gt; desde la funci&amp;oacute;n de caso de prueba, todas las variables cargadas con &lt;code&gt;config_driver:read_config/1&lt;/code&gt; se actualizan con sus &amp;uacute;ltimos valores y se devuelve el nuevo valor de la variable &lt;code&gt;localtime&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9736652812b2b809017435f7a09559dc888bc0b" translate="yes" xml:space="preserve">
          <source>Here, the same test run as in the previous examples are executed (and possibly repeated). However, when the time-out occurs, after 1 hour, &lt;code&gt;Common Test&lt;/code&gt; finishes the entire test run before stopping (that is, both &lt;code&gt;to1&lt;/code&gt; and &lt;code&gt;to2&lt;/code&gt; are always executed in the same test run).</source>
          <target state="translated">Aqu&amp;iacute;, se ejecuta la misma ejecuci&amp;oacute;n de prueba que en los ejemplos anteriores (y posiblemente se repite). Sin embargo, cuando se agota el tiempo de espera, despu&amp;eacute;s de 1 hora, &lt;code&gt;Common Test&lt;/code&gt; finaliza toda la ejecuci&amp;oacute;n de la prueba antes de detenerse (es decir, tanto &lt;code&gt;to1&lt;/code&gt; como &lt;code&gt;to2&lt;/code&gt; se ejecutan siempre en la misma ejecuci&amp;oacute;n de prueba).</target>
        </trans-unit>
        <trans-unit id="3cf47ffc88aa174995add08f4cbe16924d5664a9" translate="yes" xml:space="preserve">
          <source>Here, the same tests as in Example 1 are run, but with flag &lt;code&gt;force_stop&lt;/code&gt; set to &lt;code&gt;skip_rest&lt;/code&gt;. If time-out occurs while executing tests in directory &lt;code&gt;to1&lt;/code&gt;, the remaining test cases in &lt;code&gt;to1&lt;/code&gt; are skipped and the test is aborted without running the tests in &lt;code&gt;to2&lt;/code&gt; another time. If time-out occurs while executing tests in directory &lt;code&gt;to2&lt;/code&gt;, the remaining test cases in &lt;code&gt;to2&lt;/code&gt; are skipped and the test is aborted.</source>
          <target state="translated">Aqu&amp;iacute;, se ejecutan las mismas pruebas que en el Ejemplo 1, pero con el indicador &lt;code&gt;force_stop&lt;/code&gt; establecido en &lt;code&gt;skip_rest&lt;/code&gt; . Si se agota el tiempo de espera mientras se ejecutan las pruebas en el directorio &lt;code&gt;to1&lt;/code&gt; , los casos de prueba restantes en &lt;code&gt;to1&lt;/code&gt; se omiten y la prueba se aborta sin ejecutar las pruebas en &lt;code&gt;to2&lt;/code&gt; en otro momento. Si se agota el tiempo de espera mientras se ejecutan las pruebas en el directorio &lt;code&gt;to2&lt;/code&gt; , se omiten los casos de prueba restantes en &lt;code&gt;to2&lt;/code&gt; y se cancela la prueba.</target>
        </trans-unit>
        <trans-unit id="8725eccd38a40d0e24f360a6bca5f39b565b9081" translate="yes" xml:space="preserve">
          <source>Here, the segment corresponding to the &lt;code&gt;Opts&lt;/code&gt; variable has a &lt;strong&gt;type modifier&lt;/strong&gt;, specifying that &lt;code&gt;Opts&lt;/code&gt; is to bind to a binary. All other variables have the default type equal to unsigned integer.</source>
          <target state="translated">Aqu&amp;iacute;, el segmento correspondiente a la variable &lt;code&gt;Opts&lt;/code&gt; tiene un &lt;strong&gt;modificador de tipo&lt;/strong&gt; , que especifica que &lt;code&gt;Opts&lt;/code&gt; se enlaza a un binario. Todas las dem&amp;aacute;s variables tienen el tipo predeterminado igual a entero sin signo.</target>
        </trans-unit>
        <trans-unit id="38c740b102d15d34f934831a4b2e6f07729ae300" translate="yes" xml:space="preserve">
          <source>Here, the suites in test directory &lt;code&gt;to1&lt;/code&gt;, followed by the suites in &lt;code&gt;to2&lt;/code&gt;, are executed in one test run. A time-out event occurs after 10 minutes. As long as there is time left, &lt;code&gt;Common Test&lt;/code&gt; repeats the test run (that is, starting over with test &lt;code&gt;to1&lt;/code&gt;). After time-out, &lt;code&gt;Common Test&lt;/code&gt; stops when the current job is finished (because of flag &lt;code&gt;force_stop&lt;/code&gt;). As a result, the specified test run can be aborted after test &lt;code&gt;to1&lt;/code&gt; and before test &lt;code&gt;to2&lt;/code&gt;.</source>
          <target state="translated">Aqu&amp;iacute;, los conjuntos en el directorio de prueba &lt;code&gt;to1&lt;/code&gt; , seguidos por los conjuntos en &lt;code&gt;to2&lt;/code&gt; , se ejecutan en una ejecuci&amp;oacute;n de prueba. Un evento de tiempo muerto ocurre despu&amp;eacute;s de 10 minutos. Siempre que quede tiempo, &lt;code&gt;Common Test&lt;/code&gt; repite la ejecuci&amp;oacute;n de la prueba (es decir, comienza de nuevo con la prueba &lt;code&gt;to1&lt;/code&gt; ). Despu&amp;eacute;s del tiempo de espera, &lt;code&gt;Common Test&lt;/code&gt; detiene cuando finaliza el trabajo actual (debido al indicador &lt;code&gt;force_stop&lt;/code&gt; ). Como resultado, la ejecuci&amp;oacute;n de prueba especificada se puede cancelar despu&amp;eacute;s de la prueba &lt;code&gt;to1&lt;/code&gt; y antes de la prueba &lt;code&gt;to2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f1fe1239da690637d154f58466f31d750de5a7b" translate="yes" xml:space="preserve">
          <source>Here, the test run, including both the &lt;code&gt;to1&lt;/code&gt; and the &lt;code&gt;to2&lt;/code&gt; test, is repeated five times.</source>
          <target state="translated">Aqu&amp;iacute;, la ejecuci&amp;oacute;n de la prueba, incluidas las pruebas &lt;code&gt;to1&lt;/code&gt; y &lt;code&gt;to2&lt;/code&gt; , se repite cinco veces.</target>
        </trans-unit>
        <trans-unit id="52a7e5fe849b80f2c39e4eb11c178f9187a0c7ff" translate="yes" xml:space="preserve">
          <source>Here, the tests specified by &quot;ts1&quot; run first, then the tests specified by &quot;ts2&quot;, and finally the tests specified by both &quot;ts3&quot; and &quot;ts4&quot;.</source>
          <target state="translated">Aquí se ejecutan primero las pruebas especificadas por &quot;ts1&quot;,luego las pruebas especificadas por &quot;ts2&quot;,y finalmente las pruebas especificadas tanto por &quot;ts3&quot; como por &quot;ts4&quot;.</target>
        </trans-unit>
        <trans-unit id="872d6af667b9983eb38e96eba5f3443d21c88017" translate="yes" xml:space="preserve">
          <source>Here, the variable &lt;code&gt;X&lt;/code&gt;, defined in the head of the fun, is a new variable. The variable &lt;code&gt;Stream&lt;/code&gt;, which is used within the fun, gets its value from the &lt;code&gt;file:open&lt;/code&gt; line.</source>
          <target state="translated">Aqu&amp;iacute;, la variable &lt;code&gt;X&lt;/code&gt; , definida en el encabezado de la diversi&amp;oacute;n, es una nueva variable. La variable &lt;code&gt;Stream&lt;/code&gt; , que se utiliza dentro de la diversi&amp;oacute;n, obtiene su valor del &lt;code&gt;file:open&lt;/code&gt; l&amp;iacute;nea abierta .</target>
        </trans-unit>
        <trans-unit id="7e0c04fa994ff203608b787f3eac3297ddf1fb91" translate="yes" xml:space="preserve">
          <source>Here, white text is used instead of the default black for &lt;code&gt;div.error&lt;/code&gt; printouts (and no other attribute settings for &lt;code&gt;pre&lt;/code&gt; are affected).</source>
          <target state="translated">Aqu&amp;iacute;, se usa texto blanco en lugar del negro predeterminado para &lt;code&gt;div.error&lt;/code&gt; impresiones de error div (y no se ven afectadas otras configuraciones de atributos para &lt;code&gt;pre&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="714626a23a6977a3ba1a4332c0cb63aa0f04303b" translate="yes" xml:space="preserve">
          <source>Here,&lt;code&gt;ERL_NIF_INIT&lt;/code&gt; has the following arguments:</source>
          <target state="translated">Aqu&amp;iacute;, &lt;code&gt;ERL_NIF_INIT&lt;/code&gt; tiene los siguientes argumentos:</target>
        </trans-unit>
        <trans-unit id="a1e31a79ba26a76d28a87c7ed0407b897f88b5e6" translate="yes" xml:space="preserve">
          <source>Here:</source>
          <target state="translated">Here:</target>
        </trans-unit>
        <trans-unit id="ad89343a3d3c4ba891ac4b0730bfade95df05420" translate="yes" xml:space="preserve">
          <source>Heuristic Identification of UTF-8</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d3b73d033962cbf0bbbb6396f3106e5fadd47c5" translate="yes" xml:space="preserve">
          <source>Heuristic String Detection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e6e39c49e52c38684133449dae27a843c8c9f66" translate="yes" xml:space="preserve">
          <source>Hexadecimal digits</source>
          <target state="translated">Hexadecimal digits</target>
        </trans-unit>
        <trans-unit id="01a101ab62a2560ab10ccb525aa4aba316d01a17" translate="yes" xml:space="preserve">
          <source>HiPE is automatically enabled on the following systems:</source>
          <target state="translated">El HiPE se activa automáticamente en los siguientes sistemas:</target>
        </trans-unit>
        <trans-unit id="49e76954bbaf300a103840561af720f16c024018" translate="yes" xml:space="preserve">
          <source>HiPE supports the following system configurations:</source>
          <target state="translated">El HiPE soporta las siguientes configuraciones del sistema:</target>
        </trans-unit>
        <trans-unit id="c5263066d763fc26b746c69fd8481a0f61325e1a" translate="yes" xml:space="preserve">
          <source>Hide menu:</source>
          <target state="translated">Ocultar el menú:</target>
        </trans-unit>
        <trans-unit id="a02b1f8d870b852383550616297df9f10e5bc8ba" translate="yes" xml:space="preserve">
          <source>High fault tolerance</source>
          <target state="translated">Alta tolerancia a las fallas</target>
        </trans-unit>
        <trans-unit id="fb49d95db3dc9749450850f23cb259dfa334590a" translate="yes" xml:space="preserve">
          <source>High-Level Instructions</source>
          <target state="translated">Instrucciones de alto nivel</target>
        </trans-unit>
        <trans-unit id="e5a92cb9a3146c86050022c2169e16055f62bf41" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7116b5f034f81df6881fb6c021d526c89a62a5d" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt; resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt; accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt; precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="322a5670551101a31a0c53538057253089ee212f" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS monotonic time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; aligns with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; m&amp;aacute;s alta posible de la fuente de tiempo mon&amp;oacute;tona del sistema operativo actual como partes por segundo. Si no se puede recuperar informaci&amp;oacute;n de resoluci&amp;oacute;n del sistema operativo, &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; se establece en la resoluci&amp;oacute;n de la unidad de tiempo del valor de retorno de la &lt;code&gt;Function&lt;/code&gt; . Es decir, la resoluci&amp;oacute;n real puede ser menor que &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; . Tenga en cuenta que la resoluci&amp;oacute;n no dice nada sobre la &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; o si la &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; alinea con la resoluci&amp;oacute;n. Sin embargo, sabe que la precisi&amp;oacute;n no es mejor que &lt;code&gt;OsMonotonicTimeResolution&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fab9cfbcb573ef66eead85a0dd57991922c30f3e" translate="yes" xml:space="preserve">
          <source>Highest possible &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; of current OS system time source as parts per second. If no resolution information can be retrieved from the OS, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; is set to the resolution of the time unit of &lt;code&gt;Function&lt;/code&gt;s return value. That is, the actual resolution can be lower than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;. Notice that the resolution does not say anything about the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; or whether the &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; do align with the resolution. You do, however, know that the precision is not better than &lt;code&gt;OsSystemTimeResolution&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;&lt;a href=&quot;time_correction#Time_Resolution&quot;&gt;resolution&lt;/a&gt;&lt;/code&gt; m&amp;aacute;s alta posible de la fuente de tiempo del sistema operativo actual en partes por segundo. Si no se puede recuperar informaci&amp;oacute;n de resoluci&amp;oacute;n del sistema operativo, &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; se establece en la resoluci&amp;oacute;n de la unidad de tiempo del valor de retorno de la &lt;code&gt;Function&lt;/code&gt; . Es decir, la resoluci&amp;oacute;n real puede ser menor que &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; . Tenga en cuenta que la resoluci&amp;oacute;n no dice nada sobre la &lt;code&gt;&lt;a href=&quot;time_correction#Time_Accuracy&quot;&gt;accuracy&lt;/a&gt;&lt;/code&gt; o si la &lt;code&gt;&lt;a href=&quot;time_correction#Time_Precision&quot;&gt;precision&lt;/a&gt;&lt;/code&gt; alinea con la resoluci&amp;oacute;n. Sin embargo, sabe que la precisi&amp;oacute;n no es mejor que &lt;code&gt;OsSystemTimeResolution&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ba1d0a643c81d860412a884b89435cac1cf023d7" translate="yes" xml:space="preserve">
          <source>Hiragana</source>
          <target state="translated">Hiragana</target>
        </trans-unit>
        <trans-unit id="b5e5ac0463ba83ccbf0cfb19cb8721b646cc77b2" translate="yes" xml:space="preserve">
          <source>Hmac functions - &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Funciones de Hmac: codificaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc2104.txt&quot;&gt; Keyed-Hashing for Message Authentication (RFC 2104) &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="70f8bb9a8a5393ef080507a89e4b98d139000d65" translate="yes" xml:space="preserve">
          <source>Home</source>
          <target state="translated">Home</target>
        </trans-unit>
        <trans-unit id="e62704259a03fb1bde2c8d41669196ad51d0310c" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; can be used to change the &lt;code&gt;cth_conn_log&lt;/code&gt; behavior. The default value of this option is &lt;code&gt;raw&lt;/code&gt;, which results in the behavior described above. If the value is set to &lt;code&gt;html&lt;/code&gt;, all Telnet communication is printed to the test case HTML log instead.</source>
          <target state="translated">La opci&amp;oacute;n de gancho &lt;code&gt;log_type&lt;/code&gt; se puede utilizar para cambiar el comportamiento de &lt;code&gt;cth_conn_log&lt;/code&gt; . El valor predeterminado de esta opci&amp;oacute;n es sin &lt;code&gt;raw&lt;/code&gt; , lo que da como resultado el comportamiento descrito anteriormente. Si el valor se establece en &lt;code&gt;html&lt;/code&gt; , toda la comunicaci&amp;oacute;n Telnet se imprime en el registro HTML del caso de prueba.</target>
        </trans-unit>
        <trans-unit id="e16590a1a84c1baec0f43c0dcc1d470ab6fb6020" translate="yes" xml:space="preserve">
          <source>Hook option &lt;code&gt;log_type&lt;/code&gt; specifies the type of logging:</source>
          <target state="translated">La opci&amp;oacute;n de gancho &lt;code&gt;log_type&lt;/code&gt; especifica el tipo de registro:</target>
        </trans-unit>
        <trans-unit id="2b7ba976df46f73b2bc0332579201ada04d174eb" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite any hard-coded hook options in the test suite.</source>
          <target state="translated">Las opciones de gancho especificadas en un archivo de configuración sobrescriben cualquier opción de gancho codificada en el paquete de pruebas.</target>
        </trans-unit>
        <trans-unit id="e5130a72c3ee4bac41361eafe24a09e720b6ee4d" translate="yes" xml:space="preserve">
          <source>Hook options specified in a configuration file overwrite the hard-coded hook options in the test suite.</source>
          <target state="translated">Las opciones de gancho especificadas en un archivo de configuración sobrescriben las opciones de gancho codificadas en el paquete de pruebas.</target>
        </trans-unit>
        <trans-unit id="5699a47d64ec5afff9a00f44aa11f36f6b5577a8" translate="yes" xml:space="preserve">
          <source>Hop-by-Hop and End-to-End Identifiers are set by diameter when sending outgoing requests.</source>
          <target state="translated">Los identificadores &quot;Hop-by-Hop&quot; y &quot;End-to-End&quot; se fijan por el diámetro al enviar las solicitudes salientes.</target>
        </trans-unit>
        <trans-unit id="b856160c3f11849f763958bfca750f4da4f8b030" translate="yes" xml:space="preserve">
          <source>Horizontal tab (HT)</source>
          <target state="translated">Pestaña horizontal (HT)</target>
        </trans-unit>
        <trans-unit id="de7f8e30d370dbed377d6f3ec1e0f3638d8f7cd7" translate="yes" xml:space="preserve">
          <source>Host :: string(),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="288369442ce4af9ee861578e5997944104806d11" translate="yes" xml:space="preserve">
          <source>Host = &lt;code&gt;string() | ip_address()&lt;/code&gt;</source>
          <target state="translated">Anfitri&amp;oacute;n = &lt;code&gt;string() | ip_address()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c0506d8d8a9c994a9c2061822e71fa219eaa60fb" translate="yes" xml:space="preserve">
          <source>Host is not found, FTP server is not found, or connection is rejected by FTP server.</source>
          <target state="translated">No se encuentra el host,no se encuentra el servidor FTP o la conexión es rechazada por el servidor FTP.</target>
        </trans-unit>
        <trans-unit id="19cf18d3bb45fb6c52bc7c972db763badac874f9" translate="yes" xml:space="preserve">
          <source>Host key algorithm.</source>
          <target state="translated">Algoritmo de la clave del anfitrión.</target>
        </trans-unit>
        <trans-unit id="072282c1e2f294945717832e050c84248cb48a99" translate="yes" xml:space="preserve">
          <source>Host key(s)</source>
          <target state="translated">Clave(s)de anfitrión</target>
        </trans-unit>
        <trans-unit id="addc5b9c7be01cab649badaad9fe245dd85b99a6" translate="yes" xml:space="preserve">
          <source>Host public key(s)</source>
          <target state="translated">Clave(s)pública(s)del anfitrión</target>
        </trans-unit>
        <trans-unit id="8dea1bfa3d5f782d439b94a2dc9e26fd4b92b4b3" translate="yes" xml:space="preserve">
          <source>Host,</source>
          <target state="translated">Host,</target>
        </trans-unit>
        <trans-unit id="22d5d7183ae1bff52681fe92c469a1efdf2db570" translate="yes" xml:space="preserve">
          <source>Host-IP-Address AVP</source>
          <target state="translated">Dirección IP del anfitrión AVP</target>
        </trans-unit>
        <trans-unit id="1db3d3092adcf5851af85b54fd2dcaa3d13b20b7" translate="yes" xml:space="preserve">
          <source>Hostname extraction</source>
          <target state="translated">Extracción del nombre del anfitrión</target>
        </trans-unit>
        <trans-unit id="cc902a2f4f94e0590cff3fb32bacd18c59026842" translate="yes" xml:space="preserve">
          <source>Hostname is the result of calling net_adm:localhost() in the Erlang node where this funcion is called.</source>
          <target state="translated">El nombre del host es el resultado de llamar a net_adm:localhost()en el nodo Erlang donde se llama esta función.</target>
        </trans-unit>
        <trans-unit id="e41e038a1831d791d3fb46209bc95e438998e2ba" translate="yes" xml:space="preserve">
          <source>Hostname of the node, &lt;code&gt;host&lt;/code&gt;</source>
          <target state="translated">Nombre de host del nodo, &lt;code&gt;host&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="abd2f083d046f4cdd3824b5ac6815216f33f9d44" translate="yes" xml:space="preserve">
          <source>Hostnames and host addresses</source>
          <target state="translated">Nombres y direcciones de hospedaje</target>
        </trans-unit>
        <trans-unit id="acf387fac0d70500029ecc75aef45e78a2439ddf" translate="yes" xml:space="preserve">
          <source>How categories can be mapped to CSS tags is documented in section &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; in section Running Tests and Analyzing Results.</source>
          <target state="translated">La forma en que las categor&amp;iacute;as se pueden asignar a las etiquetas CSS se documenta en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;run_test_chapter#html_stylesheet&quot;&gt;HTML Style Sheets&lt;/a&gt;&lt;/code&gt; en la secci&amp;oacute;n Ejecuci&amp;oacute;n de pruebas y an&amp;aacute;lisis de resultados.</target>
        </trans-unit>
        <trans-unit id="4591aaae8b0152f47a2818f3eda6105fd1deb44b" translate="yes" xml:space="preserve">
          <source>How code is compiled and loaded is not a language issue, but is system-dependent. This section describes compilation and code loading in Erlang/OTP with references to relevant parts of the documentation.</source>
          <target state="translated">La forma en que se compila y se carga el código no es una cuestión de lenguaje,sino que depende del sistema.Esta sección describe la compilación y la carga del código en Erlang/OTP con referencias a las partes relevantes de la documentación.</target>
        </trans-unit>
        <trans-unit id="15c87cc7450111c7682bfcb2fe07b8147a9660ab" translate="yes" xml:space="preserve">
          <source>How long Erlang needs to be inactive before output is preceded with a time stamp. Defaults to &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt;, minimum is 1.</source>
          <target state="translated">Cu&amp;aacute;nto tiempo Erlang debe estar inactivo antes de que la salida est&amp;eacute; precedida por una marca de tiempo. El valor predeterminado es &lt;code&gt;RUN_ERL_LOG_ALIVE_MINUTES div 3&lt;/code&gt; , el m&amp;iacute;nimo es 1.</target>
        </trans-unit>
        <trans-unit id="f7148ef82d3951a0ef8aeff5732b56bd65e5d5a7" translate="yes" xml:space="preserve">
          <source>How long to wait for output (in minutes) before writing an &quot;ALIVE&quot; message to the log. Defaults to 15, minimum is 1.</source>
          <target state="translated">Cuánto tiempo hay que esperar a la salida (en minutos)antes de escribir un mensaje &quot;VIVO&quot; en el registro.Por defecto es 15,el mínimo es 1.</target>
        </trans-unit>
        <trans-unit id="1a8eccc781fb3d6e08ed9cc46cafd132607b31bb" translate="yes" xml:space="preserve">
          <source>How many bytes that are read (received) from the socket, used in similar ways as &lt;code&gt;sent&lt;/code&gt;.</source>
          <target state="translated">Cu&amp;aacute;ntos bytes que se leen (reciben) desde el socket, usados ​​de manera similar a como se &lt;code&gt;sent&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2063d1711356aa5cf80622e43bafe411dc016ccf" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29f341bd6607eedd11420fecb92a331dcfda1889" translate="yes" xml:space="preserve">
          <source>How many bytes that have been sent over the socket. This can wrap, but that is no problem for the distribution, as the Erlang distribution is only interested in if this value has changed. (The Erlang &lt;code&gt;net_kernel&lt;/code&gt;&lt;code&gt;ticker&lt;/code&gt; uses this value by calling the driver to fetch it, which is done through the &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; routine.)</source>
          <target state="translated">Cu&amp;aacute;ntos bytes se han enviado a trav&amp;eacute;s del socket. Esto se puede ajustar, pero eso no es un problema para la distribuci&amp;oacute;n, ya que a la distribuci&amp;oacute;n de Erlang solo le interesa si este valor ha cambiado. (El &lt;code&gt;ticker&lt;/code&gt; de Erlang &lt;code&gt;net_kernel&lt;/code&gt; usa este valor llamando al controlador para buscarlo, lo cual se hace a trav&amp;eacute;s de la &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f7085d139029fad5626d71df4a69c37165c0004" translate="yes" xml:space="preserve">
          <source>How schedulers are bound matters. For example, in situations when there are fewer running processes than schedulers online, the runtime system tries to migrate processes to schedulers with low scheduler identifiers. The more the schedulers are spread over the hardware, the more resources are available to the runtime system in such situations.</source>
          <target state="translated">La forma en que los planificadores están vinculados es importante.Por ejemplo,en situaciones en las que hay menos procesos en ejecución que programadores en línea,el sistema en tiempo de ejecución intenta migrar los procesos a los programadores con bajos identificadores de programador.Cuanto más se distribuyan los programadores por el hardware,más recursos estarán disponibles para el sistema en tiempo de ejecución en tales situaciones.</target>
        </trans-unit>
        <trans-unit id="22fb0d06b90905c411643c4b8d63177262432872" translate="yes" xml:space="preserve">
          <source>How the different levels of configuration &quot;interfer&quot; with this, see the section &lt;code&gt;&lt;a href=&quot;configurations#algorithm-configuration&quot;&gt;Algorithm Configuration&lt;/a&gt;&lt;/code&gt; in the chapter &lt;code&gt;&lt;a href=&quot;configurations&quot;&gt;Configuration in SSH&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20136af8c4b0c2e0978139eaccb368f03d6d08f3" translate="yes" xml:space="preserve">
          <source>How to Build a Debug Enabled Erlang RunTime System</source>
          <target state="translated">Cómo construir un sistema de tiempo de ejecución Erlang habilitado para depuración</target>
        </trans-unit>
        <trans-unit id="d0e7345d074a8ac083420a87f267a9efe5441d6f" translate="yes" xml:space="preserve">
          <source>How to Work with the New API</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c9e65c5426cc2af60f611bbcd0bef6a2d2545ba" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt; Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c1dadaae2a29663af54cb6cd0c08758049e535" translate="yes" xml:space="preserve">
          <source>How to communicate with the outside world and software written in other languages (ports); this is described in &lt;code&gt;Interoperability Tutorial&lt;/code&gt;.</source>
          <target state="translated">C&amp;oacute;mo comunicarse con el mundo exterior y software escrito en otros idiomas (puertos); esto se describe en el &lt;code&gt;Interoperability Tutorial&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5c10a361408710884679a3441fc66b438898423" translate="yes" xml:space="preserve">
          <source>How to deal with errors in the Message Length field of the Diameter Header in an incoming message. An error in this context is that the length is not at least 20 bytes (the length of a Header), is not a multiple of 4 (a valid length) or is not the length of the message in question, as received over the transport interface documented in &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">C&amp;oacute;mo tratar los errores en el campo Longitud del mensaje del Encabezado de di&amp;aacute;metro en un mensaje entrante. Un error en este contexto es que la longitud no es de al menos 20 bytes (la longitud de un encabezado), no es un m&amp;uacute;ltiplo de 4 (una longitud v&amp;aacute;lida) o no es la longitud del mensaje en cuesti&amp;oacute;n, tal como se recibe a trav&amp;eacute;s del transporte. interfaz documentada en &lt;code&gt;&lt;a href=&quot;diameter_transport&quot;&gt;diameter_transport(3)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ccbdf00e07b9b9e2844d8c343abd36e9a64cbb60" translate="yes" xml:space="preserve">
          <source>How to install a release in a target environment is described in the section about target systems in Section 2 System Principles.</source>
          <target state="translated">La forma de instalar una liberación en un entorno de destino se describe en la sección sobre sistemas de destino de la Sección 2 Principios del sistema.</target>
        </trans-unit>
        <trans-unit id="a8aa9d6c524adcbf7e604a1f12ced88b214a5951" translate="yes" xml:space="preserve">
          <source>How to program applications is described in &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La forma de programar aplicaciones se describe en &lt;code&gt;&lt;a href=&quot;applications&quot;&gt;Applications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="276dc4ca7f730347d6af07741689ad055269eecd" translate="yes" xml:space="preserve">
          <source>How to program releases is described in &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La forma de programar lanzamientos se describe en &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b4b3d991be0d0efdd7895d65ece3d2af255f1d4" translate="yes" xml:space="preserve">
          <source>How to send a trap by sending the &lt;code&gt;fTrap&lt;/code&gt; from the master agent is shown in this section. The master agent has the MIB &lt;code&gt;EX1-MIB&lt;/code&gt; loaded, where the trap is defined. This trap specifies that two variables should be sent along with the trap, &lt;code&gt;myName&lt;/code&gt; and &lt;code&gt;fIndex&lt;/code&gt;. &lt;code&gt;fIndex&lt;/code&gt; is a table column, so we must provide its value and the index for the row in the call to &lt;code&gt;snmpa:send_trap/4&lt;/code&gt;. In the example below, we assume that the row in question is indexed by 2 (the row with &lt;code&gt;fIndex&lt;/code&gt; 2).</source>
          <target state="translated">En esta secci&amp;oacute;n se muestra c&amp;oacute;mo enviar una trampa enviando el &lt;code&gt;fTrap&lt;/code&gt; desde el agente maestro. El agente maestro tiene el MIB &lt;code&gt;EX1-MIB&lt;/code&gt; cargado, donde se define la trampa. Esta trampa especifica que se deben enviar dos variables junto con la trampa, &lt;code&gt;myName&lt;/code&gt; y &lt;code&gt;fIndex&lt;/code&gt; . &lt;code&gt;fIndex&lt;/code&gt; es una columna de tabla, por lo que debemos proporcionar su valor y el &amp;iacute;ndice de la fila en la llamada a &lt;code&gt;snmpa:send_trap/4&lt;/code&gt; . En el siguiente ejemplo, asumimos que la fila en cuesti&amp;oacute;n est&amp;aacute; indexada por 2 (la fila con &lt;code&gt;fIndex&lt;/code&gt; 2).</target>
        </trans-unit>
        <trans-unit id="cd51a27fca892f8fff8444cd28b8146e7bbe5364" translate="yes" xml:space="preserve">
          <source>How to start and stop the code for the application, that is, the supervision tree, is described by two callback functions:</source>
          <target state="translated">La forma de iniciar y detener el código de la aplicación,es decir,el árbol de supervisión,se describe mediante dos funciones de devolución de llamada:</target>
        </trans-unit>
        <trans-unit id="41bdc386e84c42a60e9c78fd7063eb79494fd670" translate="yes" xml:space="preserve">
          <source>How to write &lt;code&gt;d&lt;/code&gt; programs or &lt;code&gt;systemtap&lt;/code&gt; scripts can be learned from books and from a lot of pages on the Internet. This manual page does not include any documentation about using the dynamic trace tools of respective platform. The &lt;code&gt;examples&lt;/code&gt; directory of the &lt;code&gt;runtime_tools&lt;/code&gt; application however contains comprehensive examples of both &lt;code&gt;d&lt;/code&gt; and &lt;code&gt;systemtap&lt;/code&gt; programs that will help you get started. Another source of information is the &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; chapters in the Runtime Tools Users' Guide.</source>
          <target state="translated">Se puede aprender a escribir programas &lt;code&gt;d&lt;/code&gt; o scripts &lt;code&gt;systemtap&lt;/code&gt; en libros y en muchas p&amp;aacute;ginas de Internet. Esta p&amp;aacute;gina de manual no incluye ninguna documentaci&amp;oacute;n sobre el uso de las herramientas de seguimiento din&amp;aacute;mico de la plataforma respectiva. La &lt;code&gt;examples&lt;/code&gt; directorio del &lt;code&gt;runtime_tools&lt;/code&gt; aplicaci&amp;oacute;n embargo contiene ejemplos completos de ambos &lt;code&gt;d&lt;/code&gt; e &lt;code&gt;systemtap&lt;/code&gt; programas que le ayudar&amp;aacute;n a empezar. Otra fuente de informaci&amp;oacute;n son los cap&amp;iacute;tulos &lt;code&gt;&lt;a href=&quot;dtrace&quot;&gt;dtrace&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;systemtap&quot;&gt;systemtap&lt;/a&gt;&lt;/code&gt; en la Gu&amp;iacute;a del usuario de Runtime Tools.</target>
        </trans-unit>
        <trans-unit id="0838c6817793504aa13c17409bac1788b9b01886" translate="yes" xml:space="preserve">
          <source>However, NTP is not fail-safe. The NTP server can be unavailable, &lt;code&gt;ntp.conf&lt;/code&gt; can be wrongly configured, or your computer can sometimes be disconnected from Internet. Furthermore, you can have a user (or even system administrator) who thinks the correct way to handle Daylight Saving Time is to adjust the clock one hour two times a year (which is the incorrect way to do it). To complicate things further, this user fetched your software from Internet and has not considered what the correct time is as perceived by a computer. The user does not care about keeping the wall clock in sync with the correct time. The user expects your program to have unlimited knowledge about the time.</source>
          <target state="translated">Sin embargo, NTP no es seguro. El servidor NTP puede no estar disponible, &lt;code&gt;ntp.conf&lt;/code&gt; puede estar configurado incorrectamente o su computadora a veces puede desconectarse de Internet. Adem&amp;aacute;s, puede tener un usuario (o incluso un administrador del sistema) que piense que la forma correcta de manejar el horario de verano es ajustar el reloj una hora dos veces al a&amp;ntilde;o (que es la forma incorrecta de hacerlo). Para complicar a&amp;uacute;n m&amp;aacute;s las cosas, este usuario obtuvo su software de Internet y no ha considerado cu&amp;aacute;l es la hora correcta seg&amp;uacute;n la percibe una computadora. Al usuario no le importa mantener el reloj de pared sincronizado con la hora correcta. El usuario espera que su programa tenga un conocimiento ilimitado sobre la hora.</target>
        </trans-unit>
        <trans-unit id="1d1ccf19c7bc531f33d5809c585dc1826e4637e4" translate="yes" xml:space="preserve">
          <source>However, a node started in this way refuses to talk to other nodes, as no TLS parameters are supplied (see the next section).</source>
          <target state="translated">Sin embargo,un nodo iniciado de esta manera se niega a hablar con otros nodos,ya que no se suministran parámetros TLS (véase la siguiente sección).</target>
        </trans-unit>
        <trans-unit id="b227076a401b39e896ee55916a33ca73c07f48da" translate="yes" xml:space="preserve">
          <source>However, bit strings that are not whole bytes are not allowed, so a UTF character must be split along 8-bit boundaries to ever be decoded.</source>
          <target state="translated">Sin embargo,las cadenas de bits que no son bytes enteros no están permitidas,por lo que un carácter UTF debe ser dividido a lo largo de los límites de 8 bits para poder ser decodificado.</target>
        </trans-unit>
        <trans-unit id="8ea8d93f3410c8633f2cc78f1bbe03d8844b4ed7" translate="yes" xml:space="preserve">
          <source>However, certificates can also be decoded using &lt;code&gt;pkix_decode_cert/2&lt;/code&gt;, which can customize and recursively decode standard parts of a certificate:</source>
          <target state="translated">Sin embargo, los certificados tambi&amp;eacute;n se pueden decodificar usando &lt;code&gt;pkix_decode_cert/2&lt;/code&gt; , que puede personalizar y decodificar de forma recursiva partes est&amp;aacute;ndar de un certificado:</target>
        </trans-unit>
        <trans-unit id="0c4ccce2e74bd8ac8ec245b1dfb747183f0ffc13" translate="yes" xml:space="preserve">
          <source>However, escaping other non-alphanumeric characters does no harm.</source>
          <target state="translated">Sin embargo,escapar de otros personajes no alfanuméricos no hace daño.</target>
        </trans-unit>
        <trans-unit id="46e5131246ec14a5499a18be55e9b7179d7c9b66" translate="yes" xml:space="preserve">
          <source>However, for a value of type &lt;code&gt;SET OF&lt;/code&gt;, the DER encoding format requires the elements to be sent in ascending order of their encoding, which implies an expensive sorting procedure in runtime. Therefore it is recommended to use &lt;code&gt;SEQUENCE OF&lt;/code&gt; instead of &lt;code&gt;SET OF&lt;/code&gt; if possible.</source>
          <target state="translated">Sin embargo, para un valor de tipo &lt;code&gt;SET OF&lt;/code&gt; , el formato de codificaci&amp;oacute;n DER requiere que los elementos se env&amp;iacute;en en orden ascendente de su codificaci&amp;oacute;n, lo que implica un costoso procedimiento de clasificaci&amp;oacute;n en tiempo de ejecuci&amp;oacute;n. Por lo tanto, se recomienda utilizar &lt;code&gt;SEQUENCE OF&lt;/code&gt; en lugar de &lt;code&gt;SET OF&lt;/code&gt; si es posible.</target>
        </trans-unit>
        <trans-unit id="bc244468b711f7696ac604f858e8d4fc9b46e19b" translate="yes" xml:space="preserve">
          <source>However, here you will find some examples of how to use and to what you can use xmerl. A detailed description of the user interface can be found in the reference manual.</source>
          <target state="translated">Sin embargo,aquí encontrará algunos ejemplos de cómo y a qué puede recurrir xmerl.Una descripción detallada de la interfaz de usuario se puede encontrar en el manual de referencia.</target>
        </trans-unit>
        <trans-unit id="0b9d56ea76c3544f39f6889a33eb80d1c637ad55" translate="yes" xml:space="preserve">
          <source>However, if &lt;code&gt;cp1&lt;/code&gt; also restarts, the function &lt;code&gt;application:takeover/2&lt;/code&gt; moves &lt;code&gt;myapp&lt;/code&gt; to &lt;code&gt;cp1&lt;/code&gt;, as &lt;code&gt;cp1&lt;/code&gt; has a higher priority than &lt;code&gt;cp3&lt;/code&gt; for this application. In this case, &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; is executed at &lt;code&gt;cp1&lt;/code&gt; to start the application.</source>
          <target state="translated">Sin embargo, si &lt;code&gt;cp1&lt;/code&gt; tambi&amp;eacute;n se reinicia, la &lt;code&gt;application:takeover/2&lt;/code&gt; funci&amp;oacute;n : takeover / 2 mueve &lt;code&gt;myapp&lt;/code&gt; a &lt;code&gt;cp1&lt;/code&gt; , ya que &lt;code&gt;cp1&lt;/code&gt; tiene una prioridad m&amp;aacute;s alta que &lt;code&gt;cp3&lt;/code&gt; para esta aplicaci&amp;oacute;n. En este caso, &lt;code&gt;Module:start({takeover, cp3@cave}, StartArgs)&lt;/code&gt; se ejecuta en &lt;code&gt;cp1&lt;/code&gt; para iniciar la aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d56d68a6f8912b74bb9d4335dc57800fe8ebb077" translate="yes" xml:space="preserve">
          <source>However, if a quantifier is followed by a question mark, it ceases to be greedy, and instead matches the minimum number of times possible, so the following pattern does the right thing with the C comments:</source>
          <target state="translated">Sin embargo,si un cuantificador va seguido de un signo de interrogación,deja de ser codicioso y,en cambio,coincide con el mínimo número de veces posible,por lo que el siguiente patrón hace lo correcto con los comentarios de la C:</target>
        </trans-unit>
        <trans-unit id="263a65ad8dda64685d084610e95a9d4761d42dff" translate="yes" xml:space="preserve">
          <source>However, if another process has the driver loaded, calling &lt;code&gt;reload_driver&lt;/code&gt; returns error code &lt;code&gt;pending_process&lt;/code&gt;. As stated earlier, the recommended design is to not allow other &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; than the &quot;driver reloader&quot; to demand loading of the driver in question.</source>
          <target state="translated">Sin embargo, si otro proceso tiene el controlador cargado, llamar a &lt;code&gt;reload_driver&lt;/code&gt; devuelve un c&amp;oacute;digo de error &lt;code&gt;pending_process&lt;/code&gt; . Como se indic&amp;oacute; anteriormente, el dise&amp;ntilde;o recomendado es no permitir que otros &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; que no sean el &quot;cargador de controladores&quot; exijan la carga del controlador en cuesti&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fdd9ab210aada3daba577507d301fd6bfe3e97ab" translate="yes" xml:space="preserve">
          <source>However, if the decimal number following the backslash is &amp;lt; 10, it is always taken as a back reference, and causes an error only if there are not that many capturing left parentheses in the entire pattern. That is, the parentheses that are referenced do need not be to the left of the reference for numbers &amp;lt; 10. A &quot;forward back reference&quot; of this type can make sense when a repetition is involved and the subpattern to the right has participated in an earlier iteration.</source>
          <target state="translated">Sin embargo, si el n&amp;uacute;mero decimal que sigue a la barra invertida es &amp;lt;10, siempre se toma como una referencia inversa y provoca un error solo si no hay tantos par&amp;eacute;ntesis izquierdos de captura en todo el patr&amp;oacute;n. Es decir, los par&amp;eacute;ntesis a los que se hace referencia no necesitan estar a la izquierda de la referencia para los n&amp;uacute;meros &amp;lt;10. Una &quot;referencia hacia adelante y hacia atr&amp;aacute;s&quot; de este tipo puede tener sentido cuando se trata de una repetici&amp;oacute;n y el subpatr&amp;oacute;n de la derecha ha participado en una iteraci&amp;oacute;n anterior.</target>
        </trans-unit>
        <trans-unit id="2a812868f08ecc593ae34f24cb42a6aa95624434" translate="yes" xml:space="preserve">
          <source>However, if the first pattern does not match, the second pattern is tested. If this matches, the message is removed from the queue and the actions corresponding to the second pattern are executed. If the second pattern does not match, the third is tried and so on until there are no more patterns to test. If there are no more patterns to test, the first message is kept in the queue and the second message is tried instead. If this matches any pattern, the appropriate actions are executed and the second message is removed from the queue (keeping the first message and any other messages in the queue). If the second message does not match, the third message is tried, and so on, until the end of the queue is reached. If the end of the queue is reached, the process blocks (stops execution) and waits until a new message is received and this procedure is repeated.</source>
          <target state="translated">Sin embargo,si el primer patrón no coincide,se prueba el segundo patrón.Si coincide,se elimina el mensaje de la cola y se ejecutan las acciones correspondientes al segundo patrón.Si el segundo patrón no coincide,se prueba el tercero y así sucesivamente hasta que no haya más patrones que probar.Si no hay más patrones que probar,el primer mensaje se mantiene en la cola y en su lugar se prueba el segundo mensaje.Si esto coincide con algún patrón,se ejecutan las acciones apropiadas y se elimina el segundo mensaje de la cola (manteniendo el primer mensaje y cualquier otro mensaje en la cola).Si el segundo mensaje no coincide,se intenta con el tercer mensaje,y así sucesivamente,hasta llegar al final de la cola.Si se llega al final de la cola,el proceso se bloquea (detiene la ejecución)y espera hasta que se recibe un nuevo mensaje y se repite este procedimiento.</target>
        </trans-unit>
        <trans-unit id="24786ae2162520de2c90e9e1d62681cc611c7770" translate="yes" xml:space="preserve">
          <source>However, if the input &lt;code&gt;Data&lt;/code&gt; is a pure binary, the third part of the error tuple is guaranteed to be a binary as well.</source>
          <target state="translated">Sin embargo, si los &lt;code&gt;Data&lt;/code&gt; entrada son binarios puros, se garantiza que la tercera parte de la tupla de error tambi&amp;eacute;n ser&amp;aacute; binaria.</target>
        </trans-unit>
        <trans-unit id="16d0a6fc945512ce80fc9d4797b016ad95bcce03" translate="yes" xml:space="preserve">
          <source>However, if the table is created with an explicit record name as argument, as shown in the following example, subscriber records can be stored in both of the tables regardless of the table names:</source>
          <target state="translated">Sin embargo,si la tabla se crea con un nombre de registro explícito como argumento,como se muestra en el siguiente ejemplo,los registros de los abonados pueden almacenarse en ambas tablas independientemente de los nombres de las mismas:</target>
        </trans-unit>
        <trans-unit id="1b7421b4ed5e29d178756408b1fb811393c80202" translate="yes" xml:space="preserve">
          <source>However, if this is done and a &lt;code&gt;relup&lt;/code&gt; file is generated, not only would it contain instructions for restarting (that is, removing and adding) &lt;code&gt;prim_app&lt;/code&gt;, it would also contain instructions for starting &lt;code&gt;ch_app&lt;/code&gt; (and stopping it, in the case of downgrade). This is because &lt;code&gt;ch_app&lt;/code&gt; is included in the new &lt;code&gt;.rel&lt;/code&gt; file, but not in the old one.</source>
          <target state="translated">Sin embargo, si se hace esto y se genera un archivo de &lt;code&gt;relup&lt;/code&gt; , no solo contendr&amp;iacute;a instrucciones para reiniciar (es decir, eliminar y agregar) &lt;code&gt;prim_app&lt;/code&gt; , sino que tambi&amp;eacute;n contendr&amp;iacute;a instrucciones para iniciar &lt;code&gt;ch_app&lt;/code&gt; (y detenerlo, en el caso de degradaci&amp;oacute;n) . Esto se debe a que &lt;code&gt;ch_app&lt;/code&gt; est&amp;aacute; incluido en el nuevo archivo &lt;code&gt;.rel&lt;/code&gt; , pero no en el anterior.</target>
        </trans-unit>
        <trans-unit id="88d142963f00e274bf0e73a5e3da8dd76b986238" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line do not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="671dba1e8a971cf15a413c5af3f46c832eef8168" translate="yes" xml:space="preserve">
          <source>However, if you invoke the &lt;code&gt;escript&lt;/code&gt; as follows, the contents of the first line does not matter, but it cannot contain Erlang code as it will be ignored:</source>
          <target state="translated">Sin embargo, si invoca el &lt;code&gt;escript&lt;/code&gt; de la siguiente manera, el contenido de la primera l&amp;iacute;nea no importa, pero no puede contener c&amp;oacute;digo Erlang, ya que se ignorar&amp;aacute;:</target>
        </trans-unit>
        <trans-unit id="7c6cbfad60b53ec8d8298796a95d996bcb875534" translate="yes" xml:space="preserve">
          <source>However, if you just want to change it for the current session you can also do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="733932a016243e1521c912130b4ad01ef9fa9412" translate="yes" xml:space="preserve">
          <source>However, it can also be convenient to replace variables in within a &lt;code&gt;sys.config&lt;/code&gt; on the target after unpacking but before running the release. If you have a &lt;code&gt;sys.config.src&lt;/code&gt; it will be included and is not required to be a valid Erlang term file like &lt;code&gt;sys.config&lt;/code&gt;. Before running the release you must have a valid &lt;code&gt;sys.config&lt;/code&gt; in the same directory, so using &lt;code&gt;sys.config.src&lt;/code&gt; requires having some tool to populate what is needed and write &lt;code&gt;sys.config&lt;/code&gt; to disk before booting the release.</source>
          <target state="translated">Sin embargo, tambi&amp;eacute;n puede ser conveniente reemplazar las variables dentro de un &lt;code&gt;sys.config&lt;/code&gt; en el destino despu&amp;eacute;s de desempaquetar pero antes de ejecutar la versi&amp;oacute;n. Si tiene un &lt;code&gt;sys.config.src&lt;/code&gt; , se incluir&amp;aacute; y no es necesario que sea un archivo de t&amp;eacute;rmino Erlang v&amp;aacute;lido como &lt;code&gt;sys.config&lt;/code&gt; . Antes de ejecutar la versi&amp;oacute;n, debe tener un &lt;code&gt;sys.config&lt;/code&gt; v&amp;aacute;lido en el mismo directorio, por lo que el uso de &lt;code&gt;sys.config.src&lt;/code&gt; requiere tener alguna herramienta para completar lo que se necesita y escribir &lt;code&gt;sys.config&lt;/code&gt; en el disco antes de iniciar la versi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e2548bff9e540af4d0fb0d83f010b390353ac3c3" translate="yes" xml:space="preserve">
          <source>However, it is acceptable to PCRE if rewritten to use two top-level branches:</source>
          <target state="translated">Sin embargo,es aceptable para el PCRE si se reescribe para usar dos ramas de alto nivel:</target>
        </trans-unit>
        <trans-unit id="fb5d7ab90418502bf4a66c357b3062b87e79e461" translate="yes" xml:space="preserve">
          <source>However, it is up to the tools that process the specifications to choose whether to take this extra information into account or not.</source>
          <target state="translated">Sin embargo,corresponde a las herramientas que procesan las especificaciones elegir si se tiene en cuenta o no esta información adicional.</target>
        </trans-unit>
        <trans-unit id="bfce5f1fc516ae2dd7d55f261e0b8f21a3259164" translate="yes" xml:space="preserve">
          <source>However, more dot-separated parts than this can exist. The dot-separated parts consist of non-negative integers. If all parts less significant than &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; equals &lt;code&gt;0&lt;/code&gt;, they are omitted. The three normal parts &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; are changed as follows:</source>
          <target state="translated">Sin embargo, pueden existir m&amp;aacute;s partes separadas por puntos. Las partes separadas por puntos consisten en n&amp;uacute;meros enteros no negativos. Si todas las partes menos significativas que &lt;code&gt;&amp;lt;Minor&amp;gt;&lt;/code&gt; son iguales a &lt;code&gt;0&lt;/code&gt; , se omiten. Las tres partes normales &lt;code&gt;&amp;lt;Major&amp;gt;.&amp;lt;Minor&amp;gt;.&amp;lt;Patch&amp;gt;&lt;/code&gt; se cambian de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="7df44a8a1e1ba914a7e56b28dc0791a84d52cf6e" translate="yes" xml:space="preserve">
          <source>However, no expansion is done in the following call because &lt;code&gt;{foo, false}&lt;/code&gt; shadows &lt;code&gt;foo&lt;/code&gt;:</source>
          <target state="translated">Sin embargo, no se realiza ninguna expansi&amp;oacute;n en la siguiente llamada porque &lt;code&gt;{foo, false}&lt;/code&gt; sombra a &lt;code&gt;foo&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d572d552eed7e268241fcd56330d5bd074e5ab5" translate="yes" xml:space="preserve">
          <source>However, notice that there is a risk that the database can be left in an inconsistent state if dirty operations are used to update it. Dirty operations are only to be used for performance reasons when it is absolutely necessary.</source>
          <target state="translated">Sin embargo,observe que existe el riesgo de que la base de datos se deje en un estado inconsistente si se utilizan operaciones sucias para actualizarla.Las operaciones sucias sólo se utilizarán por razones de rendimiento cuando sea absolutamente necesario.</target>
        </trans-unit>
        <trans-unit id="a529ad494df4a251bbb90b6a1eb0a32b4600b075" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes or act as a proxy filter, which sends some packets to a proxy agent and some packets to the master agent.</source>
          <target state="translated">Sin embargo,ese simple comportamiento puede ser modificado de numerosas maneras.Por ejemplo,el proceso Net if puede aplicar algún tipo de esquema de cifrado/descifrado en los bytes o actuar como un filtro proxy,que envía algunos paquetes a un agente proxy y otros paquetes al agente maestro.</target>
        </trans-unit>
        <trans-unit id="d14e5363806cde8cb157cc5a01dc9d77816a23da" translate="yes" xml:space="preserve">
          <source>However, that simple behaviour can be modified in numerous ways. For example, the Net if process can apply some kind of encrypting/decrypting scheme on the bytes.</source>
          <target state="translated">Sin embargo,ese simple comportamiento puede ser modificado de numerosas maneras.Por ejemplo,el proceso Net if puede aplicar algún tipo de esquema de encriptación/desencriptación en los bytes.</target>
        </trans-unit>
        <trans-unit id="bb8e8fcb075fb17e39be5eb5b27fd3315e7094ac" translate="yes" xml:space="preserve">
          <source>However, there are some cases where the optimization cannot be used. When .* is inside capturing parentheses that are the subject of a back reference elsewhere in the pattern, a match at the start can fail where a later one succeeds. Consider, for example:</source>
          <target state="translated">Sin embargo,hay algunos casos en los que no se puede utilizar la optimización.Cuando .*está dentro capturando paréntesis que son objeto de una referencia trasera en otra parte del patrón,una coincidencia al principio puede fallar donde una posterior tiene éxito.Consideremos,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="fa09d853f290abccb9c6e1093393c3c7791a824e" translate="yes" xml:space="preserve">
          <source>However, there is an exception. Within a macro definition, a line that starts with whitespace followed by &lt;code&gt;//|&lt;/code&gt; is treated specially. The rest of the line is assumed to contain directives to control code generation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c4528e70959d30b530219f34dfc215c6d0cefc18" translate="yes" xml:space="preserve">
          <source>However, this feature of delaying thread progress from unmanaged threads should preferably be used as little as possible, since heavy use of it will cause contention on the reference counter cache lines. The functionality is however very useful in code which normally only executes in managed threads, but which may under some infrequent circumstances be executed in other threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb1d42158bbcefd3e41b94056683aaeb566a73aa" translate="yes" xml:space="preserve">
          <source>However, this procedure can be time-consuming, the shortcut function &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; loads all the tables from disc at a faster rate. The function forces tables to be loaded from disc regardless of the network situation.</source>
          <target state="translated">Sin embargo, este procedimiento puede llevar mucho tiempo, la funci&amp;oacute;n de acceso directo &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; carga todas las tablas del disco a un ritmo m&amp;aacute;s r&amp;aacute;pido. La funci&amp;oacute;n obliga a que las tablas se carguen desde el disco independientemente de la situaci&amp;oacute;n de la red.</target>
        </trans-unit>
        <trans-unit id="7ec657f07edbe2adca75ca4efe20bdbbe6a76973" translate="yes" xml:space="preserve">
          <source>However, to avoid that old (pre R14) code changed its behavior when compiled with OTP version R14A or later, the following restriction applies: If you override the name of a BIF that was auto-imported in OTP versions prior to R14A (ERTS version 5.8) and have an implicitly qualified call to that function in your code, you either need to explicitly remove the auto-import using a compiler directive, or replace the call with a fully qualified function call. Otherwise you get a compilation error. See the following example:</source>
          <target state="translated">Sin embargo,para evitar que ese viejo código (pre R14)cambie su comportamiento cuando se compila con la versión OTP R14A o posterior,se aplica la siguiente restricción:Si anula el nombre de un BIF que fue autoimportado en las versiones OTP anteriores a la R14A (ERTS versión 5.8)y tiene una llamada implícitamente cualificada a esa función en su código,necesita eliminar explícitamente la autoimportación usando una directiva del compilador,o reemplazar la llamada con una llamada a una función totalmente cualificada.De lo contrario,obtendrá un error de compilación.Vea el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="0d770aae36addee1e6eb41cd37aaf79237dbd85a" translate="yes" xml:space="preserve">
          <source>However, what reservation of physical memory actually means highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b9c43d3cdd19de7c3638848d794e6192e00af7" translate="yes" xml:space="preserve">
          <source>However, when using, for example, IA5String (which closely resembles ASCII), byte 65 (in decimal notation) &lt;strong&gt;means&lt;/strong&gt; character 'A'.</source>
          <target state="translated">Sin embargo, cuando se usa, por ejemplo, IA5String (que se parece mucho a ASCII), el byte 65 (en notaci&amp;oacute;n decimal) &lt;strong&gt;significa el&lt;/strong&gt; car&amp;aacute;cter 'A'.</target>
        </trans-unit>
        <trans-unit id="8f5f28cc9ea54e0ce758adaa70edd19d2c7df7a4" translate="yes" xml:space="preserve">
          <source>Http client service start/stop</source>
          <target state="translated">Inicio y parada del servicio de atención al cliente Http</target>
        </trans-unit>
        <trans-unit id="2a4e8cc587ce6e7e113504c978e34c1e185e42f2" translate="yes" xml:space="preserve">
          <source>Http data types</source>
          <target state="translated">Tipos de datos Http</target>
        </trans-unit>
        <trans-unit id="421eac8e9d0f0d4fccaca857739a0c79fd890424" translate="yes" xml:space="preserve">
          <source>Hyphen (only where it can be interpreted as specifying a range)</source>
          <target state="translated">Guión (sólo cuando se puede interpretar que especifica un rango)</target>
        </trans-unit>
        <trans-unit id="df1da1414681b4aaf7b9dd8c935cd29628d37ea7" translate="yes" xml:space="preserve">
          <source>Hyphens are allowed in SMIv2 (a pragmatic approach). The reason for this is that according to SMIv2, hyphens are allowed for objects converted from SMIv1, but not for others. This is impossible to check for the compiler.</source>
          <target state="translated">Los guiones están permitidos en el SMIv2 (un enfoque pragmático).La razón de esto es que según el SMIv2,se permiten los guiones para los objetos convertidos a partir del SMIv1,pero no para los demás.Esto es imposible de comprobar para el compilador.</target>
        </trans-unit>
        <trans-unit id="c5bc42a4cab12cb2ea8fc597fa696281af9382e3" translate="yes" xml:space="preserve">
          <source>I will only present the most important functions in the API here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="317126fec2c76144e4651e497f8a410a786df087" translate="yes" xml:space="preserve">
          <source>I/O error.</source>
          <target state="translated">Error de E/S.</target>
        </trans-unit>
        <trans-unit id="629b47de797063a0b6b561c862c608954c3da6aa" translate="yes" xml:space="preserve">
          <source>I/O from a function called in an Erlang ssh daemon</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0868350648287b8190bf9c980b2ea9c46ef7d5" translate="yes" xml:space="preserve">
          <source>I/O is by far the most problematic area for Unicode. A file is an entity where bytes are stored, and the lore of programming has been to treat characters and bytes as interchangeable. With Unicode characters, you must decide on an encoding when you want to store the data in a file. In Erlang, you can open a text file with an encoding option, so that you can read characters from it rather than bytes, but you can also open a file for bytewise I/O.</source>
          <target state="translated">La E/S es de lejos el área más problemática para Unicode.Un archivo es una entidad en la que se almacenan bytes,y la tradición de la programación ha sido tratar los caracteres y los bytes como intercambiables.Con los caracteres de Unicode,debes decidir sobre una codificación cuando quieres almacenar los datos en un archivo.En Erlang,se puede abrir un archivo de texto con una opción de codificación,de modo que se puedan leer los caracteres de éste en lugar de los bytes,pero también se puede abrir un archivo para E/S bytewise.</target>
        </trans-unit>
        <trans-unit id="1fb1f4a96f553bd9d56bd14c304eff4f10d68c9d" translate="yes" xml:space="preserve">
          <source>I/O library functions.</source>
          <target state="translated">Funciones de biblioteca de E/S.</target>
        </trans-unit>
        <trans-unit id="e689b6630f1d0a364819fdd2b5731bcddd521358" translate="yes" xml:space="preserve">
          <source>I/O servers behave a little differently. The I/O servers connected to terminals (or &lt;code&gt;stdout&lt;/code&gt;) can usually cope with Unicode data regardless of the encoding option. This is convenient when one expects a modern environment but do not want to crash when writing to an archaic terminal or pipe.</source>
          <target state="translated">Los servidores de E / S se comportan de forma un poco diferente. Los servidores de E / S conectados a terminales (o &lt;code&gt;stdout&lt;/code&gt; ) generalmente pueden manejar datos Unicode independientemente de la opci&amp;oacute;n de codificaci&amp;oacute;n. Esto es conveniente cuando uno espera un entorno moderno pero no quiere fallar al escribir en una terminal o tuber&amp;iacute;a arcaica.</target>
        </trans-unit>
        <trans-unit id="2b536593017ca7fbb86fdac576736ff840ff5f41" translate="yes" xml:space="preserve">
          <source>I/O signals may however be aborted. This could be solved by letting the port specific scheduling lock also protect the private task data structure, but then the port very frequently would have to fight with others enqueueing new tasks. In order to handle this while keeping the private task data structure lock free, we use a similar &quot;non aggressive&quot; approach as we use when handling processes that gets suspended while in the run queue. Instead of removing the aborted port task, we just mark it as aborted using an atomic memory operation. When a task is selected for execution, we first verify that it has not been aborted. If aborted we, just drop the task.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fc86a2ee6eb5947817dfe748e38a27770d8f566" translate="yes" xml:space="preserve">
          <source>I/O-servers throughout the system can handle Unicode data and have options for converting data upon output or input to/from the device. As shown earlier, the &lt;code&gt;shell&lt;/code&gt; module has support for Unicode terminals and the &lt;code&gt;file&lt;/code&gt; module allows for translation to and from various Unicode formats on disk.</source>
          <target state="translated">Los servidores de E / S en todo el sistema pueden manejar datos Unicode y tienen opciones para convertir datos en la salida o entrada hacia / desde el dispositivo. Como se mostr&amp;oacute; anteriormente, el m&amp;oacute;dulo de &lt;code&gt;shell&lt;/code&gt; tiene soporte para terminales Unicode y el m&amp;oacute;dulo de &lt;code&gt;file&lt;/code&gt; permite la traducci&amp;oacute;n hacia y desde varios formatos Unicode en el disco.</target>
        </trans-unit>
        <trans-unit id="bcfd9b9aeb407171a7e2324b4088b3abd516b2fd" translate="yes" xml:space="preserve">
          <source>IANA Considerations</source>
          <target state="translated">Consideraciones de la IANA</target>
        </trans-unit>
        <trans-unit id="3e38df6d2fac16695ca12a7c20a2020653e3dafb" translate="yes" xml:space="preserve">
          <source>IC (Erlang IDL Compiler) is an interface generator that, given an IDL interface specification, automatically generates stub code in Erlang, C, or Java. See the IC User's Guide and IC Reference Manual.</source>
          <target state="translated">IC (Erlang IDL Compiler)es un generador de interfaces que,dada una especificación de interfaz IDL,genera automáticamente un código de colilla en Erlang,C o Java.Vea la Guía del usuario del IC y el Manual de referencia del IC.</target>
        </trans-unit>
        <trans-unit id="0bf03f10d1813cb5d0b794bb41322a916930011c" translate="yes" xml:space="preserve">
          <source>IC file. It runs the IDL compiler.</source>
          <target state="translated">Archivo IC.Ejecuta el compilador de IDL.</target>
        </trans-unit>
        <trans-unit id="881271d3bb93e752931432a69d275e6c5c697b27" translate="yes" xml:space="preserve">
          <source>IDEA cipher suites are not supported as they have become deprecated by the TLS 1.2 specification so it is not motivated to implement them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c51d7c7db41d3c06e8b204e1bc79bfc7925a9210" translate="yes" xml:space="preserve">
          <source>IETF - which calls the protocol Megaco</source>
          <target state="translated">IETF-que llama al protocolo Megaco</target>
        </trans-unit>
        <trans-unit id="7d26936a60ddb99baf38e0efb1e3118fc3bedbec" translate="yes" xml:space="preserve">
          <source>IG (Interface Generator) automatically generated code for port or socket communication between an Erlang program and a C program, given a C header file with certain keywords.</source>
          <target state="translated">IG (Generador de Interfaz)generó automáticamente el código para la comunicación de puerto o socket entre un programa Erlang y un programa C,dado un archivo de encabezamiento C con ciertas palabras clave.</target>
        </trans-unit>
        <trans-unit id="02cd32b9b05d3968d24a31f2968a004c733872e9" translate="yes" xml:space="preserve">
          <source>IG - Removed from Erlang/OTP R6B.</source>
          <target state="translated">IG-Removido de Erlang/OTP R6B.</target>
        </trans-unit>
        <trans-unit id="67d2109a8b5d8e4bb7b9df8f8ac917b156dee2f0" translate="yes" xml:space="preserve">
          <source>IIOP (CORBA)</source>
          <target state="translated">IIOP (CORBA)</target>
        </trans-unit>
        <trans-unit id="e11de130ad140b3de05ef1e6704f79955721f5c1" translate="yes" xml:space="preserve">
          <source>INTEGER, INT, SMALLINT</source>
          <target state="translated">INTEGER,INT,SMALLINT</target>
        </trans-unit>
        <trans-unit id="46a2b346d175bbcf022a9a889eb0d86d5bfeb44a" translate="yes" xml:space="preserve">
          <source>IOString</source>
          <target state="translated">IOString</target>
        </trans-unit>
        <trans-unit id="d191822111684cb0a3235f7ff4be7401211b5c9d" translate="yes" xml:space="preserve">
          <source>IP address, &lt;code&gt;addr&lt;/code&gt;</source>
          <target state="translated">Direcci&amp;oacute;n IP, &lt;code&gt;addr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1c4e4f4977f53cb13c9e71db88ccd9dabd0d8c68" translate="yes" xml:space="preserve">
          <source>IP v4 address and nodename.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a762fd412e63e6cdda70621754e625a105c877a8" translate="yes" xml:space="preserve">
          <source>IP v4 address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b376f791ddb908dfa5eec43b3c5893ba79b006b" translate="yes" xml:space="preserve">
          <source>IP version to use when the host address is specified as &lt;code&gt;any&lt;/code&gt;.</source>
          <target state="translated">Versi&amp;oacute;n de IP para usar cuando la direcci&amp;oacute;n de host se especifica como &lt;code&gt;any&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96a0cbf4fd8e6bbadf81a2623591ae93a5fab7c6" translate="yes" xml:space="preserve">
          <source>IPsec is transparent to diameter.</source>
          <target state="translated">El IPsec es transparente al diámetro.</target>
        </trans-unit>
        <trans-unit id="18ab43ebeda307979a5cae1e044580f0b576b6b9" translate="yes" xml:space="preserve">
          <source>ISO Latin-1 (0-255, one character per byte). Here, case parameter &lt;code&gt;InEncoding&lt;/code&gt; is to be specified as &lt;code&gt;latin1&lt;/code&gt;.</source>
          <target state="translated">ISO Latin-1 (0-255, un car&amp;aacute;cter por byte). Aqu&amp;iacute;, el par&amp;aacute;metro de caso &lt;code&gt;InEncoding&lt;/code&gt; debe especificarse como &lt;code&gt;latin1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5e544629e4d17007bac72590a9cae9dd3b4b775" translate="yes" xml:space="preserve">
          <source>ITU - which calls the protocol H.248</source>
          <target state="translated">UIT-que llama al protocolo H.248</target>
        </trans-unit>
        <trans-unit id="c633b237421559cb6821152c0d77a40227baef6f" translate="yes" xml:space="preserve">
          <source>Id of the &lt;code&gt;ssh&lt;/code&gt; channel as returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Id del canal &lt;code&gt;ssh&lt;/code&gt; devuelto por &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/2,4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eee9bf2e79695b73d87e005e3af0acf3c8bf8e02" translate="yes" xml:space="preserve">
          <source>Ideally, your code only contains the first type of efficient code. If that turns out to be too slow, profile the application to find out where the performance bottlenecks are and optimize only the bottlenecks. Let other code stay as clean as possible.</source>
          <target state="translated">Idealmente,su código sólo contiene el primer tipo de código eficiente.Si resulta ser demasiado lento,haz un perfil de la aplicación para averiguar dónde están los cuellos de botella de rendimiento y optimiza sólo los cuellos de botella.Deja que el resto del código se mantenga lo más limpio posible.</target>
        </trans-unit>
        <trans-unit id="c30e59972c073691c1e830409d7104410fccdf7c" translate="yes" xml:space="preserve">
          <source>Identified processor states may be different on different operating systems and may change between different versions of &lt;code&gt;cpu_sup&lt;/code&gt; on the same operating system. The sum of the percentage shares of the CPU cycles spent in all busy and all non-busy processor states will always add up to 100%, though.</source>
          <target state="translated">Los estados de procesador identificados pueden ser diferentes en diferentes sistemas operativos y pueden cambiar entre diferentes versiones de &lt;code&gt;cpu_sup&lt;/code&gt; en el mismo sistema operativo. Sin embargo, la suma de los porcentajes de los ciclos de CPU gastados en todos los estados de procesador ocupado y no ocupado siempre sumar&amp;aacute; el 100%.</target>
        </trans-unit>
        <trans-unit id="b46580854e82988aa9e6377bc948b9ced562fe4b" translate="yes" xml:space="preserve">
          <source>Identifiers.</source>
          <target state="translated">Identifiers.</target>
        </trans-unit>
        <trans-unit id="c4b828ddf628f41cc4d390c6deaa0302ac12c3dd" translate="yes" xml:space="preserve">
          <source>Identifies a TLS session.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75bb32d0a7ac84997a35ee28f73ca250b15a818d" translate="yes" xml:space="preserve">
          <source>Identifies a counter array returned from &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d9be73f1ae427426eb7dad6ec17364635870b5" translate="yes" xml:space="preserve">
          <source>Identifies an atomic array returned from &lt;code&gt;&lt;a href=&quot;#new-2&quot;&gt;new/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc1aea5ef7b08c4fe2e094b55f89ec9a27cc6266" translate="yes" xml:space="preserve">
          <source>Identifies and returns the type of Erlang term encoded in a buffer. It skips a trailing &lt;strong&gt;magic&lt;/strong&gt; identifier.</source>
          <target state="translated">Identifica y devuelve el tipo de t&amp;eacute;rmino Erlang codificado en un b&amp;uacute;fer. Omite un identificador &lt;strong&gt;m&amp;aacute;gico&lt;/strong&gt; final .</target>
        </trans-unit>
        <trans-unit id="d4286448984448b29096cfc37d85e421cb0b828a" translate="yes" xml:space="preserve">
          <source>Identifies the file system where the file is located. In Windows, the number indicates a drive as follows: 0 means A:, 1 means B:, and so on.</source>
          <target state="translated">Identifica el sistema de archivos donde se encuentra el archivo.En Windows,el número indica una unidad de disco de la siguiente manera:0 significa A:,1 significa B:,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="a78e241d75b4386f5966c1f03850bc25044aab1e" translate="yes" xml:space="preserve">
          <source>Identifies the key to be used. The format depends on the loaded engine. It is passed to the &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; functions in libcrypto.</source>
          <target state="translated">Identifica la clave que se utilizar&amp;aacute;. El formato depende del motor cargado. Se pasa a las &lt;code&gt;ENGINE_load_(private|public)_key&lt;/code&gt; en libcrypto.</target>
        </trans-unit>
        <trans-unit id="5c6a3f5a562e2ce595bdeeb857c4ae74f4eb3a1c" translate="yes" xml:space="preserve">
          <source>Identifies what information to sort by.</source>
          <target state="translated">Identifica la información por la que hay que clasificar.</target>
        </trans-unit>
        <trans-unit id="4c35819884b50461c098d94e30fb5a14c994b48c" translate="yes" xml:space="preserve">
          <source>Identifying capturing parentheses by number is simple, but it can be hard to keep track of the numbers in complicated regular expressions. Also, if an expression is modified, the numbers can change. To help with this difficulty, PCRE supports the naming of subpatterns. This feature was not added to Perl until release 5.10. Python had the feature earlier, and PCRE introduced it at release 4.0, using the Python syntax. PCRE now supports both the Perl and the Python syntax. Perl allows identically numbered subpatterns to have different names, but PCRE does not.</source>
          <target state="translated">Identificar la captura de paréntesis por número es simple,pero puede ser difícil seguir el rastro de los números en complicadas expresiones regulares.Además,si se modifica una expresión,los números pueden cambiar.Para ayudar con esta dificultad,PCRE apoya la denominación de subpatrones.Esta característica no se añadió a Perl hasta la versión 5.10.Python tenía la característica antes,y PCRE la introdujo en la versión 4.0,usando la sintaxis de Python.PCRE ahora soporta tanto la sintaxis de Perl como la de Python.Perl permite que subpatrones idénticamente numerados tengan nombres diferentes,pero PCRE no.</target>
        </trans-unit>
        <trans-unit id="86dd18440c1a33a5adeeb3446934c0824c7a25f8" translate="yes" xml:space="preserve">
          <source>Identity of connection or session configuration in a configuration file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dee66e066bf8a35e6b819408cf3275f475346209" translate="yes" xml:space="preserve">
          <source>Ideographic space</source>
          <target state="translated">Espacio ideográfico</target>
        </trans-unit>
        <trans-unit id="772dd6d712cea08023a9c33b5e08bad4fba86f2b" translate="yes" xml:space="preserve">
          <source>Idle.</source>
          <target state="translated">Idle.</target>
        </trans-unit>
        <trans-unit id="d71d2a6296b765e49d14ea0b96f03799b0b788cf" translate="yes" xml:space="preserve">
          <source>If (*ACCEPT) is inside capturing parentheses, the data so far is captured. For example, the following matches &quot;AB&quot;, &quot;AAD&quot;, or &quot;ACD&quot;. When it matches &quot;AB&quot;, &quot;B&quot; is captured by the outer parentheses.</source>
          <target state="translated">Si (*ACCEPT)está dentro capturando paréntesis,los datos hasta ahora son capturados.Por ejemplo,lo siguiente coincide con &quot;AB&quot;,&quot;AAD&quot; o &quot;ACD&quot;.Cuando coincide con &quot;AB&quot;,&quot;B&quot; es capturado por el paréntesis exterior.</target>
        </trans-unit>
        <trans-unit id="17049b973641f08ec5c309099cc30f3f32903038" translate="yes" xml:space="preserve">
          <source>If (*COMMIT) is the only backtracking verb that is encountered, once it has been passed, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; is committed to find a match at the current starting point, or not at all, for example:</source>
          <target state="translated">Si (* COMMIT) es el &amp;uacute;nico verbo de retroceso que se encuentra, una vez que se ha pasado, &lt;code&gt;&lt;a href=&quot;#run-2&quot;&gt;run/2,3&lt;/a&gt;&lt;/code&gt; se compromete a encontrar una coincidencia en el punto de inicio actual, o no encontrar una coincidencia, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="4f0f3a8fd87c3eaeb73231280dec7eb243d5903c" translate="yes" xml:space="preserve">
          <source>If +MMscrpm is set to true, which is default, the initial allocation will reserve physical memory for the entire super carrier. This can be used by users that want to ensure a certain &lt;strong&gt;minimum&lt;/strong&gt; amount of physical memory for the VM.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40ba26284bd6bedd0128033397652d534ba6ab6d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66bd65b9d1cb2983119740d6067afd32e3a7d58b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt; file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d780bbcc021b00d62054ba34ee21d203ad8580fa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is returned that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si el m&amp;oacute;dulo &lt;code&gt;global&lt;/code&gt; en &lt;code&gt;Kernel&lt;/code&gt; conoce &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; , se devuelve un pid Erlang que se puede usar para enviar mensajes al servicio de horario. Adem&amp;aacute;s, el &lt;code&gt;node&lt;/code&gt; se inicializa para contener el nombre del nodo donde est&amp;aacute; registrado el servicio, de modo que pueda hacer una conexi&amp;oacute;n con &amp;eacute;l simplemente pasando la variable a &lt;code&gt;&lt;a href=&quot;erl_connect&quot;&gt;erl_connect&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1dd779b7143c0739432543164284fa524cccd2f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&quot;schedule&quot;&lt;/code&gt; is known to the &lt;code&gt;global&lt;/code&gt; module in &lt;code&gt;Kernel&lt;/code&gt;, an Erlang pid is written to the_pid. This pid that can be used to send messages to the schedule service. Also, &lt;code&gt;node&lt;/code&gt; is initialized to contain the name of the node where the service is registered, so that you can make a connection to it by simply passing the variable to &lt;code&gt;&lt;a href=&quot;ei_connect&quot;&gt;ei_connect&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e26772d0fb234e217566d6d19fae8939ae23412" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt; &lt;strong&gt;callback mode&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6005483687ef9ab80b3590fb0cf13631ca631c7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt;&lt;code&gt;handle_event_function&lt;/code&gt; is used, all events are handled in &lt;code&gt;Module:handle_event/4&lt;/code&gt; and we can (but do not have to) use an event-centered approach where we first branch depending on event and then depending on state:</source>
          <target state="translated">Si se usa el &lt;code&gt;&lt;a href=&quot;#Callback%20Modes&quot;&gt;Callback Mode&lt;/a&gt;&lt;/code&gt; &lt;code&gt;handle_event_function&lt;/code&gt; llamada handle_event_function , todos los eventos se manejan en el &lt;code&gt;Module:handle_event/4&lt;/code&gt; y podemos (pero no es necesario) usar un enfoque centrado en eventos donde primero nos ramificamos dependiendo del evento y luego dependiendo del estado:</target>
        </trans-unit>
        <trans-unit id="bebc3f9361919a37bdadad08140e7c6cde4d32d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no &lt;strong&gt;state enter calls&lt;/strong&gt; are done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca5cadc65f5f231df3ce6310110d1f4f33d8f4c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; does not return such a list, no state enter calls are done.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; no devuelve dicha lista, no se realizan llamadas de entrada de estado.</target>
        </trans-unit>
        <trans-unit id="f1ede23ffb5bebc5707015ac6f688b4dfda3fb06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every &lt;strong&gt;state change&lt;/strong&gt;, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; or &lt;code&gt;(enter, OldState, State, Data)&lt;/code&gt;, depending on the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. This may look like an event but is really a call performed after the previous &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; returned and before any event is delivered to the new &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state &lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; tuple from the &lt;strong&gt;state callback&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acdd1ca7763b0bdfa6212efd72aad6a1d16e6bec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; returns a list containing &lt;code&gt;state_enter&lt;/code&gt;, the &lt;code&gt;gen_statem&lt;/code&gt; engine will, at every state change, call the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; with arguments &lt;code&gt;(enter, OldState, Data)&lt;/code&gt;. This may look like an event but is really a call performed after the previous state callback returned and before any event is delivered to the new state callback. See &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. Such a call can be repeated by returning a &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; tuple from the state callback.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;#Module:callback_mode-0&quot;&gt;Module:callback_mode/0&lt;/a&gt;&lt;/code&gt; devuelve una lista que contiene &lt;code&gt;state_enter&lt;/code&gt; , el motor &lt;code&gt;gen_statem&lt;/code&gt; , en cada cambio de estado, llamar&amp;aacute; a la &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; llamada del estado con argumentos &lt;code&gt;(enter, OldState, Data)&lt;/code&gt; . Esto puede parecer un evento, pero en realidad es una llamada realizada despu&amp;eacute;s de que se devolvi&amp;oacute; la devoluci&amp;oacute;n de llamada del estado anterior y antes de que cualquier evento se env&amp;iacute;e a la devoluci&amp;oacute;n de llamada del nuevo estado. Consulte &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; . Esta llamada se puede repetir devolviendo una tupla &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; de la devoluci&amp;oacute;n de llamada del estado.</target>
        </trans-unit>
        <trans-unit id="c28ef58b982d1f354c9c1bb974e90b1d95e0f6b3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a &lt;strong&gt;state change&lt;/strong&gt;, which will not cause a &lt;strong&gt;state enter call&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d69858e99b09a6a2285a4ba103a8f8d3c928ade9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; should transform the state, it is regarded as a state rename and not a state change, which will not cause a state enter call.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;#Module:code_change-4&quot;&gt;Module:code_change/4&lt;/a&gt;&lt;/code&gt; debe transformar el estado, se considera un cambio de nombre de estado y no un cambio de estado, lo que no provocar&amp;aacute; una llamada de entrada de estado.</target>
        </trans-unit>
        <trans-unit id="c3e9d1ef03578b7d4de76213b44cdc398818f9bc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current event is postponed.</source>
          <target state="translated">Si &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el evento actual se pospone.</target>
        </trans-unit>
        <trans-unit id="af5f4ef54abaee17eded82e21fef9696e20a28ee" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; are used, and either it is the initial state or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt; repeat_state_and_data &lt;/a&gt;&lt;/code&gt; is used the &lt;code&gt;gen_statem&lt;/code&gt; engine calls the current state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, Data)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, State, State, Data)&lt;/a&gt;&lt;/code&gt; (depending on &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;) and when it returns starts again from the top of this sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd474c164e6c98dd34c39ad22b25553a62777256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt; &lt;strong&gt;state enter calls&lt;/strong&gt; &lt;/a&gt;&lt;/code&gt; are used, and the state changes the &lt;code&gt;gen_statem&lt;/code&gt; engine calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, State, Data)&lt;/a&gt;&lt;/code&gt; (depending on &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;) and when it returns starts again from the top of this sequence.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e210051c1bffc48ec6b9fc364560332e7094f3fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; are used, and either: the state changes, it is the initial state, or one of the callback results &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; is used; the &lt;code&gt;gen_statem&lt;/code&gt; calls the new state callback with arguments &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se utilizan &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; y: el estado cambia, es el estado inicial, o se utiliza uno de los resultados de devoluci&amp;oacute;n de llamada &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#type-state_callback_result&quot;&gt;repeat_state_and_data&lt;/a&gt;&lt;/code&gt; ; la &lt;code&gt;gen_statem&lt;/code&gt; llama el nuevo estado de devoluci&amp;oacute;n de llamada con argumentos &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;(enter, OldState, Data)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="16fb9d916c4a4fe6d38e2fad03d1c0057e0a3ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; is used, exactly one system configuration file is to be used and that file is to be called &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">Si se usa el &lt;code&gt;&lt;a href=&quot;release_handling#sys&quot;&gt;release handling&lt;/a&gt;&lt;/code&gt; se usar&amp;aacute; exactamente un archivo de configuraci&amp;oacute;n del sistema y ese archivo se llamar&amp;aacute; &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="51507c4f6a07b6ee28c5c354867983982dadbd0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt; erlang:start_timer/4 &lt;/code&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6115cbb4f02f28f406dcce7ea93217a4c99b305" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Abs&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; an absolute timer is started, and if it is &lt;code&gt;false&lt;/code&gt; a relative, which is the default. See &lt;code&gt;erlang:start_timer/4&lt;/code&gt; for details.</source>
          <target state="translated">Si &lt;code&gt;Abs&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; se inicia un temporizador absoluto, y si es &lt;code&gt;false&lt;/code&gt; un relativo, que es el predeterminado. Consulte &lt;code&gt;erlang:start_timer/4&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="d0a20b01d494121fa23ac0f013c356e2645f0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt;, &lt;code&gt;Suspendee&lt;/code&gt; is currently in the suspended state.</source>
          <target state="translated">Si &lt;code&gt;ActiveSuspendCount =/= 0&lt;/code&gt; , &lt;code&gt;Suspendee&lt;/code&gt; se encuentra actualmente en estado suspendido.</target>
        </trans-unit>
        <trans-unit id="10d7f30204e89013efcda3ea67f9618ecad92260" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto&lt;/code&gt; this function behaves exactly like &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Alg&lt;/code&gt; es &lt;code&gt;crypto&lt;/code&gt; esta funci&amp;oacute;n se comporta exactamente como &lt;code&gt;&lt;a href=&quot;#rand_seed_s-0&quot;&gt;rand_seed_s/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3833f82acaa575d2a76a8a6ea669ec6336dec8e4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Alg&lt;/code&gt; is &lt;code&gt;crypto_cache&lt;/code&gt; this function fetches random data with OpenSSL's &lt;code&gt;RAND_bytes&lt;/code&gt; and caches it for speed using an internal word size of 56 bits that makes calculations fast on 64 bit machines.</source>
          <target state="translated">Si &lt;code&gt;Alg&lt;/code&gt; es &lt;code&gt;crypto_cache&lt;/code&gt; , esta funci&amp;oacute;n obtiene datos aleatorios con &lt;code&gt;RAND_bytes&lt;/code&gt; de OpenSSL y los almacena en cach&amp;eacute; para mayor velocidad utilizando un tama&amp;ntilde;o de palabra interna de 56 bits que agiliza los c&amp;aacute;lculos en m&amp;aacute;quinas de 64 bits.</target>
        </trans-unit>
        <trans-unit id="81e735d9039bbf6127ac283e19b140ef66799a72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1Type&lt;/code&gt; is &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt;, &lt;code&gt;Entity&lt;/code&gt; must be either an &lt;code&gt;rsa_public_key()&lt;/code&gt;, &lt;code&gt;dsa_public_key()&lt;/code&gt; or an &lt;code&gt;ec_public_key()&lt;/code&gt; and this function creates the appropriate &lt;code&gt;'SubjectPublicKeyInfo'&lt;/code&gt; entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="540115359cf8a83ae29b77cf40e5db9ee30403e2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Asn1module&lt;/code&gt; is a filename without extension, first &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; is assumed, then &lt;code&gt;&quot;.asn&quot;&lt;/code&gt;, and finally &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (to be compatible with the old ASN.1 compiler). &lt;code&gt;Asn1module&lt;/code&gt; can be a full pathname (relative or absolute) including filename with (or without) extension.</source>
          <target state="translated">Si &lt;code&gt;Asn1module&lt;/code&gt; es un nombre de archivo sin extensi&amp;oacute;n, primero se asume &lt;code&gt;&quot;.asn1&quot;&lt;/code&gt; , luego &lt;code&gt;&quot;.asn&quot;&lt;/code&gt; y finalmente &lt;code&gt;&quot;.py&quot;&lt;/code&gt; (para que sea compatible con el antiguo compilador ASN.1). &lt;code&gt;Asn1module&lt;/code&gt; puede ser un nombre de ruta completo (relativo o absoluto), incluido el nombre de archivo con (o sin) extensi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9fdaeedafeeda6ab32c9d50b3c97381ca731e512" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bin&lt;/code&gt; does not contain the entire packet, &lt;code&gt;{more,Length}&lt;/code&gt; is returned. &lt;code&gt;Length&lt;/code&gt; is either the expected &lt;strong&gt;total size&lt;/strong&gt; of the packet, or &lt;code&gt;undefined&lt;/code&gt; if the expected packet size is unknown. &lt;code&gt;decode_packet&lt;/code&gt; can then be called again with more data added.</source>
          <target state="translated">Si &lt;code&gt;Bin&lt;/code&gt; no contiene el paquete completo, se devuelve &lt;code&gt;{more,Length}&lt;/code&gt; . &lt;code&gt;Length&lt;/code&gt; es el &lt;strong&gt;tama&amp;ntilde;o total&lt;/strong&gt; esperado del paquete o &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definida si se desconoce el tama&amp;ntilde;o esperado del paquete. &lt;code&gt;decode_packet&lt;/code&gt; se puede volver a llamar con m&amp;aacute;s datos agregados.</target>
        </trans-unit>
        <trans-unit id="f95f96eeb6722b14446ed74c5ef5dfae744b890d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BinRel1&lt;/code&gt; is omitted, the relation of equality between the elements of the &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; of the ranges of R[i], range R[1] &amp;times; ... &amp;times; range R[n], is used instead (intuitively, nothing is &quot;lost&quot;).</source>
          <target state="translated">Si se omite &lt;code&gt;BinRel1&lt;/code&gt; , la relaci&amp;oacute;n de igualdad entre los elementos del &lt;code&gt;&lt;a href=&quot;#Cartesian_product_tuple&quot;&gt;Cartesian product&lt;/a&gt;&lt;/code&gt; de los rangos de R [i], rango R [1] &amp;times; ... &amp;times; rango R [n], se usa en su lugar (intuitivamente, nada es &quot; perdi&amp;oacute;&quot;).</target>
        </trans-unit>
        <trans-unit id="ab7b5f7a351be014914684701b08694a59a8d0bb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binaries&lt;/code&gt; is not a flat list of binaries, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si &lt;code&gt;Binaries&lt;/code&gt; no es una lista plana de binarios, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="aec03c703d777c73a4a57e3a4befcb0a209f3691" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Binary&lt;/code&gt; contains the object code for module &lt;code&gt;Module&lt;/code&gt;, this BIF loads that object code. If the code for module &lt;code&gt;Module&lt;/code&gt; already exists, all export references are replaced so they point to the newly loaded code. The previously loaded code is kept in the system as old code, as there can still be processes executing that code.</source>
          <target state="translated">Si &lt;code&gt;Binary&lt;/code&gt; contiene el c&amp;oacute;digo objeto para el m&amp;oacute;dulo &lt;code&gt;Module&lt;/code&gt; , este BIF carga ese c&amp;oacute;digo objeto. Si el c&amp;oacute;digo del m&amp;oacute;dulo &lt;code&gt;Module&lt;/code&gt; ya existe, todas las referencias de exportaci&amp;oacute;n se reemplazan para que apunten al c&amp;oacute;digo reci&amp;eacute;n cargado. El c&amp;oacute;digo previamente cargado se mantiene en el sistema como c&amp;oacute;digo antiguo, ya que todav&amp;iacute;a puede haber procesos que ejecuten ese c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="bf1ea3c8c99142091a2f51c1e81be7adb284b19c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block&lt;/code&gt;, multi-scheduling is blocked. That is, one and only one scheduler thread will execute. If &lt;code&gt;BlockState =:= unblock&lt;/code&gt; and no one else blocks multi-scheduling, and this process has blocked only once, multi-scheduling is unblocked.</source>
          <target state="translated">Si &lt;code&gt;BlockState =:= block&lt;/code&gt; , la programaci&amp;oacute;n m&amp;uacute;ltiple est&amp;aacute; bloqueada. Es decir, se ejecutar&amp;aacute; uno y solo un subproceso del planificador. Si &lt;code&gt;BlockState =:= unblock&lt;/code&gt; y nadie m&amp;aacute;s bloquea la programaci&amp;oacute;n m&amp;uacute;ltiple, y este proceso se ha bloqueado solo una vez, la programaci&amp;oacute;n m&amp;uacute;ltiple se desbloquea.</target>
        </trans-unit>
        <trans-unit id="39adb796c018ce57c270103c3c52ab7a2219f00b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;BlockState =:= block_normal&lt;/code&gt;, normal multi-scheduling is blocked. That is, only one normal scheduler thread will execute, but multiple dirty schedulers can execute. If &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; and no one else blocks normal multi-scheduling, and this process has blocked only once, normal multi-scheduling is unblocked.</source>
          <target state="translated">Si &lt;code&gt;BlockState =:= block_normal&lt;/code&gt; , la programaci&amp;oacute;n m&amp;uacute;ltiple normal est&amp;aacute; bloqueada. Es decir, solo se ejecutar&amp;aacute; un subproceso del programador normal, pero se pueden ejecutar varios programadores sucios. Si &lt;code&gt;BlockState =:= unblock_normal&lt;/code&gt; y nadie m&amp;aacute;s bloquea la programaci&amp;oacute;n m&amp;uacute;ltiple normal, y este proceso se ha bloqueado solo una vez, la programaci&amp;oacute;n m&amp;uacute;ltiple normal se desbloquea.</target>
        </trans-unit>
        <trans-unit id="4eabdce3dc316d89d6448638269f7e3485875fb5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Body&lt;/code&gt; is returned and equal to &lt;code&gt;{Fun,Arg}&lt;/code&gt;, the web server tries &lt;code&gt;apply/2&lt;/code&gt; on &lt;code&gt;Fun&lt;/code&gt; with &lt;code&gt;Arg&lt;/code&gt; as argument. The web server expects that the fun either returns a list &lt;code&gt;(Body)&lt;/code&gt; that is an HTTP repsonse, or the atom &lt;code&gt;sent&lt;/code&gt; if the HTTP response is sent back to the client. If &lt;code&gt;close&lt;/code&gt; is returned from the fun, something has gone wrong and the server signals this to the client by closing the connection.</source>
          <target state="translated">Si se devuelve &lt;code&gt;Body&lt;/code&gt; y es igual a &lt;code&gt;{Fun,Arg}&lt;/code&gt; , el servidor web intenta &lt;code&gt;apply/2&lt;/code&gt; en &lt;code&gt;Fun&lt;/code&gt; con &lt;code&gt;Arg&lt;/code&gt; como argumento. El servidor web espera que la diversi&amp;oacute;n devuelva una lista &lt;code&gt;(Body)&lt;/code&gt; que es una respuesta HTTP, o el &amp;aacute;tomo &lt;code&gt;sent&lt;/code&gt; si la respuesta HTTP se env&amp;iacute;a de vuelta al cliente. Si se devuelve un &lt;code&gt;close&lt;/code&gt; de la diversi&amp;oacute;n, algo sali&amp;oacute; mal y el servidor se lo indica al cliente cerrando la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="501ba76048afe6c06b0d19442d6fa569952e8089" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; (the default value), &lt;code&gt;rb&lt;/code&gt; prints an error message to &lt;code&gt;stdout&lt;/code&gt; for every bad report it encounters, but the logging process is never ended. All printable reports are written. If logging to file is enabled, &lt;code&gt;rb&lt;/code&gt; prints &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; in the log file at the location of an unprintable report.</source>
          <target state="translated">Si &lt;code&gt;Bool&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; (el valor predeterminado), &lt;code&gt;rb&lt;/code&gt; imprime un mensaje de error en &lt;code&gt;stdout&lt;/code&gt; por cada informe incorrecto que encuentra, pero el proceso de registro nunca termina. Todos los informes imprimibles est&amp;aacute;n escritos. Si el registro en archivo est&amp;aacute; habilitado, &lt;code&gt;rb&lt;/code&gt; imprime &lt;code&gt;* UNPRINTABLE REPORT *&lt;/code&gt; en el archivo de registro en la ubicaci&amp;oacute;n de un informe no imprimible.</target>
        </trans-unit>
        <trans-unit id="adf90318c831c61cd69b483b3f045a3d3bf9c68f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Bool&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;rb&lt;/code&gt; stops logging (and prints an error message to &lt;code&gt;stdout&lt;/code&gt;) if it encounters a badly formatted report. If logging to file is enabled, an error message is appended to the log file as well.</source>
          <target state="translated">Si &lt;code&gt;Bool&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;rb&lt;/code&gt; deja de registrar (e imprime un mensaje de error en &lt;code&gt;stdout&lt;/code&gt; ) si encuentra un informe mal formateado. Si el registro en archivo est&amp;aacute; habilitado, tambi&amp;eacute;n se agrega un mensaje de error al archivo de registro.</target>
        </trans-unit>
        <trans-unit id="f4e4245f2e5400c897f04314650c4ae5a083dc43" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, option &lt;code&gt;TCP_NODELAY&lt;/code&gt; is turned on for the socket, which means that also small amounts of data are sent immediately.</source>
          <target state="translated">Si &lt;code&gt;Boolean == true&lt;/code&gt; , la opci&amp;oacute;n &lt;code&gt;TCP_NODELAY&lt;/code&gt; est&amp;aacute; activada para el socket, lo que significa que tambi&amp;eacute;n se env&amp;iacute;an peque&amp;ntilde;as cantidades de datos inmediatamente.</target>
        </trans-unit>
        <trans-unit id="694f121851d48acf6a07239b2f70a6b720fe0aa3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Boolean == true&lt;/code&gt;, the corresponding option is turned on for the socket, which means that small amounts of data are accumulated until a full MSS-worth of data is available or this option is turned off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81aeea37b05ee5c673682e9fcc0d5b3b90b2fd57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Button&lt;/code&gt; is a top type and it is needed to exclude component &lt;code&gt;number&lt;/code&gt; from decode, &lt;code&gt;Type_List&lt;/code&gt; in the instruction in the configuration file is &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt;. If you call the decode function &lt;code&gt;decode_Button_exclusive&lt;/code&gt;, &lt;code&gt;Decode_Instruction&lt;/code&gt; is &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Button&lt;/code&gt; es un tipo superior y es necesario excluir el &lt;code&gt;number&lt;/code&gt; componente de la decodificaci&amp;oacute;n, &lt;code&gt;Type_List&lt;/code&gt; en la instrucci&amp;oacute;n en el archivo de configuraci&amp;oacute;n es &lt;code&gt;['Button',[{number,undecoded}]]&lt;/code&gt; . Si llama a la funci&amp;oacute;n de decodificaci&amp;oacute;n &lt;code&gt;decode_Button_exclusive&lt;/code&gt; , &lt;code&gt;Decode_Instruction&lt;/code&gt; es &lt;code&gt;{decode_Button_exclusive,['Button',[{number,undecoded}]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0a8d1dadfc486d1483799d20461767cefd8ed40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Common Test&lt;/code&gt; Master fails initially to connect to any of the test nodes specified in a test specification or in the &lt;code&gt;InclNodes&lt;/code&gt; list, the operator is prompted with the option to either start over again (after manually checking the status of the nodes in question), to run without the missing nodes, or to abort the operation.</source>
          <target state="translated">Si &lt;code&gt;Common Test&lt;/code&gt; Master no se conecta inicialmente a cualquiera de los nodos de prueba especificados en una especificaci&amp;oacute;n de prueba o en la lista &lt;code&gt;InclNodes&lt;/code&gt; , se le solicita al operador la opci&amp;oacute;n de comenzar de nuevo (despu&amp;eacute;s de verificar manualmente el estado de los nodos en cuesti&amp;oacute;n), para ejecutar sin los nodos faltantes, o para abortar la operaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7f9aad828bfbe4d21e5a879fcef15f035543f64c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;CurrentIndentation&lt;/code&gt; is negative, there are no line breaks and only a space is used as a separator.</source>
          <target state="translated">Si &lt;code&gt;CurrentIndentation&lt;/code&gt; es negativo, no hay saltos de l&amp;iacute;nea y solo se usa un espacio como separador.</target>
        </trans-unit>
        <trans-unit id="5c9db23221c4effc6df13f53f295b1b05c8bade4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Data&lt;/code&gt; is an invalid I/O list.</source>
          <target state="translated">Si los &lt;code&gt;Data&lt;/code&gt; son una lista de E / S no v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="d49ad8995eb2ed767b688b2071df0c58e2d5482e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dates&lt;/code&gt; has the form &lt;code&gt;{DateTo, to}&lt;/code&gt;, reports that occurred before &lt;code&gt;DateTo&lt;/code&gt; are displayed.</source>
          <target state="translated">Si &lt;code&gt;Dates&lt;/code&gt; tiene el formato &lt;code&gt;{DateTo, to}&lt;/code&gt; , se muestran los informes que ocurrieron antes de &lt;code&gt;DateTo&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a74df3b45fff783ce83be5e48dd039ecedaba02" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, it must be a &lt;code&gt;pid()&lt;/code&gt; of a process created on the current runtime system instance. This process has either terminated or not. If &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;, it is interpreted as the name of a locally registered process. The process referred to by the name is looked up at the time of timer expiration. No error is returned if the name does not refer to a process.</source>
          <target state="translated">Si &lt;code&gt;Dest&lt;/code&gt; es un &lt;code&gt;pid()&lt;/code&gt; , debe ser un &lt;code&gt;pid()&lt;/code&gt; de un proceso creado en la instancia actual del sistema en tiempo de ejecuci&amp;oacute;n. Este proceso ha terminado o no. Si &lt;code&gt;Dest&lt;/code&gt; es un &lt;code&gt;atom()&lt;/code&gt; , se interpreta como el nombre de un proceso registrado localmente. El proceso al que se hace referencia por el nombre se busca en el momento de la expiraci&amp;oacute;n del temporizador. No se devuelve ning&amp;uacute;n error si el nombre no se refiere a un proceso.</target>
        </trans-unit>
        <trans-unit id="815563aae4c2a11f4a34513e2da4caef9eb431be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dest&lt;/code&gt; is a &lt;code&gt;pid()&lt;/code&gt;, the timer is automatically canceled if the process referred to by the &lt;code&gt;pid()&lt;/code&gt; is not alive, or if the process exits. This feature was introduced in ERTS 5.4.11. Notice that timers are not automatically canceled when &lt;code&gt;Dest&lt;/code&gt; is an &lt;code&gt;atom()&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Dest&lt;/code&gt; es un &lt;code&gt;pid()&lt;/code&gt; , el temporizador se cancela autom&amp;aacute;ticamente si el proceso al que hace referencia el &lt;code&gt;pid()&lt;/code&gt; no est&amp;aacute; activo o si el proceso se cierra. Esta funci&amp;oacute;n se introdujo en ERTS 5.4.11. Tenga en cuenta que los temporizadores no se cancelan autom&amp;aacute;ticamente cuando &lt;code&gt;Dest&lt;/code&gt; es un &lt;code&gt;atom()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="444e6101a0cf1c543819e121052f438f584a1b39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Destination&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;write&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">Si &lt;code&gt;Destination&lt;/code&gt; refiere a un nombre de archivo, se abre con el modo de &lt;code&gt;write&lt;/code&gt; antepuesto a la lista de modos antes de la copia y se cierra cuando termina.</target>
        </trans-unit>
        <trans-unit id="4f4e05199aa0bb385a948469feaaa5b970e7e3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Dir&lt;/code&gt; does not exist</source>
          <target state="translated">Si &lt;code&gt;Dir&lt;/code&gt; no existe</target>
        </trans-unit>
        <trans-unit id="ee2b254fd6abe2a90dfea4382f11c9cb30169e97" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == default&lt;/code&gt;, the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt; is used.</source>
          <target state="translated">Si &lt;code&gt;Distributed == default&lt;/code&gt; , se utiliza el valor de la aplicaci&amp;oacute;n en el par&amp;aacute;metro de configuraci&amp;oacute;n del n&amp;uacute;cleo &lt;code&gt;distributed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="49d3ece08d6530837a1ab0ddc7b321c040846a53" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt;, the application becomes distributed. The argument overrides the value for the application in the Kernel configuration parameter &lt;code&gt;distributed&lt;/code&gt;. &lt;code&gt;Application&lt;/code&gt; must be the application name (same as in the first argument). If a node crashes and &lt;code&gt;Time&lt;/code&gt; is specified, the application controller waits for &lt;code&gt;Time&lt;/code&gt; milliseconds before attempting to restart the application on another node. If &lt;code&gt;Time&lt;/code&gt; is not specified, it defaults to &lt;code&gt;0&lt;/code&gt; and the application is restarted immediately.</source>
          <target state="translated">Si &lt;code&gt;Distributed == {Application,[Time,]Nodes}&lt;/code&gt; , la aplicaci&amp;oacute;n se distribuye. El argumento anula el valor de la aplicaci&amp;oacute;n en el par&amp;aacute;metro de configuraci&amp;oacute;n del n&amp;uacute;cleo &lt;code&gt;distributed&lt;/code&gt; . &lt;code&gt;Application&lt;/code&gt; debe ser el nombre de la aplicaci&amp;oacute;n (igual que en el primer argumento). Si un nodo falla y &lt;code&gt;Time&lt;/code&gt; se especifica, el controlador espera la aplicaci&amp;oacute;n para &lt;code&gt;Time&lt;/code&gt; milisegundos antes de intentar reiniciar la aplicaci&amp;oacute;n en otro nodo. Si no se especifica &lt;code&gt;Time&lt;/code&gt; , el valor predeterminado es &lt;code&gt;0&lt;/code&gt; y la aplicaci&amp;oacute;n se reinicia inmediatamente.</target>
        </trans-unit>
        <trans-unit id="4152fae1a454be09c28651bdb166f8066323431a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, lists of integers &lt;code&gt;0..255&lt;/code&gt; or binaries containing plain bytes are sent back to the client when possible. If &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;, lists with integers in the whole Unicode range or binaries encoded in UTF-8 are sent to the client. The user-supplied function always sees lists of integers, never binaries, but the list can contain numbers &amp;gt; 255 if &lt;code&gt;Encoding&lt;/code&gt; is &lt;code&gt;unicode&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Encoding&lt;/code&gt; es &lt;code&gt;latin1&lt;/code&gt; , las listas de enteros &lt;code&gt;0..255&lt;/code&gt; o binarios que contienen bytes sin formato se env&amp;iacute;an al cliente cuando es posible. Si la &lt;code&gt;Encoding&lt;/code&gt; es &lt;code&gt;unicode&lt;/code&gt; , se env&amp;iacute;an al cliente listas con n&amp;uacute;meros enteros en todo el rango Unicode o binarios codificados en UTF-8. La funci&amp;oacute;n proporcionada por el usuario siempre ve listas de enteros, nunca binarios, pero la lista puede contener n&amp;uacute;meros&amp;gt; 255 si la &lt;code&gt;Encoding&lt;/code&gt; es &lt;code&gt;unicode&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="795ff54ae5d53c3fcba2e08602c3c1f2e9df291a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == close&lt;/code&gt;, data is returned to the caller when the channel is closed by the server. If a time-out occurs before this happens, the function returns &lt;code&gt;{timeout,Data}&lt;/code&gt; (where &lt;code&gt;Data&lt;/code&gt; is the data received so far).</source>
          <target state="translated">Si &lt;code&gt;End == close&lt;/code&gt; , los datos se devuelven a la persona que llama cuando el servidor cierra el canal. Si ocurre un tiempo de espera antes de que esto suceda, la funci&amp;oacute;n devuelve &lt;code&gt;{timeout,Data}&lt;/code&gt; (donde &lt;code&gt;Data&lt;/code&gt; son los datos recibidos hasta el momento).</target>
        </trans-unit>
        <trans-unit id="4c405ae6dd72ff067086a677208e5abd694be786" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End == timeout&lt;/code&gt;, a time-out is expected and &lt;code&gt;{ok,Data}&lt;/code&gt; is returned both in the case of a time-out and when the channel is closed.</source>
          <target state="translated">Si &lt;code&gt;End == timeout&lt;/code&gt; , se espera un time-out y se devuelve &lt;code&gt;{ok,Data}&lt;/code&gt; tanto en el caso de un time-out como cuando el canal est&amp;aacute; cerrado.</target>
        </trans-unit>
        <trans-unit id="9a4d4ab4678c1a0d9f4a6cd0d0cd26eccd4b8374" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;End&lt;/code&gt; is a fun, this fun is called with one argument, the data value in a received &lt;code&gt;ssh_cm&lt;/code&gt; message (see &lt;code&gt;ssh_connection(3)&lt;/code&gt;. The fun is to return either &lt;code&gt;true&lt;/code&gt; to end the receiving operation (and have the so far collected data returned) or &lt;code&gt;false&lt;/code&gt; to wait for more data from the server. Even if a fun is supplied, the function returns immediately if the server closes the channel).</source>
          <target state="translated">Si &lt;code&gt;End&lt;/code&gt; es una diversi&amp;oacute;n, esta diversi&amp;oacute;n se llama con un argumento, el valor de los datos en un mensaje &lt;code&gt;ssh_cm&lt;/code&gt; recibido (consulte &lt;code&gt;ssh_connection(3)&lt;/code&gt; . La diversi&amp;oacute;n es devolver &lt;code&gt;true&lt;/code&gt; para finalizar la operaci&amp;oacute;n de recepci&amp;oacute;n (y que se devuelvan los datos recopilados hasta ahora ) o &lt;code&gt;false&lt;/code&gt; para esperar m&amp;aacute;s datos del servidor. Incluso si se proporciona una diversi&amp;oacute;n, la funci&amp;oacute;n regresa inmediatamente si el servidor cierra el canal).</target>
        </trans-unit>
        <trans-unit id="91045bcf979078e315cc68ac468e5a360ddec33a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EnumTypeName&lt;/code&gt; does not exist in the ASN.1 specification, the compilation stops with an error code.</source>
          <target state="translated">Si &lt;code&gt;EnumTypeName&lt;/code&gt; no existe en la especificaci&amp;oacute;n ASN.1, la compilaci&amp;oacute;n se detiene con un c&amp;oacute;digo de error.</target>
        </trans-unit>
        <trans-unit id="bd759ced4b466f7b939196360d08509e4b762583" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6ac5b0475b7a71717a3a976c82dd686c7a2b338" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt;, the event manager is registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;. If no name is provided, the event manager is not registered.</source>
          <target state="translated">Si &lt;code&gt;EventMgrName={global,GlobalName}&lt;/code&gt; , el administrador de eventos se registra globalmente como &lt;code&gt;GlobalName&lt;/code&gt; usando &lt;code&gt;global:register_name/2&lt;/code&gt; . Si no se proporciona un nombre, el administrador de eventos no est&amp;aacute; registrado.</target>
        </trans-unit>
        <trans-unit id="145008a8fe8d11833ffba04465b46c305eac398a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt;, the event manager is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;EventMgrName={local,Name}&lt;/code&gt; , el administrador de eventos se registra localmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c1d48cb710ca1d3e34d2637a454ccf4af2333759" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt;, the event manager registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave as the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Si &lt;code&gt;EventMgrName={via,Module,ViaName}&lt;/code&gt; , el administrador de eventos se registra en el registro representado por &lt;code&gt;Module&lt;/code&gt; . La devoluci&amp;oacute;n de llamada del &lt;code&gt;Module&lt;/code&gt; es para exportar las funciones &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; y &lt;code&gt;send/2&lt;/code&gt; , que se comportar&amp;aacute;n como las funciones correspondientes en &lt;code&gt;global&lt;/code&gt; . Por lo tanto, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; es una referencia v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="9ad87f8334c21e8f203f8f813c8a18649ff573f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e635b8f737737ba5a05f0c993e3dfac9ac242c2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;EventType&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt;, the caller waits for a reply. The reply can be sent from this or from any other &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; by returning with &lt;code&gt;{reply,From,Reply}&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt;, in &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt;, or by calling &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;EventType&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;#type-event_type&quot;&gt;{call,From}&lt;/a&gt;&lt;/code&gt; , la persona que llama espera una respuesta. La respuesta se puede enviar desde este o desde cualquier otro &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;state callback&lt;/a&gt;&lt;/code&gt; de llamada regresando con &lt;code&gt;{reply,From,Reply}&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;Actions&lt;/a&gt;&lt;/code&gt; , en &lt;code&gt;&lt;a href=&quot;#type-reply_action&quot;&gt;Replies&lt;/a&gt;&lt;/code&gt; o llamando a &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply(From, Reply)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="83ef91cec4b18110476efaead7f796da1eca29a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Expr1&lt;/code&gt; evaluates to a name, but this name is not registered, a &lt;code&gt;badarg&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Si &lt;code&gt;Expr1&lt;/code&gt; se eval&amp;uacute;a como un nombre, pero este nombre no est&amp;aacute; registrado, se produce un error de tiempo de ejecuci&amp;oacute;n &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abad608745399cb2e4372968eab18b8ca631a3c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ExprF&lt;/code&gt; is an atom, the function is said to be called by using the &lt;strong&gt;implicitly qualified function name&lt;/strong&gt;. If the function &lt;code&gt;ExprF&lt;/code&gt; is locally defined, it is called. Alternatively, if &lt;code&gt;ExprF&lt;/code&gt; is explicitly imported from the &lt;code&gt;M&lt;/code&gt; module, &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; is called. If &lt;code&gt;ExprF&lt;/code&gt; is neither declared locally nor explicitly imported, &lt;code&gt;ExprF&lt;/code&gt; must be the name of an automatically imported BIF.</source>
          <target state="translated">Si &lt;code&gt;ExprF&lt;/code&gt; es un &amp;aacute;tomo, se dice que la funci&amp;oacute;n se llama utilizando el &lt;strong&gt;nombre de funci&amp;oacute;n calificado impl&amp;iacute;citamente&lt;/strong&gt; . Si la funci&amp;oacute;n &lt;code&gt;ExprF&lt;/code&gt; est&amp;aacute; definida localmente, se llama. Alternativamente, si &lt;code&gt;ExprF&lt;/code&gt; se importa expl&amp;iacute;citamente desde el m&amp;oacute;dulo &lt;code&gt;M&lt;/code&gt; , se &lt;code&gt;M:ExprF(Expr1,...,ExprN)&lt;/code&gt; . Si &lt;code&gt;ExprF&lt;/code&gt; no se declara localmente ni se importa expl&amp;iacute;citamente, &lt;code&gt;ExprF&lt;/code&gt; debe ser el nombre de un BIF importado autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="292de33996b21603ce18c953090ce4d3bb28c1aa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the matching events are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the matching events are stopped.</source>
          <target state="translated">Si &lt;code&gt;Extra&lt;/code&gt; es &lt;code&gt;log&lt;/code&gt; , se permiten los eventos coincidentes. Si &lt;code&gt;Extra&lt;/code&gt; se &lt;code&gt;stop&lt;/code&gt; , los eventos coincidentes se detienen.</target>
        </trans-unit>
        <trans-unit id="0c63a514bfa0d0eec024a84c5585b4db685eb8d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;log&lt;/code&gt;, the progress reports are allowed. If &lt;code&gt;Extra&lt;/code&gt; is &lt;code&gt;stop&lt;/code&gt;, the progress reports are stopped.</source>
          <target state="translated">Si &lt;code&gt;Extra&lt;/code&gt; es &lt;code&gt;log&lt;/code&gt; , se permiten los informes de progreso. Si &lt;code&gt;Extra&lt;/code&gt; se &lt;code&gt;stop&lt;/code&gt; , los informes de progreso se detienen.</target>
        </trans-unit>
        <trans-unit id="676697b8c810137bc5f3cbd3dba9cf47ed56934a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;P&lt;/code&gt;, or &lt;code&gt;Pad&lt;/code&gt; is a &lt;code&gt;*&lt;/code&gt; character, the next argument in &lt;code&gt;Data&lt;/code&gt; is used as the value. For example:</source>
          <target state="translated">Si &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;P&lt;/code&gt; o &lt;code&gt;Pad&lt;/code&gt; es un car&amp;aacute;cter &lt;code&gt;*&lt;/code&gt; , el siguiente argumento en &lt;code&gt;Data&lt;/code&gt; se usa como valor. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="58d27e8ccd9fb7397c53540d079879af93136abc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FIPS_mode_set&lt;/code&gt; returns &lt;code&gt;no&lt;/code&gt; the OpenSSL library is not FIPS enabled and crypto won't support FIPS mode either.</source>
          <target state="translated">Si &lt;code&gt;FIPS_mode_set&lt;/code&gt; devuelve &lt;code&gt;no&lt;/code&gt; , la biblioteca OpenSSL no est&amp;aacute; habilitada para FIPS y el cifrado tampoco admitir&amp;aacute; el modo FIPS.</target>
        </trans-unit>
        <trans-unit id="03e0cd5df5f6d73de87e5cdb82e5a381f90cc69f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is equal to the index set of &lt;code&gt;Family1&lt;/code&gt;, and &lt;code&gt;Family3&lt;/code&gt;[i] is the difference between &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if &lt;code&gt;Family2&lt;/code&gt; maps i, otherwise &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; y &lt;code&gt;Family2&lt;/code&gt; son &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;Family3&lt;/code&gt; es la familia de modo que el conjunto de &amp;iacute;ndices es igual al conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 y &lt;code&gt;Family3&lt;/code&gt; [i] es la diferencia entre &lt;code&gt;Family1&lt;/code&gt; [i] y &lt;code&gt;Family2&lt;/code&gt; [i] si &lt;code&gt;Family2&lt;/code&gt; asigna i; de lo contrario &lt;code&gt;Family1[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="707694b53f4e6ff34f03b06100b8fc3bb1a63a00" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the intersection of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the intersection of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; y &lt;code&gt;Family2&lt;/code&gt; son &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;Family3&lt;/code&gt; es la familia tal que el conjunto de &amp;iacute;ndices es la intersecci&amp;oacute;n de los &lt;code&gt;Family1&lt;/code&gt; de &amp;iacute;ndices Familia1 : sy &lt;code&gt;Family2&lt;/code&gt; : s, y &lt;code&gt;Family3&lt;/code&gt; [i] es la intersecci&amp;oacute;n de &lt;code&gt;Family1&lt;/code&gt; [i] y &lt;code&gt;Family2&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="c3481789d9f11af86121200c69343c46693c383d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; and &lt;code&gt;Family2&lt;/code&gt; are &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family3&lt;/code&gt; is the family such that the index set is the union of &lt;code&gt;Family1&lt;/code&gt;:s and &lt;code&gt;Family2&lt;/code&gt;:s index sets, and &lt;code&gt;Family3&lt;/code&gt;[i] is the union of &lt;code&gt;Family1&lt;/code&gt;[i] and &lt;code&gt;Family2&lt;/code&gt;[i] if both map i, otherwise &lt;code&gt;Family1&lt;/code&gt;[i] or &lt;code&gt;Family2&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; y &lt;code&gt;Family2&lt;/code&gt; son &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;families&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;Family3&lt;/code&gt; es la familia de modo que el conjunto de &amp;iacute;ndices es la uni&amp;oacute;n de los &lt;code&gt;Family1&lt;/code&gt; de &amp;iacute;ndices de Familia1 : sy &lt;code&gt;Family2&lt;/code&gt; : s, y &lt;code&gt;Family3&lt;/code&gt; [i] es la uni&amp;oacute;n de &lt;code&gt;Family1&lt;/code&gt; [i] y &lt;code&gt;Family2&lt;/code&gt; [i] si ambos mapean i, de lo contrario, &lt;code&gt;Family1&lt;/code&gt; [i] o &lt;code&gt;Family2&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="901cb0563eae4ae927b85e3235bb204abe3eeb2a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1[i]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es una relaci&amp;oacute;n binaria para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es el &lt;code&gt;&lt;a href=&quot;#domain&quot;&gt;domain&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1[i]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10edd17f93cf8b662a14cd64ee029b216f69998c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es una relaci&amp;oacute;n binaria para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es el &lt;code&gt;&lt;a href=&quot;#field&quot;&gt;field&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i] .</target>
        </trans-unit>
        <trans-unit id="603f807d85acd930990c4dcffafa135bbe46960c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a binary relation for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es una relaci&amp;oacute;n binaria para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es el &lt;code&gt;&lt;a href=&quot;#range&quot;&gt;range&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i] .</target>
        </trans-unit>
        <trans-unit id="df7eb7122ac171a82f2f5b7eabda31d098834629" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for each i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es un conjunto de conjuntos para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es la &lt;code&gt;&lt;a href=&quot;#union_n&quot;&gt;union&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i ].</target>
        </trans-unit>
        <trans-unit id="9f6dbbe306d7fe1ab285e45f10bed30dc90b32b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;Family1&lt;/code&gt;[i] is a set of sets for every i in the index set of &lt;code&gt;Family1&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Family1&lt;/code&gt; [i] es un conjunto de conjuntos para cada i en el conjunto de &lt;code&gt;Family1&lt;/code&gt; de Familia1 , entonces &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; modo que &lt;code&gt;Family2&lt;/code&gt; [i] es la &lt;code&gt;&lt;a href=&quot;#intersection_n&quot;&gt;intersection&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i ].</target>
        </trans-unit>
        <trans-unit id="6513fd3da5029f77ec7aae42fce09531984adc2d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt; to those elements i of the index set for which &lt;code&gt;Fun&lt;/code&gt; applied to &lt;code&gt;Family1&lt;/code&gt;[i] returns &lt;code&gt;true&lt;/code&gt;. If &lt;code&gt;Fun&lt;/code&gt; is a tuple &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt;, then &lt;code&gt;Fun2&lt;/code&gt; is applied to the &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Family1&lt;/code&gt;[i], otherwise &lt;code&gt;Fun&lt;/code&gt; is applied to &lt;code&gt;Family1&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;Family2&lt;/code&gt; es la &lt;code&gt;&lt;a href=&quot;#restriction&quot;&gt;restriction&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; a los elementos i del conjunto de &amp;iacute;ndices para los que &lt;code&gt;Fun&lt;/code&gt; aplicado a &lt;code&gt;Family1&lt;/code&gt; [i] devuelve &lt;code&gt;true&lt;/code&gt; . Si &lt;code&gt;Fun&lt;/code&gt; es una tupla &lt;code&gt;{external,&amp;nbsp;Fun2}&lt;/code&gt; , &lt;code&gt;Fun2&lt;/code&gt; se aplica al &lt;code&gt;&lt;a href=&quot;#external_set&quot;&gt;external set&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Family1&lt;/code&gt; [i]; de lo contrario, &lt;code&gt;Fun&lt;/code&gt; se aplica a &lt;code&gt;Family1&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="0036be6edcb9af44b23cf453b297b5ff3815e4ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;Family2&lt;/code&gt; is the family with the same index set as &lt;code&gt;Family1&lt;/code&gt; such that &lt;code&gt;Family2&lt;/code&gt;[i] is the result of calling &lt;code&gt;SetFun&lt;/code&gt; with &lt;code&gt;Family1&lt;/code&gt;[i] as argument.</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;Family2&lt;/code&gt; es la familia con el mismo conjunto de &amp;iacute;ndices que &lt;code&gt;Family1&lt;/code&gt; ,de modo que &lt;code&gt;Family2&lt;/code&gt; [i] es el resultado de llamar a &lt;code&gt;SetFun&lt;/code&gt; con &lt;code&gt;Family1&lt;/code&gt; [i] como argumento.</target>
        </trans-unit>
        <trans-unit id="a3ed4a237eeb2ac6e0edeeca8e08129966f3f00f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family1&lt;/code&gt;[i] is an empty set for some i, the process exits with a &lt;code&gt;badarg&lt;/code&gt; message.</source>
          <target state="translated">Si &lt;code&gt;Family1&lt;/code&gt; [i] es un conjunto vac&amp;iacute;o para alguna i, el proceso sale con un mensaje &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15ab50a2f9b83c85c1bf92e12df53a14b6fa72a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Family&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;BinRel&lt;/code&gt; is the binary relation containing all pairs (i, x) such that i belongs to the index set of &lt;code&gt;Family&lt;/code&gt; and x belongs to &lt;code&gt;Family&lt;/code&gt;[i].</source>
          <target state="translated">Si &lt;code&gt;Family&lt;/code&gt; es una &lt;code&gt;&lt;a href=&quot;#family&quot;&gt;family&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;BinRel&lt;/code&gt; es la relaci&amp;oacute;n binaria que contiene todos los pares (i, x) de manera que i pertenece al conjunto de &amp;iacute;ndices de &lt;code&gt;Family&lt;/code&gt; yx pertenece a &lt;code&gt;Family&lt;/code&gt; [i].</target>
        </trans-unit>
        <trans-unit id="8cca7739eb38698717638b6eb6af393def280970" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;File&lt;/code&gt; is not specified, a file dialog is opened where the crashdump can be selected.</source>
          <target state="translated">Si &lt;code&gt;File&lt;/code&gt; no se especifica, un di&amp;aacute;logo de archivo se abre en el que el volcado de bloqueo puede ser seleccionado.</target>
        </trans-unit>
        <trans-unit id="64e8f8682c5f33b6a09cda03b8458e6523b8dd31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; cannot be run, an error exception is raised, with the POSIX error code as the reason. The error reason can differ between OSs. Typically the error &lt;code&gt;enoent&lt;/code&gt; is raised when an attempt is made to run a program that is not found and &lt;code&gt;eacces&lt;/code&gt; is raised when the specified file is not executable.</source>
          <target state="translated">Si &lt;code&gt;FileName&lt;/code&gt; no se puede ejecutar, se genera una excepci&amp;oacute;n de error, con el c&amp;oacute;digo de error POSIX como motivo. El motivo del error puede diferir entre los sistemas operativos. Normalmente, el error &lt;code&gt;enoent&lt;/code&gt; se genera cuando se intenta ejecutar un programa que no se encuentra y &lt;code&gt;eacces&lt;/code&gt; se genera cuando el archivo especificado no es ejecutable.</target>
        </trans-unit>
        <trans-unit id="d64f4daf12cc430f6c5ecc07bc1247a82079bedd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileName&lt;/code&gt; has a suffix that indicates an object file (&lt;code&gt;.beam&lt;/code&gt;), EUnit will try to reload the module from the specified file and test it. Otherwise, the file is assumed to be a text file containing test specifications, which will be read using the standard library function &lt;code&gt;file:path_consult/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;FileName&lt;/code&gt; tiene un sufijo que indica un archivo de objeto ( &lt;code&gt;.beam&lt;/code&gt; ), EUnit intentar&amp;aacute; recargar el m&amp;oacute;dulo desde el archivo especificado y probarlo. De lo contrario, se supone que el archivo es un archivo de texto que contiene especificaciones de prueba, que se leer&amp;aacute;n utilizando el &lt;code&gt;file:path_consult/2&lt;/code&gt; funci&amp;oacute;n de biblioteca est&amp;aacute;ndar : path_consult / 2 .</target>
        </trans-unit>
        <trans-unit id="f69d9680f0ea2ac6663d58bccc19bea7f9110950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is a &lt;code&gt;string()&lt;/code&gt;, &lt;code&gt;make_config/1&lt;/code&gt; will use &lt;code&gt;FileNameOrIODev&lt;/code&gt; as a filename. A file named &lt;code&gt;FileNameOrIODev&lt;/code&gt; is created and the configuration will be written to that file. If &lt;code&gt;FileNameOrIODev&lt;/code&gt; is an &lt;code&gt;io_device()&lt;/code&gt; (see the documentation of the module &lt;code&gt;io&lt;/code&gt;), the configuration will be written to the io device.</source>
          <target state="translated">Si &lt;code&gt;FileNameOrIODev&lt;/code&gt; es una &lt;code&gt;string()&lt;/code&gt; , &lt;code&gt;make_config/1&lt;/code&gt; usar&amp;aacute; &lt;code&gt;FileNameOrIODev&lt;/code&gt; como nombre de archivo. Se crea un archivo llamado &lt;code&gt;FileNameOrIODev&lt;/code&gt; y la configuraci&amp;oacute;n se escribir&amp;aacute; en ese archivo. Si &lt;code&gt;FileNameOrIODev&lt;/code&gt; es un &lt;code&gt;io_device()&lt;/code&gt; (consulte la documentaci&amp;oacute;n del m&amp;oacute;dulo &lt;code&gt;io&lt;/code&gt; ), la configuraci&amp;oacute;n se escribir&amp;aacute; en el dispositivo io.</target>
        </trans-unit>
        <trans-unit id="abe7ea2e6f95f6e74b291e53017c69e3872b70e5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Filename&lt;/code&gt; is not a symbolic link, this function returns exactly the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Filename&lt;/code&gt; no es un enlace simb&amp;oacute;lico, esta funci&amp;oacute;n devuelve exactamente el mismo resultado que &lt;code&gt;read_file_info/1&lt;/code&gt; . En plataformas que no admiten enlaces simb&amp;oacute;licos, esta funci&amp;oacute;n siempre es equivalente a &lt;code&gt;read_file_info/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="abb890f105737b8f693a0a5c7d392809221b9ef6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fix&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, table &lt;code&gt;Name&lt;/code&gt; is fixed (once more) by the calling process, otherwise the table is released. The table is also released when a fixing process terminates.</source>
          <target state="translated">Si &lt;code&gt;Fix&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el &lt;code&gt;Name&lt;/code&gt; tabla se fija (una vez m&amp;aacute;s) por el proceso de llamada; de lo contrario, la tabla se libera. La tabla tambi&amp;eacute;n se libera cuando finaliza un proceso de reparaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="35e7f62cf2a411f7548edbc78f5bda5268f86881" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;get&lt;/code&gt;, a list of all logged events is returned.</source>
          <target state="translated">Si se &lt;code&gt;get&lt;/code&gt; &lt;code&gt;Flag&lt;/code&gt; , se devuelve una lista de todos los eventos registrados.</target>
        </trans-unit>
        <trans-unit id="381028fa2c7469ac85a20d5087b1b0fd8afdf82e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;print&lt;/code&gt;, the logged events are printed to &lt;code&gt;standard_io&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;print&lt;/code&gt; &lt;code&gt;Flag&lt;/code&gt; , los eventos registrados se imprimen en &lt;code&gt;standard_io&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b722fce5cc319fa08cae29348ebef98f92c444d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a new subscription is started. If &lt;code&gt;Flag&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, all previous subscriptions started with the same &lt;code&gt;Options&lt;/code&gt; are stopped. Two option lists are considered the same if they contain the same set of options.</source>
          <target state="translated">Si &lt;code&gt;Flag&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , se inicia una nueva suscripci&amp;oacute;n. Si &lt;code&gt;Flag&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , se detienen todas las suscripciones anteriores iniciadas con las mismas &lt;code&gt;Options&lt;/code&gt; . Dos listas de opciones se consideran iguales si contienen el mismo conjunto de opciones.</target>
        </trans-unit>
        <trans-unit id="7ca78e84b760984f52335bac15cc8a1e618b6c52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flags = all&lt;/code&gt;, all possible flags are set.</source>
          <target state="translated">Si &lt;code&gt;Flags = all&lt;/code&gt; , se establecen todos los indicadores posibles.</target>
        </trans-unit>
        <trans-unit id="2613d68b6d252e8fa327001ad657894c48452d47" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;finish&lt;/code&gt;, pending input is processed, pending output is flushed, and &lt;code&gt;deflate/3&lt;/code&gt; returns. Afterwards the only possible operations on the stream are &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Flush&lt;/code&gt; est&amp;aacute; configurado para &lt;code&gt;finish&lt;/code&gt; , la entrada pendiente se procesa, la salida pendiente se vac&amp;iacute;a y se &lt;code&gt;deflate/3&lt;/code&gt; . Posteriormente, las &amp;uacute;nicas operaciones posibles en la secuencia son &lt;code&gt;&lt;a href=&quot;#deflateReset-1&quot;&gt;deflateReset/1&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#deflateEnd-1&quot;&gt;deflateEnd/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a28ee970d5c9d1771957ed2098a6a9bd614a23c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;full&lt;/code&gt;, all output is flushed as with &lt;code&gt;sync&lt;/code&gt;, and the compression state is reset so that decompression can restart from this point if previous compressed data has been damaged or if random access is desired. Using &lt;code&gt;full&lt;/code&gt; too often can seriously degrade the compression.</source>
          <target state="translated">Si &lt;code&gt;Flush&lt;/code&gt; se establece en &lt;code&gt;full&lt;/code&gt; , toda la salida se vac&amp;iacute;a como con la &lt;code&gt;sync&lt;/code&gt; , y el estado de compresi&amp;oacute;n se restablece para que la descompresi&amp;oacute;n pueda reiniciarse desde este punto si los datos comprimidos anteriores se han da&amp;ntilde;ado o si se desea un acceso aleatorio. El uso &lt;code&gt;full&lt;/code&gt; demasiada frecuencia puede degradar seriamente la compresi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5b162b87236f918abd12b2632484cedd86b7642d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Flush&lt;/code&gt; is set to &lt;code&gt;sync&lt;/code&gt;, all pending output is flushed to the output buffer and the output is aligned on a byte boundary, so that the decompressor can get all input data available so far. Flushing can degrade compression for some compression algorithms; thus, use it only when necessary.</source>
          <target state="translated">Si &lt;code&gt;Flush&lt;/code&gt; est&amp;aacute; configurado para &lt;code&gt;sync&lt;/code&gt; , toda la salida pendiente se vac&amp;iacute;a en el b&amp;uacute;fer de salida y la salida se alinea en un l&amp;iacute;mite de bytes, de modo que el descompresor pueda obtener todos los datos de entrada disponibles hasta el momento. El lavado puede degradar la compresi&amp;oacute;n de algunos algoritmos de compresi&amp;oacute;n; por lo tanto, util&amp;iacute;celo solo cuando sea necesario.</target>
        </trans-unit>
        <trans-unit id="3748c496d0aee0e31ef9623ffe6c9c459e673128" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to load each mib even after failing to load a previous mib. Use with care.</source>
          <target state="translated">Si &lt;code&gt;Force = true&lt;/code&gt; , el agente seguir&amp;aacute; intentando cargar cada mib incluso despu&amp;eacute;s de no poder cargar un mib anterior. &amp;Uacute;selo con cuidado.</target>
        </trans-unit>
        <trans-unit id="2cad12b8139e1623aaeb8a5ccd722b61cea66f96" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Force = true&lt;/code&gt; then the agent will continue attempting to unload each mib even after failing to unload a previous mib. Use with care.</source>
          <target state="translated">Si &lt;code&gt;Force = true&lt;/code&gt; , el agente seguir&amp;aacute; intentando descargar cada mib incluso despu&amp;eacute;s de no poder descargar un mib anterior. &amp;Uacute;selo con cuidado.</target>
        </trans-unit>
        <trans-unit id="7d0a736a5ea9ae64f8bc28b164008b5e41f8db91" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt;, &lt;code&gt;et_viewer&lt;/code&gt; in application ET is used for presenting the trace log graphically. &lt;code&gt;ttb&lt;/code&gt; provides a few different filters that can be selected from menu &lt;strong&gt;Filters and scaling&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;FormatHandler = get_et_handler()&lt;/code&gt; , &lt;code&gt;et_viewer&lt;/code&gt; en la aplicaci&amp;oacute;n ET se utiliza para presentar el registro de seguimiento de forma gr&amp;aacute;fica. &lt;code&gt;ttb&lt;/code&gt; proporciona algunos filtros diferentes que se pueden seleccionar en el men&amp;uacute; &lt;strong&gt;Filtros y escalado&lt;/strong&gt; en &lt;code&gt;et_viewer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="754c4ebe3c963dad574555e13a437f625208b390" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt; is called for each trace message.</source>
          <target state="translated">Si &lt;code&gt;FormatHandler = {Function,InitialState}&lt;/code&gt; , se llama a la &lt;code&gt;Function&lt;/code&gt; para cada mensaje de seguimiento.</target>
        </trans-unit>
        <trans-unit id="e464e53752a8478fcd48d7d7806a6c052a202fab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;FormatHandler&lt;/code&gt; is not specified, a default handler is used presenting each trace message as a text line.</source>
          <target state="translated">Si no se especifica &lt;code&gt;FormatHandler&lt;/code&gt; , se utiliza un controlador predeterminado que presenta cada mensaje de seguimiento como una l&amp;iacute;nea de texto.</target>
        </trans-unit>
        <trans-unit id="52add321b909cb81e422136ee5da910496779dbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Forms&lt;/code&gt; is a syntax tree of some other type than &lt;code&gt;form_list&lt;/code&gt;, the comments will be inserted directly using &lt;code&gt;recomment_tree/2&lt;/code&gt;, and any comments left over from that process are added as postcomments on the result.</source>
          <target state="translated">Si &lt;code&gt;Forms&lt;/code&gt; es un &amp;aacute;rbol de sintaxis de alg&amp;uacute;n otro tipo que &lt;code&gt;form_list&lt;/code&gt; sea form_list , los comentarios se insertar&amp;aacute;n directamente usando &lt;code&gt;recomment_tree/2&lt;/code&gt; , y cualquier comentario que quede de ese proceso se agregar&amp;aacute; como comentarios posteriores al resultado.</target>
        </trans-unit>
        <trans-unit id="c4eba9b5275105788875dd801e1636ad9a4cb30f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun(Item)&lt;/code&gt; returns &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is copied to the result queue. If it returns &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Item&lt;/code&gt; is not copied. If it returns a list, the list elements are inserted instead of &lt;code&gt;Item&lt;/code&gt; in the result queue.</source>
          <target state="translated">Si &lt;code&gt;Fun(Item)&lt;/code&gt; devuelve &lt;code&gt;true&lt;/code&gt; , el &lt;code&gt;Item&lt;/code&gt; se copia a la cola de resultados. Si devuelve &lt;code&gt;false&lt;/code&gt; , el &lt;code&gt;Item&lt;/code&gt; no se copia. Si devuelve una lista, los elementos de la lista se insertan en lugar del &lt;code&gt;Item&lt;/code&gt; en la cola de resultados.</target>
        </trans-unit>
        <trans-unit id="366fc356581d7fe3b943ae954f2a4d6cf716ab8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Module&lt;/code&gt; is the module in which the fun is defined.</source>
          <target state="translated">Si la &lt;code&gt;Fun&lt;/code&gt; es una diversi&amp;oacute;n local, el &lt;code&gt;Module&lt;/code&gt; es el m&amp;oacute;dulo en el que se define la diversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1842cf53be67683035afaacc37fa7bea8be6bb1b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is a local fun, &lt;code&gt;Name&lt;/code&gt; is the name of the local function that implements the fun. (This name was generated by the compiler, and is only of informational use. As it is a local function, it cannot be called directly.) If no code is currently loaded for the fun, &lt;code&gt;[]&lt;/code&gt; is returned instead of an atom.</source>
          <target state="translated">Si &lt;code&gt;Fun&lt;/code&gt; es una diversi&amp;oacute;n local, &lt;code&gt;Name&lt;/code&gt; es el nombre de la funci&amp;oacute;n local que implementa la diversi&amp;oacute;n. (Este nombre fue generado por el compilador y es solo para uso informativo. Como es una funci&amp;oacute;n local, no se puede llamar directamente). Si no hay ning&amp;uacute;n c&amp;oacute;digo cargado actualmente para la diversi&amp;oacute;n, se devuelve &lt;code&gt;[]&lt;/code&gt; en lugar de un &amp;aacute;tomo.</target>
        </trans-unit>
        <trans-unit id="5f28f2ecd1a2a78b09a1a1bba86bfe7cd1e5abac" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Module&lt;/code&gt; is the module that the fun refers to.</source>
          <target state="translated">Si la &lt;code&gt;Fun&lt;/code&gt; es una diversi&amp;oacute;n externa, el &lt;code&gt;Module&lt;/code&gt; es el m&amp;oacute;dulo al que se refiere la diversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7a891fa1f8c1fc67f4bfac48d75e87475a7bea29" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Fun&lt;/code&gt; is an external fun, &lt;code&gt;Name&lt;/code&gt; is the name of the exported function that the fun refers to.</source>
          <target state="translated">Si &lt;code&gt;Fun&lt;/code&gt; es una diversi&amp;oacute;n externa, &lt;code&gt;Name&lt;/code&gt; es el nombre de la funci&amp;oacute;n exportada a la que se refiere la diversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c30588de4c7f0612e073a3883c335ac9373ebde3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Function&lt;/code&gt; inserts objects into the table, or another process inserts objects into the table, those objects &lt;strong&gt;can&lt;/strong&gt; (depending on key ordering) be included in the traversal.</source>
          <target state="translated">Si &lt;code&gt;Function&lt;/code&gt; inserta objetos en la tabla, u otro proceso inserta objetos en la tabla, esos objetos &lt;strong&gt;pueden&lt;/strong&gt; (seg&amp;uacute;n el orden de las teclas) incluirse en el recorrido.</target>
        </trans-unit>
        <trans-unit id="8903d3c31d338fd3102b10a98c169c7def053e70" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;HandlerId&lt;/code&gt; is &lt;code&gt;default&lt;/code&gt;, then this entry modifies the default handler, equivalent to calling</source>
          <target state="translated">Si &lt;code&gt;HandlerId&lt;/code&gt; es el &lt;code&gt;default&lt;/code&gt; , esta entrada modifica el controlador predeterminado, equivalente a llamar</target>
        </trans-unit>
        <trans-unit id="900d11629569ab220c3331823293a0c6bc8ed798" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How == read&lt;/code&gt; or there is no outgoing data buffered in the &lt;code&gt;Socket&lt;/code&gt; port, the socket is shut down immediately and any error encountered is returned in &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;How == read&lt;/code&gt; o no hay datos salientes almacenados en b&amp;uacute;fer en el puerto de &lt;code&gt;Socket&lt;/code&gt; , el socket se apaga inmediatamente y cualquier error encontrado se devuelve en &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c71e7f1f85187ddc4b81962dde74a95d9e96b0d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;How&lt;/code&gt; is not one of the documented alternatives.</source>
          <target state="translated">Si &lt;code&gt;How&lt;/code&gt; no es una de las alternativas documentadas.</target>
        </trans-unit>
        <trans-unit id="37742d0df7de57a88343a93bbae5c582e200b4bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;I&lt;/code&gt; is not a non-negative integer, or if the array has fixed size and &lt;code&gt;I&lt;/code&gt; is larger than the maximum index, the call fails with reason &lt;code&gt;badarg&lt;/code&gt;; compare &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Si &lt;code&gt;I&lt;/code&gt; no es un n&amp;uacute;mero entero no negativo, o si la matriz tiene un tama&amp;ntilde;o fijo y &lt;code&gt;I&lt;/code&gt; es mayor que el &amp;iacute;ndice m&amp;aacute;ximo, la llamada falla con el motivo &lt;code&gt;badarg&lt;/code&gt; ; comparar &lt;code&gt;&lt;a href=&quot;#set-3&quot;&gt;set/3&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b40958d947f1e3e1dfb64d8ec37bb529fd8c2ab3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IV = &amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;, no IV is used. This is intended for ciphers without an IV (nounce). See &lt;code&gt;&lt;a href=&quot;#crypto_init-3&quot;&gt;crypto_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17757dd0369fed1b521cdc06c576ee0641e25d48" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IV = undefined&lt;/code&gt;, the IV must be added by calls to &lt;code&gt;&lt;a href=&quot;crypto#crypto_dyn_iv_update-3&quot;&gt;crypto_dyn_iv_update/3&lt;/a&gt;&lt;/code&gt;. This is intended for cases where the IV (nounce) need to be changed for each encryption and decryption. See &lt;code&gt;&lt;a href=&quot;#crypto_dyn_iv_init-3&quot;&gt;crypto_dyn_iv_init/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192de0c6fdc2dc6ed90c9948b113d350638c9ee6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt; casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff9833c3a956d76bfddbabd05552d4c92a4ea96e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt; the function does &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; on the fly before the equality test.</source>
          <target state="translated">Si &lt;code&gt;IgnoreCase&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; la funci&amp;oacute;n realiza el &lt;code&gt;&lt;a href=&quot;#casefold-1&quot;&gt;casefolding&lt;/a&gt;&lt;/code&gt; de casos sobre la marcha antes de la prueba de igualdad.</target>
        </trans-unit>
        <trans-unit id="816e7270d9b2f0ac993fa2ef79b1a16b6e25ce74" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, an error occurs whenever an integer &amp;gt; 255 is found in the lists.</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es &lt;code&gt;latin1&lt;/code&gt; , un error se produce siempre un n&amp;uacute;mero entero&amp;gt; 255 se encuentra en las listas.</target>
        </trans-unit>
        <trans-unit id="4425120ccc2526ec06a49a423343d05e8207c756" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, binaries are always valid as long as they contain whole bytes, as each byte falls into the valid ISO Latin-1 range.</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es &lt;code&gt;latin1&lt;/code&gt; , binarios son siempre v&amp;aacute;lidos, siempre que contienen bytes completos, ya que cada byte cae en el rango v&amp;aacute;lido ISO Latin-1.</target>
        </trans-unit>
        <trans-unit id="ff1d0ed37f6966c578d637dcaf03e020ca40d09f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is &lt;code&gt;latin1&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; corresponds to the &lt;code&gt;iodata()&lt;/code&gt; type, but for &lt;code&gt;unicode&lt;/code&gt;, parameter &lt;code&gt;Data&lt;/code&gt; can contain integers &amp;gt; 255 (Unicode characters beyond the ISO Latin-1 range), which makes it invalid as &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es &lt;code&gt;latin1&lt;/code&gt; , par&amp;aacute;metros &lt;code&gt;Data&lt;/code&gt; corresponde a la &lt;code&gt;iodata()&lt;/code&gt; tipo, pero para &lt;code&gt;unicode&lt;/code&gt; , el par&amp;aacute;metro &lt;code&gt;Data&lt;/code&gt; puede contener enteros&amp;gt; 255 (caracteres Unicode m&amp;aacute;s all&amp;aacute; de la gama ISO Latin-1), lo que lo hace inv&amp;aacute;lido como &lt;code&gt;iodata()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84c8391d802fddc5ccbafb2a99174fde559e23a0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is of a Unicode type, an error occurs whenever either of the following is found:</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es de tipo Unicode, se produce un error siempre que se encuentra alguno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="476e00e23216a072f0d4f2055cfb67b48c128bef" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;InEncoding&lt;/code&gt; is one of the UTF types, the bytes in any binaries must be valid in that encoding.</source>
          <target state="translated">Si &lt;code&gt;InEncoding&lt;/code&gt; es uno de los tipos UTF, los bytes de los binarios deben ser v&amp;aacute;lidos en esa codificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="22f3829c6bb886763ec35ffd0a67a42f39f5713e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Incr =:= 0&lt;/code&gt; and &lt;code&gt;From =/= To&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Incr =:= 0&lt;/code&gt; y &lt;code&gt;From =/= To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12b35d113bc1f0b8b177b00f244bbbf3e4ac06f2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IpPort&lt;/code&gt; is omitted &lt;code&gt;162&lt;/code&gt; is used.</source>
          <target state="translated">Si se omite &lt;code&gt;IpPort&lt;/code&gt; , se utiliza &lt;code&gt;162&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="57bfc33f769c9b0a788a08b107a1cedbd213bce1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;IsDst == true&lt;/code&gt;, &lt;code&gt;Localtime&lt;/code&gt; is during Daylight Saving Time, if &lt;code&gt;IsDst == false&lt;/code&gt; it is not. If &lt;code&gt;IsDst == undefined&lt;/code&gt;, the underlying OS can guess, which is the same as calling &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;IsDst == true&lt;/code&gt; , &lt;code&gt;Localtime&lt;/code&gt; es durante el horario de verano, si &lt;code&gt;IsDst == false&lt;/code&gt; no lo es. Si &lt;code&gt;IsDst == undefined&lt;/code&gt; , el sistema operativo subyacente puede adivinar, que es lo mismo que llamar a &lt;code&gt;erlang:localtime_to_universaltime(Localtime)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d88ab1af3b32ccae8c47bc290fd76139417148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Item&lt;/code&gt; is an invalid item.</source>
          <target state="translated">Si el &lt;code&gt;Item&lt;/code&gt; es un art&amp;iacute;culo no v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="0ff6e5e0312fb6570b28f21e065635f71bd160e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ItemList&lt;/code&gt; is specified, the result is &lt;code&gt;InfoTupleList&lt;/code&gt;. The &lt;code&gt;InfoTuple&lt;/code&gt;s in &lt;code&gt;InfoTupleList&lt;/code&gt; are included with the corresponding &lt;code&gt;Item&lt;/code&gt;s in the same order as the &lt;code&gt;Item&lt;/code&gt;s were included in &lt;code&gt;ItemList&lt;/code&gt;. Valid &lt;code&gt;Item&lt;/code&gt;s can be included multiple times in &lt;code&gt;ItemList&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ItemList&lt;/code&gt; se especifica, el resultado es &lt;code&gt;InfoTupleList&lt;/code&gt; . El &lt;code&gt;InfoTuple&lt;/code&gt; s en &lt;code&gt;InfoTupleList&lt;/code&gt; est&amp;aacute;n incluidos con el correspondiente &lt;code&gt;Item&lt;/code&gt; s en el mismo orden que el &lt;code&gt;Item&lt;/code&gt; s fueron incluidos en &lt;code&gt;ItemList&lt;/code&gt; . Los &lt;code&gt;Item&lt;/code&gt; v&amp;aacute;lidos se pueden incluir varias veces en &lt;code&gt;ItemList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="af422b91ec82e2dd9338132983b67650395edbc0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; do not exists, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="translated">Si la &lt;code&gt;Key&lt;/code&gt; no existe, se crea un nuevo registro con el valor &lt;code&gt;Incr&lt;/code&gt; si es mayor que 0; de lo contrario, se establece en 0.</target>
        </trans-unit>
        <trans-unit id="c41410c8bc0b6250bb7c2a4f58129afe15bfcff0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; does not exist, a new record is created with value &lt;code&gt;Incr&lt;/code&gt; if it is larger than 0, otherwise it is set to 0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6283720a87b385d954928cf8467ee97a261a260e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Key&lt;/code&gt; exists in &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new associated value.</source>
          <target state="translated">Si la &lt;code&gt;Key&lt;/code&gt; existe en &lt;code&gt;Map1&lt;/code&gt; , el antiguo valor asociado se reemplaza por el valor &lt;code&gt;Value&lt;/code&gt; . La funci&amp;oacute;n devuelve un nuevo mapa &lt;code&gt;Map2&lt;/code&gt; que contiene el nuevo valor asociado.</target>
        </trans-unit>
        <trans-unit id="1dc230226eb63b450b632e9c874a80bd2fe8c24b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;KeyOrName&lt;/code&gt; is a configured &lt;code&gt;server_id()&lt;/code&gt; or a &lt;code&gt;target_name()&lt;/code&gt; associated with such an Id, then the options for this server are fetched from the configuration file.</source>
          <target state="translated">Si &lt;code&gt;KeyOrName&lt;/code&gt; es un &lt;code&gt;server_id()&lt;/code&gt; configurado o un &lt;code&gt;target_name()&lt;/code&gt; asociado con dicho Id, las opciones para este servidor se obtienen del archivo de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="caeb4bb064b11f2b7bb8eeb778050c5ea54186c8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LinkTo&lt;/code&gt; is a pid, it becomes an owner of the log. If &lt;code&gt;LinkTo&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;, the log records that it is used anonymously by some process by incrementing the &lt;code&gt;users&lt;/code&gt; counter. By default, the process that calls &lt;code&gt;open/1&lt;/code&gt; owns the log.</source>
          <target state="translated">Si &lt;code&gt;LinkTo&lt;/code&gt; es un pid, se convierte en propietario del registro. Si &lt;code&gt;LinkTo&lt;/code&gt; es &lt;code&gt;none&lt;/code&gt; , el registro registra que alg&amp;uacute;n proceso lo usa de forma an&amp;oacute;nima aumentando el contador de &lt;code&gt;users&lt;/code&gt; . De forma predeterminada, el proceso que llama a &lt;code&gt;open/1&lt;/code&gt; es el propietario del registro.</target>
        </trans-unit>
        <trans-unit id="9888882ab2a6e6b491af7cf81626c46b51b8c093" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ListOfBinRels&lt;/code&gt; is a non-empty list [R[1], ..., R[n]] of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ListOfBinRels&lt;/code&gt; es una lista no vac&amp;iacute;a [R [1], ..., R [n]] de relaciones binarias y &lt;code&gt;BinRel1&lt;/code&gt; es una relaci&amp;oacute;n binaria, entonces &lt;code&gt;BinRel2&lt;/code&gt; es el &lt;code&gt;&lt;a href=&quot;#tuple_relative_product&quot;&gt;relative product&lt;/a&gt;&lt;/code&gt; del conjunto ordenado (R [i] ,. .., R [n]) y &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e6668fcef53284c1666f849594130ecb9a9e9189" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Loader&lt;/code&gt; is something else, the user-supplied &lt;code&gt;Loader&lt;/code&gt; port program is started.</source>
          <target state="translated">Si &lt;code&gt;Loader&lt;/code&gt; es otra cosa, se inicia el programa de puerto &lt;code&gt;Loader&lt;/code&gt; proporcionado por el usuario .</target>
        </trans-unit>
        <trans-unit id="4902233d819e3e7d17b192cdb14eea6c3a8ffc0d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a binary, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. The binary is transferred block by block and the number of transferred bytes is returned in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es un binario, &lt;code&gt;tftp_binary&lt;/code&gt; se usa como m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada. El binario se transfiere bloque por bloque y el n&amp;uacute;mero de bytes transferidos se devuelve en &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="514092af0b1076e970f978d5d6c41dea98a0f33d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It reads the file named &lt;code&gt;LocalFilename&lt;/code&gt; block by block and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es una cadena y no hay m&amp;oacute;dulos de devoluci&amp;oacute;n de llamada registrados, &lt;code&gt;tftp_file&lt;/code&gt; se utiliza como m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada. Lee el archivo llamado &lt;code&gt;LocalFilename&lt;/code&gt; bloque por bloque y devuelve el n&amp;uacute;mero de bytes transferidos en &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="172a77adcec95a2025499b6cae24513646d7c3be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are no registered callback modules, &lt;code&gt;tftp_file&lt;/code&gt; is used as callback module. It writes each transferred block to the file named &lt;code&gt;LocalFilename&lt;/code&gt; and returns the number of transferred bytes in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es una cadena y no hay m&amp;oacute;dulos de devoluci&amp;oacute;n de llamada registrados, &lt;code&gt;tftp_file&lt;/code&gt; se utiliza como m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada. Escribe cada bloque transferido en el archivo llamado &lt;code&gt;LocalFilename&lt;/code&gt; y devuelve el n&amp;uacute;mero de bytes transferidos en &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd17776ebe8291ef5b56762e6914f21f0e371fb1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is a string and there are registered callback modules, &lt;code&gt;LocalFilename&lt;/code&gt; is tested against the regexps of these and the callback module corresponding to the first match is used, or an error tuple is returned if no matching regexp is found.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es una cadena y hay m&amp;oacute;dulos de devoluci&amp;oacute;n de llamada registrados, &lt;code&gt;LocalFilename&lt;/code&gt; se prueba con las expresiones regulares de estos y se usa el m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada correspondiente a la primera coincidencia, o se devuelve una tupla de error si no se encuentra una expresi&amp;oacute;n regular coincidente.</target>
        </trans-unit>
        <trans-unit id="e10f4bb7329e24a46f5a2fd1d389f1d3eaa1ef41" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;LocalFilename&lt;/code&gt; is the atom &lt;code&gt;binary&lt;/code&gt;, &lt;code&gt;tftp_binary&lt;/code&gt; is used as callback module. It concatenates all transferred blocks and returns them as one single binary in &lt;code&gt;LastCallbackState&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;LocalFilename&lt;/code&gt; es el &lt;code&gt;binary&lt;/code&gt; del &amp;aacute;tomo , &lt;code&gt;tftp_binary&lt;/code&gt; se usa como m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada. Concatena todos los bloques transferidos y los devuelve como un solo binario en &lt;code&gt;LastCallbackState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29f45f2e11d4c10074cfecd5aefc75c9eeb1e623" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;M&lt;/code&gt; is not of type map, an exception of type &lt;code&gt;badmap&lt;/code&gt; is thrown.</source>
          <target state="translated">Si &lt;code&gt;M&lt;/code&gt; no es de tipo map, se lanza una excepci&amp;oacute;n de tipo &lt;code&gt;badmap&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="687a37c16da4f8deeaf271a8bf79963858a6f256" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; in a key exchange, it will fail with a disconnect.</source>
          <target state="translated">Si &lt;code&gt;MaxUsed &amp;lt; MinUsed&lt;/code&gt; en un intercambio de claves, fallar&amp;aacute; con una desconexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7c02225a551052905fddcfce82626e17b4c75202" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Message&lt;/code&gt; does not correspond to the response, the atom &lt;code&gt;no_response&lt;/code&gt; is returned. If &lt;code&gt;Message&lt;/code&gt; corresponds to the response, the &lt;code&gt;call&lt;/code&gt; operation is completed and either the result is returned as &lt;code&gt;{response, Result}&lt;/code&gt; where &lt;code&gt;Result&lt;/code&gt; corresponds to the value returned from the applied function or an exception is raised. The exceptions that can be raised corresponds to the same exceptions as can be raised by &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;erpc:call/4&lt;/a&gt;&lt;/code&gt;. That is, no &lt;code&gt;{erpc, timeout}&lt;/code&gt;&lt;code&gt;error&lt;/code&gt; exception can be raised. &lt;code&gt;erpc:check_response()&lt;/code&gt; will fail with an &lt;code&gt;{erpc, badarg}&lt;/code&gt; exception if/when an invalid &lt;code&gt;RequestId&lt;/code&gt; is detected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec574cad80dd815a39ff074fa450bce09ec6bf3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Minutes&lt;/code&gt; is set to &lt;code&gt;infinity&lt;/code&gt;, no rekeying will ever occur due to that max time has passed. Setting &lt;code&gt;Bytes&lt;/code&gt; to &lt;code&gt;infinity&lt;/code&gt; will inhibit rekeying after a certain amount of data has been transferred. If the option value is set to &lt;code&gt;{infinity, infinity}&lt;/code&gt;, no rekeying will be initiated. Note that rekeying initiated by the peer will still be performed.</source>
          <target state="translated">Si &lt;code&gt;Minutes&lt;/code&gt; se establece en &lt;code&gt;infinity&lt;/code&gt; , no se volver&amp;aacute; a introducir nunca debido a que ha transcurrido el tiempo m&amp;aacute;ximo. Establecer &lt;code&gt;Bytes&lt;/code&gt; en &lt;code&gt;infinity&lt;/code&gt; inhibir&amp;aacute; la repetici&amp;oacute;n de claves despu&amp;eacute;s de que se haya transferido una cierta cantidad de datos. Si el valor de la opci&amp;oacute;n se establece en &lt;code&gt;{infinity, infinity}&lt;/code&gt; , no se iniciar&amp;aacute; ninguna modificaci&amp;oacute;n. Tenga en cuenta que se seguir&amp;aacute; realizando el cambio de claves iniciado por el par.</target>
        </trans-unit>
        <trans-unit id="a9f8b097c0197afbf6ad454085a81f83c68dd174" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects an inconsistent transaction decision, an &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; system event is generated to give the application a chance to install a fallback or other appropriate measures to resolve the inconsistency. The default behavior of the &lt;code&gt;Mnesia&lt;/code&gt; event handler is the same as if the database became inconsistent as a result of partitioned network (as described earlier).</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; detecta una decisi&amp;oacute;n de transacci&amp;oacute;n &lt;code&gt;{inconsistent_database, bad_decision, Node}&lt;/code&gt; se genera un evento del sistema {inconsistent_database, bad_decision, Node} para darle a la aplicaci&amp;oacute;n la oportunidad de instalar un respaldo u otras medidas apropiadas para resolver la inconsistencia. El comportamiento predeterminado del controlador de eventos de &lt;code&gt;Mnesia&lt;/code&gt; es el mismo que si la base de datos se volviera inconsistente como resultado de una red particionada (como se describi&amp;oacute; anteriormente).</target>
        </trans-unit>
        <trans-unit id="5ca626a4154bdde85262a0b351b9ffb8e56064dc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects at startup that both the local node and another node received &lt;code&gt;mnesia_down&lt;/code&gt; from each other, &lt;code&gt;Mnesia&lt;/code&gt; generates an &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; system event and acts as described in the previous item.</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; detecta al inicio que tanto el nodo local como otro nodo recibieron &lt;code&gt;mnesia_down&lt;/code&gt; entre s&amp;iacute;, &lt;code&gt;Mnesia&lt;/code&gt; genera un evento de sistema &lt;code&gt;{inconsistent_database, starting_partitioned_network, Node}&lt;/code&gt; starts_partitioned_network , Node} y act&amp;uacute;a como se describe en el elemento anterior.</target>
        </trans-unit>
        <trans-unit id="8a5aa5b6bb0338ccad2dd9a24afe157f5c87240b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; detects that a file has not been properly closed, possibly as a result of a power failure, it tries to repair the bad file in a similar manner. Data can be lost, but &lt;code&gt;Mnesia&lt;/code&gt; can be restarted even if the data is inconsistent. Configuration parameter &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; can be used to control the behavior of &lt;code&gt;Mnesia&lt;/code&gt; at startup. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; tries to repair the file. If &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; has the value &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;Mnesia&lt;/code&gt; does not restart if it detects a suspect file. This configuration parameter affects the repair behavior of log files, &lt;code&gt;DAT&lt;/code&gt; files, and the default backup media.</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; detecta que un archivo no se ha cerrado correctamente, posiblemente como resultado de un corte de energ&amp;iacute;a, intenta reparar el archivo defectuoso de manera similar. Los datos se pueden perder, pero &lt;code&gt;Mnesia&lt;/code&gt; se puede reiniciar incluso si los datos son inconsistentes. El par&amp;aacute;metro de configuraci&amp;oacute;n &lt;code&gt;-mnesia auto_repair &amp;lt;bool&amp;gt;&lt;/code&gt; se puede utilizar para controlar el comportamiento de &lt;code&gt;Mnesia&lt;/code&gt; al inicio. Si &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; tiene el valor &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; intenta reparar el archivo. Si &lt;code&gt;&amp;lt;bool&amp;gt;&lt;/code&gt; tiene el valor &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; no se reinicia si detecta un archivo sospechoso. Este par&amp;aacute;metro de configuraci&amp;oacute;n afecta el comportamiento de reparaci&amp;oacute;n de los archivos de registro, &lt;code&gt;DAT&lt;/code&gt; archivos y el medio de copia de seguridad predeterminado.</target>
        </trans-unit>
        <trans-unit id="29d3fae27e18aeedb269f53e1a8f041e114e54d9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; has not started on some of the nodes that are involved in the transaction &lt;strong&gt;and&lt;/strong&gt; neither the local node nor any of the already running nodes know the outcome of the transaction, &lt;code&gt;Mnesia&lt;/code&gt; waits for one, by default. In the worst case scenario, all other involved nodes must start before &lt;code&gt;Mnesia&lt;/code&gt; can make the correct decision about the transaction and finish its startup.</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; no se ha iniciado en algunos de los nodos que est&amp;aacute;n involucrados en la transacci&amp;oacute;n &lt;strong&gt;y&lt;/strong&gt; ni el nodo local ni ninguno de los nodos que ya est&amp;aacute;n en ejecuci&amp;oacute;n conocen el resultado de la transacci&amp;oacute;n, &lt;code&gt;Mnesia&lt;/code&gt; espera uno, de forma predeterminada. En el peor de los casos, todos los dem&amp;aacute;s nodos involucrados deben comenzar antes de que &lt;code&gt;Mnesia&lt;/code&gt; pueda tomar la decisi&amp;oacute;n correcta sobre la transacci&amp;oacute;n y finalizar su inicio.</target>
        </trans-unit>
        <trans-unit id="dd38ec2de0e096904bd79c96261fe3dfca545808" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Mnesia&lt;/code&gt; malfunctions, system information is dumped to file &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt;. The type of system information contained in this file can also be generated with the function &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt;. If a &lt;code&gt;Mnesia&lt;/code&gt; system behaves strangely, it is recommended that a &lt;code&gt;Mnesia&lt;/code&gt; core dump file is included in the bug report.</source>
          <target state="translated">Si &lt;code&gt;Mnesia&lt;/code&gt; no funciona correctamente, la informaci&amp;oacute;n del sistema se descarga al archivo &lt;code&gt;MnesiaCore.Node.When&lt;/code&gt; . El tipo de informaci&amp;oacute;n del sistema contenida en este archivo tambi&amp;eacute;n se puede generar con la funci&amp;oacute;n &lt;code&gt;mnesia_lib:coredump()&lt;/code&gt; . Si un sistema &lt;code&gt;Mnesia&lt;/code&gt; se comporta de manera extra&amp;ntilde;a, se recomienda que se &lt;code&gt;Mnesia&lt;/code&gt; un archivo de volcado del n&amp;uacute;cleo de Mnesia en el informe de error.</target>
        </trans-unit>
        <trans-unit id="78d126042be1f1bd5d152bedd102bc2c27a70a3c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module2:init/1&lt;/code&gt; returns a correct value, this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module2:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns an unexpected value &lt;code&gt;Term&lt;/code&gt;, this function returns &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively.</source>
          <target state="translated">Si &lt;code&gt;Module2:init/1&lt;/code&gt; devuelve un valor correcto, esta funci&amp;oacute;n devuelve &lt;code&gt;ok&lt;/code&gt; . Si &lt;code&gt;Module2:init/1&lt;/code&gt; falla con &lt;code&gt;Reason&lt;/code&gt; o devuelve un valor inesperado &lt;code&gt;Term&lt;/code&gt; , esta funci&amp;oacute;n devuelve &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; o &lt;code&gt;{error,Term}&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="2800f17b5a7a3294a30bce9d692cce033e777bbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an error tuple or an incorrect value, this function returns &lt;code&gt;{error,Errorr}&lt;/code&gt;, where &lt;code&gt;Error&lt;/code&gt; is a term with information about the error, and the supervisor bridge terminates with reason &lt;code&gt;Error&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; falla o devuelve una tupla de error o un valor incorrecto, esta funci&amp;oacute;n devuelve &lt;code&gt;{error,Errorr}&lt;/code&gt; , donde &lt;code&gt;Error&lt;/code&gt; es un t&amp;eacute;rmino con informaci&amp;oacute;n sobre el error, y el puente supervisor termina con el motivo &lt;code&gt;Error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd9e3be966d4953b313f0b3139d9921bb88d0b55" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails or returns an incorrect value, this function returns &lt;code&gt;{error,Term}&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is a term with information about the error, and the supervisor terminates with reason &lt;code&gt;Term&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; falla o devuelve un valor incorrecto, esta funci&amp;oacute;n devuelve &lt;code&gt;{error,Term}&lt;/code&gt; , donde &lt;code&gt;Term&lt;/code&gt; es un t&amp;eacute;rmino con informaci&amp;oacute;n sobre el error, y el supervisor termina con el motivo &lt;code&gt;Term&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="06a79b06d12276baeba24803b1a67f3a90f7af4a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, the function returns &lt;code&gt;{error,Reason}&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;{stop,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, the process is terminated and the function returns &lt;code&gt;{error,Reason}&lt;/code&gt; or &lt;code&gt;ignore&lt;/code&gt;, respectively.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; falla con &lt;code&gt;Reason&lt;/code&gt; , la funci&amp;oacute;n devuelve &lt;code&gt;{error,Reason}&lt;/code&gt; . Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve &lt;code&gt;{stop,Reason}&lt;/code&gt; o &lt;code&gt;ignore&lt;/code&gt; , el proceso finaliza y la funci&amp;oacute;n devuelve &lt;code&gt;{error,Reason}&lt;/code&gt; o &lt;code&gt;ignore&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="08a85009b7d63daa3876ac0bbe64563be6e4667a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt;, this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, the process is terminated and this function returns &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt;, respectively.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; falla con &lt;code&gt;Reason&lt;/code&gt; , esta funci&amp;oacute;n devuelve &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; . Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{stop,Reason}&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; , el proceso finaliza y esta funci&amp;oacute;n devuelve &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;{error,Reason}&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#type-start_ret&quot;&gt;ignore&lt;/a&gt;&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="b964744cac9c86474eba0929df72fddd8367b88f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well and the supervisor bridge terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve &lt;code&gt;ignore&lt;/code&gt; , esta funci&amp;oacute;n tambi&amp;eacute;n devuelve &lt;code&gt;ignore&lt;/code&gt; y el puente supervisor termina con una raz&amp;oacute;n &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e2bd739756c272b047be065f7e266ff83f96304" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns &lt;code&gt;ignore&lt;/code&gt;, this function returns &lt;code&gt;ignore&lt;/code&gt; as well, and the supervisor terminates with reason &lt;code&gt;normal&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve &lt;code&gt;ignore&lt;/code&gt; , esta funci&amp;oacute;n tambi&amp;eacute;n devuelve &lt;code&gt;ignore&lt;/code&gt; y el supervisor finaliza con una raz&amp;oacute;n &lt;code&gt;normal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e0a0e47ea971ab5cb4ee104b3ddf1785be6b28da" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:init/1&lt;/code&gt; returns a correct value indicating successful completion, the event manager adds the event handler and this function returns &lt;code&gt;ok&lt;/code&gt;. If &lt;code&gt;Module:init/1&lt;/code&gt; fails with &lt;code&gt;Reason&lt;/code&gt; or returns &lt;code&gt;{error,Reason}&lt;/code&gt;, the event handler is ignored and this function returns &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; or &lt;code&gt;{error,Reason}&lt;/code&gt;, respectively.</source>
          <target state="translated">Si &lt;code&gt;Module:init/1&lt;/code&gt; devuelve un valor correcto que indica una finalizaci&amp;oacute;n exitosa, el administrador de eventos agrega el controlador de eventos y esta funci&amp;oacute;n devuelve &lt;code&gt;ok&lt;/code&gt; . Si &lt;code&gt;Module:init/1&lt;/code&gt; falla con &lt;code&gt;Reason&lt;/code&gt; o devuelve &lt;code&gt;{error,Reason}&lt;/code&gt; , el controlador de eventos se ignora y esta funci&amp;oacute;n devuelve &lt;code&gt;{'EXIT',Reason}&lt;/code&gt; o &lt;code&gt;{error,Reason}&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="09a967e619be6af84ec5d9fcc2d540f2231d235c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si no se exporta el &lt;code&gt;Module:on_tc_fail/4&lt;/code&gt; , common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:on_tc_fail(TestName, Reason, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="dd0d2fb7d1f38864cd0e105f7caff1a473b3f495" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si no se exporta el &lt;code&gt;Module:on_tc_skip/4&lt;/code&gt; , common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:on_tc_skip(TestName, Reason, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="6e0f9d357b53cd19411dbd2755262448109533a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si &lt;code&gt;Module:post_end_per_group/5&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:post_end_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="c30a59478d9813033d5db1ba6eb7b720e1f8a281" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si &lt;code&gt;Module:post_end_per_testcase/5&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:post_end_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="8b31af596bd3564305ac89780dcd5037ca72eed4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si el &lt;code&gt;Module:post_init_per_group/5&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:post_init_per_group(GroupName, Config, Return, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="3389cc7f2c4854aa000a5dc7cbbbd118b6386a3a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si no se exporta &lt;code&gt;Module:post_init_per_testcase/5&lt;/code&gt; , common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:post_init_per_testcase(TestcaseName, Config, Return, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="fa0c6abab53f3a1832ad70236445abe23313c949" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si &lt;code&gt;Module:pre_end_per_group/4&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:pre_end_per_group(GroupName, EndData, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="4220e81587ad22a96ae86a7cc023800c3211a2ce" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si &lt;code&gt;Module:pre_end_per_testcase/4&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:pre_end_per_testcase(TestcaseName, EndData, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="827b0497b91b5175e901d63a74e9ca29d1d28466" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si no se exporta &lt;code&gt;Module:pre_init_per_group/4&lt;/code&gt; , common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:pre_init_per_group(GroupName, InitData, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="547d2d680c102fd734e63aee60c0764a91aca79d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; is not exported, common_test will attempt to call &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; instead. This is for backwards compatibility.</source>
          <target state="translated">Si el &lt;code&gt;Module:pre_init_per_testcase/4&lt;/code&gt; no se exporta, common_test intentar&amp;aacute; llamar al &lt;code&gt;Module:pre_init_per_testcase(TestcaseName, InitData, CTHState)&lt;/code&gt; lugar. Esto es por compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="21fb0625232bdf7d33e9683b493cf013dd5244be" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is an atom and is not the path of a source file, then the code path is searched to locate the object file for the module and extract its original compiler options and source path. If the source file is not found in the original location, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; is used to search for it relative to the directory of the object file.</source>
          <target state="translated">Si &lt;code&gt;Module&lt;/code&gt; es un &amp;aacute;tomo y no es la ruta de un archivo fuente, entonces se busca la ruta del c&amp;oacute;digo para ubicar el archivo objeto del m&amp;oacute;dulo y extraer sus opciones del compilador original y ruta fuente. Si el archivo de origen no se encuentra en la ubicaci&amp;oacute;n original, &lt;code&gt;&lt;a href=&quot;filelib#find_source-1&quot;&gt;filelib:find_source/1&lt;/a&gt;&lt;/code&gt; se utiliza para buscarlo en relaci&amp;oacute;n con el directorio del archivo de objeto.</target>
        </trans-unit>
        <trans-unit id="2f35893e15d66156fbf46d4e4af24041aed07f45" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is interpreted, the interpreter is invoked and the return value of the interpreted &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; call is returned.</source>
          <target state="translated">Si se interpreta &lt;code&gt;Module&lt;/code&gt; , se invoca al int&amp;eacute;rprete y se devuelve el valor de retorno de la &lt;code&gt;Fun(Arg1,.., ArgN)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67c2474f76236eb774fc89b2d1d56a6f0f7c3f57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded and the object file exists and contains the same code.</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; est&amp;aacute; cargado y el archivo de objeto existe y contiene el mismo c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="8e3e08e194bdd0bde8a181db6a7f4ea876ef7dfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but does not have native code</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; est&amp;aacute; cargado pero no tiene c&amp;oacute;digo nativo</target>
        </trans-unit>
        <trans-unit id="6ed685bf101eabc82b65e519e9da522892714f39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but no corresponding object file can be found in the code path.</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; est&amp;aacute; cargado pero no se puede encontrar el archivo de objeto correspondiente en la ruta del c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="a3d8ad064c879fd2b635248fe4428064d2c2287b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is loaded but the object file contains code with a different MD5 checksum.</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; est&amp;aacute; cargado pero el archivo de objeto contiene c&amp;oacute;digo con una suma de comprobaci&amp;oacute;n MD5 diferente.</target>
        </trans-unit>
        <trans-unit id="0d66cbf854873559817431ac8657e00f31894e65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not Cover compiled, the function returns &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Module&lt;/code&gt; no est&amp;aacute; compilado Cover, la funci&amp;oacute;n devuelve &lt;code&gt;{error,{not_cover_compiled,Module}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35affc64e4462796f41658b1b89a47205a5418f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not an atom.</source>
          <target state="translated">Si &lt;code&gt;Module&lt;/code&gt; no es un &amp;aacute;tomo.</target>
        </trans-unit>
        <trans-unit id="28eaadbc7b4906a161654ae8a696f70005c80dff" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not currently loaded.</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; no est&amp;aacute; cargado actualmente.</target>
        </trans-unit>
        <trans-unit id="2f4aff325466dff627c5e688d76bc4df8a1246e1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not given, data for all Cover compiled or earlier imported modules is exported.</source>
          <target state="translated">Si no se proporciona &lt;code&gt;Module&lt;/code&gt; , se exportan los datos de todos los m&amp;oacute;dulos Cover compilados o importados anteriormente.</target>
        </trans-unit>
        <trans-unit id="4388daad92dd73ddcb6294d3f0538fdaca71514b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is not loaded</source>
          <target state="translated">Si el &lt;code&gt;Module&lt;/code&gt; no est&amp;aacute; cargado</target>
        </trans-unit>
        <trans-unit id="3de1d5c36e26d7596ce7561b07882f4daa22a030" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Module&lt;/code&gt; is the name of a loaded module that has native code loaded</source>
          <target state="translated">Si &lt;code&gt;Module&lt;/code&gt; es el nombre de un m&amp;oacute;dulo cargado que tiene cargado c&amp;oacute;digo nativo</target>
        </trans-unit>
        <trans-unit id="dc068e6c6fb49a84acb5b9f82ce4f1b82380c161" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;Answer&lt;/code&gt;, else the return will be a list, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Modules&lt;/code&gt; es un &amp;aacute;tomo (un m&amp;oacute;dulo), la devoluci&amp;oacute;n ser&amp;aacute; &lt;code&gt;Answer&lt;/code&gt; , de lo contrario, la devoluci&amp;oacute;n ser&amp;aacute; una lista, &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d2129780e47085f58784cab38168e42cd913f8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is an atom (one module), the return will be &lt;code&gt;OneResult&lt;/code&gt;, else the return will be &lt;code&gt;{result,Ok,Fail}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Modules&lt;/code&gt; es un &amp;aacute;tomo (un m&amp;oacute;dulo), la devoluci&amp;oacute;n ser&amp;aacute; &lt;code&gt;OneResult&lt;/code&gt; , de lo contrario, la devoluci&amp;oacute;n ser&amp;aacute; &lt;code&gt;{result,Ok,Fail}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c5660afecaaa6ae9b7c2e1dd31118d79f4a48c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules&lt;/code&gt; is not given, all modules that have data in the cover data table, are analysed. Note that this includes both cover compiled modules and imported modules.</source>
          <target state="translated">Si &lt;code&gt;Modules&lt;/code&gt; no se da, todos los m&amp;oacute;dulos que tienen datos en la tabla de datos de presentaci&amp;oacute;n, se analizan. Tenga en cuenta que esto incluye tanto los m&amp;oacute;dulos compilados de la cubierta como los m&amp;oacute;dulos importados.</target>
        </trans-unit>
        <trans-unit id="8a375b70a231e530df5647867765137b186f5486" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Modules=dynamic&lt;/code&gt;, which is the case for event managers, the event manager process informs the release handler about the list of currently installed event handlers (&lt;code&gt;gen_event&lt;/code&gt;), and it is checked if the module name is in this list instead.</source>
          <target state="translated">Si &lt;code&gt;Modules=dynamic&lt;/code&gt; , que es el caso de los administradores de eventos, el proceso del administrador de eventos informa al administrador de versiones sobre la lista de controladores de eventos instalados actualmente ( &lt;code&gt;gen_event&lt;/code&gt; ), y se verifica si el nombre del m&amp;oacute;dulo est&amp;aacute; en esta lista.</target>
        </trans-unit>
        <trans-unit id="e8cecedc28fd848e48458244703056a1ac1a339f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; does not exist.</source>
          <target state="translated">Si &lt;code&gt;MonitorPid&lt;/code&gt; no existe.</target>
        </trans-unit>
        <trans-unit id="373a002dc9620bdf865a5b5e6f260b3dd1f5301f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorPid&lt;/code&gt; is not a local process.</source>
          <target state="translated">Si &lt;code&gt;MonitorPid&lt;/code&gt; no es un proceso local.</target>
        </trans-unit>
        <trans-unit id="89660705a87398108d22c38f81698b872c41d667" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;MonitorRef&lt;/code&gt; is a reference that the calling process obtained by calling &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;, this monitoring is turned off. If the monitoring is already turned off, nothing happens.</source>
          <target state="translated">Si &lt;code&gt;MonitorRef&lt;/code&gt; es una referencia que el proceso de llamada obtuvo llamando a &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; , esta monitorizaci&amp;oacute;n est&amp;aacute; desactivada. Si la monitorizaci&amp;oacute;n ya est&amp;aacute; desactivada, no pasa nada.</target>
        </trans-unit>
        <trans-unit id="4fd962484b4478493735ba1be0d09ca7b30e44ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si &lt;code&gt;N&lt;/code&gt; &amp;lt; &lt;code&gt;0&lt;/code&gt; , se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="790d7222607fd455375f3a15db7f9612e76c7d20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;N&lt;/code&gt; = 0, call saving is disabled for the process, which is the default. Whenever the size of the call saving list is set, its contents are reset.</source>
          <target state="translated">Si &lt;code&gt;N&lt;/code&gt; = 0, el guardado de llamadas est&amp;aacute; deshabilitado para el proceso, que es el valor predeterminado. Siempre que se establece el tama&amp;ntilde;o de la lista de guardado de llamadas, se restablece su contenido.</target>
        </trans-unit>
        <trans-unit id="917defb768e26d53c01d843240d1452bda349978" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; (an alias name for &lt;code&gt;Key&lt;/code&gt;) is used to identify the connection, this name can be used as connection reference for subsequent calls. Only one open connection at a time associated with &lt;code&gt;Name&lt;/code&gt; is possible. If &lt;code&gt;Key&lt;/code&gt; is used, the returned handle must be used for subsequent calls (multiple connections can be opened using the configuration data specified by &lt;code&gt;Key&lt;/code&gt;).</source>
          <target state="translated">Si se usa &lt;code&gt;Name&lt;/code&gt; (un nombre de alias para la &lt;code&gt;Key&lt;/code&gt; ) para identificar la conexi&amp;oacute;n, este nombre se puede usar como referencia de conexi&amp;oacute;n para llamadas posteriores. Solo es posible una conexi&amp;oacute;n abierta a la vez asociada con el &lt;code&gt;Name&lt;/code&gt; . Si se usa &lt;code&gt;Key&lt;/code&gt; , el identificador devuelto debe usarse para llamadas posteriores (se pueden abrir m&amp;uacute;ltiples conexiones usando los datos de configuraci&amp;oacute;n especificados por &lt;code&gt;Key&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="656dd80cf80ca49ab5d3f335d4b4b338f312a58e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is also the name of one of the input modules, the code from that module will occur at the top of the resulting code, and no extra &quot;header&quot; comments will be added. In other words, the look of that module will be preserved.</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; es tambi&amp;eacute;n el nombre de uno de los m&amp;oacute;dulos de entrada, el c&amp;oacute;digo de ese m&amp;oacute;dulo aparecer&amp;aacute; en la parte superior del c&amp;oacute;digo resultante y no se agregar&amp;aacute;n comentarios de &quot;encabezado&quot; adicionales. En otras palabras, se conservar&amp;aacute; el aspecto de ese m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="ce802579fca60cdc1ea685ad322c443678165ff7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is an &lt;code&gt;ip_address()&lt;/code&gt;, the domain name to query for is generated as the standard reverse &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; name for an IPv4 address, or the &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; name for an IPv6 address. In this case, you most probably want to use &lt;code&gt;Class = in&lt;/code&gt; and &lt;code&gt;Type = ptr&lt;/code&gt;, but it is not done automatically.</source>
          <target state="translated">Si el &lt;code&gt;Name&lt;/code&gt; es una &lt;code&gt;ip_address()&lt;/code&gt; , el nombre de dominio para consultar se genera como el reverso est&amp;aacute;ndar &lt;code&gt;&quot;.IN-ADDR.ARPA.&quot;&lt;/code&gt; nombre para una direcci&amp;oacute;n IPv4, o el &lt;code&gt;&quot;.IP6.ARPA.&quot;&lt;/code&gt; nombre para una direcci&amp;oacute;n IPv6. En este caso, lo m&amp;aacute;s probable es que desee utilizar &lt;code&gt;Class = in&lt;/code&gt; y &lt;code&gt;Type = ptr&lt;/code&gt; , pero no se hace autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="a8688d593066763d843262dfe2006d94c1dcdd01" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, message &lt;code&gt;Msg&lt;/code&gt; is sent to the corresponding pid. The pid is also the return value of the function. If the name is not found, the function returns &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; se encuentra, el mensaje &lt;code&gt;Msg&lt;/code&gt; se env&amp;iacute;a al PID correspondiente. El pid es tambi&amp;eacute;n el valor de retorno de la funci&amp;oacute;n. Si no se encuentra el nombre, la funci&amp;oacute;n devuelve &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77e52354c073c213988ffe84ec279249d3ad68b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is found, the corresponding pid is returned. If the name is not found, the function returns &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Si se encuentra &lt;code&gt;Name&lt;/code&gt; , se devuelve el pid correspondiente. Si no se encuentra el nombre, la funci&amp;oacute;n devuelve &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b00a3532b853c4357137d1d6716fd7be18c249ed" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a globally registered name, the calling function exits with reason &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; no es un nombre registrado globalmente, la funci&amp;oacute;n de llamada &lt;code&gt;{badarg, {Name, Msg}}&lt;/code&gt; con motivo {badarg, {Nombre, Msg}} .</target>
        </trans-unit>
        <trans-unit id="db414ecce81f54e0e73f62d5d1f1d7174a6bde93" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not a symbolic link, this function returns the same result as &lt;code&gt;read_file_info/1&lt;/code&gt;. On platforms that do not support symbolic links, this function is always equivalent to &lt;code&gt;read_file_info/1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; no es un enlace simb&amp;oacute;lico, esta funci&amp;oacute;n devuelve el mismo resultado que &lt;code&gt;read_file_info/1&lt;/code&gt; . En plataformas que no admiten enlaces simb&amp;oacute;licos, esta funci&amp;oacute;n siempre es equivalente a &lt;code&gt;read_file_info/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8984feb7e9675020b1675cc50fa02225487141b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is not found</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; no se encuentra</target>
        </trans-unit>
        <trans-unit id="83d7d8a185c6a27fcabc1c06a33f11f825598937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; is set to &lt;strong&gt;&lt;code&gt;undefined&lt;/code&gt;&lt;/strong&gt; the node will be started in a special mode optimized to be the temporary client of another node. When enabled the node will request a &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#DFLAG_NAME_ME&quot;&gt;dynamic node name&lt;/a&gt;&lt;/code&gt; from the first node it connects to. In addition these distribution settings will be set:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d520edb0115ce9349b43d81a86232f4def5a898" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Name&lt;/code&gt; or &lt;code&gt;Dir&lt;/code&gt; is invalid</source>
          <target state="translated">Si &lt;code&gt;Name&lt;/code&gt; o &lt;code&gt;Dir&lt;/code&gt; no es v&amp;aacute;lido</target>
        </trans-unit>
        <trans-unit id="f315d1f10b092b6fd3887d5883429c8b05c69dd6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt;, the &lt;code&gt;net_ticktime&lt;/code&gt; change is done at the end of the transition period; otherwise at the beginning. During the transition period, &lt;code&gt;net_kernel&lt;/code&gt; ensures that there is outgoing traffic on all connections at least every &lt;code&gt;MTTI&lt;/code&gt; millisecond.</source>
          <target state="translated">Si &lt;code&gt;NetTicktime &amp;lt; PreviousNetTicktime&lt;/code&gt; , el cambio de &lt;code&gt;net_ticktime&lt;/code&gt; se realiza al final del per&amp;iacute;odo de transici&amp;oacute;n; de lo contrario al principio. Durante el per&amp;iacute;odo de transici&amp;oacute;n, &lt;code&gt;net_kernel&lt;/code&gt; asegura que haya tr&amp;aacute;fico saliente en todas las conexiones al menos cada milisegundo &lt;code&gt;MTTI&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3470b5ebd8e369aa1cfb7ac34ffa140b95c20443" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NewVsn&lt;/code&gt; is installed with option &lt;code&gt;{update_paths,true}&lt;/code&gt;, then &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; returns &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;NewVsn&lt;/code&gt; est&amp;aacute; instalado con la opci&amp;oacute;n &lt;code&gt;{update_paths,true}&lt;/code&gt; , entonces el &lt;code&gt;code:lib_dir(myapp)&lt;/code&gt; devuelve &lt;code&gt;/home/user/myapp-1.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c7547eeec41488135afba55363382ea4a68e45c3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; the state machine changes to a new state. A &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed if enabled and all &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; are retried.</source>
          <target state="translated">Si &lt;code&gt;NextState =/= State&lt;/code&gt; la m&amp;aacute;quina de estado cambia a un nuevo estado. Se realiza una &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; si est&amp;aacute; habilitada y se reintentan todos los &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed events&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="985454129fa65531f94519e19f8ec9b0b8e0bac3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NextState =/= State&lt;/code&gt; this is a &lt;strong&gt;state change&lt;/strong&gt; so the extra things &lt;code&gt;gen_statem&lt;/code&gt; does are: the event queue is restarted from the oldest &lt;code&gt;&lt;a href=&quot;#Postponing%20Events&quot;&gt;postponed event&lt;/a&gt;&lt;/code&gt;, any current &lt;code&gt;&lt;a href=&quot;#State%20Time-Outs&quot;&gt;state time-out&lt;/a&gt;&lt;/code&gt; is cancelled, and a &lt;code&gt;&lt;a href=&quot;#State%20Enter%20Calls&quot;&gt;state enter call&lt;/a&gt;&lt;/code&gt; is performed, if enabled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="192634e65d22edbbba862eb9814d7d7d08c39bad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; fails or does not exist, the message &lt;code&gt;{nodedown, Node}&lt;/code&gt; is delivered to the process. If a process has made two calls to &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; and &lt;code&gt;Node&lt;/code&gt; terminates, two &lt;code&gt;nodedown&lt;/code&gt; messages are delivered to the process. If there is no connection to &lt;code&gt;Node&lt;/code&gt;, an attempt is made to create one. If this fails, a &lt;code&gt;nodedown&lt;/code&gt; message is delivered.</source>
          <target state="translated">Si &lt;code&gt;Node&lt;/code&gt; falla o no existe, el mensaje &lt;code&gt;{nodedown, Node}&lt;/code&gt; se env&amp;iacute;a al proceso. Si un proceso ha realizado dos llamadas a &lt;code&gt;monitor_node(Node, true)&lt;/code&gt; y &lt;code&gt;Node&lt;/code&gt; termina, se &lt;code&gt;nodedown&lt;/code&gt; dos mensajes de nodedown al proceso. Si no hay conexi&amp;oacute;n con &lt;code&gt;Node&lt;/code&gt; , se intenta crear una. Si esto falla, se &lt;code&gt;nodedown&lt;/code&gt; un mensaje de nodos .</target>
        </trans-unit>
        <trans-unit id="68714d151c87dc360bf98fc14620b6c335f0dd18" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is &lt;code&gt;new&lt;/code&gt; the &lt;code&gt;Options&lt;/code&gt; will then also be added to kernel configration parameters &lt;code&gt;inet_dist_listen_options&lt;/code&gt; and &lt;code&gt;inet_dist_connect_options&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Node&lt;/code&gt; es &lt;code&gt;new&lt;/code&gt; las &lt;code&gt;Options&lt;/code&gt; tambi&amp;eacute;n se agregar&amp;aacute;n a los par&amp;aacute;metros de &lt;code&gt;inet_dist_listen_options&lt;/code&gt; kernel inet_dist_listen_options e &lt;code&gt;inet_dist_connect_options&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a374c5564c071bca33b827b4d05f4d121d56e78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Node&lt;/code&gt; is a connected node the return value is the same as from &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; where &lt;code&gt;Sock&lt;/code&gt; is the distribution socket for &lt;code&gt;Node&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Node&lt;/code&gt; es un nodo conectado, el valor de retorno es el mismo que el de &lt;code&gt;&lt;a href=&quot;inet#getopts-2&quot;&gt;inet:getopts(Sock, Options)&lt;/a&gt;&lt;/code&gt; donde &lt;code&gt;Sock&lt;/code&gt; es el conector de distribuci&amp;oacute;n para &lt;code&gt;Node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a745393bc7f4f706da8daca8a06958d92906e5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;all_nodes&lt;/code&gt;, the operation or test is performed on all specified test nodes. (Declaring a term without a &lt;code&gt;NodeRefs&lt;/code&gt; element has the same effect). If &lt;code&gt;NodeRefs&lt;/code&gt; has the value &lt;code&gt;master&lt;/code&gt;, the operation is only performed on the &lt;code&gt;Common Test&lt;/code&gt; Master node (namely set the log directory or install an event handler).</source>
          <target state="translated">Si &lt;code&gt;NodeRefs&lt;/code&gt; tiene el valor &lt;code&gt;all_nodes&lt;/code&gt; , la operaci&amp;oacute;n o prueba se realiza en todos los nodos de prueba especificados. (Declarar un t&amp;eacute;rmino sin un elemento &lt;code&gt;NodeRefs&lt;/code&gt; tiene el mismo efecto). Si &lt;code&gt;NodeRefs&lt;/code&gt; tiene el valor &lt;code&gt;master&lt;/code&gt; , la operaci&amp;oacute;n solo se realiza en el nodo &lt;code&gt;Common Test&lt;/code&gt; Master (es decir, establecer el directorio de registro o instalar un controlador de eventos).</target>
        </trans-unit>
        <trans-unit id="0a2bb885a5c6676f0b55789e9e3cebe681cef1a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Nodename&lt;/code&gt; is the local node, the error reason &lt;code&gt;cant_add_local_node&lt;/code&gt; is returned.</source>
          <target state="translated">Si &lt;code&gt;Nodename&lt;/code&gt; es el nodo local, se devuelve el motivo del error &lt;code&gt;cant_add_local_node&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88f13b4b4a78ad3eb8641157bd00453fceefb7e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt; nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt; nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt; nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt; nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cd44685473bdc36e9c30c5fd35ef39651321ff3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Norm&lt;/code&gt; is not &lt;code&gt;none&lt;/code&gt; the function applies normalization on the fly before the equality test. There are four available normalization forms: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Norm&lt;/code&gt; no es &lt;code&gt;none&lt;/code&gt; , la funci&amp;oacute;n aplica la normalizaci&amp;oacute;n sobre la marcha antes de la prueba de igualdad. Hay cuatro formas de normalizaci&amp;oacute;n disponibles: &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfc_list-1&quot;&gt;nfc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfd_list-1&quot;&gt;nfd&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkc_list-1&quot;&gt;nfkc&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;unicode#characters_to_nfkd_list-1&quot;&gt;nfkd&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e2e6781b735fbde5662ff5d701d6df3c8fc8b882" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ObjectOrObjects&lt;/code&gt; is a list, the function checks &lt;strong&gt;every&lt;/strong&gt; key before inserting anything. Nothing is inserted unless &lt;strong&gt;all&lt;/strong&gt; keys present in the list are absent from the table. Like &lt;code&gt;insert/2&lt;/code&gt;, the entire operation is guaranteed to be &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ObjectOrObjects&lt;/code&gt; es una lista, la funci&amp;oacute;n verifica &lt;strong&gt;cada&lt;/strong&gt; tecla antes de insertar algo. No se inserta nada a menos que &lt;strong&gt;todas las&lt;/strong&gt; claves presentes en la lista est&amp;eacute;n ausentes de la tabla. Como &lt;code&gt;insert/2&lt;/code&gt; , se garantiza que toda la operaci&amp;oacute;n ser&amp;aacute; &lt;code&gt;&lt;a href=&quot;#concurrency&quot;&gt;atomic and isolated&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ea049099ad2942c413fff09669264ab1e5dd87b7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; cannot fit in a 32-bit integer.</source>
          <target state="translated">Si &lt;code&gt;Operation&lt;/code&gt; no cabe en un entero de 32 bits.</target>
        </trans-unit>
        <trans-unit id="9a2af5fb3189d023dbe0c347471fbf3afbf37fe5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Operation&lt;/code&gt; does not fit in a 32-bit integer.</source>
          <target state="translated">Si &lt;code&gt;Operation&lt;/code&gt; no cabe en un entero de 32 bits.</target>
        </trans-unit>
        <trans-unit id="2ef59a44cc7221066ae352f1c66be399d1a45ac8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opt&lt;/code&gt; is any atom, it is interpreted as &lt;code&gt;{Opt,true}&lt;/code&gt; unless the atom string starts with &lt;code&gt;&quot;no&quot;&lt;/code&gt;, making the interpretation &lt;code&gt;{Opt,false}&lt;/code&gt;. For example, &lt;code&gt;usevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,true}&lt;/code&gt; and &lt;code&gt;nousevc&lt;/code&gt; is an alias for &lt;code&gt;{usevc,false}&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Opt&lt;/code&gt; es cualquier &amp;aacute;tomo, se interpreta como &lt;code&gt;{Opt,true}&lt;/code&gt; a menos que la cadena del &amp;aacute;tomo comience con &lt;code&gt;&quot;no&quot;&lt;/code&gt; , lo que hace que la interpretaci&amp;oacute;n sea &lt;code&gt;{Opt,false}&lt;/code&gt; . Por ejemplo, &lt;code&gt;usevc&lt;/code&gt; es un alias para &lt;code&gt;{usevc,true}&lt;/code&gt; y &lt;code&gt;nousevc&lt;/code&gt; es un alias para &lt;code&gt;{usevc,false}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="31127aa2062d718c77d7a07ba00f404218c5e042" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptList&lt;/code&gt; is not a proper list of valid &lt;code&gt;Opt&lt;/code&gt;s.</source>
          <target state="translated">Si &lt;code&gt;OptList&lt;/code&gt; no es una lista adecuada de &lt;code&gt;Opt&lt;/code&gt; s v&amp;aacute;lidas .</target>
        </trans-unit>
        <trans-unit id="7b4363da74d53cb9c45989d6ac83b5d6bbd19064" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptParams&lt;/code&gt; is not given, the default value &lt;code&gt;[]&lt;/code&gt; is used.</source>
          <target state="translated">Si no se proporciona &lt;code&gt;OptParams&lt;/code&gt; , se utiliza el valor predeterminado &lt;code&gt;[]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a510b4980f05110bb42f2051f210307d0b27183c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Option&lt;/code&gt; is an invalid option.</source>
          <target state="translated">Si &lt;code&gt;Option&lt;/code&gt; es una opci&amp;oacute;n inv&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="12e88c8f64ffe2e4621e2429aa9df040b6734c5f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid list of options.</source>
          <target state="translated">Si &lt;code&gt;OptionList&lt;/code&gt; es una lista de opciones no v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="28172abefdf60c0ffbe1b8a62b1fc04dc23fb874" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is an invalid option list.</source>
          <target state="translated">Si &lt;code&gt;OptionList&lt;/code&gt; es una lista de opciones no v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="93bbd7b2e7d83031f59c92a0c8ccb1cc60d19148" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OptionList&lt;/code&gt; is not a list.</source>
          <target state="translated">Si &lt;code&gt;OptionList&lt;/code&gt; no es una lista.</target>
        </trans-unit>
        <trans-unit id="47de326f53be67167a635f5060809e5db271ba9b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt; float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6133e7ac28cc0038bd62a0b0ae71e4da87c1eca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is &lt;code&gt;[]&lt;/code&gt;, the function behaves as &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Options&lt;/code&gt; es &lt;code&gt;[]&lt;/code&gt; , la funci&amp;oacute;n se comporta como &lt;code&gt;&lt;a href=&quot;#float_to_list-1&quot;&gt;float_to_list/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7730b5d34ec1da622c3e568e7e8a64ba1d2bd89" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is a list, this is equivalent to &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt;, otherwise it is equivalent to &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt;. However, using this function directly is more efficient.</source>
          <target state="translated">Si &lt;code&gt;Options&lt;/code&gt; es una lista, esto es equivalente a &lt;code&gt;new([{size, Size} | Options]&lt;/code&gt; , de lo contrario es equivalente a &lt;code&gt;new([{size, Size} | [Options]]&lt;/code&gt; . Sin embargo, usar esta funci&amp;oacute;n directamente es m&amp;aacute;s eficiente .</target>
        </trans-unit>
        <trans-unit id="9fde3e06c0c33f9a7645abc8b6b8f5e2ebe7f59a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Options&lt;/code&gt; is not &lt;code&gt;[]&lt;/code&gt;, the format is as follows:</source>
          <target state="translated">Si &lt;code&gt;Options&lt;/code&gt; no es &lt;code&gt;[]&lt;/code&gt; , el formato es el siguiente:</target>
        </trans-unit>
        <trans-unit id="30be8f5cb2762ca72a34cc75e497114c5814d418" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Opts&lt;/code&gt; is not specified or if it is &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is deleted and a new file is created. If &lt;code&gt;Opts = [append]&lt;/code&gt;, &lt;code&gt;ConfigFile&lt;/code&gt; is not deleted. The new information is appended at the end of the file.</source>
          <target state="translated">Si no se especifica &lt;code&gt;Opts&lt;/code&gt; o si es &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; se elimina y se crea un nuevo archivo. Si &lt;code&gt;Opts = [append]&lt;/code&gt; , &lt;code&gt;ConfigFile&lt;/code&gt; no se elimina. La nueva informaci&amp;oacute;n se adjunta al final del archivo.</target>
        </trans-unit>
        <trans-unit id="373e624d641069009ec67c8a54cd85bd2a2d72ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Out&lt;/code&gt; is specified, &lt;code&gt;FormatHandler&lt;/code&gt; gets the file descriptor to &lt;code&gt;Out&lt;/code&gt; as the first parameter.</source>
          <target state="translated">Si se especifica &lt;code&gt;Out&lt;/code&gt; , &lt;code&gt;FormatHandler&lt;/code&gt; obtiene el descriptor de archivo en &lt;code&gt;Out&lt;/code&gt; como primer par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="fad332308463a8263339bd3390b05cbefc19f3b2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt;, option &lt;code&gt;asynchronous&lt;/code&gt; of &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; has been used and the suspendee has not yet been suspended by &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;OutstandingSuspendCount =/= 0&lt;/code&gt; , se ha utilizado la opci&amp;oacute;n &lt;code&gt;asynchronous&lt;/code&gt; de &lt;code&gt;erlang:suspend_process/2&lt;/code&gt; y &lt;code&gt;Pid&lt;/code&gt; a&amp;uacute;n no ha suspendido el suspendee .</target>
        </trans-unit>
        <trans-unit id="3bbfc8cfc7a6d48dbab3e59b020a0ba36f02f8cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Path&lt;/code&gt; is a directory, &lt;code&gt;default_index/2&lt;/code&gt;, it starts searching for resources or files that are specified in the config directive &lt;code&gt;DirectoryIndex&lt;/code&gt;. If an appropriate resource or file is found, it is appended to the end of &lt;code&gt;Path&lt;/code&gt; and then returned. &lt;code&gt;Path&lt;/code&gt; is returned unaltered if no appropriate file is found or if &lt;code&gt;Path&lt;/code&gt; is not a directory. &lt;code&gt;config_db()&lt;/code&gt; is the server config file in ETS table format as described in &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Path&lt;/code&gt; es un directorio, &lt;code&gt;default_index/2&lt;/code&gt; , comienza a buscar recursos o archivos que se especifican en la directiva de configuraci&amp;oacute;n &lt;code&gt;DirectoryIndex&lt;/code&gt; . Si se encuentra un recurso o archivo apropiado, se agrega al final de la &lt;code&gt;Path&lt;/code&gt; y luego se devuelve. &lt;code&gt;Path&lt;/code&gt; se devuelve inalterada si no se encuentra el archivo apropiado o si la &lt;code&gt;Path&lt;/code&gt; no es un directorio. &lt;code&gt;config_db()&lt;/code&gt; es el archivo de configuraci&amp;oacute;n del servidor en formato de tabla ETS como se describe en &lt;code&gt;&lt;a href=&quot;http_server&quot;&gt;Inets User's Guide&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="beefd85af55dff03d967de6fd4d575f5153ffe35" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are valid patterns, the following is also a valid pattern:</source>
          <target state="translated">Si &lt;code&gt;Pattern1&lt;/code&gt; y &lt;code&gt;Pattern2&lt;/code&gt; son patrones v&amp;aacute;lidos, el siguiente tambi&amp;eacute;n es un patr&amp;oacute;n v&amp;aacute;lido:</target>
        </trans-unit>
        <trans-unit id="92bd28fe3699fc72ccf1ee88565e6cbd3a896278" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pattern&lt;/code&gt; is not a binary or a flat proper list of binaries with length &amp;gt; 0, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si &lt;code&gt;Pattern&lt;/code&gt; no es un binario o una lista plana adecuada de binarios con longitud&amp;gt; 0, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="e7fc7f98492ea4c007c2957660a86f1f0df53bcd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; does not exist, the 'DOWN' message is sent immediately with &lt;code&gt;Reason&lt;/code&gt; set to &lt;code&gt;noproc&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Pid2&lt;/code&gt; no existe, el mensaje 'DOWN' se env&amp;iacute;a inmediatamente con el &lt;code&gt;Reason&lt;/code&gt; establecido en &lt;code&gt;noproc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b4791446d4ac7a4577450d1706f57f608bc60d37" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid2&lt;/code&gt; terminates with exit reason &lt;code&gt;Reason&lt;/code&gt;, a 'DOWN' message is sent to &lt;code&gt;Pid1&lt;/code&gt;:</source>
          <target state="translated">Si &lt;code&gt;Pid2&lt;/code&gt; termina con el motivo de salida &lt;code&gt;Reason&lt;/code&gt; , se env&amp;iacute;a un mensaje 'DOWN' a &lt;code&gt;Pid1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c802432eb292a24b574add89af76bf12c415ea21" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt; garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4ad4270f00a30d3a004edfbf6bb0907bb89e24" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the garbage collection is performed at once, that is, the same as calling &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt;. Otherwise a request for garbage collection is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and will be handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;GCResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; es igual a &lt;code&gt;self()&lt;/code&gt; y no se ha pasado ninguna opci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; , la recolecci&amp;oacute;n de basura se realiza de una vez, es decir, lo mismo que llamar a &lt;code&gt;&lt;a href=&quot;#garbage_collect-0&quot;&gt;garbage_collect/0&lt;/a&gt;&lt;/code&gt; . De lo contrario, se env&amp;iacute;a una solicitud de recolecci&amp;oacute;n de basura al proceso identificado por &lt;code&gt;Pid&lt;/code&gt; , y se manejar&amp;aacute; cuando corresponda. Si no se ha pasado ninguna opci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; , la persona que llama se bloquea hasta que &lt;code&gt;GCResult&lt;/code&gt; est&amp;eacute; disponible y pueda devolverse.</target>
        </trans-unit>
        <trans-unit id="e39d7c1dcb4424a9d8e01705e3e21bd11e62c069" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; equals &lt;code&gt;self()&lt;/code&gt;, and no &lt;code&gt;async&lt;/code&gt; option has been passed, the operation is performed at once. Otherwise a request for the operation is sent to the process identified by &lt;code&gt;Pid&lt;/code&gt;, and is handled when appropriate. If no &lt;code&gt;async&lt;/code&gt; option has been passed, the caller blocks until &lt;code&gt;CheckResult&lt;/code&gt; is available and can be returned.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; es igual a &lt;code&gt;self()&lt;/code&gt; y no se ha pasado ninguna opci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; , la operaci&amp;oacute;n se realiza de inmediato. De lo contrario, se env&amp;iacute;a una solicitud para la operaci&amp;oacute;n al proceso identificado por &lt;code&gt;Pid&lt;/code&gt; y se maneja cuando corresponde. Si no se ha pasado ninguna opci&amp;oacute;n &lt;code&gt;async&lt;/code&gt; , la persona que llama se bloquea hasta que &lt;code&gt;CheckResult&lt;/code&gt; est&amp;eacute; disponible y pueda devolverse.</target>
        </trans-unit>
        <trans-unit id="9a5e58475adf385dca728b097c7c732d60714c40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is an I/O device, that is, a pid returned from &lt;code&gt;open/2&lt;/code&gt;, this function returns the filename, or rather:</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; es un dispositivo de E / S, es decir, un pid devuelto por &lt;code&gt;open/2&lt;/code&gt; , esta funci&amp;oacute;n devuelve el nombre del archivo, o mejor dicho:</target>
        </trans-unit>
        <trans-unit id="2c88872158412481d4632dbb6c4d0828fafd3ef7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a local process.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; no es un proceso local.</target>
        </trans-unit>
        <trans-unit id="0c4258af24e0c809dc0bd9d32eeea697ff1e2cb3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not a node local process identifier.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; no es un identificador de proceso local de nodo.</target>
        </trans-unit>
        <trans-unit id="a85548fa2767eaff370c38aaf90f8964627aa367" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is not trapping exits, &lt;code&gt;Pid&lt;/code&gt; itself exits with exit reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; no est&amp;aacute; atrapando salidas, el propio &lt;code&gt;Pid&lt;/code&gt; sale con el motivo de salida &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="981b0f8c411a07f7ef682ac79981f9ce74ca69e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Pid&lt;/code&gt; is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; and delivered to the message queue of &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Pid&lt;/code&gt; est&amp;aacute; capturando salidas, la se&amp;ntilde;al de salida se transforma en un mensaje &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; y se env&amp;iacute;a a la cola de mensajes de &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="946409162988d6dc1aff5bb11d67c23349fa4844" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist and checking it is cheap, a &lt;code&gt;noproc&lt;/code&gt; error is raised. Currently, checking is cheap if the &lt;code&gt;PidOrPort&lt;/code&gt; is local and the caller does not trap exits (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2 &lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e139aa51e35a6da6edcc143ed04c057990132602" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; does not exist, the behavior of the BIF depends on if the calling process is trapping exits or not (see &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt;):</source>
          <target state="translated">Si &lt;code&gt;PidOrPort&lt;/code&gt; no existe, el comportamiento del BIF depende de si el proceso de llamada est&amp;aacute; atrapando salidas o no (ver &lt;code&gt;&lt;a href=&quot;#process_flag-2&quot;&gt;process_flag/2&lt;/a&gt;&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="266b9e9cd253c4e1b334cac8528b2a62708531c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PidOrPort&lt;/code&gt; is not an existing local process or port.</source>
          <target state="translated">Si &lt;code&gt;PidOrPort&lt;/code&gt; no es un proceso o puerto local existente.</target>
        </trans-unit>
        <trans-unit id="ea3c1727e46c2f29d355231a14b993fe9ee7f045" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns a free UDP port, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">Si &lt;code&gt;Port == 0&lt;/code&gt; , el SO subyacente asigna un puerto UDP libre, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; para recuperarlo.</target>
        </trans-unit>
        <trans-unit id="d7fa31d4ca670522aa140145b3a60537cc2e5b54" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port == 0&lt;/code&gt;, the underlying OS assigns an available port number, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; to retrieve it.</source>
          <target state="translated">Si &lt;code&gt;Port == 0&lt;/code&gt; , el sistema operativo subyacente asigna un n&amp;uacute;mero de puerto disponible, use &lt;code&gt;&lt;a href=&quot;inet#port-1&quot;&gt;inet:port/1&lt;/a&gt;&lt;/code&gt; para recuperarlo.</target>
        </trans-unit>
        <trans-unit id="fb219559d25b9731f030a5d6d757dbdd7db890b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an identifier of an open port, or the registered name of an open port. If the calling process was previously linked to the closed port, identified by &lt;code&gt;Port&lt;/code&gt;, the exit signal from the port is guaranteed to be delivered before this &lt;code&gt;badarg&lt;/code&gt; exception occurs.</source>
          <target state="translated">Si &lt;code&gt;Port&lt;/code&gt; no es un identificador de un puerto abierto o el nombre registrado de un puerto abierto. Si el proceso de llamada se vincul&amp;oacute; previamente al puerto cerrado, identificado por &lt;code&gt;Port&lt;/code&gt; , se garantiza que la se&amp;ntilde;al de salida del puerto se entregar&amp;aacute; antes de que &lt;code&gt;badarg&lt;/code&gt; esta excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="0702a363d6583ab49124103adeca84fa54bd565c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Port&lt;/code&gt; is not an open port or the registered name of an open port.</source>
          <target state="translated">Si &lt;code&gt;Port&lt;/code&gt; no es un puerto abierto o el nombre registrado de un puerto abierto.</target>
        </trans-unit>
        <trans-unit id="ad97fac62d783a4932985f8dd89585d539b9ba38" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;PosLen&lt;/code&gt; in any way references outside the binary, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si &lt;code&gt;PosLen&lt;/code&gt; de alguna manera hace referencia fuera del binario, se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n badarg .</target>
        </trans-unit>
        <trans-unit id="5fa9284a8e57969389fe13ab25086a491ce7496c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Prefix&lt;/code&gt; is the prefix of &lt;code&gt;String&lt;/code&gt;, removes it and returns the remainder of &lt;code&gt;String&lt;/code&gt;, otherwise returns &lt;code&gt;nomatch&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Prefix&lt;/code&gt; es el prefijo de &lt;code&gt;String&lt;/code&gt; , lo elimina y devuelve el resto de &lt;code&gt;String&lt;/code&gt; ; de lo contrario, devuelve &lt;code&gt;nomatch&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4e6b8924461855959440e4adc224de1af86a752" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;QH2&lt;/code&gt; is a call to the function for &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt;, as defined in section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt;, then &lt;code&gt;gb_table:table/1&lt;/code&gt;, the iterator for the gb-tree is initiated for each answer to &lt;code&gt;QH1&lt;/code&gt;. The objects of the gb-tree are then returned one by one. This is probably the most efficient way of traversing the table in that case, as it takes minimal computational power to get the following object. But if &lt;code&gt;QH2&lt;/code&gt; is not a table but a more complicated QLC, it can be more efficient to use some RAM memory for collecting the answers in a cache, particularly if there are only a few answers. It must then be assumed that evaluating &lt;code&gt;QH2&lt;/code&gt; has no side effects so that the meaning of the query does not change if &lt;code&gt;QH2&lt;/code&gt; is evaluated only once. One way of caching the answers is to evaluate &lt;code&gt;QH2&lt;/code&gt; first of all and substitute the list of answers for &lt;code&gt;QH2&lt;/code&gt; in the query. Another way is to use option &lt;code&gt;cache&lt;/code&gt;. It is expressed like this:</source>
          <target state="translated">Si &lt;code&gt;QH2&lt;/code&gt; es una llamada a la funci&amp;oacute;n para &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; , como se define en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; , entonces &lt;code&gt;gb_table:table/1&lt;/code&gt; , el iterador para el &amp;aacute;rbol gb se inicia para cada respuesta a &lt;code&gt;QH1&lt;/code&gt; . Los objetos del &amp;aacute;rbol gb se devuelven uno por uno. Esta es probablemente la forma m&amp;aacute;s eficiente de recorrer la tabla en ese caso, ya que se necesita un poder de c&amp;aacute;lculo m&amp;iacute;nimo para obtener el siguiente objeto. Pero si &lt;code&gt;QH2&lt;/code&gt; no es una tabla sino un QLC m&amp;aacute;s complicado, puede ser m&amp;aacute;s eficiente usar algo de memoria RAM para recopilar las respuestas en un cach&amp;eacute;, particularmente si solo hay unas pocas respuestas. Entonces debe asumirse que la evaluaci&amp;oacute;n de &lt;code&gt;QH2&lt;/code&gt; no tiene efectos secundarios, por lo que el significado de la consulta no cambia si &lt;code&gt;QH2&lt;/code&gt; se eval&amp;uacute;a solo una vez. Una forma de almacenar en cach&amp;eacute; las respuestas es evaluar &lt;code&gt;QH2&lt;/code&gt; en primer lugar y sustituir la lista de respuestas por &lt;code&gt;QH2&lt;/code&gt; en la consulta. Otra forma es utilizar la &lt;code&gt;cache&lt;/code&gt; opciones . Se expresa as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="491d904b6ae249fbebb7daf8bc786e22605cc650" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;kill&lt;/code&gt;, that is, if &lt;code&gt;exit(Pid, kill)&lt;/code&gt; is called, an untrappable exit signal is sent to &lt;code&gt;Pid&lt;/code&gt;, which unconditionally exits with exit reason &lt;code&gt;killed&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Reason&lt;/code&gt; es la &lt;code&gt;kill&lt;/code&gt; del &amp;aacute;tomo , es decir, si se llama a &lt;code&gt;exit(Pid, kill)&lt;/code&gt; , se env&amp;iacute;a una se&amp;ntilde;al de salida que no se puede atrapar a &lt;code&gt;Pid&lt;/code&gt; , que sale incondicionalmente con la raz&amp;oacute;n de salida &lt;code&gt;killed&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35fbbe7923611fc3677c5eb123690517ee7e8658" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Reason&lt;/code&gt; is the atom &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;Pid&lt;/code&gt; does not exit. If it is trapping exits, the exit signal is transformed into a message &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; and delivered to its message queue.</source>
          <target state="translated">Si &lt;code&gt;Reason&lt;/code&gt; es el &amp;aacute;tomo &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;Pid&lt;/code&gt; no sale. Si est&amp;aacute; capturando salidas, la se&amp;ntilde;al de salida se transforma en un mensaje &lt;code&gt;{'EXIT', From, normal}&lt;/code&gt; y se env&amp;iacute;a a su cola de mensajes.</target>
        </trans-unit>
        <trans-unit id="cd196dac154540858e61e812e21e07f3f0b754dd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; has the value &lt;code&gt;{Tag, Recv}&lt;/code&gt;, the delivery is done according to &lt;code&gt;Recv&lt;/code&gt;:</source>
          <target state="translated">Si &lt;code&gt;Receiver&lt;/code&gt; tiene el valor &lt;code&gt;{Tag, Recv}&lt;/code&gt; , la entrega se realiza de acuerdo con &lt;code&gt;Recv&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="868986f0a85c44f9afa64f0b61bdc67eb57beed0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Receiver&lt;/code&gt; is a &lt;code&gt;notification_delivery_info()&lt;/code&gt; record, then the information about the notification delivery will be delivered to the &lt;code&gt;receiver&lt;/code&gt; via the callback functions defined by the &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; behaviour according to the content of the &lt;code&gt;notification_delivery_info()&lt;/code&gt; record.</source>
          <target state="translated">Si &lt;code&gt;Receiver&lt;/code&gt; es un registro &lt;code&gt;notification_delivery_info()&lt;/code&gt; , entonces la informaci&amp;oacute;n sobre la entrega de la notificaci&amp;oacute;n se entregar&amp;aacute; al &lt;code&gt;receiver&lt;/code&gt; trav&amp;eacute;s de las funciones de devoluci&amp;oacute;n de llamada definidas por el comportamiento &lt;code&gt;&lt;a href=&quot;snmpa_notification_delivery_info_receiver&quot;&gt;snmpa_notification_delivery_info_receiver&lt;/a&gt;&lt;/code&gt; de acuerdo con el contenido del registro &lt;code&gt;notification_delivery_info()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="508d6986d5eeb87f61b9a5f9d5b4f17fa77bcfb6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is already in use.</source>
          <target state="translated">Si &lt;code&gt;RegName&lt;/code&gt; ya est&amp;aacute; en uso.</target>
        </trans-unit>
        <trans-unit id="ae95dfac53a373131ac9010b1c1e1134c4182f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;RegName&lt;/code&gt; is the atom &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;RegName&lt;/code&gt; es el &amp;aacute;tomo &lt;code&gt;undefined&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0f5e564e5fd5ab3c1d7b8ad071d580aac2f45e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Repair&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the current log file is repaired, if needed. As the restoration is initiated, a message is output on the error log. If &lt;code&gt;false&lt;/code&gt; is specified, no automatic repair is attempted. Instead, the tuple &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; is returned if an attempt is made to open a corrupt log file. If &lt;code&gt;truncate&lt;/code&gt; is specified, the log file becomes truncated, creating an empty log. Defaults to &lt;code&gt;true&lt;/code&gt;, which has no effect on logs opened in read-only mode.</source>
          <target state="translated">Si &lt;code&gt;Repair&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el archivo de registro actual se repara, si es necesario. Cuando se inicia la restauraci&amp;oacute;n, se genera un mensaje en el registro de errores. Si se especifica &lt;code&gt;false&lt;/code&gt; , no se intentar&amp;aacute; ninguna reparaci&amp;oacute;n autom&amp;aacute;tica. En su lugar, se devuelve la tupla &lt;code&gt;{error, {need_repair, Log}}&lt;/code&gt; si se intenta abrir un archivo de registro corrupto. Si se especifica &lt;code&gt;truncate&lt;/code&gt; , el archivo de registro se trunca, creando un registro vac&amp;iacute;o. El valor predeterminado es &lt;code&gt;true&lt;/code&gt; , que no tiene ning&amp;uacute;n efecto en los registros abiertos en modo de solo lectura.</target>
        </trans-unit>
        <trans-unit id="fba0a2d131df8af1eeb91211c8b8a8dde41e75fd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Report&lt;/code&gt; is a map, it is converted to a key-value list before formatting as such.</source>
          <target state="translated">Si &lt;code&gt;Report&lt;/code&gt; es un mapa, se convierte en una lista de valores-clave antes de formatearlo como tal.</target>
        </trans-unit>
        <trans-unit id="15d8d66582408c3486d2e25500d0a72b68b8cb9f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ReqId&lt;/code&gt; is less then 0, it means that this information was not available to the manager (that info was never retrieved before the message was discarded).</source>
          <target state="translated">Si &lt;code&gt;ReqId&lt;/code&gt; es menor que 0, significa que esta informaci&amp;oacute;n no estaba disponible para el administrador (esa informaci&amp;oacute;n nunca se recuper&amp;oacute; antes de que se descartara el mensaje).</target>
        </trans-unit>
        <trans-unit id="0dee047b2dfd5610136ab93118e486cde7422df3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; &amp;gt; 0, the packet only consists of &lt;code&gt;[119, Result]&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; ado &amp;gt; 0, el paquete solo consta de &lt;code&gt;[119, Result]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c802495174a415d0a94a21a32d111d68231fb125" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This because the timer had expired, or been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never has corresponded to a timer. Even if the timer has expired, it does not tell you whether or not the time-out message has arrived at its destination yet.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , no se pudo encontrar un temporizador correspondiente a &lt;code&gt;TimerRef&lt;/code&gt; . Esto se debe a que el temporizador ha expirado o se ha cancelado, o porque &lt;code&gt;TimerRef&lt;/code&gt; nunca ha correspondido a un temporizador. Incluso si el temporizador ha expirado, no le dice si el mensaje de tiempo de espera ha llegado a su destino o no.</target>
        </trans-unit>
        <trans-unit id="c0a8cfe624c240dfdb507f48e9d219914e2f948e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, a timer corresponding to &lt;code&gt;TimerRef&lt;/code&gt; could not be found. This can be either because the timer had expired, already had been canceled, or because &lt;code&gt;TimerRef&lt;/code&gt; never corresponded to a timer. Even if the timer had expired, it does not tell you if the time-out message has arrived at its destination yet.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , no se pudo encontrar un temporizador correspondiente a &lt;code&gt;TimerRef&lt;/code&gt; . Esto puede deberse a que el temporizador hab&amp;iacute;a expirado, ya se hab&amp;iacute;a cancelado o porque &lt;code&gt;TimerRef&lt;/code&gt; nunca correspondi&amp;oacute; a un temporizador. Incluso si el temporizador ha expirado, no le indica si el mensaje de tiempo de espera ha llegado a su destino.</target>
        </trans-unit>
        <trans-unit id="bd4390894559b806475261afd409260099fb0615" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the canceled timer would have expired.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; es un n&amp;uacute;mero entero, representa el tiempo en milisegundos que queda hasta que el temporizador cancelado haya expirado.</target>
        </trans-unit>
        <trans-unit id="8b2e483082bcb6a7c95be17d5564ab01e1806263" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Result&lt;/code&gt; is an integer, it represents the time in milliseconds left until the timer expires.</source>
          <target state="translated">Si &lt;code&gt;Result&lt;/code&gt; es un n&amp;uacute;mero entero, representa el tiempo en milisegundos que queda hasta que expira el temporizador.</target>
        </trans-unit>
        <trans-unit id="996c07f00aef0bf25f1adad8d4b5c2f0b7da6aa8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Rules&lt;/code&gt; is left out or is an empty list, the default system rules are used. See also the Kernel application parameter &lt;code&gt;source_search_rules&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Rules&lt;/code&gt; se omite o es una lista vac&amp;iacute;a, se utilizan las reglas del sistema predeterminadas. Consulte tambi&amp;eacute;n el par&amp;aacute;metro de la aplicaci&amp;oacute;n Kernel &lt;code&gt;source_search_rules&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="914c10ab17b1be80fb703c7a051a9650d90020cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Schedulers&lt;/code&gt; or &lt;code&gt;SchedulersOnline&lt;/code&gt; is specified as a negative number, the value is subtracted from the default number of logical processors configured or logical processors available, respectively.</source>
          <target state="translated">Si &lt;code&gt;Schedulers&lt;/code&gt; o &lt;code&gt;SchedulersOnline&lt;/code&gt; se especifica como un n&amp;uacute;mero negativo, el valor se resta del n&amp;uacute;mero predeterminado de procesadores l&amp;oacute;gicos configurados o procesadores l&amp;oacute;gicos disponibles, respectivamente.</target>
        </trans-unit>
        <trans-unit id="1d347e571bfea9b8b89077684381b3f15fcd946f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Scope&lt;/code&gt; of the operation is &lt;code&gt;local&lt;/code&gt;, the fallback is only installed on the local node.</source>
          <target state="translated">Si el &lt;code&gt;Scope&lt;/code&gt; de la operaci&amp;oacute;n es &lt;code&gt;local&lt;/code&gt; , la reserva solo se instala en el nodo local.</target>
        </trans-unit>
        <trans-unit id="998a85ab406edc34895d37ac87304bcc5cc05937" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="translated">Si el &lt;code&gt;Server&lt;/code&gt; es &lt;code&gt;self()&lt;/code&gt; se crea un servidor an&amp;oacute;nimo al igual que cuando se usa &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link]/3&lt;/a&gt;&lt;/code&gt; . Si el &lt;code&gt;Server&lt;/code&gt; es un &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; se crea un servidor con nombre como cuando se usa &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link]/4&lt;/a&gt;&lt;/code&gt; . Sin embargo, el nombre &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; debe haberse registrado en consecuencia &lt;strong&gt;antes de&lt;/strong&gt; llamar a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1c6410f6c768335757d34c90fcb80d9e00d2828e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server&lt;/code&gt; is &lt;code&gt;self()&lt;/code&gt; an anonymous server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-3&quot;&gt;start[_link|_monitor]/3&lt;/a&gt;&lt;/code&gt;. If &lt;code&gt;Server&lt;/code&gt; is a &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; a named server is created just as when using &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start[_link|_monitor]/4&lt;/a&gt;&lt;/code&gt;. However, the &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; name must have been registered accordingly &lt;strong&gt;before&lt;/strong&gt; this function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e26e129826cd4fdc57a94f1e90b9b33f3e22dc0a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49ccf350dd38e4a46c92e05cf1457282aa2a2b57" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process id registered globally as &lt;code&gt;GlobalName&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt; If no name is provided, the &lt;code&gt;gen_server&lt;/code&gt; process is not registered.</source>
          <target state="translated">Si &lt;code&gt;ServerName={global,GlobalName}&lt;/code&gt; , la &lt;code&gt;gen_server&lt;/code&gt; proceso gen_server se registr&amp;oacute; globalmente como &lt;code&gt;GlobalName&lt;/code&gt; usando &lt;code&gt;global:register_name/2&lt;/code&gt; Si no se proporciona ning&amp;uacute;n nombre, el proceso &lt;code&gt;gen_server&lt;/code&gt; no est&amp;aacute; registrado.</target>
        </trans-unit>
        <trans-unit id="c99d7d2ec0751d55a79f6c64ef86b68f3b33366c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={local,Name}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;ServerName={local,Name}&lt;/code&gt; , el proceso &lt;code&gt;gen_server&lt;/code&gt; se registra localmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4471e49d4ac17a2da6d90db02e958498fd4eca78" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process registers with the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback is to export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, &lt;code&gt;whereis_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Si &lt;code&gt;ServerName={via,Module,ViaName}&lt;/code&gt; , el proceso &lt;code&gt;gen_server&lt;/code&gt; se registra en el registro representado por &lt;code&gt;Module&lt;/code&gt; . La devoluci&amp;oacute;n de llamada del &lt;code&gt;Module&lt;/code&gt; es para exportar las funciones &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; , &lt;code&gt;whereis_name/1&lt;/code&gt; y &lt;code&gt;send/2&lt;/code&gt; , que deben comportarse como las funciones correspondientes en &lt;code&gt;global&lt;/code&gt; . Por lo tanto, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; es una referencia v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="1a7d3d4777e0d9530a017faf5e5e71aeba400cf2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Server_or_Actions&lt;/code&gt; is a &lt;code&gt;list()&lt;/code&gt;, the same as &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; except that no &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; must have been registered and &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt;. This creates an anonymous server.</source>
          <target state="translated">Si &lt;code&gt;Server_or_Actions&lt;/code&gt; es una &lt;code&gt;list()&lt;/code&gt; , lo mismo que &lt;code&gt;&lt;a href=&quot;#enter_loop-6&quot;&gt;enter_loop/6&lt;/a&gt;&lt;/code&gt; excepto que no se debe haber registrado ning&amp;uacute;n &lt;code&gt;&lt;a href=&quot;#type-server_name&quot;&gt;server_name()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;Actions = Server_or_Actions&lt;/code&gt; . Esto crea un servidor an&amp;oacute;nimo.</target>
        </trans-unit>
        <trans-unit id="0cc5ba33de3003e688f8911d6e6894d616033d12" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SetFun&lt;/code&gt; is a number i &amp;gt;= 1 and &lt;code&gt;Set1&lt;/code&gt; is a relation, then the returned set is the &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; of &lt;code&gt;Set1&lt;/code&gt; onto coordinate i.</source>
          <target state="translated">Si &lt;code&gt;SetFun&lt;/code&gt; es un n&amp;uacute;mero i&amp;gt; = 1 y &lt;code&gt;Set1&lt;/code&gt; es una relaci&amp;oacute;n, entonces el conjunto devuelto es la &lt;code&gt;&lt;a href=&quot;#projection&quot;&gt;projection&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;Set1&lt;/code&gt; sobre la coordenada i.</target>
        </trans-unit>
        <trans-unit id="fa9d9044e1d8e367fe63682c042ce5ba7e21718e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the SSL/TLS server-side handshake and returns a TLS socket.</source>
          <target state="translated">Si &lt;code&gt;Socket&lt;/code&gt; es un &lt;code&gt;socket()&lt;/code&gt; normal () : actualiza un &lt;code&gt;gen_tcp&lt;/code&gt; , o equivalente, a un socket SSL, es decir, realiza el protocolo de enlace del lado del servidor SSL / TLS y devuelve un socket TLS.</target>
        </trans-unit>
        <trans-unit id="3a8532805c883f6bbdef2dbf1ab5fafde57ede65" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is a ordinary &lt;code&gt;socket()&lt;/code&gt;: upgrades a &lt;code&gt;gen_tcp&lt;/code&gt;, or equivalent, socket to an SSL socket, that is, performs the TLS server-side handshake and returns a TLS socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f51cfa021b587914b8d535a367aab8a9c4e3a8b9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;&lt;a href=&quot;#type-sslsocket&quot;&gt; sslsocket() &lt;/a&gt;&lt;/code&gt;: provides extra TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da7fd7fd2a8598b74434eb489d432414fe4daa4b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Socket&lt;/code&gt; is an &lt;code&gt;sslsocket()&lt;/code&gt;: provides extra SSL/TLS/DTLS options to those specified in &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; and then performs the SSL/TLS/DTLS handshake. Returns a new TLS/DTLS socket if the handshake is successful.</source>
          <target state="translated">Si &lt;code&gt;Socket&lt;/code&gt; es un &lt;code&gt;sslsocket()&lt;/code&gt; : proporciona opciones adicionales SSL / TLS / DTLS a las especificadas en &lt;code&gt;&lt;a href=&quot;#listen-2&quot;&gt;listen/2&lt;/a&gt;&lt;/code&gt; y luego realiza el protocolo de enlace SSL / TLS / DTLS. Devuelve un nuevo socket TLS / DTLS si el protocolo de enlace es exitoso.</target>
        </trans-unit>
        <trans-unit id="4841c9f7a71e862586a5146811fbbbda9e0a5d0e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Source&lt;/code&gt; refers to a filename, it is opened with &lt;code&gt;read&lt;/code&gt; mode prepended to the mode list before the copy, and closed when done.</source>
          <target state="translated">Si &lt;code&gt;Source&lt;/code&gt; refiere a un nombre de archivo, se abre con el modo de &lt;code&gt;read&lt;/code&gt; antepuesto a la lista de modos antes de la copia y se cierra cuando termina.</target>
        </trans-unit>
        <trans-unit id="b32d5c9aabdee11f000c96e5dc5cd00d32eea8d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt;, separate tests will be created per specification. If &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt;, all specifications will be merge into one test.</source>
          <target state="translated">Si &lt;code&gt;SpecsIn=[Spec1,Spec2,...]&lt;/code&gt; , se crear&amp;aacute;n pruebas independientes por especificaci&amp;oacute;n. Si &lt;code&gt;SpecsIn=[[Spec1,Spec2,...]]&lt;/code&gt; , todas las especificaciones se fusionar&amp;aacute;n en una sola prueba.</target>
        </trans-unit>
        <trans-unit id="64318942ad99e2a283846e85b41c1a1a90a245d7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Streams&lt;/code&gt; is an empty list, &lt;strong&gt;all&lt;/strong&gt; streams are requested by sending the following filter:</source>
          <target state="translated">Si &lt;code&gt;Streams&lt;/code&gt; es una lista vac&amp;iacute;a, &lt;strong&gt;todos los&lt;/strong&gt; streams se solicitan enviando el siguiente filtro:</target>
        </trans-unit>
        <trans-unit id="5a57f3a703460decb9f940e7b918e0ac60764ffe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0bddbecc2df41f591669985046f32e7a92f59d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt;, the supervisor bridge is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;SupBridgeName={global,Name}&lt;/code&gt; , el puente supervisor se registra globalmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="55b58db32cac80b6fba959bc6eb9beb456afa271" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt;, the supervisor bridge is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;SupBridgeName={local,Name}&lt;/code&gt; , el puente supervisor se registra localmente como &lt;code&gt;Name&lt;/code&gt; usando el &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="72424d21ee1e4f64401815083aa13a425812c98c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt;, the supervisor bridge is registered as &lt;code&gt;Name&lt;/code&gt; using a registry represented by Module. The &lt;code&gt;Module&lt;/code&gt; callback is to export functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which are to behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Si &lt;code&gt;SupBridgeName={via,Module,Name}&lt;/code&gt; , el puente supervisor se registra como &lt;code&gt;Name&lt;/code&gt; usando un registro representado por Module. La devoluci&amp;oacute;n de llamada del &lt;code&gt;Module&lt;/code&gt; es para exportar las funciones &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; y &lt;code&gt;send/2&lt;/code&gt; , que deben comportarse como las funciones correspondientes en &lt;code&gt;global&lt;/code&gt; . Por lo tanto, &lt;code&gt;{via,global,GlobalName}&lt;/code&gt; es una referencia v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="e6570ba727a9a3893fd9a3d0b799b833bf1451e0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt; global:register_name/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e7b2fcdf9c47fb2dceee651299ffa41113ce50c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={global,Name}&lt;/code&gt;, the supervisor is registered globally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;global:register_name/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;SupName={global,Name}&lt;/code&gt; , el supervisor se registra globalmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;global:register_name/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a94898f62db8e0366c9e39384d40e7b1aeef50e9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={local,Name}&lt;/code&gt;, the supervisor is registered locally as &lt;code&gt;Name&lt;/code&gt; using &lt;code&gt;register/2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;SupName={local,Name}&lt;/code&gt; , el supervisor se registra localmente como &lt;code&gt;Name&lt;/code&gt; usando &lt;code&gt;register/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="302a4ec0f93e1a3b85f4525fc68100cb7ea134fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt;, the supervisor is registered as &lt;code&gt;Name&lt;/code&gt; using the registry represented by &lt;code&gt;Module&lt;/code&gt;. The &lt;code&gt;Module&lt;/code&gt; callback must export the functions &lt;code&gt;register_name/2&lt;/code&gt;, &lt;code&gt;unregister_name/1&lt;/code&gt;, and &lt;code&gt;send/2&lt;/code&gt;, which must behave like the corresponding functions in &lt;code&gt;global&lt;/code&gt;. Thus, &lt;code&gt;{via,global,Name}&lt;/code&gt; is a valid reference.</source>
          <target state="translated">Si &lt;code&gt;SupName={via,Module,Name}&lt;/code&gt; , el supervisor se registra como &lt;code&gt;Name&lt;/code&gt; usando el registro representado por &lt;code&gt;Module&lt;/code&gt; . La devoluci&amp;oacute;n de llamada del &lt;code&gt;Module&lt;/code&gt; debe exportar las funciones &lt;code&gt;register_name/2&lt;/code&gt; , &lt;code&gt;unregister_name/1&lt;/code&gt; y &lt;code&gt;send/2&lt;/code&gt; , que deben comportarse como las funciones correspondientes en &lt;code&gt;global&lt;/code&gt; . Por lo tanto, &lt;code&gt;{via,global,Name}&lt;/code&gt; es una referencia v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="e19abc8d0154d9b15c235deec3229c13afe0bfd1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Suspendee&lt;/code&gt; is not a process identifier.</source>
          <target state="translated">Si &lt;code&gt;Suspendee&lt;/code&gt; no es un identificador de proceso.</target>
        </trans-unit>
        <trans-unit id="c9f3eb71690e00c625f528d1a166e4c2803c3742" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; can be matched, the function returns a non-zero value and binds any unbound variables in &lt;code&gt;Pattern&lt;/code&gt;. If &lt;code&gt;Term&lt;/code&gt; and &lt;code&gt;Pattern&lt;/code&gt; do not match, &lt;code&gt;0&lt;/code&gt; is returned. For example:</source>
          <target state="translated">Si se pueden hacer coincidir &lt;code&gt;Term&lt;/code&gt; y &lt;code&gt;Pattern&lt;/code&gt; , la funci&amp;oacute;n devuelve un valor distinto de cero y vincula las variables no vinculadas en &lt;code&gt;Pattern&lt;/code&gt; . Si el &lt;code&gt;Term&lt;/code&gt; y el &lt;code&gt;Pattern&lt;/code&gt; no coinciden, se devuelve &lt;code&gt;0&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c379e61ba098c472d84880da68787d8cf49e4a92" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;, no timer is started, as it never would expire anyway.</source>
          <target state="translated">Si el &lt;code&gt;Time&lt;/code&gt; es &lt;code&gt;infinity&lt;/code&gt; , no se inicia ning&amp;uacute;n temporizador, ya que nunca caducar&amp;iacute;a de todos modos.</target>
        </trans-unit>
        <trans-unit id="361b493363d47b76898e36a3b534cb11d8d0b1ba" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event, but after already queued events.</source>
          <target state="translated">Si el &lt;code&gt;Time&lt;/code&gt; es relativo y &lt;code&gt;0&lt;/code&gt; no se inicia realmente ning&amp;uacute;n temporizador, en su lugar, el evento de tiempo de espera se pone en cola para garantizar que se procese antes de cualquier evento externo a&amp;uacute;n no recibido, pero despu&amp;eacute;s de los eventos ya en cola.</target>
        </trans-unit>
        <trans-unit id="53be15db077d9f7386a9212d414b5bbc5efc8b98" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is relative and &lt;code&gt;0&lt;/code&gt; no timer is actually started, instead the the time-out event is enqueued to ensure that it gets processed before any not yet received external event.</source>
          <target state="translated">Si el &lt;code&gt;Time&lt;/code&gt; es relativo y &lt;code&gt;0&lt;/code&gt; no se inicia realmente ning&amp;uacute;n temporizador, el evento de tiempo de espera se pone en cola para garantizar que se procese antes de cualquier evento externo a&amp;uacute;n no recibido.</target>
        </trans-unit>
        <trans-unit id="576d56f7b80afa9316129970fc76da4c8c90a6b6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;Ret = {error, timeout}&lt;/code&gt; will be returned, and the process is killed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df42bd176e1545f79c00a2e65e652086e9d32d4d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Time&lt;/code&gt; is specified as an integer, this function waits for &lt;code&gt;Time&lt;/code&gt; milliseconds for the new process to call &lt;code&gt;init_ack&lt;/code&gt;, or &lt;code&gt;{error, timeout}&lt;/code&gt; is returned, and the process is killed.</source>
          <target state="translated">Si &lt;code&gt;Time&lt;/code&gt; se especifica como un n&amp;uacute;mero entero, esta funci&amp;oacute;n espera milisegundos de &lt;code&gt;Time&lt;/code&gt; para que el nuevo proceso llame a &lt;code&gt;init_ack&lt;/code&gt; , o se devuelve &lt;code&gt;{error, timeout}&lt;/code&gt; y el proceso se mata.</target>
        </trans-unit>
        <trans-unit id="4be60462090656e0a73c06a85dd1300e3f12ecfa" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Timeout&lt;/code&gt; is set to an integer value in milliseconds, Mnesia forces &quot;heavyweight transactions&quot; to be finished, even if the outcome of the transaction for the moment is unclear. After &lt;code&gt;Timeout&lt;/code&gt; milliseconds, Mnesia commits or terminates the transaction and continues with the startup. This can lead to a situation where the transaction is committed on some nodes and terminated on other nodes. If the transaction is a schema transaction, the inconsistency can be fatal.</source>
          <target state="translated">Si &lt;code&gt;Timeout&lt;/code&gt; se establece en un valor entero en milisegundos, Mnesia fuerza la finalizaci&amp;oacute;n de las &quot;transacciones de peso pesado&quot;, incluso si el resultado de la transacci&amp;oacute;n por el momento no est&amp;aacute; claro. Despu&amp;eacute;s de milisegundos de &lt;code&gt;Timeout&lt;/code&gt; , Mnesia confirma o termina la transacci&amp;oacute;n y contin&amp;uacute;a con el inicio. Esto puede llevar a una situaci&amp;oacute;n en la que la transacci&amp;oacute;n se confirma en algunos nodos y finaliza en otros nodos. Si la transacci&amp;oacute;n es una transacci&amp;oacute;n de esquema, la inconsistencia puede ser fatal.</target>
        </trans-unit>
        <trans-unit id="714a8fc4e60ac83febb0eba6e2e43aa29c1e43cd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;To &amp;gt; From - Incr&lt;/code&gt; e &lt;code&gt;Incr &amp;lt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="116f28b654e1b2114f084ce63da092181669b950" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt;.</source>
          <target state="translated">If &lt;code&gt;To &amp;lt; From - Incr&lt;/code&gt; and &lt;code&gt;Incr &amp;gt; 0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54f93f73769a89bfaa867aaa2f8894d3965b6413" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;TupleOfBinRels&lt;/code&gt; is a non-empty tuple {R[1], ..., R[n]} of binary relations and &lt;code&gt;BinRel1&lt;/code&gt; is a binary relation, then &lt;code&gt;BinRel2&lt;/code&gt; is the &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; of the ordered set (R[i], ..., R[n]) and &lt;code&gt;BinRel1&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;TupleOfBinRels&lt;/code&gt; es una tupla no vac&amp;iacute;a {R [1], ..., R [n]} de relaciones binarias y &lt;code&gt;BinRel1&lt;/code&gt; es una relaci&amp;oacute;n binaria, entonces &lt;code&gt;BinRel2&lt;/code&gt; es el &lt;code&gt;&lt;a href=&quot;#multiple_relative_product&quot;&gt;multiple relative product&lt;/a&gt;&lt;/code&gt; del conjunto ordenado (R [i], ..., R [n]) y &lt;code&gt;BinRel1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c970d03f8f213aa54cea6a63852543e1427736a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = load&lt;/code&gt;, the application is only loaded.</source>
          <target state="translated">Si &lt;code&gt;Type = load&lt;/code&gt; , la aplicaci&amp;oacute;n solo se carga.</target>
        </trans-unit>
        <trans-unit id="ef46ddc91155f5582e897510a78e384c324f3ca3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = none&lt;/code&gt;, the application is not loaded and not started, although the code for its modules is loaded.</source>
          <target state="translated">Si &lt;code&gt;Type = none&lt;/code&gt; , la aplicaci&amp;oacute;n no se carga ni se inicia, aunque se carga el c&amp;oacute;digo de sus m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="ee9c99386deae4cad26ab6d667423f3c8e7d9d82" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt;, the application is loaded and started in the corresponding way, see &lt;code&gt;application(3)&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Type = permanent | transient | temporary&lt;/code&gt; , la aplicaci&amp;oacute;n se carga y se inicia de la forma correspondiente, ver &lt;code&gt;application(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80d0f32ad447a0f124722ae3ffd089ea15b0187a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;file&lt;/code&gt;, the client reads all trace messages stored in the file named &lt;code&gt;Filename&lt;/code&gt; or specified by &lt;code&gt;WrapFilesSpec&lt;/code&gt; (must be the same as used when creating the trace, see trace_port/2) and let's the default handler function format the messages on the console. This is one way to interpret the data stored in a file by the file trace port driver.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;file&lt;/code&gt; , el cliente lee todos los mensajes de seguimiento almacenados en el archivo llamado &lt;code&gt;Filename&lt;/code&gt; o especificado por &lt;code&gt;WrapFilesSpec&lt;/code&gt; (debe ser el mismo que se us&amp;oacute; al crear el seguimiento, ver trace_port / 2) y deja que la funci&amp;oacute;n del controlador predeterminado formatee los mensajes en la consola . Esta es una forma de interpretar los datos almacenados en un archivo por el controlador del puerto de rastreo de archivos.</target>
        </trans-unit>
        <trans-unit id="a4858c659d369e53d254b355df46af5fbf4c16d3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;follow_file&lt;/code&gt;, the client behaves as in the &lt;code&gt;file&lt;/code&gt; case, but keeps trying to read (and process) more data from the file until stopped by &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;WrapFilesSpec&lt;/code&gt; is not allowed as second argument for this &lt;code&gt;Type&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;follow_file&lt;/code&gt; , el cliente se comporta como en el caso del &lt;code&gt;file&lt;/code&gt; , pero sigue intentando leer (y procesar) m&amp;aacute;s datos del archivo hasta que &lt;code&gt;&lt;a href=&quot;#stop_trace_client-1&quot;&gt;stop_trace_client/1&lt;/a&gt;&lt;/code&gt; lo detiene . &lt;code&gt;WrapFilesSpec&lt;/code&gt; no se permite como segundo argumento para este &lt;code&gt;Type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="180a1fd075134b1e3a57e62da41207ab78634934" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;ip&lt;/code&gt;, the client connects to the TCP/IP port &lt;code&gt;PortNumber&lt;/code&gt; on the host &lt;code&gt;Hostname&lt;/code&gt;, from where it reads trace messages until the TCP/IP connection is closed. If no &lt;code&gt;Hostname&lt;/code&gt; is specified, the local host is assumed.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;ip&lt;/code&gt; , el cliente se conecta al puerto TCP / IP &lt;code&gt;PortNumber&lt;/code&gt; en el host &lt;code&gt;Hostname&lt;/code&gt; , desde donde lee los mensajes de seguimiento hasta que se cierra la conexi&amp;oacute;n TCP / IP. Si no se especifica ning&amp;uacute;n nombre de &lt;code&gt;Hostname&lt;/code&gt; , se asume el host local.</target>
        </trans-unit>
        <trans-unit id="e7f9b8934106158303967177ea69d38323fb0f5a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;port&lt;/code&gt;, then the second parameter should be a &lt;strong&gt;fun&lt;/strong&gt; which takes no arguments and returns a newly opened trace port when called. Such a &lt;strong&gt;fun&lt;/strong&gt; is preferably generated by calling &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;port&lt;/code&gt; , entonces el segundo par&amp;aacute;metro deber&amp;iacute;a ser &lt;strong&gt;divertido&lt;/strong&gt; que no toma argumentos y devuelve un puerto de rastreo reci&amp;eacute;n abierto cuando se llama. Esta &lt;strong&gt;diversi&amp;oacute;n&lt;/strong&gt; se genera preferiblemente llamando a &lt;code&gt;&lt;a href=&quot;#trace_port-2&quot;&gt;trace_port/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcff9f93e9e05e724456b0bced8193fb3bde0690" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;process&lt;/code&gt;, a message handler function can be specified (&lt;code&gt;HandlerSpec&lt;/code&gt;). The handler function, which should be a &lt;code&gt;fun&lt;/code&gt; taking two arguments, will be called for each trace message, with the first argument containing the message as it is and the second argument containing the return value from the last invocation of the fun. The initial value of the second parameter is specified in the &lt;code&gt;InitialData&lt;/code&gt; part of the &lt;code&gt;HandlerSpec&lt;/code&gt;. The &lt;code&gt;HandlerFun&lt;/code&gt; may choose any appropriate action to take when invoked, and can save a state for the next invocation by returning it.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;process&lt;/code&gt; , se puede especificar una funci&amp;oacute;n de controlador de mensajes ( &lt;code&gt;HandlerSpec&lt;/code&gt; ). La funci&amp;oacute;n del controlador, que deber&amp;iacute;a ser &lt;code&gt;fun&lt;/code&gt; tomando dos argumentos, se llamar&amp;aacute; para cada mensaje de seguimiento, con el primer argumento que contiene el mensaje tal como est&amp;aacute; y el segundo argumento contiene el valor de retorno de la &amp;uacute;ltima invocaci&amp;oacute;n de la diversi&amp;oacute;n. El valor inicial del segundo par&amp;aacute;metro se especifica en la parte &lt;code&gt;InitialData&lt;/code&gt; de &lt;code&gt;HandlerSpec&lt;/code&gt; . El &lt;code&gt;HandlerFun&lt;/code&gt; puede elegir cualquier acci&amp;oacute;n apropiada a tomar cuando se invoca, y puede ahorrar un estado para la siguiente invocaci&amp;oacute;n por devolverlo.</target>
        </trans-unit>
        <trans-unit id="a4b1b3641b22ef8f8d51a93d3b2d1b2337213cb2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;public_key&lt;/code&gt; the binary can be either an RFC4716 public key or an OpenSSH public key.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25a5ca48186c13c4c06e74ef1db2027011e4bcd7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;table&lt;/code&gt;, the object to match against is to be a tuple. The function then returns &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is what would have been the result in a real &lt;code&gt;ets:select/2&lt;/code&gt; call, or &lt;code&gt;false&lt;/code&gt; if the match specification does not match the object tuple.</source>
          <target state="translated">Si el &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;table&lt;/code&gt; , el objeto con el que comparar es una tupla. La funci&amp;oacute;n luego devuelve &lt;code&gt;{ok,Result,[],Warnings}&lt;/code&gt; , donde &lt;code&gt;Result&lt;/code&gt; es lo que habr&amp;iacute;a sido el resultado en una llamada &lt;code&gt;ets:select/2&lt;/code&gt; real , o &lt;code&gt;false&lt;/code&gt; si la especificaci&amp;oacute;n de coincidencia no coincide con la tupla del objeto.</target>
        </trans-unit>
        <trans-unit id="79b1b01424133793a9f87e15e6618830f393c840" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is &lt;code&gt;trace&lt;/code&gt;, the object to match against is to be a list. The function returns &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt;, where &lt;code&gt;Result&lt;/code&gt; is one of the following:</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; es &lt;code&gt;trace&lt;/code&gt; , el objeto con el que comparar ser&amp;aacute; una lista. La funci&amp;oacute;n devuelve &lt;code&gt;{ok, Result, Flags, Warnings}&lt;/code&gt; , donde &lt;code&gt;Result&lt;/code&gt; es uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="55c96c3e31c21901d76762cfc3c55a1a75e182d6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;Type&lt;/code&gt; is not one of the memory types listed in the description of &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;Type&lt;/code&gt; no es uno de los tipos de memoria enumerados en la descripci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;#memory-0&quot;&gt;erlang:memory/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f09015d085c4ba86f35f77e160ea74ab1cc97841" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[]&lt;/code&gt; is returned, no OS monotonic time is available. The list contains two-tuples with &lt;code&gt;Key&lt;/code&gt;s as first element, and &lt;code&gt;Value&lt;/code&gt;s as second element. The order of these tuples is undefined. The following tuples can be part of the list, but more tuples can be introduced in the future:</source>
          <target state="translated">Si se devuelve &lt;code&gt;[]&lt;/code&gt; , no hay tiempo monot&amp;oacute;nico de SO disponible. La lista contiene dos tuplas con &lt;code&gt;Key&lt;/code&gt; s como primer elemento y &lt;code&gt;Value&lt;/code&gt; s como segundo elemento. El orden de estas tuplas no est&amp;aacute; definido. Las siguientes tuplas pueden formar parte de la lista, pero se pueden introducir m&amp;aacute;s tuplas en el futuro:</target>
        </trans-unit>
        <trans-unit id="0dab6e7436a7ad654f072804193938c789548d28" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;[node()]&lt;/code&gt; then a connection is rejected if another already exists on any of the specified nodes. Types &lt;code&gt;false&lt;/code&gt;, &lt;code&gt;node&lt;/code&gt;, &lt;code&gt;nodes&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; are equivalent to &lt;code&gt;[]&lt;/code&gt;, &lt;code&gt;[node()]&lt;/code&gt;, &lt;code&gt;[node()|nodes()]&lt;/code&gt; and the evaluated value respectively, evaluation of each expression taking place whenever a new connection is to be established. Note that &lt;code&gt;false&lt;/code&gt; allows an unlimited number of connections to be established with the same peer.</source>
          <target state="translated">Si &lt;code&gt;[node()]&lt;/code&gt; , se rechaza una conexi&amp;oacute;n si ya existe otra en cualquiera de los nodos especificados. Los tipos &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;node&lt;/code&gt; , &lt;code&gt;nodes&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; son equivalentes a &lt;code&gt;[]&lt;/code&gt; , &lt;code&gt;[node()]&lt;/code&gt; , &lt;code&gt;[node()|nodes()]&lt;/code&gt; y el valor evaluado respectivamente, la evaluaci&amp;oacute;n de cada expresi&amp;oacute;n tiene lugar cada vez que se va a realizar una nueva conexi&amp;oacute;n establecido. Tenga en cuenta que &lt;code&gt;false&lt;/code&gt; permite establecer un n&amp;uacute;mero ilimitado de conexiones con el mismo par.</target>
        </trans-unit>
        <trans-unit id="295d7333eb893d35be93e144e1767e5d9b639f90" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;active&lt;/code&gt; is specified as an integer &lt;code&gt;N&lt;/code&gt; in the range -32768 to 32767 (inclusive), that number is added to the socket's counting of data messages to be delivered to the controlling process. If the result of the addition is negative, the count is set to &lt;code&gt;0&lt;/code&gt;. Once the count reaches &lt;code&gt;0&lt;/code&gt;, either through the delivery of messages or by being explicitly set with &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt;, the socket mode is automatically reset to passive (&lt;code&gt;{active, false}&lt;/code&gt;). When a socket in this active mode transitions to passive mode, the message &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; is sent to the controlling process to notify it that if it wants to receive more data messages from the socket, it must call &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; to set the socket back into an active mode.</source>
          <target state="translated">Si &lt;code&gt;active&lt;/code&gt; se especifica como un n&amp;uacute;mero entero &lt;code&gt;N&lt;/code&gt; en el rango -32768 a 32767 (inclusive), ese n&amp;uacute;mero se agrega al conteo de mensajes de datos del socket que se entregar&amp;aacute;n al proceso de control. Si el resultado de la suma es negativo, el recuento se establece en &lt;code&gt;0&lt;/code&gt; . Una vez que el recuento llega a &lt;code&gt;0&lt;/code&gt; , ya sea a trav&amp;eacute;s de la entrega de mensajes o al establecerse expl&amp;iacute;citamente con &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; , el modo de socket se restablece autom&amp;aacute;ticamente a pasivo ( &lt;code&gt;{active, false}&lt;/code&gt; ). Cuando un conector en este modo activo &lt;code&gt;{sctp_passive, Socket}&lt;/code&gt; al modo pasivo, el mensaje {sctp_passive, Socket} se env&amp;iacute;a al proceso de control para notificarle que si desea recibir m&amp;aacute;s mensajes de datos del conector, debe llamar &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; para volver a poner el socket en modo activo.</target>
        </trans-unit>
        <trans-unit id="03b183ed01691db59614d150f25d033d938031cb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;alloc&lt;/code&gt; succeeds, &lt;code&gt;dealloc&lt;/code&gt; is also executed. If &lt;code&gt;alloc&lt;/code&gt; fails however, &lt;code&gt;dealloc&lt;/code&gt; is not executed but marked as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log. &lt;code&gt;get_resource_status&lt;/code&gt; runs no matter what happens to the &lt;code&gt;alloc_and_dealloc&lt;/code&gt; cases.</source>
          <target state="translated">Si &lt;code&gt;alloc&lt;/code&gt; tiene &amp;eacute;xito, tambi&amp;eacute;n se ejecuta &lt;code&gt;dealloc&lt;/code&gt; . &lt;code&gt;alloc&lt;/code&gt; embargo, si alloc falla, &lt;code&gt;dealloc&lt;/code&gt; no se ejecuta pero se marca como &lt;code&gt;SKIPPED&lt;/code&gt; en el registro HTML. &lt;code&gt;get_resource_status&lt;/code&gt; se ejecuta sin importar lo que suceda con los casos &lt;code&gt;alloc_and_dealloc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="352b5321f6cc2147596cc6f32fa64b28aba14c20" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;answer_3xxx&lt;/code&gt; then requests are answered without a &lt;code&gt;handle_request/3&lt;/code&gt; callback taking place. If &lt;code&gt;answer&lt;/code&gt; then even 5xxx errors are answered without a callback unless the connection in question has configured the RFC 3588 common dictionary as noted below. If &lt;code&gt;callback&lt;/code&gt; then a &lt;code&gt;handle_request/3&lt;/code&gt; callback always takes place and its return value determines the answer sent to the peer, if any.</source>
          <target state="translated">Si &lt;code&gt;answer_3xxx&lt;/code&gt; , las solicitudes se responden sin que se &lt;code&gt;handle_request/3&lt;/code&gt; una devoluci&amp;oacute;n de llamada handle_request / 3 . Si &lt;code&gt;answer&lt;/code&gt; , incluso los errores 5xxx se responden sin una devoluci&amp;oacute;n de llamada, a menos que la conexi&amp;oacute;n en cuesti&amp;oacute;n haya configurado el diccionario com&amp;uacute;n RFC 3588 como se indica a continuaci&amp;oacute;n. Si &lt;code&gt;callback&lt;/code&gt; y luego una &lt;code&gt;handle_request/3&lt;/code&gt; de devoluci&amp;oacute;n de llamada se realiza siempre y su valor de retorno determina la respuesta enviada a los pares, en su caso.</target>
        </trans-unit>
        <trans-unit id="cdb44b71a12e090bedfcba4386a9f7329590c298" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;audit_trail_log&lt;/code&gt; specifies that logging should take place, this parameter &lt;strong&gt;must&lt;/strong&gt; be defined.</source>
          <target state="translated">Si &lt;code&gt;audit_trail_log&lt;/code&gt; especifica que se debe realizar el registro, este par&amp;aacute;metro &lt;strong&gt;debe&lt;/strong&gt; definirse.</target>
        </trans-unit>
        <trans-unit id="5c3452c6586d61bda15fc59fe771d58878ac0b8b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;auto_ack&lt;/code&gt; is true, then if &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, ack's will be sent immediately. If &lt;code&gt;trans_ack&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, then ack's will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;auto_ack&lt;/code&gt; es verdadero, entonces si &lt;code&gt;trans_ack&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , los ack se enviar&amp;aacute;n inmediatamente. Si &lt;code&gt;trans_ack&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , entonces los ack se enviar&amp;aacute;n al proceso del remitente de la transacci&amp;oacute;n para su acumulaci&amp;oacute;n y env&amp;iacute;o posterior (consulte &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; y &lt;code&gt;trans_timer&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="7f3ff30c8bf2c3590c81efa740a7d601076daf88" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;callback&lt;/code&gt; then errors result in a &lt;code&gt;handle_answer/4&lt;/code&gt; callback in the same fashion as for &lt;code&gt;handle_request/3&lt;/code&gt;, with errors communicated in the &lt;code&gt;errors&lt;/code&gt; field of the &lt;code&gt;#diameter_packet{}&lt;/code&gt; passed to the callback. If &lt;code&gt;report&lt;/code&gt; then an answer containing errors is discarded without a callback and a warning report is written to the log. If &lt;code&gt;discard&lt;/code&gt; then an answer containing errors is silently discarded without a callback. In both the &lt;code&gt;report&lt;/code&gt; and &lt;code&gt;discard&lt;/code&gt; cases the return value for the &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; invocation in question is as if a callback had taken place and returned &lt;code&gt;{error, failure}&lt;/code&gt;.</source>
          <target state="translated">Si la &lt;code&gt;callback&lt;/code&gt; , los errores dan como resultado una devoluci&amp;oacute;n &lt;code&gt;handle_answer/4&lt;/code&gt; llamada handle_answer / 4 de la misma manera que para &lt;code&gt;handle_request/3&lt;/code&gt; , con errores comunicados en el campo de &lt;code&gt;errors&lt;/code&gt; del &lt;code&gt;#diameter_packet{}&lt;/code&gt; pasado a la devoluci&amp;oacute;n de llamada. Si &lt;code&gt;report&lt;/code&gt; , una respuesta que contiene errores se descarta sin una devoluci&amp;oacute;n de llamada y se escribe un informe de advertencia en el registro. Si se &lt;code&gt;discard&lt;/code&gt; , una respuesta que contenga errores se descarta silenciosamente sin una devoluci&amp;oacute;n de llamada. Tanto en el caso de &lt;code&gt;report&lt;/code&gt; como en el de &lt;code&gt;discard&lt;/code&gt; , el valor de retorno de la invocaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; en cuesti&amp;oacute;n es como si se hubiera realizado una devoluci&amp;oacute;n de llamada y se hubiera devuelto &lt;code&gt;{error, failure}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62c065b9fb27488b0e771951e56438f1b6383335" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ch4&lt;/code&gt; is part of the application &lt;code&gt;sp_app&lt;/code&gt; and a new version of the module is to be loaded when upgrading from version &quot;1&quot; to &quot;2&quot; of this application, &lt;code&gt;sp_app.appup&lt;/code&gt; can look as follows:</source>
          <target state="translated">Si &lt;code&gt;ch4&lt;/code&gt; es parte de la aplicaci&amp;oacute;n &lt;code&gt;sp_app&lt;/code&gt; y se va a cargar una nueva versi&amp;oacute;n del m&amp;oacute;dulo al actualizar de la versi&amp;oacute;n &quot;1&quot; a la &quot;2&quot; de esta aplicaci&amp;oacute;n, &lt;code&gt;sp_app.appup&lt;/code&gt; puede tener el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="704192b50b25e6b4c8a4a69ec853e8732712c9f1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;cp1&lt;/code&gt; goes down, the system checks which one of the other nodes, &lt;code&gt;cp2&lt;/code&gt; or &lt;code&gt;cp3&lt;/code&gt;, has the least number of running applications, but waits for 5 seconds for &lt;code&gt;cp1&lt;/code&gt; to restart. If &lt;code&gt;cp1&lt;/code&gt; does not restart and &lt;code&gt;cp2&lt;/code&gt; runs fewer applications than &lt;code&gt;cp3&lt;/code&gt;, &lt;code&gt;myapp&lt;/code&gt; is restarted on &lt;code&gt;cp2&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;cp1&lt;/code&gt; deja de funcionar , el sistema verifica cu&amp;aacute;l de los otros nodos, &lt;code&gt;cp2&lt;/code&gt; o &lt;code&gt;cp3&lt;/code&gt; , tiene la menor cantidad de aplicaciones en ejecuci&amp;oacute;n, pero espera 5 segundos para que &lt;code&gt;cp1&lt;/code&gt; se reinicie. Si &lt;code&gt;cp1&lt;/code&gt; no se reinicia y &lt;code&gt;cp2&lt;/code&gt; ejecuta menos aplicaciones que &lt;code&gt;cp3&lt;/code&gt; , &lt;code&gt;myapp&lt;/code&gt; se reinicia en &lt;code&gt;cp2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b17771800350279f555431c07bc7909375d85a40" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ct_run&lt;/code&gt; is called with option &lt;code&gt;-help&lt;/code&gt;, it prints all valid start flags to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">Si se llama a &lt;code&gt;ct_run&lt;/code&gt; con la opci&amp;oacute;n &lt;code&gt;-help&lt;/code&gt; , imprime todos los indicadores de inicio v&amp;aacute;lidos en &lt;code&gt;stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d7ad1711ae125314f622ecddd1f476bedaa098f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;drop_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;flush_qlen&lt;/code&gt;, drop mode is disabled and can never occur.</source>
          <target state="translated">Si &lt;code&gt;drop_mode_qlen&lt;/code&gt; se establece en el mismo valor que &lt;code&gt;flush_qlen&lt;/code&gt; , el modo de ca&amp;iacute;da est&amp;aacute; deshabilitado y nunca puede ocurrir.</target>
        </trans-unit>
        <trans-unit id="c399745e103b947fe1a2d216d913038686b47941" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; called then a connected emulator will send bit strings and export funs correctly encoded. The functions &lt;code&gt;&lt;a href=&quot;#ei_decode_bitstring&quot;&gt;ei_decode_bitstring&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#ei_decode_fun&quot;&gt;ei_decode_fun&lt;/a&gt;&lt;/code&gt; has to be used to decode such terms. Calling &lt;code&gt;ei_set_compat_rel(21)&lt;/code&gt; should only be done as a workaround to keep an old implementation alive, which expects to receive the undocumented tuple formats for bit strings and/or export funs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="173618b78a011b048e525d9c552841f6185552f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_call/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_call/3&lt;/code&gt; no est&amp;aacute; definido, se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="585b6dae1b75f75f6d17ff008d7c715232f527c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_garbage_collection/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6b7353e255834b234c18ea03d27108e34a19f8a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_ports/3&lt;/code&gt; no est&amp;aacute; definido, se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="7d175b45d5ebd8073a81917e2e671529596546a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_procs/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ebe9ceea886c3c6d1719971aa43295e9c7ed38b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_receive/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_receive/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10f4f080f33a6c7add14620c4ce363f7b8950eec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_ports/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_running_ports/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c4a84bb3f76762c65d3520facf2a72bcfc1f2ad" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_running_procs/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_running_procs/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b251834b95dc454e5654dddcf65d7d5d05abbdf9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;enabled_send/3&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;enabled_send/3&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama a &lt;code&gt;&lt;a href=&quot;#Module:enabled-3&quot;&gt;Module:enabled/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="48960527f8e8df817720dc59ec79a9e715127fc2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, the &lt;code&gt;read_line/1&lt;/code&gt; call fails if the data contains characters larger than 255, why module &lt;code&gt;io(3)&lt;/code&gt; is to be preferred when reading such a file.</source>
          <target state="translated">Si la &lt;code&gt;encoding&lt;/code&gt; se establece en algo diferente a &lt;code&gt;latin1&lt;/code&gt; , la llamada &lt;code&gt;read_line/1&lt;/code&gt; falla si los datos contienen caracteres mayores que 255, por qu&amp;eacute; se prefiere el m&amp;oacute;dulo &lt;code&gt;io(3)&lt;/code&gt; al leer dicho archivo.</target>
        </trans-unit>
        <trans-unit id="02ece68d22a0388d64a0607adb76ac441dd5ca33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the (unfortunately undocumented) &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="translated">Si se va a usar &lt;code&gt;epmd&lt;/code&gt; para el descubrimiento de nodos, normalmente querr&amp;aacute; usar el m&amp;oacute;dulo &lt;code&gt;erl_epmd&lt;/code&gt; (desafortunadamente no documentado) (parte de la aplicaci&amp;oacute;n del &lt;code&gt;kernel&lt;/code&gt; ) para registrar el puerto de escucha con &lt;code&gt;epmd&lt;/code&gt; y recuperar la &lt;code&gt;Creation&lt;/code&gt; para usar.</target>
        </trans-unit>
        <trans-unit id="c86ec487c7e02fab4d117367477d9817cdcbd441" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;epmd&lt;/code&gt; is to be used for node discovery, you typically want to use the &lt;code&gt;erl_epmd&lt;/code&gt; module (part of the &lt;code&gt;kernel&lt;/code&gt; application) in order to register the listen port with &lt;code&gt;epmd&lt;/code&gt; and retrieve &lt;code&gt;Creation&lt;/code&gt; to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48eb5a7215dde7b0dc8037cba2427a3618b189d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the server adds HTTP header fields preventing proxies from caching the page. This is generally a good idea for dynamic content, as the content often varies between each request. Default is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;erl_script_nocache&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , el servidor agrega campos de encabezado HTTP evitando que los proxies almacenen la p&amp;aacute;gina en cach&amp;eacute;. En general, esta es una buena idea para el contenido din&amp;aacute;mico, ya que el contenido suele variar entre cada solicitud. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74b3b9e997b2f242f5469345dd4b6f37734c75d2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;erl_script_timeout&lt;/code&gt; sets the time in seconds the server waits between each chunk of data to be delivered through &lt;code&gt;mod_esi:deliver/2&lt;/code&gt;. Default is &lt;code&gt;15&lt;/code&gt;. This is only relevant for scripts that use the erl scheme.</source>
          <target state="translated">Si &lt;code&gt;erl_script_timeout&lt;/code&gt; establece el tiempo en segundos, el servidor espera entre cada fragmento de datos que se entregar&amp;aacute; a trav&amp;eacute;s de &lt;code&gt;mod_esi:deliver/2&lt;/code&gt; . El valor predeterminado es &lt;code&gt;15&lt;/code&gt; . Esto solo es relevante para los scripts que usan el esquema erl.</target>
        </trans-unit>
        <trans-unit id="642c708a719a284794b6696e0acb8a429739f8e8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7c49f84d1938c55d129db8f559247ec6ced174b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;error_logger&lt;/code&gt; is not defined in the map, the system default is used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either the option &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;error_logger&lt;/code&gt; no est&amp;aacute; definido en el mapa, se usa el sistema predeterminado. El valor predeterminado del sistema es &lt;code&gt;true&lt;/code&gt; . Se puede cambiar con la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;erl#+hmaxel&quot;&gt;+hmaxel&lt;/a&gt;&lt;/code&gt; int &lt;code&gt;erl(1)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1f0b5e86017500297a623ccd787481972405c5d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ev&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt;, all ones that is &lt;code&gt;-1&lt;/code&gt; type cast to &lt;code&gt;ErlDrvSizeT&lt;/code&gt; are returned.</source>
          <target state="translated">Si &lt;code&gt;ev&lt;/code&gt; es &lt;code&gt;NULL&lt;/code&gt; , se devuelven todos los que son de tipo &lt;code&gt;-1&lt;/code&gt; convertidos a &lt;code&gt;ErlDrvSizeT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20a523dc7e77a84691bbad3e5ffc300c86d69172" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;exit&lt;/code&gt; then the transport process in question exits. If &lt;code&gt;handle&lt;/code&gt; then the message is processed as usual, a resulting &lt;code&gt;handle_request/3&lt;/code&gt; or &lt;code&gt;handle_answer/4&lt;/code&gt; callback (if one takes place) indicating the &lt;code&gt;5015&lt;/code&gt; error (DIAMETER_INVALID_MESSAGE_LENGTH). If &lt;code&gt;discard&lt;/code&gt; then the message in question is silently discarded.</source>
          <target state="translated">Si &lt;code&gt;exit&lt;/code&gt; se cierra el proceso de transporte en cuesti&amp;oacute;n. Si &lt;code&gt;handle&lt;/code&gt; , el mensaje se procesa como de costumbre, una devoluci&amp;oacute;n &lt;code&gt;handle_answer/4&lt;/code&gt; llamada &lt;code&gt;handle_request/3&lt;/code&gt; o handle_answer / 4 resultante (si se produce una) que indica el error &lt;code&gt;5015&lt;/code&gt; (DIAMETER_INVALID_MESSAGE_LENGTH). Si se &lt;code&gt;discard&lt;/code&gt; , el mensaje en cuesti&amp;oacute;n se descarta silenciosamente.</target>
        </trans-unit>
        <trans-unit id="ca99bf6a729fabb69715993d01ee3f7329b5f3f4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, Epp}&lt;/code&gt;.</source>
          <target state="translated">Si se especifica &lt;code&gt;extra&lt;/code&gt; en &lt;code&gt;Options&lt;/code&gt; , el valor de retorno es &lt;code&gt;{ok, Epp, Extra}&lt;/code&gt; lugar de &lt;code&gt;{ok, Epp}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="621b05f8dd3dbf24d54370fe9dfbe14fc856ec52" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;extra&lt;/code&gt; is specified in &lt;code&gt;Options&lt;/code&gt;, the return value is &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; instead of &lt;code&gt;{ok, [Form]}&lt;/code&gt;.</source>
          <target state="translated">Si se especifica &lt;code&gt;extra&lt;/code&gt; en &lt;code&gt;Options&lt;/code&gt; , el valor de retorno es &lt;code&gt;{ok, [Form], Extra}&lt;/code&gt; lugar de &lt;code&gt;{ok, [Form]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8b3047d3a672144cba0e123255c2c3997f12bb72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; (passive mode, the default), the caller must do an explicit &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; call to retrieve the available data from the socket.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; (modo pasivo, el predeterminado), la persona que llama debe hacer una llamada expl&amp;iacute;cita de &lt;code&gt;&lt;a href=&quot;#recv-1&quot;&gt;recv&lt;/a&gt;&lt;/code&gt; para recuperar los datos disponibles del socket.</target>
        </trans-unit>
        <trans-unit id="56e3643f360d9383768007f097296d7135ef22f5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then peers are not shared. If &lt;code&gt;[node()]&lt;/code&gt; then peers are shared with the specified list of nodes. If &lt;code&gt;eval()&lt;/code&gt; then peers are shared with the nodes returned by the specified function, evaluated whenever a peer connection becomes available or a remote service requests information about local connections. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored, so a collection of services can all be configured to share with the same list of nodes.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , los pares no se comparten. Si &lt;code&gt;[node()]&lt;/code&gt; , los pares se comparten con la lista de nodos especificada. Si &lt;code&gt;eval()&lt;/code&gt; , los pares se comparten con los nodos devueltos por la funci&amp;oacute;n especificada, se eval&amp;uacute;an siempre que una conexi&amp;oacute;n de pares est&amp;aacute; disponible o un servicio remoto solicita informaci&amp;oacute;n sobre las conexiones locales. El valor &lt;code&gt;true&lt;/code&gt; es equivalente a &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; . El valor &lt;code&gt;node()&lt;/code&gt; en una lista se ignora, por lo que una colecci&amp;oacute;n de servicios se puede configurar para compartir con la misma lista de nodos.</target>
        </trans-unit>
        <trans-unit id="61331cf5138ed4df60722b0902d831feeb5514c9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt; then remote peers are not used. If &lt;code&gt;[node()]&lt;/code&gt; then only peers from the specified list of nodes are used. If &lt;code&gt;eval()&lt;/code&gt; then only peers returned by the specified function are used, evaluated whenever a remote service communicates information about an available peer connection. The value &lt;code&gt;true&lt;/code&gt; is equivalent to &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt;. The value &lt;code&gt;node()&lt;/code&gt; in a list is ignored.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , no se utilizan pares remotos. Si &lt;code&gt;[node()]&lt;/code&gt; , solo se utilizan los pares de la lista de nodos especificada. Si &lt;code&gt;eval()&lt;/code&gt; , solo se utilizan los pares devueltos por la funci&amp;oacute;n especificada, evaluados siempre que un servicio remoto comunica informaci&amp;oacute;n sobre una conexi&amp;oacute;n de pares disponible. El valor &lt;code&gt;true&lt;/code&gt; es equivalente a &lt;code&gt;fun &lt;code&gt;erlang:nodes/0&lt;/code&gt;&lt;/code&gt; . Se ignora el valor &lt;code&gt;node()&lt;/code&gt; en una lista.</target>
        </trans-unit>
        <trans-unit id="515f5f660b2b6a5321a3301134d45702f7c8d34e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, disables the client to connect to the server if any user interaction is needed, such as accepting the server to be added to the &lt;code&gt;known_hosts&lt;/code&gt; file, or supplying a password.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , inhabilita al cliente para que se conecte al servidor si se necesita alguna interacci&amp;oacute;n del usuario, como aceptar que el servidor se agregue al archivo &lt;code&gt;known_hosts&lt;/code&gt; o proporcionar una contrase&amp;ntilde;a.</target>
        </trans-unit>
        <trans-unit id="2f21ed8efde9cbba7a84e9561d2bee32978fafa7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;false&lt;/code&gt;, the key is not saved and the key will still be unknown at the next access of the same host.</source>
          <target state="translated">Si es &lt;code&gt;false&lt;/code&gt; , la clave no se guarda y la clave seguir&amp;aacute; siendo desconocida en el pr&amp;oacute;ximo acceso del mismo host.</target>
        </trans-unit>
        <trans-unit id="6c171a334054ea3d178b695378164bb4717dbc73" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;latin1&lt;/code&gt;, no translation of path names is done.</source>
          <target state="translated">Si &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; devuelve &lt;code&gt;latin1&lt;/code&gt; , no se realiza ninguna traducci&amp;oacute;n de los nombres de las rutas.</target>
        </trans-unit>
        <trans-unit id="174e5b29f214dbcb97eabc33b079cdd65ed3ff4c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; returns &lt;code&gt;utf8&lt;/code&gt;, path names are encoded in UTF-8 when creating tar files, and path names are assumed to be encoded in UTF-8 when extracting tar files.</source>
          <target state="translated">Si &lt;code&gt;file:native_name_encoding/0&lt;/code&gt; devuelve &lt;code&gt;utf8&lt;/code&gt; , los nombres de ruta se codifican en UTF-8 cuando se crean archivos tar y se supone que los nombres de ruta est&amp;aacute;n codificados en UTF-8 cuando se extraen archivos tar.</target>
        </trans-unit>
        <trans-unit id="53f00d54c4cf2784d07f86c8a1f69d22126e8edd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;final&lt;/code&gt; is returned, the time offset was already in the final state. This either because another &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; call or because &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Si se devuelve &lt;code&gt;final&lt;/code&gt; , el desplazamiento de tiempo ya estaba en el estado final. Esto se debe a otra &lt;code&gt;erlang:system_flag(time_offset, finalize)&lt;/code&gt; o porque &lt;code&gt;&lt;a href=&quot;time_correction#No_Time_Warp_Mode&quot;&gt;no time warp mode&lt;/a&gt;&lt;/code&gt; se usa el modo time warp .</target>
        </trans-unit>
        <trans-unit id="7d84ff72a66a5f1dc4702c44281724bb233b3cbb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;0&lt;/code&gt;, the backup includes only those objects that have been created, modified, or deleted since the last backup or restore (that is, an incremental backup). After the backup, any objects that were marked dirty are now clean, and any objects that had been marked for deletion are deleted.</source>
          <target state="translated">Si &lt;code&gt;flags&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; , la copia de seguridad incluye solo aquellos objetos que se han creado, modificado o eliminado desde la &amp;uacute;ltima copia de seguridad o restauraci&amp;oacute;n (es decir, una copia de seguridad incremental). Despu&amp;eacute;s de la copia de seguridad, todos los objetos que se marcaron como sucios ahora est&amp;aacute;n limpios y todos los objetos que se marcaron para su eliminaci&amp;oacute;n se eliminan.</target>
        </trans-unit>
        <trans-unit id="1b22e611455eedf00229374381cf3ded5d86286d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;int *size&lt;/code&gt; is required, so that the size of the object can be returned.</source>
          <target state="translated">Si &lt;code&gt;flags&lt;/code&gt; es &lt;code&gt;EI_BIN&lt;/code&gt; , se requiere un quinto argumento &lt;code&gt;int *size&lt;/code&gt; , de modo que se pueda devolver el tama&amp;ntilde;o del objeto.</target>
        </trans-unit>
        <trans-unit id="5d03c462ed0e1501d3ca648701da33656f727855" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;flags&lt;/code&gt; is &lt;code&gt;EI_BIN&lt;/code&gt;, a fifth argument &lt;code&gt;size&lt;/code&gt; is required, indicating the size in bytes of the object pointed to by &lt;code&gt;v&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;flags&lt;/code&gt; es &lt;code&gt;EI_BIN&lt;/code&gt; , se requiere un quinto &lt;code&gt;size&lt;/code&gt; argumento , que indica el tama&amp;ntilde;o en bytes del objeto al que apunta &lt;code&gt;v&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef97c9cebbac0fa5b4a15003e98bfbe9b002c14c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a12847c8010acaf74585bb590e3d2d2892d7bd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;hibernate&lt;/code&gt; is specified instead of a time-out value, the process goes into hibernation when waiting for the next message to arrive (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Si se especifica &lt;code&gt;hibernate&lt;/code&gt; lugar de un valor de tiempo de espera, el proceso entra en hibernaci&amp;oacute;n cuando espera que llegue el siguiente mensaje (llamando a &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4370781db47a41ab4e7732b376aa87b3dd2e229d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;indent_opt&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt; (default), line breaks are inserted in types, contracts, and Erlang code to improve readability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81060f399c0748631583d69217b03e975ffd94c5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_group&lt;/code&gt; is skipped, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se omite &lt;code&gt;init_per_group&lt;/code&gt; , esta funci&amp;oacute;n se llama despu&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_group-5&quot;&gt;post_init_per_group&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8a09af08638c9468193e1b25b2f9c1bcc8d0b0d0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; exists, it is called initially before the test cases are executed. It typically contains initializations common for all test cases in the suite, which are only to be performed once. &lt;code&gt;init_per_suite&lt;/code&gt; is recommended for setting up and verifying state and environment on the System Under Test (SUT) or the &lt;code&gt;Common Test&lt;/code&gt; host node, or both, so that the test cases in the suite executes correctly. The following are examples of initial configuration operations:</source>
          <target state="translated">Si &lt;code&gt;init_per_suite&lt;/code&gt; existe, se llama inicialmente antes de que se ejecuten los casos de prueba. Por lo general, contiene inicializaciones comunes para todos los casos de prueba de la suite, que solo deben realizarse una vez. &lt;code&gt;init_per_suite&lt;/code&gt; se recomienda para configurar y verificar el estado y el entorno en el sistema bajo prueba (SUT) o el nodo host de &lt;code&gt;Common Test&lt;/code&gt; , o ambos, para que los casos de prueba de la suite se ejecuten correctamente. Los siguientes son ejemplos de operaciones de configuraci&amp;oacute;n inicial:</target>
        </trans-unit>
        <trans-unit id="e3cc6a46f9d6f7424ecfecec26999fd0b60da6a2" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, all test cases in the test suite are skipped automatically (so called &lt;strong&gt;auto skipped&lt;/strong&gt;), including &lt;code&gt;end_per_suite&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;init_per_suite&lt;/code&gt; falla, todos los casos de prueba en el conjunto de pruebas se omiten autom&amp;aacute;ticamente (lo que se denomina &lt;strong&gt;auto omitido&lt;/strong&gt; ), incluido &lt;code&gt;end_per_suite&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="894e342a0e85afde6f3b96340c645a2b4dd22b1e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_suite&lt;/code&gt; fails, this function is called after &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;init_per_suite&lt;/code&gt; falla, esta funci&amp;oacute;n se llama despu&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;#Module:post_init_per_suite-4&quot;&gt;post_init_per_suite&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfe02f751dfef43151df61c0738ad37b3fb27d99" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes (called &lt;strong&gt;auto skipped&lt;/strong&gt;).</source>
          <target state="translated">Si &lt;code&gt;init_per_testcase&lt;/code&gt; falla (lo que se denomina &lt;strong&gt;auto omitido&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="7150a88f54c0b7881134625da98b5bed12371c8e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; crashes, or returns &lt;code&gt;{skip,Reason}&lt;/code&gt; or &lt;code&gt;{fail,Reason}&lt;/code&gt;, function &lt;code&gt;end_per_testcase&lt;/code&gt; is not called.</source>
          <target state="translated">Si &lt;code&gt;init_per_testcase&lt;/code&gt; falla o devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; o &lt;code&gt;{fail,Reason}&lt;/code&gt; , no se llama a la funci&amp;oacute;n &lt;code&gt;end_per_testcase&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89e72fa5ab521b91a322a6c022357a5ac272ea72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; exists, it is called before each test case in the suite. It typically contains initialization that must be done for each test case (analog to &lt;code&gt;init_per_suite&lt;/code&gt; for the suite).</source>
          <target state="translated">Si existe &lt;code&gt;init_per_testcase&lt;/code&gt; , se llama antes de cada caso de prueba en la suite. Por lo general, contiene una inicializaci&amp;oacute;n que debe realizarse para cada caso de prueba (an&amp;aacute;logo a &lt;code&gt;init_per_suite&lt;/code&gt; para la suite).</target>
        </trans-unit>
        <trans-unit id="72f622c1b041a5f9b4ffb1e9a77eb43b9ec5d211" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;init_per_testcase&lt;/code&gt; returns a tuple &lt;code&gt;{skip,Reason}&lt;/code&gt; (called &lt;strong&gt;user skipped&lt;/strong&gt;).</source>
          <target state="translated">Si &lt;code&gt;init_per_testcase&lt;/code&gt; devuelve una tupla &lt;code&gt;{skip,Reason}&lt;/code&gt; (llamado &lt;strong&gt;usuario omitido&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="d395c2bde7c4e5cd016e96c83e2790c6164bde6e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;ip_access&lt;/code&gt; and &lt;code&gt;name_access&lt;/code&gt; are implemented similarly, we could write a &lt;code&gt;generic_access&lt;/code&gt; function using the &lt;code&gt;ListOfExtraArguments&lt;/code&gt;:</source>
          <target state="translated">Si &lt;code&gt;ip_access&lt;/code&gt; y &lt;code&gt;name_access&lt;/code&gt; se implementan de manera similar, podr&amp;iacute;amos escribir una funci&amp;oacute;n &lt;code&gt;generic_access&lt;/code&gt; usando &lt;code&gt;ListOfExtraArguments&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab359c8b6df991113724100b5a067f71b56dbab9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns the atom &lt;code&gt;false&lt;/code&gt;, some error has occurred and the server sends back the message:</source>
          <target state="translated">Si la &lt;code&gt;keysearch&lt;/code&gt; devuelve el &amp;aacute;tomo &lt;code&gt;false&lt;/code&gt; , se ha producido alg&amp;uacute;n error y el servidor devuelve el mensaje:</target>
        </trans-unit>
        <trans-unit id="471dd07d8c17d433b665f7f28142ddb0c9a5ccb4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;keysearch&lt;/code&gt; returns:</source>
          <target state="translated">Si la &lt;code&gt;keysearch&lt;/code&gt; regresa:</target>
        </trans-unit>
        <trans-unit id="1a3183f931de40dbb6f7631f18d3f43161a10688" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt; erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8473687ede2e043c5626f2dc6d081f3c7f8c834a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;kill&lt;/code&gt; is not defined in the map, the system default will be used. The default system default is &lt;code&gt;true&lt;/code&gt;. It can be changed by either option &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;erl(1)&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;kill&lt;/code&gt; no est&amp;aacute; definido en el mapa, se usar&amp;aacute; el sistema predeterminado. El valor predeterminado del sistema es &lt;code&gt;true&lt;/code&gt; . Se puede cambiar con la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;erl#+hmaxk&quot;&gt;+hmaxk&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;erl(1)&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#system_flag_max_heap_size&quot;&gt;erlang:system_flag(max_heap_size, MaxHeapSize)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8bce3cc2e82b9a6fd5502ccdd6aead42b567ec06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;local&lt;/code&gt; is specified as argument, Debugger interprets code only at the current node. If &lt;code&gt;global&lt;/code&gt; is specified as argument, Debugger interprets code at all known nodes, this is the default.</source>
          <target state="translated">Si se especifica &lt;code&gt;local&lt;/code&gt; como argumento, Debugger interpreta el c&amp;oacute;digo solo en el nodo actual. Si se especifica &lt;code&gt;global&lt;/code&gt; como argumento, Debugger interpreta el c&amp;oacute;digo en todos los nodos conocidos, este es el valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="f7b7e2ac7280eca021f5062e79e83b7222745d33" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;m:fact/1&lt;/code&gt; is called with a negative number as argument, no clause head matches. A &lt;code&gt;function_clause&lt;/code&gt; runtime error occurs.</source>
          <target state="translated">Si se llama a &lt;code&gt;m:fact/1&lt;/code&gt; con un n&amp;uacute;mero negativo como argumento, ning&amp;uacute;n encabezado de cl&amp;aacute;usula coincide. Se produce un error de tiempo de ejecuci&amp;oacute;n de &lt;code&gt;function_clause&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="78902773cd5b20b28d3f472a6d23e48932225627" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;master&lt;/code&gt;, one master agent is started. Otherwise, no agents are started.</source>
          <target state="translated">Si es &lt;code&gt;master&lt;/code&gt; , se inicia un agente maestro. De lo contrario, no se inicia ning&amp;uacute;n agente.</target>
        </trans-unit>
        <trans-unit id="ababfa264cf2c0471a517629bda5d420f24412f7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;maximum&lt;/code&gt; is passed as &lt;code&gt;Type&lt;/code&gt; and the emulator is not run in instrumented mode.</source>
          <target state="translated">Si el &lt;code&gt;maximum&lt;/code&gt; se pasa como &lt;code&gt;Type&lt;/code&gt; y el emulador no se ejecuta en modo instrumentado.</target>
        </trans-unit>
        <trans-unit id="fb16ce380eb14a73a96ecf98dda7ccaebbde8485" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;mon&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, a successful call stores the identity of the monitor in the &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; struct pointed to by &lt;code&gt;mon&lt;/code&gt;. This identifier is used to refer to the monitor for later removal with &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; or compare with &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt;. A monitor is automatically removed when it triggers or when the resource is deallocated.</source>
          <target state="translated">Si &lt;code&gt;mon&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , una llamada exitosa almacena la identidad del monitor en la estructura &lt;code&gt;&lt;a href=&quot;#ErlNifMonitor&quot;&gt;ErlNifMonitor&lt;/a&gt;&lt;/code&gt; apuntada por &lt;code&gt;mon&lt;/code&gt; . Este identificador se utiliza para hacer referencia al monitor para su posterior eliminaci&amp;oacute;n con &lt;code&gt;&lt;a href=&quot;#enif_demonitor_process&quot;&gt;enif_demonitor_process&lt;/a&gt;&lt;/code&gt; o comparar con &lt;code&gt;&lt;a href=&quot;#enif_compare_monitors&quot;&gt;enif_compare_monitors&lt;/a&gt;&lt;/code&gt; . Un monitor se elimina autom&amp;aacute;ticamente cuando se activa o cuando se desasigna el recurso.</target>
        </trans-unit>
        <trans-unit id="e7557ef34e7c482b82151565597fe49987e4f520" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;msg_env&lt;/code&gt; is set to &lt;code&gt;NULL&lt;/code&gt;, the &lt;code&gt;msg&lt;/code&gt; term is copied and the original term and its environment is still valid after the call.</source>
          <target state="translated">Si &lt;code&gt;msg_env&lt;/code&gt; se establece en &lt;code&gt;NULL&lt;/code&gt; , el t&amp;eacute;rmino &lt;code&gt;msg&lt;/code&gt; se copia y el t&amp;eacute;rmino original y su entorno siguen siendo v&amp;aacute;lidos despu&amp;eacute;s de la llamada.</target>
        </trans-unit>
        <trans-unit id="3324f7db747bf81fb1767f13442861504e9e2dd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;myapp&lt;/code&gt; is running at &lt;code&gt;cp3&lt;/code&gt;, and if &lt;code&gt;cp2&lt;/code&gt; now restarts, it does not restart &lt;code&gt;myapp&lt;/code&gt;, as the order between the &lt;code&gt;cp2&lt;/code&gt; and &lt;code&gt;cp3&lt;/code&gt; nodes is undefined.</source>
          <target state="translated">Si &lt;code&gt;myapp&lt;/code&gt; se est&amp;aacute; ejecutando en &lt;code&gt;cp3&lt;/code&gt; , y si &lt;code&gt;cp2&lt;/code&gt; ahora se reinicia, no reinicia &lt;code&gt;myapp&lt;/code&gt; , ya que el orden entre los nodos &lt;code&gt;cp2&lt;/code&gt; y &lt;code&gt;cp3&lt;/code&gt; no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="410c990db3f3097c54b66efc65b17fbe9e2bad60" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;nc&lt;/code&gt; is the current number of multiblock carriers (the main multiblock carrier excluded) managed by an allocator, the size of the next &lt;code&gt;mseg_alloc&lt;/code&gt; multiblock carrier allocated by this allocator is roughly &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; when &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt;, and &lt;code&gt;lmbcs&lt;/code&gt; when &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt;. If the value of parameter &lt;code&gt;sbct&lt;/code&gt; is larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, the allocator may have to create multiblock carriers that are larger than the value of parameter &lt;code&gt;lmbcs&lt;/code&gt;, though. Singleblock carriers allocated through &lt;code&gt;mseg_alloc&lt;/code&gt; are sized to whole pages.</source>
          <target state="translated">Si &lt;code&gt;nc&lt;/code&gt; es el n&amp;uacute;mero actual de portadoras multibloque (excluida la portadora multibloque principal) gestionada por un asignador, el tama&amp;ntilde;o de la siguiente &lt;code&gt;mseg_alloc&lt;/code&gt; multibloque mseg_alloc asignada por este asignador es aproximadamente &lt;code&gt;smbcs+nc*(lmbcs-smbcs)/mbcgs&lt;/code&gt; cuando &lt;code&gt;nc &amp;lt;= mbcgs&lt;/code&gt; y &lt;code&gt;lmbcs&lt;/code&gt; cuando &lt;code&gt;nc &amp;gt; mbcgs&lt;/code&gt; . Sin embargo, si el valor del par&amp;aacute;metro &lt;code&gt;sbct&lt;/code&gt; es mayor que el valor del par&amp;aacute;metro &lt;code&gt;lmbcs&lt;/code&gt; , el asignador puede tener que crear portadoras multibloque que sean mayores que el valor del par&amp;aacute;metro &lt;code&gt;lmbcs&lt;/code&gt; . Los portadores de bloque &amp;uacute;nico asignados a trav&amp;eacute;s de &lt;code&gt;mseg_alloc&lt;/code&gt; tienen el tama&amp;ntilde;o de p&amp;aacute;ginas enteras.</target>
        </trans-unit>
        <trans-unit id="00a9d4efd00c94ba68d6320fea95c0909f36f665" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated file sync operation is disabled, and it is the operating system settings that determine how quickly or slowly data is written to disk. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a file sync.</source>
          <target state="translated">Si &lt;code&gt;no_repeat&lt;/code&gt; se establece como valor, la operaci&amp;oacute;n de sincronizaci&amp;oacute;n de archivos repetida se deshabilita y son las configuraciones del sistema operativo las que determinan qu&amp;eacute; tan r&amp;aacute;pido o lento se escriben los datos en el disco. El usuario tambi&amp;eacute;n puede llamar a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;logger_std_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; para realizar una sincronizaci&amp;oacute;n de archivos.</target>
        </trans-unit>
        <trans-unit id="cf5fe50553f5c7b137deba5f80790419102c9acc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1 &lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960e9f5afba10edf0b60921b0e8e69fa2c34179d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;no_repeat&lt;/code&gt; is set as value, the repeated sync operation is disabled. The user can also call the &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; function to perform a disk_log sync.</source>
          <target state="translated">Si &lt;code&gt;no_repeat&lt;/code&gt; se establece como valor, la operaci&amp;oacute;n de sincronizaci&amp;oacute;n repetida se deshabilita. El usuario tambi&amp;eacute;n puede llamar a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;logger_disk_log_h#filesync-1&quot;&gt;filesync/1&lt;/a&gt;&lt;/code&gt; para realizar una sincronizaci&amp;oacute;n disk_log.</target>
        </trans-unit>
        <trans-unit id="a26d7bcc04c3b56013d1be0c1072c79ecbf5d9d4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;ei_connect()&lt;/code&gt; if necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92fc938fa7cba74ec1f9bb43ffd7daba5627a4cc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;node&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, it is a pointer to a buffer where the function can fill in the name of the node where &lt;code&gt;name&lt;/code&gt; is found. &lt;code&gt;node&lt;/code&gt; can be passed directly to &lt;code&gt;erl_connect()&lt;/code&gt; if necessary.</source>
          <target state="translated">Si el &lt;code&gt;node&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , es un puntero a un b&amp;uacute;fer donde la funci&amp;oacute;n puede completar el nombre del nodo donde se encuentra el &lt;code&gt;name&lt;/code&gt; . &lt;code&gt;node&lt;/code&gt; se puede pasar directamente a &lt;code&gt;erl_connect()&lt;/code&gt; si es necesario.</target>
        </trans-unit>
        <trans-unit id="8bcb0ecfc7e63283704c689b708fb3722abb28bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;once&lt;/code&gt;, only one message is automatically placed in the message queue, and after that the mode is automatically reset to passive. This provides flow control and the possibility for the receiver to listen for its incoming SCTP data interleaved with other inter-process messages.</source>
          <target state="translated">Si es &lt;code&gt;once&lt;/code&gt; , solo un mensaje se coloca autom&amp;aacute;ticamente en la cola de mensajes, y luego el modo se restablece autom&amp;aacute;ticamente a pasivo. Esto proporciona control de flujo y la posibilidad de que el receptor escuche sus datos SCTP entrantes intercalados con otros mensajes entre procesos.</target>
        </trans-unit>
        <trans-unit id="ef8342250cfaa0e36ec9bd08880c6f82e62cfce4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;after&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is stopped. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;os_sup_enable&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , esta funci&amp;oacute;n se debe llamar &lt;strong&gt;despu&amp;eacute;s de que&lt;/strong&gt; OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; se detenga. &lt;code&gt;Dir&lt;/code&gt; define el directorio que contiene la copia de seguridad y los archivos de configuraci&amp;oacute;n espec&amp;iacute;ficos de Erlang para &lt;code&gt;syslogd&lt;/code&gt; , y una canalizaci&amp;oacute;n con nombre para recibir los mensajes de &lt;code&gt;syslogd&lt;/code&gt; . El valor predeterminado es &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; . &lt;code&gt;Conf&lt;/code&gt; define el nombre completo del archivo de configuraci&amp;oacute;n para &lt;code&gt;syslogd&lt;/code&gt; . El valor predeterminado es &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a700fd6dad9f4c64ccd4666632fae200f7d79bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;os_sup_enable&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, this function must be called &lt;strong&gt;before&lt;/strong&gt; OS_Mon/&lt;code&gt;os_sup&lt;/code&gt; is started. &lt;code&gt;Dir&lt;/code&gt; defines the directory which contains the backup copy and the Erlang specific configuration files for &lt;code&gt;syslogd&lt;/code&gt;, and a named pipe to receive the messages from &lt;code&gt;syslogd&lt;/code&gt;. Defaults to &lt;code&gt;&quot;/etc&quot;&lt;/code&gt;. &lt;code&gt;Conf&lt;/code&gt; defines the full name of the configuration file for &lt;code&gt;syslogd&lt;/code&gt;. Default is &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;os_sup_enable&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , esta funci&amp;oacute;n se debe llamar &lt;strong&gt;antes de que se&lt;/strong&gt; inicie OS_Mon / &lt;code&gt;os_sup&lt;/code&gt; . &lt;code&gt;Dir&lt;/code&gt; define el directorio que contiene la copia de seguridad y los archivos de configuraci&amp;oacute;n espec&amp;iacute;ficos de Erlang para &lt;code&gt;syslogd&lt;/code&gt; , y una canalizaci&amp;oacute;n con nombre para recibir los mensajes de &lt;code&gt;syslogd&lt;/code&gt; . El valor predeterminado es &lt;code&gt;&quot;/etc&quot;&lt;/code&gt; . &lt;code&gt;Conf&lt;/code&gt; define el nombre completo del archivo de configuraci&amp;oacute;n para &lt;code&gt;syslogd&lt;/code&gt; . El valor predeterminado es &lt;code&gt;&quot;/etc/syslog.conf&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77f7d7d94477bf710f75a97f120cb44318c86bb9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;preliminary&lt;/code&gt; is returned, finalization was performed and the time offset is now final.</source>
          <target state="translated">Si se devuelve &lt;code&gt;preliminary&lt;/code&gt; , se realiz&amp;oacute; la finalizaci&amp;oacute;n y la compensaci&amp;oacute;n de tiempo ahora es definitiva.</target>
        </trans-unit>
        <trans-unit id="68ca185ba5a790749853b97ac87472bb69e0f79b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;raw&lt;/code&gt; is not found in the list, it is added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31a44d264c5bd3a087ba168aa0cf5ef541ffc19d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read/2&lt;/code&gt; calls are for sizes not significantly less than, or even greater than &lt;code&gt;Size&lt;/code&gt; bytes, no performance gain can be expected.</source>
          <target state="translated">Si las llamadas de &lt;code&gt;read/2&lt;/code&gt; son para tama&amp;ntilde;os que no sean significativamente menores o incluso mayores que los bytes de &lt;code&gt;Size&lt;/code&gt; , no se puede esperar una ganancia de rendimiento.</target>
        </trans-unit>
        <trans-unit id="3f7ab732c2a40901f7be417a921a39c57a4d5b7c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only get requests are logged.</source>
          <target state="translated">Si se especifica &lt;code&gt;read&lt;/code&gt; , solo se registran las solicitudes de obtenci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3b544ab09dc82eacf7049bd88c54823547cf046b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read&lt;/code&gt; is specified, only received messages are logged.</source>
          <target state="translated">Si se especifica &lt;code&gt;read&lt;/code&gt; , solo se registran los mensajes recibidos.</target>
        </trans-unit>
        <trans-unit id="4b7ba5f30d6fa892ea1037782ff4251339643dcf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">Si &lt;code&gt;read_concurrency&lt;/code&gt; estaba habilitado para la tabla.</target>
        </trans-unit>
        <trans-unit id="b29a25b884982cf8d002411e5810c5627d5ba822" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, all requests are logged.</source>
          <target state="translated">Si es &lt;code&gt;read_write&lt;/code&gt; , se registran todas las solicitudes.</target>
        </trans-unit>
        <trans-unit id="015bb54da55bcc930a4cbf6d43e9056cf7cdedf5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;read_write&lt;/code&gt;, both outgoing and incoming messages are logged.</source>
          <target state="translated">Si es &lt;code&gt;read_write&lt;/code&gt; , se registran tanto los mensajes salientes como los entrantes.</target>
        </trans-unit>
        <trans-unit id="b1376e2f35266b87691b21e50d6085d572b9fcbd" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;registered_name&lt;/code&gt; is part of &lt;code&gt;ItemList&lt;/code&gt; and the process has no name registered, a &lt;code&gt;{registered_name, []}&lt;/code&gt;, &lt;code&gt;InfoTuple&lt;/code&gt;&lt;strong&gt;will&lt;/strong&gt; be included in the resulting &lt;code&gt;InfoTupleList&lt;/code&gt;. This behavior is different when a single &lt;code&gt;Item =:= registered_name&lt;/code&gt; is specified, and when &lt;code&gt;process_info/1&lt;/code&gt; is used.</source>
          <target state="translated">Si &lt;code&gt;registered_name&lt;/code&gt; es parte de &lt;code&gt;ItemList&lt;/code&gt; y el proceso no tiene nombre registrado, un &lt;code&gt;{registered_name, []}&lt;/code&gt; , &lt;code&gt;InfoTuple&lt;/code&gt; &lt;strong&gt;ser&amp;aacute;&lt;/strong&gt; ser incluido en la resultante &lt;code&gt;InfoTupleList&lt;/code&gt; . Este comportamiento es diferente cuando se especifica un solo &lt;code&gt;Item =:= registered_name&lt;/code&gt; y cuando se usa &lt;code&gt;process_info/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c5b2b100f53895b2b8688baa94d7b9678f28feb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;remove_handler&lt;/code&gt; is returned, the event handler is deleted by calling &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt;.</source>
          <target state="translated">Si se devuelve &lt;code&gt;remove_handler&lt;/code&gt; , el controlador de eventos se elimina llamando a &lt;code&gt;Module:terminate(remove_handler,State)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="068df812b1be7a5c6fb7ba1d84c59687bbec92c6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;script_nocache&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the HTTP server by default adds the header fields necessary to prevent proxies from caching the page. Generally this is preferred. Default to &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si &lt;code&gt;script_nocache&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , el servidor HTTP agrega de forma predeterminada los campos de encabezado necesarios para evitar que los servidores proxy almacenen la p&amp;aacute;gina en cach&amp;eacute;. Generalmente se prefiere esto. Predeterminado a &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d372c1d474f731f0f4b202ab8bda7211457e68a7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;set_env/4&lt;/code&gt; is called before the application is loaded, the application environment values specified in file &lt;code&gt;Application.app&lt;/code&gt; override the ones previously set. This is also true for application reloads.</source>
          <target state="translated">Si se llama a &lt;code&gt;set_env/4&lt;/code&gt; antes de que se cargue la aplicaci&amp;oacute;n, los valores del entorno de la aplicaci&amp;oacute;n especificados en el archivo &lt;code&gt;Application.app&lt;/code&gt; anulan los establecidos anteriormente. Esto tambi&amp;eacute;n es cierto para las recargas de aplicaciones.</target>
        </trans-unit>
        <trans-unit id="82d435019a14ecf65737ecf3db3bfd456332513c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;size&lt;/code&gt; is not &lt;code&gt;NULL&lt;/code&gt;, the size of the head is placed there.</source>
          <target state="translated">Si el &lt;code&gt;size&lt;/code&gt; no es &lt;code&gt;NULL&lt;/code&gt; , el tama&amp;ntilde;o de la cabeza se coloca all&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="4feb70b4204ade06d5e528b8d52ed62d294cf47b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;stop&lt;/code&gt; is returned, the log event is immediately discarded. If the filter is primary, no handler filters or callbacks are called. If it is a handler filter, the corresponding handler callback is not called, but the log event is forwarded to filters attached to the next handler, if any.</source>
          <target state="translated">Si se devuelve &lt;code&gt;stop&lt;/code&gt; , el evento de registro se descarta inmediatamente. Si el filtro es primario, no se llaman filtros de controlador ni devoluciones de llamada. Si se trata de un filtro de controlador, no se llama a la devoluci&amp;oacute;n de llamada del controlador correspondiente, pero el evento de registro se reenv&amp;iacute;a a los filtros adjuntos al siguiente controlador, si corresponde.</target>
        </trans-unit>
        <trans-unit id="4b0fd3902aab568d673cab668aeb876afecb3d16" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to &lt;code&gt;0&lt;/code&gt;, all log events are handled synchronously. That is, asynchronous logging is disabled.</source>
          <target state="translated">Si &lt;code&gt;sync_mode_qlen&lt;/code&gt; se establece en &lt;code&gt;0&lt;/code&gt; , todos los eventos de registro se manejan sincr&amp;oacute;nicamente. Es decir, el registro asincr&amp;oacute;nico est&amp;aacute; deshabilitado.</target>
        </trans-unit>
        <trans-unit id="fe26b781dc9f18c574b4f5cea83e1dc7a0898036" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;sync_mode_qlen&lt;/code&gt; is set to the same value as &lt;code&gt;drop_mode_qlen&lt;/code&gt;, synchronous mode is disabled. That is, the handler always runs in asynchronous mode, unless dropping or flushing is invoked.</source>
          <target state="translated">Si &lt;code&gt;sync_mode_qlen&lt;/code&gt; se establece en el mismo valor que &lt;code&gt;drop_mode_qlen&lt;/code&gt; , el modo s&amp;iacute;ncrono est&amp;aacute; deshabilitado. Es decir, el controlador siempre se ejecuta en modo asincr&amp;oacute;nico, a menos que se invoque la eliminaci&amp;oacute;n o el vaciado.</target>
        </trans-unit>
        <trans-unit id="df2d416ddedf4f1525642d418b4917eca16a89fc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; identifies a node local port, this function initializes the port variable &lt;code&gt;*port_id&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the port is alive.</source>
          <target state="translated">Si &lt;code&gt;term&lt;/code&gt; identifica un puerto local de nodo, esta funci&amp;oacute;n inicializa la variable de puerto &lt;code&gt;*port_id&lt;/code&gt; y devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;false&lt;/code&gt; . No se realiza ninguna comprobaci&amp;oacute;n para ver si el puerto est&amp;aacute; activo.</target>
        </trans-unit>
        <trans-unit id="bb931f96868f0894c3ee44964627cb220396fbd0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is a tuple, this function sets &lt;code&gt;*array&lt;/code&gt; to point to an array containing the elements of the tuple, and sets &lt;code&gt;*arity&lt;/code&gt; to the number of elements. Notice that the array is read-only and &lt;code&gt;(*array)[N-1]&lt;/code&gt; is the Nth element of the tuple. &lt;code&gt;*array&lt;/code&gt; is undefined if the arity of the tuple is zero.</source>
          <target state="translated">Si &lt;code&gt;term&lt;/code&gt; es una tupla, esta funci&amp;oacute;n establece &lt;code&gt;*array&lt;/code&gt; para que apunte a una matriz que contiene los elementos de la tupla, y establece &lt;code&gt;*arity&lt;/code&gt; en el n&amp;uacute;mero de elementos. Observe que la matriz es de solo lectura y &lt;code&gt;(*array)[N-1]&lt;/code&gt; es el en&amp;eacute;simo elemento de la tupla. &lt;code&gt;*array&lt;/code&gt; no est&amp;aacute; definida si la aridad de la tupla es cero.</target>
        </trans-unit>
        <trans-unit id="99ce7d95b89f5e150dfbf95c1a3d757a096ea716" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;term&lt;/code&gt; is the pid of a node local process, this function initializes the pid variable &lt;code&gt;*pid&lt;/code&gt; from it and returns &lt;code&gt;true&lt;/code&gt;. Otherwise returns &lt;code&gt;false&lt;/code&gt;. No check is done to see if the process is alive.</source>
          <target state="translated">Si &lt;code&gt;term&lt;/code&gt; es el pid de un proceso local de nodo, esta funci&amp;oacute;n inicializa la variable &lt;code&gt;*pid&lt;/code&gt; y devuelve &lt;code&gt;true&lt;/code&gt; . De lo contrario, devuelve &lt;code&gt;false&lt;/code&gt; . No se realiza ninguna comprobaci&amp;oacute;n para ver si el proceso est&amp;aacute; activo.</target>
        </trans-unit>
        <trans-unit id="335749543c3f3f2a3a67c44896ae9fd2f2a9abbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;throw/1&lt;/code&gt; is not evaluated within a catch, a &lt;code&gt;nocatch&lt;/code&gt; run-time error occurs.</source>
          <target state="translated">Si &lt;code&gt;throw/1&lt;/code&gt; no se eval&amp;uacute;a dentro de un ret&amp;eacute;n, un &lt;code&gt;nocatch&lt;/code&gt; se produce un error en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2871fa0784bdb523b8ad094e354b3376cbc7c2d1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;Module:suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;Module:group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531f47b8f34afb9e971187a621871b405723e46a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; is not set, the default values specified by &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt;) are used.</source>
          <target state="translated">Si no se establece &lt;code&gt;timetrap&lt;/code&gt; o &lt;code&gt;require&lt;/code&gt; , se utilizan los valores predeterminados especificados por &lt;code&gt;&lt;a href=&quot;#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; (o &lt;code&gt;&lt;a href=&quot;#Module:group-1&quot;&gt;group/1&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="976ebeb2288ae33fa6c9a2ec2a28980aa636376c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="translated">Si &lt;code&gt;timetrap&lt;/code&gt; o &lt;code&gt;require&lt;/code&gt; , o ambos, no se configuran espec&amp;iacute;ficamente para un caso de prueba en particular, se utilizan los valores predeterminados especificados por el &lt;code&gt;&lt;a href=&quot;common_test#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; funciones / 0 .</target>
        </trans-unit>
        <trans-unit id="f5b1ebc718d9766e9f004a96387fa62f22f383b1" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;timetrap&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt;, or both, is not set specifically for a particular test case, default values specified by function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:suite-0&quot;&gt;suite/0&lt;/a&gt;&lt;/code&gt; are used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="744ac3e017c02db9473330a8d4a2dec44a7e8e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_call/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_call/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="9e1c20b572719c3331469687919f2defd8437750" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_garbage_collection/5&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6da64932aab510304a9e86727b1e2bcbdfe8f0b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_ports/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="50d620a56eb39b36411e41b4bc5a97c7bbafbd69" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_procs/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="9603bcd32c947b80ea34517cb4f3a01b71d378ab" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_receive/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_receive/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="df75f373657f0f91332cb47e91e892abb9c113a6" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_ports/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_running_ports/5&lt;/code&gt; no est&amp;aacute; definido, en su lugar se llama al &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5559d0a97110b67775d63df3a3e94529bc745fe9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_running_procs/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_running_procs/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="93b8b767ba992ffc91ebcedb4793839177d0df72" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trace_send/5&lt;/code&gt; is undefined, &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; is called instead.</source>
          <target state="translated">Si &lt;code&gt;trace_send/5&lt;/code&gt; no est&amp;aacute; definido, se llama &lt;code&gt;&lt;a href=&quot;#Module:trace-5&quot;&gt;Module:trace/5&lt;/a&gt;&lt;/code&gt; su lugar.</target>
        </trans-unit>
        <trans-unit id="901bf723e7561c2418b0b1c71d7584f891124177" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;, then request(s) will be sent immediately (in its own message).</source>
          <target state="translated">Si &lt;code&gt;trans_req&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; , las solicitudes se enviar&amp;aacute;n inmediatamente (en su propio mensaje).</target>
        </trans-unit>
        <trans-unit id="680ea9ebc8cd511dd23a5a2d9935ba441ee109e7" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;trans_req&lt;/code&gt; is true, then request(s) will instead be sent to the transaction sender process for accumulation and later sending (see &lt;code&gt;trans_ack_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxcount&lt;/code&gt;, &lt;code&gt;trans_req_maxsize&lt;/code&gt;, &lt;code&gt;trans_ack_maxcount&lt;/code&gt; and &lt;code&gt;trans_timer&lt;/code&gt;).</source>
          <target state="translated">Si &lt;code&gt;trans_req&lt;/code&gt; es verdadero, las solicitudes se enviar&amp;aacute;n en su lugar al proceso del remitente de la transacci&amp;oacute;n para su acumulaci&amp;oacute;n y env&amp;iacute;o posterior (consulte &lt;code&gt;trans_ack_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxcount&lt;/code&gt; , &lt;code&gt;trans_req_maxsize&lt;/code&gt; , &lt;code&gt;trans_ack_maxcount&lt;/code&gt; y &lt;code&gt;trans_timer&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="287b344c66382cf8b1edce4da0960025c7e9b57c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (default), the server sends a cookie extension in its HelloRetryRequest messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e70881a85aca398937951a4668c24337f4bc60ca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode) there is no flow control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48e65bf83526cb9dd2dcc5eaa66577b4aa53e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (full active mode), the pending data or events are sent to the owning process.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; (modo activo completo), los datos o eventos pendientes se env&amp;iacute;an al proceso propietario.</target>
        </trans-unit>
        <trans-unit id="25420436cf7ea356d88467267bb54e499c6238b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; (or &lt;code&gt;extended&lt;/code&gt;), the agent is multi-threaded, with one thread for each get request.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6d949864e0ff9ac2295f12de502f8af44fe5554" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt; the configuration files are re-read during start-up, and the contents of the configuration database ignored. Thus, if &lt;code&gt;true&lt;/code&gt;, changes to the configuration database are lost upon reboot of the agent.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; los archivos de configuraci&amp;oacute;n se vuelven a leer durante el inicio y se ignora el contenido de la base de datos de configuraci&amp;oacute;n. Por lo tanto, si es &lt;code&gt;true&lt;/code&gt; , los cambios en la base de datos de configuraci&amp;oacute;n se pierden al reiniciar el agente.</target>
        </trans-unit>
        <trans-unit id="5742f9a48f2a77c8abfa93b7448bf87101200ba9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, hibernates the &lt;code&gt;gen_statem&lt;/code&gt; by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; before going into &lt;code&gt;receive&lt;/code&gt; to wait for a new external event.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , hiberna &lt;code&gt;gen_statem&lt;/code&gt; llamando a &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; antes de entrar en &lt;code&gt;receive&lt;/code&gt; para esperar un nuevo evento externo.</target>
        </trans-unit>
        <trans-unit id="1c34bbe208e229e88b9cf884fe83c6e4487267fe" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, induces an error on an attempt to send a message larger than the current PMTU size (which would require fragmentation/reassembling). Notice that message fragmentation does not affect the logical atomicity of its delivery; this option is provided for performance reasons only.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , induce un error al intentar enviar un mensaje m&amp;aacute;s grande que el tama&amp;ntilde;o actual de PMTU (que requerir&amp;iacute;a fragmentaci&amp;oacute;n / reensamblaje). Observe que la fragmentaci&amp;oacute;n del mensaje no afecta la atomicidad l&amp;oacute;gica de su entrega; esta opci&amp;oacute;n se proporciona &amp;uacute;nicamente por motivos de rendimiento.</target>
        </trans-unit>
        <trans-unit id="14dea9808b1f89c089706dd845be50b4ae8f0440" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if binds to the IP address. If &lt;code&gt;false&lt;/code&gt;, net_if listens on any IP address on the host where it is running.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , net_if se une a la direcci&amp;oacute;n IP. Si es &lt;code&gt;false&lt;/code&gt; , net_if escucha cualquier direcci&amp;oacute;n IP en el host donde se est&amp;aacute; ejecutando.</target>
        </trans-unit>
        <trans-unit id="1a887d631ac5987f669427d5f352faeefbf326b5" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, net_if does not specify that the IP and port address should be reusable. If &lt;code&gt;false&lt;/code&gt;, the address is set to reusable.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , net_if no especifica que la IP y la direcci&amp;oacute;n del puerto deben ser reutilizables. Si es &lt;code&gt;false&lt;/code&gt; , la direcci&amp;oacute;n se configura como reutilizable.</target>
        </trans-unit>
        <trans-unit id="f8ccef0dc480afe24c0ff21ece83c8c3800b5e39" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it after a &lt;strong&gt;state change&lt;/strong&gt; (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cd4ac0f7d30d624066e424ed5179bc26eafc35f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, postpones the current event and retries it when the state changes (&lt;code&gt;NextState =/= State&lt;/code&gt;).</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , pospone el evento actual y vuelve a &lt;code&gt;NextState =/= State&lt;/code&gt; cuando cambia el estado ( NextState = / = State ).</target>
        </trans-unit>
        <trans-unit id="520af4aded931229fa7189fca614aa3fa7995a83" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the agent is multi-threaded, with one thread for each get request.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , el agente tiene varios subprocesos, con un subproceso para cada solicitud de obtenci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="89015f594d36423a0e641bd12c827ea801ee5cfb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client does not print anything on authorization.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , el cliente no imprime nada en la autorizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="23b8e026fd6aadff53ba83122b74ea4391419aca" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , el cliente guarda una clave de host aceptada para evitar la pregunta de aceptaci&amp;oacute;n la pr&amp;oacute;xima vez que se conecte el mismo host. Si la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; no est&amp;aacute; presente, la clave se guarda en el archivo &quot;known_hosts&quot;. Consulte la opci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; para conocer la ubicaci&amp;oacute;n de ese archivo.</target>
        </trans-unit>
        <trans-unit id="95c8aecfc16da9f44601b813f0d7e51d5bf0f4a9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the client saves an accepted host key to avoid the accept question the next time the same host is connected. If the option &lt;code&gt;&lt;a href=&quot;#type-key_cb_common_option&quot;&gt;key_cb&lt;/a&gt;&lt;/code&gt; is not present, the key is saved in the file &quot;known_hosts&quot;. See option &lt;code&gt;&lt;a href=&quot;ssh_file#type-user_dir_common_option&quot;&gt;user_dir&lt;/a&gt;&lt;/code&gt; for the location of that file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b356ac942be95783b518ac898149e69ff7f29e06" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the execution time and reductions are accumulated.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , se acumulan el tiempo de ejecuci&amp;oacute;n y las reducciones.</target>
        </trans-unit>
        <trans-unit id="a2c9b567f4306cd17d762c08a52cc878115d08b0" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, the log owners are notified when certain log events occur. Defaults to &lt;code&gt;false&lt;/code&gt;. The owners are sent one of the following messages when an event occurs:</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , se notifica a los propietarios del registro cuando se producen determinados eventos del registro. Por defecto es &lt;code&gt;false&lt;/code&gt; . A los propietarios se les env&amp;iacute;a uno de los siguientes mensajes cuando ocurre un evento:</target>
        </trans-unit>
        <trans-unit id="dac3885367e9c29a28f95ee9e91f474fd1b0d8a3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true&lt;/code&gt;, this makes &lt;code&gt;epp_dodger&lt;/code&gt; replace any program forms that could not be parsed with nodes of type &lt;code&gt;text&lt;/code&gt; (see &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt;), representing the raw token sequence of the form, instead of reporting a parse error. The default value is &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Si es &lt;code&gt;true&lt;/code&gt; , esto hace que &lt;code&gt;epp_dodger&lt;/code&gt; reemplace cualquier formulario de programa que no pueda ser analizado con nodos de tipo &lt;code&gt;text&lt;/code&gt; o (ver &lt;code&gt;&lt;a href=&quot;erl_syntax#text-1&quot;&gt;erl_syntax:text/1&lt;/a&gt;&lt;/code&gt; ), que representa la secuencia de token sin formato del formulario, en lugar de informar un error de an&amp;aacute;lisis. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="05b7850adc53f90dafb4ed1b3efc538359d746ae" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;true|once|N&lt;/code&gt; (active modes) received data or events are sent to the owning process. See &lt;code&gt;&lt;a href=&quot;#open-0&quot;&gt;open/0..2&lt;/a&gt;&lt;/code&gt; for the message format.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d40234d0ab231968f3d6203cda0f55c4df8e790c" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;I&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, &lt;code&gt;T&lt;/code&gt;, &lt;code&gt;X&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78d87db40121a7b6b4e4f2f28996811db47d8d7b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;u&lt;/code&gt; is used as subsystem identifier (that is, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt;), all allocators based on &lt;code&gt;alloc_util&lt;/code&gt; are effected. If &lt;code&gt;B&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt;, &lt;code&gt;E&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt;, &lt;code&gt;H&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt;, &lt;code&gt;R&lt;/code&gt;, &lt;code&gt;S&lt;/code&gt;, or &lt;code&gt;T&lt;/code&gt; is used as subsystem identifier, only the specific allocator identifier is effected.</source>
          <target state="translated">Si se usa &lt;code&gt;u&lt;/code&gt; como identificador de subsistema (es decir, &lt;code&gt;&amp;lt;S&amp;gt; = u&lt;/code&gt; ), se efect&amp;uacute;an todos los asignadores basados ​​en &lt;code&gt;alloc_util&lt;/code&gt; . Si se usa &lt;code&gt;B&lt;/code&gt; , &lt;code&gt;D&lt;/code&gt; , &lt;code&gt;E&lt;/code&gt; , &lt;code&gt;F&lt;/code&gt; , &lt;code&gt;H&lt;/code&gt; , &lt;code&gt;L&lt;/code&gt; , &lt;code&gt;R&lt;/code&gt; , &lt;code&gt;S&lt;/code&gt; o &lt;code&gt;T&lt;/code&gt; como identificador de subsistema, solo se efect&amp;uacute;a el identificador de asignador espec&amp;iacute;fico.</target>
        </trans-unit>
        <trans-unit id="784b625fc8171fa4983940bde7848ec14a3e23bf" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;volatile&lt;/code&gt; is returned, the time offset cannot be finalized because &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; is used.</source>
          <target state="translated">Si se devuelve &lt;code&gt;volatile&lt;/code&gt; , el desplazamiento de tiempo no se puede finalizar porque se utiliza el &lt;code&gt;&lt;a href=&quot;time_correction#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="20c03db910bef2b3379b92930db1f3ebc527788d" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only sent messages are logged.</source>
          <target state="translated">Si se especifica &lt;code&gt;write&lt;/code&gt; , solo se registran los mensajes enviados.</target>
        </trans-unit>
        <trans-unit id="a95ad12798c19a97f99824236c8f188c8076b6b4" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write&lt;/code&gt; is specified, only set requests are logged.</source>
          <target state="translated">Si se especifica &lt;code&gt;write&lt;/code&gt; , solo se registran las solicitudes de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b0db310b8af51df282663eafc88eec4c7003919f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;write_concurrency&lt;/code&gt; was enabled for the table.</source>
          <target state="translated">Si se habilit&amp;oacute; &lt;code&gt;write_concurrency&lt;/code&gt; para la tabla.</target>
        </trans-unit>
        <trans-unit id="d130e60ef67783037417bccce56bcf5768c8e099" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; is returned, the emulator is restarted before the upgrade instructions are executed. This occurs if the emulator or any of the applications Kernel, STDLIB, or SASL are updated. The new emulator version and these core applications execute after the restart. For all other applications the old versions are started and the upgrade is performed as normal by executing the upgrade instructions.</source>
          <target state="translated">Si se &lt;code&gt;{continue_after_restart,OtherVsn,Descr}&lt;/code&gt; , el emulador se reinicia antes de que se ejecuten las instrucciones de actualizaci&amp;oacute;n. Esto ocurre si se actualiza el emulador o cualquiera de las aplicaciones Kernel, STDLIB o SASL. La nueva versi&amp;oacute;n del emulador y estas aplicaciones principales se ejecutan despu&amp;eacute;s del reinicio. Para todas las dem&amp;aacute;s aplicaciones, se inician las versiones anteriores y la actualizaci&amp;oacute;n se realiza normalmente mediante la ejecuci&amp;oacute;n de las instrucciones de actualizaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="320cf62f527c030692a3479a90eabc62ad79a175" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned immediately, the call to &lt;code&gt;parse_and_scan/1&lt;/code&gt; returns &lt;code&gt;{ok, eof}&lt;/code&gt;. If &lt;code&gt;{eof, Endline}&lt;/code&gt; is returned before the parser expects end of input, &lt;code&gt;parse_and_scan/1&lt;/code&gt; will, of course, return an error message (see above). Otherwise &lt;code&gt;{ok, Result}&lt;/code&gt; is returned.</source>
          <target state="translated">Si se &lt;code&gt;{eof, Endline}&lt;/code&gt; inmediatamente, la llamada a &lt;code&gt;parse_and_scan/1&lt;/code&gt; devuelve &lt;code&gt;{ok, eof}&lt;/code&gt; . Si se &lt;code&gt;{eof, Endline}&lt;/code&gt; antes de que el analizador espere el final de la entrada, &lt;code&gt;parse_and_scan/1&lt;/code&gt; , por supuesto, devolver&amp;aacute; un mensaje de error (ver arriba). De lo contrario &lt;code&gt;{ok, Result}&lt;/code&gt; se devuelve {ok, Result} .</target>
        </trans-unit>
        <trans-unit id="dedb9788552103a1f455c74f781f00865ba7c935" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{merge_tests,true}&lt;/code&gt; is set in the source specification (which is the default setting), terms in joined specifications are merged with terms in the source specification (according to the description of &lt;code&gt;merge_tests&lt;/code&gt; earlier).</source>
          <target state="translated">Si se establece &lt;code&gt;{merge_tests,true}&lt;/code&gt; en la especificaci&amp;oacute;n de origen (que es la configuraci&amp;oacute;n predeterminada), los t&amp;eacute;rminos de las especificaciones unidas se fusionan con los t&amp;eacute;rminos de la especificaci&amp;oacute;n de origen (seg&amp;uacute;n la descripci&amp;oacute;n de &lt;code&gt;merge_tests&lt;/code&gt; anterior).</target>
        </trans-unit>
        <trans-unit id="e19028ea4203966a6e00632a19c4871950b28ef8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{noreply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt;, or &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt;, the &lt;code&gt;gen_server&lt;/code&gt; process continues executing with &lt;code&gt;NewState&lt;/code&gt;. Any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;{noreply,NewState}&lt;/code&gt; , &lt;code&gt;{noreply,NewState,Timeout}&lt;/code&gt; o &lt;code&gt;{noreply,NewState,hibernate}&lt;/code&gt; , el proceso &lt;code&gt;gen_server&lt;/code&gt; contin&amp;uacute;a ejecut&amp;aacute;ndose con &lt;code&gt;NewState&lt;/code&gt; . Cualquier respuesta a &lt;code&gt;From&lt;/code&gt; debe especificarse expl&amp;iacute;citamente usando &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e61ed5c3d675fd060bf7a5ba0b7669c540660308" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt; proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1637361f321011df9f0024cdad416df7e559bbc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event manager also goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur. It is sufficient that one of the event handlers return &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; for the whole event manager process to hibernate.</source>
          <target state="translated">Si se &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; , el administrador de eventos tambi&amp;eacute;n entra en hibernaci&amp;oacute;n (llamando a &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ), esperando que ocurra el siguiente evento. Es suficiente que uno de los controladores de eventos devuelva &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; para que todo el proceso del administrador de eventos hiberne .</target>
        </trans-unit>
        <trans-unit id="7bf6373c4c4feb0b7b12ba83feca28174cdeeb31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,NewState}&lt;/code&gt; or &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; is returned, the event handler remains in the event manager with the possible updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;{ok,NewState}&lt;/code&gt; o &lt;code&gt;{ok,NewState,hibernate}&lt;/code&gt; , el controlador de eventos permanece en el administrador de eventos con el posible estado interno actualizado &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="622b2b9487b410e4b5c3a44646686c10053b1e31" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; is returned, the event manager goes into hibernation (by calling &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt;), waiting for the next event to occur.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{ok,State,hibernate}&lt;/code&gt; , el administrador de eventos entra en hibernaci&amp;oacute;n (llamando a &lt;code&gt;&lt;a href=&quot;proc_lib#hibernate-3&quot;&gt;proc_lib:hibernate/3&lt;/a&gt;&lt;/code&gt; ), esperando que ocurra el pr&amp;oacute;ximo evento.</target>
        </trans-unit>
        <trans-unit id="4733cd19b2819c31e3b9d228b0a9153e3ac1bda9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; or &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt;, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt; as the return value of &lt;code&gt;call/2,3&lt;/code&gt; or included in the return value of &lt;code&gt;multi_call/2,3,4&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then continues executing with the possibly updated internal state &lt;code&gt;NewState&lt;/code&gt;.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{reply,Reply,NewState,Timeout}&lt;/code&gt; &lt;code&gt;{reply,Reply,NewState}&lt;/code&gt; , {responder, Responder, Nuevo estado, Tiempo de espera} o &lt;code&gt;{reply,Reply,NewState,hibernate}&lt;/code&gt; , &lt;code&gt;Reply&lt;/code&gt; se devuelve a &lt;code&gt;From&lt;/code&gt; como el valor de retorno de la &lt;code&gt;call/2,3&lt;/code&gt; o se incluye en el valor de retorno de &lt;code&gt;multi_call/2,3,4&lt;/code&gt; . El proceso &lt;code&gt;gen_server&lt;/code&gt; contin&amp;uacute;a ejecut&amp;aacute;ndose con el estado interno posiblemente actualizado &lt;code&gt;NewState&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf8d1c1849381a9a2934c0c67001278a230ee2f3" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{save_calls,N}&lt;/code&gt; has been set for the process, no function calls are saved to the call saving list. (The call saving list is not cleared. Also, send, receive, and time-out events are still added to the list.)</source>
          <target state="translated">Si se ha configurado &lt;code&gt;{save_calls,N}&lt;/code&gt; para el proceso, no se guardan llamadas de funci&amp;oacute;n en la lista de guardado de llamadas. (La lista para guardar llamadas no se borra. Adem&amp;aacute;s, los eventos de env&amp;iacute;o, recepci&amp;oacute;n y tiempo de espera a&amp;uacute;n se agregan a la lista).</target>
        </trans-unit>
        <trans-unit id="bfb24986f0a70731e0b63f3291fa396e2f3c519f" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start + Length&lt;/code&gt; is &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si se especifica &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; en las opciones tales que &lt;code&gt;Start&lt;/code&gt; &amp;gt; tama&amp;ntilde;o del &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start + Length&lt;/code&gt; &amp;lt;0 o &lt;code&gt;Start + Length&lt;/code&gt; es&amp;gt; tama&amp;ntilde;o del &lt;code&gt;Subject&lt;/code&gt; , se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="de6994202966362118bb8cacc9efab5d034d0b7e" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; is specified in the options such that &lt;code&gt;Start&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt; 0 or &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; size of &lt;code&gt;Subject&lt;/code&gt;, a &lt;code&gt;badarg&lt;/code&gt; exception is raised.</source>
          <target state="translated">Si se especifica &lt;code&gt;{scope, {Start,Length}}&lt;/code&gt; en las opciones tales como &lt;code&gt;Start&lt;/code&gt; &amp;gt; tama&amp;ntilde;o del &lt;code&gt;Subject&lt;/code&gt; , &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;lt;0 o &lt;code&gt;Start&lt;/code&gt; + &lt;code&gt;Length&lt;/code&gt; &amp;gt; tama&amp;ntilde;o del &lt;code&gt;Subject&lt;/code&gt; , se &lt;code&gt;badarg&lt;/code&gt; una excepci&amp;oacute;n de badarg .</target>
        </trans-unit>
        <trans-unit id="22f0dd2e07f51ba0bec6f71cc1bb3b006093d94a" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9167afbdea5d3a67e5f541cf0e5e6e2773017130" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e478cc8acb7bdb77b1dae6158305c98359cc9ec" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e08b34f61f1a4d3777b205be5de380bc841d230" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip, Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eb02f05292552a7ce9695f8e039ca2486be0efc" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the group are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the group.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; , se omiten todos los casos de prueba del grupo y el &lt;code&gt;Reason&lt;/code&gt; se imprime en el registro general del grupo.</target>
        </trans-unit>
        <trans-unit id="07c6e6c33ab904cab102b2ef7313020f30f3b33b" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the module are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed on the HTML result page.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; , se omiten todos los casos de prueba del m&amp;oacute;dulo y el &lt;code&gt;Reason&lt;/code&gt; se imprime en la p&amp;aacute;gina de resultados HTML.</target>
        </trans-unit>
        <trans-unit id="7176131e2ab61dc6ca1a310323b87e804a6b01fb" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, all test cases in the suite are skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; , se omiten todos los casos de prueba de la suite y la &lt;code&gt;Reason&lt;/code&gt; se imprime en el registro general de la suite.</target>
        </trans-unit>
        <trans-unit id="1d2a5b747d22c7eede603eddd2e58170ad2ad7b8" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{skip,Reason}&lt;/code&gt; is returned, the test case is skipped and &lt;code&gt;Reason&lt;/code&gt; is printed in the overview log for the suite.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{skip,Reason}&lt;/code&gt; , el caso de prueba se salta y el &lt;code&gt;Reason&lt;/code&gt; se imprime en el registro general de la suite.</target>
        </trans-unit>
        <trans-unit id="43c5190e594ca77d2bcd9761108619b8160ca730" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; is returned, any reply to &lt;code&gt;From&lt;/code&gt; must be specified explicitly using &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;gen_server&lt;/code&gt; process then calls &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; and terminates.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{stop,Reason,NewState}&lt;/code&gt; , cualquier respuesta a &lt;code&gt;From&lt;/code&gt; debe especificarse expl&amp;iacute;citamente usando &lt;code&gt;&lt;a href=&quot;#reply-2&quot;&gt;reply/2&lt;/a&gt;&lt;/code&gt; . El proceso &lt;code&gt;gen_server&lt;/code&gt; luego llama a &lt;code&gt;Module:terminate(Reason,NewState)&lt;/code&gt; y termina.</target>
        </trans-unit>
        <trans-unit id="555db6a996a08647cb4789219558187a695b3e75" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; is returned, &lt;code&gt;Reply&lt;/code&gt; is given back to &lt;code&gt;From&lt;/code&gt;.</source>
          <target state="translated">Si se devuelve &lt;code&gt;{stop,Reason,Reply,NewState}&lt;/code&gt; , se devuelve la &lt;code&gt;Reply&lt;/code&gt; a &lt;code&gt;From&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f07068ef6474408f3b2f01c567a6aa9dc31fae9" translate="yes" xml:space="preserve">
          <source>If &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; is returned, the event handler is replaced by &lt;code&gt;Handler2&lt;/code&gt; by first calling &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; and then &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt;, where &lt;code&gt;Term&lt;/code&gt; is the return value of &lt;code&gt;Module:terminate/2&lt;/code&gt;. For more information, see &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Si se &lt;code&gt;{swap_handler,Args1,NewState,Handler2,Args2}&lt;/code&gt; , el controlador de eventos se reemplaza por &lt;code&gt;Handler2&lt;/code&gt; llamando primero a &lt;code&gt;Module:terminate(Args1,NewState)&lt;/code&gt; y luego a &lt;code&gt;Module2:init({Args2,Term})&lt;/code&gt; , donde &lt;code&gt;Term&lt;/code&gt; es el valor de retorno del &lt;code&gt;Module:terminate/2&lt;/code&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;code&gt;&lt;a href=&quot;#swap_handler-3&quot;&gt;swap_handler/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="54e845975dbb16c88ec10ada23488e780175ae56" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;any&lt;/strong&gt; of the &lt;strong&gt;other&lt;/strong&gt; callback functions crashes (exit, throw or a plain crash) or return an invalid result (if a valid return has been specified), this function is called. The purpose is to allow the user handle this error (for instance to issue an error report).</source>
          <target state="translated">Si &lt;strong&gt;alguna&lt;/strong&gt; de las &lt;strong&gt;otras&lt;/strong&gt; funciones de devoluci&amp;oacute;n de llamada falla (salir, lanzar o un bloqueo simple) o devuelve un resultado no v&amp;aacute;lido (si se ha especificado una devoluci&amp;oacute;n v&amp;aacute;lida), se llama a esta funci&amp;oacute;n. El prop&amp;oacute;sito es permitir que el usuario maneje este error (por ejemplo, emitir un informe de error).</target>
        </trans-unit>
        <trans-unit id="937ff2e79e3364cc35a718607a325fdce946f46d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Si es &lt;strong&gt;falso&lt;/strong&gt; , los mensajes megaco se env&amp;iacute;an mediante la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a26b3170e7ada86a34e6bf52ec13abf6a58d809" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;false&lt;/strong&gt;, megaco messages are sent using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Si es &lt;strong&gt;falso&lt;/strong&gt; , los mensajes megaco se env&amp;iacute;an mediante la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d618248269dc3ffbf51a67242f81007c8e747d1d" translate="yes" xml:space="preserve">
          <source>If &lt;strong&gt;true&lt;/strong&gt;, megaco message &lt;strong&gt;re-sends&lt;/strong&gt; are made using the &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; function. The initial message send is still done using the &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Si &lt;strong&gt;cierto&lt;/strong&gt; , Megaco mensaje &lt;strong&gt;vuelve a enviar&lt;/strong&gt; se realizan utilizando el &lt;code&gt;&lt;a href=&quot;megaco_transport#resend_message&quot;&gt;resend_message&lt;/a&gt;&lt;/code&gt; funci&amp;oacute;n. El env&amp;iacute;o del mensaje inicial a&amp;uacute;n se realiza mediante la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;megaco_transport#send_message&quot;&gt;send_message&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6705ceafbe769b2ce43385b2299973a524847817" translate="yes" xml:space="preserve">
          <source>If A and B are matched, but there is a failure in C, matching does not backtrack into A; instead it moves to the next alternative, that is, D. However, if the subpattern containing (*THEN) is given an alternative, it behaves differently:</source>
          <target state="translated">Si A y B se emparejan,pero hay un fallo en C,el emparejamiento no retrocede a A,sino que pasa a la siguiente alternativa,es decir,a D.Sin embargo,si se da una alternativa al subpatrón que contiene (*THEN),se comporta de forma diferente:</target>
        </trans-unit>
        <trans-unit id="c0f5376ef787219224d7bfc3d76505fad1f25c03" translate="yes" xml:space="preserve">
          <source>If A is a subset of X, the &lt;strong id=&quot;image&quot;&gt;image&lt;/strong&gt; of A under R is the set {y : x R y for some x in A}. If B is a subset of Y, the &lt;strong id=&quot;inverse_image&quot;&gt;inverse image&lt;/strong&gt; of B is the set {x : x R y for some y in B}.</source>
          <target state="translated">Si A es un subconjunto de X, la &lt;strong id=&quot;image&quot;&gt;imagen&lt;/strong&gt; de A debajo de R es el conjunto {y: x R y para alguna x en A}. Si B es un subconjunto de Y, la &lt;strong id=&quot;inverse_image&quot;&gt;imagen inversa&lt;/strong&gt; de B es el conjunto {x: x R y para alguna y en B}.</target>
        </trans-unit>
        <trans-unit id="f6a630d6f8d7caebea5102271394fdcd67b18c9d" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,ANNO,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7b4fe5ddbf9a00d696a1d76a1917c8c5d2aeb3e" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K := V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">Si A es una asociaci&amp;oacute;n &lt;code&gt;K := V&lt;/code&gt; , entonces Rep (A) = &lt;code&gt;{map_field_exact,LINE,Rep(K),Rep(V)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75688e538d64827729b81c8f7409b54e266cd7bd" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,ANNO,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="930fd81e91ccd105d16e4034de1e01640fca7bc6" translate="yes" xml:space="preserve">
          <source>If A is an association &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, then Rep(A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt;.</source>
          <target state="translated">Si A es una asociaci&amp;oacute;n &lt;code&gt;K =&amp;gt; V&lt;/code&gt; , entonces Rep (A) = &lt;code&gt;{map_field_assoc,LINE,Rep(K),Rep(V)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="25f2fa0920ecae328194e2e5f0d6947b2fdf2b8f" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,ANNO,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e632ebc019048443e5c38c3f2b726fe623c1461" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K := V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">Si A es un tipo de asociaci&amp;oacute;n &lt;code&gt;K := V&lt;/code&gt; , donde &lt;code&gt;K&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; son tipos, entonces Rep (A) = &lt;code&gt;{type,LINE,map_field_exact,[Rep(K),Rep(V)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd7d66e8b109f42cf2b8b90dae2cc67fe469adfa" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,ANNO,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe916dba3dfcc9f9ef483ef2b2560b99a4239b84" translate="yes" xml:space="preserve">
          <source>If A is an association type &lt;code&gt;K =&amp;gt; V&lt;/code&gt;, where &lt;code&gt;K&lt;/code&gt; and &lt;code&gt;V&lt;/code&gt; are types, then Rep(A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt;.</source>
          <target state="translated">Si A es un tipo de asociaci&amp;oacute;n &lt;code&gt;K =&amp;gt; V&lt;/code&gt; , donde &lt;code&gt;K&lt;/code&gt; y &lt;code&gt;V&lt;/code&gt; son tipos, entonces Rep (A) = &lt;code&gt;{type,LINE,map_field_assoc,[Rep(K),Rep(V)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a746c5a2ff985d711d5a7f13e4e14806e0e62f7d" translate="yes" xml:space="preserve">
          <source>If A matches but B fails, the backtrack to (*COMMIT) causes the entire match to fail. However, if A and B match, but C fails, the backtrack to (*THEN) causes the next alternative (ABD) to be tried. This behavior is consistent, but is not always the same as in Perl. It means that if two or more backtracking verbs appear in succession, the last of them has no effect. Consider the following example:</source>
          <target state="translated">Si A coincide pero B falla,el retroceso a (*COMMIT)hace que todo el partido falle.Sin embargo,si A y B coinciden,pero C falla,el retroceso a (*ENTONCES)causa que se intente la siguiente alternativa (ABD).Este comportamiento es consistente,pero no siempre es el mismo que en Perl.Significa que si dos o más verbos de retroceso aparecen en sucesión,el último de ellos no tiene efecto.Considere el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="5ec09bef075c491da05310ae82ca09d506f563c0" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2a144a893fd5d00844284a1c4ab07c469c50d04" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula de caso &lt;code&gt;P -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0a5aa4f9266e04e273102dd79f1886cfeae24057" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1982d0d507cac2d94792ff43eb098cbb5c7b07ff" translate="yes" xml:space="preserve">
          <source>If C is a case clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula de caso &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep(P)],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3d659eda70c2e50509c30fcc418400a9aab3ac03" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5272c27438c02673801bf9383134101b74af201b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;P -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],[],Rep(B)}&lt;/code&gt; , es decir, una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita &lt;code&gt;throw&lt;/code&gt; y con o sin una variable de seguimiento de pila expl&amp;iacute;cita &lt;code&gt;_&lt;/code&gt; no se puede distinguir de una cl&amp;aacute;usula de captura sin una clase de excepci&amp;oacute;n expl&amp;iacute;cita y sin una variable de seguimiento de pila expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="c311eaf58fab876bdc94780ac91685854b17771c" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66083733733867d178cfdf05fa2ebeeb26e587ba" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class &lt;code&gt;throw&lt;/code&gt; and with or without an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause without an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;P when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({throw,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; , es decir, una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita &lt;code&gt;throw&lt;/code&gt; y con o sin una variable de seguimiento de pila expl&amp;iacute;cita &lt;code&gt;_&lt;/code&gt; no se puede distinguir de una cl&amp;aacute;usula catch sin una clase de excepci&amp;oacute;n expl&amp;iacute;cita y sin una variable de seguimiento de pila expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="8afa8db8880cd11a80b4f7cecb8f0640f10dde11" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="33763f19a17cfabb0fc3a9334e69f568d0598981" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;X : P -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;X&lt;/code&gt; es un literal at&amp;oacute;mico o un patr&amp;oacute;n variable, &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],[],Rep(B)}&lt;/code&gt; , es decir, una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita y con una variable stacktrace expl&amp;iacute;cita &lt;code&gt;_&lt;/code&gt; no se puede distinguir de una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita y sin una variable de seguimiento de pila expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="43cc8aa87c6f7cf6d65593b565e96a75d05633ea" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54e98e1e13987f32a2240be5fce9eca6126a89ed" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;X : P : S -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;X&lt;/code&gt; es un literal at&amp;oacute;mico o un patr&amp;oacute;n variable, &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;S&lt;/code&gt; es una variable y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3a262d7341faa65ccb5ac93e7079518e8857e84b" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ae0f4c55ba607c0c1ac95c07e874e6880664ec9" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, &lt;code&gt;S&lt;/code&gt; is a variable, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;X : P : S when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;X&lt;/code&gt; es un literal at&amp;oacute;mico o un patr&amp;oacute;n variable, &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda, &lt;code&gt;S&lt;/code&gt; es una variable y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,S})],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b0e601c916b6ea0d1855c5d5324b1a12d0303cb8" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd09edeb30671bd8912819376a2a0342249cf516" translate="yes" xml:space="preserve">
          <source>If C is a catch clause &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;X&lt;/code&gt; is an atomic literal or a variable pattern, &lt;code&gt;P&lt;/code&gt; is a pattern, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence, and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt;, that is, a catch clause with an explicit exception class and with an explicit stacktrace variable &lt;code&gt;_&lt;/code&gt; cannot be distinguished from a catch clause with an explicit exception class and without an explicit stacktrace variable.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula catch &lt;code&gt;X : P when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;X&lt;/code&gt; es un literal at&amp;oacute;mico o un patr&amp;oacute;n variable, &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[Rep({X,P,_})],Rep(Gs),Rep(B)}&lt;/code&gt; , es decir, una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita y con una variable de seguimiento de pila expl&amp;iacute;cita &lt;code&gt;_&lt;/code&gt; no se puede distinguir de una cl&amp;aacute;usula catch con una clase de excepci&amp;oacute;n expl&amp;iacute;cita y sin una variable de seguimiento de pila expl&amp;iacute;cita.</target>
        </trans-unit>
        <trans-unit id="4016717fdd4d5433989581c68c30070bb76884da" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,ANNO,constraint,[{atom,ANNO,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df5fe92f62215d00d030e5a7bada64a7329d2d85" translate="yes" xml:space="preserve">
          <source>If C is a constraint &lt;code&gt;V :: T&lt;/code&gt;, where &lt;code&gt;V&lt;/code&gt; is a type variable and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt;.</source>
          <target state="translated">Si C es una restricci&amp;oacute;n &lt;code&gt;V :: T&lt;/code&gt; , donde &lt;code&gt;V&lt;/code&gt; es una variable de tipo y &lt;code&gt;T&lt;/code&gt; es un tipo, entonces Rep (C) = &lt;code&gt;{type,LINE,constraint,[{atom,LINE,is_subtype},[Rep(V),Rep(T)]]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8d2da59f190a64375cc2ab954899e9cace4a77f" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17326d4fa4e4dd923f6996f5fc5f5d27a9e90bfb" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula de funci&amp;oacute;n &lt;code&gt;( Ps ) -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;Ps&lt;/code&gt; es una secuencia de patr&amp;oacute;n y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),[],Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbc0eacd6cf64ab7e1b6a5aa346f15af4ee37ac3" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b58b02b2d6778f5c78bfa5c91aec26b39e9b26e2" translate="yes" xml:space="preserve">
          <source>If C is a function clause &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Ps&lt;/code&gt; is a pattern sequence, &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula de funci&amp;oacute;n &lt;code&gt;( Ps ) when Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;Ps&lt;/code&gt; es una secuencia de patr&amp;oacute;n, &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,Rep(Ps),Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b2834d93e535442b365d66608e72b7dd5d9a7b0" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,ANNO,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bac3b590133c72b3e697e259f15ddfcb5136d5c1" translate="yes" xml:space="preserve">
          <source>If C is an if clause &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt;, where &lt;code&gt;Gs&lt;/code&gt; is a guard sequence and &lt;code&gt;B&lt;/code&gt; is a body, then Rep(C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si C es una cl&amp;aacute;usula if &lt;code&gt;Gs -&amp;gt; B&lt;/code&gt; , donde &lt;code&gt;Gs&lt;/code&gt; es una secuencia de guarda y &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (C) = &lt;code&gt;{clause,LINE,[],Rep(Gs),Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cbfab94d790c9f8ddb1d5350bddeee9c6d6348c" translate="yes" xml:space="preserve">
          <source>If CPU topology information is unavailable.</source>
          <target state="translated">Si la información de la topología de la CPU no está disponible.</target>
        </trans-unit>
        <trans-unit id="a5c3ae58fb5f8a860fea2ef9b561020e0407c0fd" translate="yes" xml:space="preserve">
          <source>If D is a module declaration consisting of the forms &lt;code&gt;F_1&lt;/code&gt;, ..., &lt;code&gt;F_k&lt;/code&gt;, then Rep(D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt;.</source>
          <target state="translated">Si D es una declaraci&amp;oacute;n de m&amp;oacute;dulo que consta de las formas &lt;code&gt;F_1&lt;/code&gt; , ..., &lt;code&gt;F_k&lt;/code&gt; , entonces Rep (D) = &lt;code&gt;[Rep(F_1), ..., Rep(F_k)]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a30963b62350996a8d59e8d3d4f4343c158ae7a4" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385f7db6a01f80887d7150e7f3e7bdd257de0fb5" translate="yes" xml:space="preserve">
          <source>If E is a bitstring comprehension &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">Si E es una comprensi&amp;oacute;n de cadenas de bits &lt;code&gt;&amp;lt;&amp;lt;E_0 || Q_1, ..., Q_k&amp;gt;&amp;gt;&lt;/code&gt; , donde cada &lt;code&gt;Q_i&lt;/code&gt; es un calificador, entonces Rep (E) = &lt;code&gt;{bc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; . Para Rep (Q), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a215b35bfabec03f705356b11df781d76fe9bda6" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a58b032de54c4d5d1f61a79ea10904e5176012ef" translate="yes" xml:space="preserve">
          <source>If E is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Si E es un constructor de cadenas de bits &lt;code&gt;&amp;lt;&amp;lt;E_1:Size_1/TSL_1, ..., E_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; , donde cada &lt;code&gt;Size_i&lt;/code&gt; es una expresi&amp;oacute;n y cada &lt;code&gt;TSL_i&lt;/code&gt; es una lista de tipos espec&amp;iacute;ficos, entonces Rep (E) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(E_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(E_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Para Rep (TSL), consulte a continuaci&amp;oacute;n. Un &lt;code&gt;Size_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; . Un &lt;code&gt;TSL_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="def0fd07bd4ff6d50e1223eca9053d3fa095d182" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,ANNO,Rep(B)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff0400ff578820209af4c6bca75270b191887cfe" translate="yes" xml:space="preserve">
          <source>If E is a block expression &lt;code&gt;begin B end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de bloque &lt;code&gt;begin B end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; es un cuerpo, entonces Rep (E) = &lt;code&gt;{block,LINE,Rep(B)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9d8af3f74254d265168f6c22c16d0838a1ea340" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',ANNO,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d61d85721a2f8e94ee818ecc0cbe514b22d9b6e5" translate="yes" xml:space="preserve">
          <source>If E is a case expression &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where &lt;code&gt;E_0&lt;/code&gt; is an expression and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;case E_0 of Cc_1 ; ... ; Cc_k end&lt;/code&gt; , donde &lt;code&gt;E_0&lt;/code&gt; es una expresi&amp;oacute;n y cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula case, entonces Rep (E) = &lt;code&gt;{'case',LINE,Rep(E_0),[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="096069597c0301e2331f3c9eeb4ba8c6fe89359b" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',ANNO,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20926c71a541ebeeb5a5ce9236741b97b74ee9ee" translate="yes" xml:space="preserve">
          <source>If E is a catch expression &lt;code&gt;catch E_0&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;catch E_0&lt;/code&gt; , captura E_0 , entonces Rep (E) = &lt;code&gt;{'catch',LINE,Rep(E_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b58d732e6eb44c8650ef6ea1ab56a5738fed639" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,ANNO,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d685232ba5f2805f2661aa4dca2a66de454be03" translate="yes" xml:space="preserve">
          <source>If E is a cons skeleton &lt;code&gt;[E_h | E_t]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt;.</source>
          <target state="translated">Si E es un esqueleto de contras &lt;code&gt;[E_h | E_t]&lt;/code&gt; , luego Rep (E) = &lt;code&gt;{cons,LINE,Rep(E_h),Rep(E_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd154a4579d9aa67e94aa4c762704930a595e132" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',ANNO,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00326b0fd36dc640e6ce203654ecdb5f5319afc6" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;fun Fc_1 ; ... ; Fc_k end&lt;/code&gt; , donde cada &lt;code&gt;Fc_i&lt;/code&gt; es una cl&amp;aacute;usula de funci&amp;oacute;n, entonces Rep (E) = &lt;code&gt;{'fun',LINE,{clauses,[Rep(Fc_1), ..., Rep(Fc_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b930f9fc614875b26b77fcef08cb18fabcffa755" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e7ad524342503c66fff38de3f9fd9620fdced2" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Module:Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt;. (Before Erlang/OTP R15: Rep(E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt;.)</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;fun Module:Name/Arity&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{'fun',LINE,{function,Rep(Module),Rep(Name),Rep(Arity)}}&lt;/code&gt; . (Antes de Erlang / OTP R15: Rep (E) = &lt;code&gt;{'fun',LINE,{function,Module,Name,Arity}}&lt;/code&gt; .)</target>
        </trans-unit>
        <trans-unit id="21dea75946b388b1e954dab71b395d65115fda11" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,ANNO,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="508f3673ffdf47d28232744927849cd0723a0e7f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt;, where &lt;code&gt;Name&lt;/code&gt; is a variable and each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause, then Rep(E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;fun Name Fc_1 ; ... ; Name Fc_k end&lt;/code&gt; , donde &lt;code&gt;Name&lt;/code&gt; es una variable y cada &lt;code&gt;Fc_i&lt;/code&gt; es una cl&amp;aacute;usula de funci&amp;oacute;n, luego Rep (E) = &lt;code&gt;{named_fun,LINE,Name,[Rep(Fc_1), ..., Rep(Fc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c48f719d2f5c29bf4ca1a282cd70942bcc783e8f" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',ANNO,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c55128cd4494aabe3305a25ed372470c6cb1e94" translate="yes" xml:space="preserve">
          <source>If E is a fun expression &lt;code&gt;fun Name/Arity&lt;/code&gt;, then Rep(E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;fun Name/Arity&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{'fun',LINE,{function,Name,Arity}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a222846ccb959514cd088c00700755704ce4b70c" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,ANNO,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae431171a9a508e70cab829bfde9130d74f3b08a" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una llamada de funci&amp;oacute;n &lt;code&gt;E_0(E_1, ..., E_k)&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{call,LINE,Rep(E_0),[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b051c7315ab5f877f6f8d1a3fcb5d7352c32d165" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a930c4f44f20684a46e411dc14a24535a2814f3b" translate="yes" xml:space="preserve">
          <source>If E is a function call &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt;, then Rep(E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una llamada de funci&amp;oacute;n &lt;code&gt;E_m:E_0(E_1, ..., E_k)&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(E_m),Rep(E_0)},[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad4dbd16a1df7767e8ca6eb37d1f31ac1e007d69" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,ANNO,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0a9ba22f768bf25ed619e9861b8a15d7cd9192c" translate="yes" xml:space="preserve">
          <source>If E is a list comprehension &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt;, where each &lt;code&gt;Q_i&lt;/code&gt; is a qualifier, then Rep(E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt;. For Rep(Q), see below.</source>
          <target state="translated">Si E es una lista de comprensi&amp;oacute;n &lt;code&gt;[E_0 || Q_1, ..., Q_k]&lt;/code&gt; , donde cada &lt;code&gt;Q_i&lt;/code&gt; es un calificador, entonces Rep (E) = &lt;code&gt;{lc,LINE,Rep(E_0),[Rep(Q_1), ..., Rep(Q_k)]}&lt;/code&gt; . Para Rep (Q), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e8512e6de961ae7de3dc6cd02be5dfd7477d76f7" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c06772c585b4d5e9af41e11c7fa823e87a3781" translate="yes" xml:space="preserve">
          <source>If E is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Si E es una creaci&amp;oacute;n de mapa &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="237f2587bea6e744a08e9b787c8ee8a08e4fc754" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,ANNO,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="800dae600f3ee86ffec1de1f210ed80d17fd2b9b" translate="yes" xml:space="preserve">
          <source>If E is a map update &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; or &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt;, then Rep(E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Si E es una actualizaci&amp;oacute;n de mapa &lt;code&gt;E_0#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;E_i_1 =&amp;gt; E_i_2&lt;/code&gt; o &lt;code&gt;E_i_1 := E_i_2&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{map,LINE,Rep(E_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4f62176ee9725e6dd7a1d357a9791afa6d505171" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,ANNO,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98ecb06f9387738ad9c4608934528d6d6501def9" translate="yes" xml:space="preserve">
          <source>If E is a match operator expression &lt;code&gt;P = E_0&lt;/code&gt;, where &lt;code&gt;P&lt;/code&gt; is a pattern, then Rep(E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de operador de coincidencia &lt;code&gt;P = E_0&lt;/code&gt; , donde &lt;code&gt;P&lt;/code&gt; es un patr&amp;oacute;n, entonces Rep (E) = &lt;code&gt;{match,LINE,Rep(P),Rep(E_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="690ad831c8e62316c71be505eb989a5f5da834db" translate="yes" xml:space="preserve">
          <source>If E is a parenthesized expression &lt;code&gt;( E_0 )&lt;/code&gt;, then Rep(E) = &lt;code&gt;Rep(E_0)&lt;/code&gt;, that is, parenthesized expressions cannot be distinguished from their bodies.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n entre par&amp;eacute;ntesis &lt;code&gt;( E_0 )&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;Rep(E_0)&lt;/code&gt; , es decir, las expresiones entre par&amp;eacute;ntesis no se pueden distinguir de sus cuerpos.</target>
        </trans-unit>
        <trans-unit id="eb97a9c72be1a3ec039d3b19e59af460c1f9597f" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03e50f32be6fa18564dc0f97ac6d17895199c4c5" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, &lt;code&gt;E_0&lt;/code&gt; is an expression, and &lt;code&gt;B_t&lt;/code&gt; is a body, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;receive Cc_1 ; ... ; Cc_k after E_0 -&amp;gt; B_t end&lt;/code&gt; , donde cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula de caso, &lt;code&gt;E_0&lt;/code&gt; es una expresi&amp;oacute;n y &lt;code&gt;B_t&lt;/code&gt; es un cuerpo, entonces Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)],Rep(E_0),Rep(B_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62607bd086692a7a4e73a9a4340bedc98933a8ce" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',ANNO,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81d96409c6d75213915ef6028c674bf71b947761" translate="yes" xml:space="preserve">
          <source>If E is a receive expression &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt;, where each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;receive Cc_1 ; ... ; Cc_k end&lt;/code&gt; , donde cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula de caso, entonces Rep (E) = &lt;code&gt;{'receive',LINE,[Rep(Cc_1), ..., Rep(Cc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8db402d6b9bfaaf27c4221b6ecb8f7a3438ef10d" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="769c6455ce5fde46b459e44a8ec3bffa7196d158" translate="yes" xml:space="preserve">
          <source>If E is a record creation &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una creaci&amp;oacute;n de registro &lt;code&gt;#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; , donde cada &lt;code&gt;Field_i&lt;/code&gt; es un &amp;aacute;tomo o &lt;code&gt;_&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b95681bf643b3e4b28c35faa965a19ee4fda5ac" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,ANNO,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="571a72b7ca82dcb7bd3dbc0550c43c731464ee91" translate="yes" xml:space="preserve">
          <source>If E is a record field access &lt;code&gt;E_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Si E es un campo de registro, acceda a &lt;code&gt;E_0#Name.Field&lt;/code&gt; , donde &lt;code&gt;Field&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (E) = &lt;code&gt;{record_field,LINE,Rep(E_0),Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bd0016f76592cf4abfa2e2b7e0edf19c3c161d6e" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41585c3fb51f7eca9a3e6945efca3d137bddef8d" translate="yes" xml:space="preserve">
          <source>If E is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Si E es un &amp;iacute;ndice de campo de registro &lt;code&gt;#Name.Field&lt;/code&gt; , donde &lt;code&gt;Field&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (E) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0e1680739b87d61cf8de240ccb43c2b9ea6736a" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,ANNO,Rep(E_0),Name,[{record_field,ANNO,Rep(Field_1),Rep(E_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c141b24fbc5240a27271026022f8b84cc1c46ec" translate="yes" xml:space="preserve">
          <source>If E is a record update &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom, then Rep(E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una actualizaci&amp;oacute;n de registro &lt;code&gt;E_0#Name{Field_1=E_1, ..., Field_k=E_k}&lt;/code&gt; , donde cada &lt;code&gt;Field_i&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (E) = &lt;code&gt;{record,LINE,Rep(E_0),Name,[{record_field,LINE,Rep(Field_1),Rep(E_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(E_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1790d1e53e6feb25e42b2594447e491760461bcd" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5433ba0e7386d18ba29df013a33a3bd71eec1de4" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B after A end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; son cuerpos, entonces Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66db70f66ec2e1c9cfff251e52d9d4fb44005444" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb0c9fd33084b3aa2b6298f495d8933521120111" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are bodies, and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k after A end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; son cuerpos, y cada &lt;code&gt;Tc_i&lt;/code&gt; es una cl&amp;aacute;usula catch, entonces Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="527f66fe559f2313ab4c9f07440149b4724a0e36" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0174ae0ac371a20fa8346b5c98865a86bb0973f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body and each &lt;code&gt;Tc_i&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B catch Tc_1 ; ... ; Tc_k end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; es un cuerpo y cada &lt;code&gt;Tc_i&lt;/code&gt; es una cl&amp;aacute;usula catch, entonces Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[],[Rep(Tc_1), ..., Rep(Tc_k)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c97756483607f476bd044cc105daba38c615ff16" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17896fd4f3f657c1acca030c3b7c2477fd7ea070" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, and each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B of Cc_1 ; ... ; Cc_k after A end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; son cuerpos, y cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula de caso, entonces Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed9f5ca2ce8dc840d927013fd593a6e43685c6fc" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f8fa527e6b0ee33c16b21df17493bd713be90d3" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; are a bodies, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n after A end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; son cuerpos, cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula case, y cada &lt;code&gt;Tc_j&lt;/code&gt; es una cl&amp;aacute;usula catch, luego Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],Rep(A)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="87716dd0d35ab489a52485d5fff86ee7a86034f5" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',ANNO,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32741bd8aaa39a55dc66b9c017671086d64dc49f" translate="yes" xml:space="preserve">
          <source>If E is a try expression &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt;, where &lt;code&gt;B&lt;/code&gt; is a body, each &lt;code&gt;Cc_i&lt;/code&gt; is a case clause, and each &lt;code&gt;Tc_j&lt;/code&gt; is a catch clause, then Rep(E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de &lt;code&gt;try B of Cc_1 ; ... ; Cc_k catch Tc_1 ; ... ; Tc_n end&lt;/code&gt; , donde &lt;code&gt;B&lt;/code&gt; es un cuerpo, cada &lt;code&gt;Cc_i&lt;/code&gt; es una cl&amp;aacute;usula case, y cada &lt;code&gt;Tc_j&lt;/code&gt; es una cl&amp;aacute;usula catch, luego Rep (E) = &lt;code&gt;{'try',LINE,Rep(B),[Rep(Cc_1), ..., Rep(Cc_k)],[Rep(Tc_1), ..., Rep(Tc_n)],[]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7a7a0dff10ecd15daa7bf8f1e4f2c478633f53be" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,ANNO,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff91a87e5952e2ad6d9b444216166d09d3ca77eb" translate="yes" xml:space="preserve">
          <source>If E is a tuple skeleton &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt;, then Rep(E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es un esqueleto de tupla &lt;code&gt;{E_1, ..., E_k}&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{tuple,LINE,[Rep(E_1), ..., Rep(E_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d73c4b24d215a5b14fa705cf6b8fc7f04eaa159" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cebb18271309572b378e6bac693d831da6a5de6" translate="yes" xml:space="preserve">
          <source>If E is a variable &lt;code&gt;V&lt;/code&gt;, then Rep(E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Si E es una variable &lt;code&gt;V&lt;/code&gt; , a continuaci&amp;oacute;n, Rep (E) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es un &amp;aacute;tomo con un printname que consiste en los mismos caracteres que &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5399bc470d1e24b61c04135abc6ec1c48ce12a53" translate="yes" xml:space="preserve">
          <source>If E is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(E) = Rep(L).</source>
          <target state="translated">Si E es un literal at&amp;oacute;mico &lt;code&gt;L&lt;/code&gt; , entonces Rep (E) = Rep (L).</target>
        </trans-unit>
        <trans-unit id="704415f6ec0f5288d1cf6770b2ca8548cffab4c3" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',ANNO,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="591459a3195bdb1721ecc29118a41cd9ecf5ad76" translate="yes" xml:space="preserve">
          <source>If E is an if expression &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt;, where each &lt;code&gt;Ic_i&lt;/code&gt; is an if clause, then Rep(E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n &lt;code&gt;if Ic_1 ; ... ; Ic_k end&lt;/code&gt; , donde cada &lt;code&gt;Ic_i&lt;/code&gt; es una cl&amp;aacute;usula if, entonces Rep (E) = &lt;code&gt;{'if',LINE,[Rep(Ic_1), ..., Rep(Ic_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a540b17ecf127991c06127bf562cd9b622f73fd8" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,ANNO,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74042cb0d91ea528b8846bce8407c4c94e7828f3" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;E_1 Op E_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de operador &lt;code&gt;E_1 Op E_2&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador binario distinto del operador de coincidencia &lt;code&gt;=&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_1),Rep(E_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ae3a7a50482463c878cd3a4535e569c8a10c045" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,ANNO,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22209cbc466369d61322ba8f94065874c289f3f5" translate="yes" xml:space="preserve">
          <source>If E is an operator expression &lt;code&gt;Op E_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt;.</source>
          <target state="translated">Si E es una expresi&amp;oacute;n de operador &lt;code&gt;Op E_0&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador unario, entonces Rep (E) = &lt;code&gt;{op,LINE,Op,Rep(E_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0dd90da6de4013d8fcdf427618cebc1de03b8894" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aecc39e30213c6bf99c4212c4aeafe719ce7ed08" translate="yes" xml:space="preserve">
          <source>If E is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(E) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Si E es nulo, &lt;code&gt;[]&lt;/code&gt; , entonces Rep (E) = &lt;code&gt;{nil,LINE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e80045470a896b7cf38c6a0866ea3eab2424863f" translate="yes" xml:space="preserve">
          <source>If Erlang is started in long name distributed mode, it needs to get the domain name from somewhere and reads system &lt;code&gt;inet&lt;/code&gt; configuration files for this information. Any hosts and resolver information found is also recorded, but not used as long as Erlang is configured for native lookups. The information becomes useful if the lookup method is changed to &lt;code&gt;'file'&lt;/code&gt; or &lt;code&gt;'dns'&lt;/code&gt;, see below.</source>
          <target state="translated">Si Erlang se inicia en modo distribuido de nombre largo, necesita obtener el nombre de dominio de alg&amp;uacute;n lugar y lee los archivos de configuraci&amp;oacute;n &lt;code&gt;inet&lt;/code&gt; del sistema para obtener esta informaci&amp;oacute;n. Toda la informaci&amp;oacute;n de hosts y resolutores que se encuentre tambi&amp;eacute;n se registra, pero no se utiliza siempre que Erlang est&amp;eacute; configurado para b&amp;uacute;squedas nativas. La informaci&amp;oacute;n se vuelve &amp;uacute;til si el m&amp;eacute;todo de b&amp;uacute;squeda se cambia a &lt;code&gt;'file'&lt;/code&gt; o &lt;code&gt;'dns'&lt;/code&gt; , ver m&amp;aacute;s abajo.</target>
        </trans-unit>
        <trans-unit id="8ba99b579cb5dc5d83148e021817ebf4a31439e9" translate="yes" xml:space="preserve">
          <source>If Erlang sends, for example, the list &lt;code&gt;[$a,$b,$c]&lt;/code&gt; to the port, the &lt;code&gt;bufflen&lt;/code&gt; variable is &lt;code&gt;3&lt;/code&gt; and the &lt;code&gt;buff&lt;/code&gt; variable contains &lt;code&gt;{'a','b','c'}&lt;/code&gt; (no &lt;code&gt;NULL&lt;/code&gt; termination). Usually the first byte is used as an opcode, which is the case in this driver too (at least when the port is in &lt;code&gt;command&lt;/code&gt; mode). The opcodes are defined as follows:</source>
          <target state="translated">Si Erlang env&amp;iacute;a, por ejemplo, la lista &lt;code&gt;[$a,$b,$c]&lt;/code&gt; al puerto, la variable &lt;code&gt;bufflen&lt;/code&gt; es &lt;code&gt;3&lt;/code&gt; y la variable &lt;code&gt;buff&lt;/code&gt; contiene &lt;code&gt;{'a','b','c'}&lt;/code&gt; (sin terminaci&amp;oacute;n &lt;code&gt;NULL&lt;/code&gt; ). Por lo general, el primer byte se utiliza como c&amp;oacute;digo de operaci&amp;oacute;n, que tambi&amp;eacute;n es el caso en este controlador (al menos cuando el puerto est&amp;aacute; en modo de &lt;code&gt;command&lt;/code&gt; ). Los c&amp;oacute;digos de operaci&amp;oacute;n se definen de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="d4fecac2cf10df2e039ce3e4f4d5fa9aa6b7bf2b" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,ANNO,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="914c013be868be9b46633a3fae8ef36377ee34a1" translate="yes" xml:space="preserve">
          <source>If F is a function declaration &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt;, where each &lt;code&gt;Fc_i&lt;/code&gt; is a function clause with a pattern sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si F es una declaraci&amp;oacute;n de funci&amp;oacute;n &lt;code&gt;Name Fc_1 ; ... ; Name Fc_k&lt;/code&gt; , donde cada &lt;code&gt;Fc_i&lt;/code&gt; es una cl&amp;aacute;usula de funci&amp;oacute;n con una secuencia de patr&amp;oacute;n de la misma longitud &lt;code&gt;Arity&lt;/code&gt; , luego Rep (F) = &lt;code&gt;{function,LINE,Name,Arity,[Rep(Fc_1), ...,Rep(Fc_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="92b2fdf009166615e68068377c093d1265169847" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="839e0427c2712f13a30277505b79b3f3678e27bc" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt;, where &lt;code&gt;Spec&lt;/code&gt; is either the atom &lt;code&gt;spec&lt;/code&gt; or the atom &lt;code&gt;callback&lt;/code&gt;, and each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Si F es una especificaci&amp;oacute;n de funci&amp;oacute;n &lt;code&gt;-Spec Name Ft_1; ...; Ft_k&lt;/code&gt; , donde &lt;code&gt;Spec&lt;/code&gt; es la &lt;code&gt;spec&lt;/code&gt; del &amp;aacute;tomo o la &lt;code&gt;callback&lt;/code&gt; del &amp;aacute;tomo , y cada &lt;code&gt;Ft_i&lt;/code&gt; es un tipo de funci&amp;oacute;n posiblemente restringido con una secuencia de argumentos de la misma longitud &lt;code&gt;Arity&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,Line,Spec,{{Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7b133a685e1078d511adc4d4a4c0155cfdea6af" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17271a999b9344b2a590ac6ed7fcd19ea7837c3a" translate="yes" xml:space="preserve">
          <source>If F is a function specification &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt;, where each &lt;code&gt;Ft_i&lt;/code&gt; is a possibly constrained function type with an argument sequence of the same length &lt;code&gt;Arity&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Si F es una especificaci&amp;oacute;n de funci&amp;oacute;n &lt;code&gt;-spec Mod:Name Ft_1; ...; Ft_k&lt;/code&gt; , donde cada &lt;code&gt;Ft_i&lt;/code&gt; es un tipo de funci&amp;oacute;n posiblemente restringido con una secuencia de argumentos de la misma longitud &lt;code&gt;Arity&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,Line,spec,{{Mod,Name,Arity},[Rep(Ft_1), ..., Rep(Ft_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3fa68f807198b22105fc44214b7d3c63162ade67" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,ANNO,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd91f9ee512189a9782c72f858106c81c42eb39a" translate="yes" xml:space="preserve">
          <source>If F is a record declaration &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt;, where each &lt;code&gt;V_i&lt;/code&gt; is a record field, then Rep(F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;. For Rep(V), see below.</source>
          <target state="translated">Si F es una declaraci&amp;oacute;n de registro &lt;code&gt;-record(Name,{V_1, ..., V_k})&lt;/code&gt; , donde cada &lt;code&gt;V_i&lt;/code&gt; es un campo de registro, entonces Rep (F) = &lt;code&gt;{attribute,LINE,record,{Name,[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; . Para Rep (V), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="25adb05f207dd769bbafb0f578b65f641a0a7794" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,ANNO,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eab32c665244fb293fe17fe26c52469e41031dd4" translate="yes" xml:space="preserve">
          <source>If F is a record field type &lt;code&gt;Name :: Type&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt;.</source>
          <target state="translated">Si F es un tipo de campo de registro &lt;code&gt;Name :: Type&lt;/code&gt; , donde &lt;code&gt;Type&lt;/code&gt; es un tipo, entonces Rep (F) = &lt;code&gt;{type,LINE,field_type,[Rep(Name),Rep(Type)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6239a9176ea881407034a190550ff59286863ce7" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a type variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,ANNO,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31cc499e6743611a48be1c32ba0e0814b6fa811f" translate="yes" xml:space="preserve">
          <source>If F is a type declaration &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt;, where &lt;code&gt;Type&lt;/code&gt; is either the atom &lt;code&gt;type&lt;/code&gt; or the atom &lt;code&gt;opaque&lt;/code&gt;, each &lt;code&gt;V_i&lt;/code&gt; is a variable, and &lt;code&gt;T&lt;/code&gt; is a type, then Rep(F) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt;.</source>
          <target state="translated">Si F es una declaraci&amp;oacute;n de tipo &lt;code&gt;-Type Name(V_1, ..., V_k) :: T&lt;/code&gt; , donde &lt;code&gt;Type&lt;/code&gt; es el &lt;code&gt;type&lt;/code&gt; &amp;aacute;tomo o el &amp;aacute;tomo &lt;code&gt;opaque&lt;/code&gt; , cada &lt;code&gt;V_i&lt;/code&gt; es una variable y &lt;code&gt;T&lt;/code&gt; es un tipo, entonces Rep (F ) = &lt;code&gt;{attribute,LINE,Type,{Name,Rep(T),[Rep(V_1), ..., Rep(V_k)]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="18b64b9b51dd41ff649ef5c26db0f7f069a7d35d" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,A,T}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81677bfb1fe791cbe449f2226181f612e7d5741" translate="yes" xml:space="preserve">
          <source>If F is a wild attribute &lt;code&gt;-A(T)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo salvaje &lt;code&gt;-A(T)&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,A,T}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b1d2d6dc97c9b7259053b20eb74732ea1141eebd" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c092236a8dd4b964a8de640c01239a90a1e7a1ac" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo &lt;code&gt;-export([Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,export,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c034270eafab2ed7bcecacf02af15e5097193b1d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3859e84d13f06a07d526a9d0610934ed80fd58d" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-file(File,Line)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo &lt;code&gt;-file(File,Line)&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,file,{File,Line}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2d15becf26ad2d7caf42380a72b2c27da43c41" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2bb3ff8ec37dad7da6fb624ff1aa1f2defef3f1c" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo &lt;code&gt;-import(Mod,[Fun_1/A_1, ..., Fun_k/A_k])&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,import,{Mod,[{Fun_1,A_1}, ..., {Fun_k,A_k}]}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eb3ea6219e1cb69bee47ba7d3c0d07637a4dae6e" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,ANNO,module,Mod}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740887309045a225d9cb600109651a0966db65e3" translate="yes" xml:space="preserve">
          <source>If F is an attribute &lt;code&gt;-module(Mod)&lt;/code&gt;, then Rep(F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt;.</source>
          <target state="translated">Si F es un atributo &lt;code&gt;-module(Mod)&lt;/code&gt; , entonces Rep (F) = &lt;code&gt;{attribute,LINE,module,Mod}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc8b8c5e56eae2112a18d51dd6a9fcb8af749ac2" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,ANNO,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be0d9740980dc9bb7d3b497c88ac52e3e4ae32a4" translate="yes" xml:space="preserve">
          <source>If Ft is a constrained function type &lt;code&gt;Ft_1 when Fc&lt;/code&gt;, where &lt;code&gt;Ft_1&lt;/code&gt; is a function type and &lt;code&gt;Fc&lt;/code&gt; is a function constraint, then Rep(T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt;. For Rep(Fc), see below.</source>
          <target state="translated">Si Ft es un tipo de funci&amp;oacute;n restringida &lt;code&gt;Ft_1 when Fc&lt;/code&gt; , donde &lt;code&gt;Ft_1&lt;/code&gt; es un tipo de funci&amp;oacute;n y &lt;code&gt;Fc&lt;/code&gt; es una restricci&amp;oacute;n de funci&amp;oacute;n, entonces Rep (T) = &lt;code&gt;{type,LINE,bounded_fun,[Rep(Ft_1),Rep(Fc)]}&lt;/code&gt; . Para Rep (Fc), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="addf4ad1342821174bcf34191602826b5ec30735" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,ANNO,'fun',[{type,ANNO,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ad272ac4cee50fc07993902e12ff74bb1a162f57" translate="yes" xml:space="preserve">
          <source>If Ft is a function type &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt;, where each &lt;code&gt;T_i&lt;/code&gt; is a type, then Rep(Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt;.</source>
          <target state="translated">Si Ft es un tipo de funci&amp;oacute;n &lt;code&gt;(T_1, ..., T_n) -&amp;gt; T_0&lt;/code&gt; , donde cada &lt;code&gt;T_i&lt;/code&gt; es un tipo, entonces Rep (Ft) = &lt;code&gt;{type,LINE,'fun',[{type,LINE,product,[Rep(T_1), ..., Rep(T_n)]},Rep(T_0)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956fa8f47f1bcedade9724b256d1fe2c59b770a8" translate="yes" xml:space="preserve">
          <source>If G is a directed graph, it holds that the vertices and edges of G are the same as the vertices and edges of &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt;.</source>
          <target state="translated">Si G es un grafo dirigido, sostiene que los v&amp;eacute;rtices y aristas de G son los mismos que los v&amp;eacute;rtices y aristas de &lt;code&gt;family_to_digraph(digraph_to_family(G))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02f41904356cb27048a5f981f0ab30233861e22f" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7c4c1f8a634a58d8cf6efc770bf44b8e01c62ed" translate="yes" xml:space="preserve">
          <source>If Gt is a bitstring constructor &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is a guard test and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see above. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un constructor de cadenas de bits &lt;code&gt;&amp;lt;&amp;lt;Gt_1:Size_1/TSL_1, ..., Gt_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; , donde cada &lt;code&gt;Size_i&lt;/code&gt; es una prueba de protecci&amp;oacute;n y cada &lt;code&gt;TSL_i&lt;/code&gt; es una lista de tipos espec&amp;iacute;ficos, entonces Rep (Gt) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(Gt_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(Gt_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Para Rep (TSL), consulte m&amp;aacute;s arriba. Un &lt;code&gt;Size_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; . Un &lt;code&gt;TSL_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd4e2d2654420d08ff75e569801e0f82ea1d8e67" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,ANNO,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84104d736902648592238a7aed481c0fca8a1b02" translate="yes" xml:space="preserve">
          <source>If Gt is a cons skeleton &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un esqueleto de contras &lt;code&gt;[Gt_h | Gt_t]&lt;/code&gt; , luego Rep (Gt) = &lt;code&gt;{cons,LINE,Rep(Gt_h),Rep(Gt_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="67aa27e3b255c0b23af7ede9fa213ab9884fe39f" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,ANNO,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="155c34327c1aac1242765939018d40572e3ece41" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es una funci&amp;oacute;n llamada &lt;code&gt;A(Gt_1, ..., Gt_k)&lt;/code&gt; , donde &lt;code&gt;A&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (Gt) = &lt;code&gt;{call,LINE,Rep(A),[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="62b6a664574ec6785fbcee63137675fde7e8ef5d" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,ANNO,{remote,ANNO,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fe106be5e00c62f004b81ec1a1e00fa0b616f14" translate="yes" xml:space="preserve">
          <source>If Gt is a function call &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt;, where &lt;code&gt;A_m&lt;/code&gt; is the atom &lt;code&gt;erlang&lt;/code&gt; and &lt;code&gt;A&lt;/code&gt; is an atom or an operator, then Rep(Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es una llamada de funci&amp;oacute;n &lt;code&gt;A_m:A(Gt_1, ..., Gt_k)&lt;/code&gt; , donde &lt;code&gt;A_m&lt;/code&gt; es el &amp;aacute;tomo &lt;code&gt;erlang&lt;/code&gt; y &lt;code&gt;A&lt;/code&gt; es un &amp;aacute;tomo o un operador, entonces Rep (Gt) = &lt;code&gt;{call,LINE,{remote,LINE,Rep(A_m),Rep(A)},[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8aef2cea48fdeba80e26c88e7eef4d4b0dc0be26" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da3cc863263c90fe7c570740ba4eda5e38a4f773" translate="yes" xml:space="preserve">
          <source>If Gt is a map creation &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Si Gt es una creaci&amp;oacute;n de mapa &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), vea arriba.</target>
        </trans-unit>
        <trans-unit id="9d73cdb5044edf8f644c77dc585bc5cd5213ffd6" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,ANNO,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b68b45a396309326113e63efb931d56c934f4e8" translate="yes" xml:space="preserve">
          <source>If Gt is a map update &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; or &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see above.</source>
          <target state="translated">Si Gt es una actualizaci&amp;oacute;n de mapa &lt;code&gt;Gt_0#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;Gt_i_1 =&amp;gt; Gt_i_2&lt;/code&gt; o &lt;code&gt;Gt_i_1 := Gt_i_2&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{map,LINE,Rep(Gt_0),[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), vea arriba.</target>
        </trans-unit>
        <trans-unit id="c71638db3891d8e47094eaea5193942aba235460" translate="yes" xml:space="preserve">
          <source>If Gt is a parenthesized guard test &lt;code&gt;( Gt_0 )&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt;, that is, parenthesized guard tests cannot be distinguished from their bodies.</source>
          <target state="translated">Si Gt es una prueba de guardia entre par&amp;eacute;ntesis &lt;code&gt;( Gt_0 )&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;Rep(Gt_0)&lt;/code&gt; , es decir, las pruebas de guardia entre par&amp;eacute;ntesis no se pueden distinguir de sus cuerpos.</target>
        </trans-unit>
        <trans-unit id="5515e293f7cbca6cd1b4d86301ecc8fcc5ad59f4" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,ANNO,Name,[{record_field,ANNO,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,ANNO,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95bc9c3e2bbe4154125f8e83e7d1dec9ccf69c3a" translate="yes" xml:space="preserve">
          <source>If Gt is a record creation &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt;, where each &lt;code&gt;Field_i&lt;/code&gt; is an atom or &lt;code&gt;_&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es una creaci&amp;oacute;n de registro &lt;code&gt;#Name{Field_1=Gt_1, ..., Field_k=Gt_k}&lt;/code&gt; , donde cada &lt;code&gt;Field_i&lt;/code&gt; es un &amp;aacute;tomo o &lt;code&gt;_&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{record,LINE,Name,[{record_field,LINE,Rep(Field_1),Rep(Gt_1)}, ..., {record_field,LINE,Rep(Field_k),Rep(Gt_k)}]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0d8c3bdf875936951f6be38abd9a234defb4a787" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,ANNO,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f5219d21b74d303638f0d998d1a523861cfd8ed" translate="yes" xml:space="preserve">
          <source>If Gt is a record field access &lt;code&gt;Gt_0#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un campo de registro, acceda a &lt;code&gt;Gt_0#Name.Field&lt;/code&gt; , donde &lt;code&gt;Field&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (Gt) = &lt;code&gt;{record_field,LINE,Rep(Gt_0),Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0ddc523ac11939b47b6ea5667d89b0cf0cbb87da" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,ANNO,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a706262c44fbdd9118d527a47e94cc7e8f43cf92" translate="yes" xml:space="preserve">
          <source>If Gt is a record field index &lt;code&gt;#Name.Field&lt;/code&gt;, where &lt;code&gt;Field&lt;/code&gt; is an atom, then Rep(Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un &amp;iacute;ndice de campo de registro &lt;code&gt;#Name.Field&lt;/code&gt; , donde &lt;code&gt;Field&lt;/code&gt; es un &amp;aacute;tomo, entonces Rep (Gt) = &lt;code&gt;{record_index,LINE,Name,Rep(Field)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91b1ff08bce1f7be5c86e93bf7b896dcee2bcdda" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,ANNO,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f481667ce91658bcad558a1af4b78b60f7692744" translate="yes" xml:space="preserve">
          <source>If Gt is a tuple skeleton &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un esqueleto de tupla &lt;code&gt;{Gt_1, ..., Gt_k}&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{tuple,LINE,[Rep(Gt_1), ..., Rep(Gt_k)]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86ba6ce0ad44989a3f9fca3540904be2d98eb9da" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,ANNO,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f06988b89d180cb11b8982908198902c04bcea42" translate="yes" xml:space="preserve">
          <source>If Gt is a variable pattern &lt;code&gt;V&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt;, where A is an atom with a printname consisting of the same characters as &lt;code&gt;V&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un patr&amp;oacute;n variable &lt;code&gt;V&lt;/code&gt; , a continuaci&amp;oacute;n, Rep (Gt) = &lt;code&gt;{var,LINE,A}&lt;/code&gt; , donde A es un &amp;aacute;tomo con un printname que consiste en los mismos caracteres que &lt;code&gt;V&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b80b2b10f76759502fc592d77587e295e44b6d5" translate="yes" xml:space="preserve">
          <source>If Gt is an atomic literal &lt;code&gt;L&lt;/code&gt;, then Rep(Gt) = Rep(L).</source>
          <target state="translated">Si Gt es un literal at&amp;oacute;mico &lt;code&gt;L&lt;/code&gt; , entonces Rep (Gt) = Rep (L).</target>
        </trans-unit>
        <trans-unit id="30bbb65a3435cb7a0b644ba508d8ad7e2aebd344" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ecca50d53c2df91c648c581d109d377a56d333" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a binary operator other than match operator &lt;code&gt;=&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es una prueba de guardia de operador &lt;code&gt;Gt_1 Op Gt_2&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador binario distinto del operador de coincidencia &lt;code&gt;=&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_1),Rep(Gt_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1590398d554a502b9031594d26d2e7f3c303dfca" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,ANNO,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59964cf24a3c6e579aace4b47998306937171209" translate="yes" xml:space="preserve">
          <source>If Gt is an operator guard test &lt;code&gt;Op Gt_0&lt;/code&gt;, where &lt;code&gt;Op&lt;/code&gt; is a unary operator, then Rep(Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es un operador de guardia, prueba &lt;code&gt;Op Gt_0&lt;/code&gt; , donde &lt;code&gt;Op&lt;/code&gt; es un operador unario, entonces Rep (Gt) = &lt;code&gt;{op,LINE,Op,Rep(Gt_0)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2bba2b902d7d011a3e4c35fe4e116ae49fd9a8a3" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,ANNO}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="498668c1ce816a52c1e11cee91561fc3f7281cec" translate="yes" xml:space="preserve">
          <source>If Gt is nil, &lt;code&gt;[]&lt;/code&gt;, then Rep(Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt;.</source>
          <target state="translated">Si Gt es nulo, &lt;code&gt;[]&lt;/code&gt; , entonces Rep (Gt) = &lt;code&gt;{nil,LINE}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fb631647ead2cb8b76c4ec1b07f1f0c70bf1b1d6" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,ANNO,L}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d91f44fbe3739ece99b11544ff08c06f7058b62" translate="yes" xml:space="preserve">
          <source>If L is a character literal, then Rep(L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Si L es un car&amp;aacute;cter literal, entonces Rep (L) = &lt;code&gt;{char,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="893eb2ba60965c09a51b1e49cb8017e58a360073" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,ANNO,L}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a70af53d75e256462e24f2a854c77741b9fe2a6" translate="yes" xml:space="preserve">
          <source>If L is a float literal, then Rep(L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Si L es un literal flotante, entonces Rep (L) = &lt;code&gt;{float,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b31cf2c573d35c24a7c01f8fb6b6ee646806df21" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,ANNO,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc4e7443f3bff9431f378dad125819933dd7b906" translate="yes" xml:space="preserve">
          <source>If L is a string literal consisting of the characters &lt;code&gt;C_1&lt;/code&gt;, ..., &lt;code&gt;C_k&lt;/code&gt;, then Rep(L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt;.</source>
          <target state="translated">Si L es una cadena literal que consta de los caracteres &lt;code&gt;C_1&lt;/code&gt; , ..., &lt;code&gt;C_k&lt;/code&gt; , entonces Rep (L) = &lt;code&gt;{string,LINE,[C_1, ..., C_k]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46dc6ddf19639701de194e194ca59776f621ce0b" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,ANNO,L}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c151061397c80cc4494386daf911cd7cd3768421" translate="yes" xml:space="preserve">
          <source>If L is an atom literal, then Rep(L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Si L es un literal de &amp;aacute;tomo, entonces Rep (L) = &lt;code&gt;{atom,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9daa1db636bdb57e06f2782f31b76d4535249681" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,ANNO,L}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="009d689b146fb6ed54f2471e1d09e781555b973a" translate="yes" xml:space="preserve">
          <source>If L is an integer literal, then Rep(L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt;.</source>
          <target state="translated">Si L es un literal entero, entonces Rep (L) = &lt;code&gt;{integer,LINE,L}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84cceee508e21c83ef5e5c68f567b7df3c0d24d4" translate="yes" xml:space="preserve">
          <source>If Mnesia is down on the local node, the function returns those other &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; that for the moment are operational.</source>
          <target state="translated">Si Mnesia est&amp;aacute; inactivo en el nodo local, la funci&amp;oacute;n devuelve esos otros &lt;code&gt;db_nodes&lt;/code&gt; y &lt;code&gt;extra_db_nodes&lt;/code&gt; que por el momento est&amp;aacute;n operativos.</target>
        </trans-unit>
        <trans-unit id="d2c7cf7bb11840eda288723b23ff4cc867a91195" translate="yes" xml:space="preserve">
          <source>If Mnesia is started, the function returns those nodes that Mnesia on the local node is fully connected to. Only those nodes that Mnesia has exchanged schema information with are included as &lt;code&gt;running_db_nodes&lt;/code&gt;. After the merge of schemas, the local Mnesia system is fully operable and applications can perform access of remote replicas. Before the schema merge, Mnesia only operates locally. Sometimes there are more nodes included in the &lt;code&gt;running_db_nodes&lt;/code&gt; list than all &lt;code&gt;db_nodes&lt;/code&gt; and &lt;code&gt;extra_db_nodes&lt;/code&gt; together.</source>
          <target state="translated">Si se inicia Mnesia, la funci&amp;oacute;n devuelve los nodos a los que Mnesia en el nodo local est&amp;aacute; completamente conectado. Solo aquellos nodos con los que Mnesia ha intercambiado informaci&amp;oacute;n de esquema se incluyen como &lt;code&gt;running_db_nodes&lt;/code&gt; . Despu&amp;eacute;s de la fusi&amp;oacute;n de esquemas, el sistema local de Mnesia est&amp;aacute; completamente operativo y las aplicaciones pueden realizar el acceso de r&amp;eacute;plicas remotas. Antes de la fusi&amp;oacute;n de esquemas, Mnesia solo opera localmente. A veces, hay m&amp;aacute;s nodos incluidos en la lista &lt;code&gt;running_db_nodes&lt;/code&gt; que todos los &lt;code&gt;db_nodes&lt;/code&gt; y &lt;code&gt;extra_db_nodes&lt;/code&gt; juntos.</target>
        </trans-unit>
        <trans-unit id="1e5a20f661013e882b9b593b517c8c9ba753d645" translate="yes" xml:space="preserve">
          <source>If Mnesia is used as storage method, Mnesia must be started before the HTTP server. The first time Mnesia is started, the schema and the tables must be created before Mnesia is started. A simple example of a module with two functions that creates and start Mnesia is provided here. Function &lt;code&gt;first_start/0&lt;/code&gt; is to be used the first time. It creates the schema and the tables. &lt;code&gt;start/0&lt;/code&gt; is to be used in consecutive startups. &lt;code&gt;start/0&lt;/code&gt; starts Mnesia and waits for the tables to be initiated. This function must only be used when the schema and the tables are already created.</source>
          <target state="translated">Si se utiliza Mnesia como m&amp;eacute;todo de almacenamiento, Mnesia debe iniciarse antes que el servidor HTTP. La primera vez que se inicia Mnesia, el esquema y las tablas deben crearse antes de iniciar Mnesia. Aqu&amp;iacute; se proporciona un ejemplo simple de un m&amp;oacute;dulo con dos funciones que crea e inicia Mnesia. La funci&amp;oacute;n &lt;code&gt;first_start/0&lt;/code&gt; debe utilizarse la primera vez. Crea el esquema y las tablas. &lt;code&gt;start/0&lt;/code&gt; se utilizar&amp;aacute; en arranques consecutivos. &lt;code&gt;start/0&lt;/code&gt; inicia Mnesia y espera a que se inicien las tablas. Esta funci&amp;oacute;n solo debe usarse cuando el esquema y las tablas ya est&amp;aacute;n creadas.</target>
        </trans-unit>
        <trans-unit id="a0ff6de34e690fd37142329b3d2414f3154795bb" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,ANNO,[{bin_element,ANNO,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,ANNO,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34211f341486b630397795df16c3df17f3d92d3" translate="yes" xml:space="preserve">
          <source>If P is a bitstring pattern &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt;, where each &lt;code&gt;Size_i&lt;/code&gt; is an expression that can be evaluated to an integer, and each &lt;code&gt;TSL_i&lt;/code&gt; is a type specificer list, then Rep(P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt;. For Rep(TSL), see below. An omitted &lt;code&gt;Size_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;. An omitted &lt;code&gt;TSL_i&lt;/code&gt; is represented by &lt;code&gt;default&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de cadena de bits &lt;code&gt;&amp;lt;&amp;lt;P_1:Size_1/TSL_1, ..., P_k:Size_k/TSL_k&amp;gt;&amp;gt;&lt;/code&gt; , donde cada &lt;code&gt;Size_i&lt;/code&gt; es una expresi&amp;oacute;n que se puede evaluar como un n&amp;uacute;mero entero, y cada &lt;code&gt;TSL_i&lt;/code&gt; es una lista de tipos espec&amp;iacute;ficos, entonces Rep (P) = &lt;code&gt;{bin,LINE,[{bin_element,LINE,Rep(P_1),Rep(Size_1),Rep(TSL_1)}, ..., {bin_element,LINE,Rep(P_k),Rep(Size_k),Rep(TSL_k)}]}&lt;/code&gt; . Para Rep (TSL), consulte a continuaci&amp;oacute;n. Un &lt;code&gt;Size_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; . Un &lt;code&gt;TSL_i&lt;/code&gt; omitido se representa de &lt;code&gt;default&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d37994ece6f75def5d9f7facc328a7886d4a88b5" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,ANNO,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8c2a2980c64258557d34be973ca8c30e59cc6bc" translate="yes" xml:space="preserve">
          <source>If P is a compound pattern &lt;code&gt;P_1 = P_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n compuesto &lt;code&gt;P_1 = P_2&lt;/code&gt; , entonces Rep (P) = &lt;code&gt;{match,LINE,Rep(P_1),Rep(P_2)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3c6ccb3b7440efc69c50224b64f913af2ed5a932" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,ANNO,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b3a96a126f33c33dfd4bad3afe04a55374bef41" translate="yes" xml:space="preserve">
          <source>If P is a cons pattern &lt;code&gt;[P_h | P_t]&lt;/code&gt;, then Rep(P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt;.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de contras &lt;code&gt;[P_h | P_t]&lt;/code&gt; , luego Rep (P) = &lt;code&gt;{cons,LINE,Rep(P_h),Rep(P_t)}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2c7ec165d91dd1b0c944a7cacc79a36a649770" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,ANNO,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd5a1996d5cee5775413b66baffcba7cfd424d8b" translate="yes" xml:space="preserve">
          <source>If P is a map pattern &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt;, where each &lt;code&gt;A_i&lt;/code&gt; is an association &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt;, then Rep(P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt;. For Rep(A), see below.</source>
          <target state="translated">Si P es un patr&amp;oacute;n de mapa &lt;code&gt;#{A_1, ..., A_k}&lt;/code&gt; , donde cada &lt;code&gt;A_i&lt;/code&gt; es una asociaci&amp;oacute;n &lt;code&gt;P_i_1 := P_i_2&lt;/code&gt; , entonces Rep (P) = &lt;code&gt;{map,LINE,[Rep(A_1), ..., Rep(A_k)]}&lt;/code&gt; . Para Rep (A), consulte a continuaci&amp;oacute;n.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
