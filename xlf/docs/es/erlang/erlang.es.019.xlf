<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="46d85843a85d8a0d52723585742b11afd0899160" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;OptionList&lt;/code&gt; can be used to specify certain behavior regarding ports and triggering monitors under certain conditions:</source>
          <target state="translated">Argument &lt;code&gt;OptionList&lt;/code&gt; se puede utilizar para especificar cierto comportamiento con respecto a los puertos y la activaci&amp;oacute;n de monitores en determinadas condiciones:</target>
        </trans-unit>
        <trans-unit id="de736e1203b55111eca5eccfabbf9c9e91ef73a2" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Options&lt;/code&gt; is a list of &lt;code&gt;{Key, Val}&lt;/code&gt; tuples, where the following values are allowed:</source>
          <target state="translated">&lt;code&gt;Options&lt;/code&gt; argumento es una lista de tuplas &lt;code&gt;{Key, Val}&lt;/code&gt; , donde se permiten los siguientes valores:</target>
        </trans-unit>
        <trans-unit id="1e3ff41c882e1943400872693455aba35a7dc893" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Opts&lt;/code&gt; is a list of the following possible options:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f846b2639fdccdd7fe83e5494fa41e5843c66eb2" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;PreArgs&lt;/code&gt; is a list of tagged values. There are two tags, &lt;code&gt;parent_value&lt;/code&gt; and &lt;code&gt;stop_fun&lt;/code&gt;, used by Mnesia for managing transactions.</source>
          <target state="translated">Argument &lt;code&gt;PreArgs&lt;/code&gt; es una lista de valores etiquetados. Hay dos etiquetas, &lt;code&gt;parent_value&lt;/code&gt; y &lt;code&gt;stop_fun&lt;/code&gt; , utilizadas por Mnesia para administrar transacciones.</target>
        </trans-unit>
        <trans-unit id="63f20a5312d5f256e87436cce6c76d1a556dfbb0" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Server&lt;/code&gt; in the SFTP functions is only to be used for SFTP sessions that have been started on existing SSH connections (that is, when the original connection type is &lt;code&gt;ssh&lt;/code&gt;). Whenever the connection type is &lt;code&gt;sftp&lt;/code&gt;, use the SSH connection reference only.</source>
          <target state="translated">Argument &lt;code&gt;Server&lt;/code&gt; en las funciones SFTP solo debe usarse para sesiones SFTP que se han iniciado en conexiones SSH existentes (es decir, cuando el tipo de conexi&amp;oacute;n original es &lt;code&gt;ssh&lt;/code&gt; ). Siempre que el tipo de conexi&amp;oacute;n sea &lt;code&gt;sftp&lt;/code&gt; , utilice &amp;uacute;nicamente la referencia de conexi&amp;oacute;n SSH.</target>
        </trans-unit>
        <trans-unit id="127495432a40845ab9ada867dc7fc2fee4865175" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;SnmpStruct&lt;/code&gt; is a list of SNMP information. Currently, the only information needed is information about the key types in the table. Multiple keys cannot be handled in Mnesia, but many SNMP tables have multiple keys. Therefore, the following convention is used: if a table has multiple keys, these must always be stored as a tuple of the keys. Information about the key types is specified as a tuple of atoms describing the types. The only significant type is &lt;code&gt;fix_string&lt;/code&gt;. This means that a string has a fixed size.</source>
          <target state="translated">El argumento &lt;code&gt;SnmpStruct&lt;/code&gt; es una lista de informaci&amp;oacute;n SNMP. Actualmente, la &amp;uacute;nica informaci&amp;oacute;n necesaria es informaci&amp;oacute;n sobre los tipos de clave en la tabla. No se pueden manejar varias claves en Mnesia, pero muchas tablas SNMP tienen varias claves. Por lo tanto, se utiliza la siguiente convenci&amp;oacute;n: si una tabla tiene varias claves, estas siempre deben almacenarse como una tupla de claves. La informaci&amp;oacute;n sobre los tipos de claves se especifica como una tupla de &amp;aacute;tomos que describen los tipos. El &amp;uacute;nico tipo significativo es &lt;code&gt;fix_string&lt;/code&gt; . Esto significa que una cuerda tiene un tama&amp;ntilde;o fijo.</target>
        </trans-unit>
        <trans-unit id="a39253d131c8288c04fe32704cab33ebdd9b2b8e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;SpawnOpts&lt;/code&gt;, if specified, is passed as the last argument to the &lt;code&gt; spawn_opt/2,3,4,5&lt;/code&gt; BIF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="134ccc578ec25f4a1b41da580e909377b6e00202" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;SpawnOpts&lt;/code&gt;, if specified, is passed as the last argument to the &lt;code&gt;spawn_opt/2,3,4,5&lt;/code&gt; BIF.</source>
          <target state="translated">Argumento &lt;code&gt;SpawnOpts&lt;/code&gt; , si se especifica, se pasa como &amp;uacute;ltimo argumento al &lt;code&gt;spawn_opt/2,3,4,5&lt;/code&gt; BIF.</target>
        </trans-unit>
        <trans-unit id="e3cedb4f6297db65a16db517b2fa86b4c83da9c5" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;State&lt;/code&gt; is a tuple &lt;code&gt;{ShellState,ExprState}&lt;/code&gt;. The return value &lt;code&gt;NewState&lt;/code&gt; has the same form. This can be used to carry a state between calls to the callback functions. Data saved in &lt;code&gt;ShellState&lt;/code&gt; lives through an entire shell session. Data saved in &lt;code&gt;ExprState&lt;/code&gt; lives only through the evaluation of the current expression.</source>
          <target state="translated">Argument &lt;code&gt;State&lt;/code&gt; es una tupla &lt;code&gt;{ShellState,ExprState}&lt;/code&gt; . El valor de retorno &lt;code&gt;NewState&lt;/code&gt; tiene la misma forma. Esto se puede utilizar para llevar un estado entre llamadas a las funciones de devoluci&amp;oacute;n de llamada. Los datos guardados en &lt;code&gt;ShellState&lt;/code&gt; se mantienen durante toda una sesi&amp;oacute;n de shell. Los datos guardados en &lt;code&gt;ExprState&lt;/code&gt; se mantienen &amp;uacute;nicamente mediante la evaluaci&amp;oacute;n de la expresi&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="4b4b0aee165785dc7cf379568e4015cc77271225" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;String&lt;/code&gt; is expected to start with a valid text represented float (the digits are ASCII values). Remaining characters in the string after the float are returned in &lt;code&gt;Rest&lt;/code&gt;.</source>
          <target state="translated">Se espera que Argument &lt;code&gt;String&lt;/code&gt; comience con un texto v&amp;aacute;lido representado como flotante (los d&amp;iacute;gitos son valores ASCII). Los caracteres restantes de la cadena despu&amp;eacute;s del flotante se devuelven en &lt;code&gt;Rest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99bddf0ad5e13463903ca5db19b6f229eaaa62d0" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;String&lt;/code&gt; is expected to start with a valid text represented integer (the digits are ASCII values). Remaining characters in the string after the integer are returned in &lt;code&gt;Rest&lt;/code&gt;.</source>
          <target state="translated">Se espera que la &lt;code&gt;String&lt;/code&gt; argumentos comience con un entero representado por texto v&amp;aacute;lido (los d&amp;iacute;gitos son valores ASCII). Los caracteres restantes en la cadena despu&amp;eacute;s del n&amp;uacute;mero entero se devuelven en &lt;code&gt;Rest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8f022d7270d5362d0771335ef05b9154a045868e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;Type&lt;/code&gt; specifies the type of the application. If omitted, it defaults to &lt;code&gt;temporary&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;Type&lt;/code&gt; argumento especifica el tipo de aplicaci&amp;oacute;n. Si se omite, el valor predeterminado es &lt;code&gt;temporary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1768b3c4a6e503991f26e6f613d8c454009d771" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;caller_env&lt;/code&gt; is the environment of the calling thread (&lt;code&gt;&lt;a href=&quot;#proc_bound_env&quot;&gt;process bound&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#callback_env&quot;&gt;callback&lt;/a&gt;&lt;/code&gt; environment) or &lt;code&gt;NULL&lt;/code&gt; if calling from a custom thread not spawned by ERTS.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52529ec5b3dbe90218521bf7062ae0ba51481ae8" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;event&lt;/code&gt; identifies the event object. On Unix systems, the functions &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; are used. The event object must be a socket, pipe or other file descriptor object that &lt;code&gt;select&lt;/code&gt;/&lt;code&gt;poll&lt;/code&gt; can use.</source>
          <target state="translated">El &lt;code&gt;event&lt;/code&gt; o de argumento identifica el objeto de evento. En los sistemas Unix, se utilizan las funciones &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; . El objeto de evento debe ser un conector, tuber&amp;iacute;a u otro objeto descriptor de archivo que pueda usar &lt;code&gt;select&lt;/code&gt; / &lt;code&gt;poll&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8c82d16dce6414cf83d8d93f8e672741f4d9ca8a" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;event&lt;/code&gt; is not a valid OS event object.</source>
          <target state="translated">El &lt;code&gt;event&lt;/code&gt; o de argumento no es un objeto de evento de SO v&amp;aacute;lido.</target>
        </trans-unit>
        <trans-unit id="7980baebdda9326ef971ef864a7e3442b2b16145" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;index&lt;/code&gt; is updated, that is, this function can be viewed as a decode function that decodes a term into a human-readable format.</source>
          <target state="translated">El &lt;code&gt;index&lt;/code&gt; argumentos se actualiza, es decir, esta funci&amp;oacute;n puede verse como una funci&amp;oacute;n de decodificaci&amp;oacute;n que decodifica un t&amp;eacute;rmino en un formato legible por humanos.</target>
        </trans-unit>
        <trans-unit id="a75ce9ef93d0395faba2903cbdd1f49f30b2929e" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;init&lt;/code&gt; is a pointer to an &lt;code&gt;&lt;a href=&quot;#ErlNifResourceTypeInit&quot;&gt;ErlNifResourceTypeInit&lt;/a&gt;&lt;/code&gt; structure that contains the function pointers for destructor, down and stop callbacks for the resource type.</source>
          <target state="translated">Argument &lt;code&gt;init&lt;/code&gt; es un puntero a una estructura &lt;code&gt;&lt;a href=&quot;#ErlNifResourceTypeInit&quot;&gt;ErlNifResourceTypeInit&lt;/a&gt;&lt;/code&gt; que contiene los punteros de funci&amp;oacute;n para destructor, down y stop callbacks para el tipo de recurso.</target>
        </trans-unit>
        <trans-unit id="01967af65e3bd411e3d849e63161eb2bd650b634" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;mode&lt;/code&gt; describes the type of events to wait for. It can be &lt;code&gt;ERL_NIF_SELECT_READ&lt;/code&gt;, &lt;code&gt;ERL_NIF_SELECT_WRITE&lt;/code&gt; or a bitwise OR combination to wait for both. It can also be &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; or &lt;code&gt;ERL_NIF_SELECT_CANCEL&lt;/code&gt; which are described further below. When a read or write event is triggered, a notification message like this is sent to the process identified by &lt;code&gt;pid&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dfed7a573331b550431a030fa57b0d3e26d11e8" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;mode&lt;/code&gt; describes the type of events to wait for. It can be &lt;code&gt;ERL_NIF_SELECT_READ&lt;/code&gt;, &lt;code&gt;ERL_NIF_SELECT_WRITE&lt;/code&gt; or a bitwise OR combination to wait for both. It can also be &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; which is described further below. When a read or write event is triggered, a notification message like this is sent to the process identified by &lt;code&gt;pid&lt;/code&gt;:</source>
          <target state="translated">El &lt;code&gt;mode&lt;/code&gt; argumento describe el tipo de eventos a esperar. Puede ser &lt;code&gt;ERL_NIF_SELECT_READ&lt;/code&gt; , &lt;code&gt;ERL_NIF_SELECT_WRITE&lt;/code&gt; o una combinaci&amp;oacute;n OR bit a bit para esperar a ambos. Tambi&amp;eacute;n puede ser &lt;code&gt;ERL_NIF_SELECT_STOP&lt;/code&gt; , que se describe m&amp;aacute;s adelante. Cuando se activa un evento de lectura o escritura, se env&amp;iacute;a un mensaje de notificaci&amp;oacute;n como este al proceso identificado por &lt;code&gt;pid&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="070acd6d1707ee826ef0d071afa4c19121b52d79" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;msg_env&lt;/code&gt; must either be &lt;code&gt;NULL&lt;/code&gt; or the environment of &lt;code&gt;msg&lt;/code&gt; allocated with &lt;code&gt;&lt;a href=&quot;#enif_alloc_env&quot;&gt; enif_alloc_env&lt;/a&gt;&lt;/code&gt;. If argument &lt;code&gt;msg_env&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt; the term &lt;code&gt;msg&lt;/code&gt; will be copied, otherwise both &lt;code&gt;msg&lt;/code&gt; and &lt;code&gt;msg_env&lt;/code&gt; will be invalidated by a successful call to &lt;code&gt;enif_select_read&lt;/code&gt; or &lt;code&gt;enif_select_write&lt;/code&gt;. The environment is then to either be freed with &lt;code&gt;&lt;a href=&quot;#enif_free_env&quot;&gt; enif_free_env&lt;/a&gt;&lt;/code&gt; or cleared for reuse with &lt;code&gt;&lt;a href=&quot;#enif_clear_env&quot;&gt;enif_clear_env&lt;/a&gt;&lt;/code&gt;. An unsuccessful call will leave &lt;code&gt;msg&lt;/code&gt; and &lt;code&gt;msg_env&lt;/code&gt; still valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a90058d12d7cac1628a470a0a7fcf5ea024b094" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;obj&lt;/code&gt; is a resource object obtained from &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt;. The purpose of the resource objects is as a container of the event object to manage its state and lifetime. A handle to the resource is received in the notification message as &lt;code&gt;Obj&lt;/code&gt;.</source>
          <target state="translated">El argumento &lt;code&gt;obj&lt;/code&gt; es un objeto de recurso obtenido de &lt;code&gt;&lt;a href=&quot;#enif_alloc_resource&quot;&gt;enif_alloc_resource&lt;/a&gt;&lt;/code&gt; . El prop&amp;oacute;sito de los objetos de recursos es como un contenedor del objeto de evento para administrar su estado y duraci&amp;oacute;n. Se recibe un identificador del recurso en el mensaje de notificaci&amp;oacute;n como &lt;code&gt;Obj&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="946db1924667eb983a11ec1edab5fe1131a72877" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;obj&lt;/code&gt; is pointer to the resource to hold the monitor and &lt;code&gt;*target_pid&lt;/code&gt; identifies the local process to be monitored.</source>
          <target state="translated">El argumento &lt;code&gt;obj&lt;/code&gt; apunta al recurso que contiene el monitor y &lt;code&gt;*target_pid&lt;/code&gt; identifica el proceso local que se va a monitorizar.</target>
        </trans-unit>
        <trans-unit id="759c092e66e225d8bfb0ee95cc9263fb1d2744cd" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;percent&lt;/code&gt; must be an integer between 1 and 100. This function must only be called from a NIF-calling thread, and argument &lt;code&gt;env&lt;/code&gt; must be the environment of the calling process.</source>
          <target state="translated">El &lt;code&gt;percent&lt;/code&gt; argumento debe ser un n&amp;uacute;mero entero entre 1 y 100. Esta funci&amp;oacute;n solo debe llamarse desde un hilo de llamada NIF y el argumento &lt;code&gt;env&lt;/code&gt; debe ser el entorno del proceso de llamada.</target>
        </trans-unit>
        <trans-unit id="f2c2f60e2d8ae32461ae1eadddd46c13583f534f" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;pid&lt;/code&gt; may be &lt;code&gt;NULL&lt;/code&gt; to indicate the calling process.</source>
          <target state="translated">El argumento &lt;code&gt;pid&lt;/code&gt; puede ser &lt;code&gt;NULL&lt;/code&gt; para indicar el proceso de llamada.</target>
        </trans-unit>
        <trans-unit id="ab52346cc79977d26d54307f6e3493efcb89ce4d" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;pid&lt;/code&gt; may be &lt;code&gt;NULL&lt;/code&gt; to indicate the calling process. It must not be set as &lt;code&gt;&lt;a href=&quot;#enif_set_pid_undefined&quot;&gt; undefined&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302f9a8d5949d2f9e3d699e1fadbaaf1fd2728b5" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;ref&lt;/code&gt; must be either a reference obtained from &lt;code&gt;&lt;a href=&quot;erlang#make_ref-0&quot;&gt;erlang:make_ref/0&lt;/a&gt;&lt;/code&gt; or the atom &lt;code&gt;undefined&lt;/code&gt;. It will be passed as &lt;code&gt;Ref&lt;/code&gt; in the notifications. If a selective &lt;code&gt;receive&lt;/code&gt; statement is used to wait for the notification then a reference created just before the &lt;code&gt;receive&lt;/code&gt; will exploit a runtime optimization that bypasses all earlier received messages in the queue.</source>
          <target state="translated">La &lt;code&gt;ref&lt;/code&gt; erencia del argumento debe ser una referencia obtenida de &lt;code&gt;&lt;a href=&quot;erlang#make_ref-0&quot;&gt;erlang:make_ref/0&lt;/a&gt;&lt;/code&gt; o el &amp;aacute;tomo &lt;code&gt;undefined&lt;/code&gt; . Se pasar&amp;aacute; como &lt;code&gt;Ref&lt;/code&gt; en las notificaciones. Si se utiliza una instrucci&amp;oacute;n de &lt;code&gt;receive&lt;/code&gt; selectiva para esperar la notificaci&amp;oacute;n, una referencia creada justo antes de la &lt;code&gt;receive&lt;/code&gt; explotar&amp;aacute; una optimizaci&amp;oacute;n del tiempo de ejecuci&amp;oacute;n que omite todos los mensajes recibidos anteriormente en la cola.</target>
        </trans-unit>
        <trans-unit id="7193c5fbe44de78fcb734160bf05a4992363162d" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;reserved&lt;/code&gt; is intended for future use and is to be ignored.</source>
          <target state="translated">El argumento &lt;code&gt;reserved&lt;/code&gt; est&amp;aacute; destinado a un uso futuro y debe ignorarse.</target>
        </trans-unit>
        <trans-unit id="47a1b242d8b4376bd70073509fcf4806ebd02558" translate="yes" xml:space="preserve">
          <source>Argument &lt;code&gt;to_enc&lt;/code&gt; is ignored. As from Erlang/OTP 20 the encoding is always done in UTF-8 which is readable by nodes as old as Erlang/OTP R16.</source>
          <target state="translated">Se ignora el argumento &lt;code&gt;to_enc&lt;/code&gt; . A partir de Erlang / OTP 20, la codificaci&amp;oacute;n siempre se realiza en UTF-8, que es legible por nodos tan antiguos como Erlang / OTP R16.</target>
        </trans-unit>
        <trans-unit id="b0bce75a84f948b1bdbc76cf38a6245a0d2345b1" translate="yes" xml:space="preserve">
          <source>Argument Types and Invalid Arguments</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="765075133d0be0aa3a9dbc9bcb841e96fb89d790" translate="yes" xml:space="preserve">
          <source>Argument list for the &lt;code&gt;init&lt;/code&gt; function in the callback module.</source>
          <target state="translated">Lista de argumentos para la funci&amp;oacute;n &lt;code&gt;init&lt;/code&gt; en el m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada.</target>
        </trans-unit>
        <trans-unit id="13185c544644b7f2a243ef918a03957be326a36d" translate="yes" xml:space="preserve">
          <source>Argument:</source>
          <target state="translated">Argument:</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="565865945dd4be2b94783c9b5e4f90518f12be80" translate="yes" xml:space="preserve">
          <source>Arguments &lt;code&gt;Format&lt;/code&gt; and &lt;code&gt;Args&lt;/code&gt; are used in a call to &lt;code&gt;io_lib:format/2&lt;/code&gt; to create the comment string. The behavior of &lt;code&gt;comment/2&lt;/code&gt; is otherwise the same as function &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;Format&lt;/code&gt; argumentos y los &lt;code&gt;Args&lt;/code&gt; se utilizan en una llamada a &lt;code&gt;io_lib:format/2&lt;/code&gt; para crear la cadena de comentarios. El comportamiento de &lt;code&gt;comment/2&lt;/code&gt; es el mismo que el de la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#comment-1&quot;&gt;ct:comment/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="a853cd0dac3624d36b7ac915686a7bf9b68613c0" translate="yes" xml:space="preserve">
          <source>Arithmetic bitshift left</source>
          <target state="translated">Desplazamiento de bits aritmético a la izquierda</target>
        </trans-unit>
        <trans-unit id="09257e94fa407278a59602ea81c51ef19d845892" translate="yes" xml:space="preserve">
          <source>Arithmetic bitwise XOR</source>
          <target state="translated">Aritmética bitácora XOR</target>
        </trans-unit>
        <trans-unit id="206db889fe395b01fcd9ea9b88e2747a6dbb4f32" translate="yes" xml:space="preserve">
          <source>Arithmetic expressions</source>
          <target state="translated">Expresiones aritméticas</target>
        </trans-unit>
        <trans-unit id="296f27747464dfd4585fc68aca14b6147fb87a9b" translate="yes" xml:space="preserve">
          <source>Arithmetics: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;rem&lt;/code&gt;</source>
          <target state="translated">Aritm&amp;eacute;tica: &lt;code&gt;+&lt;/code&gt; , &lt;code&gt;-&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;div&lt;/code&gt; , &lt;code&gt;rem&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fdadcc41e499fbe0cbed3e778cd50052fc53c2be" translate="yes" xml:space="preserve">
          <source>Arity ::= Number | &lt;code&gt;-1&lt;/code&gt;</source>
          <target state="translated">Arity :: = N&amp;uacute;mero | &lt;code&gt;-1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1a0d21145500640fd3f6136eeba595bfe934d364" translate="yes" xml:space="preserve">
          <source>Armenian</source>
          <target state="translated">Armenian</target>
        </trans-unit>
        <trans-unit id="6c4709af989db804327c6ea436d6589b124f8253" translate="yes" xml:space="preserve">
          <source>Arranges documents horizontally or vertically, separated by whitespace. Returns a document representing two alternative layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents, such that either all elements in &lt;code&gt;Docs&lt;/code&gt; are concatenated horizontally, and separated by a space character, or all elements are concatenated vertically (without extra separation).</source>
          <target state="translated">Organiza los documentos horizontal o verticalmente, separados por espacios en blanco. Devuelve un documento que representa dos dise&amp;ntilde;os alternativos de la secuencia (no vac&amp;iacute;a) &lt;code&gt;Docs&lt;/code&gt; de documentos, de modo que todos los elementos de &lt;code&gt;Docs&lt;/code&gt; est&amp;aacute;n concatenados horizontalmente y separados por un car&amp;aacute;cter de espacio, o todos los elementos est&amp;aacute;n concatenados verticalmente (sin separaci&amp;oacute;n adicional).</target>
        </trans-unit>
        <trans-unit id="cb6e8bc43bfadc15174aa7c7533ec25e49f627de" translate="yes" xml:space="preserve">
          <source>Arranges documents in a paragraph-like layout. Returns a document representing all possible left-aligned paragraph-like layouts of the (nonempty) sequence &lt;code&gt;Docs&lt;/code&gt; of documents. Elements in &lt;code&gt;Docs&lt;/code&gt; are separated horizontally by a single space character and vertically with a single line break. All lines following the first (if any) are indented to the same left column, whose indentation is specified by the optional &lt;code&gt;Offset&lt;/code&gt; parameter relative to the position of the first element in &lt;code&gt;Docs&lt;/code&gt;. For example, with an offset of -4, the following layout can be produced, for a list of documents representing the numbers 0 to 15:</source>
          <target state="translated">Organiza los documentos en un dise&amp;ntilde;o de p&amp;aacute;rrafo. Devuelve un documento que representa todas las posibles alineado a la izquierda, al igual que el p&amp;aacute;rrafo dise&amp;ntilde;os de la (no vac&amp;iacute;o) de la secuencia &lt;code&gt;Docs&lt;/code&gt; de documentos. Los elementos en &lt;code&gt;Docs&lt;/code&gt; est&amp;aacute;n separados horizontalmente por un car&amp;aacute;cter de espacio &amp;uacute;nico y verticalmente con un solo salto de l&amp;iacute;nea. Todas las l&amp;iacute;neas que siguen a la primera (si las hay) tienen sangr&amp;iacute;a en la misma columna de la izquierda, cuya sangr&amp;iacute;a se especifica mediante el par&amp;aacute;metro de &lt;code&gt;Offset&lt;/code&gt; opcional en relaci&amp;oacute;n con la posici&amp;oacute;n del primer elemento en &lt;code&gt;Docs&lt;/code&gt; . Por ejemplo, con un desplazamiento de -4, se puede producir el siguiente dise&amp;ntilde;o, para una lista de documentos que representan los n&amp;uacute;meros del 0 al 15:</target>
        </trans-unit>
        <trans-unit id="2b0401c5dcd8acaf55fb3e4a1e292be99ca524e1" translate="yes" xml:space="preserve">
          <source>Arrays uses &lt;strong&gt;zero&lt;/strong&gt;-based indexing. This is a deliberate design choice and differs from other Erlang data structures, for example, tuples.</source>
          <target state="translated">Las matrices utilizan indexaci&amp;oacute;n basada en &lt;strong&gt;cero&lt;/strong&gt; . Esta es una elecci&amp;oacute;n de dise&amp;ntilde;o deliberada y difiere de otras estructuras de datos de Erlang, por ejemplo, tuplas.</target>
        </trans-unit>
        <trans-unit id="8daa60e38c87072a49c49928224bef6c12c7e054" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; pero afecta a los programadores de CPU sucios. Por defecto es &lt;code&gt;short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="309dd2054ffb824320663f138850770c829b8b4e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;short&lt;/code&gt;.</source>
          <target state="translated">As &lt;code&gt;&lt;a href=&quot;#+sbwt&quot;&gt;+sbwt&lt;/a&gt;&lt;/code&gt; pero afecta a los programadores de E / S sucios. Por defecto es &lt;code&gt;short&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b3946f390b5828658a54092e42e5c1aeb3b35f2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty CPU schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; pero afecta a los programadores de CPU sucios. Por defecto es &lt;code&gt;medium&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e2e5d1e1ed3c38e858012a446291d2ee5eda343" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; but affects dirty IO schedulers. Defaults to &lt;code&gt;medium&lt;/code&gt;.</source>
          <target state="translated">As &lt;code&gt;&lt;a href=&quot;#+swt&quot;&gt;+swt&lt;/a&gt;&lt;/code&gt; pero afecta a los programadores de E / S sucios. Por defecto es &lt;code&gt;medium&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc32ea3f593b79a1f69eaba316d39f23e652807c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt;, but the atom must exist.</source>
          <target state="translated">Como &lt;code&gt;&lt;a href=&quot;#binary_to_atom-2&quot;&gt;binary_to_atom/2&lt;/a&gt;&lt;/code&gt; , pero el &amp;aacute;tomo debe existir.</target>
        </trans-unit>
        <trans-unit id="ca2f4a2b2d5f93cadaa314fdad3b64d75313bbcf" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#crypto_one_time-5&quot;&gt;crypto_one_time/5&lt;/a&gt;&lt;/code&gt; but for ciphers without IVs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="434cd7266c5993b7f305995750735748f31955d2" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt;, but &lt;code&gt;Subject&lt;/code&gt; is searched until exhausted and a list of all non-overlapping parts matching &lt;code&gt;Pattern&lt;/code&gt; is returned (in order).</source>
          <target state="translated">Como &lt;code&gt;&lt;a href=&quot;#match-2&quot;&gt;match/2&lt;/a&gt;&lt;/code&gt; , pero el &lt;code&gt;Subject&lt;/code&gt; se busca hasta que se agota y se devuelve una lista de todas las partes no superpuestas que coinciden con el &lt;code&gt;Pattern&lt;/code&gt; (en orden).</target>
        </trans-unit>
        <trans-unit id="62392802bcfff15af67682cfdf06f0083a7bb98e" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">Como &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; , pero no env&amp;iacute;a un mensaje de &lt;code&gt;hello&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb9ffdb93aadccde648214772c8fec53159cd3ed" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;, but does not send a &lt;code&gt;hello&lt;/code&gt; message.</source>
          <target state="translated">Como &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; , pero no env&amp;iacute;a un mensaje de &lt;code&gt;hello&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fa21b36059529486327fb112773587da1a9d73d" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;A&lt;/code&gt; and &lt;code&gt;S'&lt;/code&gt; depend only on &lt;code&gt;S&lt;/code&gt; and &lt;code&gt;E&lt;/code&gt;, the kind of state machine described here is a Mealy machine (see, for example, the Wikipedia article &quot;Mealy machine&quot;).</source>
          <target state="translated">Como &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;S'&lt;/code&gt; dependen solo de &lt;code&gt;S&lt;/code&gt; y &lt;code&gt;E&lt;/code&gt; , el tipo de m&amp;aacute;quina de estado que se describe aqu&amp;iacute; es una m&amp;aacute;quina Mealy (ver, por ejemplo, el art&amp;iacute;culo de Wikipedia &quot;M&amp;aacute;quina Mealy&quot;).</target>
        </trans-unit>
        <trans-unit id="b7f0ebcdeb2935048365b1b7688d80f3aa697b38" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;Common Test&lt;/code&gt; always finishes at least the current test case, the time specified with &lt;code&gt;duration&lt;/code&gt; or &lt;code&gt;until&lt;/code&gt; is never definitive.</source>
          <target state="translated">Como &lt;code&gt;Common Test&lt;/code&gt; siempre finaliza al menos el caso de prueba actual, el tiempo especificado con &lt;code&gt;duration&lt;/code&gt; o &lt;code&gt;until&lt;/code&gt; nunca es definitivo.</target>
        </trans-unit>
        <trans-unit id="36e279355dc9b13486eb359a6a271e352bb9ca92" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_list/1&lt;/code&gt;, but returns a list of integers corresponding to the bytes from position &lt;code&gt;Start&lt;/code&gt; to position &lt;code&gt;Stop&lt;/code&gt; in &lt;code&gt;Binary&lt;/code&gt;. The positions in the binary are numbered starting from 1.</source>
          <target state="translated">Como &lt;code&gt;binary_to_list/1&lt;/code&gt; , pero devuelve una lista de enteros correspondientes a los bytes desde la posici&amp;oacute;n &lt;code&gt;Start&lt;/code&gt; a la posici&amp;oacute;n &lt;code&gt;Stop&lt;/code&gt; en &lt;code&gt;Binary&lt;/code&gt; . Las posiciones en el binario se numeran empezando por 1.</target>
        </trans-unit>
        <trans-unit id="356a2faa4b1e013f3d85b59d1af52dcdb569daaf" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;binary_to_term/1&lt;/code&gt;, but takes these options:</source>
          <target state="translated">Como &lt;code&gt;binary_to_term/1&lt;/code&gt; , pero toma estas opciones:</target>
        </trans-unit>
        <trans-unit id="4a20cd1597bfd4ebe1b9bc83959a610632302a2c" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;init_per_testcase&lt;/code&gt; and &lt;code&gt;end_per_testcase&lt;/code&gt; execute on the same Erlang process as the test case, printouts from these configuration functions are included in the test case log file.</source>
          <target state="translated">Como &lt;code&gt;init_per_testcase&lt;/code&gt; y &lt;code&gt;end_per_testcase&lt;/code&gt; se ejecutan en el mismo proceso de Erlang que el caso de prueba, las impresiones de estas funciones de configuraci&amp;oacute;n se incluyen en el archivo de registro del caso de prueba.</target>
        </trans-unit>
        <trans-unit id="077937866e1c72c70b5a0b14cb6e8cc697f67ab6" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;reload/2&lt;/code&gt; waits for the reloading to occur, a misbehaving process keeping open ports to the driver (or keeping the driver loaded) can cause infinite waiting for reload. Time-outs must be provided outside of the process demanding the reload or by using the low-level interface &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; in combination with driver monitors.</source>
          <target state="translated">Mientras &lt;code&gt;reload/2&lt;/code&gt; espera a que ocurra la recarga, un proceso de mal comportamiento que mantiene los puertos abiertos para el controlador (o mantiene el controlador cargado) puede causar una espera infinita para la recarga. Los tiempos de espera deben proporcionarse fuera del proceso que exige la recarga o mediante el uso de la interfaz de bajo nivel &lt;code&gt;&lt;a href=&quot;#try_load-3&quot;&gt;try_load/3&lt;/a&gt;&lt;/code&gt; en combinaci&amp;oacute;n con los monitores del controlador.</target>
        </trans-unit>
        <trans-unit id="35dd6ddae6107d33b10d598d29bb9b8cf8efce75" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;{Unused,Binary}&lt;/code&gt; where &lt;code&gt;Unused&lt;/code&gt; denotes how many trailing zero-bits 0-7 that are unused in the least significant byte in &lt;code&gt;Binary&lt;/code&gt;. This format is accepted as input to the encode functions, and a &lt;code&gt;BIT STRING&lt;/code&gt; is decoded to this format if &lt;code&gt;compact_bit_string&lt;/code&gt; has been given.</source>
          <target state="translated">Como &lt;code&gt;{Unused,Binary}&lt;/code&gt; donde &lt;code&gt;Unused&lt;/code&gt; denota cu&amp;aacute;ntos bits cero finales 0-7 que no se utilizan en el byte menos significativo en &lt;code&gt;Binary&lt;/code&gt; . Este formato se acepta como entrada para las funciones de codificaci&amp;oacute;n, y se decodifica una &lt;code&gt;BIT STRING&lt;/code&gt; a este formato si se ha proporcionado &lt;code&gt;compact_bit_string&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="40263cdf47a643660bd823252e4e54341b4e8e99" translate="yes" xml:space="preserve">
          <source>As Erl_Interface operates on the Erlang external term format, the port must be set to use binaries.</source>
          <target state="translated">Como Erl_Interface opera en el formato de término externo Erlang,el puerto debe estar configurado para usar binarios.</target>
        </trans-unit>
        <trans-unit id="bf5866c25e866f9c6f9b119f63b598360bcc9ad6" translate="yes" xml:space="preserve">
          <source>As Erlang has a fixed number of types, there is no need for a programmer to define a specification for the external format used within some application. All Erlang terms have an external representation and the interpretation of the different terms is application-specific.</source>
          <target state="translated">Como Erlang tiene un número fijo de tipos,no hay necesidad de que un programador defina una especificación para el formato externo utilizado dentro de alguna aplicación.Todos los términos de Erlang tienen una representación externa y la interpretación de los diferentes términos es específica para cada aplicación.</target>
        </trans-unit>
        <trans-unit id="c7e5143ee8610dc021b9a09e083dc533d485e207" translate="yes" xml:space="preserve">
          <source>As a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children do their cleanup in parallel, and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">Como un supervisor &lt;code&gt;simple_one_for_one&lt;/code&gt; puede tener muchos hijos, los cierra a todos de forma asincr&amp;oacute;nica. Esto significa que los ni&amp;ntilde;os hacen su limpieza en paralelo y, por lo tanto, el orden en el que se detienen no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="c2fd4a4764c6e535778fe8db9cbb1523710b87e3" translate="yes" xml:space="preserve">
          <source>As a NIF library is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang (alongside port drivers). Calling NIFs requires no context switches. But it is also the least safe, because a crash in a NIF brings the emulator down too.</source>
          <target state="translated">Como una biblioteca NIF está enlazada dinámicamente al proceso del emulador,es la forma más rápida de llamar al código C desde Erlang (junto con los controladores de puerto).Llamar a los NIF no requiere de conmutadores de contexto.Pero también es la menos segura,porque un fallo en una NIF hace que el emulador se caiga también.</target>
        </trans-unit>
        <trans-unit id="58e7b3f109198992ba59bec647e67726857b68a0" translate="yes" xml:space="preserve">
          <source>As a complement to the &lt;code&gt;set&lt;/code&gt; operation, it is possible to specify a test function. This function has the same syntax as the set operation above, except that the first argument is &lt;code&gt;is_set_ok&lt;/code&gt; instead of &lt;code&gt;set&lt;/code&gt;. This function is called before the variable is set. Its purpose is to ensure that it is permissible to set the variable to the new value.</source>
          <target state="translated">Como complemento a la operaci&amp;oacute;n del &lt;code&gt;set&lt;/code&gt; , es posible especificar una funci&amp;oacute;n de prueba. Esta funci&amp;oacute;n tiene la misma sintaxis que la operaci&amp;oacute;n set anterior, excepto que el primer argumento es &lt;code&gt;is_set_ok&lt;/code&gt; en lugar de &lt;code&gt;set&lt;/code&gt; . Esta funci&amp;oacute;n se llama antes de que se establezca la variable. Su prop&amp;oacute;sito es garantizar que est&amp;eacute; permitido establecer la variable en el nuevo valor.</target>
        </trans-unit>
        <trans-unit id="2948bceb43ecea497f0a445923a501687c512364" translate="yes" xml:space="preserve">
          <source>As a convenient shorthand, if any option settings are required at the start of a non-capturing subpattern, the option letters can appear between &quot;?&quot; and &quot;:&quot;. Thus, the following two patterns match the same set of strings:</source>
          <target state="translated">Como una taquigrafía conveniente,si se requiere alguna configuración de opciones al comienzo de un subpatrón no capturado,las letras de opción pueden aparecer entre &quot;?&quot; y &quot;:&quot;.Así,los dos patrones siguientes coinciden con el mismo conjunto de cadenas:</target>
        </trans-unit>
        <trans-unit id="f6848c0bdaadb93a4b8d51c18e19a86434987f9a" translate="yes" xml:space="preserve">
          <source>As a convention, all I/O servers handle both &lt;code&gt;{setopts, [binary]}&lt;/code&gt;, &lt;code&gt;{setopts, [list]}&lt;/code&gt;, and &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt;, hence the trick with &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; and &lt;code&gt;proplists:unfold/1&lt;/code&gt;. If invalid options are sent to us, we send &lt;code&gt;{error, enotsup}&lt;/code&gt; back to the client.</source>
          <target state="translated">Como convenci&amp;oacute;n, todos los servidores de E / S manejan &lt;code&gt;{setopts, [binary]}&lt;/code&gt; , &lt;code&gt;{setopts, [list]}&lt;/code&gt; , y &lt;code&gt;{setopts,[{binary, boolean()}]}&lt;/code&gt; , de ah&amp;iacute; el truco con &lt;code&gt;proplists:substitute_negations/2&lt;/code&gt; y &lt;code&gt;proplists:unfold/1&lt;/code&gt; . Si se nos env&amp;iacute;an opciones no v&amp;aacute;lidas, enviamos &lt;code&gt;{error, enotsup}&lt;/code&gt; vuelta al cliente.</target>
        </trans-unit>
        <trans-unit id="2a763e7b020b36d9979aba8bffd33d0107367482" translate="yes" xml:space="preserve">
          <source>As a convention, the macro arguments in the head all start with an uppercase letter. In the body, the macro arguments can be expanded by preceding them with &lt;code&gt;$&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="493adbb575cc27e47dde3943edacdea5778a9cf8" translate="yes" xml:space="preserve">
          <source>As a final example we demonstrate the use of &lt;code&gt;driver_async&lt;/code&gt;. We also use the driver term interface. The driver is written in C++. This enables us to use an algorithm from STL. We use the &lt;code&gt;next_permutation&lt;/code&gt; algorithm to get the next permutation of a list of integers. For large lists (&amp;gt; 100,000 elements), this takes some time, so we perform this as an asynchronous task.</source>
          <target state="translated">Como ejemplo final, demostramos el uso de &lt;code&gt;driver_async&lt;/code&gt; . Tambi&amp;eacute;n usamos la interfaz de t&amp;eacute;rminos de controlador. El controlador est&amp;aacute; escrito en C ++. Esto nos permite utilizar un algoritmo de STL. Usamos el algoritmo &lt;code&gt;next_permutation&lt;/code&gt; para obtener la siguiente permutaci&amp;oacute;n de una lista de enteros. Para listas grandes (&amp;gt; 100.000 elementos), esto lleva algo de tiempo, por lo que lo realizamos como una tarea asincr&amp;oacute;nica.</target>
        </trans-unit>
        <trans-unit id="a1f3df7ed28f00795df09b73036126e4e8c30a4d" translate="yes" xml:space="preserve">
          <source>As a hexadecimal number (or an integer). Avoid this as it is easy to misinterpret a &lt;code&gt;BIT STRING&lt;/code&gt; value in this format.</source>
          <target state="translated">Como n&amp;uacute;mero hexadecimal (o entero). Evite esto ya que es f&amp;aacute;cil malinterpretar un valor &lt;code&gt;BIT STRING&lt;/code&gt; en este formato.</target>
        </trans-unit>
        <trans-unit id="7085268ee258ef21d5f659dd9a334d1661d8596c" translate="yes" xml:space="preserve">
          <source>As a last resort, the implementation solely based on the &lt;code&gt;gcc&lt;/code&gt;&lt;code&gt;__sync_*&lt;/code&gt; builtins. This will however cause lots of expensive and unnecessary memory barrier instructions to be issued. That is, performance will suffer. The &lt;code&gt;configure&lt;/code&gt; script will warn at the end of its execution if it cannot find any other alternative than this.</source>
          <target state="translated">Como &amp;uacute;ltimo recurso, la implementaci&amp;oacute;n se basa &amp;uacute;nicamente en los elementos &lt;code&gt;__sync_*&lt;/code&gt; &lt;code&gt;gcc&lt;/code&gt; __sync_ * . Sin embargo, esto har&amp;aacute; que se emitan muchas instrucciones de barrera de memoria costosas e innecesarias. Es decir, el rendimiento se ver&amp;aacute; afectado. El script &lt;code&gt;configure&lt;/code&gt; advertir&amp;aacute; al final de su ejecuci&amp;oacute;n si no puede encontrar otra alternativa que esta.</target>
        </trans-unit>
        <trans-unit id="ebe4b26b3285c31b7e66a15f34435eba521d186d" translate="yes" xml:space="preserve">
          <source>As a match specification can turn on sequential tracing, the combination of &lt;code&gt;dbg&lt;/code&gt; and &lt;code&gt;seq_trace&lt;/code&gt; can be quite powerful. This brief example shows a session where sequential tracing is used:</source>
          <target state="translated">Como una especificaci&amp;oacute;n de coincidencia puede activar el rastreo secuencial, la combinaci&amp;oacute;n de &lt;code&gt;dbg&lt;/code&gt; y &lt;code&gt;seq_trace&lt;/code&gt; puede ser bastante poderosa. Este breve ejemplo muestra una sesi&amp;oacute;n en la que se utiliza el seguimiento secuencial:</target>
        </trans-unit>
        <trans-unit id="57ca2c648144ecb05c83959a4bb6906fc7dba92e" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;add_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">Como parte del procedimiento &lt;code&gt;add_frag&lt;/code&gt; , Mnesia itera sobre todos los fragmentos correspondientes a los n&amp;uacute;meros de &lt;code&gt;IterFrags&lt;/code&gt; y comienza &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; para cada registro. Si el nuevo fragmento difiere del antiguo, el registro se mueve al nuevo fragmento.</target>
        </trans-unit>
        <trans-unit id="afa5aac0272b889e29ab3d3e2445e190b23afd3b" translate="yes" xml:space="preserve">
          <source>As a part of the &lt;code&gt;del_frag&lt;/code&gt; procedure, Mnesia iterates over all fragments corresponding to the &lt;code&gt;IterFrags&lt;/code&gt; numbers and starts &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; for each record. If the new fragment differs from the old fragment, the record is moved to the new fragment.</source>
          <target state="translated">Como parte del procedimiento &lt;code&gt;del_frag&lt;/code&gt; , Mnesia itera sobre todos los fragmentos correspondientes a los n&amp;uacute;meros de &lt;code&gt;IterFrags&lt;/code&gt; y comienza &lt;code&gt;key_to_frag_number(NewState,RecordKey)&lt;/code&gt; para cada registro. Si el nuevo fragmento difiere del antiguo, el registro se mueve al nuevo fragmento.</target>
        </trans-unit>
        <trans-unit id="e1a32b7616ffad81dc2a3990b12ee743d67d1150" translate="yes" xml:space="preserve">
          <source>As a port driver is dynamically linked into the emulator process, this is the fastest way of calling C-code from Erlang. Calling functions in the port driver requires no context switches. But it is also the least safe way, because a crash in the port driver brings the emulator down too.</source>
          <target state="translated">Como el controlador de puerto está enlazado dinámicamente en el proceso del emulador,esta es la forma más rápida de llamar al código C desde Erlang.Las funciones de llamada en el controlador de puerto no requieren interruptores de contexto.Pero también es la forma menos segura,porque un fallo en el controlador de puerto hace que el emulador se caiga también.</target>
        </trans-unit>
        <trans-unit id="67c16b741f04ea5b7b054409fb35ff1c48cb01da" translate="yes" xml:space="preserve">
          <source>As a side effect, the function prints the name of each module it tries to compile. If compilation fails for a module, the make procedure stops and &lt;code&gt;error&lt;/code&gt; is returned.</source>
          <target state="translated">Como efecto secundario, la funci&amp;oacute;n imprime el nombre de cada m&amp;oacute;dulo que intenta compilar. Si la compilaci&amp;oacute;n falla para un m&amp;oacute;dulo, el procedimiento make se detiene y se devuelve un &lt;code&gt;error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bef2be0aff2e7e47dd8199f96ca616049e6fbecf" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;{message, false}&lt;/code&gt; disables sending of trace messages ('call' and 'return_to') for this function call, just like if the match specification had not matched. This can be useful if only the side effects of the &lt;code&gt;MatchBody&lt;/code&gt; part are desired.</source>
          <target state="translated">Como caso especial, &lt;code&gt;{message, false}&lt;/code&gt; inhabilita el env&amp;iacute;o de mensajes de seguimiento ('llamada' y 'return_to') para esta llamada de funci&amp;oacute;n, como si la especificaci&amp;oacute;n de coincidencia no hubiera coincidido. Esto puede ser &amp;uacute;til si solo se desean los efectos secundarios de la parte &lt;code&gt;MatchBody&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc75067c89eb230d3aeaa930304e48d7ffc6b8ce" translate="yes" xml:space="preserve">
          <source>As a special case, drivers can be unloaded from processes that have done no corresponding call to &lt;code&gt;try_load/3&lt;/code&gt; if, and only if, there are &lt;strong&gt;no users of the driver at all&lt;/strong&gt;, which can occur if the process containing the last user dies.</source>
          <target state="translated">Como caso especial, los controladores se pueden descargar de procesos que no han realizado una llamada correspondiente a &lt;code&gt;try_load/3&lt;/code&gt; si, y solo si, no hay &lt;strong&gt;ning&amp;uacute;n usuario del controlador&lt;/strong&gt; , lo que puede ocurrir si el proceso que contiene al &amp;uacute;ltimo usuario muere.</target>
        </trans-unit>
        <trans-unit id="b5a63aa06a92181b3a5ed95aec64c64b4bdd7c17" translate="yes" xml:space="preserve">
          <source>As a special case, the following apply in the &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; parts:</source>
          <target state="translated">Como caso especial, se aplica lo siguiente en las partes &lt;code&gt;MatchCondition/MatchBody&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="03b85735e71929e52331dbf92e7f4188f735f3c7" translate="yes" xml:space="preserve">
          <source>As a test suite runs, all information (including output to &lt;code&gt;stdout&lt;/code&gt;) is recorded in many different log files. A minimum of information is displayed in the user console (only start and stop information, plus a note for each failed test case).</source>
          <target state="translated">A medida que se ejecuta un conjunto de pruebas, toda la informaci&amp;oacute;n (incluida la salida a &lt;code&gt;stdout&lt;/code&gt; ) se registra en muchos archivos de registro diferentes. Se muestra un m&amp;iacute;nimo de informaci&amp;oacute;n en la consola de usuario (solo informaci&amp;oacute;n de inicio y parada, m&amp;aacute;s una nota para cada caso de prueba fallido).</target>
        </trans-unit>
        <trans-unit id="579b2213688012ed19e294f3d42e5b38c477a26a" translate="yes" xml:space="preserve">
          <source>As above but with a descriptive string. The string is currently unused by &lt;code&gt;xref&lt;/code&gt; but other tools can make use of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af27c23232c9332dfe458eed56f4e4ca1c250964" translate="yes" xml:space="preserve">
          <source>As all operations performed by Dets are disk operations, it is important to realize that a single look-up operation involves a series of disk seek and read operations. The Dets functions are therefore much slower than the corresponding &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; functions, although Dets exports a similar interface.</source>
          <target state="translated">Como todas las operaciones realizadas por Dets son operaciones de disco, es importante darse cuenta de que una &amp;uacute;nica operaci&amp;oacute;n de b&amp;uacute;squeda implica una serie de operaciones de b&amp;uacute;squeda y lectura de disco. Por lo tanto, las funciones de Dets son mucho m&amp;aacute;s lentas que las funciones &lt;code&gt;&lt;a href=&quot;ets&quot;&gt;ets(3)&lt;/a&gt;&lt;/code&gt; , aunque Dets exporta una interfaz similar.</target>
        </trans-unit>
        <trans-unit id="eb95848bc99a15bbb0e15871e436bb30c7e336fc" translate="yes" xml:space="preserve">
          <source>As alternative branches are tried from left to right, and options are not reset until the end of the subpattern is reached, an option setting in one branch does affect subsequent branches, so the above patterns match both &quot;SUNDAY&quot; and &quot;Saturday&quot;.</source>
          <target state="translated">Como las ramas alternativas se intentan de izquierda a derecha,y las opciones no se restablecen hasta que se alcanza el final del subpatrón,la configuración de una opción en una rama afecta a las ramas posteriores,por lo que los patrones anteriores coinciden tanto con &quot;DOMINGO&quot; como con &quot;SÁBADO&quot;.</target>
        </trans-unit>
        <trans-unit id="3c01043c234b4ec0c86a33f6ba721a734f751f6e" translate="yes" xml:space="preserve">
          <source>As an alternative to &lt;code&gt;-pa&lt;/code&gt;, if several directories are to be prepended to the code path and the directories have a common parent directory, that parent directory can be specified in environment variable &lt;code&gt;ERL_LIBS&lt;/code&gt;; see &lt;code&gt;code(3)&lt;/code&gt;.</source>
          <target state="translated">Como alternativa a &lt;code&gt;-pa&lt;/code&gt; , si se van a anteponer varios directorios a la ruta del c&amp;oacute;digo y los directorios tienen un directorio principal com&amp;uacute;n, ese directorio principal se puede especificar en la variable de entorno &lt;code&gt;ERL_LIBS&lt;/code&gt; ; ver &lt;code&gt;code(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88dc064e87e4d93064611ba4390a686486fbcb39" translate="yes" xml:space="preserve">
          <source>As an alternative to building a bootscript, you can explicitly add the path to the SSL &lt;code&gt;ebin&lt;/code&gt; directory on the command line. This is done with command-line option &lt;code&gt;-pa&lt;/code&gt;. This works as the SSL application does not need to be started for the distribution to come up, as a clone of the SSL application is hooked into the Kernel application. So, as long as the SSL application code can be reached, the distribution starts. The &lt;code&gt;-pa&lt;/code&gt; method is only recommended for testing purposes.</source>
          <target state="translated">Como alternativa a la creaci&amp;oacute;n de un script de arranque, puede agregar expl&amp;iacute;citamente la ruta al directorio SSL &lt;code&gt;ebin&lt;/code&gt; en la l&amp;iacute;nea de comandos. Esto se hace con la opci&amp;oacute;n de l&amp;iacute;nea de comandos &lt;code&gt;-pa&lt;/code&gt; . Esto funciona ya que no es necesario iniciar la aplicaci&amp;oacute;n SSL para que surja la distribuci&amp;oacute;n, ya que un clon de la aplicaci&amp;oacute;n SSL se conecta a la aplicaci&amp;oacute;n Kernel. Por lo tanto, siempre que se pueda acceder al c&amp;oacute;digo de la aplicaci&amp;oacute;n SSL, comienza la distribuci&amp;oacute;n. El m&amp;eacute;todo &lt;code&gt;-pa&lt;/code&gt; solo se recomienda para realizar pruebas.</target>
        </trans-unit>
        <trans-unit id="99c43706bedf3f37ba2bc1f77eaef7f141bffa35" translate="yes" xml:space="preserve">
          <source>As an alternative to sorting files, a function of one argument can be specified as input. When called with argument &lt;code&gt;read&lt;/code&gt;, the function is assumed to return either of the following:</source>
          <target state="translated">Como alternativa a la clasificaci&amp;oacute;n de archivos, se puede especificar una funci&amp;oacute;n de un argumento como entrada. Cuando se llama con un argumento &lt;code&gt;read&lt;/code&gt; , se supone que la funci&amp;oacute;n devuelve cualquiera de los siguientes:</target>
        </trans-unit>
        <trans-unit id="aa2f69a7cd9917454bfd5b22b175f310f6d2bfae" translate="yes" xml:space="preserve">
          <source>As an alternative to the &lt;code&gt;-callback&lt;/code&gt; and &lt;code&gt;-optional_callbacks&lt;/code&gt; attributes you may directly implement and export &lt;code&gt;behaviour_info()&lt;/code&gt;:</source>
          <target state="translated">Como alternativa a la &lt;code&gt;-callback&lt;/code&gt; y &lt;code&gt;-optional_callbacks&lt;/code&gt; atributos puede aplicar directamente y exportaci&amp;oacute;n &lt;code&gt;behaviour_info()&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c35ac71302602496215802d2ceb07a268d8ab46b" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one and finaly a shell will be started on the host at the other end of the TCP socket.</source>
          <target state="translated">Como alternativa, se podr&amp;iacute;a pasar un socket TCP ya abierto a la funci&amp;oacute;n en &lt;code&gt;TcpSocket&lt;/code&gt; . El inicio y la negociaci&amp;oacute;n de SSH se iniciar&amp;aacute;n en ese y, finalmente, se iniciar&amp;aacute; un shell en el host en el otro extremo del socket TCP.</target>
        </trans-unit>
        <trans-unit id="310627ae72667d56b80e90bfe9262f70c174ac28" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one when an SSH starts at the other end of the TCP socket.</source>
          <target state="translated">Como alternativa, se podr&amp;iacute;a pasar un socket TCP ya abierto a la funci&amp;oacute;n en &lt;code&gt;TcpSocket&lt;/code&gt; . La iniciaci&amp;oacute;n y negociaci&amp;oacute;n de SSH se iniciar&amp;aacute; en ese cuando un SSH comience en el otro extremo del socket TCP.</target>
        </trans-unit>
        <trans-unit id="273b6d8022e0a14e661c5ebb9acfcaf89acecfbc" translate="yes" xml:space="preserve">
          <source>As an alternative, an already open TCP socket could be passed to the function in &lt;code&gt;TcpSocket&lt;/code&gt;. The SSH initiation and negotiation will be initiated on that one with the SSH that should be at the other end.</source>
          <target state="translated">Como alternativa, se podr&amp;iacute;a pasar un socket TCP ya abierto a la funci&amp;oacute;n en &lt;code&gt;TcpSocket&lt;/code&gt; . La iniciaci&amp;oacute;n y negociaci&amp;oacute;n de SSH se iniciar&amp;aacute; en ese con el SSH que deber&amp;iacute;a estar en el otro extremo.</target>
        </trans-unit>
        <trans-unit id="b0d2d299871acdd7ed8b13c9605799bbdca8d746" translate="yes" xml:space="preserve">
          <source>As an example let's add the Diffie-Hellman Group1 first in the kex list. It is supported according to &lt;code&gt;Supported algoritms&lt;/code&gt;.</source>
          <target state="translated">Como ejemplo, agreguemos el Diffie-Hellman Group1 primero en la lista kex. Es compatible de acuerdo con los &lt;code&gt;Supported algoritms&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9fed952b378ed463bdf14ff665fe8061e73af37b" translate="yes" xml:space="preserve">
          <source>As an example of analyzing indirect calls, the following Erlang function tries to answer the question: if we want to know which modules are used indirectly by some module(s), is it worth while using the &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; rather than the module graph? Recall that a module M1 is said to call a module M2 if there is some function in M1 that calls some function in M2. It would be nice if we could use the much smaller module graph, since it is available also in the light weight &lt;code&gt;modules&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; of Xref servers.</source>
          <target state="translated">Como ejemplo de an&amp;aacute;lisis de llamadas indirectas, la siguiente funci&amp;oacute;n de Erlang intenta responder a la pregunta: si queremos saber qu&amp;eacute; m&amp;oacute;dulos utilizan indirectamente algunos m&amp;oacute;dulos, &amp;iquest;vale la pena utilizar el &lt;code&gt;&lt;a href=&quot;xref#call_graph&quot;&gt;function graph&lt;/a&gt;&lt;/code&gt; lugar del gr&amp;aacute;fico de m&amp;oacute;dulos? Recuerde que se dice que un m&amp;oacute;dulo M1 llama a un m&amp;oacute;dulo M2 si hay alguna funci&amp;oacute;n en M1 que llama a alguna funci&amp;oacute;n en M2. Ser&amp;iacute;a bueno si pudi&amp;eacute;ramos usar el gr&amp;aacute;fico de m&amp;oacute;dulo mucho m&amp;aacute;s peque&amp;ntilde;o, ya que est&amp;aacute; disponible tambi&amp;eacute;n en el &lt;code&gt;&lt;a href=&quot;xref#mode&quot;&gt;mode&lt;/a&gt;&lt;/code&gt; de &lt;code&gt;modules&lt;/code&gt; ligeros de los servidores Xref.</target>
        </trans-unit>
        <trans-unit id="c9dcf4f61625ae0867c30f6f2ec1a54ebcaa12ae" translate="yes" xml:space="preserve">
          <source>As an example of how the function can be used, we create an interpreted escript that uses &lt;code&gt;emu_args&lt;/code&gt; to set some emulator flag. In this case, it happens to disable the &lt;code&gt;smp_support&lt;/code&gt;. We also extract the different sections from the newly created script:</source>
          <target state="translated">Como ejemplo de c&amp;oacute;mo se puede usar la funci&amp;oacute;n, creamos un escript interpretado que usa &lt;code&gt;emu_args&lt;/code&gt; para establecer alguna bandera del emulador. En este caso, sucede que deshabilita el &lt;code&gt;smp_support&lt;/code&gt; . Tambi&amp;eacute;n extraemos las diferentes secciones del script reci&amp;eacute;n creado:</target>
        </trans-unit>
        <trans-unit id="93e8253d4bef52c01714100b16613baca9f2eb65" translate="yes" xml:space="preserve">
          <source>As an example of how to use function &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt;, the implementation of a QLC table for the &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; module is given:</source>
          <target state="translated">Como ejemplo de c&amp;oacute;mo usar la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;table/2&lt;/a&gt;&lt;/code&gt; , se da la implementaci&amp;oacute;n de una tabla QLC para el m&amp;oacute;dulo &lt;code&gt;&lt;a href=&quot;gb_trees&quot;&gt;gb_trees&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="d7686e8d3cae0d8b83f082414847869122b1c718" translate="yes" xml:space="preserve">
          <source>As an example of the default behavior, the following call returns, as first and only captured string, the matching part of the subject (&quot;abcd&quot; in the middle) as an index pair &lt;code&gt;{3,4}&lt;/code&gt;, where character positions are zero-based, just as in offsets:</source>
          <target state="translated">Como ejemplo del comportamiento predeterminado, la siguiente llamada devuelve, como primera y &amp;uacute;nica cadena capturada, la parte coincidente del sujeto (&quot;abcd&quot; en el medio) como un par de &amp;iacute;ndices &lt;code&gt;{3,4}&lt;/code&gt; , donde las posiciones de los caracteres son cero- basado, al igual que en compensaciones:</target>
        </trans-unit>
        <trans-unit id="1363c4916ced9b1c12e495d959e392b062a979b7" translate="yes" xml:space="preserve">
          <source>As an example of these rules, suppose you want to write the function &lt;code&gt;select&lt;/code&gt;, which selects certain elements from a list of tuples. Suppose you write &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; with the intention of extracting all tuples from &lt;code&gt;L&lt;/code&gt;, where the first item is &lt;code&gt;X&lt;/code&gt;.</source>
          <target state="translated">Como ejemplo de estas reglas, suponga que desea escribir la funci&amp;oacute;n &lt;code&gt;select&lt;/code&gt; , que selecciona ciertos elementos de una lista de tuplas. Suponga que escribe &lt;code&gt;select(X, L) -&amp;gt; [Y || {X, Y} &amp;lt;- L].&lt;/code&gt; con la intenci&amp;oacute;n de extraer todas las tuplas de &lt;code&gt;L&lt;/code&gt; , en el que el primer elemento es &lt;code&gt;X&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d77fac41d8f6ac13e4c80ca8e1c35a37d97d30a" translate="yes" xml:space="preserve">
          <source>As an example, assume that the old maximum number of files is 10 and that the new maximum number of files is 6. If the current file number is not greater than the new maximum number of files, files 7-10 are removed when file 6 is full and the log starts to write to file number 1 again. Otherwise, the files greater than the current file are removed when the current file is full (for example, if the current file is 8, files 9 and 10 are removed). The files between the new maximum number of files and the current file (that is, files 7 and 8) are removed the next time file 6 is full.</source>
          <target state="translated">Como ejemplo,supongamos que el número máximo de archivos anterior es 10 y que el nuevo número máximo de archivos es 6.Si el número de archivos actual no es mayor que el nuevo número máximo de archivos,los archivos 7-10 se eliminan cuando el archivo 6 está lleno y el registro comienza a escribir de nuevo en el archivo número 1.De lo contrario,los archivos mayores que el archivo actual se eliminan cuando el archivo actual está lleno (por ejemplo,si el archivo actual es 8,los archivos 9 y 10 se eliminan).Los archivos entre el nuevo número máximo de archivos y el archivo actual (es decir,los archivos 7 y 8)se eliminan la próxima vez que el archivo 6 esté lleno.</target>
        </trans-unit>
        <trans-unit id="6df1dd563dff5d559d5237ab7b1799899d2a4427" translate="yes" xml:space="preserve">
          <source>As an example, consider sorting the terms on a disk log file. A function that reads chunks from the disk log and returns a list of binaries is used as input. The results are collected in a list of terms.</source>
          <target state="translated">Como ejemplo,considere la posibilidad de clasificar los términos en un archivo de registro del disco.Una función que lee trozos del registro del disco y devuelve una lista de binarios se utiliza como entrada.Los resultados se recogen en una lista de términos.</target>
        </trans-unit>
        <trans-unit id="9ef05760a87925d5316892398ba7e6735c0cc668" translate="yes" xml:space="preserve">
          <source>As an example, consider the following record definition:</source>
          <target state="translated">Como ejemplo,considérese la siguiente definición de registro:</target>
        </trans-unit>
        <trans-unit id="0bace29d40d7981ee102e27dfe23de3fe372b080" translate="yes" xml:space="preserve">
          <source>As an example, contemplate the issue of converting between upper and lower case letters. Reading the standard makes you realize that there is not a simple one to one mapping in all scripts, for example:</source>
          <target state="translated">Como ejemplo,contemplen la cuestión de la conversión entre mayúsculas y minúsculas.La lectura de la norma hace que te des cuenta de que no hay un simple mapeo uno a uno en todos los guiones,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="625ee0980ab37e0cc8ded0c3288fcfb1cdf01127" translate="yes" xml:space="preserve">
          <source>As an example, let say that we want to send &lt;code&gt;{call, &amp;lt;0.245.2&amp;gt;, {set_get_state, &amp;lt;&amp;lt;0:1024&amp;gt;&amp;gt;}}&lt;/code&gt; to registered process &lt;code&gt;reg&lt;/code&gt; using a fragment size of 128. To send this message we need a distribution header, atom cache updates, the control message (which would be &lt;code&gt;{6, &amp;lt;0.245.2&amp;gt;, [], reg}&lt;/code&gt; in this case) and finally the actual message. This would all be encoded into:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e81b4992cba2b699d381459f734b8216213b6b3" translate="yes" xml:space="preserve">
          <source>As an example, list comprehensions can be used to simplify some of the functions in &lt;code&gt;lists.erl&lt;/code&gt;:</source>
          <target state="translated">Como ejemplo, las listas por comprensi&amp;oacute;n se pueden utilizar para simplificar algunas de las funciones en &lt;code&gt;lists.erl&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="c1e3067854a4c9b6a2c74afda818dcdb334e651b" translate="yes" xml:space="preserve">
          <source>As an example, one can insert an object with &lt;code&gt;integer()&lt;/code&gt;&lt;code&gt;1&lt;/code&gt; as a key in an &lt;code&gt;ordered_set&lt;/code&gt; and get the object returned as a result of doing a &lt;code&gt;lookup/2&lt;/code&gt; with &lt;code&gt;float()&lt;/code&gt;&lt;code&gt;1.0&lt;/code&gt; as the key to search for.</source>
          <target state="translated">Como ejemplo, uno puede insertar un objeto con &lt;code&gt;integer()&lt;/code&gt; &lt;code&gt;1&lt;/code&gt; como clave en un &lt;code&gt;ordered_set&lt;/code&gt; y obtener el objeto devuelto como resultado de hacer una &lt;code&gt;lookup/2&lt;/code&gt; con &lt;code&gt;float()&lt;/code&gt; &lt;code&gt;1.0&lt;/code&gt; como la clave para buscar.</target>
        </trans-unit>
        <trans-unit id="66fc66c449548ea231626daea7c93210ea8cbc49" translate="yes" xml:space="preserve">
          <source>As an example, one can let trace messages be sent over the network to another Erlang node (preferably &lt;strong&gt;not&lt;/strong&gt; distributed), where the formatting occurs:</source>
          <target state="translated">Como ejemplo, se puede permitir que los mensajes de seguimiento se env&amp;iacute;en a trav&amp;eacute;s de la red a otro nodo Erlang (preferiblemente &lt;strong&gt;no&lt;/strong&gt; distribuido), donde ocurre el formateo:</target>
        </trans-unit>
        <trans-unit id="e7c1111ab56bf671a69f40fa390abccb417d88d6" translate="yes" xml:space="preserve">
          <source>As an example, suppose that you want to start a slave node at host &lt;code&gt;H&lt;/code&gt; with node name &lt;code&gt;Name@H&lt;/code&gt; and want the slave node to have the following properties:</source>
          <target state="translated">Como ejemplo, suponga que desea iniciar un nodo esclavo en el host &lt;code&gt;H&lt;/code&gt; con el nombre de nodo &lt;code&gt;Name@H&lt;/code&gt; y desea que el nodo esclavo tenga las siguientes propiedades:</target>
        </trans-unit>
        <trans-unit id="8f6e43ba50d78085627070b9be2ee7833e58261c" translate="yes" xml:space="preserve">
          <source>As an example, the I/O server for the interactive shell (in &lt;code&gt;group.erl&lt;/code&gt;) understands the following options:</source>
          <target state="translated">Como ejemplo, el servidor de E / S para el shell interactivo (en &lt;code&gt;group.erl&lt;/code&gt; ) comprende las siguientes opciones:</target>
        </trans-unit>
        <trans-unit id="c349ed36989168b087d0841f096ffe34418c5158" translate="yes" xml:space="preserve">
          <source>As an example, the following specific instructions cannot be implemented as a combined instruction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d726847c4d6dbe66ba80230721adc5bfacc18e04" translate="yes" xml:space="preserve">
          <source>As an example, we will use the following function, that you may recognise as a slightly modified benchmark function from the manpage file(3):</source>
          <target state="translated">A modo de ejemplo,utilizaremos la siguiente función,que puede reconocerse como una función de referencia ligeramente modificada del archivo de la página de manual(3):</target>
        </trans-unit>
        <trans-unit id="45ffebfcdac0f9d22d4c43b470257bc4c6356264" translate="yes" xml:space="preserve">
          <source>As an optimization this function may also return the port and version of the remote node. If port and version are returned &lt;code&gt;&lt;a href=&quot;#port_please-3&quot;&gt; port_please/3&lt;/a&gt;&lt;/code&gt; will not be called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67171017e640943dfb29d4cbec09fb767fa51114" translate="yes" xml:space="preserve">
          <source>As an snmp adaption usually keeps the index for the whole of the systems lifetime, this is rarely a problem.</source>
          <target state="translated">Como una adaptación de snmp suele mantener el índice durante toda la vida del sistema,esto rara vez es un problema.</target>
        </trans-unit>
        <trans-unit id="319bb3abd29884b1375ba09774a3c06c1a190a13" translate="yes" xml:space="preserve">
          <source>As another example, consider concatenating the answers to two queries &lt;code&gt;QH1&lt;/code&gt; and &lt;code&gt;QH2&lt;/code&gt; while removing all duplicates. This is accomplished by using option &lt;code&gt;unique&lt;/code&gt;:</source>
          <target state="translated">Como otro ejemplo, considere concatenar las respuestas a dos consultas &lt;code&gt;QH1&lt;/code&gt; y &lt;code&gt;QH2&lt;/code&gt; mientras elimina todos los duplicados. Esto se logra utilizando la opci&amp;oacute;n &lt;code&gt;unique&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="002e4414e669ace8432711f4ee7463efc45a9f68" translate="yes" xml:space="preserve">
          <source>As any other type of scripts, Erlang scripts do not work on Unix platforms if the execution bit for the script file is not set. (To turn on the execution bit, use &lt;code&gt;chmod +x script-name&lt;/code&gt;.)</source>
          <target state="translated">Como cualquier otro tipo de scripts, los scripts Erlang no funcionan en plataformas Unix si el bit de ejecuci&amp;oacute;n para el archivo de script no est&amp;aacute; configurado. (Para activar el bit de ejecuci&amp;oacute;n, use &lt;code&gt;chmod +x script-name&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="66b2e146ed4ec9e49f678bedfee3350f88534599" translate="yes" xml:space="preserve">
          <source>As any variable that occurs in the head of a fun is considered a new variable, it is equally valid to write as follows:</source>
          <target state="translated">Como cualquier variable que ocurre en la cabeza de una diversión se considera una nueva variable,es igualmente válido escribir lo siguiente:</target>
        </trans-unit>
        <trans-unit id="90f853228a72190e3c182428d8aa021055665aa1" translate="yes" xml:space="preserve">
          <source>As can be noted above, the parameter list can be matched against a single &lt;code&gt;MatchVariable&lt;/code&gt; or an &lt;code&gt;'_'&lt;/code&gt;. To replace the whole parameter list with a single variable is a special case. In all other cases the &lt;code&gt;MatchHead&lt;/code&gt; must be a &lt;strong&gt;proper&lt;/strong&gt; list.</source>
          <target state="translated">Como se puede observar anteriormente, la lista de par&amp;aacute;metros se puede comparar con una sola &lt;code&gt;MatchVariable&lt;/code&gt; o un &lt;code&gt;'_'&lt;/code&gt; . Reemplazar toda la lista de par&amp;aacute;metros con una sola variable es un caso especial. En todos los dem&amp;aacute;s casos, &lt;code&gt;MatchHead&lt;/code&gt; debe ser una lista &lt;strong&gt;adecuada&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="f45447aff436963dfcba66b79f762faf452d90b1" translate="yes" xml:space="preserve">
          <source>As can be seen from the figures above there is no real difference between a non-reentrant and an reentrant flex scanner when it comes to the decode times of an individual message.</source>
          <target state="translated">Como se puede ver en las cifras anteriores,no hay una diferencia real entre un escáner flexible de no reentrada y uno de reentrada cuando se trata de los tiempos de decodificación de un mensaje individual.</target>
        </trans-unit>
        <trans-unit id="5f43e75c9b3fbee4477b49b641a7fb630b3c13f5" translate="yes" xml:space="preserve">
          <source>As can be seen, the fun used with &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; takes a single list as parameter instead of a single tuple. The list matches a list of the parameters to the traced function. A single variable can also be used. The body of the fun expresses, in a more imperative way, actions to be taken if the fun head (and the guards) matches. &lt;code&gt;true&lt;/code&gt; is returned here, only because the body of a fun cannot be empty. The return value is discarded.</source>
          <target state="translated">Como puede verse, la diversi&amp;oacute;n usada con &lt;code&gt;dbg:fun2ms/1&lt;/code&gt; toma una sola lista como par&amp;aacute;metro en lugar de una sola tupla. La lista hace coincidir una lista de los par&amp;aacute;metros con la funci&amp;oacute;n rastreada. Tambi&amp;eacute;n se puede utilizar una &amp;uacute;nica variable. El cuerpo de la diversi&amp;oacute;n expresa, de una manera m&amp;aacute;s imperativa, las acciones que se deben tomar si la cabeza de la diversi&amp;oacute;n (y los guardias) coinciden. &lt;code&gt;true&lt;/code&gt; se devuelve aqu&amp;iacute;, solo porque el cuerpo de una diversi&amp;oacute;n no puede estar vac&amp;iacute;o. El valor de retorno se descarta.</target>
        </trans-unit>
        <trans-unit id="606f60b3cba3318c2eecb57b2a49a6b6b1a39eb6" translate="yes" xml:space="preserve">
          <source>As can be seen, the functions above are just the type of functions that are to be provided in &lt;code&gt;get_until&lt;/code&gt; requests.</source>
          <target state="translated">Como se puede ver, las funciones anteriores son solo el tipo de funciones que se proporcionar&amp;aacute;n en &lt;code&gt;get_until&lt;/code&gt; solicitudes get_until .</target>
        </trans-unit>
        <trans-unit id="191e8e1e5a9e73a6798b23edb476be7abc2c9de8" translate="yes" xml:space="preserve">
          <source>As default result sets are returned as a lists of tuples. The &lt;code&gt;TupleMode&lt;/code&gt; option still exists to keep some degree of backwards compatibility. If the option is set to off, result sets will be returned as a lists of lists instead of a lists of tuples.</source>
          <target state="translated">De forma predeterminada, los conjuntos de resultados se devuelven como listas de tuplas. La opci&amp;oacute;n &lt;code&gt;TupleMode&lt;/code&gt; todav&amp;iacute;a existe para mantener cierto grado de compatibilidad con versiones anteriores. Si la opci&amp;oacute;n est&amp;aacute; desactivada, los conjuntos de resultados se devolver&amp;aacute;n como listas de listas en lugar de listas de tuplas.</target>
        </trans-unit>
        <trans-unit id="17700b7b2c5191dc7a064a620902163dd840f68f" translate="yes" xml:space="preserve">
          <source>As described in Robert's paper, I/O servers and clients communicate using &lt;code&gt;io_request&lt;/code&gt;/&lt;code&gt;io_reply&lt;/code&gt; tuples as follows:</source>
          <target state="translated">Como se describe en el art&amp;iacute;culo de Robert, los servidores y clientes de E / S se comunican mediante tuplas &lt;code&gt;io_request&lt;/code&gt; / &lt;code&gt;io_reply&lt;/code&gt; de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="d5e4f17183134fe62fa988455bb38a208a7f52d2" translate="yes" xml:space="preserve">
          <source>As documented, the election assumes knowledge of a peer's DiameterIdentity when initiating a connection, which diameter doesn't require. Connections will be accepted if configuration allows multiple connections per peer to be established or there is no existing connection. Note that the election process is only applicable when multiple connections per peer is disallowed.</source>
          <target state="translated">Como se ha documentado,la elección supone el conocimiento de la identidad del diámetro de un par al iniciar una conexión,que no requiere de un diámetro.Las conexiones serán aceptadas si la configuración permite establecer múltiples conexiones por par o si no hay ninguna conexión existente.Tenga en cuenta que el proceso de elección sólo es aplicable cuando se desautorizan las conexiones múltiples por par.</target>
        </trans-unit>
        <trans-unit id="5435f11ff35ae6054509834ff9cbbd3dacb50a82" translate="yes" xml:space="preserve">
          <source>As each event handler is one callback module, an event manager has many callback modules that are added and deleted dynamically. &lt;code&gt;gen_event&lt;/code&gt; is therefore more tolerant of callback module errors than the other behaviors. If a callback function for an installed event handler fails with &lt;code&gt;Reason&lt;/code&gt;, or returns a bad value &lt;code&gt;Term&lt;/code&gt;, the event manager does not fail. It deletes the event handler by calling callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt;, giving as argument &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; or &lt;code&gt;{error,Term}&lt;/code&gt;, respectively. No other event handler is affected.</source>
          <target state="translated">Como cada controlador de eventos es un m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada, un administrador de eventos tiene muchos m&amp;oacute;dulos de devoluci&amp;oacute;n de llamada que se agregan y eliminan de forma din&amp;aacute;mica. &lt;code&gt;gen_event&lt;/code&gt; lo tanto, gen_event es m&amp;aacute;s tolerante a los errores del m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada que los otros comportamientos. Si una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada para un controlador de eventos instalado falla con &lt;code&gt;Reason&lt;/code&gt; o devuelve un &lt;code&gt;Term&lt;/code&gt; valor incorrecto , el administrador de eventos no falla. Elimina el controlador de eventos llamando a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;&lt;a href=&quot;#Module:terminate-2&quot;&gt;Module:terminate/2&lt;/a&gt;&lt;/code&gt; , dando como argumento &lt;code&gt;{error,{'EXIT',Reason}}&lt;/code&gt; o &lt;code&gt;{error,Term}&lt;/code&gt; , respectivamente. Ning&amp;uacute;n otro controlador de eventos se ve afectado.</target>
        </trans-unit>
        <trans-unit id="cf9e38f9c03cb4cfe6ebeed4a9cd9c1754bcff3e" translate="yes" xml:space="preserve">
          <source>As evaluating this function causes the process to terminate, it has no return value unless the arguments are invalid, in which case the function &lt;strong&gt;returns the error reason&lt;/strong&gt;&lt;code&gt;badarg&lt;/code&gt;. If you want to be sure not to return, you can call &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; and hope to distinguish exceptions later.</source>
          <target state="translated">Como la evaluaci&amp;oacute;n de esta funci&amp;oacute;n hace que el proceso termine, no tiene valor de retorno a menos que los argumentos no sean v&amp;aacute;lidos, en cuyo caso la funci&amp;oacute;n &lt;strong&gt;devuelve el motivo del error &lt;/strong&gt; &lt;code&gt;badarg&lt;/code&gt; . Si desea asegurarse de no regresar, puede llamar a &lt;code&gt;error(erlang:raise(Class, Reason, Stacktrace))&lt;/code&gt; y esperar distinguir las excepciones m&amp;aacute;s adelante.</target>
        </trans-unit>
        <trans-unit id="2842aa39be48bf38b0c0560d59180375acac20be" translate="yes" xml:space="preserve">
          <source>As everyone trying to use &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;dbg&lt;/code&gt; seems to end up reading this manual page, this description is an introduction to the concept of match specifications.</source>
          <target state="translated">Como todos los que intentan usar &lt;code&gt;&lt;a href=&quot;ets#select-1&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;dbg&lt;/code&gt; parecen terminar leyendo esta p&amp;aacute;gina de manual, esta descripci&amp;oacute;n es una introducci&amp;oacute;n al concepto de especificaciones de coincidencia.</target>
        </trans-unit>
        <trans-unit id="91ed2cd090a035beba9495ca5c354901e71094c0" translate="yes" xml:space="preserve">
          <source>As expected, double of 10 is 20.</source>
          <target state="translated">Como era de esperar,el doble de 10 es 20.</target>
        </trans-unit>
        <trans-unit id="4e58a012dddf03e3db23dd481662a4b03cf78027" translate="yes" xml:space="preserve">
          <source>As far as we know by the time of writing, it is infeasible to break &lt;code&gt;des3_cbc&lt;/code&gt; encryption without any knowledge of the key. Therefore, as long as the key is kept safe and is unguessable, the encrypted debug information &lt;strong&gt;should&lt;/strong&gt; be safe from intruders.</source>
          <target state="translated">Por lo que sabemos al momento de escribir este art&amp;iacute;culo, no es factible romper el cifrado &lt;code&gt;des3_cbc&lt;/code&gt; sin ning&amp;uacute;n conocimiento de la clave. Por lo tanto, siempre que la clave se mantenga segura y no se pueda adivinar, la informaci&amp;oacute;n de depuraci&amp;oacute;n cifrada &lt;strong&gt;debe&lt;/strong&gt; estar a salvo de intrusos.</target>
        </trans-unit>
        <trans-unit id="9f24794a82149383ffae0568581aa4a52378ab67" translate="yes" xml:space="preserve">
          <source>As file times are stored in POSIX time on most OS, it is faster to query file information with option &lt;code&gt;posix&lt;/code&gt;.</source>
          <target state="translated">Como los tiempos de los archivos se almacenan en tiempo POSIX en la mayor&amp;iacute;a de los sistemas operativos, es m&amp;aacute;s r&amp;aacute;pido consultar la informaci&amp;oacute;n del archivo con la opci&amp;oacute;n &lt;code&gt;posix&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61df7f84fe1d4826c5be72f8b4bc768821e8d381" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;i/1&lt;/code&gt; and &lt;code&gt;ni/1&lt;/code&gt;, a module can be specified by its module name or filename.</source>
          <target state="translated">En cuanto a &lt;code&gt;i/1&lt;/code&gt; y &lt;code&gt;ni/1&lt;/code&gt; , un m&amp;oacute;dulo se puede especificar por su nombre de m&amp;oacute;dulo o nombre de archivo.</target>
        </trans-unit>
        <trans-unit id="3a8f23a48e1867cb7be6b7e031f9615ed3dd2a0d" translate="yes" xml:space="preserve">
          <source>As for &lt;code&gt;select&lt;/code&gt;, the table is traversed by calling &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt;. The difference is that the match specification is explicitly specified. This is how to state match specifications that cannot easily be expressed within the syntax provided by QLC.</source>
          <target state="translated">En cuanto a &lt;code&gt;select&lt;/code&gt; , la tabla se recorre llamando a &lt;code&gt;&lt;a href=&quot;#select-3&quot;&gt;select/3&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#select-1&quot;&gt;select/1&lt;/a&gt;&lt;/code&gt; . La diferencia es que la especificaci&amp;oacute;n de coincidencia se especifica expl&amp;iacute;citamente. As&amp;iacute; es como se establecen las especificaciones de coincidencia que no se pueden expresar f&amp;aacute;cilmente dentro de la sintaxis proporcionada por QLC.</target>
        </trans-unit>
        <trans-unit id="f0387e8c16bce6477d55e9ca9b7e7cb6c002c7dd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.10 all signals from processes to ports are truly asynchronously delivered.</source>
          <target state="translated">A partir de la ERTS 5.10 todas las señales de los procesos a los puertos son verdaderamente asincrónicas.</target>
        </trans-unit>
        <trans-unit id="54e61b5a72122095dbbd0cebf9a23eab4a8e63ab" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt; statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9113f3079af7b202922889fc7baf1985e8c3b0f" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5 (Erlang/OTP R11B), this value does not include reductions performed in current time slices of currently scheduled processes. If an exact value is wanted, use &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">A partir de ERTS 5.5 (Erlang / OTP R11B), este valor no incluye las reducciones realizadas en los intervalos de tiempo actuales de los procesos programados actualmente. Si se desea un valor exacto, utilice &lt;code&gt;&lt;a href=&quot;#statistics_exact_reductions&quot;&gt;statistics(exact_reductions)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c9466fb03b2f8f448def70765eb14302f05b1d4a" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.2 exit signals to processes are truly asynchronously delivered.</source>
          <target state="translated">A partir de la ERTS 5.5.2 las señales de salida a los procesos son verdaderamente asincrónicas.</target>
        </trans-unit>
        <trans-unit id="29adb187efe70ae7ea9eb1516c814ba1bd886f73" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface has been extended (see &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt; extended marker&lt;/a&gt;&lt;/code&gt;). The extended interface introduces &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;, the possibility to pass capability flags (see &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; driver_flags&lt;/a&gt;&lt;/code&gt;) to the runtime system at driver initialization, and some new driver API functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d8b23980173959043ec4b6b8e4640034ae1c36c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface has been extended (see &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt;). The extended interface introduces &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt;, the possibility to pass capability flags (see &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt;) to the runtime system at driver initialization, and some new driver API functions.</source>
          <target state="translated">A partir de ERTS 5.5.3 se ha ampliado la interfaz del conductor (ver &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended marker&lt;/a&gt;&lt;/code&gt; ). La interfaz ampliada introduce la &lt;code&gt;&lt;a href=&quot;#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; , la posibilidad de pasar indicadores de capacidad (consulte &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;driver_flags&lt;/a&gt;&lt;/code&gt; ) al sistema de tiempo de ejecuci&amp;oacute;n en la inicializaci&amp;oacute;n del controlador y algunas funciones nuevas de la API del controlador.</target>
        </trans-unit>
        <trans-unit id="cc982ada8a0ef67bfd186892ad9105718b94c2a0" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface was extended with version control and the possibility to pass capability information. Capability flags are present on line 48. As from ERTS 5.7.4 flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; is required for drivers that are to be used by the distribution. The soft busy flag implies that the driver can handle calls to the &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;outputv&lt;/code&gt; callbacks although it has marked itself as busy. This has always been a requirement on drivers used by the distribution, but no capability information has been available about this previously. For more information. see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt; erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19ca09aeee3e5a4978501284aa2a30557b389ea8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.3 the driver interface was extended with version control and the possibility to pass capability information. Capability flags are present on line 48. As from ERTS 5.7.4 flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; is required for drivers that are to be used by the distribution. The soft busy flag implies that the driver can handle calls to the &lt;code&gt;output&lt;/code&gt; and &lt;code&gt;outputv&lt;/code&gt; callbacks although it has marked itself as busy. This has always been a requirement on drivers used by the distribution, but no capability information has been available about this previously. For more information. see &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">A partir de ERTS 5.5.3, la interfaz del controlador se ampli&amp;oacute; con control de versiones y la posibilidad de pasar informaci&amp;oacute;n de capacidad. Los indicadores de capacidad est&amp;aacute;n presentes en la l&amp;iacute;nea 48. A partir de ERTS 5.7.4, el indicador &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_SOFT_BUSY&lt;/a&gt;&lt;/code&gt; es necesario para los controladores que va a utilizar la distribuci&amp;oacute;n. La bandera ocupado suave implica que el conductor puede manejar las llamadas a la &lt;code&gt;output&lt;/code&gt; y &lt;code&gt;outputv&lt;/code&gt; devoluciones de llamada a pesar de que se ha marcado como ocupado. Esto siempre ha sido un requisito de los controladores utilizados por la distribuci&amp;oacute;n, pero anteriormente no se dispon&amp;iacute;a de informaci&amp;oacute;n sobre la capacidad. Para m&amp;aacute;s informaci&amp;oacute;n. ver &lt;code&gt;&lt;a href=&quot;erl_driver#set_busy_port&quot;&gt;erl_driver:set_busy_port()&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9a78fa09b1376522e4bce196c1fb535907b82e7d" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.5.4.3 the default stack size for threads in the async-thread pool is 16 kilowords, that is, 64 kilobyte on 32-bit architectures. This small default size has been chosen because the amount of async-threads can be quite large. The default stack size is enough for drivers delivered with Erlang/OTP, but is possibly not sufficiently large for other dynamically linked-in drivers that use the &lt;code&gt;driver_async&lt;/code&gt; functionality. A suggested stack size for threads in the async-thread pool can be configured through command-line argument &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">A partir de ERTS 5.5.4.3, el tama&amp;ntilde;o de pila predeterminado para los subprocesos en el grupo de subprocesos as&amp;iacute;ncronos es de 16 kilobytes, es decir, 64 kilobytes en arquitecturas de 32 bits. Se ha elegido este peque&amp;ntilde;o tama&amp;ntilde;o predeterminado porque la cantidad de subprocesos as&amp;iacute;ncronos puede ser bastante grande. El tama&amp;ntilde;o de pila predeterminado es suficiente para los controladores entregados con Erlang / OTP, pero posiblemente no sea lo suficientemente grande para otros controladores vinculados din&amp;aacute;micamente que utilizan la funcionalidad &lt;code&gt;driver_async&lt;/code&gt; . Se puede configurar un tama&amp;ntilde;o de pila sugerido para subprocesos en el grupo de subprocesos as&amp;iacute;ncronos a trav&amp;eacute;s del argumento de l&amp;iacute;nea de comandos &lt;code&gt;&lt;a href=&quot;erl#async_thread_stack_size&quot;&gt;+a&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;erl&quot;&gt;erl(1)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6e9cd2bd7de01214fb3ff560ba3219fdc3a33fd" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.1 the emulator refuses to use this strategy on other allocators than &lt;code&gt;temp_alloc&lt;/code&gt;. This because it only causes problems for other allocators.</source>
          <target state="translated">A partir de ERTS 5.6.1, el emulador se niega a utilizar esta estrategia en otros asignadores que &lt;code&gt;temp_alloc&lt;/code&gt; sean temp_alloc . Esto se debe a que solo causa problemas a otros asignadores.</target>
        </trans-unit>
        <trans-unit id="c9cdb7d3c60a1b802e1be9fa56092fa96daa0110" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/0&lt;/code&gt; requires that all &lt;code&gt;erts_alloc(3)&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">A partir de ERTS 5.6.4, &lt;code&gt;erlang:memory/0&lt;/code&gt; requiere que todos los &lt;code&gt;erts_alloc(3)&lt;/code&gt; est&amp;eacute;n habilitados (comportamiento predeterminado).</target>
        </trans-unit>
        <trans-unit id="0648017001664f8866e87e3887eab6500d7d8d5c" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.6.4, &lt;code&gt;erlang:memory/1&lt;/code&gt; requires that all &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; allocators are enabled (default behavior).</source>
          <target state="translated">A partir de ERTS 5.6.4, &lt;code&gt;erlang:memory/1&lt;/code&gt; requiere que todos los &lt;code&gt;&lt;a href=&quot;erts_alloc&quot;&gt;erts_alloc(3)&lt;/a&gt;&lt;/code&gt; est&amp;eacute;n habilitados (comportamiento predeterminado).</target>
        </trans-unit>
        <trans-unit id="03c3044d6f35884274a0ea9ce93bcb4a6dd2e7b8" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the old atom cache protocol was dropped and a new one was introduced. This protocol introduced the distribution header. Nodes with an ERTS version earlier than 5.7.2 can still communicate with new nodes, but no distribution header and no atom cache are used.</source>
          <target state="translated">A partir de la ERTS 5.7.2 el antiguo protocolo de caché de átomos fue abandonado y se introdujo uno nuevo.Este protocolo introdujo el encabezado de distribución.Los nodos con una versión de ERTS anterior a la 5.7.2 pueden seguir comunicándose con los nuevos nodos,pero no se utilizan ni la cabecera de distribución ni la caché de átomos.</target>
        </trans-unit>
        <trans-unit id="d0bf3fb747dbb4638699932cce5b52da0fd8c732" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.7.2 the runtime system passes a distribution flag in the handshake stage that enables the use of a &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; on all messages passed. Messages passed between nodes have in this case the following format:</source>
          <target state="translated">A partir de ERTS 5.7.2, el sistema de tiempo de ejecuci&amp;oacute;n pasa una bandera de distribuci&amp;oacute;n en la etapa de protocolo de enlace que permite el uso de un &lt;code&gt;&lt;a href=&quot;erl_ext_dist#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; en todos los mensajes transmitidos. Los mensajes que se pasan entre nodos tienen en este caso el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="1259b645a71eafd28a440edcc0bee42c289d29ad" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with larger types for the callbacks &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;. See driver &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt; version management&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32ca42b8d63db763c29dc94fc4d01b222bd06006" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the driver interface has been changed with larger types for the callbacks &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt;. See driver &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">A partir de ERTS 5.9 (Erlang / OTP R15B), la interfaz del controlador se ha cambiado con tipos m&amp;aacute;s grandes para la &lt;code&gt;&lt;a href=&quot;#output&quot;&gt;output&lt;/a&gt;&lt;/code&gt; , el &lt;code&gt;&lt;a href=&quot;#control&quot;&gt;control&lt;/a&gt;&lt;/code&gt; y la llamada de las devoluciones de &lt;code&gt;&lt;a href=&quot;#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; . Consulte la &lt;code&gt;&lt;a href=&quot;erl_driver#version_management&quot;&gt;version management&lt;/a&gt;&lt;/code&gt; controlador en &lt;code&gt;&lt;a href=&quot;erl_driver&quot;&gt;erl_driver&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ed0ea6cc1d812d63e5d244adc339b28e36e76666" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 (Erlang/OTP R15B) the runtime system does by default &lt;strong&gt;not&lt;/strong&gt; bind schedulers to logical processors. For more information, see system flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">A partir de ERTS 5.9 (Erlang / OTP R15B), el sistema de ejecuci&amp;oacute;n &lt;strong&gt;no&lt;/strong&gt; vincula de forma predeterminada a los programadores con los procesadores l&amp;oacute;gicos. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte system flag &lt;code&gt;&lt;a href=&quot;#+sbt&quot;&gt;+sbt&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8eaab9a3708d0c05a100d946be7959ae31e3845a" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 old drivers must be recompiled and use the extended interface. They must also be adjusted to the &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt; 64-bit capable driver interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90a69eabde7b774111db809b2a3f8cd2e6d93bb9" translate="yes" xml:space="preserve">
          <source>As from ERTS 5.9 old drivers must be recompiled and use the extended interface. They must also be adjusted to the &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">A partir de ERTS 5.9, los controladores antiguos deben recompilarse y utilizar la interfaz ampliada. Tambi&amp;eacute;n deben ajustarse a la &lt;code&gt;&lt;a href=&quot;#rewrites_for_64_bits&quot;&gt;64-bit capable driver interface&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d18bc1c72ccf3f56d64803c503d7a9ae14a8c4e0" translate="yes" xml:space="preserve">
          <source>As from ERTS 8.0 (Erlang/OTP 19), any lingering processes that still execute the old code is killed by this function. In earlier versions, such incorrect use could cause much more fatal failures, like emulator crash.</source>
          <target state="translated">A partir de ERTS 8.0 (Erlang/OTP 19),cualquier proceso que siga ejecutando el código antiguo es eliminado por esta función.En versiones anteriores,este uso incorrecto podía causar fallos mucho más fatales,como la caída del emulador.</target>
        </trans-unit>
        <trans-unit id="eaa0884ce96d8d06eafbfe246ea264efc463f164" translate="yes" xml:space="preserve">
          <source>As from ERTS 9.0 (OTP 20), atoms may contain any Unicode characters and are always encoded using the UTF-8 external formats &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt;. The old Latin-1 formats &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; are deprecated and are only kept for backward compatibility when decoding terms encoded by older nodes.</source>
          <target state="translated">A partir de ERTS 9.0 (OTP 20), los &amp;aacute;tomos pueden contener cualquier car&amp;aacute;cter Unicode y siempre se codifican utilizando los formatos externos UTF-8 &lt;code&gt;&lt;a href=&quot;#ATOM_UTF8_EXT&quot;&gt;ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_UTF8_EXT&quot;&gt;SMALL_ATOM_UTF8_EXT&lt;/a&gt;&lt;/code&gt; . Los antiguos formatos Latin-1 &lt;code&gt;&lt;a href=&quot;#ATOM_EXT&quot;&gt;ATOM_EXT&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#SMALL_ATOM_EXT&quot;&gt;SMALL_ATOM_EXT&lt;/a&gt;&lt;/code&gt; est&amp;aacute;n obsoletos y solo se conservan por compatibilidad con versiones anteriores al decodificar t&amp;eacute;rminos codificados por nodos m&amp;aacute;s antiguos.</target>
        </trans-unit>
        <trans-unit id="c56c4f98abd4a60cd0f47b8e3c9a0926a671f166" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No &lt;code&gt;erlang:system_info()&lt;/code&gt; argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in &lt;code&gt; System principles&lt;/code&gt; in System Documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="432b2e5b8c0948df031dfa90355327eda74cb917" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 17, the OTP release number corresponds to the major OTP version number. No &lt;code&gt;erlang:system_info()&lt;/code&gt; argument gives the exact OTP version. This is because the exact OTP version in the general case is difficult to determine. For more information, see the description of versions in &lt;code&gt;System principles&lt;/code&gt; in System Documentation.</source>
          <target state="translated">A partir de Erlang / OTP 17, el n&amp;uacute;mero de versi&amp;oacute;n de OTP corresponde al n&amp;uacute;mero de versi&amp;oacute;n principal de OTP. Sin &lt;code&gt;erlang:system_info()&lt;/code&gt; argumento da la versi&amp;oacute;n exacta OTP. Esto se debe a que la versi&amp;oacute;n exacta de OTP en el caso general es dif&amp;iacute;cil de determinar. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la descripci&amp;oacute;n de las versiones en &lt;code&gt;System principles&lt;/code&gt; sistema en Documentaci&amp;oacute;n del sistema.</target>
        </trans-unit>
        <trans-unit id="a73c626964af738d0bf5772ed44b01c65f1937d2" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 18 (ERTS 7.0) the time functionality has been extended. This includes a &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; for time and &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; that change the system behavior when system time changes.</source>
          <target state="translated">A partir de Erlang / OTP 18 (ERTS 7.0) se ha ampliado la funcionalidad de tiempo. Esto incluye una &lt;code&gt;&lt;a href=&quot;#The_New_Time_API&quot;&gt;new API&lt;/a&gt;&lt;/code&gt; para los &lt;code&gt;&lt;a href=&quot;#Time_Warp_Modes&quot;&gt;time warp modes&lt;/a&gt;&lt;/code&gt; time y time warp que cambian el comportamiento del sistema cuando cambia la hora del sistema.</target>
        </trans-unit>
        <trans-unit id="ecb4c90c54fe542574fe5a3d1dc6ac0bee28192e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;String&lt;/code&gt; may contain any Unicode character. Earlier versions allowed only ISO-latin-1 characters as the implementation did not allow Unicode characters above 255. For more information on Unicode support in atoms, see &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">A partir de Erlang / OTP 20, &lt;code&gt;String&lt;/code&gt; puede contener cualquier car&amp;aacute;cter Unicode. Las versiones anteriores solo permit&amp;iacute;an caracteres ISO-latin-1 ya que la implementaci&amp;oacute;n no permit&amp;iacute;a caracteres Unicode por encima de 255. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la compatibilidad con Unicode en &amp;aacute;tomos, consulte la &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; en la secci&amp;oacute;n &quot;Formato de t&amp;eacute;rmino externo&quot; en la Gu&amp;iacute;a del usuario.</target>
        </trans-unit>
        <trans-unit id="a96169a26804822b5af1efdb6e68b574110fb9b3" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; is capable of encoding any Unicode character. Earlier versions would fail if the binary contained Unicode characters &amp;gt; 255. For more information about Unicode support in atoms, see the &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; in section &quot;External Term Format&quot; in the User's Guide.</source>
          <target state="translated">A partir de Erlang / OTP 20, &lt;code&gt;binary_to_atom(Binary, utf8)&lt;/code&gt; es capaz de codificar cualquier car&amp;aacute;cter Unicode. Las versiones anteriores fallar&amp;iacute;an si el binario conten&amp;iacute;a caracteres Unicode&amp;gt; 255. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la compatibilidad con Unicode en &amp;aacute;tomos, consulte la &lt;code&gt;&lt;a href=&quot;erl_ext_dist#utf8_atoms&quot;&gt;note on UTF-8 encoded atoms&lt;/a&gt;&lt;/code&gt; en la secci&amp;oacute;n &quot;Formato de t&amp;eacute;rmino externo&quot; en la Gu&amp;iacute;a del usuario.</target>
        </trans-unit>
        <trans-unit id="880a395a4cc835daf564a6c2cb8b779237ad447e" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 20, atoms can contain any Unicode character and &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; may fail if the text representation for &lt;code&gt;Atom&lt;/code&gt; contains a Unicode character &amp;gt; 255.</source>
          <target state="translated">A partir de Erlang / OTP 20, los &amp;aacute;tomos pueden contener cualquier car&amp;aacute;cter Unicode y &lt;code&gt;atom_to_binary(Atom, latin1)&lt;/code&gt; puede fallar si la representaci&amp;oacute;n de texto de &lt;code&gt;Atom&lt;/code&gt; contiene un car&amp;aacute;cter Unicode&amp;gt; 255.</target>
        </trans-unit>
        <trans-unit id="05e99f10299c611eb38d2e60ef290380c488aab4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP 21.0, a field width of value &lt;code&gt;0&lt;/code&gt; can be used for specifying that a line is infinitely long, which means that no line breaks are inserted. For example:</source>
          <target state="translated">A partir de Erlang / OTP 21.0, se puede utilizar un ancho de campo de valor &lt;code&gt;0&lt;/code&gt; para especificar que una l&amp;iacute;nea es infinitamente larga, lo que significa que no se insertan saltos de l&amp;iacute;nea. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="634c1d87386aa4426d0d529b4d45ffef570a789c" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R13A, data supplied to function &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; is to be in the &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt; unicode:chardata()&lt;/a&gt;&lt;/code&gt; format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="201cedcfe08f8b8dd67e3f18b939fb9656e57837" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R13A, data supplied to function &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; is to be in the &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; format. This means that programs supplying binaries to this function must convert them to UTF-8 before trying to output the data on an I/O device.</source>
          <target state="translated">A partir de Erlang / OTP R13A, los datos suministrados a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#put_chars-2&quot;&gt;put_chars/2&lt;/a&gt;&lt;/code&gt; deben estar en formato &lt;code&gt;&lt;a href=&quot;unicode#type-chardata&quot;&gt;unicode:chardata()&lt;/a&gt;&lt;/code&gt; . Esto significa que los programas que suministran binarios a esta funci&amp;oacute;n deben convertirlos a UTF-8 antes de intentar enviar los datos a un dispositivo de E / S.</target>
        </trans-unit>
        <trans-unit id="d33e90079df692505b294a1290c3639aac4d952d" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_close/1&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">A partir de Erlang / OTP R16, &lt;code&gt;Port ! {PortOwner, close}&lt;/code&gt; es verdaderamente asincr&amp;oacute;nico. Tenga en cuenta que esta operaci&amp;oacute;n siempre se ha documentado como una operaci&amp;oacute;n asincr&amp;oacute;nica, mientras que la implementaci&amp;oacute;n subyacente ha sido sincr&amp;oacute;nica. &lt;code&gt;port_close/1&lt;/code&gt; , sin embargo, sigue siendo completamente s&amp;iacute;ncrono debido a su comportamiento de error.</target>
        </trans-unit>
        <trans-unit id="847e19f07a1da0af86460018529c6ed10c09d277" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_command/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">A partir de Erlang / OTP R16, &lt;code&gt;Port ! {PortOwner, {command, Data}}&lt;/code&gt; es verdaderamente asincr&amp;oacute;nico. Tenga en cuenta que esta operaci&amp;oacute;n siempre se ha documentado como una operaci&amp;oacute;n asincr&amp;oacute;nica, mientras que la implementaci&amp;oacute;n subyacente ha sido sincr&amp;oacute;nica. &lt;code&gt;port_command/2&lt;/code&gt; , sin embargo, sigue siendo completamente s&amp;iacute;ncrono debido a su comportamiento de error.</target>
        </trans-unit>
        <trans-unit id="5ca95bf5c29d60d3f435edb308337e14ca27dfa7" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; is truly asynchronous. Notice that this operation has always been documented as an asynchronous operation, while the underlying implementation has been synchronous. &lt;code&gt;port_connect/2&lt;/code&gt; is however still fully synchronous because of its error behavior.</source>
          <target state="translated">A partir de Erlang / OTP R16, &lt;code&gt;Port ! {PortOwner, {connect, Pid}}&lt;/code&gt; es verdaderamente asincr&amp;oacute;nico. Tenga en cuenta que esta operaci&amp;oacute;n siempre se ha documentado como una operaci&amp;oacute;n asincr&amp;oacute;nica, mientras que la implementaci&amp;oacute;n subyacente ha sido sincr&amp;oacute;nica. &lt;code&gt;port_connect/2&lt;/code&gt; , sin embargo, sigue siendo completamente s&amp;iacute;ncrono debido a su comportamiento de error.</target>
        </trans-unit>
        <trans-unit id="72f6bdc7a49b76220d72f254a24c40ac2103b81f" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16, Erlang source files can be written in UTF-8 or bytewise (&lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt;) encoding. For information about how to state the encoding of an Erlang source file, see the &lt;code&gt;epp(3)&lt;/code&gt; module. As from Erlang/OTP R16, strings and comments can be written using Unicode. As from Erlang/OTP 20, also atoms and functions can be written using Unicode. Modules, applications, and nodes must still be named using characters from the ISO Latin-1 character set. (These restrictions in the language are independent of the encoding of the source file.)</source>
          <target state="translated">A partir de Erlang / OTP R16, archivos de origen Erlang pueden ser escritos en UTF-8 o byte a byte ( &lt;code id=&quot;unicode_in_erlang&quot;&gt;latin1&lt;/code&gt; ) de codificaci&amp;oacute;n. Para obtener informaci&amp;oacute;n sobre c&amp;oacute;mo indicar la codificaci&amp;oacute;n de un archivo fuente de Erlang, consulte el m&amp;oacute;dulo &lt;code&gt;epp(3)&lt;/code&gt; . A partir de Erlang / OTP R16, las cadenas y los comentarios se pueden escribir utilizando Unicode. A partir de Erlang / OTP 20, tambi&amp;eacute;n se pueden escribir &amp;aacute;tomos y funciones utilizando Unicode. Los m&amp;oacute;dulos, las aplicaciones y los nodos a&amp;uacute;n deben tener nombres con caracteres del conjunto de caracteres ISO Latin-1. (Estas restricciones en el idioma son independientes de la codificaci&amp;oacute;n del archivo fuente).</target>
        </trans-unit>
        <trans-unit id="7886b46a773db0e50442aecaebbaf32b222b9fd4" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R16B you can select the ISO Latin-1 range or the whole Unicode range by supplying startup flag &lt;code&gt;+pc latin1&lt;/code&gt; or &lt;code&gt;+pc unicode&lt;/code&gt;, respectively. For backward compatibility, &lt;code&gt;latin1&lt;/code&gt; is default. This only controls how heuristic string detection is done. More ranges are expected to be added in the future, enabling tailoring of the heuristics to the language and region relevant to the user.</source>
          <target state="translated">A partir de Erlang / OTP R16B, puede seleccionar el rango ISO Latin-1 o todo el rango Unicode proporcionando la bandera de inicio &lt;code&gt;+pc latin1&lt;/code&gt; o &lt;code&gt;+pc unicode&lt;/code&gt; , respectivamente. Para compatibilidad con versiones anteriores, &lt;code&gt;latin1&lt;/code&gt; es el predeterminado. Esto solo controla c&amp;oacute;mo se realiza la detecci&amp;oacute;n de cadenas heur&amp;iacute;sticas. Se espera que se agreguen m&amp;aacute;s rangos en el futuro, lo que permitir&amp;aacute; adaptar la heur&amp;iacute;stica al idioma y la regi&amp;oacute;n relevantes para el usuario.</target>
        </trans-unit>
        <trans-unit id="716bfb66439cef7ad7bad31829606da528f05b26" translate="yes" xml:space="preserve">
          <source>As from Erlang/OTP R9C, the &lt;code&gt;abstract_code&lt;/code&gt; chunk contains &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt;, where &lt;code&gt;AbstractCode&lt;/code&gt; is the abstract code as described in this section.</source>
          <target state="translated">A partir de Erlang / OTP R9C, el fragmento &lt;code&gt;abstract_code&lt;/code&gt; contiene &lt;code&gt;{raw_abstract_v1,AbstractCode}&lt;/code&gt; , donde &lt;code&gt;AbstractCode&lt;/code&gt; es el c&amp;oacute;digo abstracto como se describe en esta secci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="79439af412211da1e82f500e663913d9e02afa8d" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, and ERTS version 5.5.4, the following is guaranteed:</source>
          <target state="translated">A partir de la versión 2.11.4 del núcleo y de la versión 5.5.4 de ERTS,se garantiza lo siguiente:</target>
        </trans-unit>
        <trans-unit id="e6086f606b9a19f3992ba56f0349c22f46bc841b" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.11.4, subscriptions can also be made before the &lt;code&gt;net_kernel&lt;/code&gt; server is started, that is, &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; does not return &lt;code&gt;ignored&lt;/code&gt;.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 2.11.4 del Kernel, las suscripciones tambi&amp;eacute;n se pueden realizar antes de que se &lt;code&gt;net_kernel&lt;/code&gt; servidor net_kernel , es decir, &lt;code&gt;net_kernel:monitor_nodes/[1,2]&lt;/code&gt; no regresa &lt;code&gt;ignored&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a12edcd68388680c33d418efadc851c1c0e7b367" translate="yes" xml:space="preserve">
          <source>As from Kernel version 2.13, and ERTS version 5.7, the following is guaranteed:</source>
          <target state="translated">A partir de la versión 2.13 del núcleo y de la versión 5.7 de ERTS,se garantiza lo siguiente:</target>
        </trans-unit>
        <trans-unit id="2c683a693696d1ac1e9f3a076bd2cf07e0602bc8" translate="yes" xml:space="preserve">
          <source>As from R14A and forward, the compiler resolves calls without module prefix to local or imported functions before trying with auto-imported BIFs. If the BIF is to be called, use the &lt;code&gt;erlang&lt;/code&gt; module prefix in the call, not &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt;.</source>
          <target state="translated">A partir de R14A en adelante, el compilador resuelve las llamadas sin prefijo de m&amp;oacute;dulo a funciones locales o importadas antes de intentarlo con BIF importados autom&amp;aacute;ticamente. Si se va a llamar al BIF, use el prefijo del m&amp;oacute;dulo &lt;code&gt;erlang&lt;/code&gt; en la llamada, no &lt;code&gt;{no_auto_import,[{F,A}, ...]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="23bc1a56d40682c98cebd327d476b5499f2bfa45" translate="yes" xml:space="preserve">
          <source>As from beginning with R14A, the compiler no longer calls the auto-imported BIF if the name clashes with a local or explicitly imported function, and a call without explicit module name is issued. Instead, the local or imported function is called. Still accepting &lt;code&gt;nowarn_bif_clash&lt;/code&gt; would make a module calling functions clashing with auto-imported BIFs compile with both the old and new compilers, but with completely different semantics. This is why the option is removed.</source>
          <target state="translated">A partir de R14A, el compilador ya no llama al BIF importado autom&amp;aacute;ticamente si el nombre choca con una funci&amp;oacute;n local o importada expl&amp;iacute;citamente, y se emite una llamada sin un nombre de m&amp;oacute;dulo expl&amp;iacute;cito. En su lugar, se llama a la funci&amp;oacute;n local o importada. Si todav&amp;iacute;a se acepta &lt;code&gt;nowarn_bif_clash&lt;/code&gt; , las funciones de llamada de un m&amp;oacute;dulo que chocan con los BIF importados autom&amp;aacute;ticamente se compilan con los compiladores nuevos y antiguos, pero con una sem&amp;aacute;ntica completamente diferente. Por eso se elimina la opci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8624ad0f786ca708e353d31a82300424a2da173c" translate="yes" xml:space="preserve">
          <source>As functions are relations, the definitions of the last item (domain, range, and so on) apply to functions as well.</source>
          <target state="translated">Como las funciones son relaciones,las definiciones del último elemento (dominio,rango,etc.)se aplican también a las funciones.</target>
        </trans-unit>
        <trans-unit id="07695f74f1c383a64bbc45b6016faa64c5986911" translate="yes" xml:space="preserve">
          <source>As illustrated, properties can be combined. If, for example, &lt;code&gt;shuffle&lt;/code&gt;, &lt;code&gt;repeat_until_any_fail&lt;/code&gt;, and &lt;code&gt;sequence&lt;/code&gt; are all specified, the test cases in the group are executed repeatedly, and in random order, until a test case fails. Then execution is immediately stopped and the remaining cases are skipped.</source>
          <target state="translated">Como se ilustra, las propiedades se pueden combinar. Si, por ejemplo, se especifican &lt;code&gt;shuffle&lt;/code&gt; , &lt;code&gt;repeat_until_any_fail&lt;/code&gt; y &lt;code&gt;sequence&lt;/code&gt; , los casos de prueba del grupo se ejecutan repetidamente y en orden aleatorio, hasta que falla un caso de prueba. Luego, la ejecuci&amp;oacute;n se detiene inmediatamente y se omiten los casos restantes.</target>
        </trans-unit>
        <trans-unit id="68fe7148f0f6ccc13bf1a24fdc690584b0a600f5" translate="yes" xml:space="preserve">
          <source>As illustrated, the two directories reside on different nodes, because &lt;code&gt;/ldisc/scratch&lt;/code&gt; (the &quot;local&quot; disc) exists on the two different nodes.</source>
          <target state="translated">Como se ilustra, los dos directorios residen en nodos diferentes, porque &lt;code&gt;/ldisc/scratch&lt;/code&gt; (el disco &quot;local&quot;) existe en los dos nodos diferentes.</target>
        </trans-unit>
        <trans-unit id="b2998e8a048230bd280f5294610d17bc1bd53ffb" translate="yes" xml:space="preserve">
          <source>As in &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to be specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">Como en &lt;code&gt;&lt;a href=&quot;#run-3&quot;&gt;run/3&lt;/a&gt;&lt;/code&gt; , un &lt;code&gt;mp()&lt;/code&gt; compilado con la opci&amp;oacute;n &lt;code&gt;unicode&lt;/code&gt; requiere que &lt;code&gt;Subject&lt;/code&gt; sea ​​un &lt;code&gt;charlist()&lt;/code&gt; Unicode . Si la compilaci&amp;oacute;n se realiza impl&amp;iacute;citamente y se especifica la opci&amp;oacute;n de compilaci&amp;oacute;n &lt;code&gt;unicode&lt;/code&gt; para esta funci&amp;oacute;n, tanto la expresi&amp;oacute;n regular como el &lt;code&gt;Subject&lt;/code&gt; deben especificarse como &lt;code&gt;charlist()&lt;/code&gt; Unicode v&amp;aacute;lidas .</target>
        </trans-unit>
        <trans-unit id="466e0ad8d0c7cbd5f38b33d59e9622626664550d" translate="yes" xml:space="preserve">
          <source>As in Erlang, messages can be sent to a pid or to a registered name. It is easier to send a message to a registered name, as it avoids the problem of finding a suitable pid.</source>
          <target state="translated">Como en Erlang,los mensajes pueden ser enviados a un pid o a un nombre registrado.Es más fácil enviar un mensaje a un nombre registrado,ya que evita el problema de encontrar un pid adecuado.</target>
        </trans-unit>
        <trans-unit id="a4d88e181201a03cc3fb7ded4e3d176b1c280bd5" translate="yes" xml:space="preserve">
          <source>As in construction, the order in which the key and value expressions are evaluated is not defined. The syntactic order of the key-value pairs in the update is of no relevance, except in the case where two keys match. In that case, the latter value is used.</source>
          <target state="translated">Al igual que en la construcción,no se define el orden en que se evalúan las expresiones clave y de valor.El orden sintáctico de los pares clave-valor en la actualización no tiene relevancia,excepto en el caso de que dos claves coincidan.En ese caso,se utiliza este último valor.</target>
        </trans-unit>
        <trans-unit id="bc2ecf4ab7dc9e0eae158ae04299a70b115b03c8" translate="yes" xml:space="preserve">
          <source>As in function &lt;code&gt;run/3&lt;/code&gt;, an &lt;code&gt;mp()&lt;/code&gt; compiled with option &lt;code&gt;unicode&lt;/code&gt; requires &lt;code&gt;Subject&lt;/code&gt; to be a Unicode &lt;code&gt;charlist()&lt;/code&gt;. If compilation is done implicitly and the &lt;code&gt;unicode&lt;/code&gt; compilation option is specified to this function, both the regular expression and &lt;code&gt;Subject&lt;/code&gt; are to specified as valid Unicode &lt;code&gt;charlist()&lt;/code&gt;s.</source>
          <target state="translated">Como en la funci&amp;oacute;n &lt;code&gt;run/3&lt;/code&gt; , un &lt;code&gt;mp()&lt;/code&gt; compilado con la opci&amp;oacute;n &lt;code&gt;unicode&lt;/code&gt; requiere que &lt;code&gt;Subject&lt;/code&gt; sea ​​un &lt;code&gt;charlist()&lt;/code&gt; Unicode . Si la compilaci&amp;oacute;n se realiza impl&amp;iacute;citamente y se especifica la opci&amp;oacute;n de compilaci&amp;oacute;n &lt;code&gt;unicode&lt;/code&gt; para esta funci&amp;oacute;n, tanto la expresi&amp;oacute;n regular como el &lt;code&gt;Subject&lt;/code&gt; se especificar&amp;aacute;n como &lt;code&gt;charlist()&lt;/code&gt; Unicode v&amp;aacute;lidas .</target>
        </trans-unit>
        <trans-unit id="64b4b80939944294d71727cd908b06dbe0c67247" translate="yes" xml:space="preserve">
          <source>As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a &lt;code&gt;=&lt;/code&gt;. Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the &lt;strong&gt;whole&lt;/strong&gt; object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function &lt;code&gt;object/0&lt;/code&gt; also returns the whole matched object, see section &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt; Warnings and Restrictions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3af4e7ec9b32aca75bcf09376c862c57bf6062d9" translate="yes" xml:space="preserve">
          <source>As in ordinary Erlang matching, you can bind a variable to the whole matched object using a &quot;match inside the match&quot;, that is, a &lt;code&gt;=&lt;/code&gt;. Unfortunately in funs translated to match specifications, it is allowed only at the &quot;top-level&quot;, that is, matching the &lt;strong&gt;whole&lt;/strong&gt; object arriving to be matched into a separate variable. If you are used to writing match specifications by hand, we mention that variable A is simply translated into '$_'. Alternatively, pseudo function &lt;code&gt;object/0&lt;/code&gt; also returns the whole matched object, see section &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Como en la coincidencia de Erlang ordinaria, puede vincular una variable a todo el objeto coincidente utilizando una &quot;coincidencia dentro de la coincidencia&quot;, es decir, a &lt;code&gt;=&lt;/code&gt; . Desafortunadamente, en las diversiones traducidas para coincidir con las especificaciones, solo se permite en el &quot;nivel superior&quot;, es decir, hacer coincidir &lt;strong&gt;todo el&lt;/strong&gt; objeto que llega para ser emparejado en una variable separada. Si est&amp;aacute; acostumbrado a escribir especificaciones de coincidencia a mano, mencionamos que la variable A simplemente se traduce a '$ _'. Alternativamente, la pseudo funci&amp;oacute;n &lt;code&gt;object/0&lt;/code&gt; tambi&amp;eacute;n devuelve el objeto coincidente completo, consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#warnings_and_restrictions&quot;&gt;Warnings and Restrictions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a73b3d59b95737cd7fcd0d996094833b0e3aa133" translate="yes" xml:space="preserve">
          <source>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, &lt;code&gt;ei_x_free()&lt;/code&gt; ensures that the data pointed to by &lt;code&gt;buf&lt;/code&gt; is released.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43013c670a4d6155374f58258fab04f5fbbc072" translate="yes" xml:space="preserve">
          <source>As in the previous examples, it is your responsibility to free the memory allocated for Erlang terms. In this example, &lt;code&gt;erl_free_compound()&lt;/code&gt; ensures that the complete term pointed to by &lt;code&gt;ep&lt;/code&gt; is released. This is necessary because the pointer from the second call to &lt;code&gt;erl_format&lt;/code&gt; is lost.</source>
          <target state="translated">Como en los ejemplos anteriores, es su responsabilidad liberar la memoria asignada para los t&amp;eacute;rminos de Erlang. En este ejemplo, &lt;code&gt;erl_free_compound()&lt;/code&gt; asegura que se libera el t&amp;eacute;rmino completo al que apunta &lt;code&gt;ep&lt;/code&gt; . Esto es necesario porque se pierde el puntero de la segunda llamada a &lt;code&gt;erl_format&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d26ac3436bd27f40dd7ea34e33f65a20575923b6" translate="yes" xml:space="preserve">
          <source>As in the previous section the PEM file &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; contains both the server certificate and its private key.</source>
          <target state="translated">Como en la secci&amp;oacute;n anterior, el archivo PEM &lt;code&gt;&quot;/home/me/ssl/erlserver.pem&quot;&lt;/code&gt; contiene tanto el certificado del servidor como su clave privada.</target>
        </trans-unit>
        <trans-unit id="debb8560047fb0b42a46cc59f3c825a91b4209ba" translate="yes" xml:space="preserve">
          <source>As indicated by the name, emulator flags control the behavior of the emulator.</source>
          <target state="translated">Como su nombre indica,las banderas del emulador controlan el comportamiento del mismo.</target>
        </trans-unit>
        <trans-unit id="6f49bed7fb11b494819d4e36cc0258b2b542e095" translate="yes" xml:space="preserve">
          <source>As long as all character sets were limited to 256 characters, each character could be stored in one single byte, so there was more or less only one practical encoding for the characters. Encoding each character in one byte was so common that the encoding was not even named. With the Unicode system there are much more than 256 characters, so a common way is needed to represent these. The common ways of representing the code points are the encodings. This means a whole new concept to the programmer, the concept of character representation, which was a non-issue earlier.</source>
          <target state="translated">Mientras todos los conjuntos de caracteres se limitaban a 256 caracteres,cada uno de ellos podía almacenarse en un solo byte,de modo que había más o menos una única codificación práctica para los caracteres.La codificación de cada carácter en un byte era tan común que la codificación ni siquiera tenía nombre.Con el sistema Unicode hay mucho más de 256 caracteres,por lo que se necesita una forma común de representarlos.Las formas comunes de representar los puntos de código son las codificaciones.Esto significa un concepto totalmente nuevo para el programador,el concepto de representación de caracteres,que antes no era un problema.</target>
        </trans-unit>
        <trans-unit id="9b7153107281cf1e02599d91bf8553499b75800f" translate="yes" xml:space="preserve">
          <source>As long as real identifiers are correct, it is OK to pass a CPU topology that is not a correct description of the CPU topology. When used with care this can be very useful. This to trick the emulator to bind its schedulers as you want. For example, if you want to run multiple Erlang runtime systems on the same machine, you want to reduce the number of schedulers used and manipulate the CPU topology so that they bind to different logical CPUs. An example, with two Erlang runtime systems on a quad core machine:</source>
          <target state="translated">Mientras los identificadores reales sean correctos,está bien pasar una topología de CPU que no sea una descripción correcta de la topología de la CPU.Cuando se usa con cuidado,esto puede ser muy útil.Esto para engañar al emulador para que enlace sus programadores como quieras.Por ejemplo,si quiere ejecutar varios sistemas de tiempo de ejecución Erlang en la misma máquina,quiere reducir el número de programadores utilizados y manipular la topología de la CPU para que se unan a diferentes CPUs lógicas.Un ejemplo,con dos sistemas de tiempo de ejecución Erlang en una máquina de cuatro núcleos:</target>
        </trans-unit>
        <trans-unit id="3a4531be2cf765e3ef8b54b63b05d246b380ee1c" translate="yes" xml:space="preserve">
          <source>As long as the &lt;code&gt;ftp&lt;/code&gt; application is operational, the FTP sessions are supervised and can be soft code upgraded.</source>
          <target state="translated">Siempre que la aplicaci&amp;oacute;n &lt;code&gt;ftp&lt;/code&gt; est&amp;eacute; operativa, las sesiones FTP est&amp;aacute;n supervisadas y pueden actualizarse mediante c&amp;oacute;digo software.</target>
        </trans-unit>
        <trans-unit id="b05ddb8fa8f81edfa35269196a6d393612d35a2a" translate="yes" xml:space="preserve">
          <source>As long as the data is always lists, modifier &lt;code&gt;t&lt;/code&gt; can be used for any string, but when binary data is involved, care must be taken to make the correct choice of formatting characters. A bytewise-encoded binary is also interpreted as a string, and printed even when using &lt;code&gt;~ts&lt;/code&gt;, but it can be mistaken for a valid UTF-8 string. Avoid therefore using the &lt;code&gt;~ts&lt;/code&gt; control if the binary contains bytewise-encoded characters and not UTF-8.</source>
          <target state="translated">Siempre que los datos sean siempre listas, el modificador &lt;code&gt;t&lt;/code&gt; se puede utilizar para cualquier cadena, pero cuando se trata de datos binarios, se debe tener cuidado de elegir correctamente los caracteres de formato. Un binario codificado por bytes tambi&amp;eacute;n se interpreta como una cadena y se imprime incluso cuando se usa &lt;code&gt;~ts&lt;/code&gt; , pero puede confundirse con una cadena UTF-8 v&amp;aacute;lida. Por lo tanto, evite usar el control &lt;code&gt;~ts&lt;/code&gt; si el binario contiene caracteres codificados por bytes y no UTF-8.</target>
        </trans-unit>
        <trans-unit id="38beb3decd97936c9d002a776141659553006a04" translate="yes" xml:space="preserve">
          <source>As long as the length of the message queue is lower than this value, all log events are handled asynchronously. This means that the client process sending the log event, by calling a log function in the &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt;, does not wait for a response from the handler but continues executing immediately after the event is sent. It is not affected by the time it takes the handler to print the event to the log device. If the message queue grows larger than this value, the handler starts handling log events synchronously instead, meaning that the client process sending the event must wait for a response. When the handler reduces the message queue to a level below the &lt;code&gt;sync_mode_qlen&lt;/code&gt; threshold, asynchronous operation is resumed. The switch from asynchronous to synchronous mode can slow down the logging tempo of one, or a few, busy senders, but cannot protect the handler sufficiently in a situation of many busy concurrent senders.</source>
          <target state="translated">Siempre que la longitud de la cola de mensajes sea menor que este valor, todos los eventos de registro se manejan de forma asincr&amp;oacute;nica. Esto significa que el proceso del cliente que env&amp;iacute;a el evento de registro, al llamar a una funci&amp;oacute;n de registro en la &lt;code&gt;&lt;a href=&quot;logger_chapter#logger_api&quot;&gt;Logger API&lt;/a&gt;&lt;/code&gt; , no espera una respuesta del controlador, sino que contin&amp;uacute;a ejecut&amp;aacute;ndose inmediatamente despu&amp;eacute;s de que se env&amp;iacute;a el evento. No se ve afectado por el tiempo que tarda el controlador en imprimir el evento en el dispositivo de registro. Si la cola de mensajes supera este valor, el controlador comienza a manejar los eventos de registro de forma sincr&amp;oacute;nica, lo que significa que el proceso del cliente que env&amp;iacute;a el evento debe esperar una respuesta. Cuando el controlador reduce la cola de mensajes a un nivel por debajo de &lt;code&gt;sync_mode_qlen&lt;/code&gt; umbral, se reanuda el funcionamiento asincr&amp;oacute;nico. El cambio de modo as&amp;iacute;ncrono a s&amp;iacute;ncrono puede ralentizar el ritmo de registro de uno o unos pocos remitentes ocupados, pero no puede proteger al controlador lo suficiente en una situaci&amp;oacute;n de muchos remitentes concurrentes ocupados.</target>
        </trans-unit>
        <trans-unit id="cb54073b5c596b75c4d1032a2bc0e471288f7302" translate="yes" xml:space="preserve">
          <source>As long as there are no more than 16 schedulers, there will never be any lock contention on the port lock for the driver.</source>
          <target state="translated">Mientras no haya más de 16 programadores,nunca habrá ninguna disputa sobre el bloqueo del puerto para el conductor.</target>
        </trans-unit>
        <trans-unit id="e4b29322baa56d4c7a0700a6dec611b4da2d64c8" translate="yes" xml:space="preserve">
          <source>As many options are silently discarded by the stack if they are specified out of range; it can be a good idea to check that a raw option is accepted. The following code places the value in variable &lt;code&gt;TcpLinger2:&lt;/code&gt;</source>
          <target state="translated">Como muchas opciones son descartadas silenciosamente por la pila si se especifican fuera de rango; Puede ser una buena idea comprobar que se acepta una opci&amp;oacute;n sin formato. El siguiente c&amp;oacute;digo coloca el valor en la variable &lt;code&gt;TcpLinger2:&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cde1dbb415595f7822eb3d191139162bdd23a109" translate="yes" xml:space="preserve">
          <source>As matching proceeds from left to right, PCRE looks for each &quot;a&quot; in the subject and then sees if what follows matches the remaining pattern. If the pattern is specified as</source>
          <target state="translated">A medida que la coincidencia avanza de izquierda a derecha,el PCRE busca cada &quot;a&quot; del sujeto y luego ve si lo que sigue coincide con el patrón restante.Si el patrón se especifica como</target>
        </trans-unit>
        <trans-unit id="6ca1c79babb9a0075f407b28d68680d2a199070e" translate="yes" xml:space="preserve">
          <source>As md5 is not available in FIPS mode it is only possible to use certificates that were signed using sha hashing. When validating an entire certificate chain all certificates (including the root CA's) must comply with this rule.</source>
          <target state="translated">Como el md5 no está disponible en modo FIPS,sólo es posible utilizar certificados que fueron firmados usando sha hashing.Al validar una cadena de certificados completa,todos los certificados (incluyendo las CA raíz)deben cumplir con esta regla.</target>
        </trans-unit>
        <trans-unit id="d5d8bb90e5a37caa06c5da65479a3526fd9c95dd" translate="yes" xml:space="preserve">
          <source>As mentioned above, the descriptors for the free segments are allocated in a separate area. This area has a constant configurable size (+MMscrfsd) that defaults to 65536 descriptors. This should be more than enough in most cases. If the descriptors area should fill up, new descriptor areas will be allocated first directly from the OS, and then from &lt;code&gt;sua&lt;/code&gt; and &lt;code&gt;sa&lt;/code&gt; in the super carrier, and lastly from the memory segment itself which is being deallocated. Allocating free descriptor areas from the super carrier is only a last resort, and should be avoided, as it creates fragmentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7c08fa4650f0a0fe94395e21e9822cf60a9f2f7" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a script can contains precompiled &lt;code&gt;beam&lt;/code&gt; code. In a precompiled script, the interpretation of the script header is the same as in a script containing source code. This means that you can make a &lt;code&gt;beam&lt;/code&gt; file executable by prepending the file with the lines starting with &lt;code&gt;#!&lt;/code&gt; and &lt;code&gt;%%!&lt;/code&gt; mentioned above. In a precompiled script, the &lt;code&gt;main/1&lt;/code&gt; function must be exported.</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, un script puede contener un c&amp;oacute;digo de &lt;code&gt;beam&lt;/code&gt; precompilado . En un script precompilado, la interpretaci&amp;oacute;n del encabezado del script es la misma que en un script que contiene c&amp;oacute;digo fuente. Esto significa que puede hacer que un archivo de &lt;code&gt;beam&lt;/code&gt; ejecutable anteponiendo al archivo las l&amp;iacute;neas que comienzan con &lt;code&gt;#!&lt;/code&gt; y &lt;code&gt;%%!&lt;/code&gt; mencionado anteriormente. En un script precompilado, se debe exportar la funci&amp;oacute;n &lt;code&gt;main/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e705de13180c5ffe8b4a054da182ea6ce56490f8" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, queries are expressed in the list comprehension syntax as described in section &lt;code&gt;Expressions&lt;/code&gt; in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section &lt;code&gt; List Comprehensions&lt;/code&gt; in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64feb9f4a1acc565bd79ae07225ce3ec20e86066" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, queries are expressed in the list comprehension syntax as described in section &lt;code&gt;Expressions&lt;/code&gt; in Erlang Reference Manual. In the following, some familiarity with list comprehensions is assumed. The examples in section &lt;code&gt;List Comprehensions&lt;/code&gt; in Programming Examples can get you started. Notice that list comprehensions do not add any computational power to the language; anything that can be done with list comprehensions can also be done without them. But they add syntax for expressing simple search problems, which is compact and clear once you get used to it.</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, las consultas se expresan en la sintaxis de comprensi&amp;oacute;n de la lista como se describe en la secci&amp;oacute;n &lt;code&gt;Expressions&lt;/code&gt; en el Manual de referencia de Erlang. A continuaci&amp;oacute;n, se asume cierta familiaridad con las listas por comprensi&amp;oacute;n. Los ejemplos de la secci&amp;oacute;n &lt;code&gt;List Comprehensions&lt;/code&gt; en Ejemplos de programaci&amp;oacute;n pueden ayudarlo a comenzar. Observe que las listas por comprensi&amp;oacute;n no agregan ning&amp;uacute;n poder de c&amp;aacute;lculo al lenguaje; cualquier cosa que se pueda hacer con listas por comprensi&amp;oacute;n tambi&amp;eacute;n se puede hacer sin ellas. Pero agregan sintaxis para expresar problemas de b&amp;uacute;squeda simples, que es compacta y clara una vez que te acostumbras.</target>
        </trans-unit>
        <trans-unit id="dcc63d308b096795c5804a0be71fa661e287ba90" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, segments have the following general syntax:</source>
          <target state="translated">Como ya se ha mencionado,los segmentos tienen la siguiente sintaxis general:</target>
        </trans-unit>
        <trans-unit id="04e043f1d8167a2d58dbe4fb1d07663eacbf966c" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this section, it is of vital importance that a driver callback returns relatively fast. It is difficult to give an exact maximum amount of time that a driver callback is allowed to work, but usually a well-behaving driver callback is to return within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the driver callback, the best approach is to divide the work into multiple chunks of work, and trigger multiple calls to the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; using zero time-outs. Function &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt; erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; can be useful to determine when to trigger such time-out callback calls. However, sometimes it cannot be implemented this way, for example when calling third-party libraries. In this case, you typically want to dispatch the work to another thread. Information about thread primitives is provided below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68d171b0ef9d17830114bdb2e45fbb538d0990d4" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this section, it is of vital importance that a driver callback returns relatively fast. It is difficult to give an exact maximum amount of time that a driver callback is allowed to work, but usually a well-behaving driver callback is to return within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the driver callback, the best approach is to divide the work into multiple chunks of work, and trigger multiple calls to the &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; using zero time-outs. Function &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; can be useful to determine when to trigger such time-out callback calls. However, sometimes it cannot be implemented this way, for example when calling third-party libraries. In this case, you typically want to dispatch the work to another thread. Information about thread primitives is provided below.</source>
          <target state="translated">Como se menciona en el texto de &lt;code id=&quot;lengthy_work&quot;&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; al principio de esta secci&amp;oacute;n, es de vital importancia que la devoluci&amp;oacute;n de llamada del conductor regrese relativamente r&amp;aacute;pido. Es dif&amp;iacute;cil dar una cantidad m&amp;aacute;xima exacta de tiempo que se permite que funcione una devoluci&amp;oacute;n de llamada de controlador, pero generalmente una devoluci&amp;oacute;n de llamada de controlador que se comporta bien debe regresar dentro de 1 milisegundo. Esto se puede lograr utilizando diferentes enfoques. Si tiene control total sobre el c&amp;oacute;digo para ejecutar en la devoluci&amp;oacute;n de llamada del controlador, el mejor enfoque es dividir el trabajo en m&amp;uacute;ltiples partes del trabajo y activar varias llamadas a la &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;time-out callback&lt;/a&gt;&lt;/code&gt; tiempo de espera sin tiempos de espera. Funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#erl_drv_consume_timeslice&quot;&gt;erl_drv_consume_timeslice&lt;/a&gt;&lt;/code&gt; puede ser &amp;uacute;til para determinar cu&amp;aacute;ndo activar tales llamadas de devoluci&amp;oacute;n de llamada de tiempo de espera. Sin embargo, a veces no se puede implementar de esta manera, por ejemplo, al llamar a bibliotecas de terceros. En este caso, normalmente desea enviar el trabajo a otro hilo. A continuaci&amp;oacute;n, se proporciona informaci&amp;oacute;n sobre las primitivas de subproceso.</target>
        </trans-unit>
        <trans-unit id="870908039e217eddb9cd9dd34c7a2a0d9565d41f" translate="yes" xml:space="preserve">
          <source>As mentioned in the &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; text at the beginning of this manual page, it is of &lt;strong&gt;vital importance&lt;/strong&gt; that a native function returns relatively fast. It is difficult to give an exact maximum amount of time that a native function is allowed to work, but usually a well-behaving native function is to return to its caller within 1 millisecond. This can be achieved using different approaches. If you have full control over the code to execute in the native function, the best approach is to divide the work into multiple chunks of work and call the native function multiple times. This is, however, not always possible, for example when calling third-party libraries.</source>
          <target state="translated">Como se menciona en el texto de &lt;code&gt;&lt;a href=&quot;#WARNING&quot;&gt;warning&lt;/a&gt;&lt;/code&gt; al comienzo de esta p&amp;aacute;gina del manual, es de &lt;strong&gt;vital importancia&lt;/strong&gt; que una funci&amp;oacute;n nativa regrese relativamente r&amp;aacute;pido. Es dif&amp;iacute;cil dar una cantidad m&amp;aacute;xima exacta de tiempo durante el cual se permite que una funci&amp;oacute;n nativa funcione, pero generalmente una funci&amp;oacute;n nativa que se comporta bien es regresar a su llamador en 1 milisegundo. Esto se puede lograr utilizando diferentes enfoques. Si tiene control total sobre el c&amp;oacute;digo para ejecutar en la funci&amp;oacute;n nativa, el mejor enfoque es dividir el trabajo en m&amp;uacute;ltiples partes del trabajo y llamar a la funci&amp;oacute;n nativa varias veces. Sin embargo, esto no siempre es posible, por ejemplo, al llamar a bibliotecas de terceros.</target>
        </trans-unit>
        <trans-unit id="d9a36e8e6187e92ea9445003806465beadc6eb3c" translate="yes" xml:space="preserve">
          <source>As mentioned in the Overview the size of the heap &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L247&quot;&gt;grows&lt;/a&gt;&lt;/code&gt; to accommodate more data. Heaps grow in two stages, first a &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L199-L208&quot;&gt;variation of the Fibonacci sequence&lt;/a&gt;&lt;/code&gt; is used starting at 233 words. Then at about 1 mega words the heap only &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L215-L227&quot;&gt;grows in 20% increments&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41a0f4742d111106d49a722bae376fa32463cd1a" translate="yes" xml:space="preserve">
          <source>As mentioned in the introduction, the &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4254&quot;&gt;SSH Connection Protocol&lt;/a&gt;&lt;/code&gt; events are handled as messages. When writing a channel handling process without using the support by the &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;ssh_client_channel&lt;/a&gt;&lt;/code&gt; behavior the process must handle thoose messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d72cf22161ff39dc24cc56c84b763eb1ee94488" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Inets&lt;/code&gt; 5.0 the HTTP server is an easy to start/stop and customize web server providing the most basic web server functionality. Inets is designed for embedded systems and if you want a full-fledged web server there are exists other erlang open source alternatives.</source>
          <target state="translated">A partir de &lt;code&gt;Inets&lt;/code&gt; 5.0, el servidor HTTP es un servidor web f&amp;aacute;cil de iniciar / detener y personalizar que proporciona la funcionalidad de servidor web m&amp;aacute;s b&amp;aacute;sica. Inets est&amp;aacute; dise&amp;ntilde;ado para sistemas integrados y, si desea un servidor web completo, existen otras alternativas de c&amp;oacute;digo abierto de erlang.</target>
        </trans-unit>
        <trans-unit id="04f3b139a6a6595cb20185db3ca083fba34bbe19" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Inets&lt;/code&gt; 5.0 the HTTP server is an easy to start/stop and customize web server providing the most basic web server functionality. Inets is designed for embedded systems and if you want a full-fledged web server there are other erlang open source alternatives.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33b6ffe68a9875e88f7c894ca5fdbb2187c6d41" translate="yes" xml:space="preserve">
          <source>As of ERTS version 10.0 support for distribution controller processes has been introduced. That is, the traffic over a distribution channel can be managed by a process instead of only by a port. This makes it possible to implement large parts of the logic in Erlang code, and you perhaps do not even need a new driver for the protocol. One example could be Erlang distribution over UDP using &lt;code&gt;gen_udp&lt;/code&gt; (your Erlang code will of course have to take care of retransmissions, etc in this example). That is, depending on what you want to do you perhaps do not need to implement a driver at all and can then skip the driver related sections below. The &lt;code&gt;gen_tcp_dist&lt;/code&gt; example described in the &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; section utilize distribution controller processes and can be worth having a look at if you want to use distribution controller processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0209ca89965504887d9fa6f1d52589a2103d8bad" translate="yes" xml:space="preserve">
          <source>As of ERTS version 10.0 support for distribution controller processes has been introduced. That is, the traffic over a distribution channel can be managed by a process instead of only by a port. This makes it possible to implement large parts of the logic in Erlang code, and you perhaps do not even need a new driver for the protocol. One example could be Erlang distribution over UDP using &lt;code&gt;gen_udp&lt;/code&gt; (your Erlang code will of course have to take care of retranspissions, etc in this example). That is, depending on what you want to do you perhaps do not need to implement a driver at all and can then skip the driver related sections below. The &lt;code&gt;gen_tcp_dist&lt;/code&gt; example described in the &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; section utilize distribution controller processes and can be worth having a look at if you want to use distribution controller processes.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 10.0 de ERTS, se ha introducido el soporte para procesos de controlador de distribuci&amp;oacute;n. Es decir, el tr&amp;aacute;fico a trav&amp;eacute;s de un canal de distribuci&amp;oacute;n puede ser administrado por un proceso en lugar de solo por un puerto. Esto hace posible implementar gran parte de la l&amp;oacute;gica en el c&amp;oacute;digo Erlang, y quiz&amp;aacute;s ni siquiera necesite un nuevo controlador para el protocolo. Un ejemplo podr&amp;iacute;a ser la distribuci&amp;oacute;n de Erlang sobre UDP usando &lt;code&gt;gen_udp&lt;/code&gt; (su c&amp;oacute;digo Erlang, por supuesto, tendr&amp;aacute; que encargarse de las retranspisiones, etc. en este ejemplo). Es decir, dependiendo de lo que desee hacer, tal vez no necesite implementar un controlador en absoluto y luego puede omitir las secciones relacionadas con el controlador a continuaci&amp;oacute;n. El ejemplo &lt;code&gt;gen_tcp_dist&lt;/code&gt; descrito en el &lt;code&gt;&lt;a href=&quot;#distribution_module&quot;&gt;Distribution Module&lt;/a&gt;&lt;/code&gt; secci&amp;oacute;n utiliza procesos de controlador de distribuci&amp;oacute;n y puede valer la pena echarle un vistazo si desea utilizar procesos de controlador de distribuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c85a6ebe0161eb5757b5cd028db5ba4081c57741" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, a process is only considered to be lingering in the code if it has direct references to the code. For more information see documentation of &lt;code&gt;erlang:check_process_code/3&lt;/code&gt;, which is used in order to determine this.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 9.0 de ERTS, solo se considera que un proceso permanece en el c&amp;oacute;digo si tiene referencias directas al c&amp;oacute;digo. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la documentaci&amp;oacute;n de &lt;code&gt;erlang:check_process_code/3&lt;/code&gt; , que se utiliza para determinar esto.</target>
        </trans-unit>
        <trans-unit id="6e7c328c76bb8c7c656e5de8a5de979edf715c89" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, also dirty CPU schedulers will be included in the result. That is, all scheduler threads that are expected to handle CPU bound work. If you also want information about dirty I/O schedulers, use &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt; statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="990b2f43003907f6ffa2fd600f8b8c5f6d4c0c81" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, also dirty CPU schedulers will be included in the result. That is, all scheduler threads that are expected to handle CPU bound work. If you also want information about dirty I/O schedulers, use &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 9.0 de ERTS, tambi&amp;eacute;n se incluir&amp;aacute;n programadores de CPU sucios en el resultado. Es decir, todos los subprocesos del programador que se espera que manejen el trabajo vinculado a la CPU. Si tambi&amp;eacute;n desea informaci&amp;oacute;n sobre los programadores de E / S sucios, utilice &lt;code&gt;&lt;a href=&quot;#statistics_scheduler_wall_time_all&quot;&gt;statistics(scheduler_wall_time_all)&lt;/a&gt;&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="924b8134638ed9edf16b9abf6ee2f7cc8660dc0a" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the Erlang runtime system will as default have more schedulers than logical processors. This due to the dirty schedulers.</source>
          <target state="translated">A partir de la versión 9.0 de ERTS,el sistema de tiempo de ejecución de Erlang tendrá por defecto más programadores que procesadores lógicos.Esto se debe a los programadores sucios.</target>
        </trans-unit>
        <trans-unit id="cf90680c064454d2c96d45dd08744df7108b0b29" translate="yes" xml:space="preserve">
          <source>As of ERTS version 9.0, the check process code operation only checks for direct references to the code. Indirect references via &lt;code&gt;fun&lt;/code&gt;s will be ignored. If such &lt;code&gt;fun&lt;/code&gt;s exist and are used after a purge of the old code, an exception will be raised upon usage (same as the case when the &lt;code&gt;fun&lt;/code&gt; is received by the process after the purge). Literals will be taken care of (copied) at a later stage. This behavior can as of ERTS version 8.1 be enabled when &lt;code&gt;building OTP&lt;/code&gt;, and will automatically be enabled if dirty scheduler support is enabled.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 9.0 de ERTS, la operaci&amp;oacute;n de verificaci&amp;oacute;n del c&amp;oacute;digo de proceso solo busca referencias directas al c&amp;oacute;digo. Se ignorar&amp;aacute;n las referencias indirectas a trav&amp;eacute;s de &lt;code&gt;fun&lt;/code&gt; s. Si tales &lt;code&gt;fun&lt;/code&gt; existen y se usan despu&amp;eacute;s de una purga del c&amp;oacute;digo anterior, se generar&amp;aacute; una excepci&amp;oacute;n al usarlas (igual que en el caso cuando la &lt;code&gt;fun&lt;/code&gt; recibe el proceso despu&amp;eacute;s de la purga). Los literales se encargar&amp;aacute;n (copiar&amp;aacute;n) en una etapa posterior. Este comportamiento se puede habilitar a partir de la versi&amp;oacute;n 8.1 de ERTS al &lt;code&gt;building OTP&lt;/code&gt; , y se habilitar&amp;aacute; autom&amp;aacute;ticamente si se habilita el soporte del programador sucio.</target>
        </trans-unit>
        <trans-unit id="f4e1d3eb137cab5087aa6346ca40170ec41e8ce0" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 17, most applications deliver a valid application upgrade file (&lt;code&gt;appup&lt;/code&gt;). In earlier releases, a majority of the applications in Erlang/OTP did not support upgrade. Many of the applications use the &lt;code&gt;restart_application&lt;/code&gt; instruction. These are applications for which it is not crucial to support real soft upgrade, for example, tools and library applications. The &lt;code&gt;restart_application&lt;/code&gt; instruction ensures that all modules in the application are reloaded and thereby running the new code.</source>
          <target state="translated">A partir de Erlang / OTP 17, la mayor&amp;iacute;a de las aplicaciones entregan un archivo de actualizaci&amp;oacute;n de aplicaci&amp;oacute;n v&amp;aacute;lido ( &lt;code&gt;appup&lt;/code&gt; ). En versiones anteriores, la mayor&amp;iacute;a de las aplicaciones de Erlang / OTP no admit&amp;iacute;an la actualizaci&amp;oacute;n. Muchas de las aplicaciones utilizan la instrucci&amp;oacute;n &lt;code&gt;restart_application&lt;/code&gt; . Estas son aplicaciones para las que no es crucial admitir una actualizaci&amp;oacute;n suave real, por ejemplo, herramientas y aplicaciones de biblioteca. La instrucci&amp;oacute;n &lt;code&gt;restart_application&lt;/code&gt; asegura que todos los m&amp;oacute;dulos de la aplicaci&amp;oacute;n se vuelvan a cargar y, por lo tanto, ejecuten el nuevo c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="3896e9860076cb6efc826bd1af4282cf215a66b2" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP 21.0, the concept of SASL reports is removed, meaning that the default behaviour is as follows:</source>
          <target state="translated">A partir de Erlang/OTP 21.0,se elimina el concepto de informes SASL,lo que significa que el comportamiento por defecto es el siguiente:</target>
        </trans-unit>
        <trans-unit id="5156993619ca489fb8cfd9ed4a3335d7b4428f29" translate="yes" xml:space="preserve">
          <source>As of Erlang/OTP R16, messages sent to ports are delivered truly asynchronously. The underlying implementation previously delivered messages to ports synchronously. Message passing has however always been documented as an asynchronous operation. Hence, this is not to be an issue for an Erlang program communicating with ports, unless false assumptions about ports have been made.</source>
          <target state="translated">A partir de Erlang/OTP R16,los mensajes enviados a los puertos se entregan verdaderamente asincrónicos.La implementación subyacente anteriormente entregaba los mensajes a los puertos de forma sincrónica.Sin embargo,el paso de mensajes siempre se ha documentado como una operación asincrónica.Por lo tanto,esto no debe ser un problema para un programa Erlang que se comunica con los puertos,a menos que se hayan hecho falsas suposiciones sobre los puertos.</target>
        </trans-unit>
        <trans-unit id="db7deccbe166e540f0b707dd76ed8fd8300520de" translate="yes" xml:space="preserve">
          <source>As of OTP 17.0 application versions use the same &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; as the OTP version. Application versions part of a release candidate will however not have an &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; suffix as the OTP version. Also note that a major increment in an application version does not necessarily imply a major increment of the OTP version. This depends on whether the major change in the application is considered as a major change for OTP as a whole or not.</source>
          <target state="translated">A partir de la &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;version scheme&lt;/a&gt;&lt;/code&gt; 17.0 de la aplicaci&amp;oacute;n OTP, se usa el mismo esquema de versi&amp;oacute;n que la versi&amp;oacute;n OTP. Sin embargo, las versiones de la aplicaci&amp;oacute;n que forman parte de una versi&amp;oacute;n candidata no tendr&amp;aacute;n el sufijo &lt;code&gt;-rc&amp;lt;N&amp;gt;&lt;/code&gt; como versi&amp;oacute;n de OTP. Tambi&amp;eacute;n tenga en cuenta que un incremento importante en la versi&amp;oacute;n de una aplicaci&amp;oacute;n no implica necesariamente un incremento importante de la versi&amp;oacute;n OTP. Esto depende de si el cambio principal en la aplicaci&amp;oacute;n se considera un cambio importante para la OTP en su conjunto o no.</target>
        </trans-unit>
        <trans-unit id="f41a33ea3422f58a2c592a14e6ca2fd364ded6e8" translate="yes" xml:space="preserve">
          <source>As of OTP 22 the run-time complexity is &quot;n log n&quot; and the operation will complete quickly even when both lists are very long. In fact, it is faster and uses less memory than the commonly used workaround to convert both lists to ordered sets before subtracting them with &lt;code&gt;ordsets:subtract/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a5518801a50c6a71ee3e8981653964ac2b6dbf8" translate="yes" xml:space="preserve">
          <source>As of OTP 23, a new process group implementation &lt;code&gt;pg&lt;/code&gt; is introduced. &lt;code&gt;pg&lt;/code&gt; is similar to &lt;code&gt;pg2&lt;/code&gt;, but with much better scalability properties. However, the API and behavior are not compatible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dd17f9053cdf5289c0081b64f5ede62361aa0f24" translate="yes" xml:space="preserve">
          <source>As of OTP 23, the &lt;code&gt;registry&lt;/code&gt; functionality part of &lt;code&gt;erl_interface&lt;/code&gt; has been deprecated and it has also been &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; in OTP 24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d305318f18afb878956cbef1be26210771c5dcfd" translate="yes" xml:space="preserve">
          <source>As of OTP 23, the distributed &lt;code&gt;disk_log&lt;/code&gt; feature has been deprecated and it has also been &lt;code&gt;&lt;a href=&quot;scheduled_for_removal#otp-24&quot;&gt;scheduled for removal&lt;/a&gt;&lt;/code&gt; in OTP 24.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4a95f7bae08ccde7df39187dbb3cd7db985f457" translate="yes" xml:space="preserve">
          <source>As of OTP 24 &lt;code&gt;memsup_improved_system_memory_data&lt;/code&gt; configuration parameter will be removed and &lt;code&gt;get_system_memory_data()&lt;/code&gt; will begin behaving as it does now when the configuration parameter has been set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1a516e25f41f502502c2e85a3b2d0123bd4daa" translate="yes" xml:space="preserve">
          <source>As of OTP 24, the Erlang compiler will refuse to compile source files encoded in Latin-1 but without a &lt;code&gt;%% coding: latin-1&lt;/code&gt; comment at the beginning of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9aac901e7e27d750caa95cb4832b3614a3f6a5b" translate="yes" xml:space="preserve">
          <source>As of OTP 24, the pre-release version 3 encoding configs; &lt;code&gt;prev3a&lt;/code&gt;, &lt;code&gt;prev3b&lt;/code&gt; and &lt;code&gt;prev3c&lt;/code&gt; will be removed. Use the full version instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6a68f9772c180bbf4b9650571adc55b4582fbcd" translate="yes" xml:space="preserve">
          <source>As of OTP release 17, the OTP release number corresponds to the major part of the OTP version. The OTP version as a concept was introduced in OTP 17. The version scheme used is described in detail in &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 17 de OTP, el n&amp;uacute;mero de versi&amp;oacute;n de OTP corresponde a la mayor parte de la versi&amp;oacute;n de OTP. La versi&amp;oacute;n OTP como concepto se introdujo en OTP 17. El esquema de versi&amp;oacute;n utilizado se describe en detalle en &lt;code&gt;&lt;a href=&quot;#version_scheme&quot;&gt;Version Scheme&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="aa2be4113be53a8f180a26c5c4f8137c8f0b13cc" translate="yes" xml:space="preserve">
          <source>As of R15B01, the dynamic trace code is included in the OTP source distribution, although it's considered experimental. The main development of the dtrace code still happens outside of Ericsson, but there is no need to fetch a patched version of the OTP source to get the basic functionality.</source>
          <target state="translated">A partir del R15B01,el código de trazado dinámico está incluido en la distribución de fuentes de la OTP,aunque se considera experimental.El desarrollo principal del código de rastreo todavía ocurre fuera de Ericsson,pero no hay necesidad de buscar una versión parcheada de la fuente OTP para obtener la funcionalidad básica.</target>
        </trans-unit>
        <trans-unit id="3175e151baddb9462eaca8a3103721b845c4be90" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. This function is used to convert to the old (pre-4.4) info format.</source>
          <target state="translated">A partir de la versión 4.4 el formato de la información ha sido cambiado.Esta función se utiliza para convertir al antiguo (pre-4.4)formato de la información.</target>
        </trans-unit>
        <trans-unit id="bc18a1e131252e89f07716dc1f6c84f4f113e552" translate="yes" xml:space="preserve">
          <source>As of version 4.4 the format of the info has been changed. To convert the info to the old format, call the &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 4.4, se ha cambiado el formato de la informaci&amp;oacute;n. Para convertir la informaci&amp;oacute;n al formato antiguo, llame a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#old_info_format&quot;&gt;old_info_format&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9906087c5fedcbfdab5bd69f8a1d9d0466df42d7" translate="yes" xml:space="preserve">
          <source>As one process can only be sending one fragmented message at once, it can be convenient to use the local PID as the sequence id.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0806b3a57271c3368eb538cbf78e42f66a7befe" translate="yes" xml:space="preserve">
          <source>As operators are not terms in their own right, when operators are mentioned below, the representation of an operator is to be taken to be the atom with a printname consisting of the same characters as the operator.</source>
          <target state="translated">Como los operadores no son términos en sí mismos,cuando se mencionan los operadores a continuación,la representación de un operador debe considerarse como el átomo con un nombre de impresión que consiste en los mismos caracteres que el operador.</target>
        </trans-unit>
        <trans-unit id="27aa2715207bd314b837c8f9f949d9e43e3fe153" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-M&lt;/code&gt;, except that the Makefile is written to &lt;code&gt;Makefile&lt;/code&gt;. No object file is produced.</source>
          <target state="translated">Como opci&amp;oacute;n &lt;code&gt;-M&lt;/code&gt; , excepto que Makefile se escribe en &lt;code&gt;Makefile&lt;/code&gt; . No se genera ning&amp;uacute;n archivo de objeto.</target>
        </trans-unit>
        <trans-unit id="3d10554b44799b09a5d688a7590a7e6f973d1129" translate="yes" xml:space="preserve">
          <source>As option &lt;code&gt;-MT&lt;/code&gt;, except that characters special to &lt;code&gt;make/1&lt;/code&gt; are quoted.</source>
          <target state="translated">Como opci&amp;oacute;n &lt;code&gt;-MT&lt;/code&gt; , excepto que se citan los caracteres especiales para &lt;code&gt;make/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b8f789d4c76adaa6e3ad489f09dfb73a7ef05683" translate="yes" xml:space="preserve">
          <source>As parameter &lt;code&gt;Config&lt;/code&gt; is a list of key-value tuples, that is, a data type called a property list, it can be handled by the &lt;code&gt;proplists&lt;/code&gt; module. A value can, for example, be searched for and returned with function &lt;code&gt;proplists:get_value/2&lt;/code&gt;. Also, or alternatively, the general &lt;code&gt;lists&lt;/code&gt; module contains useful functions. Normally, the only operations performed on &lt;code&gt;Config&lt;/code&gt; is insert (adding a tuple to the head of the list) and lookup. &lt;code&gt;Common Test&lt;/code&gt; provides a simple macro named &lt;code&gt;?config&lt;/code&gt;, which returns a value of an item in &lt;code&gt;Config&lt;/code&gt; given the key (exactly like &lt;code&gt;proplists:get_value&lt;/code&gt;). Example: &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt;.</source>
          <target state="translated">Como el par&amp;aacute;metro &lt;code&gt;Config&lt;/code&gt; es una lista de tuplas clave-valor, es decir, un tipo de datos llamado lista de propiedades, puede ser manejado por el m&amp;oacute;dulo &lt;code&gt;proplists&lt;/code&gt; . Un valor puede, por ejemplo, buscarse y devolverse con la funci&amp;oacute;n &lt;code&gt;proplists:get_value/2&lt;/code&gt; . Adem&amp;aacute;s, o alternativamente, el m&amp;oacute;dulo de &lt;code&gt;lists&lt;/code&gt; generales contiene funciones &amp;uacute;tiles. Normalmente, las &amp;uacute;nicas operaciones que se realizan en &lt;code&gt;Config&lt;/code&gt; son insertar (agregar una tupla al encabezado de la lista) y buscar. &lt;code&gt;Common Test&lt;/code&gt; proporciona una macro simple llamada &lt;code&gt;?config&lt;/code&gt; &lt;code&gt;Config&lt;/code&gt; , que devuelve un valor de un elemento en Config dada la clave (exactamente como &lt;code&gt;proplists:get_value&lt;/code&gt; ). Ejemplo: &lt;code&gt;PrivDir = ?config(priv_dir, Config)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="df954ec42f95212c23047d3734e01ef2d3ae2ca4" translate="yes" xml:space="preserve">
          <source>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-1&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e768910eb46b5bf1b56cc0b04701d6e5fb8dd7f" translate="yes" xml:space="preserve">
          <source>As previously described, a Functional Object (Fun) performing table access operations, as listed here, can be passed on as arguments to the function &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Como se describi&amp;oacute; anteriormente, un objeto funcional (divertido) que realiza operaciones de acceso a la tabla, como se enumera aqu&amp;iacute;, se puede pasar como argumentos a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#transaction-2&quot;&gt;mnesia:transaction/1,2,3&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="697d56b55fb0573091be8112b03dc468b6978a3a" translate="yes" xml:space="preserve">
          <source>As previously explained, this specification can also be provided by an entry like the following in a configuration file:</source>
          <target state="translated">Como se ha explicado anteriormente,esta especificación también puede ser proporcionada por una entrada como la siguiente en un archivo de configuración:</target>
        </trans-unit>
        <trans-unit id="5b4c831da626efb451c44f834caf79dfb78dcdf6" translate="yes" xml:space="preserve">
          <source>As previously stated, the locking strategy used by &lt;code&gt;Mnesia&lt;/code&gt; is to lock one record when reading a record, and lock all replicas of a record when writing a record. However, some applications use &lt;code&gt;Mnesia&lt;/code&gt; mainly for its fault-tolerant qualities. These applications can be configured with one node doing all the heavy work, and a standby node that is ready to take over if the main node fails. Such applications can benefit from using sticky locks instead of the normal locking scheme.</source>
          <target state="translated">Como se indic&amp;oacute; anteriormente, la estrategia de bloqueo utilizada por &lt;code&gt;Mnesia&lt;/code&gt; es bloquear un registro cuando se lee un registro y bloquear todas las r&amp;eacute;plicas de un registro cuando se escribe un registro. Sin embargo, algunas aplicaciones utilizan &lt;code&gt;Mnesia&lt;/code&gt; principalmente por sus cualidades de tolerancia a fallos. Estas aplicaciones se pueden configurar con un nodo que hace todo el trabajo pesado y un nodo en espera que est&amp;aacute; listo para asumir el control si falla el nodo principal. Estas aplicaciones pueden beneficiarse del uso de candados adhesivos en lugar del esquema de bloqueo normal.</target>
        </trans-unit>
        <trans-unit id="f370e8c40b9c4aba3e02b9314c912aaa28fee118" translate="yes" xml:space="preserve">
          <source>As producing and consuming standard URIs can get quite complex, Erlang/OTP provides a module, &lt;code&gt;uri_string&lt;/code&gt;, to handle all the most difficult operations such as parsing, recomposing, normalizing and resolving URIs against a base URI.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d595490ab4714d8a9871d8a09a973dfea9d0d3d" translate="yes" xml:space="preserve">
          <source>As received in the &lt;code&gt;stream_start message&lt;/code&gt;</source>
          <target state="translated">Como se recibi&amp;oacute; en el &lt;code&gt;stream_start message&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fd5870133105312565312c6b2ab7ff3fd841d30a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Seg&amp;uacute;n lo devuelto por &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#connect-3&quot;&gt;connect/3,4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b46cebaae7c70180ee044bb55a1784247c2f3b67" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Como lo devuelve &lt;code&gt;&lt;a href=&quot;#async_call-4&quot;&gt;async_call/4&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6563f22087e6266633a8cc2568e501f807ea6a94" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Como lo devuelve &lt;code&gt;&lt;a href=&quot;#new-0&quot;&gt;new/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f4cda5fd62bef4cb2abdbf95c2aa051fe7320a88" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2,3,4&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#accept-1&quot;&gt;accept/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613b92ac4a60557f480687125ac1a95cb659b564" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Devuelto por &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5ba5543136150606738a5ee102fcd04508cc21b" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Devuelto por &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;open/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="863aff4e4c6e39a97f1c4df4bc54ef46a778c1ae" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;; &lt;code&gt;pid()&lt;/code&gt; is a process handling I/O-protocols.</source>
          <target state="translated">Devuelto por &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; ; &lt;code&gt;pid()&lt;/code&gt; es un proceso que maneja protocolos de E / S.</target>
        </trans-unit>
        <trans-unit id="b4c95d43e70076905f6c54f0f92a6860693a2f6a" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Como lo devuelve &lt;code&gt;&lt;a href=&quot;#start_link-4&quot;&gt;start_link/4&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="90363fa78582864ae9fe09932744a0fa77aa02f7" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Como lo devuelve &lt;code&gt;&lt;a href=&quot;#zip_open-2&quot;&gt;zip_open/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff99780124925e73d20d6ffc6b9d429009c7ddfb" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt; erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt; io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a102b38b674404b91761c097130f2c6e8ca2119" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Como lo devuelve &lt;code&gt;&lt;a href=&quot;erl_parse#parse_exprs-1&quot;&gt;erl_parse:parse_exprs/1&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;io#parse_erl_exprs-2&quot;&gt;io:parse_erl_exprs/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="822165ce6b0feadb4e6119638d0ca82bfef5ff78" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;   As returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt; ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d84d9f434fd43a7bcd5371be1f74578362aa6337" translate="yes" xml:space="preserve">
          <source>As returned by &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt;   As returned by &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Como lo devuelve &lt;code&gt;&lt;a href=&quot;ssh#connect-3&quot;&gt;ssh:connect/3&lt;/a&gt;&lt;/code&gt; Como lo devuelve &lt;code&gt;&lt;a href=&quot;ssh_connection#session_channel-2&quot;&gt;ssh_connection:session_channel/[2,4]&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1972d70c337d0516468a049aa6934a58903d2c1e" translate="yes" xml:space="preserve">
          <source>As returned by init/0</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66acc65c2b1802196c6e3511e7c37cac12a600c6" translate="yes" xml:space="preserve">
          <source>As seen in the help text -- unless you have not upgraded your Emacs yet (well, what are you waiting around here for? Off you go and upgrade!) -- &lt;code&gt;etags&lt;/code&gt; associate the file extensions &lt;code&gt;.erl&lt;/code&gt; and &lt;code&gt;.hrl&lt;/code&gt; with Erlang.</source>
          <target state="translated">Como se ve en el texto de ayuda, a menos que a&amp;uacute;n no haya actualizado su Emacs (bueno, &amp;iquest;a qu&amp;eacute; est&amp;aacute; esperando aqu&amp;iacute;? &amp;iexcl; &lt;code&gt;etags&lt;/code&gt; y actualice!) - etags asocian las extensiones de archivo &lt;code&gt;.erl&lt;/code&gt; y &lt;code&gt;.hrl&lt;/code&gt; con Erlang.</target>
        </trans-unit>
        <trans-unit id="5f01e0b8a20288a5e48191d860785e7700a74b5b" translate="yes" xml:space="preserve">
          <source>As seen, the basic syntax of a type is an atom followed by closed parentheses. New types are declared using &lt;code&gt;-type&lt;/code&gt; and &lt;code&gt;-opaque&lt;/code&gt; attributes as in the following:</source>
          <target state="translated">Como se ve, la sintaxis b&amp;aacute;sica de un tipo es un &amp;aacute;tomo seguido de par&amp;eacute;ntesis cerrados. Los nuevos tipos se declaran utilizando los atributos &lt;code&gt;-type&lt;/code&gt; y &lt;code&gt;-opaque&lt;/code&gt; como se muestra a continuaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="a3fd03dc2b283a58adbff3d43946bbc1c68e036d" translate="yes" xml:space="preserve">
          <source>As shown above, some files have extension &lt;code&gt;.hrl&lt;/code&gt;. These are header files that are included in the &lt;code&gt;.erl&lt;/code&gt; files by:</source>
          <target state="translated">Como se muestra arriba, algunos archivos tienen la extensi&amp;oacute;n &lt;code&gt;.hrl&lt;/code&gt; . Estos son archivos de encabezado que se incluyen en los archivos &lt;code&gt;.erl&lt;/code&gt; por:</target>
        </trans-unit>
        <trans-unit id="644b5188f948ac22e42edad7ffd5f78d4eae0359" translate="yes" xml:space="preserve">
          <source>As shown by the example, the function can be called from the shell also. The fun must be literally in the call when used from the shell as well.</source>
          <target state="translated">Como se muestra en el ejemplo,la función también puede ser llamada desde el caparazón.La diversión debe estar literalmente en la llamada cuando se utiliza desde la cáscara también.</target>
        </trans-unit>
        <trans-unit id="81045d7eeb4cf703574814aab4af0c68ba1e701f" translate="yes" xml:space="preserve">
          <source>As shown in section &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt;, the test suite module implements &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; (mandatory or optional) for various purposes, for example:</source>
          <target state="translated">Como se muestra en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;basics_chapter#External_Interfaces&quot;&gt;Common Test Basics&lt;/a&gt;&lt;/code&gt; , el m&amp;oacute;dulo de la suite de pruebas implementa &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;callback functions&lt;/a&gt;&lt;/code&gt; (obligatorias u opcionales) para varios prop&amp;oacute;sitos, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="030eefb3aa3439bedecb7d423ba21572f508483d" translate="yes" xml:space="preserve">
          <source>As shown, first it is checked if a year is leap. If a year is divisible by 400, it is a leap year. To determine this, first divide the year by 400 and use the BIF &lt;code&gt;trunc&lt;/code&gt; (more about this later) to cut off any decimals. Then multiply by 400 again and see if the same value is returned again. For example, year 2004:</source>
          <target state="translated">Como se muestra, primero se comprueba si un a&amp;ntilde;o es bisiesto. Si un a&amp;ntilde;o es divisible por 400, es un a&amp;ntilde;o bisiesto. Para determinar esto, primero divida el a&amp;ntilde;o entre 400 y use el &lt;code&gt;trunc&lt;/code&gt; BIF (m&amp;aacute;s sobre esto m&amp;aacute;s adelante) para cortar los decimales. Luego, multiplique por 400 nuevamente y vea si se devuelve el mismo valor nuevamente. Por ejemplo, a&amp;ntilde;o 2004:</target>
        </trans-unit>
        <trans-unit id="732c6e940059e650b01cb8f7c64bf6533a984dc1" translate="yes" xml:space="preserve">
          <source>As shown, the Erlang shell numbers the lines that can be entered, (as 1&amp;gt; 2&amp;gt;) and that it correctly says that 2 + 5 is 7. If you make writing mistakes in the shell, you can delete with the backspace key, as in most shells. There are many more editing commands in the shell (see &lt;code&gt;tty - A command line interface&lt;/code&gt; in ERTS User's Guide).</source>
          <target state="translated">Como se muestra, el shell de Erlang numera las l&amp;iacute;neas que se pueden ingresar (como 1&amp;gt; 2&amp;gt;) y que dice correctamente que 2 + 5 es 7. Si comete errores de escritura en el shell, puede borrar con la tecla de retroceso, como en la mayor&amp;iacute;a de las conchas. Hay muchos m&amp;aacute;s comandos de edici&amp;oacute;n en el shell (consulte &lt;code&gt;tty - A command line interface&lt;/code&gt; en la Gu&amp;iacute;a del usuario de ERTS).</target>
        </trans-unit>
        <trans-unit id="e71ec6804a29b4599e20b3e464961470ccc68635" translate="yes" xml:space="preserve">
          <source>As shown, the function &lt;code&gt;say_something&lt;/code&gt; writes its first argument the number of times specified by second argument. The function &lt;code&gt;start&lt;/code&gt; starts two Erlang processes, one that writes &quot;hello&quot; three times and one that writes &quot;goodbye&quot; three times. Both processes use the function &lt;code&gt;say_something&lt;/code&gt;. Notice that a function used in this way by &lt;code&gt;spawn&lt;/code&gt;, to start a process, must be exported from the module (that is, in the &lt;code&gt;-export&lt;/code&gt; at the start of the module).</source>
          <target state="translated">Como se muestra, la funci&amp;oacute;n &lt;code&gt;say_something&lt;/code&gt; escribe su primer argumento el n&amp;uacute;mero de veces especificado por el segundo argumento. La funci&amp;oacute;n &lt;code&gt;start&lt;/code&gt; inicia dos procesos de Erlang, uno que escribe &quot;hola&quot; tres veces y otro que escribe &quot;adi&amp;oacute;s&quot; tres veces. Ambos procesos usan la funci&amp;oacute;n &lt;code&gt;say_something&lt;/code&gt; . Observe que una funci&amp;oacute;n utilizada de esta manera por &lt;code&gt;spawn&lt;/code&gt; , para iniciar un proceso, debe exportarse desde el m&amp;oacute;dulo (es decir, en el &lt;code&gt;-export&lt;/code&gt; al inicio del m&amp;oacute;dulo).</target>
        </trans-unit>
        <trans-unit id="b8dddde7bbb47337791588e9c259e08ddee9bc47" translate="yes" xml:space="preserve">
          <source>As shown, the ping pong program has run. On the &quot;pong&quot; side:</source>
          <target state="translated">Como se muestra,el programa de ping pong se ha ejecutado.En el lado del &quot;pong&quot;:</target>
        </trans-unit>
        <trans-unit id="ad4c171e5c21c103c918431cb469ba42140798d7" translate="yes" xml:space="preserve">
          <source>As stated earlier, changing child specifications does not affect existing child processes. New child specifications are automatically added, but not deleted. Child processes are not automatically started or terminated, this must be done using &lt;code&gt;apply&lt;/code&gt; instructions.</source>
          <target state="translated">Como se indic&amp;oacute; anteriormente, cambiar las especificaciones de los hijos no afecta los procesos de los hijos existentes. Las nuevas especificaciones secundarias se agregan autom&amp;aacute;ticamente, pero no se eliminan. Los procesos secundarios no se inician ni terminan autom&amp;aacute;ticamente, esto debe hacerse usando las instrucciones de &lt;code&gt;apply&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bab58f9f01e2ec9b0aff4a10808faf716038fb5e" translate="yes" xml:space="preserve">
          <source>As stated earlier, instruction &lt;code&gt;restart_new_emulator&lt;/code&gt; causes the emulator to be restarted with new versions of ERTS&amp;gt;, Kernel, STDLIB, and SASL. However, all other applications do at startup run their old versions in this new emulator. This is usually no problem, but every now and then incompatible changes occur to the core applications, which can cause trouble in this setting. Such incompatible changes (when functions are removed) are normally preceded by a deprecation over two major releases. To ensure that your application is not crashed by an incompatible change, always remove any call to deprecated functions as soon as possible.</source>
          <target state="translated">Como se indic&amp;oacute; anteriormente, la instrucci&amp;oacute;n &lt;code&gt;restart_new_emulator&lt;/code&gt; hace que el emulador se reinicie con nuevas versiones de ERTS&amp;gt;, Kernel, STDLIB y SASL. Sin embargo, todas las dem&amp;aacute;s aplicaciones al inicio ejecutan sus versiones anteriores en este nuevo emulador. Por lo general, esto no es un problema, pero de vez en cuando se producen cambios incompatibles en las aplicaciones principales, que pueden causar problemas en esta configuraci&amp;oacute;n. Estos cambios incompatibles (cuando se eliminan funciones) normalmente est&amp;aacute;n precedidos por una desaprobaci&amp;oacute;n en dos versiones principales. Para asegurarse de que su aplicaci&amp;oacute;n no se bloquee por un cambio incompatible, siempre elimine cualquier llamada a funciones obsoletas lo antes posible.</target>
        </trans-unit>
        <trans-unit id="d2f8b1ba1c67fb67671d7cb5d1f4c6ff846076c9" translate="yes" xml:space="preserve">
          <source>As stated earlier, the order of the instructions is important. When upgrading, &lt;code&gt;m1&lt;/code&gt; must be loaded, and the supervisor child specification changed, before the new child process can be started. When downgrading, the child process must be terminated before the child specification is changed and the module is deleted.</source>
          <target state="translated">Como se indic&amp;oacute; anteriormente, el orden de las instrucciones es importante. Al actualizar, se debe cargar &lt;code&gt;m1&lt;/code&gt; y cambiar la especificaci&amp;oacute;n del hijo supervisor antes de que se pueda iniciar el nuevo proceso hijo. Al degradar, el proceso secundario debe terminarse antes de que se cambie la especificaci&amp;oacute;n secundaria y se elimine el m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="b7ff2d94dd69653efaa6f0e2b153be55d281f264" translate="yes" xml:space="preserve">
          <source>As such a client cannot read a new &lt;code&gt;start_erl.data&lt;/code&gt; file (the file cannot be changed dynamically). The boot and config files are always fetched from the same place (but with new contents if a new release has been installed).</source>
          <target state="translated">Como tal, un cliente no puede leer un nuevo archivo &lt;code&gt;start_erl.data&lt;/code&gt; (el archivo no se puede cambiar din&amp;aacute;micamente). Los archivos de arranque y configuraci&amp;oacute;n siempre se obtienen del mismo lugar (pero con contenido nuevo si se ha instalado una nueva versi&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="1714bc6ebf672752fb654342a2c562571522eab2" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;++&lt;/code&gt; operator copies its left operand, the result is copied repeatedly, leading to quadratic complexity.</source>
          <target state="translated">A medida que el operador &lt;code&gt;++&lt;/code&gt; copia su operando izquierdo, el resultado se copia repetidamente, lo que genera una complejidad cuadr&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="2e226d4cd051311bceb315b8997b69c3409b32fc" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;add_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">Como el procedimiento &lt;code&gt;add_frag&lt;/code&gt; es parte de una transacci&amp;oacute;n de esquema, Mnesia adquiere bloqueos de escritura en las tablas afectadas. Es decir, tanto los fragmentos correspondientes a &lt;code&gt;IterFrags&lt;/code&gt; como los correspondientes a &lt;code&gt;AdditionalLockFrags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f8afd221610cfbc0c004b3e80d9cc06e7451e3b4" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;address&lt;/code&gt; field was omitted, its default value is used.</source>
          <target state="translated">Como se omiti&amp;oacute; el campo de &lt;code&gt;address&lt;/code&gt; , se usa su valor predeterminado.</target>
        </trans-unit>
        <trans-unit id="13444681318a2f85bf718682f9be9c04d867f14f" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;del_frag&lt;/code&gt; procedure is a part of a schema transaction, Mnesia acquires write locks on the affected tables. That is, both the fragments corresponding to &lt;code&gt;IterFrags&lt;/code&gt; and those corresponding to &lt;code&gt;AdditionalLockFrags&lt;/code&gt;.</source>
          <target state="translated">Como el procedimiento &lt;code&gt;del_frag&lt;/code&gt; es parte de una transacci&amp;oacute;n de esquema, Mnesia adquiere bloqueos de escritura en las tablas afectadas. Es decir, tanto los fragmentos correspondientes a &lt;code&gt;IterFrags&lt;/code&gt; como los correspondientes a &lt;code&gt;AdditionalLockFrags&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="996b8c87675fcbf684c10ebd80b9cfdfdf3cae34" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;total&lt;/code&gt; value is the sum of &lt;code&gt;processes&lt;/code&gt; and &lt;code&gt;system&lt;/code&gt;, the error in &lt;code&gt;system&lt;/code&gt; propagates to the &lt;code&gt;total&lt;/code&gt; value.</source>
          <target state="translated">Como el valor &lt;code&gt;total&lt;/code&gt; es la suma de &lt;code&gt;processes&lt;/code&gt; y &lt;code&gt;system&lt;/code&gt; , el error en el &lt;code&gt;system&lt;/code&gt; propaga al valor &lt;code&gt;total&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4195fa76015f84a5df8be91ff120efd14a713307" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application is dependent on third party products there are a few administrative things that needs to be done before you can get things up and running.</source>
          <target state="translated">Como la aplicación ODBC de Erlang depende de productos de terceros,hay algunas cosas administrativas que deben hacerse antes de que puedas poner las cosas en marcha.</target>
        </trans-unit>
        <trans-unit id="20c8404a5de3c59614d50e29989cfead97f57ced" translate="yes" xml:space="preserve">
          <source>As the Erlang ODBC application relies on third party products and communicates with a database that probably runs on another computer in the network there are plenty of things that might go wrong. To fully understand the things that might happen it facilitate to know the design of the Erlang ODBC application, hence here follows a short description of the current design.</source>
          <target state="translated">Como la aplicación ODBC de Erlang depende de productos de terceros y se comunica con una base de datos que probablemente se ejecuta en otro ordenador de la red,hay muchas cosas que pueden salir mal.Para entender completamente las cosas que podrían suceder es fácil conocer el diseño de la aplicación ODBC de Erlang,por lo tanto aquí sigue una breve descripción del diseño actual.</target>
        </trans-unit>
        <trans-unit id="3558041c42459c9de0de1dcf3a8814d6434e5a6c" translate="yes" xml:space="preserve">
          <source>As the UTF-8 encoding is widely spread and provides some backward compatibility in the 7-bit ASCII range, it is selected as the standard encoding for Unicode characters in binaries for Erlang.</source>
          <target state="translated">Como la codificación UTF-8 está muy extendida y proporciona cierta compatibilidad con el rango ASCII de 7 bits,se selecciona como la codificación estándar para los caracteres Unicode en binarios para Erlang.</target>
        </trans-unit>
        <trans-unit id="bdb9f25861a28ac570dd99575f72b2d8ad54d3fa" translate="yes" xml:space="preserve">
          <source>As the driver is a shared module, not a program, no main function is present. All function pointers are not used in this example, and the corresponding fields in the &lt;code&gt;driver_entry&lt;/code&gt; structure are set to NULL.</source>
          <target state="translated">Como el controlador es un m&amp;oacute;dulo compartido, no un programa, no existe ninguna funci&amp;oacute;n principal. En este ejemplo no se utilizan todos los punteros de funci&amp;oacute;n y los campos correspondientes de la estructura &lt;code&gt;driver_entry&lt;/code&gt; se establecen en NULL.</target>
        </trans-unit>
        <trans-unit id="8406821028c9ff87cf4b1f089c352e4449600154" translate="yes" xml:space="preserve">
          <source>As the execution and structure of the match specifications are like that of a fun, it is more straightforward to write it using the familiar fun syntax and to have that translated into a match specification automatically. A real fun is clearly more powerful than the match specifications allow, but bearing the match specifications in mind, and what they can do, it is still more convenient to write it all as a fun. This module contains the code that translates the fun syntax into match specification terms.</source>
          <target state="translated">Como la ejecución y la estructura de las especificaciones de los fósforos son como las de una diversión,es más sencillo escribirlas utilizando la conocida sintaxis de la diversión y hacer que se traduzcan automáticamente en una especificación de los fósforos.Una verdadera diversión es claramente más poderosa de lo que permiten las especificaciones de los partidos,pero teniendo en cuenta las especificaciones de los partidos,y lo que pueden hacer,es aún más conveniente escribirlo todo como una diversión.Este módulo contiene el código que traduce la sintaxis de la diversión en términos de especificación de coincidencias.</target>
        </trans-unit>
        <trans-unit id="500258296a887dd562c74c1baf7dab1768136ec5" translate="yes" xml:space="preserve">
          <source>As the execution of the test suites proceed, events are logged in the following four different ways:</source>
          <target state="translated">A medida que se ejecutan las suites de prueba,los eventos se registran de cuatro maneras diferentes:</target>
        </trans-unit>
        <trans-unit id="d51e39f06d97806b242fd21b87f9a687999b2271" translate="yes" xml:space="preserve">
          <source>As the high bit of the first two atoms in the cache are not set we know that they are already in the cache, so they do not have to be sent again (this is the node name of the receiving and sending node). Then follows the atoms that have to be sent, together with their segment ids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b99f096c11009199607e528c1ab4fde76715836" translate="yes" xml:space="preserve">
          <source>As the message is an &lt;code&gt;ETERM&lt;/code&gt; struct, Erl_Interface functions can be used to manipulate it. In this case, the message becomes a 3-tuple, because that is how the Erlang code is written. The second element will be the pid of the caller and the third element will be the tuple &lt;code&gt;{Function,Arg}&lt;/code&gt; determining which function to call, and with which argument. The result of calling the function is made into an &lt;code&gt;ETERM&lt;/code&gt; struct as well and sent back to Erlang using &lt;code&gt;erl_send()&lt;/code&gt;, which takes the open file descriptor, a pid, and a term as arguments:</source>
          <target state="translated">Como el mensaje es una estructura &lt;code&gt;ETERM&lt;/code&gt; , las funciones Erl_Interface se pueden usar para manipularlo. En este caso, el mensaje se convierte en una tupla de 3, porque as&amp;iacute; es como se escribe el c&amp;oacute;digo Erlang. El segundo elemento ser&amp;aacute; el pid del llamador y el tercer elemento ser&amp;aacute; la tupla &lt;code&gt;{Function,Arg}&lt;/code&gt; que determina qu&amp;eacute; funci&amp;oacute;n llamar y con qu&amp;eacute; argumento. El resultado de llamar a la funci&amp;oacute;n tambi&amp;eacute;n se convierte en una estructura &lt;code&gt;ETERM&lt;/code&gt; y se env&amp;iacute;a de vuelta a Erlang usando &lt;code&gt;erl_send()&lt;/code&gt; , que toma el descriptor de archivo abierto, un pid y un t&amp;eacute;rmino como argumentos:</target>
        </trans-unit>
        <trans-unit id="7146c7ac731941ac40a19a992206ba27e74fa230" translate="yes" xml:space="preserve">
          <source>As the position is specified as a byte-offset, take special caution when working with files where &lt;code&gt;encoding&lt;/code&gt; is set to something else than &lt;code&gt;latin1&lt;/code&gt;, as not every byte position is a valid character boundary on such a file.</source>
          <target state="translated">Como la posici&amp;oacute;n se especifica como un byte-offset, tenga especial cuidado cuando trabaje con archivos donde la &lt;code&gt;encoding&lt;/code&gt; se establece en algo diferente a &lt;code&gt;latin1&lt;/code&gt; , ya que no cada posici&amp;oacute;n de byte es un l&amp;iacute;mite de car&amp;aacute;cter v&amp;aacute;lido en dicho archivo.</target>
        </trans-unit>
        <trans-unit id="f76a9267a5d5f392fb58b458fb3bf07880270ba9" translate="yes" xml:space="preserve">
          <source>As the runtime system handles the optimization (instead of the compiler), there are very few circumstances in which the optimization does not work.</source>
          <target state="translated">Como el sistema de tiempo de ejecución se encarga de la optimización (en lugar del compilador),hay muy pocas circunstancias en las que la optimización no funcione.</target>
        </trans-unit>
        <trans-unit id="b697dde1f8ec4fdc0c53e1bd6391f4323555d01f" translate="yes" xml:space="preserve">
          <source>As the source code is distributed, it can easily be modified to accept other options. The program must still accept option &lt;code&gt;-data&lt;/code&gt; with the semantics described above for the release handler to work correctly.</source>
          <target state="translated">A medida que se distribuye el c&amp;oacute;digo fuente, se puede modificar f&amp;aacute;cilmente para aceptar otras opciones. El programa a&amp;uacute;n debe aceptar la opci&amp;oacute;n &lt;code&gt;-data&lt;/code&gt; con la sem&amp;aacute;ntica descrita anteriormente para que el controlador de versiones funcione correctamente.</target>
        </trans-unit>
        <trans-unit id="8795a3307568900a68fbd017733b56af3116954b" translate="yes" xml:space="preserve">
          <source>As the time offset is not allowed to change, time correction must adjust the frequency of the Erlang monotonic clock to align Erlang system time with OS system time smoothly. A significant downside of this approach is that we on purpose will use a faulty frequency on the Erlang monotonic clock if adjustments are needed. This error can be as large as 1%. This error will show up in all time measurements in the runtime system.</source>
          <target state="translated">Como no se permite cambiar el desfase horario,la corrección de tiempo debe ajustar la frecuencia del reloj monótono de Erlang para alinear la hora del sistema Erlang con la hora del sistema OS sin problemas.Una desventaja significativa de este enfoque es que a propósito usaremos una frecuencia defectuosa en el reloj monótono de Erlang si es necesario hacer ajustes.Este error puede ser tan grande como el 1%.Este error aparecerá en todas las mediciones de tiempo en el sistema de tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="c394e9d8956e53ffa12dda34b51f038d61fe77cf" translate="yes" xml:space="preserve">
          <source>As the two alternatives are inside a &lt;code&gt;(?|&lt;/code&gt; group, both sets of capturing parentheses are numbered one. Thus, when the pattern matches, you can look at captured substring number one, whichever alternative matched. This construct is useful when you want to capture a part, but not all, of one of many alternatives. Inside a &lt;code&gt;(?|&lt;/code&gt; group, parentheses are numbered as usual, but the number is reset at the start of each branch. The numbers of any capturing parentheses that follow the subpattern start after the highest number used in any branch. The following example is from the Perl documentation; the numbers underneath show in which buffer the captured content is stored:</source>
          <target state="translated">Como las dos alternativas est&amp;aacute;n dentro de un grupo &lt;code&gt;(?|&lt;/code&gt; , Ambos conjuntos de par&amp;eacute;ntesis de captura se numeran como uno. Por lo tanto, cuando el patr&amp;oacute;n coincide, puede observar la subcadena n&amp;uacute;mero uno capturada, cualquiera que sea la alternativa que coincida. Esta construcci&amp;oacute;n es &amp;uacute;til cuando desea capturar una parte, pero no todas, de una de las muchas alternativas. Dentro de un grupo &lt;code&gt;(?|&lt;/code&gt; , los par&amp;eacute;ntesis se numeran como de costumbre, pero el n&amp;uacute;mero se restablece al comienzo de cada rama. Los n&amp;uacute;meros de los par&amp;eacute;ntesis de captura que siguen al subpatr&amp;oacute;n comienzan despu&amp;eacute;s de el n&amp;uacute;mero m&amp;aacute;s alto usado en cualquier rama. El siguiente ejemplo es de la documentaci&amp;oacute;n de Perl; los n&amp;uacute;meros debajo muestran en qu&amp;eacute; b&amp;uacute;fer se almacena el contenido capturado:</target>
        </trans-unit>
        <trans-unit id="6b1ff2bd85ad93af178cdc629f19b070b543117b" translate="yes" xml:space="preserve">
          <source>As there can be many capturing parentheses in a pattern, all digits following the backslash are taken as part of a potential back reference number. If the pattern continues with a digit character, some delimiter must be used to terminate the back reference. If option &lt;code&gt;extended&lt;/code&gt; is set, this can be whitespace. Otherwise an empty comment (see section &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt;) can be used.</source>
          <target state="translated">Como puede haber muchos par&amp;eacute;ntesis de captura en un patr&amp;oacute;n, todos los d&amp;iacute;gitos que siguen a la barra invertida se toman como parte de un n&amp;uacute;mero de referencia posterior potencial. Si el patr&amp;oacute;n contin&amp;uacute;a con un car&amp;aacute;cter de d&amp;iacute;gito, se debe usar alg&amp;uacute;n delimitador para terminar la referencia inversa. Si se establece la opci&amp;oacute;n &lt;code&gt;extended&lt;/code&gt; , esto puede ser un espacio en blanco. De lo contrario, se puede utilizar un comentario vac&amp;iacute;o (consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#sect19&quot;&gt;Comments&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a74c4cf2304eafd1772e4800b2c34ab0218b1011" translate="yes" xml:space="preserve">
          <source>As there is no matching subexpression for the last part in the example (the &quot;g&quot;), nothing is inserted after that. To make the group of strings and the parts matching the subexpressions more obvious, one can use option &lt;code&gt;group&lt;/code&gt;, which groups together the part of the subject string with the parts matching the subexpressions when the string was split:</source>
          <target state="translated">Como no hay subexpresi&amp;oacute;n coincidente para la &amp;uacute;ltima parte del ejemplo (la &quot;g&quot;), no se inserta nada despu&amp;eacute;s de eso. Para hacer que el grupo de cadenas y las partes que coinciden con las subexpresiones sean m&amp;aacute;s obvias, se puede usar el &lt;code&gt;group&lt;/code&gt; opciones , que agrupa la parte de la cadena del sujeto con las partes que coinciden con las subexpresiones cuando se dividi&amp;oacute; la cadena:</target>
        </trans-unit>
        <trans-unit id="9e2c8ed56878a9d0ce4d6f8c64f1107a4ec68580" translate="yes" xml:space="preserve">
          <source>As these are the C library, the same limitations apply.</source>
          <target state="translated">Como se trata de la biblioteca C,se aplican las mismas limitaciones.</target>
        </trans-unit>
        <trans-unit id="c163dd9740f51616c09627b0819df111304b0a64" translate="yes" xml:space="preserve">
          <source>As this interface implies that ports are killed when the last user disappears, the function does not hang waiting for ports to get closed.</source>
          <target state="translated">Como esta interfaz implica que los puertos se matan cuando el último usuario desaparece,la función no se cuelga esperando que los puertos se cierren.</target>
        </trans-unit>
        <trans-unit id="e0d70780a73e5bd4165a4b0dfafa2579d2f5f128" translate="yes" xml:space="preserve">
          <source>As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of &lt;code&gt;Options&lt;/code&gt; that control the warnings are only described in the &lt;code&gt; compile(3)&lt;/code&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="269a4f9e2c4144f24e95fc48fbc36000ea30889f" translate="yes" xml:space="preserve">
          <source>As this module is of interest only to the maintainers of the compiler, and to avoid the same description in two places, the elements of &lt;code&gt;Options&lt;/code&gt; that control the warnings are only described in the &lt;code&gt;compile(3)&lt;/code&gt; module.</source>
          <target state="translated">Como este m&amp;oacute;dulo es de inter&amp;eacute;s solo para los mantenedores del compilador, y para evitar la misma descripci&amp;oacute;n en dos lugares, los elementos de &lt;code&gt;Options&lt;/code&gt; que controlan las advertencias solo se describen en el m&amp;oacute;dulo &lt;code&gt;compile(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4808daf64c94ffd2d15ac09bfa7bb9ffab8a8096" translate="yes" xml:space="preserve">
          <source>As was mentioned before, the graph analyses operate on the &lt;code&gt;digraph&lt;/code&gt; representation of graphs. By default, the &lt;code&gt;digraph&lt;/code&gt; representation is created when needed (and deleted when no longer used), but it can also be created explicitly by use of the &lt;code&gt;closure&lt;/code&gt; operator:</source>
          <target state="translated">Como se mencion&amp;oacute; antes, los an&amp;aacute;lisis gr&amp;aacute;fico operan en el &lt;code&gt;digraph&lt;/code&gt; representaci&amp;oacute;n de gr&amp;aacute;ficos. De forma predeterminada, la representaci&amp;oacute;n del &lt;code&gt;digraph&lt;/code&gt; se crea cuando se necesita (y se elimina cuando ya no se usa), pero tambi&amp;eacute;n se puede crear expl&amp;iacute;citamente mediante el uso del operador de &lt;code&gt;closure&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="08da2b535fd9c3da81a12df0eca527a12e4f65fc" translate="yes" xml:space="preserve">
          <source>As was mentioned in the previous section, &lt;code&gt;start_erl&lt;/code&gt; requires a &lt;code&gt;sys.config&lt;/code&gt; in the release version directory (&lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt;). If there is no such file, the system start fails. Such a file must therefore also be added.</source>
          <target state="translated">Como se mencion&amp;oacute; en la secci&amp;oacute;n anterior, &lt;code&gt;start_erl&lt;/code&gt; requiere un &lt;code&gt;sys.config&lt;/code&gt; en el directorio de la versi&amp;oacute;n de lanzamiento ( &lt;code&gt;&quot;releases/FIRST/sys.config&quot;&lt;/code&gt; ). Si no existe tal archivo, el inicio del sistema falla. Por lo tanto, tambi&amp;eacute;n debe agregarse dicho archivo.</target>
        </trans-unit>
        <trans-unit id="ec4d55429ba417e5335bd49e46c6d6d7ae28aa98" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt; enif_make_resource&lt;/a&gt;&lt;/code&gt;, no ownership transfer is done. The resource still needs to be released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt; enif_release_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f5cac0dfe306d70277c63b5386d001ed67533ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt;, no ownership transfer is done. The resource still needs to be released with &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Al igual que con &lt;code&gt;&lt;a href=&quot;#enif_make_resource&quot;&gt;enif_make_resource&lt;/a&gt;&lt;/code&gt; , no se realiza ninguna transferencia de propiedad. El recurso a&amp;uacute;n debe liberarse con &lt;code&gt;&lt;a href=&quot;#enif_release_resource&quot;&gt;enif_release_resource&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86dd8791c9b5f5dca561254006fe497e2d3994c7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt;: use with extreme care.</source>
          <target state="translated">Al igual que con &lt;code&gt;erlang:send_nosuspend/2,3&lt;/code&gt; : util&amp;iacute;celo con sumo cuidado.</target>
        </trans-unit>
        <trans-unit id="efe69f566993703e5412e0783db54d43802e91bd" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;run/3&lt;/code&gt;, compilation errors raise the &lt;code&gt;badarg&lt;/code&gt; exception. &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; can be used to get more information about the error.</source>
          <target state="translated">Al igual que con &lt;code&gt;run/3&lt;/code&gt; , los errores de compilaci&amp;oacute;n &lt;code&gt;badarg&lt;/code&gt; excepci&amp;oacute;n badarg . &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; se puede utilizar para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el error.</target>
        </trans-unit>
        <trans-unit id="65ddbc78ec2288effbfbc27dc2887832b0da7683" translate="yes" xml:space="preserve">
          <source>As with all other functions starting with &lt;code&gt;ei_&lt;/code&gt;, you are &lt;strong&gt;not&lt;/strong&gt; expected to put the socket in non-blocking mode yourself in the program. Every use of non-blocking mode is embedded inside the time-out functions. The socket will always be back in blocking mode after the operations are completed (regardless of the result). To avoid problems, leave the socket options alone. &lt;code&gt;ei&lt;/code&gt; handles any socket options that need modification.</source>
          <target state="translated">Al igual que con todas las dem&amp;aacute;s funciones a partir de &lt;code&gt;ei_&lt;/code&gt; , que est&amp;aacute; &lt;strong&gt;no&lt;/strong&gt; espera que pongan la toma en modo de no bloqueo a s&amp;iacute; mismo en el programa. Cada uso del modo sin bloqueo est&amp;aacute; integrado dentro de las funciones de tiempo de espera. El socket siempre volver&amp;aacute; a estar en modo de bloqueo despu&amp;eacute;s de que se completen las operaciones (independientemente del resultado). Para evitar problemas, deje las opciones de socket en paz. &lt;code&gt;ei&lt;/code&gt; maneja cualquier opci&amp;oacute;n de socket que necesite modificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9f18e260b234899264f52d7e455efafe8a0b767f" translate="yes" xml:space="preserve">
          <source>As with dynamically added child processes, the effects of deleting a static child process are lost if the supervisor itself restarts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3c8339b0d633ff7f739e39a8bb36a1648a7db29" translate="yes" xml:space="preserve">
          <source>As with dynamically added child processes, the effects of deleting a static child process is lost if the supervisor itself restarts.</source>
          <target state="translated">Al igual que con los procesos infantiles dinámicos,los efectos de la eliminación de un proceso infantil estático se pierden si el propio supervisor se reinicia.</target>
        </trans-unit>
        <trans-unit id="ec50db8f3e13bb5768f12bc8a6a3b1ddcd9124a9" translate="yes" xml:space="preserve">
          <source>As with normal tree structures, lookup (membership testing), insertion, and deletion have logarithmic complexity.</source>
          <target state="translated">Al igual que con las estructuras normales de los árboles,la búsqueda (prueba de adhesión),la inserción y la eliminación tienen una complejidad logarítmica.</target>
        </trans-unit>
        <trans-unit id="96a345435dd16a7fc2f73434205466252ddf7e39" translate="yes" xml:space="preserve">
          <source>As with process monitors, each driver monitor set only generates &lt;strong&gt;one single message&lt;/strong&gt;. The monitor is &quot;destroyed&quot; after the message is sent, so it is then not needed to call &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Al igual que con los monitores de proceso, cada conjunto de monitores de controlador solo genera &lt;strong&gt;un &amp;uacute;nico mensaje&lt;/strong&gt; . El monitor se &quot;destruye&quot; despu&amp;eacute;s de que se env&amp;iacute;a el mensaje, por lo que no es necesario llamar a &lt;code&gt;&lt;a href=&quot;#demonitor-1&quot;&gt;demonitor/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7211803cb34fb7ce9f0ec3a041a6c83ef73def40" translate="yes" xml:space="preserve">
          <source>As with processes we wanted to be able to do the most fundamental operations without having to acquire a lock on it. The most important being able to determine if we should enqueue a process in a specific run queue or not. This involves being able to read actual load, and load balancing information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2467dbec656f95127f4a0e7d30ecc8a6ad6234f" translate="yes" xml:space="preserve">
          <source>As you can see by the example, the function can be called from the shell too. The &lt;code&gt;fun()&lt;/code&gt; needs to be literally in the call when used from the shell as well. Other means than the parse_transform are used in the shell case, but more or less the same restrictions apply (the exception being records, as they are not handled by the shell).</source>
          <target state="translated">Como puede ver en el ejemplo, la funci&amp;oacute;n tambi&amp;eacute;n se puede llamar desde el shell. El &lt;code&gt;fun()&lt;/code&gt; debe estar literalmente en la llamada cuando se usa tambi&amp;eacute;n desde el shell. En el caso de shell se utilizan otros medios adem&amp;aacute;s de parse_transform, pero se aplican m&amp;aacute;s o menos las mismas restricciones (la excepci&amp;oacute;n son los registros, ya que no son manejados por el shell).</target>
        </trans-unit>
        <trans-unit id="2b8232bbed24ef8f629ce1816536b7c03bfad7c6" translate="yes" xml:space="preserve">
          <source>As you can understand from the illustration, &lt;code&gt;Common Test&lt;/code&gt; requires a test case to generate a runtime error to indicate failure (for example, by causing a bad match error or by calling &lt;code&gt;exit/1&lt;/code&gt;, preferably through the help function &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt;). A successful execution is indicated by a normal return from the test case function.</source>
          <target state="translated">Como puede comprender en la ilustraci&amp;oacute;n, &lt;code&gt;Common Test&lt;/code&gt; requiere un caso de prueba para generar un error de tiempo de ejecuci&amp;oacute;n para indicar una falla (por ejemplo, al causar un error de coincidencia incorrecta o al llamar a &lt;code&gt;exit/1&lt;/code&gt; , preferiblemente a trav&amp;eacute;s de la funci&amp;oacute;n de ayuda &lt;code&gt;&lt;a href=&quot;ct#fail-1&quot;&gt;ct:fail/1,2&lt;/a&gt;&lt;/code&gt; ). Una ejecuci&amp;oacute;n exitosa se indica mediante un retorno normal de la funci&amp;oacute;n de caso de prueba.</target>
        </trans-unit>
        <trans-unit id="1d0f02291e9385ef819c0f808420bd9d22f20f88" translate="yes" xml:space="preserve">
          <source>As you have seen in the previous chapter, a standard URI can only contain a strict subset of the US ASCII character set, moreover the allowed set of characters is not the same in the different URI components. Percent-encoding is a mechanism to represent a data octet in a component when that octet's corresponding character is outside of the allowed set or is being used as a delimiter. This is what you see when &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; is encoded as &lt;code&gt;%C3%B6&lt;/code&gt; and &lt;code&gt;space&lt;/code&gt; as &lt;code&gt;%20&lt;/code&gt;. Most of the API functions are expecting UTF-8 encoding when handling percent-encoded triplets. The UTF-8 encoding of the &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; character &lt;code&gt;&quot;&amp;ouml;&quot;&lt;/code&gt; is two octets: &lt;code&gt;OxC3 0xB6&lt;/code&gt;. The character &lt;code&gt;space&lt;/code&gt; is in the first 128 characters of &lt;code&gt;&lt;a href=&quot;unicode_usage#what-unicode-is&quot;&gt;Unicode&lt;/a&gt;&lt;/code&gt; and it is encoded using a single octet &lt;code&gt;0x20&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b635d527fabae96e027fa225db3c0e9bac328ef" translate="yes" xml:space="preserve">
          <source>As you have seen, it is possible to use the &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; functions explicitly. By using those functions you can write your own trace client that reads trace data from any source stored in any format and just feed the &lt;code&gt;Collector&lt;/code&gt; with it. You may replace the default &lt;code&gt;Collector Filter&lt;/code&gt; with a filter that converts new exciting trace data formats to &lt;code&gt;Event Records&lt;/code&gt; or you may convert it to an &lt;code&gt;Event Record&lt;/code&gt; before you invoke &lt;code&gt;et_collector:report/2&lt;/code&gt; and then rely on the default &lt;code&gt;Collector Filter&lt;/code&gt; to handle the new format.</source>
          <target state="translated">Como ha visto, es posible utilizar expl&amp;iacute;citamente las funciones &lt;code&gt;et_collector:report_event/5,6&lt;/code&gt; . Al usar esas funciones, puede escribir su propio cliente de seguimiento que lea los datos de seguimiento de cualquier fuente almacenada en cualquier formato y simplemente alimente al &lt;code&gt;Collector&lt;/code&gt; con ellos. Puede reemplazar el &lt;code&gt;Collector Filter&lt;/code&gt; predeterminado con un filtro que convierte nuevos y emocionantes formatos de datos de seguimiento en registros de &lt;code&gt;Event Records&lt;/code&gt; o puede convertirlo en un &lt;code&gt;Event Record&lt;/code&gt; antes de invocar &lt;code&gt;et_collector:report/2&lt;/code&gt; y luego confiar en el &lt;code&gt;Collector Filter&lt;/code&gt; predeterminado para manejar el nuevo formato .</target>
        </trans-unit>
        <trans-unit id="d261c2679b68d55f3f5768006262a218d859a604" translate="yes" xml:space="preserve">
          <source>Ask them to transform the internal state format and switch to the new version of the module.</source>
          <target state="translated">Pídeles que transformen el formato de estado interno y cambien a la nueva versión del módulo.</target>
        </trans-unit>
        <trans-unit id="7ccd30300261a4eca3d0f1af0fcf77d29e731e3c" translate="yes" xml:space="preserve">
          <source>Asking for and inspecting raw socket options require low-level information about the current operating system and TCP stack.</source>
          <target state="translated">Pedir e inspeccionar opciones de enchufes sin procesar requiere información de bajo nivel sobre el sistema operativo actual y la pila de TCP.</target>
        </trans-unit>
        <trans-unit id="f8fa830a1c76cc3d9b64640309d56c10ee2a5f9a" translate="yes" xml:space="preserve">
          <source>Asks the remote server of &lt;code&gt;ConnectionRef&lt;/code&gt; to listen to &lt;code&gt;ListenHost:ListenPort&lt;/code&gt;. When someone connects that address, the connection is forwarded in an encrypted channel from the server to the client. The client (that is, at the node that calls this function) then connects to &lt;code&gt;ConnectToHost:ConnectToPort&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0599d793007329beb80221bb5065e2bf255ef6e5" translate="yes" xml:space="preserve">
          <source>Assert end of string (or line, in multiline mode)</source>
          <target state="translated">Afirmar el final de la cadena (o línea,en modo multilínea)</target>
        </trans-unit>
        <trans-unit id="cf59339e55d5c656acd77a3516f63cf3ff15de3e" translate="yes" xml:space="preserve">
          <source>Assert start of string (or line, in multiline mode)</source>
          <target state="translated">Afirmar el inicio de la cadena (o línea,en modo multilínea)</target>
        </trans-unit>
        <trans-unit id="18d329141ee34e40c36d7b169bb7a159eb5aeb08" translate="yes" xml:space="preserve">
          <source>Assertion subpatterns are not capturing subpatterns. If such an assertion contains capturing subpatterns within it, these are counted for the purposes of numbering the capturing subpatterns in the whole pattern. However, substring capturing is done only for positive assertions. (Perl sometimes, but not always, performs capturing in negative assertions.)</source>
          <target state="translated">Los subpatrones de afirmación no están capturando subpatrones.Si tal afirmación contiene subpatrones de captura dentro de ella,éstos se cuentan a efectos de numerar los subpatrones de captura en el patrón completo.Sin embargo,la captura de subcadenas se hace sólo para afirmaciones positivas.(Perl a veces,pero no siempre,realiza la captura en afirmaciones negativas).</target>
        </trans-unit>
        <trans-unit id="dc3e91b0be656a68c41466178566755f49840e06" translate="yes" xml:space="preserve">
          <source>Assertions can be nested in any combination. For example, the following matches an occurrence of &quot;baz&quot; that is preceded by &quot;bar&quot;, which in turn is not preceded by &quot;foo&quot;:</source>
          <target state="translated">Las afirmaciones pueden anidarse en cualquier combinación.Por ejemplo,lo siguiente corresponde a una ocurrencia de &quot;baz&quot; que está precedida por &quot;bar&quot;,que a su vez no está precedida por &quot;foo&quot;:</target>
        </trans-unit>
        <trans-unit id="8383a156cd04a5d92aafffd1ec55eeaa8e37c727" translate="yes" xml:space="preserve">
          <source>Assigning a value to type &lt;code&gt;Operational&lt;/code&gt; in Erlang is possible by using the following Erlang code:</source>
          <target state="translated">Es posible asignar un valor al tipo &lt;code&gt;Operational&lt;/code&gt; en Erlang utilizando el siguiente c&amp;oacute;digo Erlang:</target>
        </trans-unit>
        <trans-unit id="4ad8afb43e64d75a730687d995308551590810c9" translate="yes" xml:space="preserve">
          <source>Assignment ::= Variable &lt;code&gt;:=&lt;/code&gt; Expression | Variable &lt;code&gt;=&lt;/code&gt; Expression</source>
          <target state="translated">Asignaci&amp;oacute;n :: = Variable &lt;code&gt;:=&lt;/code&gt; Expresi&amp;oacute;n | Variable &lt;code&gt;=&lt;/code&gt; Expresi&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="7585e904a125702314b9a3cc974072554cd19dc1" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. Same implementation as &lt;code&gt;&lt;a href=&quot;gen_udp#controlling_process-2&quot;&gt;gen_udp:controlling_process/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31732955b5b879b8595ccb4012494c26bfc62323" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. Same implementation as &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt;.</source>
          <target state="translated">Asigna un nuevo proceso de control &lt;code&gt;Pid&lt;/code&gt; a &lt;code&gt;Socket&lt;/code&gt; . Misma implementaci&amp;oacute;n que &lt;code&gt;gen_udp:controlling_process/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="750263088fcf3a705a426666d4ba4253060235cc" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process &lt;code&gt;Pid&lt;/code&gt; to &lt;code&gt;Socket&lt;/code&gt;. The controlling process is the process that receives messages from the socket. If called by any other process than the current controlling process, &lt;code&gt;{error, not_owner}&lt;/code&gt; is returned. If the process identified by &lt;code&gt;Pid&lt;/code&gt; is not an existing local pid, &lt;code&gt;{error, badarg}&lt;/code&gt; is returned. &lt;code&gt;{error, badarg}&lt;/code&gt; may also be returned in some cases when &lt;code&gt;Socket&lt;/code&gt; is closed during the execution of this function.</source>
          <target state="translated">Asigna un nuevo proceso de control &lt;code&gt;Pid&lt;/code&gt; a &lt;code&gt;Socket&lt;/code&gt; . El proceso de control es el proceso que recibe mensajes del socket. Si lo llama cualquier otro proceso que no sea el proceso de control actual &lt;code&gt;{error, not_owner}&lt;/code&gt; . Si el proceso identificado por &lt;code&gt;Pid&lt;/code&gt; no es un pid local existente &lt;code&gt;{error, badarg}&lt;/code&gt; . &lt;code&gt;{error, badarg}&lt;/code&gt; tambi&amp;eacute;n puede devolverse en algunos casos cuando &lt;code&gt;Socket&lt;/code&gt; se cierra durante la ejecuci&amp;oacute;n de esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="83e6ee60d090046ec0df21d8f20b308779b0123e" translate="yes" xml:space="preserve">
          <source>Assigns a new controlling process to the SSL socket. A controlling process is the owner of an SSL socket, and receives all messages from the socket.</source>
          <target state="translated">Asigna un nuevo proceso de control al socket SSL.Un proceso controlador es el propietario de un socket SSL,y recibe todos los mensajes del socket.</target>
        </trans-unit>
        <trans-unit id="e2015efa67c45a84e357363963f8ef7cc19116af" translate="yes" xml:space="preserve">
          <source>Associate a result set containing the whole table &lt;code&gt;EMPLOYEE&lt;/code&gt; to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">Asocie un conjunto de resultados que contenga toda la tabla &lt;code&gt;EMPLOYEE&lt;/code&gt; a la conexi&amp;oacute;n. Se devuelve el n&amp;uacute;mero de filas del conjunto de resultados.</target>
        </trans-unit>
        <trans-unit id="c01c817bd8220a9e426732586a19782a2ec8dae2" translate="yes" xml:space="preserve">
          <source>Associate a result set that contains the fields &lt;code&gt;FIRSTNAME&lt;/code&gt; and &lt;code&gt;NR&lt;/code&gt; for all female employees to the connection. The number of rows in the result set is returned.</source>
          <target state="translated">Asocie un conjunto de resultados que contenga los campos &lt;code&gt;FIRSTNAME&lt;/code&gt; y &lt;code&gt;NR&lt;/code&gt; para todas las empleadas a la conexi&amp;oacute;n. Se devuelve el n&amp;uacute;mero de filas del conjunto de resultados.</target>
        </trans-unit>
        <trans-unit id="e682a3847cd3fad46ea3e5c2bf3acec87c695369" translate="yes" xml:space="preserve">
          <source>Associates &lt;code&gt;Key&lt;/code&gt; with value &lt;code&gt;Value&lt;/code&gt; and inserts the association into map &lt;code&gt;Map2&lt;/code&gt;. If key &lt;code&gt;Key&lt;/code&gt; already exists in map &lt;code&gt;Map1&lt;/code&gt;, the old associated value is replaced by value &lt;code&gt;Value&lt;/code&gt;. The function returns a new map &lt;code&gt;Map2&lt;/code&gt; containing the new association and the old associations in &lt;code&gt;Map1&lt;/code&gt;.</source>
          <target state="translated">Asocia la &lt;code&gt;Key&lt;/code&gt; con el valor &lt;code&gt;Value&lt;/code&gt; e inserta la asociaci&amp;oacute;n en el mapa &lt;code&gt;Map2&lt;/code&gt; . Si la clave &lt;code&gt;Key&lt;/code&gt; ya existe en el mapa &lt;code&gt;Map1&lt;/code&gt; , el antiguo valor asociado se reemplaza por el valor &lt;code&gt;Value&lt;/code&gt; . La funci&amp;oacute;n devuelve un nuevo mapa &lt;code&gt;Map2&lt;/code&gt; que contiene la nueva asociaci&amp;oacute;n y las asociaciones antiguas en &lt;code&gt;Map1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fe25fda4b17970a0ef529403d3f726c24aae538c" translate="yes" xml:space="preserve">
          <source>Associates a UDP port number (&lt;code&gt;Port&lt;/code&gt;) with the calling process.</source>
          <target state="translated">Asocia un n&amp;uacute;mero de puerto UDP ( &lt;code&gt;Port&lt;/code&gt; ) con el proceso de llamada.</target>
        </trans-unit>
        <trans-unit id="f1f8648a03de87c0a9794d9b8e650c32fee361c7" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;Name&lt;/code&gt;, an atom, with the process &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Asocia el nombre &lt;code&gt;Name&lt;/code&gt; , un &amp;aacute;tomo, con el proceso &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="adba476945469569c82884884c1c62b87ee5beca" translate="yes" xml:space="preserve">
          <source>Associates the name &lt;code&gt;RegName&lt;/code&gt; with a process identifier (pid) or a port identifier. &lt;code&gt;RegName&lt;/code&gt;, which must be an atom, can be used instead of the pid or port identifier in send operator (&lt;code&gt;RegName ! Message&lt;/code&gt;). Example:</source>
          <target state="translated">Asocia el nombre &lt;code&gt;RegName&lt;/code&gt; con un identificador de proceso (pid) o un identificador de puerto. &lt;code&gt;RegName&lt;/code&gt; , que debe ser un &amp;aacute;tomo, se puede usar en lugar del pid o identificador de puerto en el operador de env&amp;iacute;o ( &lt;code&gt;RegName ! Message&lt;/code&gt; ). Ejemplo:</target>
        </trans-unit>
        <trans-unit id="41bb0af24396833201992ca15a0ccfba7ee7f093" translate="yes" xml:space="preserve">
          <source>Associates the test run with a name that gets printed in the overview HTML log files.</source>
          <target state="translated">Asocia la ejecución de la prueba con un nombre que se imprime en los archivos de registro HTML de resumen.</target>
        </trans-unit>
        <trans-unit id="98d38dc74b49e5a78d0c258ce1027deadc489dd0" translate="yes" xml:space="preserve">
          <source>Association File</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="437c9a7c9031d1af11bb4c9c4f2d1cfe844e612f" translate="yes" xml:space="preserve">
          <source>Association Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a929bb502012d59c211ba29e792fdfc1bcec65b6" translate="yes" xml:space="preserve">
          <source>Association is successfully established. This indicates a successful completion of &lt;code&gt;connect&lt;/code&gt;.</source>
          <target state="translated">La asociaci&amp;oacute;n se establece con &amp;eacute;xito. Esto indica una finalizaci&amp;oacute;n exitosa de la &lt;code&gt;connect&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="134d6b41e63f8d58f043111b94e89dcdbcc5edb8" translate="yes" xml:space="preserve">
          <source>Associations</source>
          <target state="translated">Associations</target>
        </trans-unit>
        <trans-unit id="9517f720a79af71f615e7adc80ef320ce8b35b80" translate="yes" xml:space="preserve">
          <source>Assume a test that generates some parallel stateful commands, and runs 300 tests:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd321e5d28d57fcf199c5a0fe6ae644a0f00e982" translate="yes" xml:space="preserve">
          <source>Assume that a module is extended by adding an interface function, as in the example in &lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt;, where a function &lt;code&gt;available/0&lt;/code&gt; is added to &lt;code&gt;ch3&lt;/code&gt;.</source>
          <target state="translated">Suponga que un m&amp;oacute;dulo se extiende agregando una funci&amp;oacute;n de interfaz, como en el ejemplo de &lt;code&gt;&lt;a href=&quot;release_handling#appup&quot;&gt;Release Handling&lt;/a&gt;&lt;/code&gt; , donde se agrega una funci&amp;oacute;n &lt;code&gt;available/0&lt;/code&gt; a &lt;code&gt;ch3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81e67a14a83897861024d39ef25a7c52fdc905a0" translate="yes" xml:space="preserve">
          <source>Assume that a test case for the following program should be verified:</source>
          <target state="translated">Supongamos que un caso de prueba para el siguiente programa debe ser verificado:</target>
        </trans-unit>
        <trans-unit id="71a8953ab141a80996cc4c7f627c6481c2d38dca" translate="yes" xml:space="preserve">
          <source>Assume that a user does not want Erlang to use the native lookup method, but wants Erlang to read all information necessary from start and use that for resolving names and addresses. If lookup fails, Erlang is to request the data from a nameserver (using the Erlang DNS client, set to use EDNS allowing larger responses). The resolver configuration is updated when its configuration file changes. Also, DNS records are never to be cached. The user configuration file (in this example named &lt;code&gt;erl_inetrc&lt;/code&gt;, stored in directory &lt;code&gt;./cfg_files&lt;/code&gt;) can then look as follows (Unix):</source>
          <target state="translated">Suponga que un usuario no quiere que Erlang use el m&amp;eacute;todo de b&amp;uacute;squeda nativo, pero quiere que Erlang lea toda la informaci&amp;oacute;n necesaria desde el principio y la use para resolver nombres y direcciones. Si la b&amp;uacute;squeda falla, Erlang debe solicitar los datos de un servidor de nombres (usando el cliente DNS de Erlang, configurado para usar EDNS permitiendo respuestas m&amp;aacute;s grandes). La configuraci&amp;oacute;n del resolutor se actualiza cuando cambia su archivo de configuraci&amp;oacute;n. Adem&amp;aacute;s, los registros DNS nunca deben almacenarse en cach&amp;eacute;. El archivo de configuraci&amp;oacute;n del usuario (en este ejemplo llamado &lt;code&gt;erl_inetrc&lt;/code&gt; , almacenado en el directorio &lt;code&gt;./cfg_files&lt;/code&gt; ) puede tener el siguiente aspecto (Unix):</target>
        </trans-unit>
        <trans-unit id="2d48df2f1a8f0fd07793d2b425e8df418ef5bfad" translate="yes" xml:space="preserve">
          <source>Assume that nothing happens when tracing in this way. The function is never called with these parameters. We conclude that someone else (some other module) is doing it and realize that we must trace on &lt;code&gt;ets:insert/2&lt;/code&gt; and want to see the calling function. The calling function can be retrieved using the match specification function &lt;code&gt;caller&lt;/code&gt;. To get it into the trace message, the match specification function &lt;code&gt;message&lt;/code&gt; must be used. The filter call looks like this (looking for calls to &lt;code&gt;ets:insert/2&lt;/code&gt;):</source>
          <target state="translated">Suponga que no sucede nada al rastrear de esta manera. La funci&amp;oacute;n nunca se llama con estos par&amp;aacute;metros. Concluimos que alguien m&amp;aacute;s (alg&amp;uacute;n otro m&amp;oacute;dulo) lo est&amp;aacute; haciendo y nos damos cuenta de que debemos rastrear en &lt;code&gt;ets:insert/2&lt;/code&gt; y queremos ver la funci&amp;oacute;n de llamada. La funci&amp;oacute;n de llamada se puede recuperar utilizando el &lt;code&gt;caller&lt;/code&gt; funci&amp;oacute;n de especificaci&amp;oacute;n de coincidencia . Para incluirlo en el mensaje de seguimiento, se debe utilizar el &lt;code&gt;message&lt;/code&gt; funci&amp;oacute;n de especificaci&amp;oacute;n de coincidencia . La llamada de filtro se ve as&amp;iacute; (buscando llamadas a &lt;code&gt;ets:insert/2&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="997882ed021f898e3c4711038cfd690fedaa8231" translate="yes" xml:space="preserve">
          <source>Assume that the module now passes all testing and goes into the system. After a while, it is found that table &lt;code&gt;toy_table&lt;/code&gt; grows while the system is running and that there are many elements with atoms as keys. We expected only integer keys and so does the rest of the system, but clearly not the entire system. We turn on call tracing and try to see calls to the module with an atom as the key:</source>
          <target state="translated">Suponga que el m&amp;oacute;dulo pasa ahora todas las pruebas y entra en el sistema. Despu&amp;eacute;s de un tiempo, se encuentra que table &lt;code&gt;toy_table&lt;/code&gt; crece mientras el sistema est&amp;aacute; funcionando y que hay muchos elementos con &amp;aacute;tomos como claves. Solo esper&amp;aacute;bamos claves enteras y tambi&amp;eacute;n el resto del sistema, pero claramente no todo el sistema. Activamos el rastreo de llamadas e intentamos ver las llamadas al m&amp;oacute;dulo con un &amp;aacute;tomo como clave:</target>
        </trans-unit>
        <trans-unit id="f89a940266dfec94c78b06cb601b527f92f04417" translate="yes" xml:space="preserve">
          <source>Assume that the suite contains the test case &lt;code&gt;get_resource_status&lt;/code&gt; that is independent of the other two cases, then function &lt;code&gt;all&lt;/code&gt; can look as follows:</source>
          <target state="translated">Suponga que la suite contiene el caso de prueba &lt;code&gt;get_resource_status&lt;/code&gt; que es independiente de los otros dos casos, entonces &lt;code&gt;all&lt;/code&gt; funciones pueden verse de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="d831964edca879d5d90599f59a999703ad024ad1" translate="yes" xml:space="preserve">
          <source>Assume that there are two systems, &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt;, that are tested in separate test runs. System &lt;code&gt;s1&lt;/code&gt; contains a library module &lt;code&gt;m1&lt;/code&gt; tested by test run &lt;code&gt;s1&lt;/code&gt; and is included in the cover specification of &lt;code&gt;s1&lt;/code&gt; as follows:</source>
          <target state="translated">Suponga que hay dos sistemas, &lt;code&gt;s1&lt;/code&gt; y &lt;code&gt;s2&lt;/code&gt; , que se prueban en ejecuciones de prueba separadas. El sistema &lt;code&gt;s1&lt;/code&gt; contiene un m&amp;oacute;dulo de biblioteca &lt;code&gt;m1&lt;/code&gt; probado por la ejecuci&amp;oacute;n de prueba &lt;code&gt;s1&lt;/code&gt; y se incluye en la especificaci&amp;oacute;n de portada de &lt;code&gt;s1&lt;/code&gt; de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0a42279cd9be030fbaa5a2fcc34c767220fae2bb" translate="yes" xml:space="preserve">
          <source>Assume that there is a network application that receives instances of the ASN.1 defined type &lt;code&gt;Person&lt;/code&gt;, modifies, and sends them back again:</source>
          <target state="translated">Suponga que hay una aplicaci&amp;oacute;n de red que recibe instancias del tipo definido en ASN.1 &lt;code&gt;Person&lt;/code&gt; , las modifica y las env&amp;iacute;a de regreso:</target>
        </trans-unit>
        <trans-unit id="33069b991dada2eb5da77ef53b4f64ef6b97abaa" translate="yes" xml:space="preserve">
          <source>Assume that there is an index on position &lt;code&gt;Pos&lt;/code&gt; for a certain record type. This function can be used to read the records without knowing the actual key for the record. For example, with an index in position 1 of table &lt;code&gt;person&lt;/code&gt;, the call &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; returns a list of all persons with age 36. &lt;code&gt;Pos&lt;/code&gt; can also be an attribute name (atom), but if the notation &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; is used, the field position is searched for in runtime, for each call.</source>
          <target state="translated">Suponga que existe un &amp;iacute;ndice en la posici&amp;oacute;n &lt;code&gt;Pos&lt;/code&gt; para un cierto tipo de registro. Esta funci&amp;oacute;n se puede utilizar para leer los registros sin conocer la clave real del registro. Por ejemplo, con un &amp;iacute;ndice en la posici&amp;oacute;n 1 de la tabla &lt;code&gt;person&lt;/code&gt; , la llamada &lt;code&gt;mnesia:index_read(person, 36, #person.age)&lt;/code&gt; devuelve una lista de todas las personas con 36 a&amp;ntilde;os de edad. &lt;code&gt;Pos&lt;/code&gt; tambi&amp;eacute;n puede ser un nombre de atributo (&amp;aacute;tomo), pero si se &lt;code&gt;mnesia:index_read(person, 36, age)&lt;/code&gt; la notaci&amp;oacute;n mnesia: index_read (persona, 36 a&amp;ntilde;os, edad) , se busca la posici&amp;oacute;n del campo en tiempo de ejecuci&amp;oacute;n, para cada llamada.</target>
        </trans-unit>
        <trans-unit id="829ce164f6e9881978858a93ac53473e3de7a2fe" translate="yes" xml:space="preserve">
          <source>Assume that we have not found the problem yet, and want to see what &lt;code&gt;ets:new/2&lt;/code&gt; returns. We use a slightly different trace pattern:</source>
          <target state="translated">Supongamos que a&amp;uacute;n no hemos encontrado el problema y queremos ver qu&amp;eacute; devuelve &lt;code&gt;ets:new/2&lt;/code&gt; . Usamos un patr&amp;oacute;n de rastreo ligeramente diferente:</target>
        </trans-unit>
        <trans-unit id="58d7492d43f93e533d2fc8b2893194dfb95c91d5" translate="yes" xml:space="preserve">
          <source>Assume that we want the whole object matching instead of only one element. One alternative is to assign a variable to every part of the record and build it up once again in the body of the fun, but the following is easier:</source>
          <target state="translated">Supongamos que queremos que todo el objeto coincida en lugar de un solo elemento.Una alternativa es asignar una variable a cada parte del registro y construirla una vez más en el cuerpo de la diversión,pero lo siguiente es más fácil:</target>
        </trans-unit>
        <trans-unit id="d1bf62160b9303fd32fdad0cd34b9da4d1aef481" translate="yes" xml:space="preserve">
          <source>Assume that we want to get all the employee numbers of employees hired before year 2000. Using &lt;code&gt;ets:match/2&lt;/code&gt; is not an alternative here, as relational operators cannot be expressed there. Once again, &lt;code&gt;ets:foldr/3&lt;/code&gt; can do it (slowly, but correct):</source>
          <target state="translated">Suponga que queremos obtener todos los n&amp;uacute;meros de empleados contratados antes del a&amp;ntilde;o 2000. El uso de &lt;code&gt;ets:match/2&lt;/code&gt; no es una alternativa aqu&amp;iacute;, ya que los operadores relacionales no se pueden expresar all&amp;iacute;. Una vez m&amp;aacute;s, &lt;code&gt;ets:foldr/3&lt;/code&gt; puede hacerlo (lento, pero correcto):</target>
        </trans-unit>
        <trans-unit id="35f82a62b9c069adc233b8d62c83260928f4ae7a" translate="yes" xml:space="preserve">
          <source>Assume that we want to test the lists:sort/1 function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ba39d9d328d97a989e24d8ac3124b4d21b0636f" translate="yes" xml:space="preserve">
          <source>Assume that you have an initiating process with &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; like this:</source>
          <target state="translated">Suponga que tiene un proceso de inicio con &lt;code&gt;Pid == &amp;lt;0.30.0&amp;gt;&lt;/code&gt; como este:</target>
        </trans-unit>
        <trans-unit id="59beb2deb0d2bf3ac19ece9f2db7b475398662e6" translate="yes" xml:space="preserve">
          <source>Assume that you want to calculate the factorial for 1:</source>
          <target state="translated">Suponga que quiere calcular el factorial para 1:</target>
        </trans-unit>
        <trans-unit id="81e6855c42a523802dad6f1c6e5e336c4662d743" translate="yes" xml:space="preserve">
          <source>Assume that you want to transform the &lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; document to HTML. If you want the same structure and tags of the resulting HTML document as of the XML document then you can use the &lt;code&gt;xmerl:export/2&lt;/code&gt; function. The following:</source>
          <target state="translated">Suponga que desea transformar el documento &lt;code&gt;&lt;a href=&quot;#motorcyclesxml&quot;&gt;motorcycles.xml&lt;/a&gt;&lt;/code&gt; a HTML. Si desea la misma estructura y etiquetas del documento HTML resultante que el documento XML, puede usar la funci&amp;oacute;n &lt;code&gt;xmerl:export/2&lt;/code&gt; . El seguimiento:</target>
        </trans-unit>
        <trans-unit id="42a5d8a52feabf03d2cc601350c97037810f3131" translate="yes" xml:space="preserve">
          <source>Assume the following:</source>
          <target state="translated">Supongamos lo siguiente:</target>
        </trans-unit>
        <trans-unit id="b4dd172e924a451d443d3ebe731fdc5eb7eae97d" translate="yes" xml:space="preserve">
          <source>Assume we want to check the following module:</source>
          <target state="translated">Supongamos que queremos comprobar el siguiente módulo:</target>
        </trans-unit>
        <trans-unit id="a1917e9bb4b3ba3244f0149508301240f3ef84a5" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each location &lt;code&gt;L&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">Asume que &lt;code&gt;Term&lt;/code&gt; es un t&amp;eacute;rmino con la misma estructura que un &amp;aacute;rbol &lt;code&gt;erl_parse&lt;/code&gt; , pero con &lt;code&gt;&lt;a href=&quot;erl_anno#type-location&quot;&gt;locations&lt;/a&gt;&lt;/code&gt; donde un &amp;aacute;rbol &lt;code&gt;erl_parse&lt;/code&gt; tiene colecciones de anotaciones. Devuelve un &amp;aacute;rbol &lt;code&gt;erl_parse&lt;/code&gt; donde cada ubicaci&amp;oacute;n &lt;code&gt;L&lt;/code&gt; se reemplaza por el valor devuelto por &lt;code&gt;&lt;a href=&quot;erl_anno#new-1&quot;&gt;erl_anno:new(L)&lt;/a&gt;&lt;/code&gt; . El t&amp;eacute;rmino &lt;code&gt;Term&lt;/code&gt; se recorre en profundidad primero, de izquierda a derecha.</target>
        </trans-unit>
        <trans-unit id="d66afe8dfdd48d923747ad2c5c5b06df8c1510d8" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with terms, say &lt;code&gt;T&lt;/code&gt;, where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each term &lt;code&gt;T&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt; erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7cafb7be7f1db85e6934ccfbc9df1141dff9353" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;Term&lt;/code&gt; is a term with the same structure as a &lt;code&gt;erl_parse&lt;/code&gt; tree, but with terms, say &lt;code&gt;T&lt;/code&gt;, where a &lt;code&gt;erl_parse&lt;/code&gt; tree has collections of annotations. Returns a &lt;code&gt;erl_parse&lt;/code&gt; tree where each term &lt;code&gt;T&lt;/code&gt; is replaced by the value returned by &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt;. The term &lt;code&gt;Term&lt;/code&gt; is traversed in a depth-first, left-to-right fashion.</source>
          <target state="translated">Supone que &lt;code&gt;Term&lt;/code&gt; es un t&amp;eacute;rmino con la misma estructura que un &amp;aacute;rbol &lt;code&gt;erl_parse&lt;/code&gt; , pero con t&amp;eacute;rminos, digamos &lt;code&gt;T&lt;/code&gt; , donde un &amp;aacute;rbol &lt;code&gt;erl_parse&lt;/code&gt; tiene colecciones de anotaciones. Devuelve un &amp;aacute;rbol &lt;code&gt;erl_parse&lt;/code&gt; donde cada t&amp;eacute;rmino &lt;code&gt;T&lt;/code&gt; se reemplaza por el valor devuelto por &lt;code&gt;&lt;a href=&quot;erl_anno#from_term-1&quot;&gt;erl_anno:from_term(T)&lt;/a&gt;&lt;/code&gt; . El t&amp;eacute;rmino &lt;code&gt;Term&lt;/code&gt; se recorre en profundidad primero, de izquierda a derecha.</target>
        </trans-unit>
        <trans-unit id="0867c9c6c98bb1857eef83b5370df89b6931896a" translate="yes" xml:space="preserve">
          <source>Assuming &lt;code&gt;Forms&lt;/code&gt; represents a program (or any sequence of &quot;program forms&quot;), any comments whose first lines are not directly associated with a specific program form will become standalone comments inserted between the neighbouring program forms. Furthermore, comments whose column position is less than or equal to one will not be attached to a program form that begins at a conflicting line number (this can happen with preprocessor-generated &lt;code&gt;line&lt;/code&gt;-attributes).</source>
          <target state="translated">Suponiendo que &lt;code&gt;Forms&lt;/code&gt; represente un programa (o cualquier secuencia de &quot;formularios de programa&quot;), cualquier comentario cuyas primeras l&amp;iacute;neas no est&amp;eacute;n directamente asociadas con un formulario de programa espec&amp;iacute;fico se convertir&amp;aacute;n en comentarios independientes insertados entre los formularios de programa vecinos. Adem&amp;aacute;s, los comentarios cuya posici&amp;oacute;n de columna sea menor o igual a uno no se adjuntar&amp;aacute;n a un formulario de programa que comience en un n&amp;uacute;mero de l&amp;iacute;nea en conflicto (esto puede suceder con atributos de &lt;code&gt;line&lt;/code&gt; generados por el preprocesador).</target>
        </trans-unit>
        <trans-unit id="85756eb2ccf84d68d4412ebf0e79850cfd5d276b" translate="yes" xml:space="preserve">
          <source>Assuming an Erlang system called ping (but not the &quot;ping&quot; process) has already been started on kosken, then on gollum this is done:</source>
          <target state="translated">Asumiendo que un sistema Erlang llamado ping (pero no el proceso de &quot;ping&quot;)ya se ha iniciado en el kosken,entonces en el gollum esto se hace:</target>
        </trans-unit>
        <trans-unit id="10a82aabb0e61cdb059228faa6975a490d22e3b9" translate="yes" xml:space="preserve">
          <source>Assuming an Ets table that uses &lt;code&gt;idno&lt;/code&gt; as key and contains the following:</source>
          <target state="translated">Suponiendo una tabla de Ets que usa &lt;code&gt;idno&lt;/code&gt; como clave y contiene lo siguiente:</target>
        </trans-unit>
        <trans-unit id="18d8e312811328614a25350d0eb0a85b61ed61f9" translate="yes" xml:space="preserve">
          <source>Assuming that both the arguments and the results from the C functions are less than 256, a simple encoding/decoding scheme is employed. In this scheme, &lt;code&gt;foo&lt;/code&gt; is represented by byte 1, &lt;code&gt;bar&lt;/code&gt; is represented by 2, and the argument/result is represented by a single byte as well:</source>
          <target state="translated">Suponiendo que tanto los argumentos como los resultados de las funciones C son menores que 256, se emplea un esquema de codificaci&amp;oacute;n / decodificaci&amp;oacute;n simple. En este esquema, &lt;code&gt;foo&lt;/code&gt; est&amp;aacute; representado por el byte 1, &lt;code&gt;bar&lt;/code&gt; est&amp;aacute; representado por 2 y el argumento / resultado tambi&amp;eacute;n est&amp;aacute; representado por un solo byte:</target>
        </trans-unit>
        <trans-unit id="a66845ce6e93230866ff8e0772d20b4798a32003" translate="yes" xml:space="preserve">
          <source>Assuming that environment variables has been correctly set, a strings containing valid characters on the specific OS for environment variable names and values using &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; encoding. The first &lt;code&gt;$=&lt;/code&gt; characters appearing in the string separates environment variable name (on the left) from environment variable value (on the right).</source>
          <target state="translated">Suponiendo que las variables de entorno se hayan configurado correctamente, cadenas que contienen caracteres v&amp;aacute;lidos en el sistema operativo espec&amp;iacute;fico para los nombres y valores de las variables de entorno utilizando la codificaci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;file#native_name_encoding-0&quot;&gt;file:native_name_encoding()&lt;/a&gt;&lt;/code&gt; . Los primeros caracteres &lt;code&gt;$=&lt;/code&gt; que aparecen en la cadena separan el nombre de la variable de entorno (a la izquierda) del valor de la variable de entorno (a la derecha).</target>
        </trans-unit>
        <trans-unit id="0a6f58980048155b748b7c9405f322e65c5a9184" translate="yes" xml:space="preserve">
          <source>Assuming that the call to &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; does not find any schema to read on the disc, &lt;code&gt;Mnesia&lt;/code&gt; starts as a disc-less node, and then change it to a node that use the disc to store the schema locally.</source>
          <target state="translated">Suponiendo que la llamada a &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start/0&lt;/a&gt;&lt;/code&gt; no encuentra ning&amp;uacute;n esquema para leer en el disco, &lt;code&gt;Mnesia&lt;/code&gt; comienza como un nodo sin disco y luego lo cambia a un nodo que usa el disco para almacenar el esquema localmente.</target>
        </trans-unit>
        <trans-unit id="d6872420cefd05df68dce4eed3bc63d15db4f598" translate="yes" xml:space="preserve">
          <source>Assuming that the node has been started as follows:</source>
          <target state="translated">Asumiendo que el nodo se ha iniciado de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="51630ab3cd71a8b020a5db0bc163d0f23a13638c" translate="yes" xml:space="preserve">
          <source>Assuming that the thread progress functionality is efficient, a lot of algorithms can both be simplified and made more efficient than using the first approach that comes to mind. A couple of examples follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8499608ce735317421447e4bbbb5e480084db254" translate="yes" xml:space="preserve">
          <source>Assuming that these requirements are fulfilled, time correction is enabled, and OS system time is adjusted using a time adjustment protocol such as NTP, only small adjustments of Erlang monotonic time are needed to keep system times aligned after finalization. As long as the system is not suspended, the largest adjustments needed are for inserted (or deleted) leap seconds.</source>
          <target state="translated">Suponiendo que se cumplan estos requisitos,se habilite la corrección de tiempo y se ajuste la hora del sistema operativo mediante un protocolo de ajuste de tiempo como el NTP,sólo se necesitan pequeños ajustes del tiempo monótono de Erlang para mantener alineados los tiempos del sistema después de la finalización.Mientras no se suspenda el sistema,los mayores ajustes necesarios son para los segundos bisiestos insertados (o borrados).</target>
        </trans-unit>
        <trans-unit id="03367feb887591c7e80f18fd1145673d7dcffe3e" translate="yes" xml:space="preserve">
          <source>Assuming that these types are exported from module &lt;code&gt;'mod'&lt;/code&gt;, you can refer to them from other modules using remote type expressions like the following:</source>
          <target state="translated">Suponiendo que estos tipos se exportan desde el m&amp;oacute;dulo &lt;code&gt;'mod'&lt;/code&gt; , puede consultarlos desde otros m&amp;oacute;dulos utilizando expresiones de tipo remoto como las siguientes:</target>
        </trans-unit>
        <trans-unit id="13fa45ba7f2afed612bcb3c59e68416368c08493" translate="yes" xml:space="preserve">
          <source>Assuming that we spawn fewer processes than the maximum amount of unique process identifiers in the system, one has always been able to determine the order of process creation just by comparing process identifiers. If PidX is larger than PidY, then PidX was created after PidY assuming both identifiers originates from the same node. However, since we have a quite limited amount of unique identifiers today (2^28), this property cannot be relied upon if we create large amount of processes. But never the less, this is a property the system always have had.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26267ff052ff06ed2dce21d69453c5f440474929" translate="yes" xml:space="preserve">
          <source>Assuming that we want the employee numbers of everyone in the sales department, there are several ways.</source>
          <target state="translated">Asumiendo que queremos el número de empleados de todos en el departamento de ventas,hay varias maneras.</target>
        </trans-unit>
        <trans-unit id="266f66badd0d0b518b2e5df463ab8847e52c02bb" translate="yes" xml:space="preserve">
          <source>Assuming the &lt;code&gt;.rel file&lt;/code&gt; is stored in a file &lt;code&gt;start_ssl.rel&lt;/code&gt; in the current directory, a boot script can be built as follows:</source>
          <target state="translated">Suponiendo que el &lt;code&gt;.rel file&lt;/code&gt; se almacena en un archivo &lt;code&gt;start_ssl.rel&lt;/code&gt; en el directorio actual, se puede construir un script de arranque de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="6fce84ccb66529fc8ed6e1c0f38776816b583ca0" translate="yes" xml:space="preserve">
          <source>Assuming the same &lt;code&gt;CLIENTDIR&lt;/code&gt; as above, the last line is to look like:</source>
          <target state="translated">Suponiendo el mismo &lt;code&gt;CLIENTDIR&lt;/code&gt; que el anterior, la &amp;uacute;ltima l&amp;iacute;nea se ver&amp;aacute; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="3a0c79afff9d3483a1ae5e8cbc8205664dba4b83" translate="yes" xml:space="preserve">
          <source>Assuming there is an operational target system with installation root directory &lt;code&gt;$ROOT&lt;/code&gt;, the release package with the new version of the release is to be copied to &lt;code&gt;$ROOT/releases&lt;/code&gt;.</source>
          <target state="translated">Suponiendo que hay un sistema de destino operativo con el directorio ra&amp;iacute;z de instalaci&amp;oacute;n &lt;code&gt;$ROOT&lt;/code&gt; , el paquete de lanzamiento con la nueva versi&amp;oacute;n del lanzamiento se copiar&amp;aacute; en &lt;code&gt;$ROOT/releases&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d7c30a0e4666f7264a0489fe55f811dceafac52d" translate="yes" xml:space="preserve">
          <source>Assuming these definitions:</source>
          <target state="translated">Asumiendo estas definiciones:</target>
        </trans-unit>
        <trans-unit id="c8b26ebcc3e9bf5dbba85fc702138c186d9e4f8c" translate="yes" xml:space="preserve">
          <source>Assures that literals have a compact representation. This is occasionally useful if &lt;code&gt;c_cons_skel/2&lt;/code&gt;, &lt;code&gt;c_tuple_skel/1&lt;/code&gt; or &lt;code&gt;unfold_literal/1&lt;/code&gt; were used in the construction of &lt;code&gt;Node&lt;/code&gt;, and you want to revert to the normal &quot;folded&quot; representation of literals. If &lt;code&gt;Node&lt;/code&gt; represents a tuple or list constructor, its elements are rewritten recursively, and the node is reconstructed using &lt;code&gt;c_cons/2&lt;/code&gt; or &lt;code&gt;c_tuple/1&lt;/code&gt;, respectively; otherwise, &lt;code&gt;Node&lt;/code&gt; is not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa99efafd6c95c8611da8fa8895116da74ab832" translate="yes" xml:space="preserve">
          <source>Assures that literals have a fully expanded representation. If &lt;code&gt;Node&lt;/code&gt; represents a literal tuple or list constructor, its elements are rewritten recursively, and the node is reconstructed using &lt;code&gt;c_cons_skel/2&lt;/code&gt; or &lt;code&gt;c_tuple_skel/1&lt;/code&gt;, respectively; otherwise, &lt;code&gt;Node&lt;/code&gt; is not changed. The &lt;code&gt;&lt;a href=&quot;#fold_literal-1&quot;&gt;fold_literal/1&lt;/a&gt;&lt;/code&gt; can be used to revert to the normal compact representation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f4b10ac30756395c83923e7cf3c7d80acae92175" translate="yes" xml:space="preserve">
          <source>Async queue length is not defined for &lt;code&gt;put&lt;/code&gt; operations.</source>
          <target state="translated">La longitud de la cola as&amp;iacute;ncrona no est&amp;aacute; definida para operaciones de &lt;code&gt;put&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3988dd15a01716f5457aa8c6239f3feeb9605755" translate="yes" xml:space="preserve">
          <source>Async threads are used by various linked-in drivers (mainly the file drivers) do offload non-CPU intensive work. See &lt;code&gt;erl +A&lt;/code&gt; for more details.</source>
          <target state="translated">Los subprocesos as&amp;iacute;ncronos son utilizados por varios controladores vinculados (principalmente los controladores de archivo) que descargan el trabajo que no requiere un uso intensivo de la CPU. Consulte &lt;code&gt;erl +A&lt;/code&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="1f2ff86b0c85c68964cf97af02073f12b82e6dee" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-bulk-request&lt;/code&gt; (See RFC1905).</source>
          <target state="translated">&lt;code&gt;get-bulk-request&lt;/code&gt; asincr&amp;oacute;nica (consulte RFC1905).</target>
        </trans-unit>
        <trans-unit id="3284d2626e5dc0e20ecd8465f9256541f56870e5" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-next-request&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get-next-request&lt;/code&gt; asincr&amp;oacute;nico .</target>
        </trans-unit>
        <trans-unit id="ce12675017eba1aad96dc4af8158e8ade8a6e141" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;get-request&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;get-request&lt;/code&gt; asincr&amp;oacute;nica .</target>
        </trans-unit>
        <trans-unit id="07690d2c187b7cfafc60389b63d0ee62b7cd3c1c" translate="yes" xml:space="preserve">
          <source>Asynchronous &lt;code&gt;set-request&lt;/code&gt;.</source>
          <target state="translated">&lt;code&gt;set-request&lt;/code&gt; as&amp;iacute;ncrona .</target>
        </trans-unit>
        <trans-unit id="5c7ffbaa8ef4ef8420694da665321a4afef34039" translate="yes" xml:space="preserve">
          <source>Asynchronous calls</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c4f45c7554c3415b2762a3d8f5669acc6525702" translate="yes" xml:space="preserve">
          <source>Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be able to deliver the reply (when it arrives) to the proper destination. If the reply arrives, this info will be deleted. But if there is no reply (in time), the info has to be deleted after the &lt;strong&gt;best before&lt;/strong&gt; time has been passed. This cleanup will be performed at regular intervals, defined by the &lt;code&gt;server_timeout()&lt;/code&gt; time. The information will have a &lt;strong&gt;best before&lt;/strong&gt; time, defined by the &lt;code&gt;Expire&lt;/code&gt; time given when calling the request function (see &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Tiempo de limpieza de solicitudes asincr&amp;oacute;nicas. Para cada solicitud, cierta informaci&amp;oacute;n se almacena internamente, para poder entregar la respuesta (cuando llegue) al destino adecuado. Si llega la respuesta, esta informaci&amp;oacute;n se eliminar&amp;aacute;. Pero si no hay respuesta (en el tiempo), la informaci&amp;oacute;n tiene que ser eliminado despu&amp;eacute;s de que el &lt;strong&gt;mejor antes&lt;/strong&gt; se ha pasado el tiempo. Esta limpieza se realizar&amp;aacute; a intervalos regulares, definidos por el tiempo &lt;code&gt;server_timeout()&lt;/code&gt; . La informaci&amp;oacute;n tendr&amp;aacute; un &lt;strong&gt;mejor&lt;/strong&gt; tiempo &lt;strong&gt;antes&lt;/strong&gt; , definido por el tiempo de &lt;code&gt;Expire&lt;/code&gt; dado al llamar a la funci&amp;oacute;n de solicitud (ver &lt;code&gt;&lt;a href=&quot;snmpm#async_get&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;snmpm#async_set&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="56364b7086d1002ef3358c7012d8995780475b16" translate="yes" xml:space="preserve">
          <source>Asynchronous request cleanup time. For every requests, some info is stored internally, in order to be able to deliver the reply (when it arrives) to the proper destination. If the reply arrives, this info will be deleted. But if there is no reply (in time), the info has to be deleted after the &lt;strong&gt;best before&lt;/strong&gt; time has been passed. This cleanup will be performed at regular intervals, defined by the &lt;code&gt;server_timeout()&lt;/code&gt; time. The information will have a &lt;strong&gt;best before&lt;/strong&gt; time, defined by the &lt;code&gt;Expire&lt;/code&gt; time given when calling the request function (see &lt;code&gt;&lt;a href=&quot;snmpm#async_get2&quot;&gt;async_get&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;snmpm#async_get_next2&quot;&gt;async_get_next&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;snmpm#async_set2&quot;&gt;async_set&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f4ef40b42e8c28e77390dcc6fa14ba97907a734" translate="yes" xml:space="preserve">
          <source>Asynchronous request for cancellation. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the cancellation to be performed synchronously. When &lt;code&gt;Async&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, the cancel operation is performed asynchronously. That is, &lt;code&gt;cancel_timer()&lt;/code&gt; sends an asynchronous request for cancellation to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;.</source>
          <target state="translated">Solicitud de cancelaci&amp;oacute;n asincr&amp;oacute;nica. &lt;code&gt;Async&lt;/code&gt; tiene el valor predeterminado &lt;code&gt;false&lt;/code&gt; , lo que hace que la cancelaci&amp;oacute;n se realice de forma sincr&amp;oacute;nica. Cuando &lt;code&gt;Async&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , la operaci&amp;oacute;n de cancelaci&amp;oacute;n se realiza de forma asincr&amp;oacute;nica. Es decir, &lt;code&gt;cancel_timer()&lt;/code&gt; env&amp;iacute;a una solicitud asincr&amp;oacute;nica de cancelaci&amp;oacute;n al servicio de temporizador que administra el temporizador y luego devuelve &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="95fd03b1444c479be3c52aee359cb2dfca32c856" translate="yes" xml:space="preserve">
          <source>Asynchronous request for state information. &lt;code&gt;Async&lt;/code&gt; defaults to &lt;code&gt;false&lt;/code&gt;, which causes the operation to be performed synchronously. In this case, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:read_timer&lt;/code&gt;. When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;erlang:read_timer&lt;/code&gt; sends an asynchronous request for the state information to the timer service that manages the timer, and then returns &lt;code&gt;ok&lt;/code&gt;. A message on the format &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:read_timer&lt;/code&gt; when the operation has been processed.</source>
          <target state="translated">Solicitud asincr&amp;oacute;nica de informaci&amp;oacute;n estatal. &lt;code&gt;Async&lt;/code&gt; predeterminado de Async es &lt;code&gt;false&lt;/code&gt; , lo que hace que la operaci&amp;oacute;n se realice de forma sincr&amp;oacute;nica. En este caso, el &lt;code&gt;Result&lt;/code&gt; es devuelto por &lt;code&gt;erlang:read_timer&lt;/code&gt; . Cuando &lt;code&gt;Async&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , &lt;code&gt;erlang:read_timer&lt;/code&gt; env&amp;iacute;a una solicitud asincr&amp;oacute;nica para la informaci&amp;oacute;n de estado al servicio de temporizador que administra el temporizador y luego devuelve &lt;code&gt;ok&lt;/code&gt; . Se &lt;code&gt;{read_timer, TimerRef, Result}&lt;/code&gt; un mensaje con el formato {read_timer, TimerRef, Result} al llamador de &lt;code&gt;erlang:read_timer&lt;/code&gt; cuando la operaci&amp;oacute;n ha sido procesada.</target>
        </trans-unit>
        <trans-unit id="6ca776a5d287d8b2a7dc6071e248dbb73c2d391b" translate="yes" xml:space="preserve">
          <source>Asynchronously append a list of items to a disk log. &lt;code&gt;alog_terms/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog_terms/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog_terms/2&lt;/code&gt; can also be used for internally formatted logs if the binaries are constructed with calls to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">Agregue de forma asincr&amp;oacute;nica una lista de elementos a un registro de disco. &lt;code&gt;alog_terms/2&lt;/code&gt; se utiliza para registros formateados internamente y &lt;code&gt;balog_terms/2&lt;/code&gt; para registros formateados externamente. &lt;code&gt;balog_terms/2&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para registros formateados internamente si los binarios se construyen con llamadas a &lt;code&gt;term_to_binary/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb5375e7ef1ea5eaaf79230eafedb013e5c6183e" translate="yes" xml:space="preserve">
          <source>Asynchronously append an item to a disk log. &lt;code&gt;alog/2&lt;/code&gt; is used for internally formatted logs and &lt;code&gt;balog/2&lt;/code&gt; for externally formatted logs. &lt;code&gt;balog/2&lt;/code&gt; can also be used for internally formatted logs if the binary is constructed with a call to &lt;code&gt;term_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">Anexa de forma asincr&amp;oacute;nica un elemento a un registro de disco. &lt;code&gt;alog/2&lt;/code&gt; se utiliza para registros formateados internamente y &lt;code&gt;balog/2&lt;/code&gt; para registros formateados externamente. &lt;code&gt;balog/2&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para registros formateados internamente si el binario se construye con una llamada a &lt;code&gt;term_to_binary/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="073b543723ae65bc813de7052a4d54e6f69f1707" translate="yes" xml:space="preserve">
          <source>Asynchronously send a spawn request. Returns a request identifier &lt;code&gt;ReqId&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4919029fc256c29ef79f5f904616a2c8e94c3f2" translate="yes" xml:space="preserve">
          <source>At &quot;top-level&quot;, all these recursion test conditions are false. The syntax for recursive patterns is described below.</source>
          <target state="translated">En el &quot;nivel superior&quot;,todas estas condiciones de prueba de recursividad son falsas.La sintaxis de los patrones recursivos se describe a continuación.</target>
        </trans-unit>
        <trans-unit id="f43d3dd154d77c634c392d671f75757f296a087e" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; contains a list of 'ActionReply' records possibly containing error indications.</source>
          <target state="translated">En el caso de &lt;code&gt;success()&lt;/code&gt; , &lt;code&gt;UserReply&lt;/code&gt; contiene una lista de registros 'ActionReply' que posiblemente contengan indicaciones de error.</target>
        </trans-unit>
        <trans-unit id="3d45243ad2c3b8770cad6640db0cb04483b46411" translate="yes" xml:space="preserve">
          <source>At &lt;code&gt;success()&lt;/code&gt;, the &lt;code&gt;UserReply&lt;/code&gt; either contains:</source>
          <target state="translated">En el &lt;code&gt;success()&lt;/code&gt; , &lt;code&gt;UserReply&lt;/code&gt; contiene:</target>
        </trans-unit>
        <trans-unit id="a23e179a407d51751e1caa4f70ab6a111682bb8b" translate="yes" xml:space="preserve">
          <source>At any time, the current Erlang Top display can be dumped to a text file with function &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En cualquier momento, la pantalla actual de Erlang Top se puede volcar a un archivo de texto con la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;etop#dump-1&quot;&gt;etop:dump/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f1d3d95e4cd84ec49bb6d5fe0b90a58ea62ba48" translate="yes" xml:space="preserve">
          <source>At any time, to get the current status of the test nodes, call function &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En cualquier momento, para obtener el estado actual de los nodos de prueba, llame a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ct_master#progress-0&quot;&gt;ct_master:progress()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="654554d0e9934eea080ddb2f39b539e93c3b2e5f" translate="yes" xml:space="preserve">
          <source>At carrier deallocation, we want to coalesce with any adjacent free segments, to form one large free segment. To do that, all free segments are also organized in a tree sorted in address order (&lt;code&gt;atree&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd91a4b48e4394db081304cf8a7e752960166fb5" translate="yes" xml:space="preserve">
          <source>At each iteration of the subpattern, the back reference matches the character string corresponding to the previous iteration. In order for this to work, the pattern must be such that the first iteration does not need to match the back reference. This can be done using alternation, as in the example above, or by a quantifier with a minimum of zero.</source>
          <target state="translated">En cada iteración del subpatrón,la referencia trasera coincide con la cadena de caracteres correspondiente a la iteración anterior.Para que esto funcione,el patrón debe ser tal que la primera iteración no necesite coincidir con la referencia trasera.Esto puede hacerse mediante la alternancia,como en el ejemplo anterior,o mediante un cuantificador con un mínimo de cero.</target>
        </trans-unit>
        <trans-unit id="b373a9f8122a8a2b8c68bd7132b1ca7c2848e49f" translate="yes" xml:space="preserve">
          <source>At each record access, &lt;code&gt;mnesia_frag&lt;/code&gt; first computes a hash value from the record key. Second, the name of the table fragment is determined from the hash value. Finally the actual table access is performed by the same functions as for non-fragmented tables. When the key is not known beforehand, all fragments are searched for matching records.</source>
          <target state="translated">En cada acceso al registro, &lt;code&gt;mnesia_frag&lt;/code&gt; primero calcula un valor hash de la clave del registro. En segundo lugar, el nombre del fragmento de la tabla se determina a partir del valor hash. Finalmente, el acceso real a la tabla se realiza mediante las mismas funciones que para las tablas no fragmentadas. Cuando la clave no se conoce de antemano, se buscan registros coincidentes en todos los fragmentos.</target>
        </trans-unit>
        <trans-unit id="4fa74bb3403235c6895e68dc73b513ddac9e1482" translate="yes" xml:space="preserve">
          <source>At least one host key must be defined. The default value of SYSDIR is &lt;code id=&quot;#/etc/ssh&quot;&gt;/etc/ssh&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e791bb91b86137f009adcbd36f18e163d6c841d5" translate="yes" xml:space="preserve">
          <source>At least one other identifier type besides &lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; must also have a list of identifiers.</source>
          <target state="translated">Al menos otro tipo de identificador adem&amp;aacute;s de &lt;code&gt;&amp;lt;LogicalIds&amp;gt;&lt;/code&gt; tambi&amp;eacute;n debe tener una lista de identificadores.</target>
        </trans-unit>
        <trans-unit id="f6e34fe0dc564614befa189e8748c8b5b71f49e4" translate="yes" xml:space="preserve">
          <source>At present only the default module is provided with the agent, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt;.</source>
          <target state="translated">Actualmente, solo se proporciona el m&amp;oacute;dulo predeterminado con el agente, &lt;code&gt;snmpa_mib_data_tttn&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="52b6928d79b0ae8a32944a5857ee7a65e4d13aa4" translate="yes" xml:space="preserve">
          <source>At start-up, a node has a random atom assigned as its magic cookie and the cookie of other nodes is assumed to be &lt;code&gt;nocookie&lt;/code&gt;. The first action of the Erlang network authentication server (&lt;code&gt;auth&lt;/code&gt;) is then to read a file named &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt;. If the file does not exist, it is created. The UNIX permissions mode of the file is set to octal 400 (read-only by user) and its contents are a random string. An atom &lt;code&gt;Cookie&lt;/code&gt; is created from the contents of the file and the cookie of the local node is set to this using &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt;. This also makes the local node assume that all other nodes have the same cookie &lt;code&gt;Cookie&lt;/code&gt;.</source>
          <target state="translated">Al inicio, un nodo tiene un &amp;aacute;tomo aleatorio asignado como su cookie m&amp;aacute;gica y se asume que la cookie de otros nodos es &lt;code&gt;nocookie&lt;/code&gt; . La primera acci&amp;oacute;n del servidor de autenticaci&amp;oacute;n de red de Erlang ( &lt;code&gt;auth&lt;/code&gt; ) es leer un archivo llamado &lt;code&gt;$HOME/.erlang.cookie&lt;/code&gt; . Si el archivo no existe, se crea. El modo de permisos UNIX del archivo se establece en octal 400 (solo lectura por el usuario) y su contenido es una cadena aleatoria. Se crea una &lt;code&gt;Cookie&lt;/code&gt; &amp;aacute;tomo a partir del contenido del archivo y la cookie del nodo local se establece en este utilizando &lt;code&gt;erlang:set_cookie(node(), Cookie)&lt;/code&gt; . Esto tambi&amp;eacute;n hace que el nodo local asuma que todos los dem&amp;aacute;s nodos tienen la misma cookie &lt;code&gt;Cookie&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="518744e98c40235fc6bb7d9cc4f9e7b8cd708382" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; assumes that its local replica is the most recent version and loads the table from disc if either of the following situations is detected:</source>
          <target state="translated">Al inicio, &lt;code&gt;Mnesia&lt;/code&gt; asume que su r&amp;eacute;plica local es la versi&amp;oacute;n m&amp;aacute;s reciente y carga la tabla desde el disco si se detecta alguna de las siguientes situaciones:</target>
        </trans-unit>
        <trans-unit id="e5838a6fe5958edaad5f512813e7c830bd8af3cc" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; connects different nodes to each other, then they exchange table definitions with each other, and the table definitions are merged. During the merge procedure, &lt;code&gt;Mnesia&lt;/code&gt; performs a sanity test to ensure that the table definitions are compatible with each other. If a table exists on several nodes, the cookie must be the same, otherwise &lt;code&gt;Mnesia&lt;/code&gt; shut down one of the nodes. This unfortunate situation occurs if a table has been created on two nodes independently of each other while they were disconnected. To solve this, one of the tables must be deleted (as the cookies differ, it is regarded to be two different tables even if they have the same name).</source>
          <target state="translated">Al inicio, &lt;code&gt;Mnesia&lt;/code&gt; conecta diferentes nodos entre s&amp;iacute;, luego intercambian definiciones de tabla entre s&amp;iacute; y las definiciones de tabla se fusionan. Durante el procedimiento de fusi&amp;oacute;n, &lt;code&gt;Mnesia&lt;/code&gt; realiza una prueba de cordura para asegurarse de que las definiciones de la tabla sean compatibles entre s&amp;iacute;. Si existe una tabla en varios nodos, la cookie debe ser la misma; de lo contrario, &lt;code&gt;Mnesia&lt;/code&gt; cerrar&amp;aacute; uno de los nodos. Esta situaci&amp;oacute;n desafortunada ocurre si se ha creado una tabla en dos nodos independientemente uno del otro mientras estaban desconectados. Para solucionar esto, se debe eliminar una de las tablas (dado que las cookies son diferentes, se considera que son dos tablas diferentes aunque tengan el mismo nombre).</target>
        </trans-unit>
        <trans-unit id="a627688b56cf27035c1a223f76b7c1a970186939" translate="yes" xml:space="preserve">
          <source>At startup, &lt;code&gt;Mnesia&lt;/code&gt; loads tables to make them accessible for its applications. Sometimes &lt;code&gt;Mnesia&lt;/code&gt; decides to load all tables that reside locally, and sometimes the tables are not accessible until &lt;code&gt;Mnesia&lt;/code&gt; brings a copy of the table from another node.</source>
          <target state="translated">Al inicio, &lt;code&gt;Mnesia&lt;/code&gt; carga tablas para hacerlas accesibles para sus aplicaciones. A veces, &lt;code&gt;Mnesia&lt;/code&gt; decide cargar todas las tablas que residen localmente y, a veces, las tablas no son accesibles hasta que &lt;code&gt;Mnesia&lt;/code&gt; trae una copia de la tabla desde otro nodo.</target>
        </trans-unit>
        <trans-unit id="d42e266b7e766640fca49bd15e785ddd09a12678" translate="yes" xml:space="preserve">
          <source>At startup, Mnesia always loads &lt;code&gt;read_only&lt;/code&gt; table locally regardless of when and if Mnesia is terminated on other nodes. This argument returns the access mode of the table. The access mode can be &lt;code&gt;read_only&lt;/code&gt; or &lt;code&gt;read_write&lt;/code&gt;.</source>
          <target state="translated">Al inicio, Mnesia siempre carga la tabla &lt;code&gt;read_only&lt;/code&gt; localmente, independientemente de cu&amp;aacute;ndo y si se termina Mnesia en otros nodos. Este argumento devuelve el modo de acceso de la tabla. El modo de acceso puede ser &lt;code&gt;read_only&lt;/code&gt; o &lt;code&gt;read_write&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd3b6f4ef0dfb0e46121f11afdceab8754106c9b" translate="yes" xml:space="preserve">
          <source>At startup, notice that all tables residing on nodes without a &lt;code&gt;mnesia_down&lt;/code&gt; entry can have fresher replicas. Their replicas can have been updated after the termination of &lt;code&gt;Mnesia&lt;/code&gt; on the current node. To catch up with the latest updates, transfer a copy of the table from one of these other &quot;fresh&quot; nodes. If you are unlucky, other nodes can be down and you must wait for the table to be loaded on one of these nodes before receiving a fresh copy of the table.</source>
          <target state="translated">Al inicio, observe que todas las tablas que residen en nodos sin una entrada &lt;code&gt;mnesia_down&lt;/code&gt; pueden tener r&amp;eacute;plicas m&amp;aacute;s recientes . Sus r&amp;eacute;plicas pueden haberse actualizado despu&amp;eacute;s de la terminaci&amp;oacute;n de &lt;code&gt;Mnesia&lt;/code&gt; en el nodo actual. Para ponerse al d&amp;iacute;a con las &amp;uacute;ltimas actualizaciones, transfiera una copia de la tabla desde uno de estos otros nodos &quot;nuevos&quot;. Si no tiene suerte, otros nodos pueden estar inactivos y debe esperar a que la tabla se cargue en uno de estos nodos antes de recibir una copia nueva de la tabla.</target>
        </trans-unit>
        <trans-unit id="cebd2da32e4452b268c6c9625fdcaae6da724209" translate="yes" xml:space="preserve">
          <source>At startup, the &lt;code&gt;Mnesia&lt;/code&gt; normal table load algorithm is bypassed and the table is loaded from one of the master nodes defined for the table, regardless of potential &lt;code&gt;mnesia_down&lt;/code&gt; entries in the log. &lt;code&gt;Nodes&lt;/code&gt; can only contain nodes where the table has a replica. If &lt;code&gt;Nodes&lt;/code&gt; is empty, the master node recovery mechanism for the particular table is reset and the normal load mechanism is used at the next restart.</source>
          <target state="translated">Al inicio, se &lt;code&gt;Mnesia&lt;/code&gt; el algoritmo de carga de la tabla normal de Mnesia y la tabla se carga desde uno de los nodos maestros definidos para la tabla, independientemente de las posibles entradas &lt;code&gt;mnesia_down&lt;/code&gt; en el registro. &lt;code&gt;Nodes&lt;/code&gt; solo pueden contener nodos donde la tabla tenga una r&amp;eacute;plica. Si los &lt;code&gt;Nodes&lt;/code&gt; est&amp;aacute;n vac&amp;iacute;os, el mecanismo de recuperaci&amp;oacute;n del nodo maestro para la tabla en particular se restablece y el mecanismo de carga normal se utiliza en el siguiente reinicio.</target>
        </trans-unit>
        <trans-unit id="a6322370642204a58e29b000b086020c58026493" translate="yes" xml:space="preserve">
          <source>At system start, Logger is configured through Kernel configuration parameters. The parameters that apply to Logger are described in section &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt;. Examples are found in section &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Al inicio del sistema, Logger se configura a trav&amp;eacute;s de los par&amp;aacute;metros de configuraci&amp;oacute;n del Kernel. Los par&amp;aacute;metros que se aplican a Logger se describen en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#kernel_config_params&quot;&gt;Kernel Configuration Parameters&lt;/a&gt;&lt;/code&gt; . Los ejemplos se encuentran en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#config_examples&quot;&gt;Configuration Examples&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74d12c0011c249bb23aab720fbf3331a64e7f920" translate="yes" xml:space="preserve">
          <source>At the Media Gateway Controller (MGC) side it is possible to reject a connection request (and send a message error reply to the gateway) by returning &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; or simply &lt;code&gt;error&lt;/code&gt; which generates an error descriptor with code 402 (unauthorized) and reason &quot;Connection refused by user&quot; (this is also the case for all unknown results, such as exit signals or throw).</source>
          <target state="translated">En el lado del controlador de pasarela de medios (MGC) es posible rechazar una solicitud de conexi&amp;oacute;n (y enviar un mensaje de respuesta de error a la pasarela) devolviendo &lt;code&gt;{error, ErrorDescr}&lt;/code&gt; o simplemente &lt;code&gt;error&lt;/code&gt; que genera un descriptor de error con el c&amp;oacute;digo 402 (no autorizado) y motivo &quot;Conexi&amp;oacute;n rechazada por el usuario&quot; (este es tambi&amp;eacute;n el caso de todos los resultados desconocidos, como se&amp;ntilde;ales de salida o lanzamiento).</target>
        </trans-unit>
        <trans-unit id="082190436d06dd5d49208af168f795454a1d2c3e" translate="yes" xml:space="preserve">
          <source>At the end of a match, the values of capturing parentheses are those from the outermost level. If the pattern above is matched against</source>
          <target state="translated">Al final de un partido,los valores de captura de paréntesis son los del nivel más exterior.Si el patrón anterior se compara con</target>
        </trans-unit>
        <trans-unit id="a0bd3386c01848e616038cd3be0a42aca1ff92e4" translate="yes" xml:space="preserve">
          <source>At the end of phase one, the user defined &lt;code&gt;is_set_ok&lt;/code&gt; functions are called for each scalar variable, and for each group of table operations.</source>
          <target state="translated">Al final de la fase uno, las funciones &lt;code&gt;is_set_ok&lt;/code&gt; definidas por el usuario se llaman para cada variable escalar y para cada grupo de operaciones de tabla.</target>
        </trans-unit>
        <trans-unit id="e7141009a47e03284bdfb55bb6f57dbdb2f6af74" translate="yes" xml:space="preserve">
          <source>At the end of the file the following call is made to indicate the end of the transfer:</source>
          <target state="translated">Al final del archivo se hace la siguiente llamada para indicar el final de la transferencia:</target>
        </trans-unit>
        <trans-unit id="8f5e152a75003f4c0eecbf24783ff86692b5ac63" translate="yes" xml:space="preserve">
          <source>At the moment this is always an empty list as policies are not currently supported.</source>
          <target state="translated">Por el momento,esta lista está siempre vacía,ya que las políticas no se apoyan actualmente.</target>
        </trans-unit>
        <trans-unit id="ffb7455412e52bcc56b05d38e6e5253be2bc9d2d" translate="yes" xml:space="preserve">
          <source>At the other end, a server is listening on port 5678, accepts the connection, and receives the binary:</source>
          <target state="translated">En el otro extremo,un servidor está escuchando en el puerto 5678,acepta la conexión y recibe el binario:</target>
        </trans-unit>
        <trans-unit id="6f9ff8879a1b69159c6bc968e733a435a351ea07" translate="yes" xml:space="preserve">
          <source>At the time of writing this document, in October 2020, there are two major standards concerning Universal Resource Identifiers and Universal Resource Locators:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2ee7dea7134049488781051edab25bd2f008623" translate="yes" xml:space="preserve">
          <source>At the top level, the first character is matched, but as it is not at the end of the string, the first alternative fails, the second alternative is taken, and the recursion kicks in. The recursive call to subpattern 1 successfully matches the next character (&quot;b&quot;). (Notice that the beginning and end of line tests are not part of the recursion.)</source>
          <target state="translated">En el nivel superior,el primer personaje se empareja,pero como no está al final de la cadena,la primera alternativa falla,se toma la segunda alternativa,y la recursividad hace efecto.La llamada recursiva al subpatrón 1 coincide con éxito con el siguiente personaje (&quot;b&quot;).(Obsérvese que las pruebas de principio y fin de línea no forman parte de la recursión).</target>
        </trans-unit>
        <trans-unit id="ed2220b4de1fb3635d6a43309a72686050501dc1" translate="yes" xml:space="preserve">
          <source>At this point it would make sense to create a &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt;, but in this particular example the compiler sees that there will soon be a call to a function (in this case, to &lt;code&gt;my_binary_to_list/1&lt;/code&gt; itself) that immediately will create a new match context and discard the sub binary.</source>
          <target state="translated">En este punto, tendr&amp;iacute;a sentido crear un &lt;code&gt;&lt;a href=&quot;#sub_binary&quot;&gt;sub binary&lt;/a&gt;&lt;/code&gt; , pero en este ejemplo en particular, el compilador ve que pronto habr&amp;aacute; una llamada a una funci&amp;oacute;n (en este caso, a &lt;code&gt;my_binary_to_list/1&lt;/code&gt; ) que inmediatamente crear&amp;aacute; un nuevo contexto de coincidencia. y descarte el subbinario.</target>
        </trans-unit>
        <trans-unit id="053fad4995ec80f53388ef89516e030604b7c2c8" translate="yes" xml:space="preserve">
          <source>At this point the client has stored the received session tickets and ready to use them when establishing new connections to the same server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a5d6ede3e3967bfd759ea91b6f59bd9213c0242" translate="yes" xml:space="preserve">
          <source>At this stage when we have a couple of &lt;code&gt;Events&lt;/code&gt;, it is time to show how it looks like in the graphical interface of &lt;code&gt;et_viewer&lt;/code&gt;:</source>
          <target state="translated">En esta etapa, cuando tenemos un par de &lt;code&gt;Events&lt;/code&gt; , es hora de mostrar c&amp;oacute;mo se ve en la interfaz gr&amp;aacute;fica de &lt;code&gt;et_viewer&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="41dded417052424bdcf3c39f6c8664147fae6806" translate="yes" xml:space="preserve">
          <source>Atom</source>
          <target state="translated">Atom</target>
        </trans-unit>
        <trans-unit id="c3c309f16bf4b6076b8eb93fd32be986ed93ed91" translate="yes" xml:space="preserve">
          <source>Atom ::= - same as Erlang atoms -</source>
          <target state="translated">Átomo ::=-igual que los átomos de Erlang -</target>
        </trans-unit>
        <trans-unit id="51343a15868219ae0470e742ba631bc7eec26597" translate="yes" xml:space="preserve">
          <source>Atom is another data type in Erlang. Atoms start with a small letter (see &lt;code&gt;Atom&lt;/code&gt;), for example, &lt;code&gt;charles&lt;/code&gt;, &lt;code&gt;centimeter&lt;/code&gt;, and &lt;code&gt;inch&lt;/code&gt;. Atoms are simply names, nothing else. They are not like variables, which can have a value.</source>
          <target state="translated">Atom es otro tipo de datos en Erlang. Los &amp;aacute;tomos comienzan con una letra min&amp;uacute;scula (v&amp;eacute;ase &lt;code&gt;Atom&lt;/code&gt; ), por ejemplo, &lt;code&gt;charles&lt;/code&gt; , &lt;code&gt;centimeter&lt;/code&gt; y &lt;code&gt;inch&lt;/code&gt; . Los &amp;aacute;tomos son simplemente nombres, nada m&amp;aacute;s. No son como variables, que pueden tener un valor.</target>
        </trans-unit>
        <trans-unit id="7195f879141a5a8ba030248689c692d5148b0ee2" translate="yes" xml:space="preserve">
          <source>AtomConst ::= Application | Module | Release</source>
          <target state="translated">AtomConst ::=Aplicación | Módulo | Liberación</target>
        </trans-unit>
        <trans-unit id="b2ee6dcaa3e3bc365b8aefab9465e716d6296685" translate="yes" xml:space="preserve">
          <source>Atomic Functions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c66839560fb43e9f121274907f35e59ef182189" translate="yes" xml:space="preserve">
          <source>Atomic Memory Operations and the VM</source>
          <target state="translated">Operaciones de Memoria Atómica y el VM</target>
        </trans-unit>
        <trans-unit id="23f3697ab5a23225ef71292b3984b7a0da58971b" translate="yes" xml:space="preserve">
          <source>Atomic addition and return of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="285aeb96eeef706de92b804eae05d172e8e0a60b" translate="yes" xml:space="preserve">
          <source>Atomic grouping subpatterns are not capturing subpatterns. Simple cases such as the above example can be thought of as a maximizing repeat that must swallow everything it can. So, while both \d+ and \d+? are prepared to adjust the number of digits they match to make the remaining pattern match, &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; can only match an entire sequence of digits.</source>
          <target state="translated">Los subpatrones de agrupaci&amp;oacute;n at&amp;oacute;mica no capturan subpatrones. Los casos simples como el ejemplo anterior se pueden considerar como una repetici&amp;oacute;n maximizadora que debe tragarse todo lo que pueda. Entonces, mientras tanto \ d + como \ d +? est&amp;aacute;n preparados para ajustar el n&amp;uacute;mero de d&amp;iacute;gitos que coinciden para hacer coincidir el patr&amp;oacute;n restante, &lt;code&gt;(?&amp;gt;\d+)&lt;/code&gt; solo puede coincidir con una secuencia completa de d&amp;iacute;gitos.</target>
        </trans-unit>
        <trans-unit id="70263cc27057f40aecb08445d5e4246aa30c686a" translate="yes" xml:space="preserve">
          <source>Atomic groups in general can contain any complicated subpatterns, and can be nested. However, when the subpattern for an atomic group is just a single repeated item, as in the example above, a simpler notation, called a &quot;possessive quantifier&quot; can be used. This consists of an extra + character following a quantifier. Using this notation, the previous example can be rewritten as</source>
          <target state="translated">Los grupos atómicos en general pueden contener cualquier subpatrón complicado,y pueden anidarse.Sin embargo,cuando el subpatrón de un grupo atómico es un solo elemento repetido,como en el ejemplo anterior,se puede utilizar una notación más simple,llamada &quot;cuantificador posesivo&quot;.Ésta consiste en un carácter+adicional que sigue a un cuantificador.Utilizando esta notación,el ejemplo anterior puede reescribirse como</target>
        </trans-unit>
        <trans-unit id="982546c2c1a7dfe452b41223e0b9ac156cdae924" translate="yes" xml:space="preserve">
          <source>Atomic subtraction and return of the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d74d1749d4da9ae8e4ba38276cc8935928009a4" translate="yes" xml:space="preserve">
          <source>Atomic transactions. A series of table manipulation operations can be grouped into a single atomic transaction.</source>
          <target state="translated">Transacciones atómicas.Se pueden agrupar en una sola transacción atómica una serie de operaciones de manipulación de tablas.</target>
        </trans-unit>
        <trans-unit id="e24ad40d30afa103adc1e00c3958d38ebb6700ca" translate="yes" xml:space="preserve">
          <source>Atomically changes the registered name &lt;code&gt;Name&lt;/code&gt; on all nodes to refer to &lt;code&gt;Pid&lt;/code&gt;.</source>
          <target state="translated">Cambia at&amp;oacute;micamente el nombre registrado &lt;code&gt;Name&lt;/code&gt; en todos los nodos para hacer referencia a &lt;code&gt;Pid&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2493472ac358dd449dd5c5363f10400e17b2f569" translate="yes" xml:space="preserve">
          <source>Atomically compares the atomic with &lt;code&gt;Expected&lt;/code&gt;, and if those are equal, set atomic to &lt;code&gt;Desired&lt;/code&gt;. Returns &lt;code&gt;ok&lt;/code&gt; if &lt;code&gt;Desired&lt;/code&gt; was written. Returns the actual atomic value if not equal to &lt;code&gt;Expected&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d81a1603d3a7688828359e353ff047ffd9ff583" translate="yes" xml:space="preserve">
          <source>Atomically replaces the value of the atomic with &lt;code&gt;Desired&lt;/code&gt; and returns the value it held previously.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7dfdf2c7a48eb8aa0595b9fdbbeea1555b65d328" translate="yes" xml:space="preserve">
          <source>Atomicity</source>
          <target state="translated">Atomicity</target>
        </trans-unit>
        <trans-unit id="ee048f7e55224c5c36ed6495f528ec9c74109599" translate="yes" xml:space="preserve">
          <source>Atomicity is important when it is needed to write atomically more than one record in the same transaction. The function &lt;code&gt;raise/2&lt;/code&gt;, shown in the previous example, writes one record only. The function &lt;code&gt;insert_emp/3&lt;/code&gt;, shown in the program listing in &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt;, writes the record &lt;code&gt;employee&lt;/code&gt; as well as employee relations, such as &lt;code&gt;at_dep&lt;/code&gt; and &lt;code&gt;in_proj&lt;/code&gt;, into the database. If this latter code is run inside a transaction, the transaction handler ensures that the transaction either succeeds completely, or not at all.</source>
          <target state="translated">La atomicidad es importante cuando se necesita escribir at&amp;oacute;micamente m&amp;aacute;s de un registro en la misma transacci&amp;oacute;n. La funci&amp;oacute;n &lt;code&gt;raise/2&lt;/code&gt; , que se muestra en el ejemplo anterior, escribe solo un registro. La funci&amp;oacute;n &lt;code&gt;insert_emp/3&lt;/code&gt; , que se muestra en la lista de programas en &lt;code&gt;&lt;a href=&quot;mnesia_chap2#getting_started&quot;&gt;Getting Started&lt;/a&gt;&lt;/code&gt; , escribe el &lt;code&gt;employee&lt;/code&gt; registro y las relaciones con los empleados, como &lt;code&gt;at_dep&lt;/code&gt; e &lt;code&gt;in_proj&lt;/code&gt; , en la base de datos. Si este &amp;uacute;ltimo c&amp;oacute;digo se ejecuta dentro de una transacci&amp;oacute;n, el controlador de la transacci&amp;oacute;n se asegura de que la transacci&amp;oacute;n se realice correctamente o no se realice en absoluto.</target>
        </trans-unit>
        <trans-unit id="9e7bf26b3574db121c0f9c2d5135066a290bba9b" translate="yes" xml:space="preserve">
          <source>Atomicity means that database changes that are executed by a transaction take effect on all nodes involved, or on none of the nodes. That is, the transaction either succeeds entirely, or it fails entirely.</source>
          <target state="translated">La atomicidad significa que los cambios en la base de datos que se ejecutan mediante una transacción surten efecto en todos los nodos implicados,o en ninguno de ellos.Es decir,la transacción o bien tiene éxito en su totalidad,o bien fracasa por completo.</target>
        </trans-unit>
        <trans-unit id="9fd0fef61eacad14e3b6ee3330650b0b6285e00f" translate="yes" xml:space="preserve">
          <source>Atomics are 64 bit integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="668e283c28347d455368391a2021ca18daf0d65e" translate="yes" xml:space="preserve">
          <source>Atomics are not tied to the current process and are automatically garbage collected when they are no longer referenced.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e85a2063ae4b966a0609e0b05bc24c3b00cbb202" translate="yes" xml:space="preserve">
          <source>Atomics can be represented as either signed or unsigned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd729319f6838749442998b087a916cd07e23c32" translate="yes" xml:space="preserve">
          <source>Atomics wrap around at overflow and underflow operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f53a98286f82798d588f67a7f0db19f7aebc839e" translate="yes" xml:space="preserve">
          <source>Atoms</source>
          <target state="translated">Atoms</target>
        </trans-unit>
        <trans-unit id="8b4ce0020874da6c44e911622f2debe1461e0f0d" translate="yes" xml:space="preserve">
          <source>Atoms and variables can use all Latin-1 letters.</source>
          <target state="translated">Los átomos y las variables pueden usar todas las letras del Latín-1.</target>
        </trans-unit>
        <trans-unit id="cad694cf01aa8c5551f1401deeab34aabdb5d17c" translate="yes" xml:space="preserve">
          <source>Atoms are compared using their string value, codepoint by codepoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e89bc7b897d5b27ce2d498db94d099bf846c461" translate="yes" xml:space="preserve">
          <source>Atoms are not garbage-collected. Once an atom is created, it is never removed. The emulator terminates if the limit for the number of atoms (1,048,576 by default) is reached.</source>
          <target state="translated">Los átomos no se recogen en la basura.Una vez que un átomo es creado,nunca es removido.El emulador termina si se alcanza el límite del número de átomos (1.048.576 por defecto).</target>
        </trans-unit>
        <trans-unit id="53953ef0095a671ea4007a14634a7ef6dcdd0975" translate="yes" xml:space="preserve">
          <source>Atoms starting with &lt;code&gt;@&lt;/code&gt;, for example &lt;code&gt;'@foo'&lt;/code&gt; or &lt;code&gt;'@Foo'&lt;/code&gt;</source>
          <target state="translated">&amp;Aacute;tomos que comienzan con &lt;code&gt;@&lt;/code&gt; , por ejemplo, &lt;code&gt;'@foo'&lt;/code&gt; o &lt;code&gt;'@Foo'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="cf1f2e1b1dd67aa033d9dce573a905b7f9461d62" translate="yes" xml:space="preserve">
          <source>Attaches comments to a syntax tree. The result is a pair &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; where &lt;code&gt;NewTree&lt;/code&gt; is the given &lt;code&gt;Tree&lt;/code&gt; where comments from the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places. &lt;code&gt;Remainder&lt;/code&gt; is the list of entries in &lt;code&gt;Comments&lt;/code&gt; which have not been inserted, because their line numbers are greater than those of any node in the tree. The entries in &lt;code&gt;Comments&lt;/code&gt; are inserted in order; if two comments become attached to the same node, they will appear in the same order in the program text.</source>
          <target state="translated">Adjunta comentarios a un &amp;aacute;rbol de sintaxis. El resultado es un par &lt;code&gt;{NewTree, Remainder}&lt;/code&gt; donde &lt;code&gt;NewTree&lt;/code&gt; es el &lt;code&gt;Tree&lt;/code&gt; dado donde los comentarios de la lista &lt;code&gt;Comments&lt;/code&gt; se han adjuntado en los lugares adecuados. &lt;code&gt;Remainder&lt;/code&gt; es la lista de entradas en &lt;code&gt;Comments&lt;/code&gt; que no se han insertado, porque sus n&amp;uacute;meros de l&amp;iacute;nea son mayores que los de cualquier nodo del &amp;aacute;rbol. Las entradas en &lt;code&gt;Comments&lt;/code&gt; se insertan en orden; si dos comentarios se adjuntan al mismo nodo, aparecer&amp;aacute;n en el mismo orden en el texto del programa.</target>
        </trans-unit>
        <trans-unit id="d2ceee4cae7cbba986c24f620add3c4dd9b79139" translate="yes" xml:space="preserve">
          <source>Attaches comments to the syntax tree/trees representing a program. The given &lt;code&gt;Forms&lt;/code&gt; should be a single syntax tree of type &lt;code&gt;form_list&lt;/code&gt;, or a list of syntax trees representing &quot;program forms&quot;. The syntax trees must contain valid position information (for details, see &lt;code&gt;recomment_tree/2&lt;/code&gt;). The result is a corresponding syntax tree of type &lt;code&gt;form_list&lt;/code&gt; in which all comments in the list &lt;code&gt;Comments&lt;/code&gt; have been attached at the proper places.</source>
          <target state="translated">Adjunta comentarios al &amp;aacute;rbol / &amp;aacute;rboles de sintaxis que representan un programa. Los &lt;code&gt;Forms&lt;/code&gt; dados deben ser un &amp;aacute;rbol de sintaxis &amp;uacute;nico de tipo &lt;code&gt;form_list&lt;/code&gt; , o una lista de &amp;aacute;rboles de sintaxis que representen &quot;formularios de programa&quot;. Los &amp;aacute;rboles de sintaxis deben contener informaci&amp;oacute;n de posici&amp;oacute;n v&amp;aacute;lida (para m&amp;aacute;s detalles, consulte &lt;code&gt;recomment_tree/2&lt;/code&gt; ). El resultado es un &amp;aacute;rbol de sintaxis correspondiente de tipo &lt;code&gt;form_list&lt;/code&gt; en el que todos los comentarios de la lista &lt;code&gt;Comments&lt;/code&gt; se han adjuntado en los lugares adecuados.</target>
        </trans-unit>
        <trans-unit id="08f3c18f1ef82b85d187f359be8053ba60fcff3a" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. An Attach Process window is opened for the process.</source>
          <target state="translated">Se adjunta al proceso depurado &lt;code&gt;Pid&lt;/code&gt; . Se abre una ventana Adjuntar proceso para el proceso.</target>
        </trans-unit>
        <trans-unit id="e858ba60db5ffa465fde04178472518163ea425c" translate="yes" xml:space="preserve">
          <source>Attaches to the debugged process &lt;code&gt;Pid&lt;/code&gt;. The interpreter calls &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; (and ignores the result).</source>
          <target state="translated">Se adjunta al proceso depurado &lt;code&gt;Pid&lt;/code&gt; . El int&amp;eacute;rprete llama a &lt;code&gt;spawn(Module, Name, [Pid])&lt;/code&gt; (e ignora el resultado).</target>
        </trans-unit>
        <trans-unit id="dc33862cfcafa306527c136f22aeb55fbb46ae26" translate="yes" xml:space="preserve">
          <source>Attaches to the process and open an &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se adjunta al proceso y abre una &lt;code&gt;&lt;a href=&quot;#attach&quot;&gt;Attach Process window&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a27b2860df5ad784c2a072eec792bd3ddbfbbcf2" translate="yes" xml:space="preserve">
          <source>Attempt to delete the current directory. On some platforms, &lt;code&gt;eacces&lt;/code&gt; is returned instead.</source>
          <target state="translated">Intente eliminar el directorio actual. En algunas plataformas, se devuelve &lt;code&gt;eacces&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="4dd873defa6a2d59737d4e84f136645c52891193" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can also be used for turning on warnings. For example, if a module has been fixed regarding unmatched returns, adding the following line can help in assuring that no new unmatched return warnings are introduced:</source>
          <target state="translated">El atributo &lt;code&gt;-dialyzer()&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para activar las advertencias. Por ejemplo, si se ha corregido un m&amp;oacute;dulo con respecto a devoluciones no coincidentes, agregar la siguiente l&amp;iacute;nea puede ayudar a garantizar que no se introduzcan nuevas advertencias de devoluci&amp;oacute;n no coincidentes:</target>
        </trans-unit>
        <trans-unit id="94a2d033077fb7d4c11be4d28e975e8f7fa67d5d" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; can be used for turning off warnings in a module by specifying functions or warning options. For example, to turn off all warnings for the function &lt;code&gt;f/0&lt;/code&gt;, include the following line:</source>
          <target state="translated">El atributo &lt;code&gt;-dialyzer()&lt;/code&gt; se puede utilizar para desactivar las advertencias en un m&amp;oacute;dulo especificando funciones u opciones de advertencia. Por ejemplo, para desactivar todas las advertencias para la funci&amp;oacute;n &lt;code&gt;f/0&lt;/code&gt; , incluya la siguiente l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="3bb46baccc6ddbcfec9893a911a5598494b5fa7f" translate="yes" xml:space="preserve">
          <source>Attribute &lt;code&gt;-dialyzer()&lt;/code&gt; is allowed after function declarations. Lists of warning options or functions are allowed:</source>
          <target state="translated">El atributo &lt;code&gt;-dialyzer()&lt;/code&gt; est&amp;aacute; permitido despu&amp;eacute;s de las declaraciones de funci&amp;oacute;n. Se permiten listas de opciones o funciones de advertencia:</target>
        </trans-unit>
        <trans-unit id="20497f389e60747b76a9f4c282fe115ff9e65b81" translate="yes" xml:space="preserve">
          <source>Attribute = {atom(), term()}</source>
          <target state="translated">Atributo={atom(),término()}</target>
        </trans-unit>
        <trans-unit id="56cec620065c043a2c53d113a84f30cf04a24bfc" translate="yes" xml:space="preserve">
          <source>Attributes = [{Name, Value}| #xmlAttribute{}]</source>
          <target state="translated">Atributos=[{Nombre,Valor}| #xmlAtributo{}]</target>
        </trans-unit>
        <trans-unit id="8196898f60a411611bff755ce53bcb927eed9bf5" translate="yes" xml:space="preserve">
          <source>Audit Trail Logging</source>
          <target state="translated">Registro de la pista de auditoría</target>
        </trans-unit>
        <trans-unit id="e7a0dac799c2ac1aee5c36d21a89de6463f1070c" translate="yes" xml:space="preserve">
          <source>Auth-Application-Id AVP</source>
          <target state="translated">Auth-Application-Id AVP</target>
        </trans-unit>
        <trans-unit id="6f57677bc7cc52df8c3d26defd5359054852e0c9" translate="yes" xml:space="preserve">
          <source>Auth-Grace-Period AVP</source>
          <target state="translated">Período de Auth-Grace AVP</target>
        </trans-unit>
        <trans-unit id="ffad30279d0dbdebdba0995b72cf095104751ce5" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP</source>
          <target state="translated">Auth-Request Type AVP</target>
        </trans-unit>
        <trans-unit id="bab9dd08fa19bdf6f1b4cf6e9f78668ae505c80e" translate="yes" xml:space="preserve">
          <source>Auth-Request-Type AVP Values</source>
          <target state="translated">Valores AVP de tipo solicitud automática</target>
        </trans-unit>
        <trans-unit id="d8ff104e64da7ae152dbd68cb8bb5ac85c8606c8" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP</source>
          <target state="translated">Auth-Session-State AVP</target>
        </trans-unit>
        <trans-unit id="52aa2478028e9ddcf53894d8996729bb4145d0b1" translate="yes" xml:space="preserve">
          <source>Auth-Session-State AVP Values</source>
          <target state="translated">Valores AVP del estado de la sesión de autorización</target>
        </trans-unit>
        <trans-unit id="b01542a7f0aa1f0864e6a230526030dbd833afdd" translate="yes" xml:space="preserve">
          <source>Authenticate the connection using simple authentication.</source>
          <target state="translated">Autentificar la conexión usando una simple autenticación.</target>
        </trans-unit>
        <trans-unit id="35d60aabf722ed742565d9c00b64a125d7839912" translate="yes" xml:space="preserve">
          <source>Authenticated Encryption with Associated Data</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efdb86330764c8fbe68da0d4b6819ef23c162680" translate="yes" xml:space="preserve">
          <source>Authenticating the integrity of the handshake messages.</source>
          <target state="translated">Autentificando la integridad de los mensajes del apretón de manos.</target>
        </trans-unit>
        <trans-unit id="efa60b3797f87eb6c6f0da41e22b02554c4d0aa2" translate="yes" xml:space="preserve">
          <source>Authentication (done by &lt;code&gt; net_kernel(3)&lt;/code&gt;) (3)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a30fd25c7a3f93a7b30740a0a98229a0638bb08" translate="yes" xml:space="preserve">
          <source>Authentication (done by &lt;code&gt;net_kernel(3)&lt;/code&gt;) (3)</source>
          <target state="translated">Autenticaci&amp;oacute;n (realizada por &lt;code&gt;net_kernel(3)&lt;/code&gt; ) (3)</target>
        </trans-unit>
        <trans-unit id="2ff2f3c3923c0921f88e897f48c0cfff1d679d6c" translate="yes" xml:space="preserve">
          <source>Authentication Protocol</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc6b01190c75db5a643cf18f6685ef326b9bb4bb" translate="yes" xml:space="preserve">
          <source>Authentication determines which nodes are allowed to communicate with each other. In a network of different Erlang nodes, it is built into the system at the lowest possible level. Each node has its own &lt;strong&gt;magic cookie&lt;/strong&gt;, which is an Erlang atom.</source>
          <target state="translated">La autenticaci&amp;oacute;n determina qu&amp;eacute; nodos pueden comunicarse entre s&amp;iacute;. En una red de diferentes nodos Erlang, est&amp;aacute; integrado en el sistema al nivel m&amp;aacute;s bajo posible. Cada nodo tiene su propia &lt;strong&gt;cookie m&amp;aacute;gica&lt;/strong&gt; , que es un &amp;aacute;tomo de Erlang.</target>
        </trans-unit>
        <trans-unit id="b69c9c9364edcba7a03ffefeefa382cf82287356" translate="yes" xml:space="preserve">
          <source>Authentication of the peer is done by public key path validation as defined in RFC 3280. This means basically the following:</source>
          <target state="translated">La autenticación del par se realiza mediante la validación de la ruta de la clave pública según se define en la RFC 3280.Esto significa básicamente lo siguiente:</target>
        </trans-unit>
        <trans-unit id="65b45c1a860b3348b9833c0a96364a1acd14c2b7" translate="yes" xml:space="preserve">
          <source>Authentication/access checks.</source>
          <target state="translated">Autenticación/comprobaciones de acceso.</target>
        </trans-unit>
        <trans-unit id="1ba9c0e85dda9702580d19335be06fa7a8c504cb" translate="yes" xml:space="preserve">
          <source>Authorization Session State Machine</source>
          <target state="translated">Máquina de estado de la sesión de autorización</target>
        </trans-unit>
        <trans-unit id="cd708bd6499f399dc5b86474d073a1c2f25376ad" translate="yes" xml:space="preserve">
          <source>Authorization and accounting AVPs are defined in provided dictionaries. Their proper use is the responsibility of the user.</source>
          <target state="translated">Los AVP de autorización y contabilidad se definen en los diccionarios proporcionados.Su uso apropiado es responsabilidad del usuario.</target>
        </trans-unit>
        <trans-unit id="f163341ede12f9adebdea0335c91c64ca9f864cb" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user.</source>
          <target state="translated">La autorización es responsabilidad del usuario.</target>
        </trans-unit>
        <trans-unit id="50b27cabe4dbb1d4ad17bfe9e56741a4affc2eea" translate="yes" xml:space="preserve">
          <source>Authorization is the responsibility of the user: diameter does not implement this state machine.</source>
          <target state="translated">La autorización es responsabilidad del usuario:diameter no implementa esta máquina de estado.</target>
        </trans-unit>
        <trans-unit id="30ed2a3e728e1f003c2a2c8e103841be8b0ec854" translate="yes" xml:space="preserve">
          <source>Authorization-Lifetime AVP</source>
          <target state="translated">Autorización-AVP de por vida</target>
        </trans-unit>
        <trans-unit id="11627de117205b8d3e5249886b3c5fcffd98fb20" translate="yes" xml:space="preserve">
          <source>Authorized Keys - OpenSSH Format</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edd7b5046b035f96ef22223b25da57cd6e60a20a" translate="yes" xml:space="preserve">
          <source>Authorized keys - OpenSSH format looks as follows:</source>
          <target state="translated">Llaves autorizadas-El formato de OpenSSH tiene el siguiente aspecto:</target>
        </trans-unit>
        <trans-unit id="a574cde3f8131fcb2c5ef5b3ac87763f839e4628" translate="yes" xml:space="preserve">
          <source>Auto-imported BIFs are listed without module prefix. BIFs listed with module prefix are not auto-imported.</source>
          <target state="translated">Los BIF autoimportados aparecen sin el prefijo del módulo.Los BIF listados con el prefijo del módulo no son autoimportados.</target>
        </trans-unit>
        <trans-unit id="c5883a7e0cca29e11fe6124ccc75bacf71f8b9f1" translate="yes" xml:space="preserve">
          <source>Automated execution of test suites (sets of test cases)</source>
          <target state="translated">Ejecución automatizada de suites de prueba (conjuntos de casos de prueba)</target>
        </trans-unit>
        <trans-unit id="d436c113d37a4bf9ab8a69c9c589f736a5417312" translate="yes" xml:space="preserve">
          <source>Automatic compilation of test suites (and help modules)</source>
          <target state="translated">Compilación automática de las suites de pruebas (y módulos de ayuda)</target>
        </trans-unit>
        <trans-unit id="fccc42c97a2ffc422d0e26337a4e4d5dff20a9b3" translate="yes" xml:space="preserve">
          <source>Automatic send transaction ack when the transaction reply has been received (see &lt;code&gt;trans_ack&lt;/code&gt; below).</source>
          <target state="translated">Enviar confirmaci&amp;oacute;n autom&amp;aacute;tica de la transacci&amp;oacute;n cuando se haya recibido la respuesta de la transacci&amp;oacute;n (ver &lt;code&gt;trans_ack&lt;/code&gt; a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="ca478c0ab639849e3541da90cb17a860b5490d08" translate="yes" xml:space="preserve">
          <source>Automatic send transaction pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">Transacción de envío automático pendiente si el temporizador expira antes de que se haya enviado la respuesta de la transacción.Este temporizador también se denomina temporizador de respuesta provisional.</target>
        </trans-unit>
        <trans-unit id="93da85ea44d26c2624d1e105b7f890bc46bd09ba" translate="yes" xml:space="preserve">
          <source>Automatic state enter calls</source>
          <target state="translated">El estado automático introduce las llamadas</target>
        </trans-unit>
        <trans-unit id="2a89768431c505706353574d66358c32a869dccc" translate="yes" xml:space="preserve">
          <source>Automatic type-casting probably makes these changes necessary only for a driver that encounters sizes &amp;gt; 32 bits.</source>
          <target state="translated">La conversi&amp;oacute;n de tipos autom&amp;aacute;tica probablemente hace que estos cambios sean necesarios solo para un controlador que encuentra tama&amp;ntilde;os&amp;gt; 32 bits.</target>
        </trans-unit>
        <trans-unit id="3ef94894ba2f4eb73cf0fd7bdecec218163555bf" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;HandlerId&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">Insertado autom&amp;aacute;ticamente por Logger. El valor es el mismo que el &lt;code&gt;HandlerId&lt;/code&gt; especificado al agregar el controlador y no se puede cambiar.</target>
        </trans-unit>
        <trans-unit id="77c6bd373dea25df6392c697b76ebb783fd68b3e" translate="yes" xml:space="preserve">
          <source>Automatically inserted by Logger. The value is the same as the &lt;code&gt;Module&lt;/code&gt; specified when adding the handler, and it cannot be changed.</source>
          <target state="translated">Insertado autom&amp;aacute;ticamente por Logger. El valor es el mismo que el &lt;code&gt;Module&lt;/code&gt; especificado al agregar el controlador y no se puede cambiar.</target>
        </trans-unit>
        <trans-unit id="32d8c661feaa1a96e94bb053c82356a83532060b" translate="yes" xml:space="preserve">
          <source>Automatically send pending if the timer expires before a transaction reply has been sent. This timer is also called provisional response timer.</source>
          <target state="translated">Envío automático de pendientes si el temporizador expira antes de que se haya enviado la respuesta de la transacción.Este temporizador también se denomina temporizador de respuesta provisional.</target>
        </trans-unit>
        <trans-unit id="18da0ae80b2a3d06e9335371a77bc11e953c941d" translate="yes" xml:space="preserve">
          <source>Autoresume</source>
          <target state="translated">Autoresume</target>
        </trans-unit>
        <trans-unit id="51349a6371eec8fabecdb286d36f04bc3ea24184" translate="yes" xml:space="preserve">
          <source>Available in all OpenSSL compatible with Erlang CRYPTO if not disabled by configuration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="440311567fa2e46e6495460ee5e7f6ca1160021b" translate="yes" xml:space="preserve">
          <source>Available only in some POSIX systems, this call results in a call to &lt;code&gt;fsync()&lt;/code&gt;, or has no effect in systems not providing the &lt;code&gt;fdatasync()&lt;/code&gt; syscall.</source>
          <target state="translated">Disponible solo en algunos sistemas POSIX, esta llamada da como resultado una llamada a &lt;code&gt;fsync()&lt;/code&gt; o no tiene ning&amp;uacute;n efecto en sistemas que no proporcionan la &lt;code&gt;fdatasync()&lt;/code&gt; al sistema fdatasync () .</target>
        </trans-unit>
        <trans-unit id="a5325c58f3190f03981f3d4b6e263a0fcae8b5bc" translate="yes" xml:space="preserve">
          <source>Available options are:</source>
          <target state="translated">Las opciones disponibles son:</target>
        </trans-unit>
        <trans-unit id="057b4b33c8569c09b413019743ff85bf2e11c330" translate="yes" xml:space="preserve">
          <source>Available options:</source>
          <target state="translated">Opciones disponibles:</target>
        </trans-unit>
        <trans-unit id="4e9d1b7f151f31fb76e5b9ef9857c7c1cae6dcf2" translate="yes" xml:space="preserve">
          <source>Available properties are the same as the start options of the server, but the properties &lt;code&gt;bind_address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; cannot be changed.</source>
          <target state="translated">Las propiedades disponibles son las mismas que las opciones de inicio del servidor, pero las propiedades &lt;code&gt;bind_address&lt;/code&gt; y &lt;code&gt;port&lt;/code&gt; no se pueden cambiar.</target>
        </trans-unit>
        <trans-unit id="ef104ec434506c3596f5487f13a01379d4ba6bd2" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;'receive'&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Disponible a trav&amp;eacute;s de &lt;code&gt;erlang:trace/3&lt;/code&gt; con el indicador de seguimiento &lt;code&gt;'receive'&lt;/code&gt; y &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; como m&amp;oacute;dulo de seguimiento .</target>
        </trans-unit>
        <trans-unit id="27f7db47a04206f9b18980fb6fca2934f7e7d231" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Disponible a trav&amp;eacute;s de &lt;code&gt;erlang:trace/3&lt;/code&gt; con &lt;code&gt;call&lt;/code&gt; marca de seguimiento y &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; como m&amp;oacute;dulo de seguimiento .</target>
        </trans-unit>
        <trans-unit id="ec9c72570d3ed2f9817e1e27636799b0c17600b7" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;call&lt;/code&gt; or &lt;code&gt;return_to&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Disponible a trav&amp;eacute;s de &lt;code&gt;erlang:trace/3&lt;/code&gt; con trace flag &lt;code&gt;call&lt;/code&gt; o &lt;code&gt;return_to&lt;/code&gt; y &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; como m&amp;oacute;dulo trazador.</target>
        </trans-unit>
        <trans-unit id="19369e2b69d2d29bcf7d2b110bd632c0497eadc1" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;garbage_collection&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Disponible a trav&amp;eacute;s de &lt;code&gt;erlang:trace/3&lt;/code&gt; con trace flag &lt;code&gt;garbage_collection&lt;/code&gt; y &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; como m&amp;oacute;dulo trazador.</target>
        </trans-unit>
        <trans-unit id="0b14892085d0235611acf16621043bf554272c4b" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;ports&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Disponible a trav&amp;eacute;s de &lt;code&gt;erlang:trace/3&lt;/code&gt; con &lt;code&gt;ports&lt;/code&gt; marca de seguimiento y &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; como m&amp;oacute;dulo de seguimiento .</target>
        </trans-unit>
        <trans-unit id="98fc651851a4575e9edd1b04d22bca4d2ff1533e" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;procs&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Disponible a trav&amp;eacute;s de &lt;code&gt;erlang:trace/3&lt;/code&gt; con trace flag &lt;code&gt;procs&lt;/code&gt; y &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; como m&amp;oacute;dulo tracer.</target>
        </trans-unit>
        <trans-unit id="3f46a50dcc99ab759ab69e8cdf416560bd6713f8" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;running&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Disponible a trav&amp;eacute;s de &lt;code&gt;erlang:trace/3&lt;/code&gt; con el indicador de seguimiento en &lt;code&gt;running&lt;/code&gt; y &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; como m&amp;oacute;dulo de seguimiento .</target>
        </trans-unit>
        <trans-unit id="04747a5c4337891e1a74cc42657f396a199e1343" translate="yes" xml:space="preserve">
          <source>Available through &lt;code&gt;erlang:trace/3&lt;/code&gt; with trace flag &lt;code&gt;send&lt;/code&gt; and &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; as tracer module.</source>
          <target state="translated">Disponible a trav&amp;eacute;s de &lt;code&gt;erlang:trace/3&lt;/code&gt; con trace flag &lt;code&gt;send&lt;/code&gt; y &lt;code&gt;{tracer,dyntrace,[]}&lt;/code&gt; como m&amp;oacute;dulo de seguimiento .</target>
        </trans-unit>
        <trans-unit id="0979e25ae12ecf75e6954405c51afc218144f433" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, received by the socket.</source>
          <target state="translated">Desviación media del tamaño de los paquetes,en bytes,recibida por el enchufe.</target>
        </trans-unit>
        <trans-unit id="24a6380cb9d560f221f5bab0ac3ac216888c3989" translate="yes" xml:space="preserve">
          <source>Average packet size deviation, in bytes, sent from the socket.</source>
          <target state="translated">Desviación media del tamaño de los paquetes,en bytes,enviada desde el enchufe.</target>
        </trans-unit>
        <trans-unit id="ba5da32502768a08b71f47f54787f1a18d984da2" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, received by the socket.</source>
          <target state="translated">Tamaño medio de los paquetes,en bytes,recibidos por el zócalo.</target>
        </trans-unit>
        <trans-unit id="a548c980c935b270267b69573bc6d8a367a0ccd7" translate="yes" xml:space="preserve">
          <source>Average size of packets, in bytes, sent from the socket.</source>
          <target state="translated">Tamaño medio de los paquetes,en bytes,enviados desde el zócalo.</target>
        </trans-unit>
        <trans-unit id="9310b13917c5edfa2bbc94f7c936299d95178f26" translate="yes" xml:space="preserve">
          <source>Avestan</source>
          <target state="translated">Avestan</target>
        </trans-unit>
        <trans-unit id="7666ec90c7fb3e6a7737d1ce78d04e16a63f834f" translate="yes" xml:space="preserve">
          <source>Avoid calling this on the root keys, as it can be slow.</source>
          <target state="translated">Evita llamar a esto en las claves de la raíz,ya que puede ser lento.</target>
        </trans-unit>
        <trans-unit id="9ecc5c52604408ca037f4b32a55f99303082c7df" translate="yes" xml:space="preserve">
          <source>Avoid md5 for hashing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8eebcbcc17ab43565fe594806f1d03745ee4ec86" translate="yes" xml:space="preserve">
          <source>Avoid mixing multiple &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; with driver reload requests.</source>
          <target state="translated">Evite mezclar varios &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; con solicitudes de recarga de controladores.</target>
        </trans-unit>
        <trans-unit id="64e751996a0cede9d2045cdc8ba23d1357661337" translate="yes" xml:space="preserve">
          <source>Avoid storing a retrieved persistent term in a process if that persistent term could be deleted or updated in the future. If a process holds a reference to a persistent term when the term is deleted, the process will be garbage collected and the term copied to process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98289f5c4b0096f8495ef524df96672c88d3f383" translate="yes" xml:space="preserve">
          <source>Avoid the following values of &lt;code&gt;ResourceId&lt;/code&gt;, otherwise Erlang/OTP does not work properly:</source>
          <target state="translated">Evite los siguientes valores de &lt;code&gt;ResourceId&lt;/code&gt; ; de lo contrario, Erlang / OTP no funcionar&amp;aacute; correctamente:</target>
        </trans-unit>
        <trans-unit id="69f8c47d6443544fd8368765fa26d69b3ce0d361" translate="yes" xml:space="preserve">
          <source>Avoid updating or deleting more than one persistent term at a time. Each deleted term will trigger its own global GC. That means that deleting N terms will make the system less responsive N times longer than deleting a single persistent term. Therefore, terms that are to be updated at the same time should be collected into a larger term, for example, a map or a tuple.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fd4af0dc21ec9248c3098d7f5fe046b4b61faff" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;IP_ADJUSTMENT&lt;/code&gt; directly. Use &lt;code&gt;SET_I_REL()&lt;/code&gt; or one of the macros that invoke such as &lt;code&gt;FAIL()&lt;/code&gt; or &lt;code&gt;JUMP()&lt;/code&gt; defined in &lt;code&gt;macros.tab&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ebd07d23bcd301e7132f885cb8e225fce4de1c1" translate="yes" xml:space="preserve">
          <source>Avoiding common mistakes:</source>
          <target state="translated">Evitar los errores comunes:</target>
        </trans-unit>
        <trans-unit id="8677c671e8bfb9480004f697032e107bf2d89ade" translate="yes" xml:space="preserve">
          <source>B/SFR</source>
          <target state="translated">B/SFR</target>
        </trans-unit>
        <trans-unit id="d6a2b7b76ae3b1331d97630c6fbdfda1e2e20faf" translate="yes" xml:space="preserve">
          <source>BEAM is a register-based virtual machine. It has 1024 virtual registers that are used for holding temporary values and for passing arguments when calling functions. Variables that need to survive a function call are saved to the stack.</source>
          <target state="translated">BEAM es una máquina virtual basada en registros.Tiene 1024 registros virtuales que se usan para mantener valores temporales y para pasar argumentos cuando se llaman funciones.Las variables que necesitan sobrevivir a una llamada a una función se guardan en la pila.</target>
        </trans-unit>
        <trans-unit id="4e374de82335c7a8d86c8e4d74077c948da138e0" translate="yes" xml:space="preserve">
          <source>BEAM is a threaded-code interpreter. Each instruction is word pointing directly to executable C-code, making instruction dispatching very fast.</source>
          <target state="translated">BEAM es un intérprete de código de hilo.Cada instrucción es una palabra que apunta directamente al código C ejecutable,haciendo que el envío de instrucciones sea muy rápido.</target>
        </trans-unit>
        <trans-unit id="afd33b1e8c4969947e4dc49baade4763f8ff8b20" translate="yes" xml:space="preserve">
          <source>BEAM_FORMAT_NUMBER</source>
          <target state="translated">BEAM_FORMAT_NUMBER</target>
        </trans-unit>
        <trans-unit id="7efce4656362191b2f6893e9594afff40994fed8" translate="yes" xml:space="preserve">
          <source>BIFs are functions that for some reason are built-in to the Erlang virtual machine. BIFs often implement functionality that is impossible or is too inefficient to implement in Erlang. Some BIFs can be called using the function name only but they are by default belonging to the &lt;code&gt;erlang&lt;/code&gt; module. For example, the call to the BIF &lt;code&gt;trunc&lt;/code&gt; below is equivalent to a call to &lt;code&gt;erlang:trunc&lt;/code&gt;.</source>
          <target state="translated">Los BIF son funciones que, por alguna raz&amp;oacute;n, est&amp;aacute;n integradas en la m&amp;aacute;quina virtual Erlang. Los BIF a menudo implementan funciones que son imposibles o demasiado ineficientes para implementar en Erlang. Algunos BIF se pueden llamar usando solo el nombre de la funci&amp;oacute;n, pero por defecto pertenecen al m&amp;oacute;dulo &lt;code&gt;erlang&lt;/code&gt; . Por ejemplo, la llamada al BIF &lt;code&gt;trunc&lt;/code&gt; a continuaci&amp;oacute;n es equivalente a una llamada a &lt;code&gt;erlang:trunc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="890c2ec47feac80bf8654b893be74f130c02facf" translate="yes" xml:space="preserve">
          <source>BIFs are implemented in C code in the runtime system. BIFs do things that are difficult or impossible to implement in Erlang. Most of the BIFs belong to the module &lt;code&gt;erlang&lt;/code&gt; but there are also BIFs belonging to a few other modules, for example &lt;code&gt;lists&lt;/code&gt; and &lt;code&gt;ets&lt;/code&gt;.</source>
          <target state="translated">Los BIF se implementan en c&amp;oacute;digo C en el sistema de ejecuci&amp;oacute;n. Los BIF hacen cosas que son dif&amp;iacute;ciles o imposibles de implementar en Erlang. La mayor&amp;iacute;a de los BIF pertenecen al m&amp;oacute;dulo &lt;code&gt;erlang&lt;/code&gt; , pero tambi&amp;eacute;n hay BIF que pertenecen a algunos otros m&amp;oacute;dulos, por ejemplo, &lt;code&gt;lists&lt;/code&gt; y &lt;code&gt;ets&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42278b69b892fd26dcff3099719503a85d2ed515" translate="yes" xml:space="preserve">
          <source>BIFs can fail for various reasons. All BIFs fail with reason &lt;code&gt;badarg&lt;/code&gt; if they are called with arguments of an incorrect type. The other reasons are described in the description of each individual BIF.</source>
          <target state="translated">Los BIF pueden fallar por varias razones. Todos los BIF fallan con raz&amp;oacute;n &lt;code&gt;badarg&lt;/code&gt; si se llaman con argumentos de un tipo incorrecto. Las otras razones se describen en la descripci&amp;oacute;n de cada BIF individual.</target>
        </trans-unit>
        <trans-unit id="0971b2037c9ec621fb794e414dbe4e3e6e9ea234" translate="yes" xml:space="preserve">
          <source>Back at the top level, the next character (&quot;c&quot;) is compared with what subpattern 2 matched, which was &quot;a&quot;. This fails. As the recursion is treated as an atomic group, there are now no backtracking points, and so the entire match fails. (Perl can now re-enter the recursion and try the second alternative.) However, if the pattern is written with the alternatives in the other order, things are different:</source>
          <target state="translated">De vuelta al nivel superior,el siguiente personaje (&quot;c&quot;)se compara con lo que el subpatrón 2 coincidió,que era &quot;a&quot;.Esto falla.Como la recursividad se trata como un grupo atómico,ahora no hay puntos de retroceso,y por lo tanto todo el emparejamiento falla.(Perl puede ahora volver a entrar en la recursividad e intentar la segunda alternativa.)Sin embargo,si el patrón se escribe con las alternativas en el otro orden,las cosas son diferentes:</target>
        </trans-unit>
        <trans-unit id="48a05ca6fa60802ff208e26ea9e34464ac28a529" translate="yes" xml:space="preserve">
          <source>Back references of this type cause the group that they reference to be treated as an atomic group. Once the whole group has been matched, a subsequent matching failure cannot cause backtracking into the middle of the group.</source>
          <target state="translated">Las referencias retrospectivas de este tipo hacen que el grupo al que se refieren sea tratado como un grupo atómico.Una vez que todo el grupo ha sido emparejado,un fallo de emparejamiento posterior no puede causar que se retroceda al centro del grupo.</target>
        </trans-unit>
        <trans-unit id="ab429c0e231fa759e013662e3a14521ce2c5b79b" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt;.</source>
          <target state="translated">Funciones de backend utilizadas por &lt;code&gt;inet:gethostbyaddr/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4aa3add341382a466d659f858fca56aef2ce0f58" translate="yes" xml:space="preserve">
          <source>Backend functions used by &lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt;.</source>
          <target state="translated">Funciones de backend utilizadas por &lt;code&gt;inet:gethostbyname/1,2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="64dd60fe1a049fe6db3eb1369dec2e42bf428e21" translate="yes" xml:space="preserve">
          <source>Background</source>
          <target state="translated">Background</target>
        </trans-unit>
        <trans-unit id="5563f67965aa081b7f33678be0a71475fa96ccb8" translate="yes" xml:space="preserve">
          <source>Backing Up the Registry to Mnesia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a826c283ce6a52f2d32eb19de6510cb9098ad99b" translate="yes" xml:space="preserve">
          <source>Backslash</source>
          <target state="translated">Backslash</target>
        </trans-unit>
        <trans-unit id="88d130a66de8e5db01660642d9f23e1f0eef97dd" translate="yes" xml:space="preserve">
          <source>Backspace</source>
          <target state="translated">Backspace</target>
        </trans-unit>
        <trans-unit id="84e3bb9dd16cb2ba0f02d7245545feda5e3cabcb" translate="yes" xml:space="preserve">
          <source>Backspace.</source>
          <target state="translated">Backspace.</target>
        </trans-unit>
        <trans-unit id="dd96994d01e723dd6f9b0bdb6119722dbeb9faf0" translate="yes" xml:space="preserve">
          <source>Backup</source>
          <target state="translated">Backup</target>
        </trans-unit>
        <trans-unit id="7fc5d71b3eae328beb908064e6dec5ed2151041f" translate="yes" xml:space="preserve">
          <source>Backup and restore of C node state to and from &lt;code&gt;Mnesia&lt;/code&gt;</source>
          <target state="translated">Copia de seguridad y restauraci&amp;oacute;n del estado del nodo C desde y hacia &lt;code&gt;Mnesia&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="643aeb5ad5e07a8a0aedfaec9f291b8b2d8eb1e8" translate="yes" xml:space="preserve">
          <source>Backup operation are performed with the following functions:</source>
          <target state="translated">La operación de respaldo se realiza con las siguientes funciones:</target>
        </trans-unit>
        <trans-unit id="a1b1261f879477741073cc5643737c50cece295a" translate="yes" xml:space="preserve">
          <source>Backup persistent data handled by the manager.</source>
          <target state="translated">Copia de seguridad de los datos persistentes manejados por el gerente.</target>
        </trans-unit>
        <trans-unit id="48159fb2ea43e7a90492b5cc62df25d733040b1d" translate="yes" xml:space="preserve">
          <source>Backup persistent/permanent data handled by the agent (such as local-db, mib-data and vacm).</source>
          <target state="translated">Copia de seguridad de los datos persistentes/permanentes manejados por el agente (como local-db,mib-data y vacm).</target>
        </trans-unit>
        <trans-unit id="76b2ca97753e81a47e64d73e23600b3684a357e4" translate="yes" xml:space="preserve">
          <source>Backup, restore, fallback, and disaster recovery</source>
          <target state="translated">Copia de seguridad,restauración,retroceso y recuperación de desastres</target>
        </trans-unit>
        <trans-unit id="8afb5bf327667dc553b8e9a32ac34a080d815b3b" translate="yes" xml:space="preserve">
          <source>BackupDir cannot be identical to DbDir.</source>
          <target state="translated">BackupDir no puede ser idéntico a DbDir.</target>
        </trans-unit>
        <trans-unit id="f132fe31e8d713406288c3f7dcb9dbc8378cfdf5" translate="yes" xml:space="preserve">
          <source>Backward character</source>
          <target state="translated">El carácter atrasado</target>
        </trans-unit>
        <trans-unit id="82c36d6a4f52a2dc6589f184f22fdf4b95e97b1c" translate="yes" xml:space="preserve">
          <source>Backward kill line</source>
          <target state="translated">La línea de muerte hacia atrás</target>
        </trans-unit>
        <trans-unit id="5be769b9776675c14c24d6f30ed3fba3e401a997" translate="yes" xml:space="preserve">
          <source>Backward kill word</source>
          <target state="translated">La palabra de muerte de atrás...</target>
        </trans-unit>
        <trans-unit id="c0b7a7d6f9015db486c407e9f3cba9dc8dea0ff8" translate="yes" xml:space="preserve">
          <source>Backward word</source>
          <target state="translated">Palabra atrasada</target>
        </trans-unit>
        <trans-unit id="1161e058ccd842cdd5e5fe2efd102fbd9ed43bbd" translate="yes" xml:space="preserve">
          <source>Bad argument in an arithmetic expression.</source>
          <target state="translated">Mal argumento en una expresión aritmética.</target>
        </trans-unit>
        <trans-unit id="af4ade1fd757cc8bcb7e76a2f6d37f1ec5bbb7b5" translate="yes" xml:space="preserve">
          <source>Bad argument.</source>
          <target state="translated">Mal argumento.</target>
        </trans-unit>
        <trans-unit id="c4cf9343231b13c7b7056a157910cd49cc8ff14e" translate="yes" xml:space="preserve">
          <source>Bad argument. The argument is of wrong data type, or is otherwise badly formed.</source>
          <target state="translated">Mal argumento.El argumento es de un tipo de datos erróneo,o está mal formado.</target>
        </trans-unit>
        <trans-unit id="3401e9b8481ac17e3759a0b06770cb6fc7bbc79c" translate="yes" xml:space="preserve">
          <source>Bad input arguments to &lt;code&gt;open_port&lt;/code&gt;.</source>
          <target state="translated">Argumentos de entrada &lt;code&gt;open_port&lt;/code&gt; para open_port .</target>
        </trans-unit>
        <trans-unit id="c79c6d51e7687de96c195245b69faaf4a624b33e" translate="yes" xml:space="preserve">
          <source>Balinese</source>
          <target state="translated">Balinese</target>
        </trans-unit>
        <trans-unit id="00a38285d256e3839414c33b846ee83469fa016a" translate="yes" xml:space="preserve">
          <source>Bamum</source>
          <target state="translated">Bamum</target>
        </trans-unit>
        <trans-unit id="26e5990472188146a21fbe9216d5e35fd4688af2" translate="yes" xml:space="preserve">
          <source>Base Protocol Command AVP Table</source>
          <target state="translated">Tabla AVP del Comando de Protocolo de la Base</target>
        </trans-unit>
        <trans-unit id="d9e2287d49a0defabf83f04683cfd099fe9d2461" translate="yes" xml:space="preserve">
          <source>Based on this feature, the OTP application SASL provides a framework for upgrading and downgrading between different versions of an entire release in runtime. This is called &lt;strong&gt;release handling&lt;/strong&gt;.</source>
          <target state="translated">Basado en esta caracter&amp;iacute;stica, la aplicaci&amp;oacute;n OTP SASL proporciona un marco para actualizar y degradar entre diferentes versiones de una versi&amp;oacute;n completa en tiempo de ejecuci&amp;oacute;n. A esto se le llama &lt;strong&gt;manipulaci&amp;oacute;n de liberaci&amp;oacute;n&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="37e7613ad8170257c16610a53d06cfb1a6379742" translate="yes" xml:space="preserve">
          <source>Basic AVP Data Formats</source>
          <target state="translated">Formatos básicos de datos AVP</target>
        </trans-unit>
        <trans-unit id="6b9ebfc825400dcd8efd5ccd3ed7166c57bc3280" translate="yes" xml:space="preserve">
          <source>Basic Encoding Rules (BER)</source>
          <target state="translated">Reglas básicas de codificación (BER)</target>
        </trans-unit>
        <trans-unit id="20b19d89ef0aed3f2d4f1afed1d3f801c6b85aa5" translate="yes" xml:space="preserve">
          <source>Basic example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67d805a220598736617f1f5898d5984c11a47e33" translate="yes" xml:space="preserve">
          <source>Basic functions on Core Erlang abstract syntax trees.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60289c0d7f3cdae9e1d8eee79fef52de4c163a03" translate="yes" xml:space="preserve">
          <source>Basic knowledge of Emacs and Erlang/OTP.</source>
          <target state="translated">Conocimientos básicos de Emacs y Erlang/OTP.</target>
        </trans-unit>
        <trans-unit id="d3e42820dfcf4a655372ec7f0d0863e80c0b502a" translate="yes" xml:space="preserve">
          <source>Basic knowledge of property based testing is assumed in the following. It is also assumed that at least one of the following property based testing tools is installed and available in the library path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9dd9d44759000b74a8ffb28eb7a9b5d4bda605bf" translate="yes" xml:space="preserve">
          <source>Basic usage consists of creating a representation of a locally implemented Diameter node and its capabilities with &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt;, adding transport capability using &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; and sending Diameter requests and receiving Diameter answers with &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt;. Incoming Diameter requests are communicated as callbacks to a &lt;code&gt;diameter_app(3)&lt;/code&gt; callback modules as specified in the service configuration.</source>
          <target state="translated">El uso b&amp;aacute;sico consiste en crear una representaci&amp;oacute;n de un nodo Diameter implementado localmente y sus capacidades con &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; , agregar capacidad de transporte usando &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; y enviar solicitudes de Diameter y recibir respuestas de Diameter con &lt;code&gt;&lt;a href=&quot;#call-4&quot;&gt;call/4&lt;/a&gt;&lt;/code&gt; . Las solicitudes entrantes de Diameter se comunican como devoluciones de llamada a un m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada de &lt;code&gt;diameter_app(3)&lt;/code&gt; como se especifica en la configuraci&amp;oacute;n del servicio.</target>
        </trans-unit>
        <trans-unit id="d03e3070f8930ea991974fa59117d8692bbcffdd" translate="yes" xml:space="preserve">
          <source>Basically the same as UTF-32, but without some Unicode semantics, defined by IEEE, and has little use as a separate encoding standard. For all normal (and possibly abnormal) use, UTF-32 and UCS-4 are interchangeable.</source>
          <target state="translated">Básicamente lo mismo que el UTF-32,pero sin alguna semántica de Unicode,definida por el IEEE,y tiene poco uso como un estándar de codificación separado.Para todo uso normal (y posiblemente anormal),UTF-32 y UCS-4 son intercambiables.</target>
        </trans-unit>
        <trans-unit id="7299a57060c9f81f94931f5581972334cd31d5c2" translate="yes" xml:space="preserve">
          <source>Basically, the &lt;code&gt;etags&lt;/code&gt; utility is ran using the following form:</source>
          <target state="translated">B&amp;aacute;sicamente, la utilidad &lt;code&gt;etags&lt;/code&gt; se ejecuta con el siguiente formulario:</target>
        </trans-unit>
        <trans-unit id="38c83af4610a697d6724ff3bf3f45adb4124041d" translate="yes" xml:space="preserve">
          <source>Basically, the procedure is as follows:</source>
          <target state="translated">Básicamente,el procedimiento es el siguiente:</target>
        </trans-unit>
        <trans-unit id="0912c94afdbb67bfe98617e8b201d30776d260bb" translate="yes" xml:space="preserve">
          <source>Basics of the ssh protocol's algorithms handling</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c6f5bb2c23fc72e02ed4fe91c08eb86ab7eb097" translate="yes" xml:space="preserve">
          <source>Basics on how computers are programmed</source>
          <target state="translated">Los fundamentos de cómo se programan los ordenadores</target>
        </trans-unit>
        <trans-unit id="075b61c3bd00c5372d9b40a37e76d0e216819b8e" translate="yes" xml:space="preserve">
          <source>Bassa_Vah</source>
          <target state="translated">Bassa_Vah</target>
        </trans-unit>
        <trans-unit id="8c4b76d47cc4be674049d954ba4923101a8b3e4d" translate="yes" xml:space="preserve">
          <source>Batak</source>
          <target state="translated">Batak</target>
        </trans-unit>
        <trans-unit id="61a2382405e7fcf34f5d81f378bf0ae437ec6326" translate="yes" xml:space="preserve">
          <source>Be Less Aggressive</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58c655b2cd5d86487b8917d2d93a7efbac26efff" translate="yes" xml:space="preserve">
          <source>Be aware that &lt;code&gt;enif_schedule_nif&lt;/code&gt;, as its name implies, only schedules the NIF for future execution. The calling NIF does not block waiting for the scheduled NIF to execute and return. This means that the calling NIF cannot expect to receive the scheduled NIF return value and use it for further operations.</source>
          <target state="translated">Tenga en cuenta que &lt;code&gt;enif_schedule_nif&lt;/code&gt; , como su nombre lo indica, solo programa el NIF para su ejecuci&amp;oacute;n futura. El NIF que llama no bloquea la espera de que se ejecute y regrese el NIF programado. Esto significa que el NIF que llama no puede esperar recibir el valor de retorno del NIF programado y utilizarlo para operaciones posteriores.</target>
        </trans-unit>
        <trans-unit id="1bb1d4b8960f0882b546a0b46a0612e449641efb" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process, it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">Tenga cuidado al establecer el tiempo de apagado en &lt;code&gt;infinity&lt;/code&gt; cuando el proceso hijo es un trabajador. Debido a que, en esta situaci&amp;oacute;n, la terminaci&amp;oacute;n del &amp;aacute;rbol de supervisi&amp;oacute;n depende del proceso hijo, debe implementarse de manera segura y su procedimiento de limpieza siempre debe regresar.</target>
        </trans-unit>
        <trans-unit id="ffb65a64fc348102ef56127a672718177ad2a7ab" translate="yes" xml:space="preserve">
          <source>Be careful when setting the shutdown time to &lt;code&gt;infinity&lt;/code&gt; when the child process is a worker. Because, in this situation, the termination of the supervision tree depends on the child process; it must be implemented in a safe way and its cleanup procedure must always return.</source>
          <target state="translated">Tenga cuidado al establecer el tiempo de apagado en &lt;code&gt;infinity&lt;/code&gt; cuando el proceso hijo es un trabajador. Porque, en esta situaci&amp;oacute;n, la terminaci&amp;oacute;n del &amp;aacute;rbol de supervisi&amp;oacute;n depende del proceso hijo; debe implementarse de manera segura y su procedimiento de limpieza siempre debe regresar.</target>
        </trans-unit>
        <trans-unit id="2fd62499ab8def7b8b69fee274c4b8917538a4e1" translate="yes" xml:space="preserve">
          <source>Be careful with the version header, use &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; when appropriate.</source>
          <target state="translated">Tenga cuidado con el encabezado de la versi&amp;oacute;n, use &lt;code&gt;ei_x_new_with_version()&lt;/code&gt; cuando sea apropiado.</target>
        </trans-unit>
        <trans-unit id="7301ce2a6e0b85e60f35ab88d520e5d9725285df" translate="yes" xml:space="preserve">
          <source>Be started in a way that makes the process fit into a supervision tree</source>
          <target state="translated">Se iniciará de manera que el proceso encaje en un árbol de supervisión...</target>
        </trans-unit>
        <trans-unit id="105320a56b534ace4c0d31c6412a7c5d4168a815" translate="yes" xml:space="preserve">
          <source>Be sure &lt;strong&gt;not&lt;/strong&gt; no name the directory containing the measurement binaries starting with 'megaco-', e.g. megaco-meas. This will confuse the erlang application loader (erlang applications are named, e.g. megaco-1.0.2).</source>
          <target state="translated">Aseg&amp;uacute;rese de &lt;strong&gt;no&lt;/strong&gt; nombrar el directorio que contiene los binarios de medici&amp;oacute;n que comienzan con 'megaco-', por ejemplo, megaco-Meas. Esto confundir&amp;aacute; al cargador de aplicaciones erlang (las aplicaciones erlang se nombran, por ejemplo, megaco-1.0.2).</target>
        </trans-unit>
        <trans-unit id="00d0130a026229dfaa52123c4c578740ea2d109c" translate="yes" xml:space="preserve">
          <source>Be sure to read about &lt;code&gt;Long-running NIFs&lt;/code&gt; before writing a NIF.</source>
          <target state="translated">Aseg&amp;uacute;rese de leer acerca de las NIF de &lt;code&gt;Long-running NIFs&lt;/code&gt; antes de escribir una NIF.</target>
        </trans-unit>
        <trans-unit id="88f10cc94f264a9568d393b9037d05b81b7daf69" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;-dist_auto_connect&lt;/code&gt; is set to &lt;code&gt;never&lt;/code&gt;, the system will have to manually call &lt;code&gt; net_kernel:connect_node/1&lt;/code&gt; in order to start the distribution. If the distribution channel is closed, when a node uses a dynamic node name, the node will stop the distribution and a new call to &lt;code&gt; net_kernel:connect_node/1&lt;/code&gt; has to be made. Note that the node name may change if the distribution is dropped and then set up again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2edff3a35b65adb5039205d11c2d7f121323a42" translate="yes" xml:space="preserve">
          <source>Because a &lt;code&gt;simple_one_for_one&lt;/code&gt; supervisor can have many children, it shuts them all down asynchronously. This means that the children will do their cleanup in parallel and therefore the order in which they are stopped is not defined.</source>
          <target state="translated">Debido a que un supervisor &lt;code&gt;simple_one_for_one&lt;/code&gt; puede tener muchos hijos, los cierra a todos de forma asincr&amp;oacute;nica. Esto significa que los ni&amp;ntilde;os har&amp;aacute;n su limpieza en paralelo y, por lo tanto, el orden en el que se detendr&amp;aacute;n no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="abef4f4009e13039f29fcccf0a57474c315686c1" translate="yes" xml:space="preserve">
          <source>Because lists are commonly used, they have shorthand type notations. The types &lt;code&gt;list(T)&lt;/code&gt; and &lt;code&gt;nonempty_list(T)&lt;/code&gt; have the shorthands &lt;code&gt;[T]&lt;/code&gt; and &lt;code&gt;[T,...]&lt;/code&gt;, respectively. The only difference between the two shorthands is that &lt;code&gt;[T]&lt;/code&gt; can be an empty list but &lt;code&gt;[T,...]&lt;/code&gt; cannot.</source>
          <target state="translated">Debido a que las listas se usan com&amp;uacute;nmente, tienen notaciones de tipo abreviado. Los tipos &lt;code&gt;list(T)&lt;/code&gt; y &lt;code&gt;nonempty_list(T)&lt;/code&gt; tienen las abreviaturas &lt;code&gt;[T]&lt;/code&gt; y &lt;code&gt;[T,...]&lt;/code&gt; , respectivamente. La &amp;uacute;nica diferencia entre las dos abreviaturas es que &lt;code&gt;[T]&lt;/code&gt; puede ser una lista vac&amp;iacute;a pero &lt;code&gt;[T,...]&lt;/code&gt; no.</target>
        </trans-unit>
        <trans-unit id="5b3a7dd1ee18a1a87ef5bd7ed89f7551e8ad10ce" translate="yes" xml:space="preserve">
          <source>Because of network and processing delays, the period of tracing is approximate.</source>
          <target state="translated">Debido a las demoras en la red y en el procesamiento,el período de rastreo es aproximado.</target>
        </trans-unit>
        <trans-unit id="d37fd4abb225a06f4a6768bb951238ff22bfe669" translate="yes" xml:space="preserve">
          <source>Because of peculiarities in the dynamic loading interfaces on different platforms, the returned string is only guaranteed to describe the correct error &lt;strong&gt;if format_error/1 is called in the same instance of the Erlang virtual machine as the error appeared in&lt;/strong&gt; (meaning the same operating system process).</source>
          <target state="translated">Debido a las peculiaridades de las interfaces de carga din&amp;aacute;mica en diferentes plataformas, solo se garantiza que la cadena devuelta describe el error correcto &lt;strong&gt;si se llama a format_error / 1 en la misma instancia de la m&amp;aacute;quina virtual Erlang en la que apareci&amp;oacute; el error&lt;/strong&gt; (es decir, el mismo proceso del sistema operativo ).</target>
        </trans-unit>
        <trans-unit id="2937aec3114f354420a4dc65f7919f8480931c3a" translate="yes" xml:space="preserve">
          <source>Because of subtype relations that exist between types, types form a lattice where the top-most element, &lt;code&gt;any()&lt;/code&gt;, denotes the set of all Erlang terms and the bottom-most element, &lt;code&gt;none()&lt;/code&gt;, denotes the empty set of terms.</source>
          <target state="translated">Debido a las relaciones de subtipo que existen entre los tipos, los tipos forman un enrejado donde el elemento superior, &lt;code&gt;any()&lt;/code&gt; , denota el conjunto de todos los t&amp;eacute;rminos de Erlang y el elemento inferior, &lt;code&gt;none()&lt;/code&gt; , denota el conjunto vac&amp;iacute;o de t&amp;eacute;rminos.</target>
        </trans-unit>
        <trans-unit id="022a498b7c46fc56b49452af050953c22bfbf306" translate="yes" xml:space="preserve">
          <source>Because of the limited length of atoms, it is recommended to use &lt;code&gt;-run&lt;/code&gt; instead.</source>
          <target state="translated">Debido a la longitud limitada de los &amp;aacute;tomos, se recomienda utilizar &lt;code&gt;-run&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="1384b995beb9b21c8a759c386f9768bb6e9bf48f" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\h&lt;/strong&gt;</source>
          <target state="translated">Se convierte en &lt;strong&gt;\ h&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="299f84debe52036e59ae03120fd4f1dabe601f72" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Ll}&lt;/strong&gt;</source>
          <target state="translated">Se convierte en &lt;strong&gt;\ p {Ll}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="4d91b3caacd37fdde510b95d27795a9af6bf8136" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Lu}&lt;/strong&gt;</source>
          <target state="translated">Se convierte en &lt;strong&gt;\ p {Lu}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="1c0abdb743817968c55df2e58d08673027964564" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{L}&lt;/strong&gt;</source>
          <target state="translated">Se convierte en &lt;strong&gt;\ p {L}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="730c516db3536d87659465b8430f3c06b9b28d02" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Nd}&lt;/strong&gt;</source>
          <target state="translated">Se convierte en &lt;strong&gt;\ p {Nd}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="af6446ff6bb33935f80c0e27353d8c85c94660f6" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xan}&lt;/strong&gt;</source>
          <target state="translated">Se convierte en &lt;strong&gt;\ p {Xan}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="990d22b3bf8b56b82387696e9e8f32390beb8e0c" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xps}&lt;/strong&gt;</source>
          <target state="translated">Se convierte en &lt;strong&gt;\ p {Xps}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="89fc848e28a9b477f8a3b6e31d45687e11d42e23" translate="yes" xml:space="preserve">
          <source>Becomes &lt;strong&gt;\p{Xwd}&lt;/strong&gt;</source>
          <target state="translated">Se convierte en &lt;strong&gt;\ p {Xwd}&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="0ebae434cd88ef2302f9bbb202778d21d2e46d19" translate="yes" xml:space="preserve">
          <source>Before ERTS 10.0 (OTP 21.0), monitoring a process could fail with &lt;code&gt;badarg&lt;/code&gt; if the monitored process resided on a primitive node (such as erl_interface or jinterface), where remote process monitoring is not implemented.</source>
          <target state="translated">Antes de ERTS 10.0 (OTP 21.0), la supervisi&amp;oacute;n de un proceso pod&amp;iacute;a fallar con &lt;code&gt;badarg&lt;/code&gt; si el proceso supervisado resid&amp;iacute;a en un nodo primitivo (como erl_interface o jinterface), donde no se implementa la supervisi&amp;oacute;n remota de procesos.</target>
        </trans-unit>
        <trans-unit id="c2170fbb9997cb7343b013f87d0b07f06679bee2" translate="yes" xml:space="preserve">
          <source>Before ERTS 5.9 it was possible to configure a smaller number of thread-specific instances than schedulers. This is, however, not possible anymore.</source>
          <target state="translated">Antes de la ERTS 5.9 era posible configurar un número menor de instancias específicas de hilos que los programadores.Sin embargo,esto ya no es posible.</target>
        </trans-unit>
        <trans-unit id="60f2fe367a59604d77c1ee7cdc5c0f81f65eda6e" translate="yes" xml:space="preserve">
          <source>Before ERTS 7.0 (Erlang/OTP 18), the return value from &lt;code&gt;enif_make_badarg&lt;/code&gt; had to be returned from the NIF. This requirement is now lifted as the return value from the NIF is ignored if &lt;code&gt;enif_make_badarg&lt;/code&gt; has been invoked.</source>
          <target state="translated">Antes de ERTS 7.0 (Erlang / OTP 18), el valor de retorno de &lt;code&gt;enif_make_badarg&lt;/code&gt; ten&amp;iacute;a que ser devuelto desde el NIF. Este requisito ahora se elimina ya que el valor de retorno del NIF se ignora si se ha invocado &lt;code&gt;enif_make_badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8ec3341c03352c2dcbc8cc1ae6efea67d454637" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.0 (OTP-20.0), all resource terms did compare equal to each other and to empty binaries (&lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;). If serialized, they would be recreated as plain empty binaries.</source>
          <target state="translated">Antes de ERTS 9.0 (OTP-20.0), todos los t&amp;eacute;rminos de recursos se comparaban entre s&amp;iacute; y con binarios vac&amp;iacute;os ( &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt; ). Si se serializan, se volver&amp;aacute;n a crear como binarios vac&amp;iacute;os.</target>
        </trans-unit>
        <trans-unit id="f16cc2c8df0cf217a1b01164cd474f9be586865b" translate="yes" xml:space="preserve">
          <source>Before ERTS 9.1 (OTP-20.1) only code points in the range 0-255 was accepted in the string. Now any unicode string is valid.</source>
          <target state="translated">Antes de ERTS 9.1 (OTP-20.1)sólo se aceptaban en la cadena puntos de código en el rango 0-255.Ahora cualquier cadena de unicode es válida.</target>
        </trans-unit>
        <trans-unit id="b8815a40e2ba0160069e9df632d708ff9fef831a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 17.1, if your test run consisted of multiple tests, cover would be started and stopped for each test within the test run. Separate logs would be available through the &quot;Coverage log&quot; link on the test suite result pages. These links are still available, but now they all point to the same page as the button on the top-level index page. The log contains the accumulated results for the complete test run. For details about this change, see the release notes.</source>
          <target state="translated">Antes de Erlang/OTP 17.1,si su prueba consistía en múltiples pruebas,la cobertura se iniciaría y se detendría para cada prueba dentro de la prueba.Se dispondría de registros separados a través del enlace &quot;Registro de cobertura&quot; en las páginas de resultados del conjunto de pruebas.Estos enlaces siguen estando disponibles,pero ahora todos apuntan a la misma página que el botón de la página de índice del nivel superior.El registro contiene los resultados acumulados de la ejecución completa de la prueba.Para obtener más detalles sobre este cambio,consulte las notas de la versión.</target>
        </trans-unit>
        <trans-unit id="173b9788d3472306f8bca6acb906380d15ebb018" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP 19, for fields without initial values, the singleton type &lt;code&gt;'undefined'&lt;/code&gt; was added to all declared types. In other words, the following two record declarations had identical effects:</source>
          <target state="translated">Antes de Erlang / OTP 19, para los campos sin valores iniciales, se agregaba el tipo singleton &lt;code&gt;'undefined'&lt;/code&gt; a todos los tipos declarados. En otras palabras, las siguientes dos declaraciones de registro tuvieron efectos id&amp;eacute;nticos:</target>
        </trans-unit>
        <trans-unit id="1ebd17eea52effdc10d3b387a5f97c65de3d711a" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;demonitor/1&lt;/code&gt; behaved completely asynchronously, that is, the monitor was active until the &quot;demonitor signal&quot; reached the monitored entity. This had one undesirable effect. You could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to receive a &lt;code&gt;DOWN&lt;/code&gt; message because of the monitor.</source>
          <target state="translated">Antes de Erlang / OTP R11B (ERTS 5.5) &lt;code&gt;demonitor/1&lt;/code&gt; se comportaba de forma completamente asincr&amp;oacute;nica, es decir, el monitor estaba activo hasta que la &quot;se&amp;ntilde;al del demonitor&quot; llegaba a la entidad monitoreada. Esto tuvo un efecto indeseable. Nunca podr&amp;iacute;a saber cu&amp;aacute;ndo se le garantiz&amp;oacute; que &lt;strong&gt;no&lt;/strong&gt; recibir&amp;iacute;a un mensaje &lt;code&gt;DOWN&lt;/code&gt; debido al monitor.</target>
        </trans-unit>
        <trans-unit id="c04cf745a3c4adfcd300b132adf03ceaef66e4c6" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R11B (ERTS 5.5) &lt;code&gt;unlink/1&lt;/code&gt; behaved completely asynchronously, that is, the link was active until the &quot;unlink signal&quot; reached the linked entity. This had an undesirable effect, as you could never know when you were guaranteed &lt;strong&gt;not&lt;/strong&gt; to be effected by the link.</source>
          <target state="translated">Antes de Erlang / OTP R11B (ERTS 5.5) &lt;code&gt;unlink/1&lt;/code&gt; se comportaba de forma completamente asincr&amp;oacute;nica, es decir, el enlace estaba activo hasta que la &quot;se&amp;ntilde;al de desvinculaci&amp;oacute;n&quot; llegaba a la entidad vinculada. Esto tuvo un efecto indeseable, ya que nunca podr&amp;iacute;a saber cu&amp;aacute;ndo estaba garantizado que &lt;strong&gt;no se&lt;/strong&gt; ver&amp;iacute;a afectado por el enlace.</target>
        </trans-unit>
        <trans-unit id="14149394b7877b033496395cfd6e420c1de55bda" translate="yes" xml:space="preserve">
          <source>Before Erlang/OTP R16, the port ID could be used as a key with proper casting, but after the rewrite of the port subsystem, this is no longer the case. With this function, you can achieve the same distribution based on port IDs as before Erlang/OTP R16.</source>
          <target state="translated">Antes de Erlang/OTP R16,la identificación del puerto podía ser usada como una llave con un molde adecuado,pero después de la reescritura del subsistema del puerto,este ya no es el caso.Con esta función,se puede lograr la misma distribución basada en las identificaciones de los puertos que antes de Erlang/OTP R16.</target>
        </trans-unit>
        <trans-unit id="055828a24a30444b0c0047933c2db837ba4b5188" translate="yes" xml:space="preserve">
          <source>Before Linux 3.8, this socket option could be set, but could not retrieved with &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt;. Since Linux 3.8, it is readable.</source>
          <target state="translated">Antes de Linux 3.8, esta opci&amp;oacute;n de socket se pod&amp;iacute;a configurar, pero no se pod&amp;iacute;a recuperar con &lt;code&gt;&lt;a href=&quot;#getopts-2&quot;&gt;getopts/2&lt;/a&gt;&lt;/code&gt; . Desde Linux 3.8, es legible.</target>
        </trans-unit>
        <trans-unit id="6730ee065030a00d88c78657469d331d9b0d4526" translate="yes" xml:space="preserve">
          <source>Before Linux 3.8, this socket option could be set, but not get. Only works for some socket types (e.g. &lt;code&gt;inet&lt;/code&gt;). If empty value is set, the binding is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de814773d3f4ef3f2f57f8421829e0616b1e21de" translate="yes" xml:space="preserve">
          <source>Before OTP 19, if the &lt;code&gt;on_load&lt;/code&gt; function failed, any previously current code would become old, essentially leaving the system without any working and reachable instance of the module. That problem has been eliminated in OTP 19.</source>
          <target state="translated">Antes de OTP 19, si la funci&amp;oacute;n &lt;code&gt;on_load&lt;/code&gt; fallaba, cualquier c&amp;oacute;digo previamente actual se volver&amp;iacute;a viejo, esencialmente dejando el sistema sin ninguna instancia funcional y accesible del m&amp;oacute;dulo. Ese problema se ha eliminado en OTP 19.</target>
        </trans-unit>
        <trans-unit id="4a26f53b8fd124a2195afd74e62b113f37b0fb17" translate="yes" xml:space="preserve">
          <source>Before OTP 22, the option &lt;code&gt;{nowarn_deprecated_function, MFAs}&lt;/code&gt; was only recognized when given in the file with attribute &lt;code&gt;-compile()&lt;/code&gt;. (The option &lt;code&gt;{nowarn_unused_function,FAs}&lt;/code&gt; was incorrectly documented to only work in a file, but it also worked when given in the option list.) Starting from OTP 22, all options that can be given in the file can also be given in the option list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac6280bf5d40e1ad7fd5221aeb6433bc3d21c56c" translate="yes" xml:space="preserve">
          <source>Before OTP 23, &lt;code&gt;Size&lt;/code&gt; was restricted to be an integer or a variable bound to an integer.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f89094b9481b9b8c9439e6748d4ddfcd926381b9" translate="yes" xml:space="preserve">
          <source>Before OTP 23, the expression defining the key &lt;code&gt;K&lt;/code&gt; was restricted to be either a single variable or a literal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0463b80fdbddc48ab1e8bca76239196573ee534f" translate="yes" xml:space="preserve">
          <source>Before OTP R14A (ERTS version 5.8), an implicitly qualified function call to a function having the same name as an auto-imported BIF always resulted in the BIF being called. In newer versions of the compiler, the local function is called instead. This is to avoid that future additions to the set of auto-imported BIFs do not silently change the behavior of old code.</source>
          <target state="translated">Antes del OTP R14A (ERTS versión 5.8),una llamada implícita de una función con el mismo nombre que un BIF autoimportado siempre daba lugar a que se llamara al BIF.En las versiones más recientes del compilador,se llama a la función local en su lugar.Esto es para evitar que futuras adiciones al conjunto de BIF autoimportados no cambien silenciosamente el comportamiento del código antiguo.</target>
        </trans-unit>
        <trans-unit id="e9407c86312dec72e66a3d1afa8b0f111f642f45" translate="yes" xml:space="preserve">
          <source>Before OTP R16 when an Erlang code module was loaded, all other execution in the VM were halted while the load operation was carried out in single threaded mode. This might not be a big problem for initial loading of modules during VM boot, but it can be a severe problem for availability when upgrading modules or adding new code on a VM with running payload. This problem grows with the number of cores as both the time it takes to wait for all schedulers to stop increases as well as the potential amount of halted ongoing work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e13a53367593b9c5d185550d151836210a12440" translate="yes" xml:space="preserve">
          <source>Before OTP R16 when trace settings were changed by &lt;code&gt;erlang:trace_pattern&lt;/code&gt;, all other execution in the VM were halted while the trace operation was carried out in single threaded mode. Similar to code loading, this can impose a severe problem for availability that grows with the number of cores.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83f7f3432428a2eb46f419c68c366cf2370764d0" translate="yes" xml:space="preserve">
          <source>Before OTP-17.4 the search algorithm had a problem as the search always started at the same position in the pool, the sentinel. This could lead to contention from concurrent searching processes. But even worse, it could lead to a &quot;bad&quot; state when searches fail with a high rate leading to new carriers instead being allocated. These new carriers may later be inserted into the pool due to bad utilization. If the frequency of insertions into the pool is higher than successful fetching from the pool, memory will eventually get exhausted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6244bef3fa35080f6be664c665752e7ae747946" translate="yes" xml:space="preserve">
          <source>Before OTP-23 the user &lt;strong&gt;needed&lt;/strong&gt; to supply a valid &lt;code&gt;-sname&lt;/code&gt; or &lt;code&gt;-name&lt;/code&gt; for &lt;code&gt;-remsh&lt;/code&gt; to work. This is still the case if the target node is not running OTP-23 or later.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b947a51569cc1cfaeef7b7ff4bf48e678a02c245" translate="yes" xml:space="preserve">
          <source>Before R14, parentheses were needed as follows:</source>
          <target state="translated">Antes del R14,se necesitaban los siguientes paréntesis:</target>
        </trans-unit>
        <trans-unit id="2556eabbc9f968558043782e1fcdc348f5df35c3" translate="yes" xml:space="preserve">
          <source>Before STDLIB 3.4 (OTP 20.0) compiled match specifications did not have an external representation. If passed through &lt;code&gt;binary_to_term(term_to_binary(CMS))&lt;/code&gt; or sent to another node and back, the result was always an empty binary &lt;code&gt;&amp;lt;&amp;lt;&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787dfaa6bed7bb38d94c61fd72dc85362aa99313" translate="yes" xml:space="preserve">
          <source>Before a driver can be called from Erlang, it must be loaded and opened. Loading is done using the &lt;code&gt;erl_ddll&lt;/code&gt; module (the &lt;code&gt;erl_ddll&lt;/code&gt; driver that loads dynamic driver is actually a driver itself). If loading is successful, the port can be opened with &lt;code&gt;open_port/2&lt;/code&gt;. The port name must match the name of the shared library and the name in the driver entry structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="777f496c9fcf95c8a759b97ce9f5b072f83c3c75" translate="yes" xml:space="preserve">
          <source>Before a driver can be called from Erlang, it must be loaded and opened. Loading is done using the &lt;code&gt;erl_ddll&lt;/code&gt; module (the &lt;code&gt;erl_ddll&lt;/code&gt; driver that loads dynamic driver is actually a driver itself). If loading is successfull, the port can be opened with &lt;code&gt;open_port/2&lt;/code&gt;. The port name must match the name of the shared library and the name in the driver entry structure.</source>
          <target state="translated">Antes de poder llamar a un controlador desde Erlang, debe cargarse y abrirse. La carga se realiza utilizando el m&amp;oacute;dulo &lt;code&gt;erl_ddll&lt;/code&gt; (el controlador &lt;code&gt;erl_ddll&lt;/code&gt; que carga el controlador din&amp;aacute;mico es en realidad un controlador). Si la carga es exitosa, el puerto se puede abrir con &lt;code&gt;open_port/2&lt;/code&gt; . El nombre del puerto debe coincidir con el nombre de la biblioteca compartida y el nombre en la estructura de entrada del controlador.</target>
        </trans-unit>
        <trans-unit id="20019fdf1abe6fd7869945f2f7dac92f9f72ebdc" translate="yes" xml:space="preserve">
          <source>Before a file is transferred, the following call is made to indicate the start of the file transfer and how large the file is. The return value of the callback function is to be a new value for the &lt;code&gt;UserProgressTerm&lt;/code&gt; that will be used as input the next time the callback function is called.</source>
          <target state="translated">Antes de transferir un archivo, se realiza la siguiente llamada para indicar el inicio de la transferencia del archivo y el tama&amp;ntilde;o del archivo. El valor de retorno de la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada ser&amp;aacute; un nuevo valor para &lt;code&gt;UserProgressTerm&lt;/code&gt; que se utilizar&amp;aacute; como entrada la pr&amp;oacute;xima vez que se llame a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada.</target>
        </trans-unit>
        <trans-unit id="159e2277de857354c36db29ad08f2c463be464e2" translate="yes" xml:space="preserve">
          <source>Before an application can be started, it must be &lt;strong&gt;loaded&lt;/strong&gt;. The application controller reads and stores the information from the &lt;code&gt;.app&lt;/code&gt; file:</source>
          <target state="translated">Antes de que se pueda iniciar una aplicaci&amp;oacute;n, se debe &lt;strong&gt;cargar&lt;/strong&gt; . El controlador de la aplicaci&amp;oacute;n lee y almacena la informaci&amp;oacute;n del archivo &lt;code&gt;.app&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="afd284c8bc9adc5dd4975944173af35c38112da6" translate="yes" xml:space="preserve">
          <source>Before an application makes its first access to a table, &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; is to be executed to ensure that the table is accessible from the local node. If the function times out, the application can choose to force a load of the local replica with &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; and deliberately lose all updates that can have been performed on the other nodes while the local node was down. If &lt;code&gt;Mnesia&lt;/code&gt; has loaded the table on another node already, or intends to do so, copy the table from that node to avoid unnecessary inconsistency.</source>
          <target state="translated">Antes de que una aplicaci&amp;oacute;n acceda por primera vez a una tabla, se &lt;code&gt;&lt;a href=&quot;mnesia#wait_for_tables-2&quot;&gt;mnesia:wait_for_tables(TabList, Timeout)&lt;/a&gt;&lt;/code&gt; para garantizar que la tabla sea accesible desde el nodo local. Si la funci&amp;oacute;n se agota, la aplicaci&amp;oacute;n puede optar por forzar una carga de la r&amp;eacute;plica local con &lt;code&gt;&lt;a href=&quot;mnesia#force_load_table-1&quot;&gt;mnesia:force_load_table(Tab)&lt;/a&gt;&lt;/code&gt; y perder deliberadamente todas las actualizaciones que se pueden haber realizado en los otros nodos mientras el nodo local estaba inactivo. Si &lt;code&gt;Mnesia&lt;/code&gt; ya ha cargado la tabla en otro nodo, o tiene la intenci&amp;oacute;n de hacerlo, copie la tabla de ese nodo para evitar inconsistencias innecesarias.</target>
        </trans-unit>
        <trans-unit id="75a2137a0d589f3ac4ee86651537916f812a4998" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, module data must be &lt;strong&gt;set up&lt;/strong&gt;. For instance, the cross reference and the unknown functions are computed when all module data are known. The functions that need complete data (&lt;code&gt;analyze&lt;/code&gt;, &lt;code&gt;q&lt;/code&gt;, &lt;code&gt;variables&lt;/code&gt;) take care of setting up data automatically. Module data need to be set up (again) after calls to any of the &lt;code&gt;add&lt;/code&gt;, &lt;code&gt;replace&lt;/code&gt;, &lt;code&gt;remove&lt;/code&gt;, &lt;code&gt;set_library_path&lt;/code&gt; or &lt;code&gt;update&lt;/code&gt; functions.</source>
          <target state="translated">Antes de que se pueda realizar cualquier an&amp;aacute;lisis, se deben &lt;strong&gt;configurar los&lt;/strong&gt; datos del m&amp;oacute;dulo . Por ejemplo, la referencia cruzada y las funciones desconocidas se calculan cuando se conocen todos los datos del m&amp;oacute;dulo. Las funciones que necesitan datos completos ( &lt;code&gt;analyze&lt;/code&gt; , &lt;code&gt;q&lt;/code&gt; , &lt;code&gt;variables&lt;/code&gt; ) se encargan de configurar los datos autom&amp;aacute;ticamente. Los datos del m&amp;oacute;dulo deben configurarse (nuevamente) despu&amp;eacute;s de las llamadas a cualquiera de las funciones &lt;code&gt;add&lt;/code&gt; , &lt;code&gt;replace&lt;/code&gt; , &lt;code&gt;remove&lt;/code&gt; , establecer &lt;code&gt;set_library_path&lt;/code&gt; o &lt;code&gt;update&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ca67bda82873ef4332d857192e18635d990609ed" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt;. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">Antes de que pueda realizarse cualquier an&amp;aacute;lisis, los m&amp;oacute;dulos involucrados deben &lt;strong&gt;compilarse Cover&lt;/strong&gt; . Esto significa que se agrega informaci&amp;oacute;n adicional al m&amp;oacute;dulo antes de que se compile en un binario que luego se &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;loaded&lt;/a&gt;&lt;/code&gt; . El archivo fuente del m&amp;oacute;dulo no se ve afectado y no se &lt;code&gt;.beam&lt;/code&gt; ning&amp;uacute;n archivo .beam .</target>
        </trans-unit>
        <trans-unit id="258fe4cd782832c98fba1da0a69f9a8b68aa3908" translate="yes" xml:space="preserve">
          <source>Before any analysis can take place, the involved modules must be &lt;strong&gt;Cover compiled&lt;/strong&gt;. This means that some extra information is added to the module before it is compiled into a binary which then is loaded. The source file of the module is not affected and no &lt;code&gt;.beam&lt;/code&gt; file is created.</source>
          <target state="translated">Antes de que pueda realizarse cualquier an&amp;aacute;lisis, los m&amp;oacute;dulos involucrados deben &lt;strong&gt;compilarse Cover&lt;/strong&gt; . Esto significa que se agrega informaci&amp;oacute;n adicional al m&amp;oacute;dulo antes de que se compile en un binario que luego se carga. El archivo fuente del m&amp;oacute;dulo no se ve afectado y no se &lt;code&gt;.beam&lt;/code&gt; ning&amp;uacute;n archivo .beam .</target>
        </trans-unit>
        <trans-unit id="451eac2b19829254921c8ba2920439b2b92145f5" translate="yes" xml:space="preserve">
          <source>Before applying a patch you need to do a &lt;strong&gt;full&lt;/strong&gt; build of OTP in the source directory.</source>
          <target state="translated">Antes de aplicar un parche, debe realizar una compilaci&amp;oacute;n &lt;strong&gt;completa&lt;/strong&gt; de OTP en el directorio de origen.</target>
        </trans-unit>
        <trans-unit id="0af32825676162dfe9c05e6f703b3efa51985180" translate="yes" xml:space="preserve">
          <source>Before asking a question you can browse the &lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt; mailing list archive&lt;/a&gt; and read the &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;Frequently Asked Questions&lt;/a&gt;.</source>
          <target state="translated">Antes de hacer una pregunta, puede explorar el &lt;a href=&quot;http://www.erlang.org/pipermail/erlang-questions/&quot;&gt;archivo de la lista de correo&lt;/a&gt; y leer las &lt;a href=&quot;http://www.erlang.org/faq/faq.html&quot;&gt;Preguntas frecuentes&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cda5c6edb9898f9347103f74f622c57ddde1c654" translate="yes" xml:space="preserve">
          <source>Before calling any of the other &lt;code&gt;Erl_Interface&lt;/code&gt; functions, call &lt;code&gt;erl_init()&lt;/code&gt; exactly once to initialize the library. &lt;code&gt;erl_init()&lt;/code&gt; takes two arguments. However, the arguments are no longer used by &lt;code&gt;Erl_Interface&lt;/code&gt; and are therefore to be specified as &lt;code&gt;erl_init(NULL,0)&lt;/code&gt;.</source>
          <target state="translated">Antes de llamar a cualquiera de las otras funciones &lt;code&gt;Erl_Interface&lt;/code&gt; , llame a &lt;code&gt;erl_init()&lt;/code&gt; exactamente una vez para inicializar la biblioteca. &lt;code&gt;erl_init()&lt;/code&gt; toma dos argumentos. Sin embargo, &lt;code&gt;Erl_Interface&lt;/code&gt; ya no usa los argumentos y, por lo tanto, deben especificarse como &lt;code&gt;erl_init(NULL,0)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="258c449a5777b1e0308a8597c71acd1f65986e67" translate="yes" xml:space="preserve">
          <source>Before calling any of the other functions in the library, initialize it by calling &lt;code&gt;ei_init()&lt;/code&gt; exactly once.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5913933d73f661127a755638c745adee88554860" translate="yes" xml:space="preserve">
          <source>Before calling any other function in Erl_Interface, the memory handling must be initiated:</source>
          <target state="translated">Antes de llamar a cualquier otra función en Erl_Interface,se debe iniciar el manejo de la memoria:</target>
        </trans-unit>
        <trans-unit id="c91078fc982ffe0902391841ac4ff114e2a4c572" translate="yes" xml:space="preserve">
          <source>Before execution of a group begins, the configuration function &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. The list of tuples returned from this function is passed to the test cases in the usual manner by argument &lt;code&gt;Config&lt;/code&gt;. &lt;code&gt;init_per_group/2&lt;/code&gt; is meant to be used for initializations common for the test cases in the group. After execution of the group is finished, function &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. This function is meant to be used for cleaning up after &lt;code&gt;init_per_group/2&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="translated">Antes de que comience la ejecuci&amp;oacute;n de un grupo, se &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; funci&amp;oacute;n de configuraci&amp;oacute;n init_per_group (GroupName, Config) . La lista de tuplas devuelta por esta funci&amp;oacute;n se pasa a los casos de prueba de la manera habitual mediante el argumento &lt;code&gt;Config&lt;/code&gt; . &lt;code&gt;init_per_group/2&lt;/code&gt; est&amp;aacute; destinado a ser utilizado para inicializaciones comunes para los casos de prueba en el grupo. Una vez finalizada la ejecuci&amp;oacute;n del grupo, se &lt;code&gt;&lt;a href=&quot;common_test#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; funci&amp;oacute;n end_per_group (GroupName, Config) . Esta funci&amp;oacute;n est&amp;aacute; dise&amp;ntilde;ada para limpiar despu&amp;eacute;s de &lt;code&gt;init_per_group/2&lt;/code&gt; . Si la funci&amp;oacute;n init est&amp;aacute; definida, tambi&amp;eacute;n debe estarlo la funci&amp;oacute;n end.</target>
        </trans-unit>
        <trans-unit id="742d99c38a98962fb67614d643aed1075c662a8f" translate="yes" xml:space="preserve">
          <source>Before execution of a group begins, the configuration function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_group-2&quot;&gt;init_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. The list of tuples returned from this function is passed to the test cases in the usual manner by argument &lt;code&gt;Config&lt;/code&gt;. &lt;code&gt;init_per_group/2&lt;/code&gt; is meant to be used for initializations common for the test cases in the group. After execution of the group is finished, function &lt;code&gt;&lt;a href=&quot;ct_suite#Module:end_per_group-2&quot;&gt;end_per_group(GroupName, Config)&lt;/a&gt;&lt;/code&gt; is called. This function is meant to be used for cleaning up after &lt;code&gt;init_per_group/2&lt;/code&gt;. If the init function is defined, so must the end function be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfe638852bde7e76a1e9584d5c09fb0ca66d3651" translate="yes" xml:space="preserve">
          <source>Before execution of the timetrap function (which is performed on a parallel, dedicated timetrap process), &lt;code&gt;Common Test&lt;/code&gt; cancels any previously set timer for the test case or configuration function. When the timetrap function returns, the time-out is triggered, &lt;strong&gt;unless&lt;/strong&gt; the return value is a valid timetrap time, such as an integer, or a &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; tuple (for details, see module &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt;). If a time value is returned, a new timetrap is started to generate a time-out after the specified time.</source>
          <target state="translated">Antes de la ejecuci&amp;oacute;n de la funci&amp;oacute;n de captura de tiempo (que se realiza en un proceso de captura de tiempo dedicado paralelo), &lt;code&gt;Common Test&lt;/code&gt; cancela cualquier temporizador previamente establecido para el caso de prueba o la funci&amp;oacute;n de configuraci&amp;oacute;n. Cuando la funci&amp;oacute;n timetrap regresa, se activa el time-out, a &lt;strong&gt;menos que&lt;/strong&gt; el valor de retorno sea un timetrap v&amp;aacute;lido, como un n&amp;uacute;mero entero, o una &lt;code&gt;{SecMinOrHourTag,Time}&lt;/code&gt; (para m&amp;aacute;s detalles, consulte el m&amp;oacute;dulo &lt;code&gt;&lt;a href=&quot;common_test&quot;&gt;common_test&lt;/a&gt;&lt;/code&gt; ). Si se devuelve un valor de tiempo, se inicia una nueva captura de tiempo para generar un tiempo de espera despu&amp;eacute;s del tiempo especificado.</target>
        </trans-unit>
        <trans-unit id="08b1254c8bec1bc486b54b5a55646cb74814353f" translate="yes" xml:space="preserve">
          <source>Before going into details of the supervision and error handling in an Erlang system, let us see how Erlang processes terminate, or in Erlang terminology, &lt;strong&gt;exit&lt;/strong&gt;.</source>
          <target state="translated">Antes de entrar en detalles sobre la supervisi&amp;oacute;n y el manejo de errores en un sistema Erlang, veamos c&amp;oacute;mo terminan los procesos Erlang, o en terminolog&amp;iacute;a Erlang, &lt;strong&gt;salen&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="158d175d6b77bf980038361a2e334b0ed9a4b8fc" translate="yes" xml:space="preserve">
          <source>Before improving the messenger program, let us look at some general principles, using the ping pong program as an example. Recall that when &quot;ping&quot; finishes, it tells &quot;pong&quot; that it has done so by sending the atom &lt;code&gt;finished&lt;/code&gt; as a message to &quot;pong&quot; so that &quot;pong&quot; can also finish. Another way to let &quot;pong&quot; finish is to make &quot;pong&quot; exit if it does not receive a message from ping within a certain time. This can be done by adding a &lt;strong&gt;time-out&lt;/strong&gt; to &lt;code&gt;pong&lt;/code&gt; as shown in the following example:</source>
          <target state="translated">Antes de mejorar el programa de mensajer&amp;iacute;a, veamos algunos principios generales, usando el programa de ping pong como ejemplo. Recuerde que cuando &quot;ping&quot; termina, le dice a &quot;pong&quot; que lo ha hecho enviando el &amp;aacute;tomo &lt;code&gt;finished&lt;/code&gt; como un mensaje a &quot;pong&quot; para que &quot;pong&quot; tambi&amp;eacute;n pueda terminar. Otra forma de dejar que &quot;pong&quot; termine es hacer que &quot;pong&quot; salga si no recibe un mensaje de ping dentro de un tiempo determinado. Esto puede hacerse mediante la adici&amp;oacute;n de un &lt;strong&gt;tiempo de espera&lt;/strong&gt; a &lt;code&gt;pong&lt;/code&gt; como se muestra en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="5d0240a960734bd032bfb25f877be3ed95c27ca3" translate="yes" xml:space="preserve">
          <source>Before installation you should test whether your build is working properly by running our smoke test. The smoke test is a subset of the complete Erlang/OTP test suites. First you will need to build and release the test suites.</source>
          <target state="translated">Antes de la instalación debe comprobar si su edificio funciona correctamente realizando nuestra prueba de humo.La prueba de humo es un subconjunto de las suites de pruebas completas de Erlang/OTP.Primero tendrá que construir y liberar las suites de prueba.</target>
        </trans-unit>
        <trans-unit id="f9b6bb02452d70c4cea213f1df9be77d0db03bc1" translate="yes" xml:space="preserve">
          <source>Before looking at how this program works, notice that a few comments are added to the code. A comment starts with a %-character and goes on to the end of the line. Notice also that the &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; line only includes the function &lt;code&gt;format_temps/1&lt;/code&gt;. The other functions are &lt;strong&gt;local&lt;/strong&gt; functions, that is, they are not visible from outside the module &lt;code&gt;tut5&lt;/code&gt;.</source>
          <target state="translated">Antes de ver c&amp;oacute;mo funciona este programa, observe que se agregan algunos comentarios al c&amp;oacute;digo. Un comentario comienza con un car&amp;aacute;cter% y contin&amp;uacute;a hasta el final de la l&amp;iacute;nea. Observe tambi&amp;eacute;n que &lt;code&gt;-export([format_temps/1]).&lt;/code&gt; La l&amp;iacute;nea solo incluye la funci&amp;oacute;n &lt;code&gt;format_temps/1&lt;/code&gt; . Las otras funciones son funciones &lt;strong&gt;locales&lt;/strong&gt; , es decir, no son visibles desde fuera del m&amp;oacute;dulo &lt;code&gt;tut5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12bcc79844186de606633bdd333ae924acec0daf" translate="yes" xml:space="preserve">
          <source>Before registering a name, you should already have registered your port number with &lt;code&gt;epmd&lt;/code&gt;. This is not strictly necessary, but if you neglect to do so, then other nodes wishing to communicate with your service cannot find or connect to your process.</source>
          <target state="translated">Antes de registrar un nombre, ya deber&amp;iacute;a haber registrado su n&amp;uacute;mero de puerto con &lt;code&gt;epmd&lt;/code&gt; . Esto no es estrictamente necesario, pero si no lo hace, otros nodos que deseen comunicarse con su servicio no podr&amp;aacute;n encontrar o conectarse a su proceso.</target>
        </trans-unit>
        <trans-unit id="26cb26b93d1388560e328aa535c6bbe4b5f0b51c" translate="yes" xml:space="preserve">
          <source>Before registering with &lt;code&gt;epmd&lt;/code&gt;, you must first create a listen socket and bind it to a port. Then:</source>
          <target state="translated">Antes de registrarse con &lt;code&gt;epmd&lt;/code&gt; , primero debe crear un socket de escucha y vincularlo a un puerto. Luego:</target>
        </trans-unit>
        <trans-unit id="9c7e0e1b9fcac24580ab6b3d03b6e4b55f4c8972" translate="yes" xml:space="preserve">
          <source>Before starting &lt;code&gt;Mnesia&lt;/code&gt;, the following must be done:</source>
          <target state="translated">Antes de iniciar &lt;code&gt;Mnesia&lt;/code&gt; , se debe hacer lo siguiente:</target>
        </trans-unit>
        <trans-unit id="7a519a0020d8de31b673de93ded06a0618f853d2" translate="yes" xml:space="preserve">
          <source>Before starting, notice the following:</source>
          <target state="translated">Antes de empezar,fíjese en lo siguiente:</target>
        </trans-unit>
        <trans-unit id="7011eaabfad589a3868b28c469ad42e5d05beb89" translate="yes" xml:space="preserve">
          <source>Before the call of &lt;code&gt;deflateParams&lt;/code&gt;, the stream state must be set as for a call of &lt;code&gt;deflate/3&lt;/code&gt;, as the currently available input may have to be compressed and flushed.</source>
          <target state="translated">Antes de la llamada de &lt;code&gt;deflateParams&lt;/code&gt; , el estado de la secuencia debe establecerse como para una llamada de &lt;code&gt;deflate/3&lt;/code&gt; , ya que la entrada actualmente disponible puede tener que comprimirse y vaciarse.</target>
        </trans-unit>
        <trans-unit id="78fa7e00043ebdf38881948abf63f1275524f7cf" translate="yes" xml:space="preserve">
          <source>Before the first call to &lt;code&gt;allow/1&lt;/code&gt;, any node with the correct cookie can be connected. When &lt;code&gt;allow/1&lt;/code&gt; is called, a list of allowed nodes is established. Any access attempts made from (or to) nodes not in that list will be rejected.</source>
          <target state="translated">Antes de la primera llamada a &lt;code&gt;allow/1&lt;/code&gt; , se puede conectar cualquier nodo con la cookie correcta. Cuando se llama a &lt;code&gt;allow/1&lt;/code&gt; , se establece una lista de nodos permitidos. Se rechazar&amp;aacute; cualquier intento de acceso realizado desde (o hacia) nodos que no est&amp;eacute;n en esa lista.</target>
        </trans-unit>
        <trans-unit id="dc3113c94757b2848bc9b3cfac6670102a406895" translate="yes" xml:space="preserve">
          <source>Before the log is dumped, the file &lt;code&gt;LATEST.LOG&lt;/code&gt; is renamed to &lt;code&gt;PREVIOUS.LOG&lt;/code&gt;, and a new &lt;code&gt;LATEST.LOG&lt;/code&gt; file is created. Once the log has been successfully dumped, the file &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; is deleted.</source>
          <target state="translated">Antes de que se &lt;code&gt;LATEST.LOG&lt;/code&gt; el registro, se cambia el nombre del archivo LATEST.LOG a &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; y se crea un nuevo archivo &lt;code&gt;LATEST.LOG&lt;/code&gt; . Una vez que el registro se ha volcado con &amp;eacute;xito, se elimina el archivo &lt;code&gt;PREVIOUS.LOG&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db255d80fd5fbd19169beeb79eff7051fb467716" translate="yes" xml:space="preserve">
          <source>Before the port is created, the driver must be loaded. This is done with the function &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt;, with the name of the shared library as argument.</source>
          <target state="translated">Antes de que se cree el puerto, se debe cargar el controlador. Esto se hace con la funci&amp;oacute;n &lt;code&gt;erl_dll:load_driver/1&lt;/code&gt; , con el nombre de la biblioteca compartida como argumento.</target>
        </trans-unit>
        <trans-unit id="46a334a8ddbc15c984030c1582dd4508b5f21665" translate="yes" xml:space="preserve">
          <source>Before the traversal starts, the source backup media is opened with &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt;, and the target backup media is opened with &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt;. The arguments are as follows:</source>
          <target state="translated">Antes de que comience el recorrido, el medio de respaldo de origen se abre con &lt;code&gt;SourceMod:open_read(Source)&lt;/code&gt; y el medio de respaldo de destino se abre con &lt;code&gt;TargetMod:open_write(Target)&lt;/code&gt; . Los argumentos son los siguientes:</target>
        </trans-unit>
        <trans-unit id="a1da9ec4f3c9fc4eb1c3cfeb7777f44d15e8f2fe" translate="yes" xml:space="preserve">
          <source>Before this instruction occurs, &lt;code&gt;Mod&lt;/code&gt; must have been loaded using &lt;code&gt;load_object_code&lt;/code&gt;. This instruction loads the module. &lt;code&gt;PrePurge&lt;/code&gt; is ignored. For a description of &lt;code&gt;PostPurge&lt;/code&gt;, see the high-level instruction &lt;code&gt;update&lt;/code&gt; earlier.</source>
          <target state="translated">Antes de que ocurra esta instrucci&amp;oacute;n, el &lt;code&gt;Mod&lt;/code&gt; debe haberse cargado usando &lt;code&gt;load_object_code&lt;/code&gt; . Esta instrucci&amp;oacute;n carga el m&amp;oacute;dulo. &lt;code&gt;PrePurge&lt;/code&gt; se ignora. Para obtener una descripci&amp;oacute;n de &lt;code&gt;PostPurge&lt;/code&gt; , consulte la &lt;code&gt;update&lt;/code&gt; instrucciones de alto nivel anterior.</target>
        </trans-unit>
        <trans-unit id="352876a2381c0951748f4964cadc93f74da158b5" translate="yes" xml:space="preserve">
          <source>Begin the scope of a prefix-URI Namespace mapping. Note that start/endPrefixMapping events are not guaranteed to be properly nested relative to each other: all startPrefixMapping events will occur immediately before the corresponding startElement event, and all endPrefixMapping events will occur immediately after the corresponding endElement event, but their order is not otherwise guaranteed. There will not be start/endPrefixMapping events for the &quot;xml&quot; prefix, since it is predeclared and immutable.</source>
          <target state="translated">Comienza el alcance de un mapeo del prefijo-URI Namespace.Obsérvese que no se garantiza que los eventos startPrefixMapping estén anidados adecuadamente entre sí:todos los eventos startPrefixMapping se producirán inmediatamente antes del correspondiente evento startElement,y todos los eventos endPrefixMapping se producirán inmediatamente después del correspondiente evento endElement,pero su orden no está garantizado de otro modo.No habrá eventos start/endPrefixMapping para el prefijo &quot;xml&quot;,ya que está predeclarado e inmutable.</target>
        </trans-unit>
        <trans-unit id="ef3ba8079ba496eafefddd167fd69849d3349c1c" translate="yes" xml:space="preserve">
          <source>Beginning of line</source>
          <target state="translated">Comienzo de la línea</target>
        </trans-unit>
        <trans-unit id="a0541a24650d9da6d38c74c8da4b43cac73179f4" translate="yes" xml:space="preserve">
          <source>Beginning with Erlang/OTP R14, parentheses when accessing or updating nested records can be omitted. Assume the following record definitions:</source>
          <target state="translated">Comenzando con Erlang/OTP R14,se pueden omitir los paréntesis cuando se accede o se actualizan los registros anidados.Supongamos las siguientes definiciones de registro:</target>
        </trans-unit>
        <trans-unit id="04a97d065ff4fbd74684b1f948daab7f3b7943dc" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt; characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but produces a binary instead of a Unicode list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dbe51e0d3cf7fe095d04d74ded17ede0a93150c5" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt;, but produces a binary instead of a Unicode list.</source>
          <target state="translated">Se comporta como &lt;code&gt;&lt;a href=&quot;#characters_to_list-2&quot;&gt;characters_to_list/2&lt;/a&gt;&lt;/code&gt; , pero produce una lista binaria en lugar de Unicode.</target>
        </trans-unit>
        <trans-unit id="89ade40ae04b2b1a7cb87dcb6495bdb4cd27f4c3" translate="yes" xml:space="preserve">
          <source>Behaves as &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; except that it allows an extra option to be specified, namely &lt;code&gt;allow_passive_connect&lt;/code&gt;. This option allows the BIF to wait the normal network connection time-out for the &lt;strong&gt;monitored node&lt;/strong&gt; to connect itself, even if it cannot be actively connected from this node (that is, it is blocked). The state where this can be useful can only be achieved by using the Kernel option &lt;code&gt;dist_auto_connect once&lt;/code&gt;. If that option is not used, option &lt;code&gt;allow_passive_connect&lt;/code&gt; has no effect.</source>
          <target state="translated">Se comporta como &lt;code&gt;&lt;a href=&quot;#monitor_node-2&quot;&gt;monitor_node/2&lt;/a&gt;&lt;/code&gt; excepto que permite especificar una opci&amp;oacute;n adicional, a saber, &lt;code&gt;allow_passive_connect&lt;/code&gt; . Esta opci&amp;oacute;n permite que el BIF espere el tiempo de espera normal de la conexi&amp;oacute;n de red para que el &lt;strong&gt;nodo monitoreado se&lt;/strong&gt; conecte, incluso si no puede conectarse activamente desde este nodo (es decir, est&amp;aacute; bloqueado). El estado en el que esto puede ser &amp;uacute;til solo se puede lograr usando la opci&amp;oacute;n del n&amp;uacute;cleo &lt;code&gt;dist_auto_connect once&lt;/code&gt; . Si esa opci&amp;oacute;n no se usa, la opci&amp;oacute;n &lt;code&gt;allow_passive_connect&lt;/code&gt; no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="58884446ca5852c4e8961c8c91d6b677aceaea96" translate="yes" xml:space="preserve">
          <source>Behavior describing the API for public key handling of an SSH client. By implementing the callbacks defined in this behavior, the public key handling of an SSH client can be customized. By default the &lt;code&gt;ssh&lt;/code&gt; application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt; ssh(6)&lt;/code&gt; application manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64aaa639db43c0fb66ead8ebf5d3670fe4ea4ff0" translate="yes" xml:space="preserve">
          <source>Behavior describing the API for public key handling of an SSH client. By implementing the callbacks defined in this behavior, the public key handling of an SSH client can be customized. By default the &lt;code&gt;ssh&lt;/code&gt; application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">Comportamiento que describe la API para el manejo de claves p&amp;uacute;blicas de un cliente SSH. Al implementar las devoluciones de llamada definidas en este comportamiento, se puede personalizar el manejo de la clave p&amp;uacute;blica de un cliente SSH. De forma predeterminada, la aplicaci&amp;oacute;n &lt;code&gt;ssh&lt;/code&gt; implementa este comportamiento con la ayuda de los archivos OpenSSH est&amp;aacute;ndar, consulte el manual de la aplicaci&amp;oacute;n &lt;code&gt;ssh(6)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c2cfec7cf1dcce3dafc9cae66013644e8eff42f" translate="yes" xml:space="preserve">
          <source>Behaviour Module Attribute</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6505f096bd0cf99b3b2b5bc3d911574d1d3ac320" translate="yes" xml:space="preserve">
          <source>Behaviour describing the API for public key handling of an SSH server. By implementing the callbacks defined in this behavior, the public key handling of an SSH server can be customized. By default the SSH application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt; ssh(6)&lt;/code&gt; application manual.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f16faae4208d9a96f7fb1bb23ef9cd7087ccfdeb" translate="yes" xml:space="preserve">
          <source>Behaviour describing the API for public key handling of an SSH server. By implementing the callbacks defined in this behavior, the public key handling of an SSH server can be customized. By default the SSH application implements this behavior with help of the standard OpenSSH files, see the &lt;code&gt;ssh(6)&lt;/code&gt; application manual.</source>
          <target state="translated">Comportamiento que describe la API para el manejo de claves p&amp;uacute;blicas de un servidor SSH. Al implementar las devoluciones de llamada definidas en este comportamiento, se puede personalizar el manejo de la clave p&amp;uacute;blica de un servidor SSH. De forma predeterminada, la aplicaci&amp;oacute;n SSH implementa este comportamiento con la ayuda de los archivos OpenSSH est&amp;aacute;ndar, consulte el manual de la aplicaci&amp;oacute;n &lt;code&gt;ssh(6)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0d4ec155f7430eef8a27415e38c4ad6595b98c0" translate="yes" xml:space="preserve">
          <source>Behaviour module for reporting SNMP agent errors</source>
          <target state="translated">Módulo de comportamiento para informar de los errores del agente SNMP</target>
        </trans-unit>
        <trans-unit id="2d41c7e7235b92d9c78165f5ea1a1214538b7ae8" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent discovery handler.</source>
          <target state="translated">Módulo de comportamiento para el manejador de descubrimiento de agentes SNMP.</target>
        </trans-unit>
        <trans-unit id="4d88eee718b5f101a30d4bf7abe96e2a4af445a2" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib storage.</source>
          <target state="translated">Módulo de comportamiento para el almacenamiento del agente SNMP mib.</target>
        </trans-unit>
        <trans-unit id="213836ecbce5c62ee5c70a707ff8f6efbfddb7e0" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent mib-server data module.</source>
          <target state="translated">Módulo de comportamiento para el módulo de datos del mib-servidor del agente SNMP.</target>
        </trans-unit>
        <trans-unit id="9b9ea5bbfad06ea1fc316484f53361a36304e0df" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network interface.</source>
          <target state="translated">Módulo de comportamiento para la interfaz de red del agente SNMP.</target>
        </trans-unit>
        <trans-unit id="b7490591e615b37731085e0dc791786738305c7b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent network-interface filter.</source>
          <target state="translated">Módulo de comportamiento para el filtro de la interfaz de la red del agente SNMP.</target>
        </trans-unit>
        <trans-unit id="2d2c6aaaa587ce80e3a95c5e764e760aa91d874b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification delivery information receiver.</source>
          <target state="translated">Módulo de comportamiento para el receptor de información de entrega de notificaciones del agente SNMP.</target>
        </trans-unit>
        <trans-unit id="625c1c9de2b712103668af5814be0412885b49e5" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP agent notification filters.</source>
          <target state="translated">Módulo de comportamiento para los filtros de notificación del agente SNMP.</target>
        </trans-unit>
        <trans-unit id="de9d0d8b19209222093743579cc0da909bbbb028" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network interface.</source>
          <target state="translated">Módulo de comportamiento para la interfaz de red del administrador SNMP.</target>
        </trans-unit>
        <trans-unit id="2f41f4d43078504e98d5de4dc916e14eb8a85ba6" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager network-interface filter.</source>
          <target state="translated">Módulo de comportamiento para el filtro de la interfaz de la red del administrador de SNMP.</target>
        </trans-unit>
        <trans-unit id="eb1e7ed7fa32a13f652cc9e9bf36d2ab93e52c2b" translate="yes" xml:space="preserve">
          <source>Behaviour module for the SNMP manager user.</source>
          <target state="translated">Módulo de comportamiento para el usuario administrador del SNMP.</target>
        </trans-unit>
        <trans-unit id="77b3fcb503c107fdcf78ea27b16f4310e4bd176a" translate="yes" xml:space="preserve">
          <source>Behaviour with optional callbacks to customize the inets HTTP server.</source>
          <target state="translated">Comportamiento con llamadas opcionales para personalizar el servidor HTTP de inets.</target>
        </trans-unit>
        <trans-unit id="e0f283a40056570ec143d350395380c52fd1c5b2" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;/usr/local/otp&lt;/code&gt;:</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra un ejemplo completo de lo que debe agregarse a &lt;code&gt;.emacs&lt;/code&gt; de un usuario siempre que OTP est&amp;eacute; instalado en el directorio &lt;code&gt;/usr/local/otp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1fad7bb629bd2e9041c6abf5bc0a920316f854b0" translate="yes" xml:space="preserve">
          <source>Below is a complete example of what should be added to a user's &lt;code&gt;.emacs&lt;/code&gt; provided that OTP is installed in the directory &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra un ejemplo completo de lo que se debe agregar a &lt;code&gt;.emacs&lt;/code&gt; de un usuario siempre que OTP est&amp;eacute; instalado en el directorio &lt;code&gt;C:\Program Files\erl&amp;lt;Ver&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="40217191ef85c64b525b787ccb400689f06f21a9" translate="yes" xml:space="preserve">
          <source>Below is an example of the grammar above with structure building code added:</source>
          <target state="translated">Abajo hay un ejemplo de la gramática de arriba con el código de construcción de la estructura añadido:</target>
        </trans-unit>
        <trans-unit id="5d5970fcf1e0337426fd2a5c1de2fd3082f3b1fe" translate="yes" xml:space="preserve">
          <source>Benchmarks can measure wall-clock time or CPU time.</source>
          <target state="translated">Los puntos de referencia pueden medir el tiempo del reloj de pared o el tiempo de la CPU.</target>
        </trans-unit>
        <trans-unit id="bfb8b17cc74805621ef756d36abfea020e22ec89" translate="yes" xml:space="preserve">
          <source>Benchmarks that appear to be concurrent are often sequential. The estone benchmark, for example, is entirely sequential. So is the most common implementation of the &quot;ring benchmark&quot;; usually one process is active, while the others wait in a &lt;code&gt;receive&lt;/code&gt; statement.</source>
          <target state="translated">Los puntos de referencia que parecen concurrentes suelen ser secuenciales. El punto de referencia de estone, por ejemplo, es completamente secuencial. Tambi&amp;eacute;n lo es la implementaci&amp;oacute;n m&amp;aacute;s com&amp;uacute;n del &quot;&amp;iacute;ndice de referencia en anillo&quot;; por lo general, un proceso est&amp;aacute; activo, mientras que los otros esperan en una instrucci&amp;oacute;n de &lt;code&gt;receive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="198e9c0851a2cebe3440bd1cafd71b98e2d83392" translate="yes" xml:space="preserve">
          <source>Bengali</source>
          <target state="translated">Bengali</target>
        </trans-unit>
        <trans-unit id="c274af2a723078651a0cf0e2bdc4b8cb3f48d70d" translate="yes" xml:space="preserve">
          <source>Besides &lt;code&gt;qlc:table/2&lt;/code&gt;, other functions return query handles. They are used more seldom than tables, but are sometimes useful. &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; traverses objects from many tables or lists after each other. If, for example, you want to traverse all answers to a query &lt;code&gt;QH&lt;/code&gt; and then finish off by a term &lt;code&gt;{finished}&lt;/code&gt;, you can do that by calling &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt;. &lt;code&gt;append/2&lt;/code&gt; first returns all objects of &lt;code&gt;QH&lt;/code&gt;, then &lt;code&gt;{finished}&lt;/code&gt;. If a tuple &lt;code&gt;{finished}&lt;/code&gt; exists among the answers to &lt;code&gt;QH&lt;/code&gt;, it is returned twice from &lt;code&gt;append/2&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de &lt;code&gt;qlc:table/2&lt;/code&gt; , otras funciones devuelven identificadores de consulta. Se utilizan menos que las tablas, pero a veces son &amp;uacute;tiles. &lt;code&gt;&lt;a href=&quot;#append-1&quot;&gt;qlc:append/1,2&lt;/a&gt;&lt;/code&gt; atraviesa objetos de muchas tablas o listas uno tras otro. Si, por ejemplo, desea recorrer todas las respuestas a una consulta &lt;code&gt;QH&lt;/code&gt; y luego terminar con un t&amp;eacute;rmino &lt;code&gt;{finished}&lt;/code&gt; , puede hacerlo llamando a &lt;code&gt;qlc:append(QH, [{finished}])&lt;/code&gt; . &lt;code&gt;append/2&lt;/code&gt; primero devuelve todos los objetos de &lt;code&gt;QH&lt;/code&gt; , luego &lt;code&gt;{finished}&lt;/code&gt; . Si existe una tupla &lt;code&gt;{finished}&lt;/code&gt; entre las respuestas a &lt;code&gt;QH&lt;/code&gt; , se devuelve dos veces desde &lt;code&gt;append/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c6260580b5bc11052e617d5d44b018db15e9a982" translate="yes" xml:space="preserve">
          <source>Besides addressing a process by using its pid, there are also BIFs for registering a process under a name. The name must be an atom and is automatically unregistered if the process terminates:</source>
          <target state="translated">Además de abordar un proceso utilizando su pid,también existen BIF para registrar un proceso bajo un nombre.El nombre debe ser un átomo y se anula automáticamente si el proceso termina:</target>
        </trans-unit>
        <trans-unit id="453d7ac3df855ff457e6e90c9784d798c45f0f44" translate="yes" xml:space="preserve">
          <source>Besides implementing the functionality enabling the scheduling, preparation of signal data without port lock, etc, each operation sending signals to ports had to be quite extensively re-written. This in order to move all sub-operations that can be done without the lock to a place before we have acquired the lock, and also since signals now sometimes are executed immediately and sometimes scheduled for execution at a later time which put different requirements on the data to pass along with the signal.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4fc21da73002de65cd31f4246dde118952a0ef0" translate="yes" xml:space="preserve">
          <source>Besides passing carrier pool name as value to the parameter, you can also pass &lt;code&gt;:&lt;/code&gt;. By passing &lt;code&gt;:&lt;/code&gt; instead of carrier pool name, the allocator will use the carrier pool associated with itself. By passing the command line argument &quot;&lt;code&gt;+Mucg :&lt;/code&gt;&quot;, all allocators that have an associated carrier pool will use the carrier pool associated with themselves.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5348075792306c67e1b0814d6ba0ff860d6cb22" translate="yes" xml:space="preserve">
          <source>Besides reporting time, &lt;code&gt;erlang:now/0&lt;/code&gt; also produces unique and strictly monotonically increasing values. To detach this functionality from time measurements, we have introduced &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt; erlang:unique_integer()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b15bc3f2eceb04129fd4516b3b370516eb00424d" translate="yes" xml:space="preserve">
          <source>Besides reporting time, &lt;code&gt;erlang:now/0&lt;/code&gt; also produces unique and strictly monotonically increasing values. To detach this functionality from time measurements, we have introduced &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de informar el tiempo, &lt;code&gt;erlang:now/0&lt;/code&gt; tambi&amp;eacute;n produce valores &amp;uacute;nicos y estrictamente monot&amp;oacute;nicos que aumentan. Para separar esta funcionalidad de las mediciones de tiempo, hemos introducido &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a52810e66627e5a80808e690811322ee8adf786" translate="yes" xml:space="preserve">
          <source>Besides test cases and groups, the test suite can also contain configuration functions. These functions are meant to be used for setting up (and verifying) environment and state in the SUT (and/or the &lt;code&gt;Common Test&lt;/code&gt; host node), required for the tests to execute correctly. Examples of operations are: Opening a connection to the SUT, initializing a database, running an installation script, and so on. Configuration can be performed per suite, per test case group, and per individual test case.</source>
          <target state="translated">Adem&amp;aacute;s de los casos y grupos de prueba, la suite de pruebas tambi&amp;eacute;n puede contener funciones de configuraci&amp;oacute;n. Estas funciones est&amp;aacute;n destinadas a ser utilizadas para configurar (y verificar) el entorno y el estado en el SUT (y / o el nodo host de &lt;code&gt;Common Test&lt;/code&gt; ), necesarios para que las pruebas se ejecuten correctamente. Algunos ejemplos de operaciones son: abrir una conexi&amp;oacute;n al SUT, inicializar una base de datos, ejecutar un script de instalaci&amp;oacute;n, etc. La configuraci&amp;oacute;n se puede realizar por suite, por grupo de casos de prueba y por caso de prueba individual.</target>
        </trans-unit>
        <trans-unit id="007ac80b876d6b31b51d4c189993df4c58d1fc5a" translate="yes" xml:space="preserve">
          <source>Besides the already mentioned source parameters &lt;code&gt;root_dir&lt;/code&gt; and &lt;code&gt;lib_dirs&lt;/code&gt;, the following system (&lt;code&gt;sys&lt;/code&gt;) level options are supported:</source>
          <target state="translated">Adem&amp;aacute;s de los par&amp;aacute;metros de origen ya mencionados &lt;code&gt;root_dir&lt;/code&gt; y &lt;code&gt;lib_dirs&lt;/code&gt; , se admiten las siguientes opciones de nivel de sistema ( &lt;code&gt;sys&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="e7b2c0c382d27b288446a0bacbb0c94ce486cb4f" translate="yes" xml:space="preserve">
          <source>Best Practices for Using Persistent Terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d77fc5043db349a36fcc2530a0223317a9d51ded" translate="yes" xml:space="preserve">
          <source>Between modules</source>
          <target state="translated">Entre los módulos</target>
        </trans-unit>
        <trans-unit id="7e04d97ca7154dfa6468b97d3b9c42d0c616a358" translate="yes" xml:space="preserve">
          <source>Between nodes</source>
          <target state="translated">Entre los nodos</target>
        </trans-unit>
        <trans-unit id="3430043cce88789d3bd382a0b2a1bc3c39a24538" translate="yes" xml:space="preserve">
          <source>Between processes</source>
          <target state="translated">Entre los procesos</target>
        </trans-unit>
        <trans-unit id="f6202bc62a181da8db026f3b5d7d396e4ee251e7" translate="yes" xml:space="preserve">
          <source>Between step 6 and 8, runninng processes might execute the written &lt;code&gt;op_i_generic_breakpoint&lt;/code&gt; instruction. They will get the breakpoint structure written in step 3, read &lt;code&gt;erts_active_bp_index&lt;/code&gt; and execute the corresponding part of the breakpoint. Before the switch in step 8 becomes visible they will however execute the disabled part of the breakpoint structure and do nothing other than executing the saved original instruction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0ece311d270b7fe14ea09dcb08057562506122" translate="yes" xml:space="preserve">
          <source>Beware</source>
          <target state="translated">Beware</target>
        </trans-unit>
        <trans-unit id="f647ae7d5e7143915c4692eef6551f34333f508c" translate="yes" xml:space="preserve">
          <source>Beware of confusing mandatory in the sense of the M-bit with mandatory in the sense of the command grammar. The former is a semantic requirement: that the receiver understand the semantics of the AVP in the context in question. The latter is a syntactic requirement: whether or not the AVP must occur in the message in question.</source>
          <target state="translated">Cuidado con confundir obligatorio en el sentido del M-bit con obligatorio en el sentido de la gramática de comandos.El primero es un requisito semántico:que el receptor entienda la semántica del AVP en el contexto en cuestión.El segundo es un requisito sintáctico:si el AVP debe ocurrir o no en el mensaje en cuestión.</target>
        </trans-unit>
        <trans-unit id="5a3b08c5bdc112934a46e49f93c6566926eb949f" translate="yes" xml:space="preserve">
          <source>Beware of trailing space in &lt;code&gt;Replacement&lt;/code&gt; to be used. If you must have a space in &lt;code&gt;Re&lt;/code&gt;, use, for example, the character encoding &lt;code&gt;\040&lt;/code&gt;, see &lt;code&gt;re(3)&lt;/code&gt;.</source>
          <target state="translated">Tenga cuidado con el espacio final en el &lt;code&gt;Replacement&lt;/code&gt; que se utilizar&amp;aacute;. Si debe tener un espacio en &lt;code&gt;Re&lt;/code&gt; , utilice, por ejemplo, la codificaci&amp;oacute;n de caracteres &lt;code&gt;\040&lt;/code&gt; , consulte &lt;code&gt;re(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="99e106abb61082912f0a96161c0ad22a4eea32f3" translate="yes" xml:space="preserve">
          <source>Beware of using fun expressions of the form &lt;code&gt;fun Name/Arity&lt;/code&gt; in situations in which the fun is not short-lived and code is to be upgraded at runtime since any processes retaining such a fun will have a reference to old code. In particular, such a value is typically inappropriate in configuration passed to &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Tenga cuidado con el uso de expresiones divertidas de la forma &lt;code&gt;fun Name/Arity&lt;/code&gt; en situaciones en las que la diversi&amp;oacute;n no es de corta duraci&amp;oacute;n y el c&amp;oacute;digo debe actualizarse en tiempo de ejecuci&amp;oacute;n, ya que cualquier proceso que conserve dicha diversi&amp;oacute;n tendr&amp;aacute; una referencia al c&amp;oacute;digo antiguo. En particular, este valor suele ser inapropiado en la configuraci&amp;oacute;n que se pasa a &lt;code&gt;&lt;a href=&quot;#start_service-2&quot;&gt;start_service/2&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#add_transport-2&quot;&gt;add_transport/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f04d9d4432e8383e468152a41bfa09dcf4f742e" translate="yes" xml:space="preserve">
          <source>Beware that RFC 6733 changed the DiameterURI transport/port defaults specified in RFC3588. Relying on the defaults can result in interoperability problems.</source>
          <target state="translated">Tengan en cuenta que el RFC 6733 cambió los valores por defecto de transporte/puerto de DiameterURI especificados en el RFC3588.Confiar en los valores por defecto puede resultar en problemas de interoperabilidad.</target>
        </trans-unit>
        <trans-unit id="37789191d916ab6f4adfabdff7e05307d5bbf9ba" translate="yes" xml:space="preserve">
          <source>Beware the difference between &lt;strong&gt;diameter&lt;/strong&gt; (not capitalized) and &lt;strong&gt;Diameter&lt;/strong&gt; (capitalized). The former refers to the Erlang application named diameter whose main api is defined here, the latter to Diameter protocol in the sense of RFC 6733.</source>
          <target state="translated">Tenga cuidado con la diferencia entre el &lt;strong&gt;di&amp;aacute;metro&lt;/strong&gt; (no en may&amp;uacute;scula) y el &lt;strong&gt;di&amp;aacute;metro&lt;/strong&gt; (en may&amp;uacute;scula). El primero se refiere a la aplicaci&amp;oacute;n Erlang denominada di&amp;aacute;metro cuya api principal se define aqu&amp;iacute;, el segundo al protocolo Diameter en el sentido de RFC 6733.</target>
        </trans-unit>
        <trans-unit id="7e27c93748471a211ccbeda730113ee702b30a76" translate="yes" xml:space="preserve">
          <source>Bignums are stored in unary form with a &lt;code&gt;Sign&lt;/code&gt; byte, that is, 0 if the bignum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b68a0f135268fc97357fa1f2e8bec70aa5933a7" translate="yes" xml:space="preserve">
          <source>Bignums are stored in unary form with a &lt;code&gt;Sign&lt;/code&gt; byte, that is, 0 if the binum is positive and 1 if it is negative. The digits are stored with the least significant byte stored first. To calculate the integer, the following formula can be used:</source>
          <target state="translated">Los bignums se almacenan en forma unaria con un byte de &lt;code&gt;Sign&lt;/code&gt; , es decir, 0 si el binum es positivo y 1 si es negativo. Los d&amp;iacute;gitos se almacenan con el byte menos significativo almacenado primero. Para calcular el n&amp;uacute;mero entero, se puede utilizar la siguiente f&amp;oacute;rmula:</target>
        </trans-unit>
        <trans-unit id="915f680c2bd74e3a951cc35061c83bda7c9d3906" translate="yes" xml:space="preserve">
          <source>Binaries are generated with bit syntax expression or with &lt;code&gt; erlang:list_to_binary/1&lt;/code&gt;, &lt;code&gt; erlang:term_to_binary/1&lt;/code&gt;, or as input from binary ports. The &lt;code&gt;Len&lt;/code&gt; length field is an unsigned 4 byte integer (big-endian).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0c51379d746d689abb0d4163480ae980cc1ea4f" translate="yes" xml:space="preserve">
          <source>Binaries are generated with bit syntax expression or with &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt;, or as input from binary ports. The &lt;code&gt;Len&lt;/code&gt; length field is an unsigned 4 byte integer (big-endian).</source>
          <target state="translated">Los binarios se generan con una expresi&amp;oacute;n de sintaxis de bits o con &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; , &lt;code&gt;erlang:term_to_binary/1&lt;/code&gt; , o como entrada desde puertos binarios. El campo de longitud de &lt;code&gt;Len&lt;/code&gt; es un entero de 4 bytes sin signo (big-endian).</target>
        </trans-unit>
        <trans-unit id="afb16785a033cecba113ba879f8a7ad266f9f880" translate="yes" xml:space="preserve">
          <source>Binaries are more troublesome. For performance reasons, programs often store textual data in binaries instead of lists, mainly because they are more compact (one byte per character instead of two words per character, as is the case with lists). Using &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt;, an ISO Latin-1 Erlang string can be converted into a binary, effectively using bytewise encoding: one byte per character. This was convenient for those limited Erlang strings, but cannot be done for arbitrary Unicode lists.</source>
          <target state="translated">Los binarios son m&amp;aacute;s problem&amp;aacute;ticos. Por motivos de rendimiento, los programas suelen almacenar datos textuales en binarios en lugar de listas, principalmente porque son m&amp;aacute;s compactos (un byte por car&amp;aacute;cter en lugar de dos palabras por car&amp;aacute;cter, como es el caso de las listas). Usando &lt;code&gt;erlang:list_to_binary/1&lt;/code&gt; , una cadena ISO Latin-1 Erlang se puede convertir en un binario, usando efectivamente codificaci&amp;oacute;n bytewise: un byte por car&amp;aacute;cter. Esto fue conveniente para esas cadenas limitadas de Erlang, pero no se puede hacer para listas Unicode arbitrarias.</target>
        </trans-unit>
        <trans-unit id="9777da829501809520a535ef9e6d08ff6a5dcba9" translate="yes" xml:space="preserve">
          <source>Binaries are sequences of whole bytes. Bitstrings with an arbitrary bit length have no support yet.</source>
          <target state="translated">Los binarios son secuencias de bytes enteros.Las cadenas de bits con una longitud de bits arbitraria aún no tienen soporte.</target>
        </trans-unit>
        <trans-unit id="ddb0d785eee554ca3ad9cce85a18ca8630f56b8c" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently built in the following way:</source>
          <target state="translated">Los binarios pueden ser construidos eficientemente de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="0d0d3b67132c6fcaa92c679366fed8db13d485e2" translate="yes" xml:space="preserve">
          <source>Binaries can be efficiently matched like this:</source>
          <target state="translated">Los binarios se pueden emparejar eficientemente de esta manera:</target>
        </trans-unit>
        <trans-unit id="66639f7d455dd71faa9147f5d69e5ce885d8bebd" translate="yes" xml:space="preserve">
          <source>Binary</source>
          <target state="translated">Binary</target>
        </trans-unit>
        <trans-unit id="892dde55806e241693a0b3bdfdd1efae250f381f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;Bin&lt;/code&gt; contains the same information as the output from &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt;. Use &lt;code&gt;binary_to_list/1&lt;/code&gt; to obtain the string of characters from the binary.</source>
          <target state="translated">&lt;code&gt;Bin&lt;/code&gt; binario contiene la misma informaci&amp;oacute;n que la salida de &lt;code&gt;erlang:process_display(Pid, backtrace)&lt;/code&gt; . Utilice &lt;code&gt;binary_to_list/1&lt;/code&gt; para obtener la cadena de caracteres del binario.</target>
        </trans-unit>
        <trans-unit id="ebbd4d9948de9c87d6e53af4cc41250b5709a590" translate="yes" xml:space="preserve">
          <source>Binary boot script</source>
          <target state="translated">Guión binario de arranque</target>
        </trans-unit>
        <trans-unit id="6ca5ef63e7a423ed4f0c902eb2201ec5aa53e26f" translate="yes" xml:space="preserve">
          <source>Binary callback function &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; is used for looking up objects in the table. The first argument &lt;code&gt;Position&lt;/code&gt; is the key position or an indexed position and the second argument &lt;code&gt;Keys&lt;/code&gt; is a sorted list of unique values. The return value is to be a list of all objects (tuples), such that the element at &lt;code&gt;Position&lt;/code&gt; is a member of &lt;code&gt;Keys&lt;/code&gt;. Any other return value is immediately returned as value of the query evaluation. &lt;code&gt;LookupFun&lt;/code&gt; is called instead of traversing the table if the parse transform at compile time can determine that the filters match and compare the element at &lt;code&gt;Position&lt;/code&gt; in such a way that only &lt;code&gt;Keys&lt;/code&gt; need to be looked up to find all potential answers.</source>
          <target state="translated">La funci&amp;oacute;n de devoluci&amp;oacute;n de llamada binaria &lt;code id=&quot;lookup_fun&quot;&gt;LookupFun&lt;/code&gt; se utiliza para buscar objetos en la tabla. El primer argumento &lt;code&gt;Position&lt;/code&gt; es la posici&amp;oacute;n clave o una posici&amp;oacute;n indexada y el segundo argumento &lt;code&gt;Keys&lt;/code&gt; es una lista ordenada de valores &amp;uacute;nicos. El valor de retorno debe ser una lista de todos los objetos (tuplas), de modo que el elemento en &lt;code&gt;Position&lt;/code&gt; sea ​​miembro de &lt;code&gt;Keys&lt;/code&gt; . Cualquier otro valor devuelto se devuelve inmediatamente como valor de la evaluaci&amp;oacute;n de la consulta. Se llama a &lt;code&gt;LookupFun&lt;/code&gt; en lugar de atravesar la tabla si la transformaci&amp;oacute;n de an&amp;aacute;lisis en tiempo de compilaci&amp;oacute;n puede determinar que los filtros coinciden y comparan el elemento en la &lt;code&gt;Position&lt;/code&gt; de tal manera que solo las &lt;code&gt;Keys&lt;/code&gt; deben buscarse para encontrar todas las posibles respuestas.</target>
        </trans-unit>
        <trans-unit id="91649b24f930abce26bedbe83f0148ebb05baa18" translate="yes" xml:space="preserve">
          <source>Binary codecs</source>
          <target state="translated">Códecs binarios</target>
        </trans-unit>
        <trans-unit id="bfbd337015a6a1e9c7fe45e7f4ee5d33b7a0cc06" translate="yes" xml:space="preserve">
          <source>Binary data is shared among processes. If another process still references the larger binary, copying the part this process uses only consumes more memory and does not free up the larger binary for garbage collection. Use this kind of intrusive functions with extreme care and only if a real problem is detected.</source>
          <target state="translated">Los datos binarios se comparten entre los procesos.Si otro proceso sigue haciendo referencia al binario más grande,al copiar la parte que este proceso utiliza sólo se consume más memoria y no se libera el binario más grande para la recogida de basura.Utilice este tipo de funciones intrusivas con extremo cuidado y sólo si se detecta un problema real.</target>
        </trans-unit>
        <trans-unit id="e0b461eb903baadd26c515cd4ef53be30f07dc47" translate="yes" xml:space="preserve">
          <source>Binary handling was significantly improved in R12B. Because code that was efficient in R11B might not be efficient in R12B, and vice versa, earlier revisions of this Efficiency Guide contained some information about binary handling in R11B.</source>
          <target state="translated">El manejo binario se mejoró significativamente en el R12B.Debido a que el código que era eficiente en el R11B podría no serlo en el R12B,y viceversa,las revisiones anteriores de esta Guía de Eficiencia contenían alguna información sobre el manejo binario en el R11B.</target>
        </trans-unit>
        <trans-unit id="3435ca67f0f051a1fea228cdb0770bf8e8bb3d65" translate="yes" xml:space="preserve">
          <source>Binary sharing occurs whenever binaries are taken apart. This is the fundamental reason why binaries are fast, decomposition can always be done with O(1) complexity. In rare circumstances this data sharing is however undesirable, why this function together with &lt;code&gt;copy/1&lt;/code&gt; can be useful when optimizing for memory use.</source>
          <target state="translated">El uso compartido de binarios ocurre siempre que los binarios se desarman. Esta es la raz&amp;oacute;n fundamental por la que los binarios son r&amp;aacute;pidos, la descomposici&amp;oacute;n siempre se puede hacer con complejidad O (1). Sin embargo, en raras circunstancias, este intercambio de datos no es deseable, por lo que esta funci&amp;oacute;n junto con &lt;code&gt;copy/1&lt;/code&gt; puede ser &amp;uacute;til cuando se optimiza para el uso de la memoria.</target>
        </trans-unit>
        <trans-unit id="444f4f33b9d5b0002c23fd9ec1a4edab1ded0af6" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in UTF-8 or UTF-16.</source>
          <target state="translated">Binario con caracteres codificados en UTF-8 o UTF-16.</target>
        </trans-unit>
        <trans-unit id="c065024f1e88a0e634a5d724af341ce692e22147" translate="yes" xml:space="preserve">
          <source>Binary with characters encoded in iso-latin-1.</source>
          <target state="translated">Binario con caracteres codificados en iso-latin-1.</target>
        </trans-unit>
        <trans-unit id="89f902f1a369dce968f46c3953a9e68e0d99f72f" translate="yes" xml:space="preserve">
          <source>BinaryGraphOp ::= &lt;code&gt;of&lt;/code&gt;</source>
          <target state="translated">BinaryGraphOp :: = &lt;code&gt;of&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7513e46be3c5ca02f1cd91f8479bcae815aa2cca" translate="yes" xml:space="preserve">
          <source>BinarySetOp ::= &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</source>
          <target state="translated">BinarySetOp :: = &lt;code&gt;+&lt;/code&gt; | &lt;code&gt;*&lt;/code&gt; | &lt;code&gt;-&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1eb97ea1779ca334fa82951915ccbbf0c411af8d" translate="yes" xml:space="preserve">
          <source>Bind a name to a socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a13da3886205091801df2d6f1afb4618b1d0ec53" translate="yes" xml:space="preserve">
          <source>Bind the socket identified by &lt;code&gt;ctx&lt;/code&gt; to a local interface and then listen on it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4666da54d73c3984e4c044ae18083dcbc9b65311" translate="yes" xml:space="preserve">
          <source>Binding and Using a Size Variable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8264338650782cc58de94b15794c38a796b18c92" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is not supported on the specific platform.</source>
          <target state="translated">La vinculación de los programadores no está soportada en la plataforma específica.</target>
        </trans-unit>
        <trans-unit id="65e949b92a71c14d4ea442682069d67c76442e70" translate="yes" xml:space="preserve">
          <source>Binding of schedulers is only supported on newer Linux, Solaris, FreeBSD, and Windows systems.</source>
          <target state="translated">La vinculación de los programadores sólo está soportada en los sistemas más recientes de Linux,Solaris,FreeBSD y Windows.</target>
        </trans-unit>
        <trans-unit id="1e29acb46257f51cfc0f132df9d70d5a8cf45608" translate="yes" xml:space="preserve">
          <source>Bindings,</source>
          <target state="translated">Bindings,</target>
        </trans-unit>
        <trans-unit id="a255a9d3a4009bbdfcc5e9d159b353b687a30da6" translate="yes" xml:space="preserve">
          <source>Binds a socket to a specific network interface. This option must be used in a function call that creates a socket, that is, &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Vincula un socket a una interfaz de red espec&amp;iacute;fica. Esta opci&amp;oacute;n debe usarse en una llamada de funci&amp;oacute;n que cree un socket, es decir, &lt;code&gt;&lt;a href=&quot;gen_tcp#connect-3&quot;&gt;gen_tcp:connect/3,4&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_tcp#listen-2&quot;&gt;gen_tcp:listen/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;gen_udp#open-1&quot;&gt;gen_udp:open/1,2&lt;/a&gt;&lt;/code&gt; , o &lt;code&gt;&lt;a href=&quot;gen_sctp#open-0&quot;&gt;gen_sctp:open/0,1,2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63d9eb9271114848197174178defd97f77fc4e24" translate="yes" xml:space="preserve">
          <source>Bit Syntax</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360cda316649dfca67f2603c94b136a74b6c648a" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are analogous to List Comprehensions. They are used to generate bit strings efficiently and succinctly.</source>
          <target state="translated">Las comprensiones de cadenas de bits son análogas a las comprensiones de listas.Se utilizan para generar cadenas de bits de forma eficiente y sucinta.</target>
        </trans-unit>
        <trans-unit id="f9ef7ef37c0e6417fc396a660a24f1538c5ef671" translate="yes" xml:space="preserve">
          <source>Bit string comprehensions are written with the following syntax:</source>
          <target state="translated">Las comprensiones de las cadenas de bits se escriben con la siguiente sintaxis:</target>
        </trans-unit>
        <trans-unit id="5d2f7999e57c41f3eb88a4f59c1cc481292645c5" translate="yes" xml:space="preserve">
          <source>Bit strings are compared bit by bit. If one bit string is a prefix of the other, the shorter bit string is considered smaller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2441919ecc33eba0d15c91c6774d8e118b27fa" translate="yes" xml:space="preserve">
          <source>Bit strings are expressed using the &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Las cadenas de bits se expresan utilizando la &lt;code&gt;&lt;a href=&quot;expressions#bit_syntax&quot;&gt;bit syntax&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ef4786f28896f4e7ec27947fbbc93a25189b57f1" translate="yes" xml:space="preserve">
          <source>Bit strings that consist of a number of bits that are evenly divisible by eight, are called &lt;strong&gt;binaries&lt;/strong&gt;</source>
          <target state="translated">Las cadenas de bits que constan de una cantidad de bits que son divisibles por ocho se denominan &lt;strong&gt;binarios.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="71ef7d1974a07fcaa17eb97f44c3fb4fcef331ed" translate="yes" xml:space="preserve">
          <source>Bitshift right</source>
          <target state="translated">Bitshift a la derecha</target>
        </trans-unit>
        <trans-unit id="a8a268a3b89f5db9e48e02038fd78e154fb41041" translate="yes" xml:space="preserve">
          <source>Bitstring Element Type Specifiers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17e80e5f71e9b85954b350f117d4dfeb3c5cf70a" translate="yes" xml:space="preserve">
          <source>Bitwise AND</source>
          <target state="translated">Un poco más inteligente y...</target>
        </trans-unit>
        <trans-unit id="f4be0adcfa81c37e1e7bbf2e23630f30974d164f" translate="yes" xml:space="preserve">
          <source>Bitwise OR</source>
          <target state="translated">Un poco más o menos...</target>
        </trans-unit>
        <trans-unit id="567f521d0a70021d35df0a7429cd3579c200a9d3" translate="yes" xml:space="preserve">
          <source>Bitwise operators: &lt;code&gt;band&lt;/code&gt;, &lt;code&gt;bor&lt;/code&gt;, &lt;code&gt;bxor&lt;/code&gt;, &lt;code&gt;bnot&lt;/code&gt;, &lt;code&gt;bsl&lt;/code&gt;, &lt;code&gt;bsr&lt;/code&gt;</source>
          <target state="translated">Operadores de bits: &lt;code&gt;band&lt;/code&gt; a , &lt;code&gt;bor&lt;/code&gt; , &lt;code&gt;bxor&lt;/code&gt; , &lt;code&gt;bnot&lt;/code&gt; , &lt;code&gt;bsl&lt;/code&gt; , &lt;code&gt;bsr&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ae104d5e9f670270b20927f74417d76623f8773a" translate="yes" xml:space="preserve">
          <source>Black-box testing of target systems of any type (that is, not necessarily implemented in Erlang). This is performed through standard O&amp;amp;M interfaces (such as SNMP, HTTP, CORBA, and Telnet) and, if necessary, through user-specific interfaces (often called test ports).</source>
          <target state="translated">Pruebas de caja negra de sistemas de destino de cualquier tipo (es decir, no necesariamente implementadas en Erlang). Esto se realiza a trav&amp;eacute;s de interfaces est&amp;aacute;ndar de O&amp;amp;M (como SNMP, HTTP, CORBA y Telnet) y, si es necesario, a trav&amp;eacute;s de interfaces espec&amp;iacute;ficas del usuario (a menudo llamadas puertos de prueba).</target>
        </trans-unit>
        <trans-unit id="9a8a1cf314b7d5a93ed2c3c8500ce8e82ea060d8" translate="yes" xml:space="preserve">
          <source>Block ciphers -  DES and AES in Block Cipher Modes - &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</source>
          <target state="translated">Cifrados en bloque: DES y AES en modos de cifrado en bloque: &lt;code&gt;&lt;a href=&quot;http://csrc.nist.gov/groups/ST/toolkit/BCM/index.html&quot;&gt; ECB, CBC, CFB, OFB, CTR and GCM &lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="fc11d63974d38781fdb2ea32c8ba8e895421285c" translate="yes" xml:space="preserve">
          <source>Block expressions provide a way to group a sequence of expressions, similar to a clause body. The return value is the value of the last expression &lt;code&gt;ExprN&lt;/code&gt;.</source>
          <target state="translated">Las expresiones de bloque proporcionan una forma de agrupar una secuencia de expresiones, similar al cuerpo de una cl&amp;aacute;usula. El valor de retorno es el valor de la &amp;uacute;ltima expresi&amp;oacute;n &lt;code&gt;ExprN&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a11c7845b57dd764a4e0b6dfeac45510d039cbd4" translate="yes" xml:space="preserve">
          <source>Blocking of multi-scheduling and normal multi-scheduling is normally not needed. If you feel that you need to use these features, consider it a few more times again. Blocking multi-scheduling is only to be used as a last resort, as it is most likely a &lt;strong&gt;very inefficient&lt;/strong&gt; way to solve the problem.</source>
          <target state="translated">Normalmente no es necesario bloquear la programaci&amp;oacute;n m&amp;uacute;ltiple y la programaci&amp;oacute;n m&amp;uacute;ltiple normal. Si cree que necesita utilizar estas funciones, consid&amp;eacute;relo un par de veces m&amp;aacute;s. El bloqueo de la programaci&amp;oacute;n m&amp;uacute;ltiple solo debe usarse como &amp;uacute;ltimo recurso, ya que probablemente sea una forma &lt;strong&gt;muy ineficiente&lt;/strong&gt; de resolver el problema.</target>
        </trans-unit>
        <trans-unit id="f88bcddd0731f8535aab4cf6c4aea9771da5b592" translate="yes" xml:space="preserve">
          <source>Blocks that are larger than the value of the singleblock carrier threshold (&lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt;) parameter are placed in singleblock carriers.</source>
          <target state="translated">Los bloques que son mayores que el valor del par&amp;aacute;metro umbral de portadora de bloque &lt;code&gt;&lt;a href=&quot;#M_sbct&quot;&gt;sbct&lt;/a&gt;&lt;/code&gt; ( sbct ) se colocan en portadoras de bloque &amp;uacute;nico.</target>
        </trans-unit>
        <trans-unit id="19edd385ea6503e1211246f52fb3bd015a6b72b6" translate="yes" xml:space="preserve">
          <source>Blocks that are smaller than the value of parameter &lt;code&gt;sbct&lt;/code&gt; are placed in multiblock carriers.</source>
          <target state="translated">Los bloques que son m&amp;aacute;s peque&amp;ntilde;os que el valor del par&amp;aacute;metro &lt;code&gt;sbct&lt;/code&gt; se colocan en portadoras multibloque.</target>
        </trans-unit>
        <trans-unit id="4206776cd5ab32e70519cb42f90bc1cb4373333a" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;is_map_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;is_seq_trace&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e3cde099dd0c2860dfd30f6b0378f3f056b13cc7" translate="yes" xml:space="preserve">
          <source>BoolFunction ::= &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</source>
          <target state="translated">BoolFunction :: = &lt;code&gt;is_atom&lt;/code&gt; | &lt;code&gt;is_float&lt;/code&gt; | &lt;code&gt;is_integer&lt;/code&gt; | &lt;code&gt;is_list&lt;/code&gt; | &lt;code&gt;is_number&lt;/code&gt; | &lt;code&gt;is_pid&lt;/code&gt; | &lt;code&gt;is_port&lt;/code&gt; | &lt;code&gt;is_reference&lt;/code&gt; | &lt;code&gt;is_tuple&lt;/code&gt; | &lt;code&gt;is_map&lt;/code&gt; | &lt;code&gt;map_is_key&lt;/code&gt; | &lt;code&gt;is_binary&lt;/code&gt; | &lt;code&gt;is_function&lt;/code&gt; | &lt;code&gt;is_record&lt;/code&gt; | &lt;code&gt;'and'&lt;/code&gt; | &lt;code&gt;'or'&lt;/code&gt; | &lt;code&gt;'not'&lt;/code&gt; | &lt;code&gt;'xor'&lt;/code&gt; | &lt;code&gt;'andalso'&lt;/code&gt; | &lt;code&gt;'orelse'&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="60192723d1692fc0b5f8fc179416c38b9c58ae23" translate="yes" xml:space="preserve">
          <source>Boolean expressions</source>
          <target state="translated">Expresiones booleanas</target>
        </trans-unit>
        <trans-unit id="66182d005e228ccf7ad8ca7af48f43e62e8288b3" translate="yes" xml:space="preserve">
          <source>Boolean operators: &lt;code&gt;not&lt;/code&gt;, &lt;code&gt;and&lt;/code&gt;, &lt;code&gt;or&lt;/code&gt;, &lt;code&gt;andalso&lt;/code&gt;, &lt;code&gt;orelse&lt;/code&gt;</source>
          <target state="translated">Operadores booleanos: &lt;code&gt;not&lt;/code&gt; , &lt;code&gt;and&lt;/code&gt; , &lt;code&gt;or&lt;/code&gt; , &lt;code&gt;andalso&lt;/code&gt; , &lt;code&gt;orelse&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ff2372b936c678678613bf8145deb94c379766ad" translate="yes" xml:space="preserve">
          <source>Booleans in ASN.1 express values that can be either &lt;code&gt;TRUE&lt;/code&gt; or &lt;code&gt;FALSE&lt;/code&gt;. The meanings assigned to &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; are outside the scope of this text.</source>
          <target state="translated">Los booleanos en ASN.1 expresan valores que pueden ser &lt;code&gt;TRUE&lt;/code&gt; o &lt;code&gt;FALSE&lt;/code&gt; . Los significados asignados a &lt;code&gt;TRUE&lt;/code&gt; y &lt;code&gt;FALSE&lt;/code&gt; est&amp;aacute;n fuera del alcance de este texto.</target>
        </trans-unit>
        <trans-unit id="57f87135d0b5c7204e5e725d7f6d51c65d0e1da6" translate="yes" xml:space="preserve">
          <source>Boot script</source>
          <target state="translated">Guión de arranque</target>
        </trans-unit>
        <trans-unit id="55cc3a7f7d6ae5f5575682107980e3293f644b52" translate="yes" xml:space="preserve">
          <source>Boot scripts are built using the &lt;code&gt;systools&lt;/code&gt; utility in the SASL application. For more information on &lt;code&gt;systools&lt;/code&gt;, see the SASL documentation. This is only an example of what can be done.</source>
          <target state="translated">Los scripts de arranque se crean utilizando la utilidad &lt;code&gt;systools&lt;/code&gt; en la aplicaci&amp;oacute;n SASL. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre &lt;code&gt;systools&lt;/code&gt; , consulte la documentaci&amp;oacute;n de SASL. Este es solo un ejemplo de lo que se puede hacer.</target>
        </trans-unit>
        <trans-unit id="a3d4144d275cc7e2f7cb03eca0c38a1d2569fa5e" translate="yes" xml:space="preserve">
          <source>Boot server for other Erlang machines.</source>
          <target state="translated">Servidor de arranque para otras máquinas de Erlang.</target>
        </trans-unit>
        <trans-unit id="516f821cffde24557819cc9db18117f3a7da6530" translate="yes" xml:space="preserve">
          <source>Bopomofo</source>
          <target state="translated">Bopomofo</target>
        </trans-unit>
        <trans-unit id="aeca55061b1a7fcf42d399adecf44466466ea1f5" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;GetInfo&lt;/code&gt; and &lt;code&gt;GetBin&lt;/code&gt; must be called within the &lt;code&gt;Fun&lt;/code&gt;. Their behavior is undefined if they are called outside the context of &lt;code&gt;Fun&lt;/code&gt;.</source>
          <target state="translated">Tanto &lt;code&gt;GetInfo&lt;/code&gt; como &lt;code&gt;GetBin&lt;/code&gt; deben llamarse dentro de &lt;code&gt;Fun&lt;/code&gt; . Su comportamiento no est&amp;aacute; definido si se les llama fuera del contexto de &lt;code&gt;Fun&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="088b2c8092f1e119c8753dea210acbd5446d7101" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;WarningList&lt;/code&gt; and &lt;code&gt;ErrorList&lt;/code&gt; have the following format:</source>
          <target state="translated">Tanto &lt;code&gt;WarningList&lt;/code&gt; como &lt;code&gt;ErrorList&lt;/code&gt; tienen el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="17f701bc8b6f6001358219750664486c85b21b5d" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;case&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt; have &lt;strong&gt;return values&lt;/strong&gt;, that is, in the above example &lt;code&gt;case&lt;/code&gt; returned either &lt;code&gt;{inch,X/2.54}&lt;/code&gt; or &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt;. The behaviour of &lt;code&gt;case&lt;/code&gt; can also be modified by using guards. The following example clarifies this. It tells us the length of a month, given the year. The year must be known, since February has 29 days in a leap year.</source>
          <target state="translated">Tanto el &lt;code&gt;case&lt;/code&gt; como el &lt;code&gt;if&lt;/code&gt; tienen &lt;strong&gt;valores de retorno&lt;/strong&gt; , es decir, en el &lt;code&gt;case&lt;/code&gt; ejemplo anterior devolvi&amp;oacute; &lt;code&gt;{inch,X/2.54}&lt;/code&gt; o &lt;code&gt;{centimeter,Y*2.54}&lt;/code&gt; . El comportamiento del &lt;code&gt;case&lt;/code&gt; tambi&amp;eacute;n se puede modificar mediante el uso de guardias. El siguiente ejemplo aclara esto. Nos dice la duraci&amp;oacute;n de un mes, dado el a&amp;ntilde;o. Hay que conocer el a&amp;ntilde;o, ya que febrero tiene 29 d&amp;iacute;as en un a&amp;ntilde;o bisiesto.</target>
        </trans-unit>
        <trans-unit id="28509f91486de7be6923a1aa53ee47118e6db5bf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;sys&lt;/code&gt; and &lt;code&gt;proc_lib&lt;/code&gt; belong to the STDLIB application.</source>
          <target state="translated">Tanto &lt;code&gt;sys&lt;/code&gt; como &lt;code&gt;proc_lib&lt;/code&gt; pertenecen a la aplicaci&amp;oacute;n STDLIB.</target>
        </trans-unit>
        <trans-unit id="da40d11cd13d54f5078c0119cec66e0ccfe5dfdd" translate="yes" xml:space="preserve">
          <source>Both building with dynamic trace probes and using them is experimental and unsupported by Erlang/OTP. It is included as an option for the developer to trace and debug performance issues in their systems.</source>
          <target state="translated">Tanto la construcción con sondas de rastreo dinámico como su uso es experimental y no tiene el apoyo de Erlang/OTP.Se incluye como una opción para que el desarrollador rastree y depure los problemas de rendimiento en sus sistemas.</target>
        </trans-unit>
        <trans-unit id="272b41459c2a4ad1e5b3d0281a8c236f1fbb8ef5" translate="yes" xml:space="preserve">
          <source>Both clients and daemons accepts options that controls the exact behaviour. Some options are common to both. The three sets are called &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Tanto los clientes como los demonios aceptan opciones que controlan el comportamiento exacto. Algunas opciones son comunes a ambos. Los tres conjuntos se denominan &lt;code&gt;&lt;a href=&quot;#type-client_options&quot;&gt;Client Options&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#type-daemon_options&quot;&gt;Daemon Options&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#type-common_options&quot;&gt;Common Options&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43500df87c9d667061a043ba9cd51b43abef2516" translate="yes" xml:space="preserve">
          <source>Both functions are described in the following.</source>
          <target state="translated">Ambas funciones se describen a continuación.</target>
        </trans-unit>
        <trans-unit id="8393123b8c640d62b0cc06dc60be2e57645d7426" translate="yes" xml:space="preserve">
          <source>Both increasing and decreasing &lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt;s are allowed.</source>
          <target state="translated">Se &lt;code&gt;&amp;lt;IdRange&amp;gt;&lt;/code&gt; tanto crecientes como decrecientes .</target>
        </trans-unit>
        <trans-unit id="84d91e83adcd109e53d7f1d1718f4d0e6a80ae0d" translate="yes" xml:space="preserve">
          <source>Both mechanisms have the same theoretical time and memory complexity, while the selective receive language construct has smaller constant factors.</source>
          <target state="translated">Ambos mecanismos tienen el mismo tiempo teórico y la misma complejidad de memoria,mientras que la construcción del lenguaje de recepción selectiva tiene factores constantes más pequeños.</target>
        </trans-unit>
        <trans-unit id="c1196a55702bdb5abaf2deea06cedc05c7a896fe" translate="yes" xml:space="preserve">
          <source>Both of them can be empty, but not at the same time. If &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; is empty, no changes have been made that change the build result of any application. This could, for example, be a pure bug fix of the build system. The order of lines is undefined. All white-space characters in this file are either space (character 32) or line-break (character 10).</source>
          <target state="translated">Ambos pueden estar vac&amp;iacute;os, pero no al mismo tiempo. Si &lt;code&gt;&amp;lt;ChangedAppVersions&amp;gt;&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o, no se han realizado cambios que cambien el resultado de la compilaci&amp;oacute;n de ninguna aplicaci&amp;oacute;n. Esto podr&amp;iacute;a, por ejemplo, ser una pura correcci&amp;oacute;n de errores del sistema de compilaci&amp;oacute;n. El orden de las l&amp;iacute;neas no est&amp;aacute; definido. Todos los caracteres de espacio en blanco en este archivo son espacios (car&amp;aacute;cter 32) o saltos de l&amp;iacute;nea (car&amp;aacute;cter 10).</target>
        </trans-unit>
        <trans-unit id="3442514fe2989d64511fbe704d87cbeac484a561" translate="yes" xml:space="preserve">
          <source>Both old and current code for a module are valid, and can even be evaluated concurrently. The difference is that exported functions in old code are unavailable. Hence, a global call cannot be made to an exported function in old code, but old code can still be evaluated because of processes lingering in it.</source>
          <target state="translated">Tanto el código antiguo como el actual de un módulo son válidos,e incluso pueden ser evaluados simultáneamente.La diferencia es que las funciones exportadas en el código antiguo no están disponibles.Por lo tanto,no se puede hacer una llamada global a una función exportada en código antiguo,pero el código antiguo puede seguir siendo evaluado debido a los procesos que persisten en él.</target>
        </trans-unit>
        <trans-unit id="0a81666107cfaaf40864441b74f9792a8cc7fb8a" translate="yes" xml:space="preserve">
          <source>Both old and current code is valid, and can be evaluated concurrently. Fully qualified function calls always refer to current code. Old code can still be evaluated because of processes lingering in the old code.</source>
          <target state="translated">Tanto el código antiguo como el actual son válidos,y pueden ser evaluados simultáneamente.Las llamadas a funciones totalmente calificadas siempre se refieren al código actual.El código antiguo todavía puede ser evaluado debido a los procesos que perduran en el código antiguo.</target>
        </trans-unit>
        <trans-unit id="19893bb20867dad51e674f2c8283aa35e37963b9" translate="yes" xml:space="preserve">
          <source>Both options give the same effect, the input string is interpreted as UTF-8. Notice that with these instructions, the automatic conversion of lists to UTF-8 is not performed by the &lt;code&gt;re&lt;/code&gt; functions. Therefore, using these sequences is not recommended. Add option &lt;code&gt;unicode&lt;/code&gt; when running &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Ambas opciones dan el mismo efecto, la cadena de entrada se interpreta como UTF-8. Tenga en cuenta que con estas instrucciones, las funciones &lt;code&gt;re&lt;/code&gt; no realizan la conversi&amp;oacute;n autom&amp;aacute;tica de listas a UTF-8 . Por lo tanto, no se recomienda el uso de estas secuencias. En su lugar, agregue la opci&amp;oacute;n &lt;code&gt;unicode&lt;/code&gt; al ejecutar &lt;code&gt;&lt;a href=&quot;#compile-2&quot;&gt;compile/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04f750b6f7ecf467d03fd155880c2c08a8e8637a" translate="yes" xml:space="preserve">
          <source>Both server and event manager are registered processes which can be expected to be always accessible. Thus they are specified to be &lt;code&gt;permanent&lt;/code&gt;.</source>
          <target state="translated">Tanto el servidor como el administrador de eventos son procesos registrados que se puede esperar que est&amp;eacute;n siempre accesibles. Por lo tanto, se especifican como &lt;code&gt;permanent&lt;/code&gt; es .</target>
        </trans-unit>
        <trans-unit id="57dd8748ee1441894d656dd738cdc13c745b3ff2" translate="yes" xml:space="preserve">
          <source>Both source code and object code for the module is found.</source>
          <target state="translated">Se encuentra tanto el código fuente como el código objeto del módulo.</target>
        </trans-unit>
        <trans-unit id="e0ebc6ec0ff8694d627315dcce4507da48f45e45" translate="yes" xml:space="preserve">
          <source>Both the agent and the manager can be configured to log incoming and outgoing messages. It uses the Erlang standard log mechanism &lt;code&gt;disk_log&lt;/code&gt; for logging. The size and location of the log files are configurable. A wrap log is used, which means that when the log has grown to a maximum size, it starts from the beginning of the log, overwriting existing log records.</source>
          <target state="translated">Tanto el agente como el administrador pueden configurarse para registrar mensajes entrantes y salientes. Utiliza el mecanismo de registro est&amp;aacute;ndar de Erlang &lt;code&gt;disk_log&lt;/code&gt; para el registro. El tama&amp;ntilde;o y la ubicaci&amp;oacute;n de los archivos de registro se pueden configurar. Se utiliza un registro de ajuste, lo que significa que cuando el registro ha crecido hasta un tama&amp;ntilde;o m&amp;aacute;ximo, comienza desde el principio del registro, sobrescribiendo los registros de registro existentes.</target>
        </trans-unit>
        <trans-unit id="31ef6ae37976246cbbb8302e6168cf2ddacebc06" translate="yes" xml:space="preserve">
          <source>Both the module declaration and the export declaration of the &lt;code&gt;main/1&lt;/code&gt; function are optional.</source>
          <target state="translated">Tanto la declaraci&amp;oacute;n del m&amp;oacute;dulo como la declaraci&amp;oacute;n de exportaci&amp;oacute;n de la funci&amp;oacute;n &lt;code&gt;main/1&lt;/code&gt; son opcionales.</target>
        </trans-unit>
        <trans-unit id="19b296fa85d6e817ce8e73a30a0d4e4ab33ce24a" translate="yes" xml:space="preserve">
          <source>Both the old and new versions of the &lt;code&gt;.app&lt;/code&gt; and &lt;code&gt;.rel&lt;/code&gt; files must be in the code path, as well as the &lt;code&gt;.appup&lt;/code&gt; and (new) &lt;code&gt;.beam&lt;/code&gt; files. The code path can be extended by using the option &lt;code&gt;path&lt;/code&gt;:</source>
          <target state="translated">Tanto la versi&amp;oacute;n antigua como la nueva de los archivos &lt;code&gt;.app&lt;/code&gt; y &lt;code&gt;.rel&lt;/code&gt; deben estar en la ruta del c&amp;oacute;digo, as&amp;iacute; como los &lt;code&gt;.appup&lt;/code&gt; y (nuevos) &lt;code&gt;.beam&lt;/code&gt; . La ruta del c&amp;oacute;digo se puede ampliar utilizando la &lt;code&gt;path&lt;/code&gt; opci&amp;oacute;n :</target>
        </trans-unit>
        <trans-unit id="b2a0efd65a8f4b932941a27e1ed06208576cd1ee" translate="yes" xml:space="preserve">
          <source>Both the registration and lock services are atomic. All nodes involved in these actions have the same view of the information.</source>
          <target state="translated">Tanto el servicio de registro como el de cierre son atómicos.Todos los nodos involucrados en estas acciones tienen la misma visión de la información.</target>
        </trans-unit>
        <trans-unit id="a1ccfade4aa63d420f2f18a1184490432f9a36ed" translate="yes" xml:space="preserve">
          <source>Both these tools use the message package (time_test.msgs) provided with the tool(s), although it can run on any message package as long as it has the same structure.</source>
          <target state="translated">Ambas herramientas utilizan el paquete de mensajes (time_test.msgs)proporcionado con la(s)herramienta(s),aunque puede ejecutarse en cualquier paquete de mensajes siempre que tenga la misma estructura.</target>
        </trans-unit>
        <trans-unit id="127d494892f18e1ed814ec5250b9730b0af20bb3" translate="yes" xml:space="preserve">
          <source>Both times are in milli seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ccbfe9c0e689e8b9dc53b4b4ec4a1a3a8c73326" translate="yes" xml:space="preserve">
          <source>Both transport security at connection establishment and negotiated via an Inband-Security AVP are supported.</source>
          <target state="translated">Se apoya tanto la seguridad del transporte en el establecimiento de la conexión como la negociada a través de un AVP de seguridad en banda.</target>
        </trans-unit>
        <trans-unit id="6c92949313aaa03bcf35ffa7934493789f21f7cd" translate="yes" xml:space="preserve">
          <source>Both when the client establishes a connection with ssh:connect or other functions, or a daemon is started with ssh:daemon, the option lists in the function calls are also used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c0eaabc27903558b46afc5c85515d4a1d0fc689" translate="yes" xml:space="preserve">
          <source>Bound on the expected size of incoming Diameter messages. Messages larger than the specified number of bytes are discarded.</source>
          <target state="translated">Ligado al tamaño esperado de los mensajes entrantes de Diametro.Los mensajes más grandes que el número especificado de bytes son descartados.</target>
        </trans-unit>
        <trans-unit id="0021328dee4879f40d348f1597841de3b466cc17" translate="yes" xml:space="preserve">
          <source>Bound parts (Erlang terms)</source>
          <target state="translated">Partes de la frontera (términos de Erlang)</target>
        </trans-unit>
        <trans-unit id="24afa8c574a58ec588a649b2ee14b50d33a8ca50" translate="yes" xml:space="preserve">
          <source>Braille</source>
          <target state="translated">Braille</target>
        </trans-unit>
        <trans-unit id="5ff74b881495206c989aabf9a3102e44cc4e4f4e" translate="yes" xml:space="preserve">
          <source>Branch to &lt;code&gt;$Fail&lt;/code&gt;. Suppresses generation of dispatch of the next instruction (&lt;code&gt;-no_next&lt;/code&gt;). Typical use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29ee5bc7776fe10e3fd6ef23bda664af1a74f8a6" translate="yes" xml:space="preserve">
          <source>Branch to &lt;code&gt;$Fail&lt;/code&gt;. Will suppress prefetch (&lt;code&gt;-no_prefetch&lt;/code&gt;). Typical use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd5609c99b4261f4b2a9f0f2cd2cd2a63fc35c8" translate="yes" xml:space="preserve">
          <source>Branches off an existing association &lt;code&gt;Assoc&lt;/code&gt; in a socket &lt;code&gt;Socket&lt;/code&gt; of type &lt;code&gt;seqpacket&lt;/code&gt; (one-to-many style) into a new socket &lt;code&gt;NewSocket&lt;/code&gt; of type &lt;code&gt;stream&lt;/code&gt; (one-to-one style).</source>
          <target state="translated">Se ramifica de una asociaci&amp;oacute;n existente &lt;code&gt;Assoc&lt;/code&gt; en un socket &lt;code&gt;Socket&lt;/code&gt; de tipo &lt;code&gt;seqpacket&lt;/code&gt; (estilo uno a varios) en un nuevo socket &lt;code&gt;NewSocket&lt;/code&gt; de tipo &lt;code&gt;stream&lt;/code&gt; (estilo uno a uno).</target>
        </trans-unit>
        <trans-unit id="7fb13ed24388f546ddc4203cc04ff019ad463378" translate="yes" xml:space="preserve">
          <source>Branches that match different length strings are permitted only at the top-level of a lookbehind assertion. This is an extension compared with Perl, which requires all branches to match the same length of string. An assertion such as the following is not permitted, as its single top-level branch can match two different lengths:</source>
          <target state="translated">Las ramas que coinciden con cuerdas de diferente longitud sólo se permiten en el nivel superior de una afirmación de mirar hacia atrás.Esta es una extensión comparada con la de Perl,que requiere que todas las ramas coincidan con la misma longitud de cuerda.Una afirmación como la siguiente no está permitida,ya que su única rama de nivel superior puede coincidir con dos longitudes diferentes:</target>
        </trans-unit>
        <trans-unit id="2e74a43e735ca8cd77a918952d725756f6ea7331" translate="yes" xml:space="preserve">
          <source>Break Menu</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1151e1739c46421831435065fa64d3a4378e7dc" translate="yes" xml:space="preserve">
          <source>Break, Windows, and Help Menus</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5a0f50acb3dd75574af8408fef3b88b8ceb46b5" translate="yes" xml:space="preserve">
          <source>Breaking up a long-running function in this manner enables the VM to regain control between calls to the NIFs.</source>
          <target state="translated">Romper una función de larga duración de esta manera permite al VM recuperar el control entre las llamadas a los NIF.</target>
        </trans-unit>
        <trans-unit id="8bdcc7199154fffd9f8d9a9848283a3809fc361e" translate="yes" xml:space="preserve">
          <source>Breakpoints are created and deleted using the &lt;strong&gt;Break&lt;/strong&gt; menu of either the Monitor window, View Module window, or Attach Process window.</source>
          <target state="translated">Los puntos de interrupci&amp;oacute;n se crean y eliminan utilizando la &lt;strong&gt;rotura&lt;/strong&gt; del men&amp;uacute; de la ventana de monitor o bien, ventana del m&amp;oacute;dulo, o Adjuntar ventana de proceso.</target>
        </trans-unit>
        <trans-unit id="7a8d8f460f3a399bfb04e89862d06e9b316c1004" translate="yes" xml:space="preserve">
          <source>Breakpoints are marked with a stop symbol.</source>
          <target state="translated">Los puntos de ruptura están marcados con un símbolo de parada.</target>
        </trans-unit>
        <trans-unit id="e0fac70209382c8083fb51c23797738064b31d35" translate="yes" xml:space="preserve">
          <source>Breakpoints are specified on a line basis. When a process executing code in an interpreted module reaches a breakpoint, it stops. This means that a breakpoint must be set at an executable line, that is, a code line containing an executable expression.</source>
          <target state="translated">Los puntos de ruptura se especifican por línea.Cuando un proceso que ejecuta un código en un módulo interpretado alcanza un punto de ruptura,se detiene.Esto significa que un punto de interrupción debe establecerse en una línea ejecutable,es decir,una línea de código que contenga una expresión ejecutable.</target>
        </trans-unit>
        <trans-unit id="fbbe2bd05741e651732db1439c4df7101add2a7e" translate="yes" xml:space="preserve">
          <source>Briefly on Solaris 10</source>
          <target state="translated">Brevemente en Solaris 10</target>
        </trans-unit>
        <trans-unit id="2c54c32cef81a294e27f0b55c17e9d3989656be7" translate="yes" xml:space="preserve">
          <source>Broadcasts on a condition variable. That is, if other threads are waiting on the condition variable being broadcast on, &lt;strong&gt;all&lt;/strong&gt; of them are woken.</source>
          <target state="translated">Emisiones con una condici&amp;oacute;n variable. Es decir, si otros subprocesos est&amp;aacute;n esperando a que se difunda la variable de condici&amp;oacute;n, &lt;strong&gt;todos&lt;/strong&gt; se activan.</target>
        </trans-unit>
        <trans-unit id="298841afbb7ef24f7711e916938def078c174299" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; asynchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">Transmite el mensaje &lt;code&gt;Msg&lt;/code&gt; de forma asincr&amp;oacute;nica al proceso registrado &lt;code&gt;Name&lt;/code&gt; en los nodos especificados.</target>
        </trans-unit>
        <trans-unit id="0e9067bfac6a20153ac4defbe476694c9b168a4a" translate="yes" xml:space="preserve">
          <source>Broadcasts the message &lt;code&gt;Msg&lt;/code&gt; synchronously to the registered process &lt;code&gt;Name&lt;/code&gt; on the specified nodes.</source>
          <target state="translated">Transmite el mensaje &lt;code&gt;Msg&lt;/code&gt; sincr&amp;oacute;nicamente al proceso registrado &lt;code&gt;Name&lt;/code&gt; en los nodos especificados.</target>
        </trans-unit>
        <trans-unit id="e87af70cba1f1e451d37824609594b2a73b9bafc" translate="yes" xml:space="preserve">
          <source>Browse the application configuration file (do &lt;strong&gt;not&lt;/strong&gt; edit it). The full name of the application configuration file is derived from the position of the &lt;code&gt;os_mon&lt;/code&gt; application in the file system by adding &lt;code&gt;/ebin/os_mon.app&lt;/code&gt;.</source>
          <target state="translated">Examine el archivo de configuraci&amp;oacute;n de la aplicaci&amp;oacute;n (no &lt;strong&gt;lo&lt;/strong&gt; edite). El nombre completo del archivo de configuraci&amp;oacute;n de la aplicaci&amp;oacute;n se deriva de la posici&amp;oacute;n de la aplicaci&amp;oacute;n &lt;code&gt;os_mon&lt;/code&gt; en el sistema de archivos agregando &lt;code&gt;/ebin/os_mon.app&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d698cd7b5307da0633f70f00f726e5dbe00ea1a" translate="yes" xml:space="preserve">
          <source>Browses table &lt;code&gt;Tab&lt;/code&gt; on a terminal.</source>
          <target state="translated">Navega por la &lt;code&gt;Tab&lt;/code&gt; tabla en un terminal.</target>
        </trans-unit>
        <trans-unit id="f47b617427a681f5cc68845744e7adc91ae07ed8" translate="yes" xml:space="preserve">
          <source>Browsing the html pages by loading the page &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; or &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; if the prefix option has been used.</source>
          <target state="translated">Navegar por las p&amp;aacute;ginas html cargando la p&amp;aacute;gina &lt;code&gt;/usr/local/lib/erlang/doc/erlang/index.html&lt;/code&gt; o &lt;code&gt;&amp;lt;BaseDir&amp;gt;/lib/erlang/doc/erlang/index.html&lt;/code&gt; si se ha utilizado la opci&amp;oacute;n de prefijo.</target>
        </trans-unit>
        <trans-unit id="792fdd1cd5fd403216843c6560d9bf75c37a3a2e" translate="yes" xml:space="preserve">
          <source>Buf is initialized to contain object attributes.</source>
          <target state="translated">El Buf está inicializado para contener atributos de objeto.</target>
        </trans-unit>
        <trans-unit id="3caca7ca1e839168f274364c9d0c4a80119c3d3a" translate="yes" xml:space="preserve">
          <source>Buffer is too small.</source>
          <target state="translated">El buffer es demasiado pequeño.</target>
        </trans-unit>
        <trans-unit id="c32cae74e192e8ea56db8683dfa3876fd9fa316b" translate="yes" xml:space="preserve">
          <source>Buginese</source>
          <target state="translated">Buginese</target>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="f55777a6f9cd8a9c1199724cddc2f176cde4e922" translate="yes" xml:space="preserve">
          <source>Buhid</source>
          <target state="translated">Buhid</target>
        </trans-unit>
        <trans-unit id="5e39e7697b21824bcc7130368908ca3db3109308" translate="yes" xml:space="preserve">
          <source>Build Erlang/OTP</source>
          <target state="translated">Construir Erlang/OTP</target>
        </trans-unit>
        <trans-unit id="da71556c2060cac2828b51ce118c10a5f1cb07b2" translate="yes" xml:space="preserve">
          <source>Build Issues</source>
          <target state="translated">Problemas de construcción...</target>
        </trans-unit>
        <trans-unit id="9bd5d4eae87e4cb4572c4356e658e62097907c06" translate="yes" xml:space="preserve">
          <source>Build Your Own Tool</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82de423db4cc623ec5f04ba52bfec4b055f722a1" translate="yes" xml:space="preserve">
          <source>Build or install the FIPS Object Module and a FIPS enabled OpenSSL library.</source>
          <target state="translated">Construya o instale el módulo de objetos FIPS y una biblioteca OpenSSL habilitada para FIPS.</target>
        </trans-unit>
        <trans-unit id="0ca44d234eb0f2b9b591c5ee4decd555e8ce199c" translate="yes" xml:space="preserve">
          <source>Build the Erlang/OTP release.</source>
          <target state="translated">Construye el lanzamiento de Erlang/OTP.</target>
        </trans-unit>
        <trans-unit id="07f491f3b5c090f34f2ee3e97cafbb3c5f5f8099" translate="yes" xml:space="preserve">
          <source>Build the boot script.</source>
          <target state="translated">Construye el guión de arranque.</target>
        </trans-unit>
        <trans-unit id="77d5d2f2a5f4a3ffbde6ae0d3e363ac721059f26" translate="yes" xml:space="preserve">
          <source>Build the documentation.</source>
          <target state="translated">Construye la documentación.</target>
        </trans-unit>
        <trans-unit id="a24b09d07965fb944dc46c1d07ebc9828be50298" translate="yes" xml:space="preserve">
          <source>Build with:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d9080383317c03f360d21bbd25b0561e946784" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. Note that &lt;code&gt;otp_build configure&lt;/code&gt; will produce a default configuration that differs from what &lt;code&gt;configure&lt;/code&gt; will produce by default. For example, currently &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; is added to the &lt;code&gt;configure&lt;/code&gt; command line arguments unless &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; has been explicitly passed. The binary releases that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;. The defaults used by &lt;code&gt;otp_build configure&lt;/code&gt; may change at any time without prior notice.</source>
          <target state="translated">La construcci&amp;oacute;n de Erlang / OTP se puede realizar utilizando el &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; o invocando &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; y &lt;code&gt;make&lt;/code&gt; directamente. Construir usando &lt;code&gt;otp_build&lt;/code&gt; es m&amp;aacute;s f&amp;aacute;cil ya que implica menos pasos, pero el procedimiento de construcci&amp;oacute;n &lt;code&gt;otp_build&lt;/code&gt; no es tan flexible como el procedimiento de construcci&amp;oacute;n &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; . Tenga en cuenta que &lt;code&gt;otp_build configure&lt;/code&gt; producir&amp;aacute; una configuraci&amp;oacute;n predeterminada que difiere de la que &lt;code&gt;configure&lt;/code&gt; producir&amp;aacute; de forma predeterminada. Por ejemplo, actualmente &lt;code&gt;--disable-dynamic-ssl-lib&lt;/code&gt; se agrega a los argumentos de la l&amp;iacute;nea de comandos de &lt;code&gt;configure&lt;/code&gt; menos que &lt;code&gt;--enable-dynamic-ssl-lib&lt;/code&gt; se ha pasado expl&amp;iacute;citamente. Las versiones binarias que entregamos se crean utilizando &lt;code&gt;otp_build&lt;/code&gt; . Los valores predeterminados utilizados por &lt;code&gt;otp_build configure&lt;/code&gt; pueden cambiar en cualquier momento sin previo aviso.</target>
        </trans-unit>
        <trans-unit id="0288be29544ae6b8e621446c1d716ba731ebd705" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP can be done either by using the &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; script, or by invoking &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; and &lt;code&gt;make&lt;/code&gt; directly. Building using &lt;code&gt;otp_build&lt;/code&gt; is easier since it involves fewer steps, but the &lt;code&gt;otp_build&lt;/code&gt; build procedure is not as flexible as the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure. The binary releases for Windows that we deliver are built using &lt;code&gt;otp_build&lt;/code&gt;.</source>
          <target state="translated">La construcci&amp;oacute;n de Erlang / OTP se puede realizar utilizando el &lt;code&gt;$ERL_TOP/otp_build&lt;/code&gt; o invocando &lt;code&gt;$ERL_TOP/configure&lt;/code&gt; y &lt;code&gt;make&lt;/code&gt; directamente. Construir usando &lt;code&gt;otp_build&lt;/code&gt; es m&amp;aacute;s f&amp;aacute;cil ya que implica menos pasos, pero el procedimiento de construcci&amp;oacute;n &lt;code&gt;otp_build&lt;/code&gt; no es tan flexible como el procedimiento de construcci&amp;oacute;n &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; . Las versiones binarias para Windows que entregamos se crean utilizando &lt;code&gt;otp_build&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9a1d72262f0ba28560224e8b5f84f82d3a37931" translate="yes" xml:space="preserve">
          <source>Building Erlang/OTP on a relatively fast computer takes approximately 5 minutes. To speed it up, you can utilize parallel make with the &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; option.</source>
          <target state="translated">La construcci&amp;oacute;n de Erlang / OTP en una computadora relativamente r&amp;aacute;pida toma aproximadamente 5 minutos. Para acelerarlo, puede utilizar la creaci&amp;oacute;n en paralelo con la opci&amp;oacute;n &lt;code&gt;-j&amp;lt;num_jobs&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9ef5793998a525a29078ba78dcc6651a8e69241f" translate="yes" xml:space="preserve">
          <source>Building a Bootstrap System</source>
          <target state="translated">Construyendo un sistema de Bootstrap</target>
        </trans-unit>
        <trans-unit id="6fcd9e84832d8fc06ff9412088752b9ac40d1d27" translate="yes" xml:space="preserve">
          <source>Building in Git</source>
          <target state="translated">Edificio en Git</target>
        </trans-unit>
        <trans-unit id="6e610827003738b99e768b26958b3f36694ff33c" translate="yes" xml:space="preserve">
          <source>Building is easiest using the &lt;code&gt;otp_build&lt;/code&gt; script:</source>
          <target state="translated">La construcci&amp;oacute;n es m&amp;aacute;s f&amp;aacute;cil usando el script &lt;code&gt;otp_build&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="840f8d32dc79d0e6d7906ca187022ffdcd65d433" translate="yes" xml:space="preserve">
          <source>Building on OS X</source>
          <target state="translated">Construyendo sobre OS X</target>
        </trans-unit>
        <trans-unit id="0919d6c99c47efcb70329ed0ebdeb92cd58e964c" translate="yes" xml:space="preserve">
          <source>Building terms and patterns</source>
          <target state="translated">Términos y patrones de construcción</target>
        </trans-unit>
        <trans-unit id="d7b4eea65f50794546e0a9cd2e50530baa9d4e3f" translate="yes" xml:space="preserve">
          <source>Building with wxErlang</source>
          <target state="translated">Construir con WxErlang</target>
        </trans-unit>
        <trans-unit id="03d9659d4e51ca391a6e1291a5a6e5195ec7e16f" translate="yes" xml:space="preserve">
          <source>Building with wxWidgets. Download wxWidgets-3.0.3 or higher.</source>
          <target state="translated">Construir con wxWidgets.Descarga wxWidgets-3.0.3 o superior.</target>
        </trans-unit>
        <trans-unit id="5a48efe1163ff4f604b0e75b0f8069e848d42294" translate="yes" xml:space="preserve">
          <source>Builds a BEAM module (as a binary) from a list of chunks.</source>
          <target state="translated">Construye un módulo BEAM (como binario)a partir de una lista de trozos.</target>
        </trans-unit>
        <trans-unit id="04266b7610bbe7204641a5a18f1b641cc5a4ad92" translate="yes" xml:space="preserve">
          <source>Builds an internal structure representing a compilation of a search pattern, later to be used in functions &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;cp()&lt;/code&gt; returned is guaranteed to be a &lt;code&gt;tuple()&lt;/code&gt; to allow programs to distinguish it from non-precompiled search patterns.</source>
          <target state="translated">Construye una estructura interna que representa una compilaci&amp;oacute;n de un patr&amp;oacute;n de b&amp;uacute;squeda, que luego se utilizar&amp;aacute; en las funciones &lt;code&gt;&lt;a href=&quot;#match-3&quot;&gt;match/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#matches-3&quot;&gt;matches/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#split-3&quot;&gt;split/3&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#replace-4&quot;&gt;replace/4&lt;/a&gt;&lt;/code&gt; . Se garantiza que el &lt;code&gt;cp()&lt;/code&gt; devuelto es una &lt;code&gt;tuple()&lt;/code&gt; para permitir que los programas lo distingan de los patrones de b&amp;uacute;squeda no precompilados.</target>
        </trans-unit>
        <trans-unit id="20f409cc87c744070ec80e942947a590f8db80d1" translate="yes" xml:space="preserve">
          <source>Built-in</source>
          <target state="translated">Built-in</target>
        </trans-unit>
        <trans-unit id="3685c8c87d2a5725cbc54a94228a1a89d1d88a57" translate="yes" xml:space="preserve">
          <source>Built-in term storage.</source>
          <target state="translated">Almacenamiento a término incorporado.</target>
        </trans-unit>
        <trans-unit id="0bb738fd2329e288e2fef0e51024a5ca1fdbc3e0" translate="yes" xml:space="preserve">
          <source>Busy Port Queue</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5c53caa503fd2d5724e0037aba0a5ac29a1adc" translate="yes" xml:space="preserve">
          <source>But &lt;code&gt;'ssh-dss'&lt;/code&gt; is selected although the call inserted &lt;strong&gt;only&lt;/strong&gt;&lt;code&gt;'ecdsa-sha2-nistp256'&lt;/code&gt; as acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="298adb411a18178593c4d780e03d5a00362414a8" translate="yes" xml:space="preserve">
          <source>But before all name servers are tried again, there is a (user configurable) timeout, &lt;code&gt;servfail_retry_timeout&lt;/code&gt;. The point of this is to prevent the new query to be handled by to the servfail cache (a client that is to eager will actually only get what is in the servfail cache).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb37192b82c7544aec29ebacff8270ec18c0cbee" translate="yes" xml:space="preserve">
          <source>But how can the client know that the host</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5849712291c78b1a99987a87b4b4819b9538fc4d" translate="yes" xml:space="preserve">
          <source>But if a constant is sent to another process (or stored in an Ets table), it is &lt;strong&gt;copied&lt;/strong&gt;. The reason is that the runtime system must be able to keep track of all references to constants to unload code containing constants properly. (When the code is unloaded, the constants are copied to the heap of the processes that refer to them.) The copying of constants might be eliminated in a future Erlang/OTP release.</source>
          <target state="translated">Pero si una constante se env&amp;iacute;a a otro proceso (o se almacena en una tabla Ets), se &lt;strong&gt;copia&lt;/strong&gt; . La raz&amp;oacute;n es que el sistema de tiempo de ejecuci&amp;oacute;n debe poder realizar un seguimiento de todas las referencias a constantes para descargar el c&amp;oacute;digo que contiene constantes correctamente. (Cuando se descarga el c&amp;oacute;digo, las constantes se copian en el mont&amp;oacute;n de los procesos que se refieren a ellas). La copia de constantes podr&amp;iacute;a eliminarse en una futura versi&amp;oacute;n de Erlang / OTP.</target>
        </trans-unit>
        <trans-unit id="12383ec381d6eef21e12692f3a3beac567f979cb" translate="yes" xml:space="preserve">
          <source>But in more complicated code, how can one know whether the optimization is applied or not?</source>
          <target state="translated">Pero en un código más complicado,¿cómo se puede saber si la optimización se aplica o no?</target>
        </trans-unit>
        <trans-unit id="13e80088d58b6e2e78ae703a190df34ce17a3ab1" translate="yes" xml:space="preserve">
          <source>But it will generate code that builds a sub binary in the first clause:</source>
          <target state="translated">Pero generará un código que construye un sub-binario en la primera cláusula:</target>
        </trans-unit>
        <trans-unit id="a0a27a5b2ec989d8d33e3ef99ff2c029f3ccadb0" translate="yes" xml:space="preserve">
          <source>But that is history. Funs was given its own data type in R6B and was further optimized in R7B. Now the cost for a fun call falls roughly between the cost for a call to a local function and &lt;code&gt;apply/3&lt;/code&gt;.</source>
          <target state="translated">Pero eso es historia. Funs recibi&amp;oacute; su propio tipo de datos en R6B y se optimiz&amp;oacute; a&amp;uacute;n m&amp;aacute;s en R7B. Ahora, el costo de una llamada divertida cae aproximadamente entre el costo de una llamada a una funci&amp;oacute;n local y &lt;code&gt;apply/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff87650cc86869f3f95aa712bb2012bf312a0ec1" translate="yes" xml:space="preserve">
          <source>But they &lt;strong&gt;cannot&lt;/strong&gt; be combined with intAgentTransports.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9edeffd1c02cedcbcf042627c2b5c0c907cde008" translate="yes" xml:space="preserve">
          <source>But this fails as Fred has already logged off.</source>
          <target state="translated">Pero esto falla porque Fred ya se ha desconectado.</target>
        </trans-unit>
        <trans-unit id="3c55fef2a765c8d16ab4eacfbd4c2a04ae1406db" translate="yes" xml:space="preserve">
          <source>But this fails:</source>
          <target state="translated">Pero esto falla:</target>
        </trans-unit>
        <trans-unit id="ae29bf624e4dd4338883041af300ffb73e4829e9" translate="yes" xml:space="preserve">
          <source>But this is not enough. There is also a set of &lt;strong&gt;mandatory&lt;/strong&gt; messages which the network interface entity must be able to receive and be able to send. This is described in chapter &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Pero esto no es suficiente. Tambi&amp;eacute;n hay un conjunto de mensajes &lt;strong&gt;obligatorios&lt;/strong&gt; que la entidad de interfaz de red debe poder recibir y enviar. Esto se describe en el cap&amp;iacute;tulo &lt;code&gt;&lt;a href=&quot;snmp_agent_netif&quot;&gt;snmp_agent_netif&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45778b54cb8ef168c982efffe69e2d8b502fce93" translate="yes" xml:space="preserve">
          <source>But using &lt;code&gt;++&lt;/code&gt; as follows is not bad:</source>
          <target state="translated">Pero usar &lt;code&gt;++&lt;/code&gt; de la siguiente manera no es malo:</target>
        </trans-unit>
        <trans-unit id="521274df22007097293748284fe185141e772a3c" translate="yes" xml:space="preserve">
          <source>But you realize that it is unnecessary to have the Erlang compiler in this one:</source>
          <target state="translated">Pero te das cuenta de que no es necesario tener el compilador de Erlang en este:</target>
        </trans-unit>
        <trans-unit id="94852e93461c3ce16031709d1ba53f77338d1422" translate="yes" xml:space="preserve">
          <source>But, if we nevertheless &lt;strong&gt;do&lt;/strong&gt; dig down we find the call to the linked in driver that does the file operations towards the host operating system:</source>
          <target state="translated">Pero, si, no obstante &lt;strong&gt;,&lt;/strong&gt; profundizamos, encontramos la llamada al controlador vinculado que realiza las operaciones de archivo hacia el sistema operativo host:</target>
        </trans-unit>
        <trans-unit id="aaa9717eecd88e22102280721e33d90c4f0a390a" translate="yes" xml:space="preserve">
          <source>By &lt;strong&gt;attaching to&lt;/strong&gt; a process executing interpreted code, it is possible to examine variable bindings and order stepwise execution. This is done by sending and receiving information to/from the process through a third process, called the meta process. You can implement your own attached process. See &lt;code&gt;int.erl&lt;/code&gt; for available functions and &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; for possible messages.</source>
          <target state="translated">Al &lt;strong&gt;adjuntar a&lt;/strong&gt; un proceso que ejecuta c&amp;oacute;digo interpretado, es posible examinar los enlaces de variables y ordenar la ejecuci&amp;oacute;n paso a paso. Esto se hace enviando y recibiendo informaci&amp;oacute;n hacia / desde el proceso a trav&amp;eacute;s de un tercer proceso, llamado metaproceso. Puede implementar su propio proceso adjunto. Consulte &lt;code&gt;int.erl&lt;/code&gt; para conocer las funciones disponibles y &lt;code&gt;dbg_wx_trace.erl&lt;/code&gt; para ver posibles mensajes.</target>
        </trans-unit>
        <trans-unit id="5e25689214717ab6f387eff1ce87fefe79882799" translate="yes" xml:space="preserve">
          <source>By SASL reports we mean supervisor reports, crash reports and progress reports.</source>
          <target state="translated">Por informes SASL nos referimos a informes de supervisión,informes de accidentes e informes de progreso.</target>
        </trans-unit>
        <trans-unit id="df385cba3294f848291c72e2a88cfe1519f5944b" translate="yes" xml:space="preserve">
          <source>By being able to determine when the first event above has occurred we can easily know when all managed threads have completed accesses to a data structure. This can be determined the following way. We have an implementation of some functionality &lt;code&gt;F&lt;/code&gt; using a data structure &lt;code&gt;D&lt;/code&gt;. The reference to &lt;code&gt;D&lt;/code&gt; is always looked up before &lt;code&gt;D&lt;/code&gt; is being accessed, and the references to &lt;code&gt;D&lt;/code&gt; is always dropped before we leave the code implementing &lt;code&gt;F&lt;/code&gt;. If we remove the possibility to look up &lt;code&gt;D&lt;/code&gt; and then wait until the first event has occurred in all managed threads, no managed threads can have any references to the data structure &lt;code&gt;D&lt;/code&gt;. This could for example have been achieved by using reference counting, but the cache line containing the reference counter would in this case be ping ponged between all processors accessing &lt;code&gt;D&lt;/code&gt; at every access.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="524b3185d88f75bd50294ceb9e69a53458ed7610" translate="yes" xml:space="preserve">
          <source>By being able to determine when the second event has occurred it is quite easy to do complex modifications of memory that needs to be seen consistently by other threads without having to resort to locking. By doing the modifications, then issuing a full memory barrier, then wait until the second event has occurred in all managed threads, and then publish the modifications, we know that all managed threads reading this memory will get a consistent view of the modifications. Managed threads reading this will not have to issue any extra memory barriers at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61329f5b77a1e8f4de56300ae6baa6480eff0a5f" translate="yes" xml:space="preserve">
          <source>By calling &lt;code&gt;blend/2&lt;/code&gt; on any color term created by &lt;code&gt;new/4&lt;/code&gt;, the resulting color can be calculated as determined by the two map terms.</source>
          <target state="translated">Al llamar a &lt;code&gt;blend/2&lt;/code&gt; en cualquier t&amp;eacute;rmino de color creado por &lt;code&gt;new/4&lt;/code&gt; , el color resultante se puede calcular seg&amp;uacute;n lo determinado por los dos t&amp;eacute;rminos del mapa.</target>
        </trans-unit>
        <trans-unit id="6e21b8bafe38feea973da163115371fd334e57e8" translate="yes" xml:space="preserve">
          <source>By calling function &lt;code&gt;info/0&lt;/code&gt; in a generated module, you get information about which compiler options were used.</source>
          <target state="translated">Al llamar a la funci&amp;oacute;n &lt;code&gt;info/0&lt;/code&gt; en un m&amp;oacute;dulo generado, obtiene informaci&amp;oacute;n sobre las opciones del compilador que se utilizaron.</target>
        </trans-unit>
        <trans-unit id="817528d15c927d91ed8c4901f6bd96f0b70a6a47" translate="yes" xml:space="preserve">
          <source>By clicking the name in the column header of any table (for example, &quot;Ok&quot;, &quot;Case&quot;, &quot;Time&quot;, and so on), the table rows are sorted in whatever order makes sense for the type of value (for example, numerical for &quot;Ok&quot; or &quot;Time&quot;, and alphabetical for &quot;Case&quot;). The sorting is performed through JavaScript code, automatically inserted into the HTML log files. &lt;code&gt;Common Test&lt;/code&gt; uses the &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; library and the &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; plugin, with customized sorting functions, for this implementation.</source>
          <target state="translated">Al hacer clic en el nombre en el encabezado de la columna de cualquier tabla (por ejemplo, &quot;Ok&quot;, &quot;Caso&quot;, &quot;Hora&quot;, etc.), las filas de la tabla se ordenan en el orden que tenga sentido para el tipo de valor (por ejemplo , num&amp;eacute;rico para &quot;Ok&quot; o &quot;Hora&quot;, y alfab&amp;eacute;tico para &quot;Caso&quot;). La clasificaci&amp;oacute;n se realiza mediante c&amp;oacute;digo JavaScript, que se inserta autom&amp;aacute;ticamente en los archivos de registro HTML. &lt;code&gt;Common Test&lt;/code&gt; utiliza la biblioteca &lt;code&gt;&lt;a href=&quot;http://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; y el complemento &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; , con funciones de clasificaci&amp;oacute;n personalizadas, para esta implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="0a6c1fc3876db3765bb6b4c92b2fa0963dbbc1e8" translate="yes" xml:space="preserve">
          <source>By clicking the name in the column header of any table (for example, &quot;Ok&quot;, &quot;Case&quot;, &quot;Time&quot;, and so on), the table rows are sorted in whatever order makes sense for the type of value (for example, numerical for &quot;Ok&quot; or &quot;Time&quot;, and alphabetical for &quot;Case&quot;). The sorting is performed through JavaScript code, automatically inserted into the HTML log files. &lt;code&gt;Common Test&lt;/code&gt; uses the &lt;code&gt;&lt;a href=&quot;https://jquery.com&quot;&gt;jQuery&lt;/a&gt;&lt;/code&gt; library and the &lt;code&gt;&lt;a href=&quot;http://tablesorter.com&quot;&gt;tablesorter&lt;/a&gt;&lt;/code&gt; plugin, with customized sorting functions, for this implementation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ea0e955d25fd75ff5b4bf677527caab934dbed9" translate="yes" xml:space="preserve">
          <source>By combining the modifications of the process state management and the run queue management, we can do large parts of the work involved when managing processes with regards to scheduling and migration without having any locks locked at all. In these situations we previously had to have multiple locks locked. This of course caused a lot of rewrites across large parts of the runtime system, but the rewrite both simplified code and eliminated locking at a number of places. The major benefit is, of course, reduced contention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e3f09bd43c71064511228990649461289b5c148" translate="yes" xml:space="preserve">
          <source>By configuration, you can also modify or disable the default handler, replace it by a custom handler, and install additional handlers.</source>
          <target state="translated">Mediante la configuración,también puedes modificar o desactivar el manejador predeterminado,reemplazarlo por un manejador personalizado e instalar manejadores adicionales.</target>
        </trans-unit>
        <trans-unit id="65dc91babe6148c48d235004a31fddc4c1120398" translate="yes" xml:space="preserve">
          <source>By convention, most Built-In Functions (BIFs) are included in this module. Some of the BIFs are viewed more or less as part of the Erlang programming language and are &lt;strong&gt;auto-imported&lt;/strong&gt;. Thus, it is not necessary to specify the module name. For example, the calls &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; and &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; are identical.</source>
          <target state="translated">Por convenci&amp;oacute;n, la mayor&amp;iacute;a de las funciones integradas (BIF) se incluyen en este m&amp;oacute;dulo. Algunos de los BIF se consideran m&amp;aacute;s o menos como parte del lenguaje de programaci&amp;oacute;n Erlang y se importan &lt;strong&gt;autom&amp;aacute;ticamente&lt;/strong&gt; . Por tanto, no es necesario especificar el nombre del m&amp;oacute;dulo. Por ejemplo, las llamadas &lt;code&gt;atom_to_list(erlang)&lt;/code&gt; y &lt;code&gt;erlang:atom_to_list(erlang)&lt;/code&gt; son id&amp;eacute;nticas.</target>
        </trans-unit>
        <trans-unit id="082c66d79fe52cb570696433b4792152063b55b2" translate="yes" xml:space="preserve">
          <source>By convention, the name of a tar file is to end in &quot;&lt;code&gt;.tar&lt;/code&gt;&quot;. To abide to the convention, add &quot;&lt;code&gt;.tar&lt;/code&gt;&quot; to the name.</source>
          <target state="translated">Por convenci&amp;oacute;n, el nombre de un archivo tar debe terminar en &quot; &lt;code&gt;.tar&lt;/code&gt; &quot;. Para cumplir con la convenci&amp;oacute;n, agregue &quot; &lt;code&gt;.tar&lt;/code&gt; &quot; al nombre.</target>
        </trans-unit>
        <trans-unit id="e51e93220df3f4bd5dc8a32795232ab13e7f0c15" translate="yes" xml:space="preserve">
          <source>By convention, the name of a zip file is to end with &lt;code&gt;.zip&lt;/code&gt;. To abide to the convention, add &lt;code&gt;.zip&lt;/code&gt; to the filename.</source>
          <target state="translated">Por convenci&amp;oacute;n, el nombre de un archivo zip debe terminar en &lt;code&gt;.zip&lt;/code&gt; . Para cumplir con la convenci&amp;oacute;n, agregue &lt;code&gt;.zip&lt;/code&gt; al nombre del archivo.</target>
        </trans-unit>
        <trans-unit id="458ef8621b4f7c4ee2bf42d5b9e1f263171a21fb" translate="yes" xml:space="preserve">
          <source>By default 16 files are merged at a time. This option is rarely needed.</source>
          <target state="translated">Por defecto,se fusionan 16 archivos a la vez.Esta opción rara vez es necesaria.</target>
        </trans-unit>
        <trans-unit id="f916c5ec73659e63b033b011cdae7b63d48ef9e3" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Mnesia&lt;/code&gt; either dumps the log whenever 100 records have been written in the log or when three minutes have passed. This is controlled by the two application parameters &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; and &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;Mnesia&lt;/code&gt; descarga el registro cada vez que se han escrito 100 registros en el registro o cuando han pasado tres minutos. Esto est&amp;aacute; controlado por los dos par&amp;aacute;metros de la aplicaci&amp;oacute;n &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; y &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f74ee3ee744473dfcdc8d613d9c22514ab7711d7" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;Mnesia&lt;/code&gt; either dumps the log whenever 1000 records have been written in the log or when three minutes have passed. This is controlled by the two application parameters &lt;code&gt;-mnesia dump_log_write_threshold WriteOperations&lt;/code&gt; and &lt;code&gt;-mnesia dump_log_time_threshold MilliSecs&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1b4d9f0f830cdbeba0bff6368aca7f38a671867" translate="yes" xml:space="preserve">
          <source>By default &lt;code&gt;ei&lt;/code&gt; supplies a TCP/IPv4 socket interface that is used when communicating. The user can however plug in his/her own IPv4 socket implementation. This, for example, in order to communicate over TLS. A user supplied socket implementation is plugged in by passing a &lt;code&gt;&lt;a href=&quot;#ei_socket_callbacks&quot;&gt;callback structure&lt;/a&gt;&lt;/code&gt; to either &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_init_ussi()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#ei_connect_init&quot;&gt;ei_connect_xinit_ussi()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e33f74e5fe8c2a189ae75982a8ae0619e585aa16" translate="yes" xml:space="preserve">
          <source>By default SSL/TLS is run over the TCP/IP protocol even though you can plug in any other reliable transport protocol with the same Application Programming Interface (API) as the &lt;code&gt;gen_tcp&lt;/code&gt; module in Kernel. DTLS is by default run over UDP/IP, which means that application data has no delivery guarentees. Other transports, such as SCTP, may be supported in future releases.</source>
          <target state="translated">De forma predeterminada, SSL / TLS se ejecuta sobre el protocolo TCP / IP, aunque puede conectar cualquier otro protocolo de transporte confiable con la misma interfaz de programaci&amp;oacute;n de aplicaciones (API) que el m&amp;oacute;dulo &lt;code&gt;gen_tcp&lt;/code&gt; en el kernel. DTLS se ejecuta de forma predeterminada sobre UDP / IP, lo que significa que los datos de la aplicaci&amp;oacute;n no tienen garant&amp;iacute;as de entrega. Otros transportes, como SCTP, pueden ser compatibles en versiones futuras.</target>
        </trans-unit>
        <trans-unit id="eabed6d7dfce1497434c059489829d94c31442b4" translate="yes" xml:space="preserve">
          <source>By default TLS is run over the TCP/IP protocol even though you can plug in any other reliable transport protocol with the same Application Programming Interface (API) as the &lt;code&gt;gen_tcp&lt;/code&gt; module in Kernel. DTLS is by default run over UDP/IP, which means that application data has no delivery guarentees. Other transports, such as SCTP, may be supported in future releases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55b91f316a10114e643a738ef56cbce119a92d15" translate="yes" xml:space="preserve">
          <source>By default about 512*1024 bytes read from files are sorted internally. This option is rarely needed.</source>
          <target state="translated">Por defecto,unos 512*1024 bytes leídos de los archivos están ordenados internamente.Esta opción es raramente necesaria.</target>
        </trans-unit>
        <trans-unit id="1e8fa96214b81833eb829752ba3cb11f2aac75f4" translate="yes" xml:space="preserve">
          <source>By default in OTP 17, the representation of the &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; types as Erlang terms were changed. &lt;code&gt;BIT STRING&lt;/code&gt; values are now Erlang bit strings and &lt;code&gt;OCTET STRING&lt;/code&gt; values are binaries. Also, an undecoded open type is now wrapped in an &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; tuple. For details, see &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">De forma predeterminada, en OTP 17, se cambi&amp;oacute; la representaci&amp;oacute;n de los tipos &lt;code&gt;BIT STRING&lt;/code&gt; y &lt;code&gt;OCTET STRING&lt;/code&gt; como t&amp;eacute;rminos de Erlang. &lt;code&gt;BIT STRING&lt;/code&gt; valores BIT STRING ahora son cadenas de bits Erlang y los valores &lt;code&gt;OCTET STRING&lt;/code&gt; son binarios. Adem&amp;aacute;s, un tipo abierto no &lt;code&gt;asn1_OPENTYPE&lt;/code&gt; ahora est&amp;aacute; envuelto en una tupla asn1_OPENTYPE . Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;code&gt;&lt;a href=&quot;asn1_getting_started#Information%20Object&quot;&gt;ASN.1 Information Objects&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;asn1_getting_started#BIT%20STRING&quot;&gt;BIT STRING&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;asn1_getting_started#OCTET%20STRING&quot;&gt;OCTET STRING&lt;/a&gt;&lt;/code&gt; y ASN.1 en la Gu&amp;iacute;a del usuario.</target>
        </trans-unit>
        <trans-unit id="9dc86d1dada42ddb164640d0be1c9cd268646f6a" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be.</source>
          <target state="translated">Por defecto no está incluido,pero si esta opción está presente lo estará.</target>
        </trans-unit>
        <trans-unit id="c97804b0eee285b037a2d076e7ba516d0e16e389" translate="yes" xml:space="preserve">
          <source>By default it is not included, but if this option is present it will be. The reference text will be placed in the allocList field of the mib-entry record (#me{}) for the table.</source>
          <target state="translated">Por defecto no está incluido,pero si esta opción está presente lo estará.El texto de referencia se colocará en el campo allocList del registro mib-entry (#me{})para la tabla.</target>
        </trans-unit>
        <trans-unit id="a4cb7bdb00bc5f4f34ca644e957ab5ac212ab81d" translate="yes" xml:space="preserve">
          <source>By default on such systems, Erlang starts in &lt;code&gt;utf8&lt;/code&gt; filename mode if the terminal supports UTF-8, otherwise in &lt;code&gt;latin1&lt;/code&gt; mode.</source>
          <target state="translated">De forma predeterminada en tales sistemas, Erlang se inicia en el modo de nombre de archivo &lt;code&gt;utf8&lt;/code&gt; si el terminal admite UTF-8, de lo contrario, en el modo &lt;code&gt;latin1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="66001038963df69c701cdea04de30818e23ced2f" translate="yes" xml:space="preserve">
          <source>By default only the running target is available, unless the server includes &lt;code&gt;:candidate&lt;/code&gt; or &lt;code&gt;:startup&lt;/code&gt; in its list of capabilities.</source>
          <target state="translated">De forma predeterminada, solo est&amp;aacute; disponible el destino en ejecuci&amp;oacute;n, a menos que el servidor incluya &lt;code&gt;:candidate&lt;/code&gt; o &lt;code&gt;:startup&lt;/code&gt; en su lista de capacidades.</target>
        </trans-unit>
        <trans-unit id="b1f41b809750734c802dac0f55be66baad734531" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Application inclusion policy&lt;/code&gt; on system level is used for all applications. Set the value to &lt;code&gt;include&lt;/code&gt; if you want to explicitly include one particular application. Set it to &lt;code&gt;exclude&lt;/code&gt; if you want to exclude the application despite that it is used by another (explicitly or implicitly) included application. &lt;code&gt;derived&lt;/code&gt; means that the application automatically will be included if some other (explicitly or implicitly) included application uses it.</source>
          <target state="translated">De forma predeterminada, la &lt;code&gt;Application inclusion policy&lt;/code&gt; a nivel del sistema se utiliza para todas las aplicaciones. Establezca el valor para &lt;code&gt;include&lt;/code&gt; si desea incluir expl&amp;iacute;citamente una aplicaci&amp;oacute;n en particular. Config&amp;uacute;relo para &lt;code&gt;exclude&lt;/code&gt; si desea excluir la aplicaci&amp;oacute;n a pesar de que sea utilizada por otra aplicaci&amp;oacute;n incluida (expl&amp;iacute;cita o impl&amp;iacute;citamente). &lt;code&gt;derived&lt;/code&gt; significa que la aplicaci&amp;oacute;n se incluir&amp;aacute; autom&amp;aacute;ticamente si alguna otra aplicaci&amp;oacute;n incluida (expl&amp;iacute;cita o impl&amp;iacute;citamente) la usa.</target>
        </trans-unit>
        <trans-unit id="3bb33b9d4c2d5314003279505372f2bd591c4469" translate="yes" xml:space="preserve">
          <source>By default the &lt;code&gt;Module inclusion policy&lt;/code&gt; on system level is used for all applications. Set it to &lt;code&gt;derived&lt;/code&gt; if you only want actually used modules to be included. Set it to &lt;code&gt;app&lt;/code&gt; if you, besides derived modules, also want the modules listed in the app file to be included. Set it to &lt;code&gt;ebin&lt;/code&gt; if you, besides derived modules, also want the modules that exist as beam files in the ebin directory to be included. Set it to &lt;code&gt;all&lt;/code&gt; if you want all modules to be included, that is the union of modules found in the ebin directory and listed in the app file.</source>
          <target state="translated">De forma predeterminada, la &lt;code&gt;Module inclusion policy&lt;/code&gt; a nivel del sistema se utiliza para todas las aplicaciones. Config&amp;uacute;relo como &lt;code&gt;derived&lt;/code&gt; si solo desea que se incluyan los m&amp;oacute;dulos realmente utilizados. Config&amp;uacute;relo como &lt;code&gt;app&lt;/code&gt; si, adem&amp;aacute;s de los m&amp;oacute;dulos derivados, tambi&amp;eacute;n desea que se incluyan los m&amp;oacute;dulos enumerados en el archivo de la aplicaci&amp;oacute;n. &lt;code&gt;ebin&lt;/code&gt; en ebin si, adem&amp;aacute;s de los m&amp;oacute;dulos derivados, tambi&amp;eacute;n desea que se incluyan los m&amp;oacute;dulos que existen como archivos de haz en el directorio ebin. Config&amp;uacute;relo en &lt;code&gt;all&lt;/code&gt; si desea que se incluyan todos los m&amp;oacute;dulos, es decir, la uni&amp;oacute;n de m&amp;oacute;dulos que se encuentran en el directorio ebin y se enumeran en el archivo de la aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="81c493b42c1c2d3836dadd1b1f65d1b4066bbbb2" translate="yes" xml:space="preserve">
          <source>By default the EPMD listens on port 4369.</source>
          <target state="translated">Por defecto,el EPMD escucha en el puerto 4369.</target>
        </trans-unit>
        <trans-unit id="60c9fed0b81fb4b980269d86433bdb1dec183e3e" translate="yes" xml:space="preserve">
          <source>By default the TLS/DTLS clients try to reuse an available session and by default the TLS/DTLS servers agree to reuse sessions when clients ask for it.</source>
          <target state="translated">Por defecto,los clientes TLS/DTLS intentan reutilizar una sesión disponible y por defecto los servidores TLS/DTLS aceptan reutilizar las sesiones cuando los clientes lo solicitan.</target>
        </trans-unit>
        <trans-unit id="81d8c9fb8831024a08c4d93b4cdac4bc82433614" translate="yes" xml:space="preserve">
          <source>By default the TLS/DTLS clients try to reuse an available session and by default the TLS/DTLS servers agree to reuse sessions when clients ask for it. See also &lt;code&gt; Session Reuse Pre TLS-1.3 &lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40a1d269c0b2f20066064de554ea4fe767edbe1b" translate="yes" xml:space="preserve">
          <source>By default the currently stored events (existing) are written to a brand new file (write) and the events are kept (keep) after they have been written to the file.</source>
          <target state="translated">Por defecto,los eventos almacenados actualmente (existentes)se escriben en un archivo nuevo (escribir)y los eventos se mantienen (guardar)después de haber sido escritos en el archivo.</target>
        </trans-unit>
        <trans-unit id="b301155fe91b7f29a76df23651c02320368fef48" translate="yes" xml:space="preserve">
          <source>By default the flex scanner reports line-number of an error. But it can be built without line-number reporting. Instead token number is used. This will speed up the scanning some 5-10%. Use &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; when configuring the application.</source>
          <target state="translated">De forma predeterminada, el esc&amp;aacute;ner flexible informa el n&amp;uacute;mero de l&amp;iacute;nea de un error. Pero se puede construir sin informes de n&amp;uacute;meros de l&amp;iacute;nea. En su lugar, se utiliza el n&amp;uacute;mero de token. Esto acelerar&amp;aacute; el escaneo entre un 5% y un 10%. Utilice &lt;code&gt;--disable-megaco-flex-scanner-lineno&lt;/code&gt; al configurar la aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c20eaae0e3f3676678ff09602bb8cee954cea155" translate="yes" xml:space="preserve">
          <source>By default the socket options set by function &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; are used when establishing a connection.</source>
          <target state="translated">Por defecto, las opciones de socket establecidas por la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#set_options-1&quot;&gt;set_options/[1,2]&lt;/a&gt;&lt;/code&gt; se utilizan al establecer una conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c911090b3724ca04bd13ed3fc1bce3d52a0723e3" translate="yes" xml:space="preserve">
          <source>By default time correction is enabled if support for it exists on the specific platform. Support for it includes both OS monotonic time, provided by the OS, and an implementation in the Erlang runtime system using OS monotonic time. To check if your system has support for OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt; erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;. To check if time correction is enabled on your system, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt; erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec72fa4eac79a3cc871f1f0e43828e92af1bb91b" translate="yes" xml:space="preserve">
          <source>By default time correction is enabled if support for it exists on the specific platform. Support for it includes both OS monotonic time, provided by the OS, and an implementation in the Erlang runtime system using OS monotonic time. To check if your system has support for OS monotonic time, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt;. To check if time correction is enabled on your system, call &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, la correcci&amp;oacute;n de tiempo est&amp;aacute; habilitada si existe soporte para ella en la plataforma espec&amp;iacute;fica. El soporte incluye tanto el tiempo mon&amp;oacute;tono del sistema operativo, proporcionado por el sistema operativo, como una implementaci&amp;oacute;n en el sistema de ejecuci&amp;oacute;n de Erlang que utiliza el tiempo mon&amp;oacute;tono del sistema operativo. Para comprobar si su sistema es compatible con el tiempo monot&amp;oacute;nico del sistema operativo, llame a &lt;code&gt;&lt;a href=&quot;erlang#system_info_os_monotonic_time_source&quot;&gt;erlang:system_info(os_monotonic_time_source)&lt;/a&gt;&lt;/code&gt; . Para verificar si la correcci&amp;oacute;n de tiempo est&amp;aacute; habilitada en su sistema, llame a &lt;code&gt;&lt;a href=&quot;erlang#system_info_time_correction&quot;&gt;erlang:system_info(time_correction)&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7ceb9ebe7b981aea32343aa2ebada87a65d18c16" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; fetches trace logs and trace information files from all nodes. The logs are stored in a new directory named &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; under the working directory of the trace control node. Fetching can be disabled by providing option &lt;code&gt;nofetch&lt;/code&gt; to &lt;code&gt;ttb:stop/1&lt;/code&gt;. The user can specify a fetch directory by passing option &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;&lt;a href=&quot;ttb#stop-1&quot;&gt;ttb:stop/1&lt;/a&gt;&lt;/code&gt; obtiene registros de seguimiento y archivos de informaci&amp;oacute;n de seguimiento de todos los nodos. Los registros se almacenan en un nuevo directorio llamado &lt;code&gt;ttb_upload-Filename-Timestamp&lt;/code&gt; bajo el directorio de trabajo del nodo de control de seguimiento. La recuperaci&amp;oacute;n se puede desactivar proporcionando la opci&amp;oacute;n &lt;code&gt;nofetch&lt;/code&gt; a &lt;code&gt;ttb:stop/1&lt;/code&gt; . El usuario puede especificar un directorio de recuperaci&amp;oacute;n pasando la opci&amp;oacute;n &lt;code&gt;{fetch_dir, Dir}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e28d91aead7c4c840b960191290c3223a7f6126a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Char&lt;/code&gt; is &lt;code&gt;$\s&lt;/code&gt; and &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;trailing&lt;/code&gt;.</source>
          <target state="translated">Por defecto, &lt;code&gt;Char&lt;/code&gt; es &lt;code&gt;$\s&lt;/code&gt; y &lt;code&gt;Dir&lt;/code&gt; se &lt;code&gt;trailing&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="071766231ebcbb0e6dd0a89742db95d7cd2d08e3" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Common Test&lt;/code&gt; creates one central private directory per test run, shared by all test cases. This is not always suitable. Especially if the same test cases are executed multiple times during a test run (that is, if they belong to a test case group with property &lt;code&gt;repeat&lt;/code&gt;) and there is a risk that files in the private directory get overwritten. Under these circumstances, &lt;code&gt;Common Test&lt;/code&gt; can be configured to create one dedicated private directory per test case and execution instead. This is accomplished with the flag/option &lt;code&gt;create_priv_dir&lt;/code&gt; (to be used with the &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; program, the &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; function, or as test specification term). There are three possible values for this option as follows:</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;Common Test&lt;/code&gt; crea un directorio privado central por ejecuci&amp;oacute;n de prueba, compartido por todos los casos de prueba. Esto no siempre es adecuado. Especialmente si los mismos casos de prueba se ejecutan varias veces durante una ejecuci&amp;oacute;n de prueba (es decir, si pertenecen a un grupo de casos de prueba con &lt;code&gt;repeat&lt;/code&gt; propiedad ) y existe el riesgo de que se sobrescriban los archivos del directorio privado. En estas circunstancias, &lt;code&gt;Common Test&lt;/code&gt; se puede configurar para crear un directorio privado dedicado por caso de prueba y ejecuci&amp;oacute;n en su lugar. Esto se logra con el indicador / opci&amp;oacute;n &lt;code&gt;create_priv_dir&lt;/code&gt; (para ser usado con el programa &lt;code&gt;&lt;a href=&quot;ct_run&quot;&gt;ct_run&lt;/a&gt;&lt;/code&gt; , el &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; funci&amp;oacute;n, o como t&amp;eacute;rmino de especificaci&amp;oacute;n de prueba). Hay tres valores posibles para esta opci&amp;oacute;n de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="bc3169458b9c52d0cd7a98448830679fb2a8731a" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Dir&lt;/code&gt; is &lt;code&gt;leading&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;Dir&lt;/code&gt; est&amp;aacute; a la &lt;code&gt;leading&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="28f74729db7b0c3b278863ef6db06bd5bab6afe7" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;ERTS&lt;/code&gt; is only guaranteed to be compatible with other Erlang/OTP components from the same release as &lt;code&gt;ERTS&lt;/code&gt; itself.</source>
          <target state="translated">De forma predeterminada, solo se garantiza que &lt;code&gt;ERTS&lt;/code&gt; sea ​​compatible con otros componentes de Erlang / OTP de la misma versi&amp;oacute;n que &lt;code&gt;ERTS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4d10644009649e0b88125d8c14d6cdb3379fe167" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;IgnoreCase&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; and &lt;code&gt;Norm&lt;/code&gt; is &lt;code&gt;none&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, &lt;code&gt;IgnoreCase&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; y &lt;code&gt;Norm&lt;/code&gt; es &lt;code&gt;none&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9d6341953fcce030f785b04ed13be99fb6431b5" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;Length&lt;/code&gt; is &lt;code&gt;infinity&lt;/code&gt;.</source>
          <target state="translated">Por defecto, &lt;code&gt;Length&lt;/code&gt; es &lt;code&gt;infinity&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="737dbf79ae1fa944f9b53b6e9f296655a6f7aa71" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;relup&lt;/code&gt; file is located in the current working directory. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, the &lt;code&gt;relup&lt;/code&gt; file is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">De forma predeterminada, el archivo de &lt;code&gt;relup&lt;/code&gt; se encuentra en el directorio de trabajo actual. Si se especifica la opci&amp;oacute;n &lt;code&gt;{outdir,Dir}&lt;/code&gt; , el archivo de &lt;code&gt;relup&lt;/code&gt; se encuentra en &lt;code&gt;Dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e5740833bc9a00277b2eef37e4a06e9efa51635" translate="yes" xml:space="preserve">
          <source>By default, &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; is returned if no information about the initial call can be found. It is assumed that the caller knows that the process has been spawned with the &lt;code&gt;proc_lib&lt;/code&gt; module.</source>
          <target state="translated">De forma predeterminada, se &lt;code&gt;{proc_lib,init_p,5}&lt;/code&gt; si no se puede encontrar informaci&amp;oacute;n sobre la llamada inicial. Se supone que la persona que llama sabe que el proceso se ha generado con el m&amp;oacute;dulo &lt;code&gt;proc_lib&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a09da640fbd6b16e4c97f30cbf385b23a15ab05" translate="yes" xml:space="preserve">
          <source>By default, Debugger only saves information about recursive function calls, that is, function calls that have not yet returned a value (option &lt;strong&gt;Stack On, No Tail&lt;/strong&gt;).</source>
          <target state="translated">De forma predeterminada, Debugger solo guarda informaci&amp;oacute;n sobre llamadas de funci&amp;oacute;n recursivas, es decir, llamadas de funci&amp;oacute;n que a&amp;uacute;n no han devuelto un valor (opci&amp;oacute;n &lt;strong&gt;Stack On, No Tail&lt;/strong&gt; ).</target>
        </trans-unit>
        <trans-unit id="cb83760fc1df1215ce919183bfc30967f2391d71" translate="yes" xml:space="preserve">
          <source>By default, Dialyzer caches the results of native compilation in directory &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt;. &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; defaults to &lt;code&gt;$HOME/.cache&lt;/code&gt;. Use this option to disable caching.</source>
          <target state="translated">De forma predeterminada, Dialyzer almacena en cach&amp;eacute; los resultados de la compilaci&amp;oacute;n nativa en el directorio &lt;code&gt;$XDG_CACHE_HOME/erlang/dialyzer_hipe_cache&lt;/code&gt; . &lt;code&gt;XDG_CACHE_HOME&lt;/code&gt; tiene como valor predeterminado &lt;code&gt;$HOME/.cache&lt;/code&gt; . Utilice esta opci&amp;oacute;n para deshabilitar el almacenamiento en cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="ca501566661fba6186a204103ba54062fe33920b" translate="yes" xml:space="preserve">
          <source>By default, Erlang is started so that only the &lt;code&gt;latin1&lt;/code&gt; range of characters indicate that a list of integers is a string.</source>
          <target state="translated">Por defecto, Erlang se inicia para que solo el rango de caracteres &lt;code&gt;latin1&lt;/code&gt; indique que una lista de enteros es una cadena.</target>
        </trans-unit>
        <trans-unit id="600a9af71026fcfac59ffff3d502bc67475337e3" translate="yes" xml:space="preserve">
          <source>By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the &lt;code&gt;+pc unicode&lt;/code&gt; flag can be used to change this (see &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt; printable_range/0&lt;/a&gt;&lt;/code&gt; for details). For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a82754162a45a0d73de414ecadee9a7ddca8c1b" translate="yes" xml:space="preserve">
          <source>By default, Erlang only detects lists of characters in the Latin-1 range as strings, but the &lt;code&gt;+pc unicode&lt;/code&gt; flag can be used to change this (see &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; for details). For example:</source>
          <target state="translated">De forma predeterminada, Erlang solo detecta listas de caracteres en el rango Latin-1 como cadenas, pero la bandera &lt;code&gt;+pc unicode&lt;/code&gt; se puede usar para cambiar esto (vea &lt;code&gt;&lt;a href=&quot;#printable_range-0&quot;&gt;printable_range/0&lt;/a&gt;&lt;/code&gt; para m&amp;aacute;s detalles). Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="ddfb5846cc6e75b4d26cdc33d2870cc55885837f" translate="yes" xml:space="preserve">
          <source>By default, Erlang/OTP release will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. If you for instance don't have the permission to install in the standard location, you can install Erlang/OTP somewhere else. For example, to install in &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt;, use the &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; option.</source>
          <target state="translated">De forma predeterminada, la versi&amp;oacute;n de Erlang / OTP se instalar&amp;aacute; en &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt; . Si, por ejemplo, no tiene permiso para instalar en la ubicaci&amp;oacute;n est&amp;aacute;ndar, puede instalar Erlang / OTP en otro lugar. Por ejemplo, para instalar en &lt;code&gt;/opt/erlang/21.0/{bin,lib/erlang}&lt;/code&gt; , use la &lt;code&gt;--prefix=/opt/erlang/21.0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="97faf8e4ee820690a95a2f9c0c26ec78fc837744" translate="yes" xml:space="preserve">
          <source>By default, Erlang/OTP release will be installed in &lt;code&gt;/usr/local/{bin,lib/erlang}&lt;/code&gt;. If you for instance don't have the permission to install in the standard location, you can install Erlang/OTP somewhere else. For example, to install in &lt;code&gt;/opt/erlang/23.2/{bin,lib/erlang}&lt;/code&gt;, use the &lt;code&gt;--prefix=/opt/erlang/23.2&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="449ac9961843b5846b7c02a09a67a56c7a856de8" translate="yes" xml:space="preserve">
          <source>By default, PCRE treats the subject string as consisting of a single line of characters (even if it contains newlines). The &quot;start of line&quot; metacharacter (&lt;code&gt;^&lt;/code&gt;) matches only at the start of the string, while the &quot;end of line&quot; metacharacter (&lt;code&gt;$&lt;/code&gt;) matches only at the end of the string, or before a terminating newline (unless option &lt;code&gt;dollar_endonly&lt;/code&gt; is specified). This is the same as in Perl.</source>
          <target state="translated">De forma predeterminada, PCRE trata la cadena de asunto como si constara de una sola l&amp;iacute;nea de caracteres (incluso si contiene nuevas l&amp;iacute;neas). El metacar&amp;aacute;cter de &quot;inicio de l&amp;iacute;nea&quot; ( &lt;code&gt;^&lt;/code&gt; ) coincide solo al principio de la cadena, mientras que el metacar&amp;aacute;cter de &quot;final de l&amp;iacute;nea&quot; ( &lt;code&gt;$&lt;/code&gt; ) coincide solo al final de la cadena, o antes de un salto de l&amp;iacute;nea final (a menos que se especifique la opci&amp;oacute;n &lt;code&gt;dollar_endonly&lt;/code&gt; ). Esto es lo mismo que en Perl.</target>
        </trans-unit>
        <trans-unit id="c5979203f447d5bf52653ed357687aa3ce1b0b5f" translate="yes" xml:space="preserve">
          <source>By default, a breakpoint is active, has trigger action &lt;code&gt;enable&lt;/code&gt;, and has no associated condition. For details about breakpoints, see the User's Guide.</source>
          <target state="translated">De forma predeterminada, un punto de interrupci&amp;oacute;n est&amp;aacute; activo, tiene &lt;code&gt;enable&lt;/code&gt; acci&amp;oacute;n de disparo y no tiene ninguna condici&amp;oacute;n asociada. Para obtener detalles sobre los puntos de interrupci&amp;oacute;n, consulte la Gu&amp;iacute;a del usuario.</target>
        </trans-unit>
        <trans-unit id="e107c7882dfb4fe6b976132714721e9f7743401c" translate="yes" xml:space="preserve">
          <source>By default, a filter with the content: &lt;code&gt;#{family =&amp;gt; default, flags =&amp;gt; any}&lt;/code&gt; is used. This will return all interfaces with adresses in the &lt;code&gt;inet&lt;/code&gt; and &lt;code&gt;inet6&lt;/code&gt; families.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ce5b679d831561af8a791cf34b427a861410973" translate="yes" xml:space="preserve">
          <source>By default, a name must be unique within a pattern, but this constraint can be relaxed by setting option &lt;code&gt;dupnames&lt;/code&gt; at compile time. (Duplicate names are also always permitted for subpatterns with the same number, set up as described in the previous section.) Duplicate names can be useful for patterns where only one instance of the named parentheses can match. Suppose that you want to match the name of a weekday, either as a 3-letter abbreviation or as the full name, and in both cases you want to extract the abbreviation. The following pattern (ignoring the line breaks) does the job:</source>
          <target state="translated">Por defecto, un nombre debe ser &amp;uacute;nico dentro de un patr&amp;oacute;n, pero esta restricci&amp;oacute;n se puede relajar estableciendo la opci&amp;oacute;n &lt;code&gt;dupnames&lt;/code&gt; en el momento de la compilaci&amp;oacute;n. (Los nombres duplicados tambi&amp;eacute;n se permiten siempre para subpatrones con el mismo n&amp;uacute;mero, configurados como se describe en la secci&amp;oacute;n anterior). Los nombres duplicados pueden ser &amp;uacute;tiles para patrones en los que solo una instancia de los par&amp;eacute;ntesis nombrados puede coincidir. Suponga que desea hacer coincidir el nombre de un d&amp;iacute;a de la semana, ya sea como una abreviatura de 3 letras o como el nombre completo, y en ambos casos desea extraer la abreviatura. El siguiente patr&amp;oacute;n (ignorando los saltos de l&amp;iacute;nea) hace el trabajo:</target>
        </trans-unit>
        <trans-unit id="c874b6a01a35c20ad7535dd46729e15bd7a18206" translate="yes" xml:space="preserve">
          <source>By default, after \x that is not followed by {, from zero to two hexadecimal digits are read (letters can be in upper or lower case). Any number of hexadecimal digits may appear between \x{ and }. If a character other than a hexadecimal digit appears between \x{ and }, or if there is no terminating }, an error occurs.</source>
          <target state="translated">Por defecto,después de \x que no va seguido de {,se leen de cero a dos dígitos hexadecimales (las letras pueden estar en mayúsculas o minúsculas).Cualquier número de dígitos hexadecimales puede aparecer entre \x{y }.Si un carácter que no sea un dígito hexadecimal aparece entre \x{y },o si no hay una terminación },se produce un error.</target>
        </trans-unit>
        <trans-unit id="1911d23f55521707a73b458b73f12a15fc75306a" translate="yes" xml:space="preserve">
          <source>By default, all I/O devices in OTP are set in &lt;code&gt;list&lt;/code&gt; mode. However, the I/O functions can handle any of these modes and so should other, user-written, modules behaving as clients to I/O servers.</source>
          <target state="translated">De forma predeterminada, todos los dispositivos de E / S en OTP est&amp;aacute;n configurados en modo de &lt;code&gt;list&lt;/code&gt; a . Sin embargo, las funciones de E / S pueden manejar cualquiera de estos modos y tambi&amp;eacute;n deber&amp;iacute;an hacerlo otros m&amp;oacute;dulos escritos por el usuario que se comporten como clientes de los servidores de E / S.</target>
        </trans-unit>
        <trans-unit id="6b2f7942ad86f7d74769554cdd60a7505d483c06" translate="yes" xml:space="preserve">
          <source>By default, all NETCONF traffic is logged in one single log file. However, different connections can be logged in separate files. To do this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work, that is, they must be opened with &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, todo el tr&amp;aacute;fico NETCONF se registra en un solo archivo de registro. Sin embargo, se pueden registrar diferentes conexiones en archivos separados. Para hacer esto, use &lt;code&gt;hosts&lt;/code&gt; de opci&amp;oacute;n de gancho y enumere los nombres de los servidores / conexiones que se usar&amp;aacute;n en la suite. Las conexiones deben tener un nombre para que esto funcione, es decir, deben abrirse con &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d82598d7e978ba992edaa523f47e7a8ba20e371c" translate="yes" xml:space="preserve">
          <source>By default, all applications are loaded with permission &lt;code&gt;true&lt;/code&gt; on all nodes. The permission can be configured using the Kernel configuration parameter &lt;code&gt;permissions&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, todas las aplicaciones se cargan con permiso &lt;code&gt;true&lt;/code&gt; en todos los nodos. El permiso se puede configurar mediante los &lt;code&gt;permissions&lt;/code&gt; par&amp;aacute;metro de configuraci&amp;oacute;n del kernel .</target>
        </trans-unit>
        <trans-unit id="5f0f346db1a0fb06831da54e7c60fe03cdae297d" translate="yes" xml:space="preserve">
          <source>By default, all code is compiled in a separate process which is terminated at the end of compilation. However, some tools, like Dialyzer or compilers for other BEAM languages, may already manage their own worker processes and spawning an extra process may slow the compilation down. In such scenarios, you can pass this option to stop the compiler from spawning an additional process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97ad4d1175f0f089a0071483175aa615b421ee54" translate="yes" xml:space="preserve">
          <source>By default, all existing files with the same name as files in the tar file are overwritten. With this option, existing files are not overwriten.</source>
          <target state="translated">Por defecto,se sobrescriben todos los archivos existentes con el mismo nombre que los del archivo tar.Con esta opción,los archivos existentes no se sobrescriben.</target>
        </trans-unit>
        <trans-unit id="7e40750937dae4fae3bc5f70b97a3f2528fbb80b" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the tar file. With this option, only those files are extracted whose names are included in &lt;code&gt;FileList&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, todos los archivos se extraen del archivo tar. Con esta opci&amp;oacute;n, solo se extraen aquellos archivos cuyos nombres est&amp;aacute;n incluidos en &lt;code&gt;FileList&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="88e8684fe917ca09c774ce03048bec7c20dc7976" translate="yes" xml:space="preserve">
          <source>By default, all files are extracted from the zip archive. With option &lt;code&gt;{file_list, FileList}&lt;/code&gt;, function &lt;code&gt;unzip/2&lt;/code&gt; only extracts the files whose names are included in &lt;code&gt;FileList&lt;/code&gt;. The full paths, including the names of all subdirectories within the zip archive, must be specified.</source>
          <target state="translated">De forma predeterminada, todos los archivos se extraen del archivo zip. Con la opci&amp;oacute;n &lt;code&gt;{file_list, FileList}&lt;/code&gt; , la funci&amp;oacute;n &lt;code&gt;unzip/2&lt;/code&gt; solo extrae los archivos cuyos nombres est&amp;aacute;n incluidos en &lt;code&gt;FileList&lt;/code&gt; . Deben especificarse las rutas completas, incluidos los nombres de todos los subdirectorios dentro del archivo zip.</target>
        </trans-unit>
        <trans-unit id="8373c854a1dcafc057dbfa5df0f447eef64bc1ef" translate="yes" xml:space="preserve">
          <source>By default, all files with the same name as files in the zip archive are overwritten. With option &lt;code&gt;keep_old_files&lt;/code&gt; set, function &lt;code&gt;unzip/2&lt;/code&gt; does not overwrite existing files. Notice that even with option &lt;code&gt;memory&lt;/code&gt; specified, which means that no files are overwritten, existing files are excluded from the result.</source>
          <target state="translated">De forma predeterminada, se sobrescriben todos los archivos con el mismo nombre que los archivos del archivo zip. Con la opci&amp;oacute;n &lt;code&gt;keep_old_files&lt;/code&gt; configurada, la funci&amp;oacute;n &lt;code&gt;unzip/2&lt;/code&gt; no sobrescribe los archivos existentes. Tenga en cuenta que incluso con la opci&amp;oacute;n de &lt;code&gt;memory&lt;/code&gt; especificada, lo que significa que no se sobrescriben archivos, los archivos existentes se excluyen del resultado.</target>
        </trans-unit>
        <trans-unit id="6de29fd7730a88164d057863c9dcf72fa1cb3f6c" translate="yes" xml:space="preserve">
          <source>By default, all log events originating from within OTP, except the former so called &quot;SASL reports&quot;, look the same as before.</source>
          <target state="translated">Por defecto,todos los eventos de registro que se originan dentro de la OTP,excepto los primeros llamados &quot;informes SASL&quot;,se ven igual que antes.</target>
        </trans-unit>
        <trans-unit id="2882c6abbebff5ea0f043573bc5ce53ddfde39c3" translate="yes" xml:space="preserve">
          <source>By default, all parts of the string, including the empty strings, are returned from the function, for example:</source>
          <target state="translated">Por defecto,todas las partes de la cadena,incluidas las cadenas vacías,se devuelven de la función,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="74b4b269097f50b433c9602d13038dfa07527232" translate="yes" xml:space="preserve">
          <source>By default, an &lt;code&gt;OCTET STRING&lt;/code&gt; is always represented as an Erlang binary. If the specification has been compiled with option &lt;code&gt;legacy_erlang_types&lt;/code&gt;, the encode functions accept both lists and binaries, and the decode functions decode an &lt;code&gt;OCTET STRING&lt;/code&gt; to a list.</source>
          <target state="translated">De forma predeterminada, una &lt;code&gt;OCTET STRING&lt;/code&gt; siempre se representa como un binario de Erlang. Si la especificaci&amp;oacute;n se ha compilado con la opci&amp;oacute;n &lt;code&gt;legacy_erlang_types&lt;/code&gt; , las funciones de codificaci&amp;oacute;n aceptan tanto listas como binarios, y las funciones de decodificaci&amp;oacute;n decodifican una &lt;code&gt;OCTET STRING&lt;/code&gt; en una lista.</target>
        </trans-unit>
        <trans-unit id="0bac80eb92816a5a88bf3b52b9fd2aacd857eeb1" translate="yes" xml:space="preserve">
          <source>By default, autostart information is stored in a file named &lt;code&gt;ttb_autostart.bin&lt;/code&gt; on each node. If this is not desired (for example, on diskless nodes), a custom module handling autostart information storage and retrieval can be provided by specifying environment variable &lt;code&gt;ttb_autostart_module&lt;/code&gt; for the application Runtime_Tools. The module must respond to the following API:</source>
          <target state="translated">De forma predeterminada, la informaci&amp;oacute;n de &lt;code&gt;ttb_autostart.bin&lt;/code&gt; autom&amp;aacute;tico se almacena en un archivo llamado ttb_autostart.bin en cada nodo. Si esto no se desea (por ejemplo, en nodos sin disco), se puede proporcionar un m&amp;oacute;dulo personalizado que maneje el almacenamiento y la recuperaci&amp;oacute;n de informaci&amp;oacute;n de &lt;code&gt;ttb_autostart_module&lt;/code&gt; especificando la variable de entorno ttb_autostart_module para la aplicaci&amp;oacute;n Runtime_Tools. El m&amp;oacute;dulo debe responder a la siguiente API:</target>
        </trans-unit>
        <trans-unit id="ad25aa21de1694492059b0bfb35caab2d579e0fb" translate="yes" xml:space="preserve">
          <source>By default, characters with values &amp;gt; 255 do not match any of the Posix character classes. However, if option &lt;code&gt;PCRE_UCP&lt;/code&gt; is passed to &lt;code&gt;pcre_compile()&lt;/code&gt;, some of the classes are changed so that Unicode character properties are used. This is achieved by replacing certain Posix classes by other sequences, as follows:</source>
          <target state="translated">De forma predeterminada, los caracteres con valores&amp;gt; 255 no coinciden con ninguna de las clases de caracteres Posix. Sin embargo, si se pasa la opci&amp;oacute;n &lt;code&gt;PCRE_UCP&lt;/code&gt; a &lt;code&gt;pcre_compile()&lt;/code&gt; , algunas de las clases se cambian para que se utilicen las propiedades de los caracteres Unicode. Esto se logra reemplazando ciertas clases Posix por otras secuencias, de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="053346f97801947e69ed842b8b3fec738287fe79" translate="yes" xml:space="preserve">
          <source>By default, data for all Telnet connections is logged in one common file (named &lt;code&gt;default&lt;/code&gt;), which can get messy, for example, if multiple Telnet sessions are running in parallel. Therefore a separate log file can be created for each connection. To configure this, use hook option &lt;code&gt;hosts&lt;/code&gt; and list the names of the servers/connections to be used in the suite. The connections must be named for this to work (see &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">De forma predeterminada, los datos de todas las conexiones Telnet se registran en un archivo com&amp;uacute;n (denominado &lt;code&gt;default&lt;/code&gt; ), lo que puede resultar complicado, por ejemplo, si se ejecutan varias sesiones Telnet en paralelo. Por tanto, se puede crear un archivo de registro independiente para cada conexi&amp;oacute;n. Para configurar esto, use &lt;code&gt;hosts&lt;/code&gt; de opci&amp;oacute;n de gancho y enumere los nombres de los servidores / conexiones que se usar&amp;aacute;n en la suite. Las conexiones deben tener un nombre para que esto funcione (consulte &lt;code&gt;&lt;a href=&quot;#open-1&quot;&gt;ct_telnet:open/1,2,3,4&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="776bbd51980a39359333108981da5fd37cece1a7" translate="yes" xml:space="preserve">
          <source>By default, each CTH installed is executed in the order that they are installed for init calls, and then reversed for end calls. This is not always desired, so &lt;code&gt;Common Test&lt;/code&gt; allows the user to specify a priority for each hook. The priority can either be specified in the CTH function &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; or when installing the hook. The priority specified at installation overrides the priority returned by the CTH.</source>
          <target state="translated">De forma predeterminada, cada CTH instalado se ejecuta en el orden en que se instalan para las llamadas de inicio y luego se invierte para las llamadas finales. Esto no siempre se desea, por lo que &lt;code&gt;Common Test&lt;/code&gt; permite al usuario especificar una prioridad para cada gancho. La prioridad se puede especificar en la funci&amp;oacute;n CTH &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:init-2&quot;&gt;init/2&lt;/a&gt;&lt;/code&gt; o al instalar el gancho. La prioridad especificada en la instalaci&amp;oacute;n anula la prioridad devuelta por CTH.</target>
        </trans-unit>
        <trans-unit id="462e7da9c97e5f027114d96a2306c993c035da8a" translate="yes" xml:space="preserve">
          <source>By default, each installation of a CTH causes a new instance of it to be activated. This can cause problems if you want to override CTHs in test specifications while still having them in the suite information function. The &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; callback exists to address this problem. By returning the same &lt;code&gt;id&lt;/code&gt; in both places, &lt;code&gt;Common Test&lt;/code&gt; knows that this CTH is already installed and does not try to install it again.</source>
          <target state="translated">De forma predeterminada, cada instalaci&amp;oacute;n de un CTH provoca que se active una nueva instancia del mismo. Esto puede causar problemas si desea anular los CTH en las especificaciones de prueba mientras los mantiene en la funci&amp;oacute;n de informaci&amp;oacute;n de la suite. La devoluci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ct_hooks#Module:id-1&quot;&gt;id/1&lt;/a&gt;&lt;/code&gt; llamada id / 1 existe para solucionar este problema. Al devolver la misma &lt;code&gt;id&lt;/code&gt; entificaci&amp;oacute;n en ambos lugares, &lt;code&gt;Common Test&lt;/code&gt; sabe que este CTH ya est&amp;aacute; instalado y no intenta instalarlo nuevamente.</target>
        </trans-unit>
        <trans-unit id="46480571329f9b5765128d1e4d2b38b49550c0a0" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead either returns &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt;, where &lt;code&gt;Relup&lt;/code&gt; is the release upgrade file, or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, los errores y advertencias se imprimen en tty y la funci&amp;oacute;n devuelve &lt;code&gt;ok&lt;/code&gt; o &lt;code&gt;error&lt;/code&gt; . Si se especifica la opci&amp;oacute;n &lt;code&gt;silent&lt;/code&gt; , la funci&amp;oacute;n en cambio devuelve &lt;code&gt;{ok,Relup,Module,Warnings}&lt;/code&gt; , donde &lt;code&gt;Relup&lt;/code&gt; es el archivo de actualizaci&amp;oacute;n de la versi&amp;oacute;n, o &lt;code&gt;{error,Module,Error}&lt;/code&gt; . Las advertencias y los errores se pueden convertir en cadenas llamando al &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; o al &lt;code&gt;Module:format_error(Error)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="294052fb58119cdee244d014d8cb85f8f3d4b24a" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;silent&lt;/code&gt; is specified, the function instead returns &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, los errores y advertencias se imprimen en tty y la funci&amp;oacute;n devuelve &lt;code&gt;ok&lt;/code&gt; o &lt;code&gt;error&lt;/code&gt; . Si se especifica la opci&amp;oacute;n &lt;code&gt;silent&lt;/code&gt; , la funci&amp;oacute;n devuelve &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; o &lt;code&gt;{error,Module,Error}&lt;/code&gt; . Las advertencias y los errores se pueden convertir en cadenas llamando al &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; o al &lt;code&gt;Module:format_error(Error)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b92da4aa5277f398cb7d427508ed2a69567e18a" translate="yes" xml:space="preserve">
          <source>By default, errors and warnings are printed to tty and the function returns &lt;code&gt;ok&lt;/code&gt; or &lt;code&gt;error&lt;/code&gt;. If option &lt;code&gt;{ok,Module,Warnings}&lt;/code&gt; or &lt;code&gt;{error,Module,Error}&lt;/code&gt;. &lt;code&gt;silent&lt;/code&gt; is specified, the function instead returns Warnings and errors can be converted to strings by calling &lt;code&gt;Module:format_warning(Warnings)&lt;/code&gt; or &lt;code&gt;Module:format_error(Error)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee3c67a77746a67e2bb8398f5d758b0ceca821c3" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; function opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">Por defecto, la funci&amp;oacute;n &lt;code&gt;open/2&lt;/code&gt; abre el archivo tar en modo &lt;code&gt;raw&lt;/code&gt; , que es m&amp;aacute;s r&amp;aacute;pido pero no permite utilizar un servidor de archivos remoto (Erlang). Agregar &lt;code&gt;cooked&lt;/code&gt; a la lista de modos anula el predeterminado y abre el archivo tar sin la opci&amp;oacute;n &lt;code&gt;raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c31b08201db8e452376ac550216866c4f0213c87" translate="yes" xml:space="preserve">
          <source>By default, function &lt;code&gt;open/2&lt;/code&gt; opens the tar file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, la funci&amp;oacute;n &lt;code&gt;open/2&lt;/code&gt; abre el archivo tar en modo &lt;code&gt;raw&lt;/code&gt; , que es m&amp;aacute;s r&amp;aacute;pido pero no permite utilizar un servidor de archivos remoto (Erlang). Agregar &lt;code&gt;cooked&lt;/code&gt; a la lista de modos anula el predeterminado y abre el archivo tar sin la opci&amp;oacute;n &lt;code&gt;raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4c4fa6e3241b3f16b2494ba76c92a8e6751097f9" translate="yes" xml:space="preserve">
          <source>By default, if any requested chunk is missing in &lt;code&gt;Beam&lt;/code&gt;, an &lt;code&gt;error&lt;/code&gt; tuple is returned. However, if option &lt;code&gt;allow_missing_chunks&lt;/code&gt; is specified, a result is returned even if chunks are missing. In the result list, any missing chunks are represented as &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt;. Notice however that if chunk &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; is missing, that is considered a fatal error and the return value is an &lt;code&gt;error&lt;/code&gt; tuple.</source>
          <target state="translated">De forma predeterminada, si falta alg&amp;uacute;n fragmento solicitado en &lt;code&gt;Beam&lt;/code&gt; , se devuelve una tupla de &lt;code&gt;error&lt;/code&gt; . Sin embargo, si se especifica la opci&amp;oacute;n &lt;code&gt;allow_missing_chunks&lt;/code&gt; , se devuelve un resultado incluso si faltan fragmentos. En la lista de resultados, los fragmentos que faltan se representan como &lt;code&gt;{ChunkRef,missing_chunk}&lt;/code&gt; . Sin embargo , tenga en cuenta que si falta el fragmento &lt;code&gt;&quot;Atom&quot;&lt;/code&gt; , se considera un error fatal y el valor de retorno es una tupla de &lt;code&gt;error&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6f53b57e48d13ba35bc616bbd211c0e3f61e0177" translate="yes" xml:space="preserve">
          <source>By default, in &lt;code&gt;unicode&lt;/code&gt; mode, characters with values &amp;gt; 255, that is, all characters outside the ISO Latin-1 character set, never match \d, \s, or \w, and always match \D, \S, and \W. These sequences retain their original meanings from before UTF support was available, mainly for efficiency reasons. However, if option &lt;code&gt;ucp&lt;/code&gt; is set, the behavior is changed so that Unicode properties are used to determine character types, as follows:</source>
          <target state="translated">De forma predeterminada, en el modo &lt;code&gt;unicode&lt;/code&gt; , los caracteres con valores&amp;gt; 255, es decir, todos los caracteres fuera del conjunto de caracteres ISO Latin-1, nunca coinciden con \ d, \ s o \ w, y siempre coinciden con \ D, \ S y \ W. Estas secuencias conservan sus significados originales antes de que el soporte UTF estuviera disponible, principalmente por razones de eficiencia. Sin embargo, si se establece la opci&amp;oacute;n &lt;code&gt;ucp&lt;/code&gt; , el comportamiento se cambia para que las propiedades Unicode se utilicen para determinar los tipos de caracteres, de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="8dce2b9977241b689bc8a7cc79ba1876582a372f" translate="yes" xml:space="preserve">
          <source>By default, symbolic links are stored as symbolic links in the tar file. To override the default and store the file that the symbolic link points to into the tar file, use option &lt;code&gt;dereference&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, los enlaces simb&amp;oacute;licos se almacenan como enlaces simb&amp;oacute;licos en el archivo tar. Para anular el valor predeterminado y almacenar el archivo al que apunta el enlace simb&amp;oacute;lico en el archivo tar, use la opci&amp;oacute;n &lt;code&gt;dereference&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="307631df678df3363024a8553c6845aa25ac4dbc" translate="yes" xml:space="preserve">
          <source>By default, that lock is at the driver level, that is, if several ports have been opened to the same driver, only code for one port at the same time can be running.</source>
          <target state="translated">Por defecto,ese bloqueo está a nivel del controlador,es decir,si se han abierto varios puertos para el mismo controlador,sólo se puede ejecutar el código de un puerto al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="59ef4e65d1c06e09a6d712a392cd376d76f7e30c" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; libraries are only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, solo se garantiza que las bibliotecas &lt;code&gt;Erl_Interface&lt;/code&gt; sean compatibles con otros componentes Erlang / OTP de la misma versi&amp;oacute;n que las propias bibliotecas. Para obtener informaci&amp;oacute;n sobre c&amp;oacute;mo comunicarse con los componentes de Erlang / OTP de versiones anteriores, consulte la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt;ei:ei_set_compat_rel&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;erl_eterm#erl_set_compat_rel&quot;&gt;erl_eterm:erl_set_compat_rel&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="de70cb5ed283df211d9a60f565e19a6787b411b0" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;Erl_Interface&lt;/code&gt; library itself. For example, &lt;code&gt;Erl_Interface&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">De forma predeterminada, solo se garantiza que la biblioteca &lt;code&gt;Erl_Interface&lt;/code&gt; sea ​​compatible con otros componentes Erlang / OTP de la misma versi&amp;oacute;n que la biblioteca &lt;code&gt;Erl_Interface&lt;/code&gt; . Por ejemplo, &lt;code&gt;Erl_Interface&lt;/code&gt; de Erlang / OTP R10 no es compatible con un emulador de Erlang de Erlang / OTP R9 por defecto.</target>
        </trans-unit>
        <trans-unit id="f1410ec7350e5013f18865c794a36ebbd177c8c8" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;Erl_Interface&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the libraries themselves. For information about how to communicate with Erlang/OTP components from earlier releases, see function &lt;code&gt;&lt;a href=&quot;ei#ei_set_compat_rel&quot;&gt; ei_set_compat_rel&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5408a0e73229b9b5e967fe902da2634b16e6868a" translate="yes" xml:space="preserve">
          <source>By default, the &lt;code&gt;ei&lt;/code&gt; library is only guaranteed to be compatible with other Erlang/OTP components from the same release as the &lt;code&gt;ei&lt;/code&gt; library itself. For example, &lt;code&gt;ei&lt;/code&gt; from Erlang/OTP R10 is not compatible with an Erlang emulator from Erlang/OTP R9 by default.</source>
          <target state="translated">De forma predeterminada, solo se garantiza que la biblioteca &lt;code&gt;ei&lt;/code&gt; sea ​​compatible con otros componentes de Erlang / OTP de la misma versi&amp;oacute;n que la propia biblioteca &lt;code&gt;ei&lt;/code&gt; . Por ejemplo, &lt;code&gt;ei&lt;/code&gt; de Erlang / OTP R10 no es compatible con un emulador de Erlang de Erlang / OTP R9 por defecto.</target>
        </trans-unit>
        <trans-unit id="cc7855f5354d795a3773624d2090708d90c447ea" translate="yes" xml:space="preserve">
          <source>By default, the &lt;strong&gt;default user&lt;/strong&gt; is set to the &lt;code&gt;snmpm_user_default&lt;/code&gt; module, which simply sends an info message to the error_logger. It is however highly recommended that this module be replaced by another that does something useful (see &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; for more info).</source>
          <target state="translated">De forma predeterminada, el &lt;strong&gt;usuario predeterminado&lt;/strong&gt; est&amp;aacute; configurado en el m&amp;oacute;dulo &lt;code&gt;snmpm_user_default&lt;/code&gt; , que simplemente env&amp;iacute;a un mensaje de informaci&amp;oacute;n al error_logger. Sin embargo, es muy recomendable que este m&amp;oacute;dulo sea reemplazado por otro que haga algo &amp;uacute;til (consulte &lt;code&gt;&lt;a href=&quot;snmp_config#configuration_params&quot;&gt;configuration params&lt;/a&gt;&lt;/code&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="8754a9737ab7ee6fe2f3b847124e99177bf4ce53" translate="yes" xml:space="preserve">
          <source>By default, the Cover tool is automatically stopped when the tests are completed. This causes the original (non-cover compiled) modules to be loaded back into the test node. If a process at this point still runs old code of any of the modules that are cover compiled, meaning that it has not done any fully qualified function call after the cover compilation, the process is killed. To avoid this, set the value of option &lt;code&gt;cover_stop&lt;/code&gt; to &lt;code&gt;false&lt;/code&gt;. This means that the modules stay cover compiled. Therefore, this is only recommended if the Erlang nodes under test are terminated after the test is completed, or if cover can be manually stopped.</source>
          <target state="translated">De forma predeterminada, la herramienta Portada se detiene autom&amp;aacute;ticamente cuando se completan las pruebas. Esto hace que los m&amp;oacute;dulos originales (compilados sin cobertura) se vuelvan a cargar en el nodo de prueba. Si un proceso en este punto todav&amp;iacute;a ejecuta c&amp;oacute;digo antiguo de cualquiera de los m&amp;oacute;dulos que est&amp;aacute;n compilados por cover, lo que significa que no ha realizado ninguna llamada de funci&amp;oacute;n completamente calificada despu&amp;eacute;s de la compilaci&amp;oacute;n de cover, el proceso se mata. Para evitar esto, establezca el valor de la opci&amp;oacute;n &lt;code&gt;cover_stop&lt;/code&gt; en &lt;code&gt;false&lt;/code&gt; . Esto significa que los m&amp;oacute;dulos permanecen compilados. Por lo tanto, esto solo se recomienda si los nodos de Erlang bajo prueba se terminan una vez finalizada la prueba, o si la cobertura se puede detener manualmente.</target>
        </trans-unit>
        <trans-unit id="9bc1af126fb19b5493bbbaf63937647ea51683fa" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default printed to the terminal.</source>
          <target state="translated">De forma predeterminada, la aplicaci&amp;oacute;n Kernel instala un controlador de registro al iniciar el sistema. Este controlador se denomina &lt;code&gt;default&lt;/code&gt; . Recibe y procesa eventos de registro est&amp;aacute;ndar producidos por el sistema de ejecuci&amp;oacute;n de Erlang, comportamientos est&amp;aacute;ndar y diferentes aplicaciones de Erlang / OTP. Los eventos de registro se imprimen de forma predeterminada en el terminal.</target>
        </trans-unit>
        <trans-unit id="44204f5230679d2fef96d8949b078f4f3e6c9083" translate="yes" xml:space="preserve">
          <source>By default, the Kernel application installs one log handler at system start. This handler is named &lt;code&gt;default&lt;/code&gt;. It receives and processes standard log events produced by the Erlang runtime system, standard behaviours and different Erlang/OTP applications. The log events are by default written to the terminal.</source>
          <target state="translated">De forma predeterminada, la aplicaci&amp;oacute;n Kernel instala un controlador de registro al iniciar el sistema. Este controlador se denomina &lt;code&gt;default&lt;/code&gt; . Recibe y procesa eventos de registro est&amp;aacute;ndar producidos por el sistema de ejecuci&amp;oacute;n de Erlang, comportamientos est&amp;aacute;ndar y diferentes aplicaciones de Erlang / OTP. Los eventos de registro se escriben de forma predeterminada en el terminal.</target>
        </trans-unit>
        <trans-unit id="05263651b062c95772f413d54c47f0b67ec3f917" translate="yes" xml:space="preserve">
          <source>By default, the actual access to the backup media is performed through module &lt;code&gt;mnesia_backup&lt;/code&gt; for both read and write. Currently &lt;code&gt;mnesia_backup&lt;/code&gt; is implemented with the standard library module &lt;code&gt;disc_log&lt;/code&gt;. However, you can write your own module with the same interface as &lt;code&gt;mnesia_backup&lt;/code&gt; and configure &lt;code&gt;Mnesia&lt;/code&gt; so that the alternative module performs the actual accesses to the backup media. The user can therefore put the backup on a media that &lt;code&gt;Mnesia&lt;/code&gt; does not know about, possibly on hosts where Erlang is not running. Use configuration parameter &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; for this purpose.</source>
          <target state="translated">De forma predeterminada, el acceso real a los medios de respaldo se realiza a trav&amp;eacute;s del m&amp;oacute;dulo &lt;code&gt;mnesia_backup&lt;/code&gt; tanto para lectura como para escritura. Actualmente &lt;code&gt;mnesia_backup&lt;/code&gt; se implementa con el m&amp;oacute;dulo de biblioteca est&amp;aacute;ndar &lt;code&gt;disc_log&lt;/code&gt; . Sin embargo, puede escribir su propio m&amp;oacute;dulo con la misma interfaz que &lt;code&gt;mnesia_backup&lt;/code&gt; y configurar &lt;code&gt;Mnesia&lt;/code&gt; para que el m&amp;oacute;dulo alternativo realice los accesos reales a los medios de respaldo. Por lo tanto, el usuario puede colocar la copia de seguridad en un medio que &lt;code&gt;Mnesia&lt;/code&gt; no conoce, posiblemente en hosts donde Erlang no se est&amp;aacute; ejecutando. Utilice el par&amp;aacute;metro de configuraci&amp;oacute;n &lt;code&gt;-mnesia backup_module &amp;lt;module&amp;gt;&lt;/code&gt; para este prop&amp;oacute;sito.</target>
        </trans-unit>
        <trans-unit id="f1afaf0fcbb8ede75fea0c65c21d25a0925f3450" translate="yes" xml:space="preserve">
          <source>By default, the agent has no knowledge of any other contexts than the default context, &lt;code&gt;&quot;&quot;&lt;/code&gt;. If it is to support more contexts, these must be explicitly added, by using an appropriate configuration file &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, el agente no tiene conocimiento de ning&amp;uacute;n otro contexto que no sea el contexto predeterminado, &lt;code&gt;&quot;&quot;&lt;/code&gt; . Si es para admitir m&amp;aacute;s contextos, estos deben agregarse expl&amp;iacute;citamente mediante el uso de un archivo de configuraci&amp;oacute;n apropiado &lt;code&gt;&lt;a href=&quot;snmp_agent_config_files&quot;&gt;Agent Configuration Files&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="90e34246dd8429aefe6c7b588f2a3b0f064042d2" translate="yes" xml:space="preserve">
          <source>By default, the boot script and boot file are located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, they are located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">De forma predeterminada, el script de inicio y el archivo de inicio se encuentran en el mismo directorio que &lt;code&gt;Name.rel&lt;/code&gt; . Es decir, en el directorio de trabajo actual a menos que &lt;code&gt;Name&lt;/code&gt; contenga una ruta. Si se especifica la opci&amp;oacute;n &lt;code&gt;{outdir,Dir}&lt;/code&gt; ,se ubicar&amp;aacute;n en &lt;code&gt;Dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="12131639ccba633c1e0c7ee60e1e122164ffcb95" translate="yes" xml:space="preserve">
          <source>By default, the compile server is not used. It can be enabled by giving &lt;code&gt;erlc&lt;/code&gt; the option &lt;code&gt;-server&lt;/code&gt; or by setting the environment variable &lt;code&gt;ERLC_USE_SERVER&lt;/code&gt; to &lt;code&gt;yes&lt;/code&gt; or &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d3804b66310d736d0a24d21cca9ed0959844c03" translate="yes" xml:space="preserve">
          <source>By default, the generated code for operation &lt;code&gt;Record#record_tag.field&lt;/code&gt; verifies that the tuple &lt;code&gt;Record&lt;/code&gt; has the correct size for the record, and that the first element is the tag &lt;code&gt;record_tag&lt;/code&gt;. Use this option to omit the verification code.</source>
          <target state="translated">Por defecto, el c&amp;oacute;digo generado para la operaci&amp;oacute;n &lt;code&gt;Record#record_tag.field&lt;/code&gt; verifica que la tupla &lt;code&gt;Record&lt;/code&gt; tiene el tama&amp;ntilde;o correcto para el registro y que el primer elemento es la etiqueta &lt;code&gt;record_tag&lt;/code&gt; . Utilice esta opci&amp;oacute;n para omitir el c&amp;oacute;digo de verificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="92ed03811630a1034411365747a68f1b027d08b7" translate="yes" xml:space="preserve">
          <source>By default, the maximum number of atoms is 1,048,576. This limit can be raised or lowered using the &lt;code&gt;+t&lt;/code&gt; option.</source>
          <target state="translated">De forma predeterminada, el n&amp;uacute;mero m&amp;aacute;ximo de &amp;aacute;tomos es 1.048.576. Este l&amp;iacute;mite se puede subir o bajar usando la opci&amp;oacute;n &lt;code&gt;+t&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c86aae6b772372c0ae40b88282e56c074aa7a5f1" translate="yes" xml:space="preserve">
          <source>By default, the parser that was generated will not print out error messages to the screen. The user will have to do this either by printing the returned error messages, or by inserting tests and print instructions in the Erlang code associated with the syntax rules of the grammar file.</source>
          <target state="translated">Por defecto,el analizador que se generó no imprimirá mensajes de error en la pantalla.El usuario tendrá que hacerlo ya sea imprimiendo los mensajes de error devueltos,o insertando pruebas e instrucciones de impresión en el código Erlang asociado a las reglas de sintaxis del archivo de gramática.</target>
        </trans-unit>
        <trans-unit id="e241a1115343866b033984b2e0f3224cbedbb8d1" translate="yes" xml:space="preserve">
          <source>By default, the quantifiers are &quot;greedy&quot;, that is, they match as much as possible (up to the maximum number of permitted times), without causing the remaining pattern to fail. The classic example of where this gives problems is in trying to match comments in C programs. These appear between /* and */. Within the comment, individual * and / characters can appear. An attempt to match C comments by applying the pattern</source>
          <target state="translated">Por defecto,los cuantificadores son &quot;codiciosos&quot;,es decir,coinciden en la medida de lo posible (hasta el máximo número de veces permitidas),sin que el patrón restante falle.El ejemplo clásico de donde esto da problemas es al tratar de hacer coincidir los comentarios en los programas C.Estos aparecen entre /*y */.Dentro del comentario,pueden aparecer caracteres individuales*y //.Un intento de hacer coincidir los comentarios de C aplicando el patrón</target>
        </trans-unit>
        <trans-unit id="3c85bc6c43eb52272e65af88f8cd9d253d828366" translate="yes" xml:space="preserve">
          <source>By default, the release package contains the directories &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; and &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; for each included application. If more directories are to be included, option &lt;code&gt;dirs&lt;/code&gt; is specified, for example, &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, el paquete de lanzamiento contiene los directorios &lt;code&gt;lib/App-Vsn/ebin&lt;/code&gt; y &lt;code&gt;lib/App-Vsn/priv&lt;/code&gt; para cada aplicaci&amp;oacute;n incluida. Si se van a incluir m&amp;aacute;s directorios, se especifica la opci&amp;oacute;n &lt;code&gt;dirs&lt;/code&gt; , por ejemplo, &lt;code&gt;{dirs,[src,examples]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f48b56c162fe6bc8e83c9024713b2063795276f9" translate="yes" xml:space="preserve">
          <source>By default, the release package file is located in the same directory as &lt;code&gt;Name.rel&lt;/code&gt;. That is, in the current working directory unless &lt;code&gt;Name&lt;/code&gt; contains a path. If option &lt;code&gt;{outdir,Dir}&lt;/code&gt; is specified, it is located in &lt;code&gt;Dir&lt;/code&gt; instead.</source>
          <target state="translated">De forma predeterminada, el archivo del paquete de lanzamiento se encuentra en el mismo directorio que &lt;code&gt;Name.rel&lt;/code&gt; . Es decir, en el directorio de trabajo actual a menos que &lt;code&gt;Name&lt;/code&gt; contenga una ruta. Si se especifica la opci&amp;oacute;n &lt;code&gt;{outdir,Dir}&lt;/code&gt; , se ubicar&amp;aacute; en &lt;code&gt;Dir&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd67be193ef985280c7869e02ad1eaa76d02cee6" translate="yes" xml:space="preserve">
          <source>By default, the script will be interpreted. You can force it to be compiled by including the following line somewhere in the script file:</source>
          <target state="translated">Por defecto,el guión será interpretado.Puede forzarlo a ser compilado incluyendo la siguiente línea en algún lugar del archivo del guión:</target>
        </trans-unit>
        <trans-unit id="b2a64b819e1641df3c5bc639a09bb56418f80b28" translate="yes" xml:space="preserve">
          <source>By default, the tar file is opened in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the tar file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">Por defecto, el archivo tar se abre en modo &lt;code&gt;raw&lt;/code&gt; , que es m&amp;aacute;s r&amp;aacute;pido pero no permite utilizar un servidor de archivos remoto (Erlang). Agregar &lt;code&gt;cooked&lt;/code&gt; a la lista de modos anula el predeterminado y abre el archivo tar sin la opci&amp;oacute;n &lt;code&gt;raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="968238200f11724a49fdbda317cbe260c831d025" translate="yes" xml:space="preserve">
          <source>By default, the value is as before, that is, &lt;code&gt;minimal&lt;/code&gt;.</source>
          <target state="translated">Por defecto, el valor es como antes, es decir, &lt;code&gt;minimal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="76563b7abdc9fe4d5e61b108b45efa4f79168faa" translate="yes" xml:space="preserve">
          <source>By default, this function adds &quot;\n&quot; to the end of the specified command. If this is not desired, option &lt;code&gt;{newline,false}&lt;/code&gt; can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interpret As Command (IAC). Option &lt;code&gt;{newline,string()}&lt;/code&gt; can also be used if a different line end than &quot;\n&quot; is required, for instance &lt;code&gt;{newline,&quot;\r\n&quot;}&lt;/code&gt;, to add both carriage return and newline characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="853ca12d28a4ac6514c7cb70a17bec30cd8f3e6f" translate="yes" xml:space="preserve">
          <source>By default, this function adds &quot;\n&quot; to the end of the specified command. If this is not desired, use option &lt;code&gt;{newline,false}&lt;/code&gt;. This is necessary, for example, when sending Telnet command sequences prefixed with character Interpret As Command (IAC). Option &lt;code&gt;{newline,string()}&lt;/code&gt; can also be used if a different line end than &quot;\n&quot; is required, for instance &lt;code&gt;{newline,&quot;\r\n&quot;}&lt;/code&gt;, to add both carriage return and newline characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e69fa5b82743edee630d33a79817b045aafc5d81" translate="yes" xml:space="preserve">
          <source>By default, this function adds a new line to the end of the specified command. If this is not desired, use option &lt;code&gt;{newline,false}&lt;/code&gt;. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">De forma predeterminada, esta funci&amp;oacute;n agrega una nueva l&amp;iacute;nea al final del comando especificado. Si no lo desea, use la opci&amp;oacute;n &lt;code&gt;{newline,false}&lt;/code&gt; . Esto es necesario, por ejemplo, al enviar secuencias de comandos Telnet con el prefijo del car&amp;aacute;cter Interpretar como comando (IAC).</target>
        </trans-unit>
        <trans-unit id="d49eba4b9253b8356ed12159ecfe231995c2f898" translate="yes" xml:space="preserve">
          <source>By default, this function adds a newline to the end of the specified command. If this is not desired, option &lt;code&gt;{newline,false}&lt;/code&gt; can be used. This is necessary, for example, when sending Telnet command sequences prefixed with character Interprete As Command (IAC).</source>
          <target state="translated">De forma predeterminada, esta funci&amp;oacute;n agrega una nueva l&amp;iacute;nea al final del comando especificado. Si no se desea, se puede utilizar la opci&amp;oacute;n &lt;code&gt;{newline,false}&lt;/code&gt; . Esto es necesario, por ejemplo, al enviar secuencias de comandos Telnet con el prefijo del car&amp;aacute;cter Interpretar como comando (IAC).</target>
        </trans-unit>
        <trans-unit id="a9e7714f2d506552215115a4ebf113d003a0acf0" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, esta funci&amp;oacute;n abre el archivo zip en modo sin &lt;code&gt;raw&lt;/code&gt; , que es m&amp;aacute;s r&amp;aacute;pido pero no permite utilizar un servidor de archivos remoto (Erlang). Agregar &lt;code&gt;cooked&lt;/code&gt; a la lista de modos anula el valor predeterminado y abre el archivo zip sin la opci&amp;oacute;n sin &lt;code&gt;raw&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d14a17c6143d2f118a5dcf4b9f9f2f606d6beef7" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in &lt;code&gt;raw&lt;/code&gt; mode, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without option &lt;code&gt;raw&lt;/code&gt;. The same applies for the files extracted.</source>
          <target state="translated">De forma predeterminada, esta funci&amp;oacute;n abre el archivo zip en modo sin &lt;code&gt;raw&lt;/code&gt; , que es m&amp;aacute;s r&amp;aacute;pido pero no permite utilizar un servidor de archivos remoto (Erlang). Agregar &lt;code&gt;cooked&lt;/code&gt; a la lista de modos anula el valor predeterminado y abre el archivo zip sin la opci&amp;oacute;n sin &lt;code&gt;raw&lt;/code&gt; . Lo mismo se aplica a los archivos extra&amp;iacute;dos.</target>
        </trans-unit>
        <trans-unit id="7a8f2bce9d4e28310f04f71c37d623d77632500e" translate="yes" xml:space="preserve">
          <source>By default, this function opens the zip file in mode &lt;code&gt;raw&lt;/code&gt;, which is faster but does not allow a remote (Erlang) file server to be used. Adding &lt;code&gt;cooked&lt;/code&gt; to the mode list overrides the default and opens the zip file without the &lt;code&gt;raw&lt;/code&gt; option. The same applies for the files added.</source>
          <target state="translated">De forma predeterminada, esta funci&amp;oacute;n abre el archivo zip en modo &lt;code&gt;raw&lt;/code&gt; , que es m&amp;aacute;s r&amp;aacute;pido pero no permite utilizar un servidor de archivos remoto (Erlang). Agregar &lt;code&gt;cooked&lt;/code&gt; a la lista de modos anula el valor predeterminado y abre el archivo zip sin la opci&amp;oacute;n sin &lt;code&gt;raw&lt;/code&gt; . Lo mismo se aplica a los archivos agregados.</target>
        </trans-unit>
        <trans-unit id="679e4d02c8183bf697056897c283fb7c9fe1a240" translate="yes" xml:space="preserve">
          <source>By default, this option is not set. This means that the number is not limited.</source>
          <target state="translated">Por defecto,esta opción no está configurada.Esto significa que el número no está limitado.</target>
        </trans-unit>
        <trans-unit id="6486abd515b1ceb341dd61657f6cfe722ef188e0" translate="yes" xml:space="preserve">
          <source>By default, this rule is written to &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt;. However, if option &lt;code&gt;binary&lt;/code&gt; is set, nothing is written and the rule is returned in &lt;code&gt;Binary&lt;/code&gt;.</source>
          <target state="translated">De forma predeterminada, esta regla se escribe en &lt;code&gt;&amp;lt;File&amp;gt;.Pbeam&lt;/code&gt; . Sin embargo, si se establece la opci&amp;oacute;n &lt;code&gt;binary&lt;/code&gt; , no se escribe nada y la regla se devuelve en &lt;code&gt;Binary&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3dc5c5c502173feaca81300d649a4642ade965d9" translate="yes" xml:space="preserve">
          <source>By default, this will &lt;strong&gt;not&lt;/strong&gt; be used.</source>
          <target state="translated">De forma predeterminada, esto &lt;strong&gt;no&lt;/strong&gt; se utilizar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="9e77c5d7a27dc1e5cf909f3bf8e3e3ad53b629c2" translate="yes" xml:space="preserve">
          <source>By default, warnings are emitted for unused variables, except for variables beginning with an underscore (&quot;Prolog style warnings&quot;). Use this option to turn off this kind of warnings.</source>
          <target state="translated">Por defecto,se emiten advertencias para las variables no utilizadas,excepto para las variables que empiezan con un guión bajo (&quot;Advertencias de estilo Prolog&quot;).Utilice esta opción para desactivar este tipo de advertencias.</target>
        </trans-unit>
        <trans-unit id="25048d6dfb90d946e1d4080a2f5aec1215e6a89c" translate="yes" xml:space="preserve">
          <source>By default, warnings are emitted when inlining is enabled in a module that may load NIFs, as the compiler may inline NIF fallbacks by accident. Use this option to turn off this kind of warnings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20ba07e398dad932a7a5314c1ee7e53c53da657a" translate="yes" xml:space="preserve">
          <source>By default, when &lt;code&gt;[]&lt;/code&gt; is passed as &lt;code&gt;ModifierList&lt;/code&gt;, both negative and positive integers can be returned. This to use the range of integers that do not need heap memory allocation as much as possible. By default the returned integers are also only guaranteed to be unique, that is, any returned integer can be smaller or larger than previously returned integers.</source>
          <target state="translated">De forma predeterminada, cuando se pasa &lt;code&gt;[]&lt;/code&gt; como &lt;code&gt;ModifierList&lt;/code&gt; , se pueden devolver enteros tanto negativos como positivos. Esto para usar el rango de enteros que no necesitan asignaci&amp;oacute;n de memoria de pila tanto como sea posible. De forma predeterminada, tambi&amp;eacute;n se garantiza que los enteros devueltos son &amp;uacute;nicos, es decir, cualquier entero devuelto puede ser m&amp;aacute;s peque&amp;ntilde;o o m&amp;aacute;s grande que los enteros devueltos anteriormente.</target>
        </trans-unit>
        <trans-unit id="11b69da7024ea541c3dc95c3ee7904796b05dd49" translate="yes" xml:space="preserve">
          <source>By definition, it is not possible to send objects with ACCESS &lt;code&gt;not-accessible&lt;/code&gt; in notifications. However, historically this is often done and for this reason we allow it in notification sending. If a variable has ACCESS &lt;code&gt;not-accessible&lt;/code&gt;, the user must provide a value for the variable in the &lt;code&gt;Varbinds&lt;/code&gt; list. It is not possible for the agent to perform a get-operation to retrieve this value.</source>
          <target state="translated">Por definici&amp;oacute;n, no es posible enviar objetos con ACCESO &lt;code&gt;not-accessible&lt;/code&gt; en notificaciones. Sin embargo, hist&amp;oacute;ricamente esto se hace a menudo y por eso lo permitimos en el env&amp;iacute;o de notificaciones. Si una variable tiene ACCESO &lt;code&gt;not-accessible&lt;/code&gt; , el usuario debe proporcionar un valor para la variable en la lista &lt;code&gt;Varbinds&lt;/code&gt; . No es posible que el agente realice una operaci&amp;oacute;n de obtenci&amp;oacute;n para recuperar este valor.</target>
        </trans-unit>
        <trans-unit id="1fe4bf7551fb0bca40b8408258d2d9b38f061a30" translate="yes" xml:space="preserve">
          <source>By deliberately copying a single binary to avoid referencing a larger binary, one can, instead of freeing up the larger binary for later garbage collection, create much more binary data than needed. Sharing binary data is usually good. Only in special cases, when small parts reference large binaries and the large binaries are no longer used in any process, deliberate copying can be a good idea.</source>
          <target state="translated">Copiando deliberadamente un solo binario para evitar referirse a un binario más grande,se puede,en lugar de liberar el binario más grande para la posterior recogida de basura,crear muchos más datos binarios de los necesarios.Compartir datos binarios suele ser bueno.Sólo en casos especiales,cuando las partes pequeñas hacen referencia a binarios grandes y los binarios grandes ya no se utilizan en ningún proceso,la copia deliberada puede ser una buena idea.</target>
        </trans-unit>
        <trans-unit id="3a1bde088e58ddc2e236cd1237348e4ca2d354a9" translate="yes" xml:space="preserve">
          <source>By executing these commands, two Erlang nodes are configured to run the &lt;code&gt;Company&lt;/code&gt; database, and therefore, initialize the database. This is required only once when setting up. The next time the system is started, &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; is called on both nodes, to initialize the system from disc.</source>
          <target state="translated">Al ejecutar estos comandos, se configuran dos nodos Erlang para ejecutar la base de datos de la &lt;code&gt;Company&lt;/code&gt; y, por lo tanto, inicializar la base de datos. Esto es necesario solo una vez durante la configuraci&amp;oacute;n. La pr&amp;oacute;xima vez que se inicia el sistema, se &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; en ambos nodos, para inicializar el sistema desde el disco.</target>
        </trans-unit>
        <trans-unit id="d4cbb518f731cd8bac9f82803da816e494e6c084" translate="yes" xml:space="preserve">
          <source>By far the most common situation where this occurs, is when you get lists of UTF-8 instead of proper Unicode strings, and then convert them to UTF-8 in a binary or on a file:</source>
          <target state="translated">La situación más común en la que esto ocurre es cuando se obtienen listas de UTF-8 en lugar de cadenas Unicode adecuadas,y luego se convierten a UTF-8 en un binario o en un archivo:</target>
        </trans-unit>
        <trans-unit id="e536308fb486e25402a1208f98bf1f7153e3c15e" translate="yes" xml:space="preserve">
          <source>By focusing on getting the code to pass the tests, the programmer can become more productive, not overspecify or get lost in premature optimizations, and create code that is correct from the very beginning (so-called &lt;strong&gt;test-driven development&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Al enfocarse en lograr que el c&amp;oacute;digo pase las pruebas, el programador puede volverse m&amp;aacute;s productivo, no sobreespecificar ni perderse en optimizaciones prematuras, y crear c&amp;oacute;digo que sea correcto desde el principio (el llamado &lt;strong&gt;desarrollo impulsado por pruebas&lt;/strong&gt; ; consulte &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="1be6092d2f04d5672bbcc552b76ea03252377f9a" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application (see section &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Al proporcionar el controlador de formato &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; , puede hacer que el registro de seguimiento se presente gr&amp;aacute;ficamente con &lt;code&gt;et_viewer&lt;/code&gt; en la aplicaci&amp;oacute;n ET (consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#et_viewer&quot;&gt;Presenting Trace Logs with Event Tracer&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4d1f348639ff071f4f3a637874209a8d2a2be427" translate="yes" xml:space="preserve">
          <source>By giving the format handler &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt;, you can have the trace log presented graphically with &lt;code&gt;et_viewer&lt;/code&gt; in the ET application. &lt;code&gt;ttb&lt;/code&gt; provides filters that can be selected from the menu &lt;strong&gt;Filter&lt;/strong&gt; in the &lt;code&gt;et_viewer&lt;/code&gt; window. The filters are names according to the type of actors they present (that is, what each vertical line in the sequence diagram represents). Interaction between actors is shown as red arrows between two vertical lines, and activities within an actor are shown as blue text to the right of the actors line.</source>
          <target state="translated">Al proporcionar el controlador de formato &lt;code&gt;&lt;a href=&quot;ttb#get_et_handler-0&quot;&gt;ttb:get_et_handler()&lt;/a&gt;&lt;/code&gt; , puede hacer que el registro de seguimiento se presente gr&amp;aacute;ficamente con &lt;code&gt;et_viewer&lt;/code&gt; en la aplicaci&amp;oacute;n ET. &lt;code&gt;ttb&lt;/code&gt; proporciona filtros que se pueden seleccionar desde el men&amp;uacute; &lt;strong&gt;Filtro&lt;/strong&gt; en la ventana &lt;code&gt;et_viewer&lt;/code&gt; . Los filtros son nombres seg&amp;uacute;n el tipo de actores que presentan (es decir, lo que representa cada l&amp;iacute;nea vertical en el diagrama de secuencia). La interacci&amp;oacute;n entre actores se muestra como flechas rojas entre dos l&amp;iacute;neas verticales y las actividades dentro de un actor se muestran como texto azul a la derecha de la l&amp;iacute;nea de actores.</target>
        </trans-unit>
        <trans-unit id="67f7db44464541266f3f0704ea1cb52a5cffad39" translate="yes" xml:space="preserve">
          <source>By going different directions when inserting and fetching, we avoid contention between threads inserting and threads fetching as much as possible. By skipping one element when we begin searching, we preserve the sentinel unmodified as much as possible. This is beneficial since all search operations need to read the content of the sentinel. If we were to modify the sentinel, the cache line containing the sentinel would unnecessarily be bounced between processors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8645150b63184ee0f8a1f1a7796ff9caeac2c2be" translate="yes" xml:space="preserve">
          <source>By increasing the size of identifiers, at least on 64-bit machines (which isn't as easy as it first might seem) we get further room for improvement. Besides the obvious improvement of not reusing identifiers as fast as we currently do, it makes it possible to further avoid contention when inserting elements in the table. At least if we drop this ordering property, which isn't that useful anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c38dcce4fbbcbaa49db2c494d622ac31a93af9e" translate="yes" xml:space="preserve">
          <source>By inspecting the headers or writing a small C program, it is found that &lt;code&gt;IPPROTO_TCP&lt;/code&gt; is 6, &lt;code&gt;TCP_INFO&lt;/code&gt; is 11, the structure size is 92 (bytes), the offset of &lt;code&gt;tcpi_sacked&lt;/code&gt; is 28 bytes, and the value is a 32-bit integer. The following code can be used to retrieve the value:</source>
          <target state="translated">Al inspeccionar los encabezados o escribir un peque&amp;ntilde;o programa en C, se encuentra que &lt;code&gt;IPPROTO_TCP&lt;/code&gt; es 6, &lt;code&gt;TCP_INFO&lt;/code&gt; es 11, el tama&amp;ntilde;o de la estructura es 92 (bytes), el desplazamiento de &lt;code&gt;tcpi_sacked&lt;/code&gt; es 28 bytes y el valor es un entero de 32 bits. El siguiente c&amp;oacute;digo se puede utilizar para recuperar el valor:</target>
        </trans-unit>
        <trans-unit id="018fc7c90872dc5bcc3ecc8ce71bc58db7e38b60" translate="yes" xml:space="preserve">
          <source>By inspecting the implementation, you might notice that some specific signal gives a stricter guarantee than described above. It is of vital importance that such knowledge about the implementation is &lt;strong&gt;not&lt;/strong&gt; used by Erlang code, as the implementation can change at any time without prior notice.</source>
          <target state="translated">Al inspeccionar la implementaci&amp;oacute;n, puede notar que alguna se&amp;ntilde;al espec&amp;iacute;fica brinda una garant&amp;iacute;a m&amp;aacute;s estricta que la descrita anteriormente. Es de vital importancia que dicho conocimiento sobre la implementaci&amp;oacute;n &lt;strong&gt;no sea&lt;/strong&gt; utilizado por el c&amp;oacute;digo Erlang, ya que la implementaci&amp;oacute;n puede cambiar en cualquier momento sin previo aviso.</target>
        </trans-unit>
        <trans-unit id="0d5d59f9d063b86f9130d5f5210753452085dc85" translate="yes" xml:space="preserve">
          <source>By introduction of this new busy state we still can provide the flow control. Old driver do not even have to be changed. The limits can, however, be configured and even disabled by the port. By default the high limit is 8 KB and the low limit is 4 KB.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27a61522ba19814181bc4db8e5c44cbf812700d2" translate="yes" xml:space="preserve">
          <source>By keeping this part when reverting back to a locked implementation, we could remove a pointer field in each process structure, and avoid unnecessary operations on the process and the queue which might cause contention.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b879e7731e558078b8cea840f1fb4c1f690b4a" translate="yes" xml:space="preserve">
          <source>By looking at the results from the analyses, it can be deducted that the test case does not cover the case when all channels are allocated and &lt;code&gt;test.erl&lt;/code&gt; should be extended accordingly.</source>
          <target state="translated">Al observar los resultados de los an&amp;aacute;lisis, se puede deducir que el caso de prueba no cubre el caso en el que todos los canales est&amp;aacute;n asignados y &lt;code&gt;test.erl&lt;/code&gt; debe ampliarse en consecuencia.</target>
        </trans-unit>
        <trans-unit id="0adc0a428da4933a5c912fbd894ed220b7168db5" translate="yes" xml:space="preserve">
          <source>By parsing an XML document you will get a record, displaying the structure of the document, as return value. The record also holds the data of the document. xmerl is convenient to use in for instance the following scenarios:</source>
          <target state="translated">Analizando un documento XML se obtiene un registro que muestra la estructura del documento como valor de retorno.El registro también contiene los datos del documento.xmerl es conveniente para usar en,por ejemplo,los siguientes escenarios:</target>
        </trans-unit>
        <trans-unit id="805a7a9a8ddfb1ba7400cf31f92187edc3ff9a77" translate="yes" xml:space="preserve">
          <source>By passing a pointer to an integer variable containing the value &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt;, the currently used limit is read and written back to the integer variable. A new limit can be set by passing a pointer to an integer variable containing a valid limit. The passed value is written to the internal limit. The internal limit is then adjusted. After this the adjusted limit is written back to the integer variable from which the new value was read. Values are in bytes.</source>
          <target state="translated">Al pasar un puntero a una variable entera que contiene el valor &lt;code&gt;ERL_DRV_BUSY_MSGQ_READ_ONLY&lt;/code&gt; , el l&amp;iacute;mite utilizado actualmente se lee y se vuelve a escribir en la variable entera. Se puede establecer un nuevo l&amp;iacute;mite pasando un puntero a una variable entera que contenga un l&amp;iacute;mite v&amp;aacute;lido. El valor pasado se escribe en el l&amp;iacute;mite interno. Luego se ajusta el l&amp;iacute;mite interno. Despu&amp;eacute;s de esto, el l&amp;iacute;mite ajustado se vuelve a escribir en la variable entera de la que se ley&amp;oacute; el nuevo valor. Los valores est&amp;aacute;n en bytes.</target>
        </trans-unit>
        <trans-unit id="5fab0b335aad4687a0efd2b2918fb0d4d20a2d30" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-1&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in almost the same context as the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-1&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; is useful in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75da6c1f2ebad0633762bf86ba622c3a4f5ba6cd" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as an argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in almost the same context as the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt;. The difference is that the operations are performed synchronously. The caller waits for the updates to be performed on all active replicas. Using &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">Al pasar el mismo &quot;diversi&amp;oacute;n&quot; como argumento a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#sync_dirty-2&quot;&gt;mnesia:sync_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; , se realiza casi en el mismo contexto que la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty/1,2&lt;/a&gt;&lt;/code&gt; . La diferencia es que las operaciones se realizan de forma sincr&amp;oacute;nica. La persona que llama espera a que se realicen las actualizaciones en todas las r&amp;eacute;plicas activas. El uso de &lt;code&gt;mnesia:sync_dirty/1,2&lt;/code&gt; es &amp;uacute;til en los siguientes casos:</target>
        </trans-unit>
        <trans-unit id="07cd49a0634099807d33616dd0caa93e4fb6d9a9" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-1&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated &quot;dirty&quot;. Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="808cd51c3638fb04adece47349170a09569ccf1c" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt;, it is performed in dirty context. The function calls are mapped to the corresponding dirty functions. This still involves logging, replication, and subscriptions but no locking, local transaction storage, or commit protocols are involved. Checkpoint retainers are updated but updated &quot;dirty&quot;. Thus, they are updated asynchronously. The functions wait for the operation to be performed on one node but not the others. If the table resides locally, no waiting occurs.</source>
          <target state="translated">Al pasar el mismo &quot;divertido&quot; como argumento a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#async_dirty-2&quot;&gt;mnesia:async_dirty(Fun [, Args])&lt;/a&gt;&lt;/code&gt; , se realiza en contexto sucio. Las llamadas a funciones se asignan a las funciones sucias correspondientes. Esto todav&amp;iacute;a implica el registro, la replicaci&amp;oacute;n y las suscripciones, pero no implica ning&amp;uacute;n bloqueo, almacenamiento de transacciones locales o protocolos de confirmaci&amp;oacute;n. Los retenedores de puntos de control se actualizan pero se actualizan &quot;sucios&quot;. Por lo tanto, se actualizan de forma asincr&amp;oacute;nica. Las funciones esperan a que la operaci&amp;oacute;n se realice en un nodo pero no en los dem&amp;aacute;s. Si la mesa reside localmente, no se produce ninguna espera.</target>
        </trans-unit>
        <trans-unit id="e0b3ed9cf7bda275ce89d365e3ae0df2fa60e975" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-1&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; call. Using &lt;code&gt;sync_transaction&lt;/code&gt; is useful in the following cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fe18782111712f87288c23d1c8fb50a83e580df" translate="yes" xml:space="preserve">
          <source>By passing the same &quot;fun&quot; as argument to the function &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; it is performed in synced transaction context. Synced transactions wait until all active replicas has committed the transaction (to disc) before returning from the &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; call. Using &lt;code&gt;sync_transaction&lt;/code&gt; is useful in the following cases:</source>
          <target state="translated">Al pasar el mismo &quot;diversi&amp;oacute;n&quot; como argumento a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#sync_transaction-3&quot;&gt;mnesia:sync_transaction(Fun [, Args])&lt;/a&gt;&lt;/code&gt; , se realiza en el contexto de la transacci&amp;oacute;n sincronizada. Las transacciones sincronizadas esperan hasta que todas las r&amp;eacute;plicas activas hayan confirmado la transacci&amp;oacute;n (en el disco) antes de regresar de la llamada &lt;code&gt;mnesia:sync_transaction&lt;/code&gt; . El uso de &lt;code&gt;sync_transaction&lt;/code&gt; es &amp;uacute;til en los siguientes casos:</target>
        </trans-unit>
        <trans-unit id="8d8e68091d4403f0e83bd114c70649e6a566d00b" translate="yes" xml:space="preserve">
          <source>By preference, these functions can be included in module &lt;code&gt;shell_default&lt;/code&gt;. By default, they are included in that module.</source>
          <target state="translated">De preferencia, estas funciones se pueden incluir en el m&amp;oacute;dulo &lt;code&gt;shell_default&lt;/code&gt; . De forma predeterminada, se incluyen en ese m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="7f254d4f66995179ccfd6ad20889ce3083eb5612" translate="yes" xml:space="preserve">
          <source>By setting &lt;code&gt;SourceMod&lt;/code&gt; and &lt;code&gt;TargetMod&lt;/code&gt; to different modules, a backup can be copied from one backup media to another.</source>
          <target state="translated">Al configurar &lt;code&gt;SourceMod&lt;/code&gt; y &lt;code&gt;TargetMod&lt;/code&gt; en m&amp;oacute;dulos diferentes, se puede copiar una copia de seguridad de un medio de copia de seguridad a otro.</target>
        </trans-unit>
        <trans-unit id="d49dba3e2b5c5cceb098125c642fa912b7e82445" translate="yes" xml:space="preserve">
          <source>By testing in a bottom-up fashion, beginning with the smallest program units and creating a confidence in that they work as they should, it becomes easier to test that a higher-level component, consisting of several such units, also behaves according to specification (known as &lt;strong&gt;integration testing&lt;/strong&gt;; see &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Al probar de forma ascendente, comenzando con las unidades de programa m&amp;aacute;s peque&amp;ntilde;as y creando la confianza de que funcionan como deber&amp;iacute;an, resulta m&amp;aacute;s f&amp;aacute;cil probar que un componente de nivel superior, que consta de varias de estas unidades, tambi&amp;eacute;n se comporta de acuerdo con las especificaciones. (conocido como &lt;strong&gt;prueba de integraci&amp;oacute;n&lt;/strong&gt; ; consulte &lt;code&gt;&lt;a href=&quot;#Terminology&quot;&gt;Terminology&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ff05bbe6b9df494deffc0d26f620950719c544d4" translate="yes" xml:space="preserve">
          <source>By this means, options can be made to have different settings in different parts of the pattern. Any changes made in one alternative do carry on into subsequent branches within the same subpattern. For example:</source>
          <target state="translated">Por este medio,se pueden hacer opciones para tener diferentes ajustes en diferentes partes del patrón.Cualquier cambio realizado en una alternativa se lleva a cabo en las ramas subsiguientes dentro del mismo subpatrón.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="35ec349917181f956c0a4c9c0f4a81caa7003c00" translate="yes" xml:space="preserve">
          <source>By using &lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt;, you can specify if Debugger is to be started in local or global mode:</source>
          <target state="translated">Al usar &lt;code&gt;&lt;a href=&quot;debugger#start-1&quot;&gt;debugger:start/1&lt;/a&gt;&lt;/code&gt; , puede especificar si Debugger se iniciar&amp;aacute; en modo local o global:</target>
        </trans-unit>
        <trans-unit id="99adfb49899ce85d907d066e2103689e06c7ae25" translate="yes" xml:space="preserve">
          <source>By using one data structure of free blocks in each carrier and an allocator instance-wide data structure of carriers managed by the allocator instance, the work needed in order to remove and add carriers can be kept to a minimum. When migration of carriers is enabled on a specific allocator type, we require that an allocation strategy with such an implementation is used. Currently we've implemented this for three different allocation strategies. All of these strategies use a search tree of carriers sorted so that we can find the carrier with the lowest address that can satisfy the request. Internally in carriers we use yet another search tree that either implement address order first fit, address order best fit, or best fit. The abbreviations used for these different allocation strategies are &lt;code&gt;aoff&lt;/code&gt;, and &lt;code&gt;aoffcaobf&lt;/code&gt;, &lt;code&gt;aoffcbf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da8978f9ea68a7c6f48f6d3c9e527498ef08964" translate="yes" xml:space="preserve">
          <source>By using option &lt;code&gt;handler&lt;/code&gt; when starting the tracer, the information about how to format the file is stored in the trace information file (&lt;code&gt;.ti&lt;/code&gt;). This is not necessary, as it can be specified when formatting instead. However, It can be useful if you, for example, want to format trace logs automatically using option &lt;code&gt;format&lt;/code&gt; in &lt;code&gt;ttb:stop/1&lt;/code&gt;. Also, you do not need any knowledge of the content of a binary log to format it the way it is intended. If option &lt;code&gt;handler&lt;/code&gt; is specified both when starting the tracer and when formatting, the one specified when formatting is used.</source>
          <target state="translated">Al utilizar el &lt;code&gt;handler&lt;/code&gt; opciones al iniciar el trazador, la informaci&amp;oacute;n sobre c&amp;oacute;mo formatear el archivo se almacena en el archivo de informaci&amp;oacute;n de seguimiento ( &lt;code&gt;.ti&lt;/code&gt; ). Esto no es necesario, ya que se puede especificar al formatear. Sin embargo, puede ser &amp;uacute;til si, por ejemplo, desea formatear los registros de seguimiento autom&amp;aacute;ticamente usando la opci&amp;oacute;n &lt;code&gt;format&lt;/code&gt; o en &lt;code&gt;ttb:stop/1&lt;/code&gt; . Adem&amp;aacute;s, no necesita ning&amp;uacute;n conocimiento del contenido de un registro binario para formatearlo de la forma prevista. Si se especifica el &lt;code&gt;handler&lt;/code&gt; opciones tanto al iniciar el trazador como al formatear, se utiliza el especificado al formatear.</target>
        </trans-unit>
        <trans-unit id="02d1325592a3ef565e5e7f405f91fc17bcd0d42f" translate="yes" xml:space="preserve">
          <source>By using ordinary UNIX tools like &lt;code&gt;sed&lt;/code&gt; and &lt;code&gt;grep&lt;/code&gt; one can easily find answers to various questions like:</source>
          <target state="translated">Al utilizar herramientas comunes de UNIX como &lt;code&gt;sed&lt;/code&gt; y &lt;code&gt;grep&lt;/code&gt; , uno puede encontrar f&amp;aacute;cilmente respuestas a varias preguntas como:</target>
        </trans-unit>
        <trans-unit id="a2d275dd09349865f8c3284b6c4fd5293841ad62" translate="yes" xml:space="preserve">
          <source>By using the new API, you automatically get scalability and performance improvements. This also enables you to use the &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; that improves accuracy and precision of time measurements.</source>
          <target state="translated">Al utilizar la nueva API, obtiene autom&amp;aacute;ticamente mejoras de escalabilidad y rendimiento. Esto tambi&amp;eacute;n le permite utilizar el &lt;code&gt;&lt;a href=&quot;#Multi_Time_Warp_Mode&quot;&gt;multi-time warp mode&lt;/a&gt;&lt;/code&gt; que mejora la exactitud y precisi&amp;oacute;n de las mediciones de tiempo.</target>
        </trans-unit>
        <trans-unit id="77c257b7be9bfb86770597be303f8b67e4aa586a" translate="yes" xml:space="preserve">
          <source>By wrapping the API with functions that fall back on &lt;code&gt;erlang:now/0&lt;/code&gt; when the new API is unavailable, and using these wrappers instead of using the API directly, the problem is solved. These wrappers can, for example, be implemented as in &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt;.</source>
          <target state="translated">Al empaquetar la API con funciones que &lt;code&gt;erlang:now/0&lt;/code&gt; a erlang: now / 0 cuando la nueva API no est&amp;aacute; disponible, y usar estos contenedores en lugar de usar la API directamente, el problema est&amp;aacute; resuelto. Estos contenedores se pueden implementar, por ejemplo, como en &lt;code&gt;$ERL_TOP/erts/example/time_compat.erl&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00bf079d821f3a0145d168bfcf76ce42b727b9c4" translate="yes" xml:space="preserve">
          <source>Bypass all messages to the receiving process.</source>
          <target state="translated">Desvíe todos los mensajes al proceso de recepción.</target>
        </trans-unit>
        <trans-unit id="0cfa66375624ff2bee2fec17b2715898b2615b30" translate="yes" xml:space="preserve">
          <source>Bypass the native code compilation of some key files that Dialyzer heuristically performs when dialyzing many files. This avoids the compilation time, but can result in (much) longer analysis time.</source>
          <target state="translated">Evita la compilación de código nativo de algunos archivos clave que Dialyzer realiza heurísticamente cuando dializa muchos archivos.Esto evita el tiempo de compilación,pero puede resultar en un tiempo de análisis (mucho)más largo.</target>
        </trans-unit>
        <trans-unit id="ed612f8fe61f0988ef76386aa7006b8a480853b5" translate="yes" xml:space="preserve">
          <source>Byte Order Marks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eed4df1a2c0521e891f717551aca2cc2df95a04a" translate="yes" xml:space="preserve">
          <source>Bytes that are out of the range 0x2A, 0x2D, 0x2E, 0x30 to 0x39, 0x41 to 0x5A, 0x5F, 0x61 to 0x7A, are percent-encoded (U+0025 PERCENT SIGN character (%) followed by uppercase ASCII hex digits representing the hexadecimal value of the byte).</source>
          <target state="translated">Los bytes que están fuera del rango 0x2A,0x2D,0x2E,0x30 a 0x39,0x41 a 0x5A,0x5F,0x61 a 0x7A,están codificados como porcentaje (carácter U+0025 PERCENT SIGN (%)seguido de dígitos hexadecimales ASCII en mayúsculas que representan el valor hexadecimal del byte).</target>
        </trans-unit>
        <trans-unit id="0ca15868aa5caba5cda8401a4c79d41061a3d6a4" translate="yes" xml:space="preserve">
          <source>Bytes written to the file by any means are translated to UTF-8 encoding before being stored on the disk file.</source>
          <target state="translated">Los bytes escritos en el archivo por cualquier medio se traducen a la codificación UTF-8 antes de ser almacenados en el archivo del disco.</target>
        </trans-unit>
        <trans-unit id="32096c2e0eff33d844ee6d675407ace18289357d" translate="yes" xml:space="preserve">
          <source>C</source>
          <target state="translated">C</target>
        </trans-unit>
        <trans-unit id="b723b73b1800e21096c057fb6a01f5938c1a20f5" translate="yes" xml:space="preserve">
          <source>C Library</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf32b3ba375bfb965d1f8f4ebf787e42c9dc1ea" translate="yes" xml:space="preserve">
          <source>C Nodes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e48d8a1314ac59090c047f1cace030d6174ffe04" translate="yes" xml:space="preserve">
          <source>C nodes can also register themselves with &lt;code&gt;epmd&lt;/code&gt; if they want other nodes in the system to be able to find and connect to them.</source>
          <target state="translated">Los nodos C tambi&amp;eacute;n pueden registrarse con &lt;code&gt;epmd&lt;/code&gt; si quieren que otros nodos del sistema puedan encontrarlos y conectarse a ellos.</target>
        </trans-unit>
        <trans-unit id="7aaca542e8937ae72090fdd955fe659422678461" translate="yes" xml:space="preserve">
          <source>C-Left</source>
          <target state="translated">C-Left</target>
        </trans-unit>
        <trans-unit id="e2bb854461c349ecc3ae2bfb00ac6727ba113ad8" translate="yes" xml:space="preserve">
          <source>C-Right</source>
          <target state="translated">C-Right</target>
        </trans-unit>
        <trans-unit id="015b01935f205cea280aafb1b1c1757c49bc1bf4" translate="yes" xml:space="preserve">
          <source>C-]</source>
          <target state="translated">C-]</target>
        </trans-unit>
        <trans-unit id="3bff8fb1aa290267671b1c50e3b32db24f00b295" translate="yes" xml:space="preserve">
          <source>C-a</source>
          <target state="translated">C-a</target>
        </trans-unit>
        <trans-unit id="c204a76fc3c1123c96b13dd7ec922d02d4b00e91" translate="yes" xml:space="preserve">
          <source>C-b</source>
          <target state="translated">C-b</target>
        </trans-unit>
        <trans-unit id="1d8e75405de8be939b05db3eef9ab4daa516674d" translate="yes" xml:space="preserve">
          <source>C-d</source>
          <target state="translated">C-d</target>
        </trans-unit>
        <trans-unit id="a7ef1e89e28b60bd53a0a5ab746fbcd131fdf224" translate="yes" xml:space="preserve">
          <source>C-e</source>
          <target state="translated">C-e</target>
        </trans-unit>
        <trans-unit id="dd71d43937255c2ba419c077fa824865f8267186" translate="yes" xml:space="preserve">
          <source>C-f</source>
          <target state="translated">C-f</target>
        </trans-unit>
        <trans-unit id="a6d13ed5d2d00101157246b7ae1e91a19d7d7406" translate="yes" xml:space="preserve">
          <source>C-g</source>
          <target state="translated">C-g</target>
        </trans-unit>
        <trans-unit id="d5eeac2f32301e2b964f421e02a44c5afa000881" translate="yes" xml:space="preserve">
          <source>C-k</source>
          <target state="translated">C-k</target>
        </trans-unit>
        <trans-unit id="2fef5b5a274737535a312ecc5d6b8de717c1cb77" translate="yes" xml:space="preserve">
          <source>C-l</source>
          <target state="translated">C-l</target>
        </trans-unit>
        <trans-unit id="aa3408adf600065cf33c17971e8cdd9f76e5d785" translate="yes" xml:space="preserve">
          <source>C-n</source>
          <target state="translated">C-n</target>
        </trans-unit>
        <trans-unit id="332268c029d8126391ff9151361238bdf44870d8" translate="yes" xml:space="preserve">
          <source>C-p</source>
          <target state="translated">C-p</target>
        </trans-unit>
        <trans-unit id="68b4cf03a08cd7bf7acc0d39d68cca6ef0f409f3" translate="yes" xml:space="preserve">
          <source>C-t</source>
          <target state="translated">C-t</target>
        </trans-unit>
        <trans-unit id="ac7de9aff7d0daffb3ae53140a783f411f89c587" translate="yes" xml:space="preserve">
          <source>C-u</source>
          <target state="translated">C-u</target>
        </trans-unit>
        <trans-unit id="8e0be97e2cc76979d93e15014888863a6e79a7af" translate="yes" xml:space="preserve">
          <source>C-w</source>
          <target state="translated">C-w</target>
        </trans-unit>
        <trans-unit id="f286461016d3e4db77e8a575a1f55b2d71886961" translate="yes" xml:space="preserve">
          <source>C-y</source>
          <target state="translated">C-y</target>
        </trans-unit>
        <trans-unit id="8bcd80750450915a11400a818b9b66c894b79ce2" translate="yes" xml:space="preserve">
          <source>C. J. Cheney. A nonrecursive list compacting algorithm. Commun. ACM, 13(11):677&amp;ndash;678, Nov. 1970.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="27ae2e5d9b51df18972eb310bdefaba625476830" translate="yes" xml:space="preserve">
          <source>CEA is sent and received by diameter.</source>
          <target state="translated">El CEA se envía y se recibe por diámetro.</target>
        </trans-unit>
        <trans-unit id="ff534b0e9ae18ae782f79e9fe262a000f3c6ff49" translate="yes" xml:space="preserve">
          <source>CER is sent and received by diameter.</source>
          <target state="translated">El CER se envía y se recibe por diámetro.</target>
        </trans-unit>
        <trans-unit id="dc47309cd47139b3a06fa2c74bdb7d228d8051f1" translate="yes" xml:space="preserve">
          <source>CGI Version 1.1, RFC 3875</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="112d72d949c9bbe40789456cde8492d907b63e28" translate="yes" xml:space="preserve">
          <source>CHARACTER (size), CHAR (size)</source>
          <target state="translated">CARÁCTER (tamaño),CHAR (tamaño)</target>
        </trans-unit>
        <trans-unit id="24ecce9e5657a884a70aea047867075f09d39ad6" translate="yes" xml:space="preserve">
          <source>CHARACTER VARYING(size), CHAR VARYING(size)</source>
          <target state="translated">CARACTERES VARIANTES (tamaño),CARES VARIANTES (tamaño)</target>
        </trans-unit>
        <trans-unit id="c58d76589eba57b4dea4b621e7f3e9e5e0856e8f" translate="yes" xml:space="preserve">
          <source>CMAC</source>
          <target state="translated">CMAC</target>
        </trans-unit>
        <trans-unit id="af34028d9d3b30dd0a7cd2e8ede32a3c41ceeef2" translate="yes" xml:space="preserve">
          <source>CMAC with the following ciphers are available with OpenSSL 1.0.1 or later if not disabled by configuration.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
