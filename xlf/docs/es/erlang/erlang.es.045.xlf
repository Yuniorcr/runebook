<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="erlang">
    <body>
      <group id="erlang">
        <trans-unit id="94ae17188be414c8f3700fb89b358ab0b027a799" translate="yes" xml:space="preserve">
          <source>Use maps instead of records to represent the &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; types. No &lt;code&gt;.hrl&lt;/code&gt; files will be generated. See the Section &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt; Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66df33ce491bfcd444a606b910f4cb9ff07688b9" translate="yes" xml:space="preserve">
          <source>Use maps instead of records to represent the &lt;code&gt;SEQUENCE&lt;/code&gt; and &lt;code&gt;SET&lt;/code&gt; types. No &lt;code&gt;.hrl&lt;/code&gt; files will be generated. See the Section &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; for more information.</source>
          <target state="translated">Utilice mapas en lugar de registros para representar los tipos &lt;code&gt;SEQUENCE&lt;/code&gt; y &lt;code&gt;SET&lt;/code&gt; . No se &lt;code&gt;.hrl&lt;/code&gt; archivos .hrl . Consulte la &lt;code&gt;&lt;a href=&quot;asn1_getting_started#MAP_SEQ_SET&quot;&gt;Map representation for SEQUENCE and SET&lt;/a&gt;&lt;/code&gt; secci&amp;oacute;n para SEQUENCE y SET para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d6e7a5bbaac2fe1d22a38124df53d79bef29a950" translate="yes" xml:space="preserve">
          <source>Use of the &lt;code&gt;killproc&lt;/code&gt; procedure in the above script can be combined with a call to &lt;code&gt;erl_call&lt;/code&gt;, for example:</source>
          <target state="translated">El uso del procedimiento &lt;code&gt;killproc&lt;/code&gt; en el script anterior se puede combinar con una llamada a &lt;code&gt;erl_call&lt;/code&gt; , por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b3ca6ef9bc0eb0fd175268e16b224fb66ca6f3fe" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to receive messages:</source>
          <target state="translated">Utilice una de las dos funciones siguientes para recibir mensajes:</target>
        </trans-unit>
        <trans-unit id="889a7015472f4f91d80360afa19301c38e311202" translate="yes" xml:space="preserve">
          <source>Use one of the following two functions to send messages:</source>
          <target state="translated">Utilice una de las dos funciones siguientes para enviar mensajes:</target>
        </trans-unit>
        <trans-unit id="4154e7c45ed1c09b28a8e036ce840111c118baa6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; to name directories to be searched for application files (equivalent to the &lt;code&gt;path&lt;/code&gt; in the option list for &lt;code&gt;systools:make_script/2&lt;/code&gt;).</source>
          <target state="translated">Utilice la opci&amp;oacute;n &lt;code&gt;-I&lt;/code&gt; para nombrar los directorios en los que se &lt;code&gt;systools:make_script/2&lt;/code&gt; archivos de la aplicaci&amp;oacute;n (equivalente a la &lt;code&gt;path&lt;/code&gt; en la lista de opciones para systools: make_script / 2 ).</target>
        </trans-unit>
        <trans-unit id="0c5e91c4910f51c44ca054a05924c3387fce83e6" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;-I&lt;/code&gt; with the name of a file to use that file as a customized prologue file (option &lt;code&gt;includefile&lt;/code&gt;).</source>
          <target state="translated">Use la opci&amp;oacute;n &lt;code&gt;-I&lt;/code&gt; con el nombre de un archivo para usar ese archivo como un archivo de pr&amp;oacute;logo personalizado (opci&amp;oacute;n &lt;code&gt;includefile&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d55bb82b3630e22429844da6211b0339bba98ea8" translate="yes" xml:space="preserve">
          <source>Use option &lt;code&gt;strong_validation&lt;/code&gt; to generate all warnings that the compiler would generate.</source>
          <target state="translated">Utilice la opci&amp;oacute;n &lt;code&gt;strong_validation&lt;/code&gt; para generar todas las advertencias que generar&amp;iacute;a el compilador.</target>
        </trans-unit>
        <trans-unit id="7937b3339663cb4514ac276573d7e2c9e0dfd606" translate="yes" xml:space="preserve">
          <source>Use relaxed command checking only on systems with very limited interactive usage.</source>
          <target state="translated">Utilice la comprobación de comandos relajados sólo en sistemas con un uso interactivo muy limitado.</target>
        </trans-unit>
        <trans-unit id="7e8be1e3581d1297371b0474f66ebe7774bd9957" translate="yes" xml:space="preserve">
          <source>Use script &lt;code&gt;etop&lt;/code&gt;.</source>
          <target state="translated">Utilice el script &lt;code&gt;etop&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecdd13a57f7a43ae5c5be43fc2ede21e975f620a" translate="yes" xml:space="preserve">
          <source>Use selective decode instead of exclusive decode if you are interested in only a single subvalue.</source>
          <target state="translated">Utilice la decodificación selectiva en lugar de la decodificación exclusiva si está interesado en un solo subvalor.</target>
        </trans-unit>
        <trans-unit id="24a48f85522c3c675cca203ceb229fa7527ddbde" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;&lt;a href=&quot;#compile_server&quot;&gt;compile server&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc5a942c59a4e030f1c2785f2614bd8aa51f00a" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;PAYLOAD_EXIT&lt;/code&gt;, &lt;code&gt;PAYLOAD_EXIT_TT&lt;/code&gt;, &lt;code&gt;PAYLOAD_EXIT2&lt;/code&gt;, &lt;code&gt;PAYLOAD_EXIT2_TT&lt;/code&gt; and &lt;code&gt;PAYLOAD_MONITOR_P_EXIT&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt;s instead of the non-PAYLOAD variants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc8ad2b93f84080dbc37116f7108a665d7b55ac" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;SEND_SENDER&lt;/code&gt;&lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; instead of the &lt;code&gt;SEND&lt;/code&gt; control message and use the &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; control message instead of the &lt;code&gt;SEND_TT&lt;/code&gt; control message.</source>
          <target state="translated">Utilice el &lt;code&gt;&lt;a href=&quot;#control_message&quot;&gt;control message&lt;/a&gt;&lt;/code&gt; &lt;code&gt;SEND_SENDER&lt;/code&gt; en lugar del mensaje de control &lt;code&gt;SEND&lt;/code&gt; y utilice el mensaje de control &lt;code&gt;SEND_SENDER_TT&lt;/code&gt; en lugar del mensaje de control &lt;code&gt;SEND_TT&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0eb13f68ed22ba4a08751c4363250d2b2b3fba90" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;bin_opt_info&lt;/code&gt; option to have the compiler print a lot of information about binary optimizations. It can be given either to the compiler or &lt;code&gt;erlc&lt;/code&gt;:</source>
          <target state="translated">Utilice la opci&amp;oacute;n &lt;code&gt;bin_opt_info&lt;/code&gt; para que el compilador imprima mucha informaci&amp;oacute;n sobre optimizaciones binarias. Se le puede dar al compilador o al &lt;code&gt;erlc&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2c30d8bd130bb93833dc88f2efb2369af2066111" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;file&lt;/code&gt; module for files opened for bytewise access (&lt;code&gt;{encoding,latin1}&lt;/code&gt;).</source>
          <target state="translated">Use el m&amp;oacute;dulo de &lt;code&gt;file&lt;/code&gt; para archivos abiertos para acceso por bytes ( &lt;code&gt;{encoding,latin1}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="cec2d14858ca56aa4886d5cb596e4d1c4389bb5d" translate="yes" xml:space="preserve">
          <source>Use the &lt;code&gt;io&lt;/code&gt; module when accessing files with any other encoding (for example &lt;code&gt;{encoding,uf8}&lt;/code&gt;).</source>
          <target state="translated">Utilice el m&amp;oacute;dulo &lt;code&gt;io&lt;/code&gt; cuando acceda a archivos con cualquier otra codificaci&amp;oacute;n (por ejemplo, &lt;code&gt;{encoding,uf8}&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="9e21bc6d17c5f3138b318feb1664293ef1335717" translate="yes" xml:space="preserve">
          <source>Use the GUI.</source>
          <target state="translated">Usa la interfaz gráfica de usuario.</target>
        </trans-unit>
        <trans-unit id="e3f1aa1f6c936dd4bbcc665fff827922973d80d2" translate="yes" xml:space="preserve">
          <source>Use the following command to generate a .hrl file from an MIB:</source>
          <target state="translated">Use el siguiente comando para generar un archivo .hrl a partir de un MIB:</target>
        </trans-unit>
        <trans-unit id="285645e77ad81adce8bdc1256d83d49b2f715165" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described here and in the User's Guide:</source>
          <target state="translated">Utilice la siguiente directiva de inclusión para obtener acceso a los registros y macros constantes descritos aquí y en la Guía del usuario:</target>
        </trans-unit>
        <trans-unit id="26340e5bfdecd44f5d627a8bf499337d449c9b39" translate="yes" xml:space="preserve">
          <source>Use the following include directive to get access to the records and constant macros described in the following sections:</source>
          <target state="translated">Utilice la siguiente directiva de inclusión para obtener acceso a los registros y macros constantes descritos en las siguientes secciones:</target>
        </trans-unit>
        <trans-unit id="eaf38e520f81f823bc5c2944fc89ede2ea27b2c7" translate="yes" xml:space="preserve">
          <source>Use the function &lt;code&gt;mnesia:change_table_frag/2&lt;/code&gt; to add new fragments and apply the usual schema manipulation functions (such as &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt;) on each fragment to perform the actual redistribution.</source>
          <target state="translated">Utilice la funci&amp;oacute;n &lt;code&gt;mnesia:change_table_frag/2&lt;/code&gt; para agregar nuevos fragmentos y aplique las funciones habituales de manipulaci&amp;oacute;n de esquemas (como &lt;code&gt;&lt;a href=&quot;mnesia#add_table_copy-3&quot;&gt;mnesia:add_table_copy/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;mnesia#del_table_copy-2&quot;&gt;mnesia:del_table_copy/2&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/2&lt;/a&gt;&lt;/code&gt; ) en cada fragmento para realizar la redistribuci&amp;oacute;n real.</target>
        </trans-unit>
        <trans-unit id="81d58859492a0e6cf67a695fecde344397df4fa0" translate="yes" xml:space="preserve">
          <source>Use the function describe_table/[2,3] to find out which ODBC data type that is expected for each column of that table. If a column has a data type that is described with capital letters, alas it is not currently supported by the param_query function. Too know which Erlang data type corresponds to an ODBC data type see the Erlang to ODBC data type &lt;code&gt;&lt;a href=&quot;databases#type&quot;&gt;mapping&lt;/a&gt;&lt;/code&gt; in the User's Guide.</source>
          <target state="translated">Utilice la funci&amp;oacute;n describe_table / [2,3] para averiguar qu&amp;eacute; tipo de datos ODBC se espera para cada columna de esa tabla. Si una columna tiene un tipo de datos que se describe con letras may&amp;uacute;sculas, lamentablemente no es compatible actualmente con la funci&amp;oacute;n param_query. Para saber qu&amp;eacute; tipo de datos de Erlang corresponde a un tipo de datos ODBC, consulte la &lt;code&gt;&lt;a href=&quot;databases#type&quot;&gt;mapping&lt;/a&gt;&lt;/code&gt; tipos de datos de Erlang a ODBC en la Gu&amp;iacute;a del usuario.</target>
        </trans-unit>
        <trans-unit id="6e938f8eaaf7a2fb5db93a5741c75b6c3d2b1e56" translate="yes" xml:space="preserve">
          <source>Use the functional API with a non-constant seed:</source>
          <target state="translated">Usar el API funcional con una semilla no constante:</target>
        </trans-unit>
        <trans-unit id="541ddc36dcd95bdf4f3b7b106057bafcf839da79" translate="yes" xml:space="preserve">
          <source>Use the map in the ssl key option:</source>
          <target state="translated">Utilice el mapa en la opción de la tecla ssl:</target>
        </trans-unit>
        <trans-unit id="8bedd4105b0c918e36403c94a86cea217070bfac" translate="yes" xml:space="preserve">
          <source>Use the same Erlang types to represent &lt;code&gt;BIT STRING&lt;/code&gt; and &lt;code&gt;OCTET STRING&lt;/code&gt; as in OTP R16.</source>
          <target state="translated">Utilice los mismos tipos de Erlang para representar &lt;code&gt;BIT STRING&lt;/code&gt; y &lt;code&gt;OCTET STRING&lt;/code&gt; que en OTP R16.</target>
        </trans-unit>
        <trans-unit id="2b8bf9ebaa15f0fd8cafa74076170d6b2f131de7" translate="yes" xml:space="preserve">
          <source>Use the socket option &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt; {packet, N}&lt;/a&gt;&lt;/code&gt; (or something similar) to make it possible for the receiver to close the connection when it knowns it has received all the data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="203bf7370538dd892cf94b38b1e17b25aedb4cc9" translate="yes" xml:space="preserve">
          <source>Use the socket option &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt;{packet, N}&lt;/a&gt;&lt;/code&gt; (or something similar) to make it possible for the receiver to close the connection when it knowns it has received all the data.</source>
          <target state="translated">Utilice la opci&amp;oacute;n de socket &lt;code&gt;&lt;a href=&quot;inet#packet&quot;&gt;{packet, N}&lt;/a&gt;&lt;/code&gt; (o algo similar) para que el receptor pueda cerrar la conexi&amp;oacute;n cuando sepa que ha recibido todos los datos.</target>
        </trans-unit>
        <trans-unit id="57d720aadc70a1b56241025a699cc74ef9ea249d" translate="yes" xml:space="preserve">
          <source>Use the specified PLT as the initial PLT. If the PLT was built during setup, the files are checked for consistency.</source>
          <target state="translated">Usar el PLT especificado como el PLT inicial.Si el PLT se construyó durante la configuración,se comprueba la consistencia de los archivos.</target>
        </trans-unit>
        <trans-unit id="23a325631bef6112525e951a3d4952dbdf388985" translate="yes" xml:space="preserve">
          <source>Use the value returned from &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt; erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; to create a name unique on the current runtime system instance. If you only want positive integers, you can use &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt; erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ad77542229ec1d771e4e02b6524ee184d641040" translate="yes" xml:space="preserve">
          <source>Use the value returned from &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt;erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; to create a name unique on the current runtime system instance. If you only want positive integers, you can use &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Utilice el valor devuelto por &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-0&quot;&gt;erlang:unique_integer/0&lt;/a&gt;&lt;/code&gt; para crear un nombre &amp;uacute;nico en la instancia actual del sistema en tiempo de ejecuci&amp;oacute;n. Si solo desea n&amp;uacute;meros enteros positivos, puede usar &lt;code&gt;&lt;a href=&quot;erlang#unique_integer-1&quot;&gt;erlang:unique_integer([positive])&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3e36f8f2cb8b647a47cca517ff03d541469491a2" translate="yes" xml:space="preserve">
          <source>Use the values returned from &lt;code&gt;erlang:now/0&lt;/code&gt; to create a name unique on the current runtime system instance.</source>
          <target state="translated">Utilice los valores devueltos por &lt;code&gt;erlang:now/0&lt;/code&gt; para crear un nombre &amp;uacute;nico en la instancia actual del sistema en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5a1a3d93db801fcbd6f501d39eac8cc569d5150c" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure, and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n despu&amp;eacute;s de una llamada al sistema fallida. El mensaje proporcionado por la persona que llama se imprime seguido de una cadena que describe el motivo de la falla y el proceso termina con el valor de salida &lt;code&gt;1&lt;/code&gt; . Esta funci&amp;oacute;n no regresa.</target>
        </trans-unit>
        <trans-unit id="60cd4eee7b91477f96873aee8f0c08a0e1659942" translate="yes" xml:space="preserve">
          <source>Use this function after a failed system call. The message provided by the caller is printed followed by a string describing the reason for failure.</source>
          <target state="translated">Utilice esta función después de una llamada de sistema fallida.Se imprime el mensaje proporcionado por la persona que llama seguido de una cadena que describe el motivo del fallo.</target>
        </trans-unit>
        <trans-unit id="ac3be946393c47f35eede2756d19558abc69e73e" translate="yes" xml:space="preserve">
          <source>Use this function only if you know what you are doing, that is, on your own applications. It is very application-dependent and configuration parameter-dependent when and how often the value is read by the application. Careless use of this function can put the application in a weird, inconsistent, and malfunctioning state.</source>
          <target state="translated">Utilice esta función sólo si sabe lo que está haciendo,es decir,en sus propias aplicaciones.Depende mucho de la aplicación y de los parámetros de configuración cuando y con qué frecuencia el valor es leído por la aplicación.El uso descuidado de esta función puede poner a la aplicación en un estado extraño,inconsistente y de mal funcionamiento.</target>
        </trans-unit>
        <trans-unit id="8d1a6a43cff399c18914850f099af42f99ff52a6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; a specific match specification saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n para &quot;olvidar&quot; una especificaci&amp;oacute;n de coincidencia espec&amp;iacute;fica guardada durante las llamadas a &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b6bca535e578b8f96edf192f36e88f0568555ba6" translate="yes" xml:space="preserve">
          <source>Use this function to &quot;forget&quot; all match specifications saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;. This is useful when one wants to restore other match specifications from a file with &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt;. Use &lt;code&gt;&lt;a href=&quot;#dtp-1&quot;&gt;dtp/1&lt;/a&gt;&lt;/code&gt; to delete specific saved match specifications.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n para &quot;olvidar&quot; todas las especificaciones de coincidencia guardadas durante las llamadas a &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; . Esto es &amp;uacute;til cuando se desea restaurar otras especificaciones de coincidencia desde un archivo con &lt;code&gt;&lt;a href=&quot;#rtp-1&quot;&gt;rtp/1&lt;/a&gt;&lt;/code&gt; . Utilice &lt;code&gt;&lt;a href=&quot;#dtp-1&quot;&gt;dtp/1&lt;/a&gt;&lt;/code&gt; para eliminar especificaciones de coincidencias guardadas espec&amp;iacute;ficas.</target>
        </trans-unit>
        <trans-unit id="d051de59e60744864ad96b5d4970120ccdf3ce13" translate="yes" xml:space="preserve">
          <source>Use this function to recall all match specifications previously used in the session (i. e. previously saved during calls to &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt;, and built-in match specifications. This is very useful, as a complicated match_spec can be quite awkward to write. Note that the match specifications are lost if &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n para recuperar todas las especificaciones de coincidencia utilizadas anteriormente en la sesi&amp;oacute;n (es decir, guardadas previamente durante las llamadas a &lt;code&gt;&lt;a href=&quot;#tp-2&quot;&gt;tp/2&lt;/a&gt;&lt;/code&gt; , y especificaciones de coincidencia integradas. Esto es muy &amp;uacute;til, ya que una especificaci&amp;oacute;n de coincidencia complicada puede ser bastante inc&amp;oacute;moda de escribir. Tenga en cuenta que la las especificaciones de coincidencia se pierden si se llama a &lt;code&gt;&lt;a href=&quot;#stop-0&quot;&gt;stop/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2f20da1728d7b0010525545f9f1f93fe66b04dcf" translate="yes" xml:space="preserve">
          <source>Use this function to set, or modify, the verbosity level for a logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt; User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to set the general verbosity level.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c941b9c92bccb005e3755850980e1a4c93df1aed" translate="yes" xml:space="preserve">
          <source>Use this function to set, or modify, the verbosity level for a logging category. See the &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; for details. Use the value &lt;code&gt;default&lt;/code&gt; to set the general verbosity level.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n para establecer o modificar el nivel de verbosidad de una categor&amp;iacute;a de registro. Consulte la &lt;code&gt;&lt;a href=&quot;write_test_chapter#logging&quot;&gt;User's Guide&lt;/a&gt;&lt;/code&gt; para obtener m&amp;aacute;s detalles. Utilice el valor &lt;code&gt;default&lt;/code&gt; para establecer el nivel de verbosidad general.</target>
        </trans-unit>
        <trans-unit id="cb4f981450d616f53002b2dbe1a22bf77c775fe2" translate="yes" xml:space="preserve">
          <source>Use this function when a fatal error has occurred that is not because of a system call. The message provided by the caller is printed and the process terminates with exit value &lt;code&gt;1&lt;/code&gt;. This function does not return.</source>
          <target state="translated">Utilice esta funci&amp;oacute;n cuando haya ocurrido un error fatal que no se deba a una llamada al sistema. El mensaje proporcionado por la persona que llama se imprime y el proceso termina con el valor de salida &lt;code&gt;1&lt;/code&gt; . Esta funci&amp;oacute;n no regresa.</target>
        </trans-unit>
        <trans-unit id="927c6ba6b883da5a944bc17195e2455b95cac07d" translate="yes" xml:space="preserve">
          <source>Use this function with extreme caution, as it makes existing persistent data obsolete. Think twice before using it.</source>
          <target state="translated">Utilice esta función con extrema precaución,ya que hace que los datos persistentes existentes sean obsoletos.Piénselo dos veces antes de usarla.</target>
        </trans-unit>
        <trans-unit id="03f95d87f375280efaeeb6fe8cafb649410d718d" translate="yes" xml:space="preserve">
          <source>Use this module to set up Telnet connections, send commands, and perform string matching on the result. For information about how to use &lt;code&gt;ct_telnet&lt;/code&gt; and configure connections, specifically for UNIX hosts, see the &lt;code&gt;&lt;a href=&quot;unix_telnet&quot;&gt;unix_telnet&lt;/a&gt;&lt;/code&gt; manual page.</source>
          <target state="translated">Utilice este m&amp;oacute;dulo para configurar conexiones Telnet, enviar comandos y realizar una coincidencia de cadenas en el resultado. Para obtener informaci&amp;oacute;n sobre c&amp;oacute;mo utilizar &lt;code&gt;ct_telnet&lt;/code&gt; y configurar conexiones, espec&amp;iacute;ficamente para hosts UNIX, consulte la p&amp;aacute;gina de manual de &lt;code&gt;&lt;a href=&quot;unix_telnet&quot;&gt;unix_telnet&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d5d50bad282c0804f9a7e02550f10159ee185809" translate="yes" xml:space="preserve">
          <source>Use this option when receiving binaries from an untrusted source.</source>
          <target state="translated">Utilice esta opción cuando reciba binarios de una fuente no confiable.</target>
        </trans-unit>
        <trans-unit id="01f5382feca2bb4947c345ec5297001b4439de6e" translate="yes" xml:space="preserve">
          <source>Use with extreme care.</source>
          <target state="translated">Usar con extremo cuidado.</target>
        </trans-unit>
        <trans-unit id="926a25ba00ec3f71fce83c4ae2a582227ec44542" translate="yes" xml:space="preserve">
          <source>Used BIFs. &lt;code&gt;B&lt;/code&gt; is empty if &lt;code&gt;builtins&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt; for all analyzed modules.</source>
          <target state="translated">BIF usados. &lt;code&gt;B&lt;/code&gt; est&amp;aacute; vac&amp;iacute;o si las &lt;code&gt;builtins&lt;/code&gt; son &lt;code&gt;false&lt;/code&gt; para todos los m&amp;oacute;dulos analizados.</target>
        </trans-unit>
        <trans-unit id="c11ee9255f50f3fa3a1ac060817b8601274af33d" translate="yes" xml:space="preserve">
          <source>Used Library Modules.</source>
          <target state="translated">Módulos de biblioteca usados.</target>
        </trans-unit>
        <trans-unit id="f2aba5aee8ae8ee86804bcb14e53b26b3dd95541" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt; enif_system_info&lt;/a&gt;&lt;/code&gt; to return information about the runtime system. Contains the same content as &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt; ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaea96d1f0adade7428605a5b6a71a977e21c17f" translate="yes" xml:space="preserve">
          <source>Used by &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info&lt;/a&gt;&lt;/code&gt; to return information about the runtime system. Contains the same content as &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Utilizado por &lt;code&gt;&lt;a href=&quot;#enif_system_info&quot;&gt;enif_system_info&lt;/a&gt;&lt;/code&gt; para devolver informaci&amp;oacute;n sobre el sistema en tiempo de ejecuci&amp;oacute;n. Contiene el mismo contenido que &lt;code&gt;&lt;a href=&quot;erl_driver#ErlDrvSysInfo&quot;&gt;ErlDrvSysInfo&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="42d74dbb12b0fb1f6ea1d95300289917f6910dc7" translate="yes" xml:space="preserve">
          <source>Used by a process to redefine the error handler for undefined function calls and undefined registered processes. Inexperienced users are not to use this flag, as code auto-loading depends on the correct operation of the error handling module.</source>
          <target state="translated">Utilizado por un proceso para redefinir el manejador de errores para llamadas a funciones no definidas y procesos registrados no definidos.Los usuarios inexpertos no deben utilizar este indicador,ya que la carga automática de códigos depende del correcto funcionamiento del módulo de tratamiento de errores.</target>
        </trans-unit>
        <trans-unit id="021e8894d4cd8efeb3800e902cce4283561eaa59" translate="yes" xml:space="preserve">
          <source>Used by a server process to accept a connection from a client process.</source>
          <target state="translated">Utilizado por un proceso servidor para aceptar una conexión de un proceso cliente.</target>
        </trans-unit>
        <trans-unit id="6c49623f58e59d8735fea69dd29c4f20e63decdd" translate="yes" xml:space="preserve">
          <source>Used by a server process to register with the local name server EPMD, thereby allowing other processes to send messages by using the registered name. Before calling either of these functions, the process should have called &lt;code&gt;bind()&lt;/code&gt; and &lt;code&gt;listen()&lt;/code&gt; on an open socket.</source>
          <target state="translated">Utilizado por un proceso de servidor para registrarse con el servidor de nombres local EPMD, permitiendo as&amp;iacute; que otros procesos env&amp;iacute;en mensajes utilizando el nombre registrado. Antes de llamar a cualquiera de estas funciones, el proceso deber&amp;iacute;a haber llamado a &lt;code&gt;bind()&lt;/code&gt; y &lt;code&gt;listen()&lt;/code&gt; en un socket abierto.</target>
        </trans-unit>
        <trans-unit id="b328120a25406cfa5be9b6c7e4c0d4da319fda04" translate="yes" xml:space="preserve">
          <source>Used by a server process to setup a listen socket which later can be used for accepting connections from client processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5237d3789fea5df1f7ffca0fba9777e1547c1e" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Size&lt;/code&gt; is an expression that is to evaluate to an integer.</source>
          <target state="translated">Usado en una construcci&amp;oacute;n de cadena de bits, &lt;code&gt;Size&lt;/code&gt; es una expresi&amp;oacute;n que se eval&amp;uacute;a como un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="a7cde552a3551769508a6d34af2b5b84e289881d" translate="yes" xml:space="preserve">
          <source>Used in a bit string construction, &lt;code&gt;Value&lt;/code&gt; is an expression that is to evaluate to an integer, float, or bit string. If the expression is not a single literal or variable, it is to be enclosed in parentheses.</source>
          <target state="translated">Utilizado en una construcci&amp;oacute;n de cadena de bits, &lt;code&gt;Value&lt;/code&gt; es una expresi&amp;oacute;n que se eval&amp;uacute;a como una cadena de bits, flotante o entero. Si la expresi&amp;oacute;n no es un solo literal o variable, debe incluirse entre par&amp;eacute;ntesis.</target>
        </trans-unit>
        <trans-unit id="319d7a71912a6a421ba26d32164c23729df90f10" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Size&lt;/code&gt; must be a &lt;code&gt;&lt;a href=&quot;#guard_expressions&quot;&gt;guard expression&lt;/a&gt;&lt;/code&gt; that evaluates to an integer. All variables in the guard expression must be already bound.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7fa51f6619aef90e556b2317c4e8c8b56b58094" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Size&lt;/code&gt; must be an integer, or a variable bound to an integer.</source>
          <target state="translated">Usado en una coincidencia de cadenas de bits, &lt;code&gt;Size&lt;/code&gt; debe ser un n&amp;uacute;mero entero o una variable vinculada a un n&amp;uacute;mero entero.</target>
        </trans-unit>
        <trans-unit id="a2ea25edea36db50d30cde55ba8333dc776429fb" translate="yes" xml:space="preserve">
          <source>Used in a bit string matching, &lt;code&gt;Value&lt;/code&gt; must be a variable, or an integer, float, or string.</source>
          <target state="translated">Usado en una coincidencia de cadenas de bits, el &lt;code&gt;Value&lt;/code&gt; debe ser una variable o un entero, flotante o cadena.</target>
        </trans-unit>
        <trans-unit id="00b8635528024d62633ce26ebc8ade8bf9cf1f13" translate="yes" xml:space="preserve">
          <source>Used in socket close message.</source>
          <target state="translated">Se utiliza en el mensaje de cierre de socorro.</target>
        </trans-unit>
        <trans-unit id="37771a4a8b87640f401b1b514090e62c25bfd4a6" translate="yes" xml:space="preserve">
          <source>Used in socket data message.</source>
          <target state="translated">Se utiliza en el mensaje de datos del zócalo.</target>
        </trans-unit>
        <trans-unit id="94de0e417f3f0b14c77f33a57c9b9d9d4a4e16c3" translate="yes" xml:space="preserve">
          <source>Used to perform codec measurements. That is, to see what kind of performance can be expected by the different codecs provided by the megaco application.</source>
          <target state="translated">Se utiliza para realizar mediciones de códecs.Es decir,para ver qué tipo de rendimiento se puede esperar de los diferentes códecs proporcionados por la aplicación megaco.</target>
        </trans-unit>
        <trans-unit id="c90819c1d1025e50a1c34d2b3826c5ef2c0b5b68" translate="yes" xml:space="preserve">
          <source>Used to set the network namespace during the open call. Only supported on the Linux platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c84b814113321eb30117cec8f04565b7ae8fc7" translate="yes" xml:space="preserve">
          <source>Used to set tracing on the distribution. The levels are different verbosity levels. A higher level means more information. See also section &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt; Debug Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ea4aa7eefddb763ba10cb9daaf61feb433c13d7" translate="yes" xml:space="preserve">
          <source>Used to set tracing on the distribution. The levels are different verbosity levels. A higher level means more information. See also section &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt;Debug Information&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se utiliza para establecer el seguimiento de la distribuci&amp;oacute;n. Los niveles son diferentes niveles de verbosidad. Un nivel m&amp;aacute;s alto significa m&amp;aacute;s informaci&amp;oacute;n. Consulte tambi&amp;eacute;n la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#debug_information&quot;&gt;Debug Information&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="444add2c3da696b8c15c1fad22d917131601a637" translate="yes" xml:space="preserve">
          <source>Used to trigger the replay feature and indicate that the replay is to start at the time specified. If &lt;code&gt;StartTime&lt;/code&gt; is not present, this is not a replay subscription. It is not valid to specify start times that are later than the current time. If &lt;code&gt;StartTime&lt;/code&gt; is specified earlier than the log can support, the replay begins with the earliest available notification. This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0558fbc4bfc3f98f9c0aff78f8bf8c889c7ae8" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; to uniquely identify a HTTP server. This can be useful in a virtualized environment, where there can be more that one server that has the same bind_address and port. If this property is not explicitly set, it is assumed that the &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt;uniquely identifies the HTTP server.</source>
          <target state="translated">Se utiliza junto con &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; para identificar de forma exclusiva un servidor HTTP. Esto puede resultar &amp;uacute;til en un entorno virtualizado, donde puede haber m&amp;aacute;s de un servidor que tenga el mismo bind_address y puerto. Si esta propiedad no se establece expl&amp;iacute;citamente, se supone que &lt;code&gt;&lt;a href=&quot;#prop_bind_address&quot;&gt;bind_address&lt;/a&gt;&lt;/code&gt; y el &lt;code&gt;&lt;a href=&quot;#prop_port&quot;&gt;port&lt;/a&gt;&lt;/code&gt; identifican de forma exclusiva el servidor HTTP.</target>
        </trans-unit>
        <trans-unit id="770e0b9f1dc73dcbf183dcbbbc53e3cf5e4375d4" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; to uniquely identify a ssh daemon. This can be useful in a virtualized environment, where there can be more that one server that has the same &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt;. If this property is not explicitly set, it is assumed that the the &lt;code&gt;ip-address&lt;/code&gt; and &lt;code&gt;port&lt;/code&gt; uniquely identifies the SSH daemon.</source>
          <target state="translated">Se usa junto con &lt;code&gt;ip-address&lt;/code&gt; y el &lt;code&gt;port&lt;/code&gt; para identificar de forma &amp;uacute;nica un demonio ssh. Esto puede resultar &amp;uacute;til en un entorno virtualizado, donde puede haber m&amp;aacute;s de un servidor que tenga la misma &lt;code&gt;ip-address&lt;/code&gt; y &lt;code&gt;port&lt;/code&gt; . Si esta propiedad no se establece expl&amp;iacute;citamente, se asume que la &lt;code&gt;ip-address&lt;/code&gt; y el &lt;code&gt;port&lt;/code&gt; identifican de forma exclusiva el demonio SSH.</target>
        </trans-unit>
        <trans-unit id="adce6622f9543e73767624ada8f13763e382d86b" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;send_timeout&lt;/code&gt; to specify whether the socket is to be automatically closed when the send operation returns &lt;code&gt;{error,timeout}&lt;/code&gt;. The recommended setting is &lt;code&gt;true&lt;/code&gt;, which automatically closes the socket. Defaults to &lt;code&gt;false&lt;/code&gt; because of backward compatibility.</source>
          <target state="translated">Se usa junto con &lt;code&gt;send_timeout&lt;/code&gt; para especificar si el socket se cerrar&amp;aacute; autom&amp;aacute;ticamente cuando la operaci&amp;oacute;n de env&amp;iacute;o devuelva &lt;code&gt;{error,timeout}&lt;/code&gt; . La configuraci&amp;oacute;n recomendada es &lt;code&gt;true&lt;/code&gt; , que cierra autom&amp;aacute;ticamente el enchufe. El valor predeterminado es &lt;code&gt;false&lt;/code&gt; debido a la compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="07eb868bef5aa368e19bb894ec05dbc37d91a59f" translate="yes" xml:space="preserve">
          <source>Used together with &lt;code&gt;{verify, verify_peer}&lt;/code&gt; by an TLS/DTLS server. If set to &lt;code&gt;true&lt;/code&gt;, the server fails if the client does not have a certificate to send, that is, sends an empty certificate. If set to &lt;code&gt;false&lt;/code&gt;, it fails only if the client sends an invalid certificate (an empty certificate is considered valid). Defaults to false.</source>
          <target state="translated">Usado junto con &lt;code&gt;{verify, verify_peer}&lt;/code&gt; por un servidor TLS / DTLS. Si se establece en &lt;code&gt;true&lt;/code&gt; , el servidor falla si el cliente no tiene un certificado para enviar, es decir, env&amp;iacute;a un certificado vac&amp;iacute;o. Si se establece en &lt;code&gt;false&lt;/code&gt; , solo falla si el cliente env&amp;iacute;a un certificado no v&amp;aacute;lido (un certificado vac&amp;iacute;o se considera v&amp;aacute;lido). El valor predeterminado es falso.</target>
        </trans-unit>
        <trans-unit id="5ec279a6fe9dd1161f2aa08b6ed9eb431c51ce40" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; has called &lt;code&gt;seq_trace:print(Label, TraceInfo)&lt;/code&gt; and has a trace token with flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;, and &lt;code&gt;label&lt;/code&gt; set to &lt;code&gt;Label&lt;/code&gt;.</source>
          <target state="translated">Se usa cuando un proceso &lt;code&gt;From&lt;/code&gt; ha llamado a &lt;code&gt;seq_trace:print(Label, TraceInfo)&lt;/code&gt; y tiene un token de seguimiento con la &lt;code&gt;print&lt;/code&gt; bandera establecida en &lt;code&gt;true&lt;/code&gt; y la &lt;code&gt;label&lt;/code&gt; establecida en &lt;code&gt;Label&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ec8ed9ea4c0a02770b19230ee831fc7eabc65212" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; with its trace token flag &lt;code&gt;print&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; has sent a message.</source>
          <target state="translated">Se utiliza cuando un proceso &lt;code&gt;From&lt;/code&gt; con su indicador de se&amp;ntilde;al de seguimiento de &lt;code&gt;print&lt;/code&gt; establecido en &lt;code&gt;true&lt;/code&gt; ha enviado un mensaje.</target>
        </trans-unit>
        <trans-unit id="5a6c5ffbc1f01a1110cfda8597d119f7cb6deda4" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;From&lt;/code&gt; with its trace token flag &lt;code&gt;send&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt; has sent information. &lt;code&gt;To&lt;/code&gt; may be a process identifier, a registered name on a node represented as &lt;code&gt;{NameAtom, NodeAtom}&lt;/code&gt;, or a node name represented as an atom. &lt;code&gt;From&lt;/code&gt; may be a process identifier or a node name represented as an atom. &lt;code&gt;Message&lt;/code&gt; contains the information passed along in this information transfer. If the transfer is done via message passing, it is the actual message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f532ecd45390412a4c37f8eaaaf1dd3a2bc7a9e4" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;To&lt;/code&gt; receives a message with a trace token that has flag &lt;code&gt;'receive'&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Se usa cuando un proceso &lt;code&gt;To&lt;/code&gt; recibe un mensaje con un token de seguimiento que tiene el indicador &lt;code&gt;'receive'&lt;/code&gt; establecido en &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1d2aa763f5b505650b3a0a4c6cb3a9ea0e4cca03" translate="yes" xml:space="preserve">
          <source>Used when a process &lt;code&gt;To&lt;/code&gt; receives information with a trace token that has flag &lt;code&gt;'receive'&lt;/code&gt; set to &lt;code&gt;true&lt;/code&gt;. &lt;code&gt;To&lt;/code&gt; may be a process identifier, or a node name represented as an atom. &lt;code&gt;From&lt;/code&gt; may be a process identifier or a node name represented as an atom. &lt;code&gt;Message&lt;/code&gt; contains the information passed along in this information transfer. If the transfer is done via message passing, it is the actual message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed866b317195673cc57f0bfced4e8f18f9deb039" translate="yes" xml:space="preserve">
          <source>Used when a restart of the emulator is required after all other upgrade instructions are executed. For more information about this instruction, see restart_emulator (Low-Level) in &lt;code&gt;&lt;a href=&quot;release_handling#restart_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se utiliza cuando se requiere reiniciar el emulador despu&amp;eacute;s de que se hayan ejecutado todas las dem&amp;aacute;s instrucciones de actualizaci&amp;oacute;n. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre esta instrucci&amp;oacute;n, consulte restart_emulator (nivel bajo) en &lt;code&gt;&lt;a href=&quot;release_handling#restart_emulator_instr&quot;&gt;Release Handling Instructions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b51ce444943f18b5b406c12d5de312dd469de6a1" translate="yes" xml:space="preserve">
          <source>Used when connection is up.</source>
          <target state="translated">Se usa cuando la conexión está lista.</target>
        </trans-unit>
        <trans-unit id="98f3f0d6b5fe552d6fdd9e8a1ac4b1dbc95a1e0a" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. &lt;code&gt;{M, F, Arity}&lt;/code&gt; is specified instead of &lt;code&gt;{M, F, Args}&lt;/code&gt; in call trace messages.</source>
          <target state="translated">Se utiliza con la &lt;code&gt;call&lt;/code&gt; seguimiento de llamadas . &lt;code&gt;{M, F, Arity}&lt;/code&gt; se especifica en lugar de &lt;code&gt;{M, F, Args}&lt;/code&gt; en los mensajes de seguimiento de llamadas.</target>
        </trans-unit>
        <trans-unit id="35c8c1e7148c094e7f1037898138a703736b5c71" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. The &lt;code&gt;call&lt;/code&gt;, &lt;code&gt;return_from&lt;/code&gt;, and &lt;code&gt;return_to&lt;/code&gt; trace messages are inhibited if this flag is set, but they are executed as normal if there are match specifications.</source>
          <target state="translated">Se utiliza con la &lt;code&gt;call&lt;/code&gt; seguimiento de llamadas . Los mensajes &lt;code&gt;call&lt;/code&gt; , &lt;code&gt;return_from&lt;/code&gt; y &lt;code&gt;return_to&lt;/code&gt; trace se inhiben si se establece este indicador, pero se ejecutan normalmente si existen especificaciones coincidentes.</target>
        </trans-unit>
        <trans-unit id="2a44c884d9e9ccdf7459174638e1116bfc6664fd" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. Traces the return from a traced function back to its caller. Only works for functions traced with option &lt;code&gt;local&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt; erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35f97b1230868a1d952f070b44e014ae71c9b348" translate="yes" xml:space="preserve">
          <source>Used with the &lt;code&gt;call&lt;/code&gt; trace flag. Traces the return from a traced function back to its caller. Only works for functions traced with option &lt;code&gt;local&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Se utiliza con la &lt;code&gt;call&lt;/code&gt; seguimiento de llamadas . Rastrea el retorno de una funci&amp;oacute;n rastreada hasta su llamador. Solo funciona para funciones rastreadas con la opci&amp;oacute;n &lt;code&gt;local&lt;/code&gt; a &lt;code&gt;&lt;a href=&quot;#trace_pattern-3&quot;&gt;erlang:trace_pattern/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="71278576734ac4954eb54529eb1f8e6a8e33b380" translate="yes" xml:space="preserve">
          <source>Used with the optional replay feature to indicate the newest notifications of interest. If &lt;code&gt;StopTime&lt;/code&gt; is not present, the notifications continues until the subscription is terminated. Must be used with and be later than &lt;code&gt;StartTime&lt;/code&gt;. Values of &lt;code&gt;StopTime&lt;/code&gt; in the future are valid. This parameter is of type &lt;code&gt;dateTime&lt;/code&gt; and compliant to RFC 3339. Implementations must support time zones.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fba48e276aeb34c1e005677779fd01f8c437d09" translate="yes" xml:space="preserve">
          <source>Useful BIFs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0771df2c0469ced91bfba340e5621231c3eb3f97" translate="yes" xml:space="preserve">
          <source>Useful for debugging. Prints the arguments sent to the emulator.</source>
          <target state="translated">Útil para la depuración.Imprime los argumentos enviados al emulador.</target>
        </trans-unit>
        <trans-unit id="bda40ec80a6280d040ae6cb2132464ae8868382d" translate="yes" xml:space="preserve">
          <source>Useful only for performance tuning. Do not use this option unless you know that there is problem with execution times or memory consumption, and ensure that the option improves matters.</source>
          <target state="translated">Útil sólo para la puesta a punto de la actuación.No utilice esta opción a menos que sepa que hay problemas con los tiempos de ejecución o el consumo de memoria,y asegúrese de que la opción mejora las cosas.</target>
        </trans-unit>
        <trans-unit id="1b5232bbae53583af327fbf580fd761e961eb1ae" translate="yes" xml:space="preserve">
          <source>Useful options for the ASN.1 compiler:</source>
          <target state="translated">Opciones útiles para el compilador ASN.1:</target>
        </trans-unit>
        <trans-unit id="108800af422d061f509679723cbd223daa96eb6e" translate="yes" xml:space="preserve">
          <source>User Authentication (using Mnesia, Dets or plain text database)</source>
          <target state="translated">Autenticación del usuario (usando Mnesia,Dets o base de datos de texto plano)</target>
        </trans-unit>
        <trans-unit id="ed5170cd339b4047e02379b1d218d6d630aafc71" translate="yes" xml:space="preserve">
          <source>User Interface</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b544db80e74a2aaa321fb9ef1a50c8268a9abd0" translate="yes" xml:space="preserve">
          <source>User Supplied Socket Implementation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6d7d2ae9aeff0edfea9298508c33c3156394dee" translate="yes" xml:space="preserve">
          <source>User authentication using text files, Dets, or Mnesia database.</source>
          <target state="translated">Autenticación del usuario mediante archivos de texto,Dets o base de datos Mnesia.</target>
        </trans-unit>
        <trans-unit id="fdf44c259444d43d89a931e2c5f009d59f5246ec" translate="yes" xml:space="preserve">
          <source>User does not have privileges to create symbolic links (&lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; on Windows).</source>
          <target state="translated">El usuario no tiene privilegios para crear enlaces simb&amp;oacute;licos ( &lt;code&gt;SeCreateSymbolicLinkPrivilege&lt;/code&gt; en Windows).</target>
        </trans-unit>
        <trans-unit id="bfa1d0c7af0339d4d928dbeac41cc561fc954a37" translate="yes" xml:space="preserve">
          <source>User info - Information related to megaco users. Read/Write.</source>
          <target state="translated">Información del usuario-Información relacionada con los usuarios de megaco.Leer/escribir.</target>
        </trans-unit>
        <trans-unit id="5943eb1d1f04ded83e3e46ef3224b51f634ef059" translate="yes" xml:space="preserve">
          <source>User is not logged in.</source>
          <target state="translated">El usuario no está conectado.</target>
        </trans-unit>
        <trans-unit id="ad777a4590258aa35737d9328314ce537d2c9cb8" translate="yes" xml:space="preserve">
          <source>User login information</source>
          <target state="translated">Información de acceso del usuario</target>
        </trans-unit>
        <trans-unit id="6fb1ac68e43ee6fa885af993d59c13a42fa4cd33" translate="yes" xml:space="preserve">
          <source>User owning the public key.</source>
          <target state="translated">El usuario que posee la clave pública.</target>
        </trans-unit>
        <trans-unit id="ba07b0c96db1af8dcefb2d9162e61ba1cb1cc53b" translate="yes" xml:space="preserve">
          <source>User's private key(s)</source>
          <target state="translated">Clave(s)privada(s)del usuario</target>
        </trans-unit>
        <trans-unit id="31f9f489aed30f7126e13ae2a6c8aa3e1dfb69c4" translate="yes" xml:space="preserve">
          <source>User's public key</source>
          <target state="translated">La clave pública del usuario</target>
        </trans-unit>
        <trans-unit id="9426098e573c085d3d557403caba209e6444ee08" translate="yes" xml:space="preserve">
          <source>User-Defined Boot Scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a1ad1d15fcc5f9e499bc1732d0978996617997" translate="yes" xml:space="preserve">
          <source>User-Name AVP</source>
          <target state="translated">Nombre de usuario AVP</target>
        </trans-unit>
        <trans-unit id="de7eccf174631d1a9cc0a633fafcff4e91154a99" translate="yes" xml:space="preserve">
          <source>User-Specific Terms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12d9701932fd2b8fbf1ff963e66877b3fb9d5041" translate="yes" xml:space="preserve">
          <source>User-defined entries can also be written to a configuration file by calling function &lt;code&gt;ttb:write_config(ConfigFile,ConfigList)&lt;/code&gt;, where &lt;code&gt;ConfigList&lt;/code&gt; is a list of &lt;code&gt;{Module,Function,Args}&lt;/code&gt;.</source>
          <target state="translated">Las entradas definidas por el usuario tambi&amp;eacute;n se pueden escribir en un archivo de configuraci&amp;oacute;n llamando a la funci&amp;oacute;n &lt;code&gt;ttb:write_config(ConfigFile,ConfigList)&lt;/code&gt; , donde &lt;code&gt;ConfigList&lt;/code&gt; es una lista de &lt;code&gt;{Module,Function,Args}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="56ea86a7fa1494da2715a81abce4cab0c8f4eb29" translate="yes" xml:space="preserve">
          <source>User-defined event handlers can be added to handle application-specific events.</source>
          <target state="translated">Se pueden agregar manejadores de eventos definidos por el usuario para manejar eventos específicos de la aplicación.</target>
        </trans-unit>
        <trans-unit id="d44e29b83c2f61db1703ca0d31d257ddfa7ed010" translate="yes" xml:space="preserve">
          <source>User-specific data for use in hook functions. The default value is &lt;code&gt;undefined&lt;/code&gt;.</source>
          <target state="translated">Datos espec&amp;iacute;ficos del usuario para su uso en funciones de enlace. El valor predeterminado &lt;code&gt;undefined&lt;/code&gt; est&amp;aacute; definido .</target>
        </trans-unit>
        <trans-unit id="18e7327216976d6005c52f79eedee5271cbeaf73" translate="yes" xml:space="preserve">
          <source>User-specific event handlers can be plugged into a &lt;code&gt;Common Test&lt;/code&gt; event manager, either by telling &lt;code&gt;Common Test&lt;/code&gt; to install them before the test run (described later), or by adding the handlers dynamically during the test run using &lt;code&gt;gen_event:add_handler/3&lt;/code&gt; or &lt;code&gt;gen_event:add_sup_handler/3&lt;/code&gt;. In the latter scenario, the reference of the &lt;code&gt;Common Test&lt;/code&gt; event manager is required. To get it, call &lt;code&gt;&lt;a href=&quot;ct#get_event_mgr_ref-0&quot;&gt;ct:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; or (on the &lt;code&gt;Common Test&lt;/code&gt; Master node) &lt;code&gt;&lt;a href=&quot;ct_master#get_event_mgr_ref-0&quot;&gt;ct_master:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Los controladores de eventos espec&amp;iacute;ficos del usuario se pueden conectar a un administrador de eventos &lt;code&gt;Common Test&lt;/code&gt; , ya sea indicando a &lt;code&gt;Common Test&lt;/code&gt; que los instale antes de la ejecuci&amp;oacute;n de la prueba (que se describe m&amp;aacute;s adelante) o agregando los controladores din&amp;aacute;micamente durante la ejecuci&amp;oacute;n de la prueba utilizando &lt;code&gt;gen_event:add_handler/3&lt;/code&gt; o &lt;code&gt;gen_event:add_sup_handler/3&lt;/code&gt; . En el &amp;uacute;ltimo escenario, se requiere la referencia del administrador de eventos de &lt;code&gt;Common Test&lt;/code&gt; . Para obtenerlo, llame a &lt;code&gt;&lt;a href=&quot;ct#get_event_mgr_ref-0&quot;&gt;ct:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; o (en el nodo &lt;code&gt;Common Test&lt;/code&gt; Master) &lt;code&gt;&lt;a href=&quot;ct_master#get_event_mgr_ref-0&quot;&gt;ct_master:get_event_mgr_ref/0&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dca5c1acac21d9a3b6102ae9dadcfac83499ca32" translate="yes" xml:space="preserve">
          <source>UserMod:handle_connect/2</source>
          <target state="translated">UserMod:handle_connect/2</target>
        </trans-unit>
        <trans-unit id="f0d3fd03fc3def42c8da5fe622ad791ccaa1a0ea" translate="yes" xml:space="preserve">
          <source>UserMod:handle_message_error/3</source>
          <target state="translated">UserMod:handle_message_error/3</target>
        </trans-unit>
        <trans-unit id="a3bdb9436158799687b4418588b8647662e27155" translate="yes" xml:space="preserve">
          <source>UserMod:handle_syntax_error/3</source>
          <target state="translated">UserMod:handle_syntax_error/3</target>
        </trans-unit>
        <trans-unit id="7e0a148d93ed9e16bd5599754876deca380f643d" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_ack/4</source>
          <target state="translated">UserMod:handle_trans_ack/4</target>
        </trans-unit>
        <trans-unit id="d345f713a7834aaf56186658aec2115bcc13351b" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_reply/4</source>
          <target state="translated">UserMod:handle_trans_reply/4</target>
        </trans-unit>
        <trans-unit id="3884319e28f9e311d120dba2fbc454b53cead5a4" translate="yes" xml:space="preserve">
          <source>UserMod:handle_trans_request/3</source>
          <target state="translated">UserMod:handle_trans_request/3</target>
        </trans-unit>
        <trans-unit id="3f6d997ef0e4d563bff3ecdcaff66971fd6b9762" translate="yes" xml:space="preserve">
          <source>Users are advised not to unregister system processes.</source>
          <target state="translated">Se aconseja a los usuarios que no den de baja los procesos del sistema.</target>
        </trans-unit>
        <trans-unit id="2d7d513ec1d0fa107e592cfc1c6289d5e8f86f88" translate="yes" xml:space="preserve">
          <source>Users are not allowed to define types with the same names as the predefined or built-in ones. This is checked by the compiler and its violation results in a compilation error.</source>
          <target state="translated">No se permite a los usuarios definir tipos con los mismos nombres que los predefinidos o incorporados.Esto es comprobado por el compilador y su violación resulta en un error de compilación.</target>
        </trans-unit>
        <trans-unit id="259b250e47199fdb387584511bbacec343b879b8" translate="yes" xml:space="preserve">
          <source>Users may either explicitly be registered with megaco:start_user/2 and/or be statically configured by setting the application environment variable 'users' to a list of {UserMid, Config} tuples. See the function megaco:start_user/2 for details.</source>
          <target state="translated">Los usuarios pueden ser registrados explícitamente con megaco:start_user/2 y/o ser configurados estáticamente ajustando la variable de entorno de la aplicación &quot;users&quot; a una lista de tuplas {UserMid,Config}.Ver la función megaco:start_user/2 para más detalles.</target>
        </trans-unit>
        <trans-unit id="944ad3a48b1f08bbcf2fb59d662131185d4fa39c" translate="yes" xml:space="preserve">
          <source>Uses a separate log file for every invocation of the service (&amp;lt;servicename&amp;gt;&lt;code&gt;.debug.&lt;/code&gt;&amp;lt;N&amp;gt;).</source>
          <target state="translated">Utiliza un archivo de registro independiente para cada invocaci&amp;oacute;n del servicio (&amp;lt;servicename&amp;gt; &lt;code&gt;.debug.&lt;/code&gt; &amp;lt;N&amp;gt;).</target>
        </trans-unit>
        <trans-unit id="66ba2c7044af64caa2e9580c9ae81af796b430d1" translate="yes" xml:space="preserve">
          <source>Uses a sequence of wrap log files of limited size. As a wrap log file is filled up, further items are logged on to the next file in the sequence, starting all over with the first file when the last file is filled up.</source>
          <target state="translated">Utiliza una secuencia de archivos de registro de envoltura de tamaño limitado.A medida que se llena un archivo de registro de envoltura,los elementos adicionales se registran en el siguiente archivo de la secuencia,comenzando de nuevo con el primer archivo cuando se llena el último.</target>
        </trans-unit>
        <trans-unit id="63cc551f28fdc9de0a6c288edb557951e593faa7" translate="yes" xml:space="preserve">
          <source>Uses a specific or customised prologue file instead of default &lt;code&gt;lib/parsetools/include/leexinc.hrl&lt;/code&gt; which is otherwise included.</source>
          <target state="translated">Utiliza un archivo de pr&amp;oacute;logo espec&amp;iacute;fico o personalizado en lugar de &lt;code&gt;lib/parsetools/include/leexinc.hrl&lt;/code&gt; predeterminado, que de otro modo se incluye.</target>
        </trans-unit>
        <trans-unit id="cfb35a958a3524ef916a2dee520c654de0d97728" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a deep list of characters that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure (described in section &lt;code&gt;&lt;a href=&quot;#error_information&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;) is processed.</source>
          <target state="translated">Utiliza un &lt;code&gt;ErrorDescriptor&lt;/code&gt; y devuelve una lista detallada de caracteres que describe el error. Esta funci&amp;oacute;n se suele llamar impl&amp;iacute;citamente cuando se &lt;code&gt;ErrorInfo&lt;/code&gt; una estructura ErrorInfo (descrita en la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#error_information&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="c4139194e768c251d84b03abf5cd321d1df4d02c" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error or warning. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Utiliza un &lt;code&gt;ErrorDescriptor&lt;/code&gt; y devuelve una cadena que describe el error o la advertencia. Esta funci&amp;oacute;n se suele llamar impl&amp;iacute;citamente cuando se &lt;code&gt;ErrorInfo&lt;/code&gt; una estructura ErrorInfo (consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="81c0e97bc4b6d9f801ca4dae0a9674ebd48bf699" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt; Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c93cef9ab961b13c52c3ee1286af209a4ef5d08b" translate="yes" xml:space="preserve">
          <source>Uses an &lt;code&gt;ErrorDescriptor&lt;/code&gt; and returns a string that describes the error. This function is usually called implicitly when an &lt;code&gt;ErrorInfo&lt;/code&gt; structure is processed (see section &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">Utiliza un &lt;code&gt;ErrorDescriptor&lt;/code&gt; y devuelve una cadena que describe el error. Esta funci&amp;oacute;n se suele llamar impl&amp;iacute;citamente cuando se &lt;code&gt;ErrorInfo&lt;/code&gt; una estructura ErrorInfo (consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#errorinfo&quot;&gt;Error Information&lt;/a&gt;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="4e240ed0f46a0e7052bee5a3dec802b98fe462d1" translate="yes" xml:space="preserve">
          <source>Uses test specification as input (described later).</source>
          <target state="translated">Utiliza la especificación de la prueba como entrada (descrita más adelante).</target>
        </trans-unit>
        <trans-unit id="713999a06cadf66964b72d923b13701c303aa173" translate="yes" xml:space="preserve">
          <source>Uses the Pseudo-Random Function (PRF) of a TLS session to generate extra key material. It either takes user-generated values for &lt;code&gt;Secret&lt;/code&gt; and &lt;code&gt;Seed&lt;/code&gt; or atoms directing it to use a specific value from the session security parameters.</source>
          <target state="translated">Utiliza la funci&amp;oacute;n pseudoaleatoria (PRF) de una sesi&amp;oacute;n TLS para generar material clave adicional. Toma valores generados por el usuario para &lt;code&gt;Secret&lt;/code&gt; y &lt;code&gt;Seed&lt;/code&gt; o &amp;aacute;tomos que lo dirigen a usar un valor espec&amp;iacute;fico de los par&amp;aacute;metros de seguridad de la sesi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="29fb0bd5ac8937f75326b05d56a7b9c426068b8d" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang Web Server API interaction data:</source>
          <target state="translated">Utiliza los siguientes datos de interacción de la API del servidor web de Erlang:</target>
        </trans-unit>
        <trans-unit id="6542021570e55732848d7c4ecf584a9f1fce4a50" translate="yes" xml:space="preserve">
          <source>Uses the following Erlang web server API interaction data:</source>
          <target state="translated">Utiliza los siguientes datos de interacción de la API del servidor web de Erlang:</target>
        </trans-unit>
        <trans-unit id="9c87b085bc59aac65ced245c43dfb66c0a327d57" translate="yes" xml:space="preserve">
          <source>Uses the return value of command &lt;code&gt;N&lt;/code&gt; in the current command, if &lt;code&gt;N&lt;/code&gt; is positive. If it is negative, the return value of the &lt;code&gt;N&lt;/code&gt;th previous command is used (that is, &lt;code&gt;v(-1)&lt;/code&gt; uses the value of the previous command).</source>
          <target state="translated">Utiliza el valor de retorno del comando &lt;code&gt;N&lt;/code&gt; en el comando actual, si &lt;code&gt;N&lt;/code&gt; es positivo. Si es negativo, se usa el valor de retorno del &lt;code&gt;N&lt;/code&gt; - &amp;eacute;simo comando anterior (es decir, &lt;code&gt;v(-1)&lt;/code&gt; usa el valor del comando anterior).</target>
        </trans-unit>
        <trans-unit id="eecb17cf153ec064278785165dee55062f6944c8" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current directory. It is prepended to filenames when extracting them from the zip archive. (Acting like &lt;code&gt; file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7825c5becf2a7bc58af7be09180ec50f46648e4" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current directory. It is prepended to filenames when extracting them from the zip archive. (Acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.)</source>
          <target state="translated">Utiliza el directorio especificado como directorio actual. Se antepone a los nombres de los archivos al extraerlos del archivo zip. (Actuando como &lt;code&gt;file:set_cwd/1&lt;/code&gt; en Kernel, pero sin cambiar la propiedad global &lt;code&gt;cwd&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="70df806adc59e0170f9b3abdae1e333b936a59c8" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current work directory (&lt;code&gt;cwd&lt;/code&gt;). This is prepended to filenames when adding them, although not in the zip archive (acting like &lt;code&gt; file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f356880e1a29c6875ae88d729105f2618d77c27f" translate="yes" xml:space="preserve">
          <source>Uses the specified directory as current work directory (&lt;code&gt;cwd&lt;/code&gt;). This is prepended to filenames when adding them, although not in the zip archive (acting like &lt;code&gt;file:set_cwd/1&lt;/code&gt; in Kernel, but without changing the global &lt;code&gt;cwd&lt;/code&gt; property.).</source>
          <target state="translated">Utiliza el directorio especificado como directorio de trabajo actual ( &lt;code&gt;cwd&lt;/code&gt; ). Esto se antepone a los nombres de archivo al agregarlos, aunque no en el archivo zip (actuando como &lt;code&gt;file:set_cwd/1&lt;/code&gt; en Kernel, pero sin cambiar la propiedad global &lt;code&gt;cwd&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="3b24dbe95482357a59b64bc1da6d8ac53437250c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-group top1 top2&lt;/code&gt;, or &lt;code&gt;{group,[top1,top2]}&lt;/code&gt; gives the same result.</source>
          <target state="translated">El uso de &lt;code&gt;-group top1 top2&lt;/code&gt; , o &lt;code&gt;{group,[top1,top2]}&lt;/code&gt; da el mismo resultado.</target>
        </trans-unit>
        <trans-unit id="88f4f21380171a61e0164a29d94211d35a1afc8d" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;-include_lib(&quot;syntax_tools/include/merl.hrl&quot;).&lt;/code&gt; enables this transform, unless the macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; is defined first.</source>
          <target state="translated">Usando &lt;code&gt;-include_lib(&quot;syntax_tools/include/merl.hrl&quot;).&lt;/code&gt; habilita esta transformaci&amp;oacute;n, a menos que la macro &lt;code&gt;MERL_NO_TRANSFORM&lt;/code&gt; se defina primero.</target>
        </trans-unit>
        <trans-unit id="c20e26276eb3aeb9f802837228801c44d2e93f19" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;&lt;a href=&quot;ets#select-2&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; and a match specification, one can filter out rows of a table and construct a list of tuples containing relevant parts of the data in these rows. One can use &lt;code&gt;&lt;a href=&quot;ets#foldl-3&quot;&gt;ets:foldl/3&lt;/a&gt;&lt;/code&gt; instead, but the &lt;code&gt;ets:select/2&lt;/code&gt; call is far more efficient. Without the translation provided by &lt;code&gt;ms_transform&lt;/code&gt;, one must struggle with writing match specifications terms to accommodate this.</source>
          <target state="translated">Usando &lt;code&gt;&lt;a href=&quot;ets#select-2&quot;&gt;ets:select/2&lt;/a&gt;&lt;/code&gt; y una especificaci&amp;oacute;n de coincidencia, uno puede filtrar filas de una tabla y construir una lista de tuplas que contengan partes relevantes de los datos en estas filas. En su lugar, se puede usar &lt;code&gt;&lt;a href=&quot;ets#foldl-3&quot;&gt;ets:foldl/3&lt;/a&gt;&lt;/code&gt; , pero la llamada &lt;code&gt;ets:select/2&lt;/code&gt; es mucho m&amp;aacute;s eficiente. Sin la traducci&amp;oacute;n proporcionada por &lt;code&gt;ms_transform&lt;/code&gt; , uno debe luchar con la escritura de t&amp;eacute;rminos de especificaciones de coincidencia para adaptarse a esto.</target>
        </trans-unit>
        <trans-unit id="c82c027de482fad19a39ea9d254bbafa02b405e5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;cprof:analyse()&lt;/code&gt; in this example also shows approximately the same background work as in the first example.</source>
          <target state="translated">El uso de &lt;code&gt;cprof:analyse()&lt;/code&gt; en este ejemplo tambi&amp;eacute;n muestra aproximadamente el mismo trabajo de fondo que en el primer ejemplo.</target>
        </trans-unit>
        <trans-unit id="8c0e8375352b28a80765ea773ca843308851404f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ct_run -step [opts]&lt;/code&gt;, or by passing option &lt;code&gt;{step,Opts}&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt;, the following is possible:</source>
          <target state="translated">Usando &lt;code&gt;ct_run -step [opts]&lt;/code&gt; , o pasando la opci&amp;oacute;n &lt;code&gt;{step,Opts}&lt;/code&gt; a &lt;code&gt;&lt;a href=&quot;ct#run_test-1&quot;&gt;ct:run_test/1&lt;/a&gt;&lt;/code&gt; , lo siguiente es posible:</target>
        </trans-unit>
        <trans-unit id="8f64a2837eaf7b8603ee4f3b40320c612c90d80f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;erl_drv_output_term()&lt;/code&gt; or &lt;code&gt;erl_drv_send_term()&lt;/code&gt;, a binary can be included in an Erlang term.</source>
          <target state="translated">Usando &lt;code&gt;erl_drv_output_term()&lt;/code&gt; o &lt;code&gt;erl_drv_send_term()&lt;/code&gt; , se puede incluir un binario en un t&amp;eacute;rmino de Erlang.</target>
        </trans-unit>
        <trans-unit id="22c339dd691e6a37b987bcf7700c90e985445f81" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;, we can combine the ease of use of the &lt;code&gt;ets:foldr/3&lt;/code&gt; and the efficiency of the pure &lt;code&gt;ets:select/2&lt;/code&gt; example:</source>
          <target state="translated">Usando &lt;code&gt;ets:fun2ms/1&lt;/code&gt; , podemos combinar la facilidad de uso de &lt;code&gt;ets:foldr/3&lt;/code&gt; y la eficiencia del ejemplo puro de &lt;code&gt;ets:select/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8d06eaee0affa1e9d7ed35b71b0a99a0f3c00b54" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;list_to_atom/1&lt;/code&gt; to construct an atom that is passed to &lt;code&gt;apply/3&lt;/code&gt; as follows, is quite expensive and not recommended in time-critical code:</source>
          <target state="translated">Usar &lt;code&gt;list_to_atom/1&lt;/code&gt; para construir un &amp;aacute;tomo que se pasa a &lt;code&gt;apply/3&lt;/code&gt; de la siguiente manera, es bastante caro y no se recomienda en c&amp;oacute;digo de tiempo cr&amp;iacute;tico:</target>
        </trans-unit>
        <trans-unit id="d46674608018d628e05f3f6b918685848c3d908c" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;off_heap&lt;/code&gt; may seem like a nice way to get a more scalable system as you get very little contention on the main locks, however, allocating a heap fragment is more expensive than allocating on the heap of the receiving process. So if it is very unlikely that contention will occur, it is more efficient to try to allocate the message directly on the receiving process' heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fcacc23564d64117fc9064f1fef0cef7f077dab" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;on_heap&lt;/code&gt; will force all messages to be part of on the young heap which will increase the amount of data that the garbage collector has to move. So if a garbage collection is triggered while processing a large amount of messages, they will be copied to the young heap. This in turn will lead to that the messages will quickly be promoted to the old heap and thus increase its size. This may be good or bad depending on exactly what the process does. A large old heap means that the young heap will also be larger, which in turn means that less garbage collections will be triggered while processing the message queue. This will temporarly increase the throughput of the process at the cost of more memory usage. However, if after all the messages have been consumed the process enters a state where a lot less messages are being received. Then it may be a long time before the next fullsweep garbage collection happens and the messages that are on the old heap will be there until that happens. So while &lt;code&gt;on_heap&lt;/code&gt; is potentially faster than the other modes, it uses more memory for a longer time. This mode is the legacy mode which is almost how the message queue was handled before Erlang/OTP 19.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81394dd93922176e47458d5f3c15c2b0804bd134" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;scheduler_wall_time&lt;/code&gt; to calculate scheduler utilization:</source>
          <target state="translated">Uso del &lt;code&gt;scheduler_wall_time&lt;/code&gt; para calcular la utilizaci&amp;oacute;n del programador:</target>
        </trans-unit>
        <trans-unit id="862378469cf87dc0f0b44de7c775b81caef36dd4" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;skip_suites&lt;/code&gt; and &lt;code&gt;skip_cases&lt;/code&gt; terms in &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specifications&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Uso de t&amp;eacute;rminos &lt;code&gt;skip_suites&lt;/code&gt; y &lt;code&gt;skip_cases&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;run_test_chapter#test_specifications&quot;&gt;test specifications&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ad8c3317a3e308fa4049e5bb381826628649bab5" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;uri_string:percent_decode/1&lt;/code&gt; directly on a URI is not safe. This example shows, that after each consecutive application of the function the resulting URI will be changed. None of these URIs refer to the same resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf508ced4ee281be2348cd08d12f83a3f75cac1" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; makes SSL or TLS vulnerable to the BEAST attack.</source>
          <target state="translated">El uso de &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; hace que SSL o TLS sean vulnerables al ataque BEAST.</target>
        </trans-unit>
        <trans-unit id="87dfbc56acc4a3ad5ee7a36ef57f4914ecd5323f" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{beast_mitigation, disabled}&lt;/code&gt; makes TLS-1.0 vulnerable to the BEAST attack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e8a3b96a977f8581a203f0cc7479a4fa622cf64" translate="yes" xml:space="preserve">
          <source>Using &lt;code&gt;{padding_check, boolean()}&lt;/code&gt; makes TLS vulnerable to the Poodle attack.</source>
          <target state="translated">El uso de &lt;code&gt;{padding_check, boolean()}&lt;/code&gt; hace que TLS sea vulnerable al ataque Poodle.</target>
        </trans-unit>
        <trans-unit id="1984579de8895e18f9ec4b106a61232ce3d2f9a9" translate="yes" xml:space="preserve">
          <source>Using Dialyzer from Erlang</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12c74ea67a8bf514e98bacaa08d939dc388ff2c9" translate="yes" xml:space="preserve">
          <source>Using HiPE</source>
          <target state="translated">Usando HiPE</target>
        </trans-unit>
        <trans-unit id="33d4374af52dd4c6d3bf7dd77f27a252b67bb304" translate="yes" xml:space="preserve">
          <source>Using Keys of Ets Table</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787b8b2ecfeeac0dc6c8b30eb4f29ae6e32df930" translate="yes" xml:space="preserve">
          <source>Using Mnesia Functions</source>
          <target state="translated">Usando las funciones de la mnesia</target>
        </trans-unit>
        <trans-unit id="69b70d7925c3d595457eb50569e18e9253b0f84e" translate="yes" xml:space="preserve">
          <source>Using Mnesia tables as SNMP tables</source>
          <target state="translated">Usando tablas de Mnesia como tablas de SNMP</target>
        </trans-unit>
        <trans-unit id="3313c0cf350dee6afc582a4e81b3944a9c28027c" translate="yes" xml:space="preserve">
          <source>Using Multiple Test Specification Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4556d3a05908d3a2fd5b120b9264ae977bdd001" translate="yes" xml:space="preserve">
          <source>Using QLC</source>
          <target state="translated">Usando QLC</target>
        </trans-unit>
        <trans-unit id="eb75491192cbec18ddc3193ff609070567e4f298" translate="yes" xml:space="preserve">
          <source>Using QLC can be more expensive than using &lt;code&gt;Mnesia&lt;/code&gt; functions directly but offers a nice syntax.</source>
          <target state="translated">Usar QLC puede ser m&amp;aacute;s costoso que usar &lt;code&gt;Mnesia&lt;/code&gt; funciones de Mnesia directamente, pero ofrece una buena sintaxis.</target>
        </trans-unit>
        <trans-unit id="a066eefba1eeb1104df3eae5dd3e9fa8ab61feec" translate="yes" xml:space="preserve">
          <source>Using XML Configuration Files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b888e7581a06a39525c04389ba7f49f831878208" translate="yes" xml:space="preserve">
          <source>Using a &lt;code&gt;msg_env&lt;/code&gt; of &lt;code&gt;NULL&lt;/code&gt; is an optimization, which groups together calls to &lt;code&gt;enif_alloc_env&lt;/code&gt;, &lt;code&gt;enif_make_copy&lt;/code&gt;, &lt;code&gt;enif_port_command&lt;/code&gt;, and &lt;code&gt;enif_free_env&lt;/code&gt; into one call. This optimization is only useful when a majority of the terms are to be copied from &lt;code&gt;env&lt;/code&gt; to &lt;code&gt;msg_env&lt;/code&gt;.</source>
          <target state="translated">El uso de &lt;code&gt;msg_env&lt;/code&gt; de &lt;code&gt;NULL&lt;/code&gt; es una optimizaci&amp;oacute;n, que agrupa las llamadas a &lt;code&gt;enif_alloc_env&lt;/code&gt; , &lt;code&gt;enif_make_copy&lt;/code&gt; , &lt;code&gt;enif_port_command&lt;/code&gt; y &lt;code&gt;enif_free_env&lt;/code&gt; en una sola llamada. Esta optimizaci&amp;oacute;n solo es &amp;uacute;til cuando la mayor&amp;iacute;a de los t&amp;eacute;rminos se van a copiar de &lt;code&gt;env&lt;/code&gt; a &lt;code&gt;msg_env&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6e05aace796b827cc7de5108dc65985d67668971" translate="yes" xml:space="preserve">
          <source>Using a bridge that maps control messages in a proprietary protocol to a standardized management protocol and conversely</source>
          <target state="translated">El uso de un puente que mapea los mensajes de control en un protocolo propietario a un protocolo de gestión estandarizado y a la inversa</target>
        </trans-unit>
        <trans-unit id="23f87dc632b3b3a497eda26d1e0fd7f024ede833" translate="yes" xml:space="preserve">
          <source>Using a configuration target name (an alias) as reference.</source>
          <target state="translated">Usando un nombre de objetivo de configuración (un alias)como referencia.</target>
        </trans-unit>
        <trans-unit id="1bd7819b4238a75d18eacbc298988f60839565ee" translate="yes" xml:space="preserve">
          <source>Using a driver binary instead of a normal buffer is often faster, as the emulator needs not to copy the data, only the pointer is used.</source>
          <target state="translated">El uso de un binario controlador en lugar de un búfer normal suele ser más rápido,ya que el emulador no necesita copiar los datos,sólo se utiliza el puntero.</target>
        </trans-unit>
        <trans-unit id="bd91214b8e2268d8b06993311ecee8c2eef8c119" translate="yes" xml:space="preserve">
          <source>Using a password protected private key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a4f00d83853b9a89087a2b4d34b93f85e90b8b4" translate="yes" xml:space="preserve">
          <source>Using a proprietary control protocol</source>
          <target state="translated">Usando un protocolo de control propietario</target>
        </trans-unit>
        <trans-unit id="8e93a7f8043acf2f93881fdb114964f55246a652" translate="yes" xml:space="preserve">
          <source>Using a pure password-based authentication scheme. Here, the plain text password is encrypted before sent over the network.</source>
          <target state="translated">Utilizando un esquema de autenticación basado en una contraseña pura.Aquí,la contraseña en texto plano es encriptada antes de ser enviada a través de la red.</target>
        </trans-unit>
        <trans-unit id="b4a6cc06302869126e46d43f8937deb8a274ac3e" translate="yes" xml:space="preserve">
          <source>Using a set of bits in the process identifier as index into an array seems hard to beat. By replacing the array of pointers with an array of our pointer sized atomic data type, a lookup will consist of the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b61ea81dc7d1d41a9c00c2e18e56e9bb004eb512" translate="yes" xml:space="preserve">
          <source>Using a trace port significantly lowers the overhead imposed by using tracing.</source>
          <target state="translated">El uso de un puerto de rastreo reduce significativamente los gastos generales impuestos por el uso del rastreo.</target>
        </trans-unit>
        <trans-unit id="ef1a11e39ee5139ba5f2dcc235a18443f44a0583" translate="yes" xml:space="preserve">
          <source>Using a value of &lt;code&gt;Timeout&lt;/code&gt; less than the maximum time taken by the OS to establish an association (around 4.5 minutes if the default values from &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC 4960&lt;/a&gt;&lt;/code&gt; are used), can result in inconsistent or incorrect return values. This is especially relevant for associations sharing the same &lt;code&gt;Socket&lt;/code&gt; (that is, source address and port), as the controlling process blocks until &lt;code&gt;connect/*&lt;/code&gt; returns. &lt;code&gt;&lt;a href=&quot;#connect_init-4&quot;&gt;connect_init/*&lt;/a&gt;&lt;/code&gt; provides an alternative without this limitation.</source>
          <target state="translated">Usar un valor de tiempo de &lt;code&gt;Timeout&lt;/code&gt; menor que el tiempo m&amp;aacute;ximo que toma el sistema operativo para establecer una asociaci&amp;oacute;n (alrededor de 4.5 minutos si se usan los valores predeterminados de &lt;code&gt;&lt;a href=&quot;https://tools.ietf.org/html/rfc4960&quot;&gt;RFC 4960&lt;/a&gt;&lt;/code&gt; ), puede resultar en valores de retorno inconsistentes o incorrectos. Esto es especialmente relevante para las asociaciones que comparten el mismo &lt;code&gt;Socket&lt;/code&gt; (es decir, la direcci&amp;oacute;n de origen y el puerto), ya que el proceso de control se bloquea hasta que &lt;code&gt;connect/*&lt;/code&gt; regresa. &lt;code&gt;&lt;a href=&quot;#connect_init-4&quot;&gt;connect_init/*&lt;/a&gt;&lt;/code&gt; proporciona una alternativa sin esta limitaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="ac881e536beb671038423cc61533d8765126d30b" translate="yes" xml:space="preserve">
          <source>Using and especially configuring Logger can be difficult at times as there are many different options that can be changed and often more than one way to achieve the same result. This User's Guide tries to help by giving many different examples of how you can use logger.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba9ca7df52061ff3c5b19d7603144639874aa7f" translate="yes" xml:space="preserve">
          <source>Using behaviours also makes it easier to read and understand code written by other programmers. Improvised programming structures, while possibly more efficient, are always more difficult to understand.</source>
          <target state="translated">El uso de comportamientos también facilita la lectura y la comprensión del código escrito por otros programadores.Las estructuras de programación improvisadas,aunque posiblemente más eficientes,siempre son más difíciles de entender.</target>
        </trans-unit>
        <trans-unit id="be49034820244435a044e90d7061836773df04c0" translate="yes" xml:space="preserve">
          <source>Using binaries is faster if more than a few bytes are returned.</source>
          <target state="translated">El uso de binarios es más rápido si se devuelven más de unos pocos bytes.</target>
        </trans-unit>
        <trans-unit id="86c27bef1bf11875cf4524858dc2b5b6d1f57e8f" translate="yes" xml:space="preserve">
          <source>Using global names</source>
          <target state="translated">Usando nombres globales</target>
        </trans-unit>
        <trans-unit id="83523a7442b26b6b81628c22227c3e6adc4deb1a" translate="yes" xml:space="preserve">
          <source>Using keyboard-interactive authentication. This is suitable for interactive authentication methods that do not need any special software support on the client side. Instead, all authentication data is entered from the keyboard.</source>
          <target state="translated">Usando la autenticación interactiva del teclado.Esto es adecuado para los métodos de autenticación interactiva que no necesitan ningún tipo de soporte de software especial en el lado del cliente.En cambio,todos los datos de autenticación se introducen desde el teclado.</target>
        </trans-unit>
        <trans-unit id="1a390fb32c6eae4e12e20eb0d4d9a4b34d640e2f" translate="yes" xml:space="preserve">
          <source>Using one of the latter three requires good knowledge about the protocol and is not covered by this tutorial. See the SNMP, Inets, and Orber applications, respectively.</source>
          <target state="translated">El uso de uno de los tres últimos requiere un buen conocimiento del protocolo y no está cubierto por este tutorial.Ver las aplicaciones SNMP,Inets y Orber,respectivamente.</target>
        </trans-unit>
        <trans-unit id="5809e3cc4f955b265b3823ad9d7e5a15c18140e7" translate="yes" xml:space="preserve">
          <source>Using public key technology. RSA and DSA, X509-certificates are not supported.</source>
          <target state="translated">Usando tecnología de clave pública.Los certificados RSA y DSA,X509 no son compatibles.</target>
        </trans-unit>
        <trans-unit id="e0f94a2e35a5586c99778544bf1babebc9b68874" translate="yes" xml:space="preserve">
          <source>Using raw socket options requires detailed knowledge about the current operating system and TCP stack.</source>
          <target state="translated">El uso de las opciones de socorro en bruto requiere un conocimiento detallado del sistema operativo actual y de la pila de TCP.</target>
        </trans-unit>
        <trans-unit id="c43bcf358f1478cc031c03e30ad078b80a07cfdf" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">No se permite el uso del &lt;code&gt;monitor&lt;/code&gt; de opciones de &lt;code&gt;badarg&lt;/code&gt; , hace que la funci&amp;oacute;n falle con motivo badarg .</target>
        </trans-unit>
        <trans-unit id="35f019fb91f46510f8e2ab9ec3e19f04bc02403c" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed, it causes this function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">No se permite el uso del &lt;code&gt;monitor&lt;/code&gt; de opci&amp;oacute;n de &lt;code&gt;badarg&lt;/code&gt; , hace que esta funci&amp;oacute;n falle con motivo badarg .</target>
        </trans-unit>
        <trans-unit id="5a580b4208da4e796317767a96b5a26cf22e6b99" translate="yes" xml:space="preserve">
          <source>Using spawn option &lt;code&gt;monitor&lt;/code&gt; is not allowed. It causes the function to fail with reason &lt;code&gt;badarg&lt;/code&gt;.</source>
          <target state="translated">No se permite el uso del &lt;code&gt;monitor&lt;/code&gt; de opci&amp;oacute;n de generaci&amp;oacute;n . Hace que la funci&amp;oacute;n falle con motivo &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43a9c674a9710324d1b88cb77d06f6cc4e6cfec2" translate="yes" xml:space="preserve">
          <source>Using state functions:</source>
          <target state="translated">Usando las funciones del estado:</target>
        </trans-unit>
        <trans-unit id="d6a2d079afcf63d89e623e699169fa524219390a" translate="yes" xml:space="preserve">
          <source>Using the &quot;&lt;code&gt;--&lt;/code&gt;&quot; operator to delete an element from a list is not a performance problem:</source>
          <target state="translated">Usar el operador &quot; &lt;code&gt;--&lt;/code&gt; &quot; para eliminar un elemento de una lista no es un problema de rendimiento:</target>
        </trans-unit>
        <trans-unit id="2b4f7382590545933da8c1a5ca844a0b2dbf266e" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; BIF, the size of the deep list can be calculated if sharing is ignored. It becomes the size of the list when it has been sent to another process or stored in an Ets table:</source>
          <target state="translated">Usando &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; BIF, el tama&amp;ntilde;o de la lista profunda se puede calcular si se ignora el uso compartido. Se convierte en el tama&amp;ntilde;o de la lista cuando se env&amp;iacute;a a otro proceso o se almacena en una tabla de Ets:</target>
        </trans-unit>
        <trans-unit id="f45d11e06ad9c8b5b97c2a1d3733d7810b2b6a1d" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;erts_debug:size/1&lt;/code&gt; BIF, it can be seen that the deep list only requires 22 words of heap space:</source>
          <target state="translated">Usando &lt;code&gt;erts_debug:size/1&lt;/code&gt; BIF, se puede ver que la lista profunda solo requiere 22 palabras de espacio de pila:</target>
        </trans-unit>
        <trans-unit id="69d1d8837258e11d9f37b8093e934034d0224323" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;match_object&lt;/code&gt; functions for traversing all table objects is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="translated">Usar las funciones &lt;code&gt;match_object&lt;/code&gt; para atravesar todos los objetos de la tabla es m&amp;aacute;s eficiente que llamar a &lt;code&gt;first/1&lt;/code&gt; y &lt;code&gt;next/2&lt;/code&gt; o &lt;code&gt;slot/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb9890e5b6fe40e8ce4e970b7ac20a2736549546" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;move&lt;/code&gt; instruction as an example, we will give a quick tour to show the main features of &lt;strong&gt;beam_makeops&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88489091684544e2ce31ba031314c433818b9650" translate="yes" xml:space="preserve">
          <source>Using the &lt;code&gt;select&lt;/code&gt; functions for traversing all objects of a table is more efficient than calling &lt;code&gt;first/1&lt;/code&gt; and &lt;code&gt;next/2&lt;/code&gt; or &lt;code&gt;slot/2&lt;/code&gt;.</source>
          <target state="translated">El uso de las funciones de &lt;code&gt;select&lt;/code&gt; para recorrer todos los objetos de una tabla es m&amp;aacute;s eficiente que llamar &lt;code&gt;first/1&lt;/code&gt; y &lt;code&gt;next/2&lt;/code&gt; o &lt;code&gt;slot/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61a624a4dabba21043f9ab83195b8048f47a13d2" translate="yes" xml:space="preserve">
          <source>Using the &lt;strong&gt;Options&lt;/strong&gt; menu, you can set which areas to be displayed. By default, all areas except the Trace area are displayed.</source>
          <target state="translated">Con el men&amp;uacute; &lt;strong&gt;Opciones&lt;/strong&gt; , puede establecer qu&amp;eacute; &amp;aacute;reas se mostrar&amp;aacute;n. De forma predeterminada, se muestran todas las &amp;aacute;reas excepto el &amp;aacute;rea de seguimiento.</target>
        </trans-unit>
        <trans-unit id="deaaf3fd831f16ebe5c78cc725732bfa850f0ae7" translate="yes" xml:space="preserve">
          <source>Using the BIFs &lt;code&gt;tuple_size/1&lt;/code&gt; and &lt;code&gt;byte_size/1&lt;/code&gt; gives the compiler and the runtime system more opportunities for optimization. Another advantage is that the BIFs give Dialyzer more type information.</source>
          <target state="translated">El uso de los BIF &lt;code&gt;tuple_size/1&lt;/code&gt; y &lt;code&gt;byte_size/1&lt;/code&gt; le da al compilador y al sistema en tiempo de ejecuci&amp;oacute;n m&amp;aacute;s oportunidades de optimizaci&amp;oacute;n. Otra ventaja es que los BIF le dan a Dialyzer m&amp;aacute;s informaci&amp;oacute;n sobre tipos.</target>
        </trans-unit>
        <trans-unit id="5ffd8340dfb4e279ea5e33db1e4fc34776f3431f" translate="yes" xml:space="preserve">
          <source>Using the Erlang Port Mapper Daemon (EPMD)</source>
          <target state="translated">Usando el demonio de mapeo de puertos de Erlang (EPMD)</target>
        </trans-unit>
        <trans-unit id="74a23b01b4aba69b50c3d95e7b04c3987e9060d6" translate="yes" xml:space="preserve">
          <source>Using the Kernel configuration parameters above, one can set default options for all TCP sockets on a node, but use this with care. Options such as &lt;code&gt;{delay_send,true}&lt;/code&gt; can be specified in this way. The following is an example of starting an Erlang node with all sockets using delayed send:</source>
          <target state="translated">Usando los par&amp;aacute;metros de configuraci&amp;oacute;n del Kernel anteriores, se pueden establecer opciones predeterminadas para todos los sockets TCP en un nodo, pero util&amp;iacute;celo con cuidado. De esta forma se pueden especificar opciones como &lt;code&gt;{delay_send,true}&lt;/code&gt; . El siguiente es un ejemplo de c&amp;oacute;mo iniciar un nodo Erlang con todos los sockets usando el env&amp;iacute;o retrasado:</target>
        </trans-unit>
        <trans-unit id="d1a737c5f8225e696e7f3578db64802e348cec28" translate="yes" xml:space="preserve">
          <source>Using the SNMP Agent in a Distributed Environment</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="980131d837205b9d57e4456d942aace527d0b1b4" translate="yes" xml:space="preserve">
          <source>Using the compile server does not always speed up the build, as the compile server sometimes must be restarted to ensure correctness. Here are some examples of situtations that force a restart:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c13013135bcccdcdbbd4af4075c0fbd41fe4a1df" translate="yes" xml:space="preserve">
          <source>Using the configuration variable as reference.</source>
          <target state="translated">Usando la variable de configuración como referencia.</target>
        </trans-unit>
        <trans-unit id="6387e670864aedf383cf907c6d29480da77d049e" translate="yes" xml:space="preserve">
          <source>Using the erlc program, write like this</source>
          <target state="translated">Usando el programa erlc,escribe así</target>
        </trans-unit>
        <trans-unit id="cba5c7b8f3196008174c43d66ec7b6eeb23e5802" translate="yes" xml:space="preserve">
          <source>Using the following rule we can combine two &lt;code&gt;move&lt;/code&gt; instructions to a &lt;code&gt;move2&lt;/code&gt; instruction:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48fe6335c37dc35de5485bc852958929b084eb85" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;broadcast&lt;/code&gt; becomes:</source>
          <target state="translated">Usando la funci&amp;oacute;n &lt;code&gt;foreach&lt;/code&gt; , la funci&amp;oacute;n &lt;code&gt;broadcast&lt;/code&gt; se convierte en:</target>
        </trans-unit>
        <trans-unit id="3bd90c46e2dfc7b2e3d344d9519f155f341267df" translate="yes" xml:space="preserve">
          <source>Using the function &lt;code&gt;foreach&lt;/code&gt;, the function &lt;code&gt;print_list&lt;/code&gt; becomes:</source>
          <target state="translated">Usando la funci&amp;oacute;n &lt;code&gt;foreach&lt;/code&gt; , la funci&amp;oacute;n &lt;code&gt;print_list&lt;/code&gt; se convierte en:</target>
        </trans-unit>
        <trans-unit id="b09520015307c351db8684a091c45386c6ce9fb4" translate="yes" xml:space="preserve">
          <source>Using the monitor triggers in the call to &lt;code&gt;try_unload&lt;/code&gt; ensures that the monitor is added before the unloading is executed, meaning that the monitor is always properly triggered, which is not the case if &lt;code&gt;monitor/2&lt;/code&gt; is called separately.</source>
          <target state="translated">El uso de los activadores del monitor en la llamada a &lt;code&gt;try_unload&lt;/code&gt; asegura que el monitor se agregue antes de que se ejecute la descarga, lo que significa que el monitor siempre se activa correctamente, lo que no es el caso si se llama al &lt;code&gt;monitor/2&lt;/code&gt; por separado.</target>
        </trans-unit>
        <trans-unit id="e7fa3b27587f43d236bfc06bb5036ddb2f4e6201" translate="yes" xml:space="preserve">
          <source>Using the registry</source>
          <target state="translated">Usando el registro</target>
        </trans-unit>
        <trans-unit id="ffb1c5489112873955c3175cf9ad9aba4db225d6" translate="yes" xml:space="preserve">
          <source>Using the same snapshots to calculate a total scheduler utilization:</source>
          <target state="translated">Usando las mismas instantáneas para calcular la utilización total del programador:</target>
        </trans-unit>
        <trans-unit id="a20644602b05608c2ad01e03c87f70e3ffe5b61d" translate="yes" xml:space="preserve">
          <source>Using the single time warp mode, the time offset is handled in two phases:</source>
          <target state="translated">Usando el modo de urdimbre de tiempo simple,el desplazamiento de tiempo se maneja en dos fases:</target>
        </trans-unit>
        <trans-unit id="8eee4ea386e884fcda7fe99030e661fbbf1aa947" translate="yes" xml:space="preserve">
          <source>Using the specific path &lt;code&gt;-group [sub121]&lt;/code&gt; or &lt;code&gt;{group,[[sub121]]}&lt;/code&gt; gives the same result in this example.</source>
          <target state="translated">El uso de la ruta espec&amp;iacute;fica &lt;code&gt;-group [sub121]&lt;/code&gt; o &lt;code&gt;{group,[[sub121]]}&lt;/code&gt; da el mismo resultado en este ejemplo.</target>
        </trans-unit>
        <trans-unit id="5c52f9666d83bbf64ddaeeafc9ca31c5700aca1b" translate="yes" xml:space="preserve">
          <source>Using these facts, the two small circles in the picture below can be combined.</source>
          <target state="translated">Usando estos hechos,los dos pequeños círculos en la imagen de abajo pueden ser combinados.</target>
        </trans-unit>
        <trans-unit id="c051a5a3fd4ccf36ccc537b80db2ff67e34eac9f" translate="yes" xml:space="preserve">
          <source>Using this approach we keep the properties like identifier ordering, and identifier reuse while improving performance and scalability. It has one flaw, though. There is no guarantee that the operation will terminate. This can quite easily be fixed though, and will be fixed in the next release. We will get back to this below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aa02cd7977a3da27f5010ebc2df637a05af28d4" translate="yes" xml:space="preserve">
          <source>Using this new lookup approach we wont modify any memory at all which is important. A lookup conceptually only read memory, now this is true in the implementation also which is important from a scalability perspective. The previous implementation modified the cache line containing the reference counter two times, and the cache line containing the corresponding lock two times at each lookup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63be83a0c1d3953deae8f0d528efae09e644ff83" translate="yes" xml:space="preserve">
          <source>Using this option makes mod_log and mod_disk_log error logs redundant.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86aadd39c7dc4683cf62fc0ed24ee58375d7f5d3" translate="yes" xml:space="preserve">
          <source>Using transactions is a way to guarantee that the distributed Mnesia database remains consistent, even when many different processes update it in parallel. However, if you have real-time requirements it is recommended to use &lt;code&gt;dirty&lt;/code&gt; operations instead of transactions. When using &lt;code&gt;dirty&lt;/code&gt; operations, you lose the consistency guarantee; this is usually solved by only letting one process update the table. Other processes must send update requests to that process.</source>
          <target state="translated">El uso de transacciones es una forma de garantizar que la base de datos distribuida de Mnesia permanezca consistente, incluso cuando muchos procesos diferentes la actualizan en paralelo. Sin embargo, si tiene requisitos en tiempo real, se recomienda utilizar operaciones &lt;code&gt;dirty&lt;/code&gt; en lugar de transacciones. Al utilizar operaciones &lt;code&gt;dirty&lt;/code&gt; , pierde la garant&amp;iacute;a de consistencia; esto generalmente se resuelve dejando que solo un proceso actualice la tabla. Otros procesos deben enviar solicitudes de actualizaci&amp;oacute;n a ese proceso.</target>
        </trans-unit>
        <trans-unit id="2cb7bee577205f37d65f9821375accf63f59b42f" translate="yes" xml:space="preserve">
          <source>Usually a few managers communicate with many agents.</source>
          <target state="translated">Normalmente unos pocos gerentes se comunican con muchos agentes.</target>
        </trans-unit>
        <trans-unit id="cdaebc21aedbdaa85649f3457b904bb990d3b2ea" translate="yes" xml:space="preserve">
          <source>Usually a line is added that is to state:</source>
          <target state="translated">Normalmente se añade una línea que es para indicar:</target>
        </trans-unit>
        <trans-unit id="f7c9ebf9950b5eb0782b3cd23c9a753ea0c5e533" translate="yes" xml:space="preserve">
          <source>Usually it suffices to detect time-outs on receive, as most protocols include some sort of acknowledgment from the server, but if the protocol is strictly one way, option &lt;code&gt;send_timeout&lt;/code&gt; comes in handy.</source>
          <target state="translated">Por lo general, es suficiente detectar tiempos de espera en la recepci&amp;oacute;n, ya que la mayor&amp;iacute;a de los protocolos incluyen alg&amp;uacute;n tipo de reconocimiento del servidor, pero si el protocolo es estrictamente unidireccional, la opci&amp;oacute;n &lt;code&gt;send_timeout&lt;/code&gt; resulta &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="72f960a27f294ee8a3a2af0d51fbe8531fe5bf1b" translate="yes" xml:space="preserve">
          <source>Usually one of &lt;code&gt;&quot;System&quot;&lt;/code&gt;, &lt;code&gt;&quot;Application&quot;&lt;/code&gt; or &lt;code&gt;&quot;Security&quot;&lt;/code&gt;. Note that the NT eventlog viewer has another notion of category, which in most cases is totally meaningless and therefore not imported into Erlang. What is called a category here is one of the main three types of events occurring in a normal NT system.</source>
          <target state="translated">Por lo general, uno de &lt;code&gt;&quot;System&quot;&lt;/code&gt; , &lt;code&gt;&quot;Application&quot;&lt;/code&gt; o &lt;code&gt;&quot;Security&quot;&lt;/code&gt; . Tenga en cuenta que el visor de registro de eventos de NT tiene otra noci&amp;oacute;n de categor&amp;iacute;a, que en la mayor&amp;iacute;a de los casos no tiene ning&amp;uacute;n significado y, por lo tanto, no se importa a Erlang. Lo que aqu&amp;iacute; se llama categor&amp;iacute;a es uno de los tres tipos principales de eventos que ocurren en un sistema NT normal.</target>
        </trans-unit>
        <trans-unit id="eaa3a8b7b3a6f1f39061eab776dd864c04df5840" translate="yes" xml:space="preserve">
          <source>Usually, the entities defined in the MIB are called &lt;strong&gt;Managed Objects (MOs)&lt;/strong&gt;, although they do not have to be objects in the object-oriented way. For example, a simple scalar variable defined in a MIB is called an MO. The MOs are logical objects, not necessarily with a one-to-one mapping to the resources.</source>
          <target state="translated">Por lo general, las entidades definidas en la MIB se denominan &lt;strong&gt;objetos administrados (MO)&lt;/strong&gt; , aunque no tienen por qu&amp;eacute; ser objetos en la forma orientada a objetos. Por ejemplo, una variable escalar simple definida en un MIB se llama MO. Los MO son objetos l&amp;oacute;gicos, no necesariamente con un mapeo uno a uno a los recursos.</target>
        </trans-unit>
        <trans-unit id="34333d124dba7ee56119ecbb8915169706ed629f" translate="yes" xml:space="preserve">
          <source>Utility for reading and creating 'zip' archives.</source>
          <target state="translated">Utilidad para leer y crear archivos 'zip'.</target>
        </trans-unit>
        <trans-unit id="4587d8ae182b07cd6c5ddcc7013d5c9b99960884" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;BITS&lt;/code&gt; to &lt;code&gt;OCTET-STRING&lt;/code&gt;.</source>
          <target state="translated">Funci&amp;oacute;n de utilidad para convertir un valor de tipo &lt;code&gt;BITS&lt;/code&gt; en &lt;code&gt;OCTET-STRING&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0e44844d0966f1f6069d31b91bf4a8abdb72b4d1" translate="yes" xml:space="preserve">
          <source>Utility function for converting a value of type &lt;code&gt;OCTET-STRING&lt;/code&gt; to &lt;code&gt;BITS&lt;/code&gt;.</source>
          <target state="translated">Funci&amp;oacute;n de utilidad para convertir un valor de tipo &lt;code&gt;OCTET-STRING&lt;/code&gt; en &lt;code&gt;BITS&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4388b46bdace9a8dd94930d061cd808992ffbdfc" translate="yes" xml:space="preserve">
          <source>Utility function that starts the applications &lt;code&gt;crypto&lt;/code&gt;, &lt;code&gt;public_key&lt;/code&gt;, and &lt;code&gt;ssh&lt;/code&gt;. Default type is &lt;code&gt;temporary&lt;/code&gt;. For more information, see the &lt;code&gt;application(3)&lt;/code&gt; manual page in Kernel.</source>
          <target state="translated">Funci&amp;oacute;n de utilidad que inicia las aplicaciones &lt;code&gt;crypto&lt;/code&gt; , &lt;code&gt;public_key&lt;/code&gt; y &lt;code&gt;ssh&lt;/code&gt; . El tipo predeterminado es &lt;code&gt;temporary&lt;/code&gt; . Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la p&amp;aacute;gina de manual de la &lt;code&gt;application(3)&lt;/code&gt; en Kernel.</target>
        </trans-unit>
        <trans-unit id="4c7f90797d67794eeec5a51cfe794b557e3c3507" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formated printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions.</source>
          <target state="translated">Funci&amp;oacute;n de utilidad para producir una impresi&amp;oacute;n formateada de la informaci&amp;oacute;n de versiones generada por las funciones de &lt;code&gt;versions1&lt;/code&gt; y &lt;code&gt;versions2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0bbbc215beb617665e30c05f1df892f3ab385b7d" translate="yes" xml:space="preserve">
          <source>Utility function to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; and &lt;code&gt;versions2&lt;/code&gt; functions</source>
          <target state="translated">Funci&amp;oacute;n de utilidad para producir una impresi&amp;oacute;n formateada de la informaci&amp;oacute;n de versiones generada por las funciones de &lt;code&gt;versions1&lt;/code&gt; y &lt;code&gt;versions2&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e9ca3adcd5764dc7d65f56277bec220d9992d1f5" translate="yes" xml:space="preserve">
          <source>Utility function(s) to produce a formatted printout of the versions info generated by the &lt;code&gt;versions1&lt;/code&gt; function</source>
          <target state="translated">Funci&amp;oacute;n (es) de utilidad para producir una impresi&amp;oacute;n formateada de la informaci&amp;oacute;n de versiones generada por la funci&amp;oacute;n &lt;code&gt;versions1&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e9a4acca18dc29ce31970a704bacd6a0999cfc7" translate="yes" xml:space="preserve">
          <source>Utility functions for Core Erlang case/receive clauses.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9d38534bb1763cd2ba3d18a6d7ecd6c0ae55401" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the agent config files.</source>
          <target state="translated">Funciones de utilidad para manejar los archivos de configuración del agente.</target>
        </trans-unit>
        <trans-unit id="2afa581e37f140ef78590e09404a9aae431c2390" translate="yes" xml:space="preserve">
          <source>Utility functions for handling the manager config files.</source>
          <target state="translated">Funciones de utilidad para manejar los archivos de configuración del administrador.</target>
        </trans-unit>
        <trans-unit id="6433ab0ec2c7394b801c26a999984771d7a0ae8b" translate="yes" xml:space="preserve">
          <source>Utility functions used to retrieve some system and application info.</source>
          <target state="translated">Funciones de utilidad utilizadas para recuperar alguna información del sistema y de la aplicación.</target>
        </trans-unit>
        <trans-unit id="aa9f46ccd3ba41c02d70b7e973f34c959fc38d56" translate="yes" xml:space="preserve">
          <source>VACM is described in detail in RFC2275. Here is only a brief description given.</source>
          <target state="translated">El VACM se describe en detalle en el RFC2275.Aquí sólo se da una breve descripción.</target>
        </trans-unit>
        <trans-unit id="4f374392fc8216fb266b35c7afa3c5383908a973" translate="yes" xml:space="preserve">
          <source>Vai</source>
          <target state="translated">Vai</target>
        </trans-unit>
        <trans-unit id="c8a5c44daefed8fa60457df49456ebe3ace77f95" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BackupItems&lt;/code&gt; are the following tuples:</source>
          <target state="translated">Los elementos de &lt;code&gt;BackupItems&lt;/code&gt; v&amp;aacute;lidos son las siguientes tuplas:</target>
        </trans-unit>
        <trans-unit id="8f005ec226ccd5bd77580fd1619b366495013be6" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;BindType&lt;/code&gt;s:</source>
          <target state="translated">&lt;code&gt;BindType&lt;/code&gt; s v&amp;aacute;lidos :</target>
        </trans-unit>
        <trans-unit id="3768a7ccfdefa3ace61d00f77e188549db26cf0f" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;InfoTuple&lt;/code&gt;s with corresponding &lt;code&gt;Item&lt;/code&gt;s:</source>
          <target state="translated">&lt;code&gt;InfoTuple&lt;/code&gt; v&amp;aacute;lidos con los &lt;code&gt;Item&lt;/code&gt; correspondientes :</target>
        </trans-unit>
        <trans-unit id="bc05afbe09b2e8c8117fcc39f7f35cc60250e0d4" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for functions:</source>
          <target state="translated">V&amp;aacute;lido &lt;code&gt;Item&lt;/code&gt; es para las funciones:</target>
        </trans-unit>
        <trans-unit id="cf53d05dcad2f68d3d2da7de03839fc48e89fb6c" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Item&lt;/code&gt;s for ports and processes:</source>
          <target state="translated">&lt;code&gt;Item&lt;/code&gt; v&amp;aacute;lidos para puertos y procesos:</target>
        </trans-unit>
        <trans-unit id="52a65f9e3e7dcb0306411c6c3f71279192f79ba0" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Option&lt;/code&gt;s:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="531c29f343d1120961be4920ea66239ca958e2cd" translate="yes" xml:space="preserve">
          <source>Valid &lt;code&gt;Reply&lt;/code&gt; values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="267195f93799c6c9557e8b18de85ebfc710db9e1" translate="yes" xml:space="preserve">
          <source>Valid Erlang expressions and guard sequences are described in &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Las expresiones de Erlang y las secuencias de protecci&amp;oacute;n v&amp;aacute;lidas se describen en &lt;code&gt;&lt;a href=&quot;expressions&quot;&gt;Expressions&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b338a1ad5b1c7b18820779179ab41de826744b2b" translate="yes" xml:space="preserve">
          <source>Valid Return Values</source>
          <target state="translated">Valores de retorno válidos</target>
        </trans-unit>
        <trans-unit id="efbf48a6212e82d31e363fa76b710eb93043cb0c" translate="yes" xml:space="preserve">
          <source>Valid categories are:</source>
          <target state="translated">Las categorías válidas son:</target>
        </trans-unit>
        <trans-unit id="e1cdb0f6fd9b5c7ae6270cdbd6aa6489ff170a68" translate="yes" xml:space="preserve">
          <source>Valid limits are values in the range &lt;code&gt;[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]&lt;/code&gt;. Limits are automatically adjusted to be sane. That is, the system adjusts values so that the low limit used is lower than or equal to the high limit used. By default the high limit is 8 kB and the low limit is 4 kB.</source>
          <target state="translated">Los l&amp;iacute;mites v&amp;aacute;lidos son valores en el rango &lt;code&gt;[ERL_DRV_BUSY_MSGQ_LIM_MIN, ERL_DRV_BUSY_MSGQ_LIM_MAX]&lt;/code&gt; . Los l&amp;iacute;mites se ajustan autom&amp;aacute;ticamente para estar cuerdos. Es decir, el sistema ajusta los valores de modo que el l&amp;iacute;mite inferior utilizado sea inferior o igual al l&amp;iacute;mite superior utilizado. Por defecto, el l&amp;iacute;mite superior es de 8 kB y el l&amp;iacute;mite inferior es de 4 kB.</target>
        </trans-unit>
        <trans-unit id="ead2bf03d6fc68d606be1689e0611b409e03bb2a" translate="yes" xml:space="preserve">
          <source>Valid option:</source>
          <target state="translated">Opción válida:</target>
        </trans-unit>
        <trans-unit id="2c6356256194f4dacdd3ceac883fb104c7079f63" translate="yes" xml:space="preserve">
          <source>Valid options &lt;code&gt;set_options&lt;/code&gt; are:</source>
          <target state="translated">Las opciones v&amp;aacute;lidas de &lt;code&gt;set_options&lt;/code&gt; son:</target>
        </trans-unit>
        <trans-unit id="eeda404dab46510032ac078c150033a69675f334" translate="yes" xml:space="preserve">
          <source>Valid options depends on what options are supported by the node identified by &lt;code&gt;Node&lt;/code&gt;. A description of valid &lt;code&gt;Option&lt;/code&gt;s for the local node of current OTP version can be found in the documentation of &lt;code&gt;&lt;a href=&quot;#spawn_opt-4&quot;&gt;spawn_opt/4&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="850c962c3f063b586578621ee12bbb84d6f38bb7" translate="yes" xml:space="preserve">
          <source>Valid options:</source>
          <target state="translated">Opciones válidas:</target>
        </trans-unit>
        <trans-unit id="e4f1c0729761400496e047f8f256412e68cceee0" translate="yes" xml:space="preserve">
          <source>Valid return values</source>
          <target state="translated">Valores de retorno válidos</target>
        </trans-unit>
        <trans-unit id="1630b32c9530f31c96e521c8cf0ccc55338fbbc7" translate="yes" xml:space="preserve">
          <source>Valid values for &lt;code&gt;NodeType&lt;/code&gt;:</source>
          <target state="translated">Valores v&amp;aacute;lidos para &lt;code&gt;NodeType&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="82b8127698b8ef2cfa8edc57143af42260620903" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element (Element).</source>
          <target state="translated">Valida un elemento XML bien formado (Elemento).</target>
        </trans-unit>
        <trans-unit id="b239d15c1167b7afc50fb4ba90a070cafbcead1e" translate="yes" xml:space="preserve">
          <source>Validates a parsed well-formed XML element towards an XML schema.</source>
          <target state="translated">Valida un elemento XML bien formado hacia un esquema XML.</target>
        </trans-unit>
        <trans-unit id="30aa57af8387dd9dda72f74225d0c83ea7830682" translate="yes" xml:space="preserve">
          <source>Validates in two steps. First it processes the schema, saves the type and structure info in an ets table and then validates the element towards the schema.</source>
          <target state="translated">Valida en dos pasos.Primero procesa el esquema,graba la información de tipo y estructura en una tabla ets y luego valida el elemento hacia el esquema.</target>
        </trans-unit>
        <trans-unit id="d81dc9238e6ae4be4cef7714f7fca70a30cc0272" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;default&lt;/code&gt; states that the predefined properties are to be used.</source>
          <target state="translated">El valor &lt;code&gt;default&lt;/code&gt; indica que se utilizar&amp;aacute;n las propiedades predefinidas.</target>
        </trans-unit>
        <trans-unit id="8f4b4232752a2d39d8445512cde28d28668f7d1f" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;force&lt;/code&gt; means that a reparation is made even if the table is properly closed. This is a seldom needed option.</source>
          <target state="translated">Valor de &lt;code&gt;force&lt;/code&gt; significa que se realiza una reparaci&amp;oacute;n incluso si la mesa est&amp;aacute; correctamente cerrada. Esta es una opci&amp;oacute;n que rara vez se necesita.</target>
        </trans-unit>
        <trans-unit id="9fbeacf98f8026e5fab1b1d01a773952a1337a76" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables burst control and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="translated">El valor &lt;code&gt;true&lt;/code&gt; habilita el control de r&amp;aacute;fagas y &lt;code&gt;false&lt;/code&gt; deshabilita.</target>
        </trans-unit>
        <trans-unit id="e3e5e9f151e03304f82baa34e7f4f70c22fcd0d8" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;true&lt;/code&gt; enables the feature and &lt;code&gt;false&lt;/code&gt; disables it.</source>
          <target state="translated">El valor &lt;code&gt;true&lt;/code&gt; habilita la funci&amp;oacute;n y &lt;code&gt;false&lt;/code&gt; deshabilita.</target>
        </trans-unit>
        <trans-unit id="54db79fce832cc1178c718ad9c79945056373188" translate="yes" xml:space="preserve">
          <source>Value &lt;code&gt;undefined&lt;/code&gt; for &lt;code&gt;A&lt;/code&gt; (the argument list) is only to be used internally in &lt;code&gt;supervisor&lt;/code&gt;. If the restart type of the child is &lt;code&gt;temporary&lt;/code&gt;, the process is never to be restarted and therefore there is no need to store the real argument list. Value &lt;code&gt;undefined&lt;/code&gt; is then stored instead.</source>
          <target state="translated">El valor &lt;code&gt;undefined&lt;/code&gt; para &lt;code&gt;A&lt;/code&gt; (la lista de argumentos) solo debe usarse internamente en el &lt;code&gt;supervisor&lt;/code&gt; . Si el tipo de reinicio del ni&amp;ntilde;o es &lt;code&gt;temporary&lt;/code&gt; , el proceso nunca se reiniciar&amp;aacute; y, por lo tanto, no es necesario almacenar la lista de argumentos real. El valor &lt;code&gt;undefined&lt;/code&gt; se almacena en su lugar.</target>
        </trans-unit>
        <trans-unit id="b4c13cbe61dee9b68ffaef6134995ebd910fbd5e" translate="yes" xml:space="preserve">
          <source>Value = IOString | atom() | integer()</source>
          <target state="translated">Valor=IOString | átomo()| entero()</target>
        </trans-unit>
        <trans-unit id="1bbca064dbc2becbd7d3555273dcd4ac5b367fab" translate="yes" xml:space="preserve">
          <source>Value of a configuration parameter.</source>
          <target state="translated">Valor de un parámetro de configuración.</target>
        </trans-unit>
        <trans-unit id="384e64d4c66abb9cfb384072bb26c3dd0bab6612" translate="yes" xml:space="preserve">
          <source>Value to convert time unit for.</source>
          <target state="translated">Valor para el que convertir la unidad de tiempo.</target>
        </trans-unit>
        <trans-unit id="768d2b954af31866b6e32d7a85e19622323f08f3" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;atom()&lt;/code&gt;</source>
          <target state="translated">Valor: &lt;code&gt;atom()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="97045cfdad33dd3dba2b9ed63a6c87874f526b4d" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="translated">Valor: &lt;code&gt;boolean()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="a052394fb5d5289ec24690454284914e11a61275" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;integer()&lt;/code&gt;</source>
          <target state="translated">Valor: &lt;code&gt;integer()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="813cf4fbeafa5124c59029940c3b8ba23a170cb6" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;on | off&lt;/code&gt;</source>
          <target state="translated">Valor: &lt;code&gt;on | off&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="65c8d38d0b9fb94d17867d4881ce4e1d9d89030a" translate="yes" xml:space="preserve">
          <source>Value: &lt;code&gt;runtime | reductions | memory | msg_q&lt;/code&gt;</source>
          <target state="translated">Valor: &lt;code&gt;runtime | reductions | memory | msg_q&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6970e248833158e8e073b58247bd68dcfc9cbf85" translate="yes" xml:space="preserve">
          <source>Values can be assigned in Erlang as follows:</source>
          <target state="translated">Los valores pueden asignarse en Erlang de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="2cb45cee19fe1842c7fe4075c27f3b1076ddd053" translate="yes" xml:space="preserve">
          <source>Values can be assigned to an ASN.1 type within the ASN.1 code itself, as opposed to the actions in the previous section where a value was assigned to an ASN.1 type in Erlang. The full value syntax of ASN.1 is supported and X.680 describes in detail how to assign values in ASN.1. A short example:</source>
          <target state="translated">Se pueden asignar valores a un tipo de ASN.1 dentro del propio código ASN.1,a diferencia de las acciones de la sección anterior en las que se asignaba un valor a un tipo de ASN.1 en Erlang.Se admite la sintaxis completa de valores de ASN.1 y X.680 describe en detalle cómo asignar valores en ASN.1.Un breve ejemplo:</target>
        </trans-unit>
        <trans-unit id="0cebf5af2c916d50162daf2371942434d298c322" translate="yes" xml:space="preserve">
          <source>Values corresponding to the R(equest), P(roxiable), E(rror) and T(Potentially re-transmitted message) flags of the Diameter header.</source>
          <target state="translated">Valores correspondientes a las banderas R(equest),P(roxiable),E(rror)y T(mensaje potencialmente retransmitido)del encabezamiento del Diámetro.</target>
        </trans-unit>
        <trans-unit id="96ef06f93f26e99ce4292fa7f5fd3f23d636c4eb" translate="yes" xml:space="preserve">
          <source>Values in the AVP header, corresponding to AVP Code, the M flag, P flags and Vendor-ID respectively. A Vendor-ID other than &lt;code&gt;undefined&lt;/code&gt; implies a set V flag.</source>
          <target state="translated">Valores en el encabezado AVP, correspondientes al c&amp;oacute;digo AVP, la bandera M, las banderas P y el ID de proveedor, respectivamente. Un Vendor-ID que &lt;code&gt;undefined&lt;/code&gt; sea indefinido implica un indicador V establecido.</target>
        </trans-unit>
        <trans-unit id="a0444f2cacebf8b2705dc3aa6c687df85244bfd3" translate="yes" xml:space="preserve">
          <source>Values of the Version, Message Length, Command-Code, Application-ID, Hop-by-Hop Identifier and End-to-End Identifier fields of the Diameter header.</source>
          <target state="translated">Valores de los campos Versión,Longitud del mensaje,Código de comando,Identificación de la aplicación,Identificador &quot;Hop-by-Hop&quot; e Identificador &quot;End-to-End&quot; del encabezado Diámetro.</target>
        </trans-unit>
        <trans-unit id="25b7b3117ec67f563a385f6a6bbb3fc464310423" translate="yes" xml:space="preserve">
          <source>Values of these types are not currently parsed by diameter.</source>
          <target state="translated">Los valores de estos tipos no están actualmente analizados por el diámetro.</target>
        </trans-unit>
        <trans-unit id="d14186fcac41fa3af58224092399d938dd7267c2" translate="yes" xml:space="preserve">
          <source>Values of this type can be assigned a value as an ordinary string as follows:</source>
          <target state="translated">A los valores de este tipo se les puede asignar un valor como una cadena ordinaria de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="297576f454c4d00030676aa9862a2b6c6efbd141" translate="yes" xml:space="preserve">
          <source>Values of type &lt;code&gt;Emb&lt;/code&gt; can be assigned as follows:</source>
          <target state="translated">Los valores de tipo &lt;code&gt;Emb&lt;/code&gt; se pueden asignar de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="cee70396c85e9d16e65df42fd317982706258e73" translate="yes" xml:space="preserve">
          <source>Variable ::= - same as Erlang variables -</source>
          <target state="translated">Variable ::=-igual que las variables de Erlang -</target>
        </trans-unit>
        <trans-unit id="748e5ba4cc296f39b4935e55b1705fc8ee581ce2" translate="yes" xml:space="preserve">
          <source>Variable &lt;code&gt;A&lt;/code&gt; is bound to the evaluated value of the list comprehension (&lt;code&gt;[1,2]&lt;/code&gt;). The compiler complains with an error message (&quot;argument is not a query list comprehension&quot;); the shell process stops with a &lt;code&gt;badarg&lt;/code&gt; reason.</source>
          <target state="translated">La variable &lt;code&gt;A&lt;/code&gt; est&amp;aacute; vinculada al valor evaluado de la comprensi&amp;oacute;n de la lista ( &lt;code&gt;[1,2]&lt;/code&gt; ). El compilador se queja con un mensaje de error (&quot;el argumento no es una comprensi&amp;oacute;n de la lista de consultas&quot;); el proceso de shell se detiene por una raz&amp;oacute;n &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9a90e8a96c62ffb5d1cd6f65922e2fc9c80f1799" translate="yes" xml:space="preserve">
          <source>Variable bindings, and local process dictionary changes that are generated in user expressions are preserved, and the variables can be used in later commands to access their values. The bindings can also be forgotten so the variables can be reused.</source>
          <target state="translated">Se conservan los enlaces de variables y los cambios en el diccionario de procesos locales que se generan en las expresiones de usuario,y las variables pueden utilizarse en comandos posteriores para acceder a sus valores.Los enlaces también pueden ser olvidados para que las variables puedan ser reutilizadas.</target>
        </trans-unit>
        <trans-unit id="d0a8ee25c863aa2419107fceb204e47f57f1db36" translate="yes" xml:space="preserve">
          <source>Variable key length from 32 bits up to 448 bits</source>
          <target state="translated">Longitud de clave variable desde 32 bits hasta 448 bits</target>
        </trans-unit>
        <trans-unit id="bfc036b2b9309c7bdc08e56f286b100a63accced" translate="yes" xml:space="preserve">
          <source>Variable key length from 8 bits up to 2048 bits (usually between 40 and 256)</source>
          <target state="translated">Longitud de la clave variable desde 8 bits hasta 2048 bits (normalmente entre 40 y 256)</target>
        </trans-unit>
        <trans-unit id="ac018db1f7b00972061adff843d37497d8ee153c" translate="yes" xml:space="preserve">
          <source>Variables</source>
          <target state="translated">Variables</target>
        </trans-unit>
        <trans-unit id="98c3d8899ac90eda2399d72ac989d5a5b85bf50c" translate="yes" xml:space="preserve">
          <source>Variables are bound to values through the &lt;strong&gt;pattern matching&lt;/strong&gt; mechanism. Pattern matching occurs when evaluating a function call, &lt;code&gt;case&lt;/code&gt;- &lt;code&gt;receive&lt;/code&gt;- &lt;code&gt;try&lt;/code&gt;- expressions and match operator (=) expressions.</source>
          <target state="translated">Las variables est&amp;aacute;n vinculadas a valores a trav&amp;eacute;s del mecanismo de &lt;strong&gt;coincidencia de patrones&lt;/strong&gt; . La coincidencia de patrones se produce cuando se eval&amp;uacute;a una llamada de funci&amp;oacute;n, expresiones de &lt;code&gt;case&lt;/code&gt; - &lt;code&gt;receive&lt;/code&gt; - &lt;code&gt;try&lt;/code&gt; y expresiones de operador de coincidencia (=).</target>
        </trans-unit>
        <trans-unit id="2184e01d1f22737f67295ee5c99577b7f02640c4" translate="yes" xml:space="preserve">
          <source>Variables are bound to values using &lt;code&gt;&lt;a href=&quot;patterns&quot;&gt;pattern matching&lt;/a&gt;&lt;/code&gt;. Erlang uses &lt;strong&gt;single assignment&lt;/strong&gt;, that is, a variable can only be bound once.</source>
          <target state="translated">Las variables est&amp;aacute;n vinculadas a valores mediante &lt;code&gt;&lt;a href=&quot;patterns&quot;&gt;pattern matching&lt;/a&gt;&lt;/code&gt; . Erlang usa &lt;strong&gt;una asignaci&amp;oacute;n &amp;uacute;nica&lt;/strong&gt; , es decir, una variable solo se puede vincular una vez.</target>
        </trans-unit>
        <trans-unit id="af1686696b0da48d910d4a99c77d1e302b425bc7" translate="yes" xml:space="preserve">
          <source>Variables can also be used to improve the readability of programs. For example, in function &lt;code&gt;list_max/2&lt;/code&gt; above, you can write:</source>
          <target state="translated">Las variables tambi&amp;eacute;n se pueden utilizar para mejorar la legibilidad de los programas. Por ejemplo, en la funci&amp;oacute;n &lt;code&gt;list_max/2&lt;/code&gt; anterior, puede escribir:</target>
        </trans-unit>
        <trans-unit id="e040ee86e634cf4aa0be3ce9492a2d6be860d5dc" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a fun.</source>
          <target state="translated">Las variables no pueden ser exportadas de una diversión.</target>
        </trans-unit>
        <trans-unit id="9c57858e4cc8b9cf7467d2261e8b3c42734717f8" translate="yes" xml:space="preserve">
          <source>Variables cannot be exported from a list comprehension.</source>
          <target state="translated">Las variables no pueden exportarse a partir de la comprensión de una lista.</target>
        </trans-unit>
        <trans-unit id="f8d2854195ed04278e5b7b15a33240c69501a326" translate="yes" xml:space="preserve">
          <source>Variables exported from &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;case&lt;/code&gt;/&lt;code&gt;receive&lt;/code&gt;</source>
          <target state="translated">Variables exportadas de &lt;code&gt;if&lt;/code&gt; / &lt;code&gt;case&lt;/code&gt; / &lt;code&gt;receive&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5eb952951e49a9b2fcfc380fe82f3b23f85123e9" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that the following works:</source>
          <target state="translated">Las variables del medio ambiente pueden ser importadas,para que funcione</target>
        </trans-unit>
        <trans-unit id="ed92f2d37abdcb00aafc2e8c807cfc991b6f8842" translate="yes" xml:space="preserve">
          <source>Variables from the environment can be imported, so that this works:</source>
          <target state="translated">Las variables del medio ambiente pueden ser importadas,para que esto funcione:</target>
        </trans-unit>
        <trans-unit id="e88c0b53ad71637f25dfbd793cc2441d427e3881" translate="yes" xml:space="preserve">
          <source>Variables imported into matches</source>
          <target state="translated">Las variables importadas en los fósforos</target>
        </trans-unit>
        <trans-unit id="1b2ab1f9eb238cbc2cccee8878b2d4f07a335e18" translate="yes" xml:space="preserve">
          <source>Variables in a fun head shadow the function name and both shadow variables in the function clause surrounding the fun expression. Variables bound in a fun body are local to the fun body.</source>
          <target state="translated">Las variables en una cabeza divertida sombrean el nombre de la función y ambas variables de sombra en la cláusula de la función que rodea la expresión divertida.Las variables unidas en un cuerpo de diversión son locales al cuerpo de diversión.</target>
        </trans-unit>
        <trans-unit id="18d218f35a2e3577a6c500538445abcceb060b64" translate="yes" xml:space="preserve">
          <source>Variables in this section are only used, when configuring Erlang/OTP for cross compilation using &lt;code&gt;$ERL_TOP/otp_build configure&lt;/code&gt;.</source>
          <target state="translated">Las variables en esta secci&amp;oacute;n solo se usan cuando se configura Erlang / OTP para compilaci&amp;oacute;n cruzada usando &lt;code&gt;$ERL_TOP/otp_build configure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="08df3acc57d3675cf908a2f26030ccd4ae2beb38" translate="yes" xml:space="preserve">
          <source>Variables occurring in the head of the fun are replaced by match specification variables in the order of occurrence, so that fragment &lt;code&gt;fun({A,B,C})&lt;/code&gt; is replaced by &lt;code&gt;{'$1', '$2', '$3'}&lt;/code&gt;, and so on. Every occurrence of such a variable in the match specification is replaced by a match specification variable in the same way, so that the fun &lt;code&gt;fun({A,B}) when is_atom(A) -&amp;gt; B end&lt;/code&gt; is translated into &lt;code&gt;[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]&lt;/code&gt;.</source>
          <target state="translated">Las variables que aparecen en el encabezado de la diversi&amp;oacute;n se reemplazan por variables de especificaci&amp;oacute;n de coincidencia en el orden de aparici&amp;oacute;n, de modo que la &lt;code&gt;fun({A,B,C})&lt;/code&gt; fragmento ({A, B, C}) se reemplaza por &lt;code&gt;{'$1', '$2', '$3'}&lt;/code&gt; , y as&amp;iacute;. Cada aparici&amp;oacute;n de dicha variable en la especificaci&amp;oacute;n de coincidencia se reemplaza por una variable de especificaci&amp;oacute;n de coincidencia de la misma manera, de modo que la diversi&amp;oacute;n &lt;code&gt;fun({A,B}) when is_atom(A) -&amp;gt; B end&lt;/code&gt; se traduce en &lt;code&gt;[{{'$1','$2'},[{is_atom,'$1'}],['$2']}]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f0ae0e8be972f79e65125dff2b6c4f9cdfb890f0" translate="yes" xml:space="preserve">
          <source>Variables of type &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; can refer to any Erlang term. This is an opaque type and values of it can only by used either as arguments to API functions or as return values from NIFs. All &lt;code&gt;ERL_NIF_TERM&lt;/code&gt;s belong to an environment (&lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt;). A term cannot be destructed individually, it is valid until its environment is destructed.</source>
          <target state="translated">Las variables de tipo &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; pueden hacer referencia a cualquier t&amp;eacute;rmino de Erlang. Este es un tipo opaco y sus valores solo se pueden usar como argumentos para funciones API o como valores de retorno de NIF. Todos los &lt;code&gt;ERL_NIF_TERM&lt;/code&gt; s pertenecen a un entorno ( &lt;code&gt;&lt;a href=&quot;#ErlNifEnv&quot;&gt;ErlNifEnv&lt;/a&gt;&lt;/code&gt; ). Un t&amp;eacute;rmino no se puede destruir individualmente, es v&amp;aacute;lido hasta que se destruye su entorno.</target>
        </trans-unit>
        <trans-unit id="debd1f76422a0d8de3199d01bf29f5e66c2af413" translate="yes" xml:space="preserve">
          <source>Variables shadowed in funs and list comprehensions</source>
          <target state="translated">Variables sombreadas en las diversiones y la comprensión de las listas</target>
        </trans-unit>
        <trans-unit id="d19ebfb8e1f3e97056afbbe53540cc96bcfb11ed" translate="yes" xml:space="preserve">
          <source>Variables start with an uppercase letter or underscore (_). Variables can contain alphanumeric characters, underscore and &lt;code&gt;@&lt;/code&gt;.</source>
          <target state="translated">Las variables comienzan con una letra may&amp;uacute;scula o un gui&amp;oacute;n bajo (_). Las variables pueden contener caracteres alfanum&amp;eacute;ricos, subrayado y &lt;code&gt;@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09f862d436d21532b455bff8e767c989deff6bc5" translate="yes" xml:space="preserve">
          <source>Variables starting with &lt;code&gt;_@&lt;/code&gt;, for example &lt;code&gt;_@bar&lt;/code&gt; or &lt;code&gt;_@Bar&lt;/code&gt;</source>
          <target state="translated">Variables que comienzan con &lt;code&gt;_@&lt;/code&gt; , por ejemplo &lt;code&gt;_@bar&lt;/code&gt; o &lt;code&gt;_@Bar&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="1225854353b77d49f7cc40d13247de7c80827209" translate="yes" xml:space="preserve">
          <source>Variables starting with underscore (_), for example, &lt;code&gt;_Height&lt;/code&gt;, are normal variables, not anonymous. They are however ignored by the compiler in the sense that they do not generate any warnings for unused variables.</source>
          <target state="translated">Variables empezando con subrayado (_), por ejemplo, &lt;code&gt;_Height&lt;/code&gt; , son variables normales, no an&amp;oacute;nimos. Sin embargo, el compilador las ignora en el sentido de que no generan ninguna advertencia para las variables no utilizadas.</target>
        </trans-unit>
        <trans-unit id="024d797490e6edf809ed5b6c2e34f4bc4f3bebd1" translate="yes" xml:space="preserve">
          <source>Variables take the form &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt;, where &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; is an integer between 0 and 100,000,000 (1e+8). The behavior if the number is outside these limits is &lt;strong&gt;undefined&lt;/strong&gt;. In the &lt;code&gt;MatchHead&lt;/code&gt; part, the special variable &lt;code&gt;'_'&lt;/code&gt; matches anything, and never gets bound (like &lt;code&gt;_&lt;/code&gt; in Erlang).</source>
          <target state="translated">Las variables toman la forma &lt;code&gt;'$&amp;lt;number&amp;gt;'&lt;/code&gt; , donde &lt;code&gt;&amp;lt;number&amp;gt;&lt;/code&gt; es un n&amp;uacute;mero entero entre 0 y 100.000.000 (1e + 8). El comportamiento si el n&amp;uacute;mero est&amp;aacute; fuera de estos l&amp;iacute;mites &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute; &lt;strong&gt;definido&lt;/strong&gt; . En la parte &lt;code&gt;MatchHead&lt;/code&gt; , la variable especial &lt;code&gt;'_'&lt;/code&gt; coincide con cualquier cosa y nunca se enlaza (como &lt;code&gt;_&lt;/code&gt; en Erlang).</target>
        </trans-unit>
        <trans-unit id="00bf9ad78f5cec1dd65d66ced1104921a78f995a" translate="yes" xml:space="preserve">
          <source>Variables that are defined before the fun, and that occur in function calls or guard tests within the fun, have the values they had outside the fun.</source>
          <target state="translated">Las variables que se definen antes de la diversión,y que se producen en llamadas de función o pruebas de guardia dentro de la diversión,tienen los valores que tenían fuera de la diversión.</target>
        </trans-unit>
        <trans-unit id="bf0dcb58581abd4fe80849d394380c5cd405dc3e" translate="yes" xml:space="preserve">
          <source>Variables that are not included in the head are imported from the environment and made into match specification &lt;code&gt;const&lt;/code&gt; expressions. Example from the shell:</source>
          <target state="translated">Las variables que no est&amp;aacute;n incluidas en el encabezado se importan del entorno y se convierten en expresiones &lt;code&gt;const&lt;/code&gt; de especificaci&amp;oacute;n de coincidencia . Ejemplo del caparaz&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="e0fa7e4c68a7ab8979529890e0791f677b7bd7ef" translate="yes" xml:space="preserve">
          <source>Variables that have been bound on the left side can be used on the right side. For example, this rule will rewrite all &lt;code&gt;move&lt;/code&gt; instructions to &lt;code&gt;assign&lt;/code&gt; instructions with the operands swapped:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55df9f3ef32c412357dbc3a18bd56c7d4ce619de" translate="yes" xml:space="preserve">
          <source>Variance :: number(),</source>
          <target state="translated">Variación ::número(),</target>
        </trans-unit>
        <trans-unit id="0e31c4461c806559eaf12528c8fe9a9d293a746d" translate="yes" xml:space="preserve">
          <source>Various &quot;isolate&quot;s</source>
          <target state="translated">Varios &quot;aislamientos&quot;</target>
        </trans-unit>
        <trans-unit id="a1d64fcf9bb61fad40e3871e66b33e563f5b1f28" translate="yes" xml:space="preserve">
          <source>Various Erlang net administration routines.</source>
          <target state="translated">Varias rutinas de administración de la red Erlang.</target>
        </trans-unit>
        <trans-unit id="f6b924712003f40d3f2878b1cac363cf1976078c" translate="yes" xml:space="preserve">
          <source>Vendor-Id AVP</source>
          <target state="translated">Vendor-Id AVP</target>
        </trans-unit>
        <trans-unit id="48eb606505901d94f78b31e43f73e095bdf04786" translate="yes" xml:space="preserve">
          <source>Vendor-Specific-Application-Id AVP</source>
          <target state="translated">Vendor-Specific-Application-Id AVP</target>
        </trans-unit>
        <trans-unit id="e96f73110a27dcecf42e3942850fdb9a84214cad" translate="yes" xml:space="preserve">
          <source>Verbose = &lt;code&gt;boolean()&lt;/code&gt;</source>
          <target state="translated">Verboso = &lt;code&gt;boolean()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="5e80e8afa8277ee05efe0825f2f72b290ab38b7f" translate="yes" xml:space="preserve">
          <source>Verbose.</source>
          <target state="translated">Verbose.</target>
        </trans-unit>
        <trans-unit id="adb0c527629b97acddda692f399e9ccb978796eb" translate="yes" xml:space="preserve">
          <source>Verbosity for a SNMP process. This specifies now much debug info is printed.</source>
          <target state="translated">Verbosidad para un proceso de SNMP.Esto especifica que ahora se imprime mucha información de depuración.</target>
        </trans-unit>
        <trans-unit id="fee450697a5689ff92f9f50edecbf9c5c91da171" translate="yes" xml:space="preserve">
          <source>Verifies PKIX x.509 certificate signature.</source>
          <target state="translated">Verifica la firma del certificado PKIX x.509.</target>
        </trans-unit>
        <trans-unit id="4326ee1947d5233b0586b451628ad661e97a0e04" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature</source>
          <target state="translated">Verifica una firma digital</target>
        </trans-unit>
        <trans-unit id="d9ade396ed77dbd522a02203fe6942326134914f" translate="yes" xml:space="preserve">
          <source>Verifies a digital signature.</source>
          <target state="translated">Verifica una firma digital.</target>
        </trans-unit>
        <trans-unit id="b9525ebe014b53689fa4e11b528180aae4abeb4b" translate="yes" xml:space="preserve">
          <source>Verifies that the current location of the execution is visible in the code area.</source>
          <target state="translated">Verifica que la ubicación actual de la ejecución es visible en el área del código.</target>
        </trans-unit>
        <trans-unit id="1dc4741dffd06fe660bc6cd57000623888541a03" translate="yes" xml:space="preserve">
          <source>Verify that &lt;code&gt;Cert&lt;/code&gt; is the &lt;code&gt;CRL&lt;/code&gt; signer.</source>
          <target state="translated">Verifique que &lt;code&gt;Cert&lt;/code&gt; sea ​​el firmante de la &lt;code&gt;CRL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f040269483ba291a5dc58f8344423a743ace3bf6" translate="yes" xml:space="preserve">
          <source>Verify with an engine stored public key</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="536244f4cc64c32141c5753233b90a09618435ae" translate="yes" xml:space="preserve">
          <source>Verifying</source>
          <target state="translated">Verifying</target>
        </trans-unit>
        <trans-unit id="2da600bf9404843107a9531694f654e5662959e0" translate="yes" xml:space="preserve">
          <source>Version</source>
          <target state="translated">Version</target>
        </trans-unit>
        <trans-unit id="d5417e5a99f86d22c5664ec343d3a6c2609ec65a" translate="yes" xml:space="preserve">
          <source>Version 1.6.10 or later of the &lt;strong&gt;asn1&lt;/strong&gt; application.</source>
          <target state="translated">Versi&amp;oacute;n 1.6.10 o posterior de la aplicaci&amp;oacute;n &lt;strong&gt;asn1&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a661417de642bc6b468d76fe5b3c6bc8775de7ac" translate="yes" xml:space="preserve">
          <source>Version 3.11 or later of &lt;strong&gt;this&lt;/strong&gt; application.</source>
          <target state="translated">Versi&amp;oacute;n 3.11 o posterior de &lt;strong&gt;esta&lt;/strong&gt; aplicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2c53b65799c019b459fedea45335868fd7a802d8" translate="yes" xml:space="preserve">
          <source>Version downgrade protection</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="554f7abde7f492a763703dbbf95c1a1680dca835" translate="yes" xml:space="preserve">
          <source>Version downgrade protection mechanism</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9406ae17f9404f81cf7cdbb053a74c6ecc560456" translate="yes" xml:space="preserve">
          <source>Version management is enabled for drivers that have set the &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt; extended_marker&lt;/a&gt;&lt;/code&gt; field of their &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;. &lt;code&gt;erl_driver.h&lt;/code&gt; defines:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56e5ca082097444de77af1c9fd7d0a5134aed383" translate="yes" xml:space="preserve">
          <source>Version management is enabled for drivers that have set the &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended_marker&lt;/a&gt;&lt;/code&gt; field of their &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; to &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt;. &lt;code&gt;erl_driver.h&lt;/code&gt; defines:</source>
          <target state="translated">La gesti&amp;oacute;n de versiones est&amp;aacute; habilitada para los controladores que han establecido el campo &lt;code&gt;&lt;a href=&quot;driver_entry#extended_marker&quot;&gt;extended_marker&lt;/a&gt;&lt;/code&gt; de su &lt;code&gt;&lt;a href=&quot;driver_entry&quot;&gt;driver_entry&lt;/a&gt;&lt;/code&gt; en &lt;code&gt;ERL_DRV_EXTENDED_MARKER&lt;/code&gt; . &lt;code&gt;erl_driver.h&lt;/code&gt; define:</target>
        </trans-unit>
        <trans-unit id="21b8714f6e355164babd4f77276d9b70c8b55f19" translate="yes" xml:space="preserve">
          <source>Version numbers in general are only partially ordered. However, normal version numbers (with three parts) as of OTP 17.0 have a total or linear order. This applies both to normal OTP versions and normal application versions.</source>
          <target state="translated">Los números de versión en general sólo están parcialmente ordenados.Sin embargo,los números de versión normales (con tres partes)a partir del OTP 17.0 tienen un orden total o lineal.Esto se aplica tanto a las versiones normales de la OTP como a las versiones normales de la aplicación.</target>
        </trans-unit>
        <trans-unit id="e126978ac6222c855c920d79411bed5cf12c2966" translate="yes" xml:space="preserve">
          <source>Version of an application included in the release.</source>
          <target state="translated">Versión de una aplicación incluida en el lanzamiento.</target>
        </trans-unit>
        <trans-unit id="473be10b81925976c7e4903e9b43ac593c8ae1c5" translate="yes" xml:space="preserve">
          <source>Version of the application.</source>
          <target state="translated">Versión de la aplicación.</target>
        </trans-unit>
        <trans-unit id="9a7876f7a0f780d649e426501cf895ebbd7b0903" translate="yes" xml:space="preserve">
          <source>Vertical bar characters are used to separate alternative patterns. For example, the following pattern matches either &quot;gilbert&quot; or &quot;sullivan&quot;:</source>
          <target state="translated">Se utilizan caracteres de barras verticales para separar patrones alternativos.Por ejemplo,el siguiente patrón coincide con &quot;gilbert&quot; o &quot;sullivan&quot;:</target>
        </trans-unit>
        <trans-unit id="f26a73edd5911cc59d619f45a8244a225ed70c75" translate="yes" xml:space="preserve">
          <source>Vertical tab</source>
          <target state="translated">Pestaña vertical</target>
        </trans-unit>
        <trans-unit id="5fd82a7e8d422aaa4b53ae82c82d9414739c27a0" translate="yes" xml:space="preserve">
          <source>Vertical tab (VT)</source>
          <target state="translated">Pestaña vertical (VT)</target>
        </trans-unit>
        <trans-unit id="089b74a153ec7d14e48cc1b72fe57aef02d54503" translate="yes" xml:space="preserve">
          <source>Vertical tab.</source>
          <target state="translated">Pestaña vertical.</target>
        </trans-unit>
        <trans-unit id="29e9914d64c8384c209127eaf16006134a978f22" translate="yes" xml:space="preserve">
          <source>Very similar to &lt;code&gt;portTypeAcceptor&lt;/code&gt;, an intermediate stage between the request for a connect operation and that the socket is connected to an accepting ditto in the other end. When the sockets are connected, the port switches type to &lt;code&gt;portTypeCommand&lt;/code&gt;.</source>
          <target state="translated">Muy similar a &lt;code&gt;portTypeAcceptor&lt;/code&gt; , una etapa intermedia entre la solicitud de una operaci&amp;oacute;n de conexi&amp;oacute;n y que el enchufe est&amp;aacute; conectado a un &amp;iacute;dem de aceptaci&amp;oacute;n en el otro extremo. Cuando los enchufes est&amp;aacute;n conectados, el puerto cambia a &lt;code&gt;portTypeCommand&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8e64e0bec8b57844c72ad51fbe4f769f2b726868" translate="yes" xml:space="preserve">
          <source>Viewer menu:</source>
          <target state="translated">Menú del visor:</target>
        </trans-unit>
        <trans-unit id="a76c37f0a0334ff643407ad5eae8341e4157dd19" translate="yes" xml:space="preserve">
          <source>Visual Studio 2013 (Visual Studio 12.0). Download and run the web installer from:</source>
          <target state="translated">Visual Studio 2013 (Visual Studio 12.0).Descargue y ejecute el instalador web desde:</target>
        </trans-unit>
        <trans-unit id="244d869d05e05e311d391ddca36084184536284d" translate="yes" xml:space="preserve">
          <source>Visual Studio 2019 Download and run the installer from: &lt;code&gt;&lt;a href=&quot;http://visualstudio.microsoft.com/downloads&quot;&gt;http://visualstudio.microsoft.com/downloads&lt;/a&gt;&lt;/code&gt; Install C++ and SDK packages to the default installation directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c915e18af7a75d3dbbd7d92286c7e2d9ac312998" translate="yes" xml:space="preserve">
          <source>Voila! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 21-&amp;gt;Erlang&lt;/code&gt; starts the Erlang Windows shell.</source>
          <target state="translated">&amp;iexcl;Voila! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 21-&amp;gt;Erlang&lt;/code&gt; inicia el shell de Windows de Erlang.</target>
        </trans-unit>
        <trans-unit id="a6f93d383c4325ccf160b881c9d175a89508dbb1" translate="yes" xml:space="preserve">
          <source>Voila! &lt;code&gt;Start-&amp;gt;Programs-&amp;gt;Erlang OTP 23-&amp;gt;Erlang&lt;/code&gt; starts the Erlang Windows shell.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716dd3292ee085b4712046407eb276268b149ea2" translate="yes" xml:space="preserve">
          <source>Voluntarily lets other processes (if any) get a chance to execute. Using this function is similar to &lt;code&gt;receive after 1 -&amp;gt; ok end&lt;/code&gt;, except that &lt;code&gt;yield()&lt;/code&gt; is faster.</source>
          <target state="translated">Permite voluntariamente que otros procesos (si los hay) tengan la oportunidad de ejecutarse. El uso de esta funci&amp;oacute;n es similar a &lt;code&gt;receive after 1 -&amp;gt; ok end&lt;/code&gt; , excepto que &lt;code&gt;yield()&lt;/code&gt; es m&amp;aacute;s r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="8fb00b6962541e4e4e75cf39aece6826243afc2a" translate="yes" xml:space="preserve">
          <source>Voluntarily lets other processes (if any) get a chance to execute. Using this function is similar to &lt;code&gt;receive after 1 -&amp;gt; true end&lt;/code&gt;, except that &lt;code&gt;yield()&lt;/code&gt; is faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e07124d37d04067c5b24ce9f8122728b6c492ef" translate="yes" xml:space="preserve">
          <source>VxWorks Support</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d736ea0f1fc6aa3f95dc939e7dc07d919541f69e" translate="yes" xml:space="preserve">
          <source>WSL: Install WSL and Ubuntu in Windows 10 &lt;code&gt;&lt;a href=&quot;https://docs.microsoft.com/en-us/windows/wsl/install-win10&quot;&gt;https://docs.microsoft.com/en-us/windows/wsl/install-win10&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ebf20f8d1333c6ed323b151df8d0b75baeab5a0" translate="yes" xml:space="preserve">
          <source>Wait for an ack.</source>
          <target state="translated">Espere un momento.</target>
        </trans-unit>
        <trans-unit id="4d14f3abfec373cbe89f6626aa814e6ca203b696" translate="yes" xml:space="preserve">
          <source>Wait for reply after having received a pending message.</source>
          <target state="translated">Espere la respuesta después de haber recibido un mensaje pendiente.</target>
        </trans-unit>
        <trans-unit id="03a3dd1877c6b650ce26278dad8e2fb191a587d5" translate="yes" xml:space="preserve">
          <source>Wait for reply.</source>
          <target state="translated">Espere la respuesta.</target>
        </trans-unit>
        <trans-unit id="8094e62f79c4399dd8f66ec127a5866ea7c65659" translate="yes" xml:space="preserve">
          <source>Wait for thread progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c9fa9326ddb841f72c6292157f69d607e668076c" translate="yes" xml:space="preserve">
          <source>Wait or poll for a response message to a &lt;code&gt;call&lt;/code&gt; request previously made by the calling process using &lt;code&gt;&lt;a href=&quot;#send_request-4&quot;&gt;erpc:send_request/4&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;RequestId&lt;/code&gt; should be the value returned from the previously made &lt;code&gt;erpc:send_request()&lt;/code&gt; call, and the corresponding response should not already have been received and handled to completion by &lt;code&gt;&lt;a href=&quot;#check_response-2&quot;&gt;erpc:check_response()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#receive_response-2&quot;&gt;erpc:receive_response()&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;erpc:wait_response()&lt;/code&gt;. &lt;code&gt;WaitTime&lt;/code&gt; equals the time to wait in milliseconds (or the atom &lt;code&gt;infinity&lt;/code&gt;) during the wait. &lt;code&gt;WaitTime&lt;/code&gt; is an integer representing time to wait in milliseconds or the atom &lt;code&gt;infinity&lt;/code&gt; which will cause &lt;code&gt;wait_response/2&lt;/code&gt; to wait for a response until it appears regardless of how long time that is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c5a9ccfb857e48896b332926f19499a3bf34466" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive...after&lt;/code&gt;.</source>
          <target state="translated">Esperando una &lt;code&gt;receive...after&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15e59facfb286b560b3bd7e76028f43e2127a06c" translate="yes" xml:space="preserve">
          <source>Waiting in a &lt;code&gt;receive&lt;/code&gt;.</source>
          <target state="translated">Esperando una &lt;code&gt;receive&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e3d6ef3cb84dde159db4dc284cfdc308ccef71dd" translate="yes" xml:space="preserve">
          <source>Waiting. This state is currently only identified on Solaris.</source>
          <target state="translated">Esperando.Este estado sólo se identifica actualmente en Solaris.</target>
        </trans-unit>
        <trans-unit id="7c806137ff16518173274ba603d62ffafc3bdf63" translate="yes" xml:space="preserve">
          <source>Waits for a reply.</source>
          <target state="translated">Espera una respuesta.</target>
        </trans-unit>
        <trans-unit id="bd2ac24407b3f1c35309d00d94c7cf3be1ef6a8a" translate="yes" xml:space="preserve">
          <source>Waits on a condition variable. The calling thread is blocked until another thread wakes it by signaling or broadcasting on the condition variable. Before the calling thread is blocked, it unlocks the mutex passed as argument. When the calling thread is woken, it locks the same mutex before returning. That is, the mutex currently must be locked by the calling thread when calling this function.</source>
          <target state="translated">Espera en una condición variable.El hilo de llamada se bloquea hasta que otro hilo lo despierta señalando o emitiendo sobre la variable de condición.Antes de que el hilo de llamada se bloquee,desbloquea el mutex pasado como argumento.Cuando el hilo de llamada se despierta,bloquea el mismo mutex antes de volver.Es decir,el mutex actualmente debe ser bloqueado por el hilo de llamada cuando se llama a esta función.</target>
        </trans-unit>
        <trans-unit id="ab9651595cb08f88e44fd940126d1c71dd69f853" translate="yes" xml:space="preserve">
          <source>Waits until data have been committed and logged to disk (if disk is used) on every involved node before it returns, otherwise it behaves as &lt;code&gt;mnesia:transaction/[1,2,3]&lt;/code&gt;.</source>
          <target state="translated">Espera hasta que los datos se hayan confirmado y registrado en el disco (si se usa el disco) en cada nodo involucrado antes de regresar; de lo contrario, se comporta como &lt;code&gt;mnesia:transaction/[1,2,3]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d95099fabbff08dd069c5c4ee916cb8f9b1a506" translate="yes" xml:space="preserve">
          <source>Wallclock_Time_Since_Last_Call}</source>
          <target state="translated">Wallclock_Time_Since_Last_Call}</target>
        </trans-unit>
        <trans-unit id="c3b288f7da975708a0f5e331c0f162ed064cf7c2" translate="yes" xml:space="preserve">
          <source>Warang_Citi</source>
          <target state="translated">Warang_Citi</target>
        </trans-unit>
        <trans-unit id="73cea05d9ab0a2033c2e880c88d16336c1ad4134" translate="yes" xml:space="preserve">
          <source>Warn about overspecified functions (the specification is strictly less allowing than the success typing).</source>
          <target state="translated">Advertir sobre las funciones excesivamente especificadas (la especificación es estrictamente menos permisiva que el tecleo de éxito).</target>
        </trans-unit>
        <trans-unit id="09d2b974a5e842f51243b3499495df6bdd13bcaa" translate="yes" xml:space="preserve">
          <source>Warn about underspecified functions (the specification is strictly more allowing than the success typing).</source>
          <target state="translated">Advertir sobre las funciones no especificadas (la especificación es estrictamente más permisiva que el tecleo de éxito).</target>
        </trans-unit>
        <trans-unit id="6cccd5dcb30984a83e1ff196e1800d93a16fd24a" translate="yes" xml:space="preserve">
          <source>Warn when the specification is different than the success typing.</source>
          <target state="translated">Avisa cuando la especificación es diferente a la tipificación de éxito.</target>
        </trans-unit>
        <trans-unit id="e9c45563358e813f157ba81b33143542165ba84e" translate="yes" xml:space="preserve">
          <source>Warning</source>
          <target state="translated">Warning</target>
        </trans-unit>
        <trans-unit id="83bd22f6ddfb4c6af6ec49ac28fc7020e55db1cb" translate="yes" xml:space="preserve">
          <source>Warning events were introduced in Erlang/OTP R9C and are enabled by default as from Erlang/OTP 18.0. To retain backwards compatibility with existing user-defined event handlers, the warning events can be tagged as &lt;code&gt;errors&lt;/code&gt; or &lt;code&gt;info&lt;/code&gt; using command-line flag &lt;code&gt;+W &amp;lt;e | i | w&amp;gt;&lt;/code&gt;, thus showing up as &lt;code&gt;ERROR REPORT&lt;/code&gt; or &lt;code&gt;INFO REPORT&lt;/code&gt; in the logs.</source>
          <target state="translated">Los eventos de advertencia se introdujeron en Erlang / OTP R9C y est&amp;aacute;n habilitados de forma predeterminada a partir de Erlang / OTP 18.0. Para mantener la compatibilidad con versiones anteriores de los controladores de eventos definidos por el usuario existentes, los eventos de advertencia se pueden etiquetar como &lt;code&gt;errors&lt;/code&gt; o &lt;code&gt;info&lt;/code&gt; rmaci&amp;oacute;n mediante el indicador de l&amp;iacute;nea de comandos &lt;code&gt;+W &amp;lt;e | i | w&amp;gt;&lt;/code&gt; , por lo que aparece como &lt;code&gt;ERROR REPORT&lt;/code&gt; o INFORME DE &lt;code&gt;INFO REPORT&lt;/code&gt; en los registros.</target>
        </trans-unit>
        <trans-unit id="6c71f2eab8af60b63ce0e407c87968c7af135f73" translate="yes" xml:space="preserve">
          <source>Warning option &lt;code&gt;-Wrace_conditions&lt;/code&gt; has no effect when set in source files.</source>
          <target state="translated">La opci&amp;oacute;n de advertencia &lt;code&gt;-Wrace_conditions&lt;/code&gt; no tiene ning&amp;uacute;n efecto cuando se establece en los archivos de origen.</target>
        </trans-unit>
        <trans-unit id="b855954419a97257855c46e228014ea8104ff80a" translate="yes" xml:space="preserve">
          <source>Warning options can be restricted to functions:</source>
          <target state="translated">Las opciones de advertencia pueden limitarse a las funciones:</target>
        </trans-unit>
        <trans-unit id="350f98fe7365f5591c6175d100ed10f345354502" translate="yes" xml:space="preserve">
          <source>Warning: you wanted to visit the site www.example.com, but the certificate is for shop.example.com. Accept anyway (yes/no)?&quot;</source>
          <target state="translated">Advertencia:querías visitar el sitio www.example.com,pero el certificado es para shop.example.com.Aceptar de todos modos (sí/no)?&quot;</target>
        </trans-unit>
        <trans-unit id="4e6fc17d67b22f27c12488bddcfdd561fdbab970" translate="yes" xml:space="preserve">
          <source>Warnings and Restrictions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bfa481bc1014e68bf8d7481ee0ba5e89fda097c2" translate="yes" xml:space="preserve">
          <source>We add &lt;code&gt;-heart&lt;/code&gt; to &lt;code&gt;bin/start&lt;/code&gt;:</source>
          <target state="translated">A&amp;ntilde;adimos &lt;code&gt;-heart&lt;/code&gt; a &lt;code&gt;bin/start&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="73b280a7b7aba8731e641abebde7cc0face25615" translate="yes" xml:space="preserve">
          <source>We already have the data as (Unicode) lists and therefore only split the list in runs of a predefined size and put each run in the table at the current position (and forward). Functions &lt;code&gt;split_data/3&lt;/code&gt; and &lt;code&gt;apply_update/2&lt;/code&gt; are implemented below.</source>
          <target state="translated">Ya tenemos los datos como listas (Unicode) y, por lo tanto, solo dividimos la lista en ejecuciones de un tama&amp;ntilde;o predefinido y colocamos cada ejecuci&amp;oacute;n en la tabla en la posici&amp;oacute;n actual (y hacia adelante). Las funciones &lt;code&gt;split_data/3&lt;/code&gt; y &lt;code&gt;apply_update/2&lt;/code&gt; se implementan a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="da12a6009775f6352a760fe1d7ed31c170d4b8e7" translate="yes" xml:space="preserve">
          <source>We also need a CommonTest test suite:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5226f0d44c399be112d6e2c67714235696a1e7cd" translate="yes" xml:space="preserve">
          <source>We also see that the call to &lt;code&gt;file:write/2&lt;/code&gt; that writes 1/4 of the file contents takes very little time in itself. What takes time is to build the data (&lt;code&gt;lists:seq/2&lt;/code&gt; and &lt;code&gt;lists:map/2&lt;/code&gt;).</source>
          <target state="translated">Tambi&amp;eacute;n vemos que la llamada a &lt;code&gt;file:write/2&lt;/code&gt; que escribe 1/4 del contenido del archivo toma muy poco tiempo en s&amp;iacute; misma. Lo que lleva tiempo es construir los datos ( &lt;code&gt;lists:seq/2&lt;/code&gt; y &lt;code&gt;lists:map/2&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a7655995e200021034a1234263f9bb9fd897f337" translate="yes" xml:space="preserve">
          <source>We also want threads to be able to determine when thread progress has been made relatively fast. That is we need to have some balance between comunication overhead and time to complete the operation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d49ee7e4ad5636419e727eed1a3416350054ba7c" translate="yes" xml:space="preserve">
          <source>We always strive to remain as compatible as possible even in the cases where we give no compatibility guarantees.</source>
          <target state="translated">Siempre nos esforzamos por ser tan compatibles como sea posible,incluso en los casos en que no damos garantías de compatibilidad.</target>
        </trans-unit>
        <trans-unit id="225f863cbc345617cdd927f674aea220d5833e8d" translate="yes" xml:space="preserve">
          <source>We begin by reserving space in the table by atomically incrementing a counter of processes in the table. If our increment brings the counter above the maximum size of the table, the operation fail and a &lt;code&gt;system_limit&lt;/code&gt; exception is raised.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c06b23c2a34df45341a353c1d6915221b4316d" translate="yes" xml:space="preserve">
          <source>We belive that the truth finally has caught with the following, retired myths.</source>
          <target state="translated">Creemos que la verdad finalmente se ha enganchado con los siguientes mitos retirados.</target>
        </trans-unit>
        <trans-unit id="a21d18a0aa2c147b58a169cb973ed1ce3338cf1f" translate="yes" xml:space="preserve">
          <source>We call a set of ordered sets (x[1], ..., x[n]) an &lt;strong id=&quot;n_ary_relation&quot;&gt;(n-ary) relation&lt;/strong&gt;, and say that the relation is a subset of the Cartesian product X[1] &amp;times; ... &amp;times; X[n], where x[i] is an element of X[i], 1 &amp;lt;= i &amp;lt;= n.</source>
          <target state="translated">Llamamos a un conjunto de conjuntos ordenados (x [1], ..., x [n]) una relaci&amp;oacute;n &lt;strong id=&quot;n_ary_relation&quot;&gt;(n-aria)&lt;/strong&gt; , y decimos que la relaci&amp;oacute;n es un subconjunto del producto cartesiano X [1] &amp;times; ... &amp;times; X [n], donde x [i] es un elemento de X [i], 1 &amp;lt;= i &amp;lt;= n.</target>
        </trans-unit>
        <trans-unit id="413c823c35b15bc9d9bba19b8e901ed4a84786b5" translate="yes" xml:space="preserve">
          <source>We call disconnect to log out from the database. (This should have been done from Erlang, but just in case.)</source>
          <target state="translated">Llamamos a desconexión para salir de la base de datos.(Esto debería haberse hecho desde Erlang,pero por si acaso.)</target>
        </trans-unit>
        <trans-unit id="522acbf7d3d85ef274cefb977f558982277af2ea" translate="yes" xml:space="preserve">
          <source>We call this fragment &lt;code&gt;execute&lt;/code&gt;. It will handle the three remaining operands (&lt;code&gt;W t d&lt;/code&gt;). There will only be one copy of this fragment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee0e548c81b6e89076547f66f838c75eec0931cf" translate="yes" xml:space="preserve">
          <source>We call this fragment &lt;code&gt;fetch&lt;/code&gt;. This fragment will be duplicated three times, one for each value of the first operand (&lt;code&gt;r&lt;/code&gt;, &lt;code&gt;x&lt;/code&gt;, and &lt;code&gt;y&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a622cc685c06ebc1847f597b7b757bf135bf65a2" translate="yes" xml:space="preserve">
          <source>We can also start a distributed system (requires &lt;code&gt;bin/epmd&lt;/code&gt;).</source>
          <target state="translated">Tambi&amp;eacute;n podemos iniciar un sistema distribuido (requiere &lt;code&gt;bin/epmd&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="d27be01791833f5e7361c562bc0586ab7a53f67b" translate="yes" xml:space="preserve">
          <source>We can in this example hibernate in the &lt;code&gt;{open,_}&lt;/code&gt; state, because what normally occurs in that state is that the state time-out after a while triggers a transition to &lt;code&gt;{locked,_}&lt;/code&gt;:</source>
          <target state="translated">En este ejemplo, podemos hibernar en el estado &lt;code&gt;{open,_}&lt;/code&gt; , porque lo que ocurre normalmente en ese estado es que el tiempo de espera del estado despu&amp;eacute;s de un tiempo desencadena una transici&amp;oacute;n a &lt;code&gt;{locked,_}&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="723ac72181a0f65089e1039932052a9e46e076de" translate="yes" xml:space="preserve">
          <source>We can now continue with further analyses, or we can delete the Xref server:</source>
          <target state="translated">Ahora podemos continuar con más análisis,o podemos eliminar el servidor Xref:</target>
        </trans-unit>
        <trans-unit id="2cc179d98b76e6b3d41baf1c227027f8bb4da940" translate="yes" xml:space="preserve">
          <source>We can see that that &lt;code&gt;$NEXT_INSTRUCTION&lt;/code&gt; has been expanded to &lt;code&gt;I+2&lt;/code&gt;. That makes sense since the size of the &lt;code&gt;i_call_f/1&lt;/code&gt; instruction is two words.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66a68a7d66829ca42ef25d404e41acb97b44c301" translate="yes" xml:space="preserve">
          <source>We can see that the prefetch is no longer done:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80d30cce8e804ded34a7689032f878d3a116eea" translate="yes" xml:space="preserve">
          <source>We can then define:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d9647a6d5681d02b8300287887329e1b58baac" translate="yes" xml:space="preserve">
          <source>We check which algoritms are negotiated by the client and the server, and note that the (only) &lt;code&gt;kex&lt;/code&gt; algorithm &lt;code&gt;'curve25519-sha256@libssh.org'&lt;/code&gt; was selected:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="731dac39a948da6420329e5012364c57947f8871" translate="yes" xml:space="preserve">
          <source>We chose a &quot;semi locked&quot; approach, with one public locked task queue, and a private, lock free, queue like, task data structure. This &quot;semi locked&quot; approach is similar to how the message boxes of processes are managed. The lock is port specific and only used for protection of port tasks, so the run queue lock is now needed in more or less the same way for ports as for processes. This ensures that we wont see an increased lock contention on run queue locks due to this rewrite of the port functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed2f11fd9224dc5918c516e18e8c1fc044f95ee" translate="yes" xml:space="preserve">
          <source>We continue the example above by connecting to a server and modifying the &lt;code&gt;kex&lt;/code&gt; algorithm set. We remove the only one (&lt;code&gt;'ecdh-sha2-nistp384'&lt;/code&gt;) and add &lt;code&gt;'curve25519-sha256@libssh.org'&lt;/code&gt; by appending it to the now empty list:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="256ebb1297d3c5168e6d4942a26c829b8f6be203" translate="yes" xml:space="preserve">
          <source>We continue trying to write until the queue is empty or the writing blocks.</source>
          <target state="translated">Seguimos intentando escribir hasta que la cola está vacía o los bloques de escritura.</target>
        </trans-unit>
        <trans-unit id="598054eadf14bd6e3fc4f983c0ea4bf5d2acfe0d" translate="yes" xml:space="preserve">
          <source>We could find the size of the closure of the module graph with a loop similar to one used for the function graph, but since the module graph is so much smaller, a more direct method is feasible.</source>
          <target state="translated">Podríamos encontrar el tamaño del cierre de la gráfica del módulo con un bucle similar al utilizado para la gráfica de funciones,pero como la gráfica del módulo es mucho más pequeña,es factible un método más directo.</target>
        </trans-unit>
        <trans-unit id="d13bdb2791f9edb9789c1e21484024176d248d1d" translate="yes" xml:space="preserve">
          <source>We could say that the button was pressed too early so it is not to be recognized as the lock button. Or we can make the lock button part of the state so when we then change the lock button in the locked state, the change becomes a &lt;strong&gt;state change&lt;/strong&gt; and all postponed events are retried, therefore the lock is immediately locked!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1991f07b9f9058aea6db1e8f77c1b4a56e270edc" translate="yes" xml:space="preserve">
          <source>We could say that the button was pressed too early so it is not to be recognized as the lock button. Or we can make the lock button part of the state so when we then change the lock button in the locked state, the change becomes a state change and all postponed events are retried, therefore the lock is immediately locked!</source>
          <target state="translated">Podríamos decir que el botón fue presionado demasiado pronto para no ser reconocido como el botón de bloqueo.O podemos hacer que el botón de bloqueo forme parte del estado,de modo que cuando cambiemos el botón de bloqueo en el estado de bloqueo,el cambio se convierte en un cambio de estado y todos los eventos aplazados se vuelven a intentar,¡por lo que el bloqueo se bloquea inmediatamente!</target>
        </trans-unit>
        <trans-unit id="5a9ed4b8c10518737f16e11ac495badece57b9c4" translate="yes" xml:space="preserve">
          <source>We create the table using:</source>
          <target state="translated">Creamos la tabla usando:</target>
        </trans-unit>
        <trans-unit id="32473b5c4698fb40d28c5576c29bf1a8447287f7" translate="yes" xml:space="preserve">
          <source>We define the state as &lt;code&gt;{StateName,LockButton}&lt;/code&gt;, where &lt;code&gt;StateName&lt;/code&gt; is as before and &lt;code&gt;LockButton&lt;/code&gt; is the current lock button:</source>
          <target state="translated">Definimos el estado como &lt;code&gt;{StateName,LockButton}&lt;/code&gt; , donde &lt;code&gt;StateName&lt;/code&gt; es como antes y &lt;code&gt;LockButton&lt;/code&gt; es el bot&amp;oacute;n de bloqueo actual:</target>
        </trans-unit>
        <trans-unit id="7e5b4ef345a93f5049df742fe31287578cf4c7e2" translate="yes" xml:space="preserve">
          <source>We do not need a sub-agent for each table holder. Normally, the sub-agent is needed to take care of communication, but in Distributed Erlang we use ordinary message passing.</source>
          <target state="translated">No necesitamos un subagente para cada porta-mesa.Normalmente,el sub-agente se necesita para cuidar la comunicación,pero en el Erlang Distribuido usamos el paso de mensajes ordinario.</target>
        </trans-unit>
        <trans-unit id="3dcce44305924654369f1be725b80d831eab3129" translate="yes" xml:space="preserve">
          <source>We execute a query and encode the result. Encoding is done in another C module, &lt;code&gt;pg_encode.c&lt;/code&gt;, which is also provided as sample code.</source>
          <target state="translated">Ejecutamos una consulta y codificamos el resultado. La codificaci&amp;oacute;n se realiza en otro m&amp;oacute;dulo C, &lt;code&gt;pg_encode.c&lt;/code&gt; , que tambi&amp;eacute;n se proporciona como c&amp;oacute;digo de muestra.</target>
        </trans-unit>
        <trans-unit id="c0fc2d127a89f720c3128d44e169672e74e15c80" translate="yes" xml:space="preserve">
          <source>We fill the table with randomly chosen data:</source>
          <target state="translated">Llenamos la tabla con datos elegidos al azar:</target>
        </trans-unit>
        <trans-unit id="3c1b0d2fdb890ab43ab70bb52624aa632e05a8ee" translate="yes" xml:space="preserve">
          <source>We find no particulary long suspend times, so no function seems to have waited in a receive statement. Actually, &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; contains a receive statement, but in this test program, the message lies in the process receive buffer when the receive statement is entered. We also see that the total suspend time for the test run is small.</source>
          <target state="translated">No encontramos tiempos de suspensi&amp;oacute;n particularmente largos, por lo que ninguna funci&amp;oacute;n parece haber esperado en una instrucci&amp;oacute;n de recepci&amp;oacute;n. En realidad, &lt;code&gt;prim_file:drv_command/4&lt;/code&gt; contiene una instrucci&amp;oacute;n de recepci&amp;oacute;n, pero en este programa de prueba, el mensaje se encuentra en el b&amp;uacute;fer de recepci&amp;oacute;n del proceso cuando se ingresa la instrucci&amp;oacute;n de recepci&amp;oacute;n. Tambi&amp;eacute;n vemos que el tiempo total de suspensi&amp;oacute;n para la ejecuci&amp;oacute;n de prueba es peque&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="539abdc8c79a99e16a54fd4c1353932c38835c6d" translate="yes" xml:space="preserve">
          <source>We get all features of Mnesia, such as fault tolerance, persistent data storage, replication, and so on.</source>
          <target state="translated">Obtenemos todas las características de la Mnesia,como la tolerancia a las fallas,el almacenamiento de datos persistentes,la replicación,etc.</target>
        </trans-unit>
        <trans-unit id="162b9af34243f4c75d056a06375ee57f22d03768" translate="yes" xml:space="preserve">
          <source>We handle the requests for retrieving data:</source>
          <target state="translated">Nos encargamos de las solicitudes de recuperación de datos:</target>
        </trans-unit>
        <trans-unit id="82bb167cd1f1aaced33ce89ec08193896c8c8861" translate="yes" xml:space="preserve">
          <source>We have a structure to store state needed by the driver, in this case we only need to keep the database connection:</source>
          <target state="translated">Tenemos una estructura para almacenar el estado que necesita el conductor,en este caso sólo tenemos que mantener la conexión a la base de datos:</target>
        </trans-unit>
        <trans-unit id="f0f2ae2c27d8d0a5f2644b532540797a414ff961" translate="yes" xml:space="preserve">
          <source>We have included some simple tool(s) for codec measurement (meas), performance tests (mstone1 and mstone2) and message transformation.</source>
          <target state="translated">Hemos incluido algunas herramientas simples para la medición del códec (meas),pruebas de rendimiento (mstone1 y mstone2)y transformación de mensajes.</target>
        </trans-unit>
        <trans-unit id="8d35a0217a0c4d25516c55c6b13eeb0ee82ce246" translate="yes" xml:space="preserve">
          <source>We have instrumented our code in order to enable tracing. Running the application with tracing deactivated, causes a negligible performance overhead (an external call to a function which returns an atom). Activation of tracing does not require any recompilation of the code, since we rely on Erlang/OTP's built in support for dynamic trace activation. In our case tracing of calls to a given external function.</source>
          <target state="translated">Hemos instrumentado nuestro código para permitir el rastreo.Ejecutar la aplicación con el rastreo desactivado,provoca un rendimiento insignificante de la sobrecarga (una llamada externa a una función que devuelve un átomo).La activación del rastreo no requiere ninguna recompilación del código,ya que confiamos en el soporte incorporado de Erlang/OTP para la activación dinámica del rastreo.En nuestro caso,el rastreo de llamadas a una función externa determinada.</target>
        </trans-unit>
        <trans-unit id="19f3224f897b7485ee092aee943fad0f50d468c0" translate="yes" xml:space="preserve">
          <source>We have introduced the term &quot;user&quot; as a generic term for either an MG or an MGC, since most of the functionality we support, is common for both MG's and MGC's. A (local) user may be configured in various ways and it may establish any number of connections to its counterpart, the remote user. Once a connection has been established, the connection is supervised and it may be used for the purpose of sending messages. N.B. according to the standard an MG is connected to at most one MGC, while an MGC may be connected to any number of MG's.</source>
          <target state="translated">Hemos introducido el término &quot;usuario&quot; como un término genérico para un MG o un MGC,ya que la mayor parte de la funcionalidad que apoyamos es común tanto para los MG como para los MGC.Un usuario (local)puede configurarse de varias maneras y puede establecer cualquier número de conexiones con su homólogo,el usuario remoto.Una vez que se ha establecido una conexión,ésta es supervisada y puede ser utilizada con el propósito de enviar mensajes.N.B.Según la norma,una MG está conectada a un MGC como máximo,mientras que un MGC puede estar conectado a cualquier número de MG.</target>
        </trans-unit>
        <trans-unit id="877518c89585383e3076c104aa3cd7f7e23bc498" translate="yes" xml:space="preserve">
          <source>We have made four different measurements of our Erlang/OTP implementation of the Megaco/H.248 protocol stack, in order to compare our different encoders/decoders. The result of each one is summarized in the table below.</source>
          <target state="translated">Hemos hecho cuatro mediciones diferentes de nuestra implementación Erlang/OTP de la pila de protocolos Megaco/H.248,para comparar nuestros diferentes codificadores/decodificadores.El resultado de cada una de ellas se resume en la siguiente tabla.</target>
        </trans-unit>
        <trans-unit id="e594586e3be21133f5db0b9bde85bb9f42084bb6" translate="yes" xml:space="preserve">
          <source>We have sometimes experienced problems with Oracle's &lt;code&gt;java&lt;/code&gt; running out of memory when running &lt;code&gt;fop&lt;/code&gt;. Increasing the amount of memory available as follows has in our case solved the problem.</source>
          <target state="translated">A veces hemos experimentado problemas con &lt;code&gt;java&lt;/code&gt; de Oracle que se queda sin memoria al ejecutar &lt;code&gt;fop&lt;/code&gt; . En nuestro caso, aumentar la cantidad de memoria disponible de la siguiente manera ha resuelto el problema.</target>
        </trans-unit>
        <trans-unit id="bd8061d4d0a1f8978730bf0df09ec0f575e585ee" translate="yes" xml:space="preserve">
          <source>We have used and tested with WSL-1, WSL-2 was not available and may not be prefered when building Erlang/OTP since access to the windows disk is (currently) slower WSL-2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9ef581fc03c4350a26dcbbfc87b431aa1e17cc7" translate="yes" xml:space="preserve">
          <source>We implemented a test version using lock free run queues. This implementation did however not perform as good as the version using one lock per run queue. The reason for this was not investigated enough to say why this was. Since the locked version performed better we kept it, at least for now. The lock free version, however, forced us to use other solutions, some of them we kept.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bc0044e17c922875d4350027f6b2f290ff7821f" translate="yes" xml:space="preserve">
          <source>We include &lt;code&gt;FromPid&lt;/code&gt; just in case we want to trace this.</source>
          <target state="translated">Incluimos &lt;code&gt;FromPid&lt;/code&gt; en caso de que queramos rastrear esto.</target>
        </trans-unit>
        <trans-unit id="f19bccb4e164c8777a7def288e8e12ee2b2459b4" translate="yes" xml:space="preserve">
          <source>We increment last identifier value used. In order determine the slot that corresponds to this identifier we call &lt;code&gt;erts_ptab_data2pix()&lt;/code&gt; that maps identifier to slot. We read the content of the slot. If the slot is free we try to write a reservation marker using an atomic compare and swap. If this fails we repeat this step until it succeeds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62c14d96eb9053e2cc8b3f1d2c457d07c9567687" translate="yes" xml:space="preserve">
          <source>We loop through the requests one at the time, stopping when we either encounter an error or the list is exhausted. The last return value is sent back to the client (it is first returned to the main loop and then sent back by function &lt;code&gt;io_reply&lt;/code&gt;).</source>
          <target state="translated">Repasamos las solicitudes una a la vez, deteni&amp;eacute;ndonos cuando encontramos un error o la lista se agota. El &amp;uacute;ltimo valor devuelto se env&amp;iacute;a de vuelta al cliente (primero se devuelve al bucle principal y luego se devuelve mediante la funci&amp;oacute;n &lt;code&gt;io_reply&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a36c7a61f34ba2a33c8e34b5446fa5e93cb80751" translate="yes" xml:space="preserve">
          <source>We match on the top element and embed the inner parts in an HTML body. Then we extract the string values of all motorcycle brands, sort them and removes duplicates by &lt;code&gt;remove_duplicates(value_of(select(&quot;bike/name/manufacturer&quot;, E)))&lt;/code&gt;. We also process the substructure of the top element and pass it to a function that sorts all motorcycle information by brand according to the task formulation in the beginning of this example.</source>
          <target state="translated">Coincidimos en el elemento superior e incrustamos las partes internas en un cuerpo HTML. Luego extraemos los valores de cadena de todas las marcas de motocicletas, los &lt;code&gt;remove_duplicates(value_of(select(&quot;bike/name/manufacturer&quot;, E)))&lt;/code&gt; duplicados por remove_duplicates (value_of (select (&quot;bicicleta / nombre / fabricante&quot;, E))) . Tambi&amp;eacute;n procesamos la subestructura del elemento superior y la pasamos a una funci&amp;oacute;n que ordena toda la informaci&amp;oacute;n de la motocicleta por marca de acuerdo con la formulaci&amp;oacute;n de la tarea al comienzo de este ejemplo.</target>
        </trans-unit>
        <trans-unit id="7fc71c9eb936d94faf74a6949f057f8aa6f51f52" translate="yes" xml:space="preserve">
          <source>We need a property to test the function. In normal way, we create &lt;code&gt;property_test/ct_prop.erl&lt;/code&gt; module in the &lt;code&gt;test&lt;/code&gt; directory in our application:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fc0e2937cea34ba0f1d5aa2eb64c711b2673f69" translate="yes" xml:space="preserve">
          <source>We need to handle backward compatibility and the &lt;code&gt;file&lt;/code&gt; module (which uses the old requests until backward compatibility with pre-R13 nodes is no longer needed). Notice that the I/O server does not work with a simple &lt;code&gt;file:write/2&lt;/code&gt; if these are not added:</source>
          <target state="translated">Necesitamos manejar la compatibilidad con versiones anteriores y el m&amp;oacute;dulo de &lt;code&gt;file&lt;/code&gt; (que usa las solicitudes anteriores hasta que ya no se necesite la compatibilidad con versiones anteriores a los nodos R13). Observe que el servidor de E / S no funciona con un &lt;code&gt;file:write/2&lt;/code&gt; simple : escriba / 2 si no se agregan:</target>
        </trans-unit>
        <trans-unit id="4d6ac95529809d2ef950ae107e48095fe8aabd08" translate="yes" xml:space="preserve">
          <source>We need to handle some requests. First the requests for writing characters:</source>
          <target state="translated">Necesitamos manejar algunas peticiones.Primero las solicitudes de escritura de caracteres:</target>
        </trans-unit>
        <trans-unit id="12600f207204a472f087d90744262b5725d45b4e" translate="yes" xml:space="preserve">
          <source>We need to keep track of all the free segments in order to reuse them for new carrier allocations. One initial idea was to use the same mechanism that is used to keep track of free blocks within MBCs (alloc_util and the different strategies). However, that would not be as straight forward as one can think and can also waste quite a lot of memory as it uses prepended block headers. The granularity of the super carrier is one memory page (usually 4kb). We want to allocate and free entire pages and we don't want to waste an entire page just to hold the block header of the following pages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fb1a4cf95904afc1e359200da010b92404f8edb" translate="yes" xml:space="preserve">
          <source>We now do some initializations of the process structure that cannot be done before we know the process identifier, and have to be done before we publish the structure in the table. This, for example, includes storing the identifier in the process structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c07daf03f4db4caf19e38c7f867ab3cb5a53f055" translate="yes" xml:space="preserve">
          <source>We of course periodically need to move the &lt;code&gt;head.unref_end&lt;/code&gt; closer to the end in order to be able to continue deallocating memory blocks. Since all threads inserting new elements in the linked list will enter the list using the last pointer we can use this knowledge. If we call &lt;code&gt;erts_thr_progress_later()&lt;/code&gt; and wait until we have reached that thread progress we know that no managed threads can refer the elements up to the element pointed to by the last pointer at the time when we called &lt;code&gt;erts_thr_progress_later()&lt;/code&gt;. This since, all managed threads must have left the code implementing this at least once, and they always enters into the list via the last pointer. The &lt;code&gt;tail.next&lt;/code&gt; field contains information about next &lt;code&gt;head.unref_end&lt;/code&gt; pointer and thread progress that needs to be reached before we can move &lt;code&gt;head.unref_end&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65164610102defaf9d5b21fb95ba5620406fc14d" translate="yes" xml:space="preserve">
          <source>We recommend using the &lt;code&gt;-callback&lt;/code&gt; attribute rather than the &lt;code&gt;behaviour_info()&lt;/code&gt; function. The reason is that the extra type information can be used by tools to produce documentation or find discrepancies.</source>
          <target state="translated">Recomendamos usar el atributo &lt;code&gt;-callback&lt;/code&gt; en lugar de la funci&amp;oacute;n &lt;code&gt;behaviour_info()&lt;/code&gt; . La raz&amp;oacute;n es que las herramientas pueden utilizar la informaci&amp;oacute;n de tipo adicional para producir documentaci&amp;oacute;n o encontrar discrepancias.</target>
        </trans-unit>
        <trans-unit id="3f93e7d7fa1859286f601226a405040346701e5c" translate="yes" xml:space="preserve">
          <source>We recommend v1.1.1d or later. There are prebuilt avaiable binaries, which you can just download and install, available here: URL: &lt;code&gt;&lt;a href=&quot;http://wiki.openssl.org/index.php/Binaries&quot;&gt;http://wiki.openssl.org/index.php/Binaries&lt;/a&gt;&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1e39f49e759598de101c5da9790a0b4bd059c21" translate="yes" xml:space="preserve">
          <source>We recommend v3.1.3 or later. Unpack into &lt;code&gt;c:/opt/local64/pgm/wxWidgets-3.1.3&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="346c9aa8780b8aa277233c8030ef3ce8528b2a4f" translate="yes" xml:space="preserve">
          <source>We refer to these as &quot;automatic metavariables&quot;. If in addition the name ends with &lt;code&gt;@&lt;/code&gt;, as in &lt;code&gt;_@Foo@&lt;/code&gt;, the value of the variable as an Erlang term will be automatically converted to the corresponding abstract syntax tree when used to construct a larger tree. For example, in:</source>
          <target state="translated">Nos referimos a estos como &quot;metavariables autom&amp;aacute;ticas&quot;. Si adem&amp;aacute;s el nombre termina con &lt;code&gt;@&lt;/code&gt; , como en &lt;code&gt;_@Foo@&lt;/code&gt; , el valor de la variable como t&amp;eacute;rmino de Erlang se convertir&amp;aacute; autom&amp;aacute;ticamente al &amp;aacute;rbol de sintaxis abstracta correspondiente cuando se utilice para construir un &amp;aacute;rbol m&amp;aacute;s grande. Por ejemplo, en:</target>
        </trans-unit>
        <trans-unit id="06786f57e1bc44f393d7c2e9b4b0714fd0164849" translate="yes" xml:space="preserve">
          <source>We run it as usual, for example with ct_run in the OS shell:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16a9f8a4bc23ba990af592e409f5c51b8ea523ef" translate="yes" xml:space="preserve">
          <source>We see that &lt;code&gt;file:write/2&lt;/code&gt; only calls &lt;code&gt;prim_file:write/2&lt;/code&gt;, but let us refrain from digging into the internals of the kernel application.</source>
          <target state="translated">Vemos que &lt;code&gt;file:write/2&lt;/code&gt; solo llama a &lt;code&gt;prim_file:write/2&lt;/code&gt; , pero evitemos indagar en los aspectos internos de la aplicaci&amp;oacute;n del kernel.</target>
        </trans-unit>
        <trans-unit id="1ae6a760c341c75f5fb2da4019fa63a21130812e" translate="yes" xml:space="preserve">
          <source>We see that the algorithm set is changed to the one in the &lt;code&gt;ex2.config&lt;/code&gt;. Since &lt;code&gt;compression&lt;/code&gt; is not specified in the file, the hard-coded default is still used for that entry.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c3b22518344463198707dd795380094d0c8925a" translate="yes" xml:space="preserve">
          <source>We see that the new release version is &lt;code&gt;permanent&lt;/code&gt;, so it would be safe to restart the node.</source>
          <target state="translated">Vemos que la nueva versi&amp;oacute;n de lanzamiento es &lt;code&gt;permanent&lt;/code&gt; e , por lo que ser&amp;iacute;a seguro reiniciar el nodo.</target>
        </trans-unit>
        <trans-unit id="b50565a62199c6c141d92fc8afb4546283ef2fd4" translate="yes" xml:space="preserve">
          <source>We simply pick out an I/O vector from the queue (which is the whole queue as a &lt;code&gt;SysIOVec&lt;/code&gt;). If the I/O vector is too long (&lt;code&gt;IO_VECTOR_MAX&lt;/code&gt; is defined to 16), the vector length is decreased (line 15), otherwise the &lt;code&gt;writev&lt;/code&gt; call (line 17) fails. Writing is tried and anything written is dequeued (line 27). If the write fails with &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (notice that all sockets are in non-blocking mode), &lt;code&gt;driver_select&lt;/code&gt; is called to make the &lt;code&gt;uds_output&lt;/code&gt; routine be called when there is space to write again.</source>
          <target state="translated">Simplemente seleccionamos un vector de E / S de la cola (que es toda la cola como &lt;code&gt;SysIOVec&lt;/code&gt; ). Si el vector de E / S es demasiado largo ( &lt;code&gt;IO_VECTOR_MAX&lt;/code&gt; se define en 16), la longitud del vector se reduce (l&amp;iacute;nea 15); de lo contrario, la llamada &lt;code&gt;writev&lt;/code&gt; (l&amp;iacute;nea 17) falla. Se intenta escribir y todo lo que se escribe se quita de la cola (l&amp;iacute;nea 27). Si la escritura falla con &lt;code&gt;EWOULDBLOCK&lt;/code&gt; (aviso de que todos los conectores est&amp;aacute;n en modo no-bloqueo), &lt;code&gt;driver_select&lt;/code&gt; est&amp;aacute; llamado a hacer el &lt;code&gt;uds_output&lt;/code&gt; rutina se llama cuando hay espacio para escribir de nuevo.</target>
        </trans-unit>
        <trans-unit id="d0ada7dbfa4e9b0738c600e7e0aaa004c64d9416" translate="yes" xml:space="preserve">
          <source>We specify the filter, we want to view calls that resemble &lt;code&gt;ets:new(toy_table, &amp;lt;something&amp;gt;)&lt;/code&gt;:</source>
          <target state="translated">Especificamos el filtro, queremos ver llamadas que se parezcan a &lt;code&gt;ets:new(toy_table, &amp;lt;something&amp;gt;)&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1235892250491b3de3e5ff2495a68e9d2682e8e0" translate="yes" xml:space="preserve">
          <source>We start a &lt;strong&gt;simple target system&lt;/strong&gt; as above. The only difference is that also the file &lt;code&gt;releases/RELEASES&lt;/code&gt; is present for code replacement in runtime to work.</source>
          <target state="translated">Comenzamos un &lt;strong&gt;sistema de destino simple&lt;/strong&gt; como el anterior. La &amp;uacute;nica diferencia es que tambi&amp;eacute;n los &lt;code&gt;releases/RELEASES&lt;/code&gt; archivos / RELEASES est&amp;aacute;n presentes para que el reemplazo de c&amp;oacute;digo en tiempo de ejecuci&amp;oacute;n funcione.</target>
        </trans-unit>
        <trans-unit id="c601e5855e0a64b0a4dc2997f72bc0154a5ac01a" translate="yes" xml:space="preserve">
          <source>We start writing the example Unix domain sockets driver by declaring prototypes and filling in a static &lt;code&gt;ErlDrvEntry&lt;/code&gt; structure:</source>
          <target state="translated">Comenzamos a escribir el controlador de sockets de dominio Unix de ejemplo declarando prototipos y completando una estructura &lt;code&gt;ErlDrvEntry&lt;/code&gt; est&amp;aacute;tica :</target>
        </trans-unit>
        <trans-unit id="0ed0ee62a50934d618226ac2077c2ac131a4a88f" translate="yes" xml:space="preserve">
          <source>We still go to single threaded mode when new code is loaded for a module that is traced, or when loading code when there is a default trace pattern set. That is not impossible to fix, but that requires much closer cooperation between tracing BIFs and the loader BIFs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644c408e343363fe6260f95a6a30cda576bd3ce6" translate="yes" xml:space="preserve">
          <source>We store the &lt;code&gt;creation&lt;/code&gt; serial number in the file. The &lt;code&gt;creation&lt;/code&gt; is a number that is to change between different instances of different Erlang emulators with the same name, so that process identifiers from one emulator do not become valid when sent to a new emulator with the same distribution name. The creation can be from 0 through 3 (two bits) and is stored in every process identifier sent to another node.</source>
          <target state="translated">Almacenamos el n&amp;uacute;mero de serie de &lt;code&gt;creation&lt;/code&gt; en el archivo. La &lt;code&gt;creation&lt;/code&gt; es un n&amp;uacute;mero que debe cambiar entre diferentes instancias de diferentes emuladores de Erlang con el mismo nombre, de modo que los identificadores de proceso de un emulador no sean v&amp;aacute;lidos cuando se env&amp;iacute;en a un nuevo emulador con el mismo nombre de distribuci&amp;oacute;n. La creaci&amp;oacute;n puede ser de 0 a 3 (dos bits) y se almacena en cada identificador de proceso enviado a otro nodo.</target>
        </trans-unit>
        <trans-unit id="63a6ffdb62bb132307bcc5f5fe297a041b9ec3d7" translate="yes" xml:space="preserve">
          <source>We strongly encourage the use of the &lt;code&gt;RowStatus&lt;/code&gt; convention for every table that can be modified from the manager, even for newly designed SNMPv1 MIBs. In SNMPv1, everybody has invented their own scheme for emulating table operations, which has led to numerous inconsistencies. The convention in SNMPv2 is flexible and powerful and has been tested successfully. If the table is read only, no RowStatus column should be used.</source>
          <target state="translated">&lt;code&gt;RowStatus&lt;/code&gt; encarecidamente el uso de la convenci&amp;oacute;n RowStatus para cada tabla que se pueda modificar desde el administrador, incluso para MIB SNMPv1 de nuevo dise&amp;ntilde;o. En SNMPv1, todos han inventado su propio esquema para emular operaciones de tablas, lo que ha dado lugar a numerosas inconsistencias. La convenci&amp;oacute;n en SNMPv2 es flexible y potente y se ha probado con &amp;eacute;xito. Si la tabla es de solo lectura, no se debe utilizar ninguna columna RowStatus.</target>
        </trans-unit>
        <trans-unit id="508ccb34921947b5beb2005777369f595ad7c8a8" translate="yes" xml:space="preserve">
          <source>We study the state that is needed for the ports. Notice that not all fields are used for all types of ports. Some space could be saved by using unions, but that would clutter the code with multiple indirections, so here is used one struct for all types of ports, for readability:</source>
          <target state="translated">Estudiamos el estado que se necesita para los puertos.Noten que no todos los campos se usan para todos los tipos de puertos.Se podría ahorrar algo de espacio usando uniones,pero eso desordenaría el código con múltiples indirectas,así que aquí se usa una estructura para todos los tipos de puertos,para la legibilidad:</target>
        </trans-unit>
        <trans-unit id="0570780114e9fc609087371872169fccbd297f49" translate="yes" xml:space="preserve">
          <source>We suspect the &lt;code&gt;ets:new/2&lt;/code&gt; call, as we match hard on the return value, but want only the particular &lt;code&gt;new/2&lt;/code&gt; call with &lt;code&gt;toy_table&lt;/code&gt; as first parameter. So we start a default tracer on the node:</source>
          <target state="translated">Sospechamos la llamada &lt;code&gt;ets:new/2&lt;/code&gt; , ya que coincidimos con el valor de retorno, pero solo queremos la llamada &lt;code&gt;new/2&lt;/code&gt; particular con &lt;code&gt;toy_table&lt;/code&gt; como primer par&amp;aacute;metro. Entonces comenzamos un trazador predeterminado en el nodo:</target>
        </trans-unit>
        <trans-unit id="f5bbffab7f95f81cee247421bd092ab29a87848d" translate="yes" xml:space="preserve">
          <source>We turn on call tracing for all processes, we want to make a pretty restrictive trace pattern, so there is no need to call trace only a few processes (usually it is not):</source>
          <target state="translated">Activamos el rastreo de llamadas para todos los procesos,queremos hacer un patrón de rastreo bastante restrictivo,por lo que no es necesario llamar a rastreo sólo a unos pocos procesos (normalmente no lo es):</target>
        </trans-unit>
        <trans-unit id="59f43c3a056dd53d064433399740ce5398c03179" translate="yes" xml:space="preserve">
          <source>We use &lt;code&gt;dbg:tpl/3&lt;/code&gt; to ensure to catch local calls (assume that the module has grown since the smaller version and we are unsure if this inserting of atoms is not done locally). When in doubt, always use local call tracing.</source>
          <target state="translated">Usamos &lt;code&gt;dbg:tpl/3&lt;/code&gt; para asegurarnos de capturar llamadas locales (supongamos que el m&amp;oacute;dulo ha crecido desde la versi&amp;oacute;n m&amp;aacute;s peque&amp;ntilde;a y no estamos seguros de si esta inserci&amp;oacute;n de &amp;aacute;tomos no se realiza localmente). En caso de duda, utilice siempre el rastreo de llamadas locales.</target>
        </trans-unit>
        <trans-unit id="3db459c71765166584b222966eebe056c8bcb451" translate="yes" xml:space="preserve">
          <source>We use the &lt;code&gt;port_control/3&lt;/code&gt; function for all calls into the driver. The result from the driver is returned immediately and converted to terms by calling &lt;code&gt;binary_to_term/1&lt;/code&gt;. (We trust that the terms returned from the driver are well-formed, otherwise the &lt;code&gt;binary_to_term&lt;/code&gt; calls could be contained in a &lt;code&gt;catch&lt;/code&gt;.)</source>
          <target state="translated">Usamos la funci&amp;oacute;n &lt;code&gt;port_control/3&lt;/code&gt; para todas las llamadas al controlador. El resultado del controlador se devuelve inmediatamente y se convierte en t&amp;eacute;rminos llamando a &lt;code&gt;binary_to_term/1&lt;/code&gt; . (Confiamos en que los t&amp;eacute;rminos devueltos por el controlador est&amp;eacute;n bien formados; de lo contrario, las llamadas &lt;code&gt;binary_to_term&lt;/code&gt; podr&amp;iacute;an incluirse en una &lt;code&gt;catch&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="02fb426878fcef94b8e18d9576286ad65ac4ed4a" translate="yes" xml:space="preserve">
          <source>We use the binary format only to return data to the emulator; input data is a string parameter for &lt;code&gt;connect&lt;/code&gt; and &lt;code&gt;select&lt;/code&gt;. The returned data consists of Erlang terms.</source>
          <target state="translated">Usamos el formato binario solo para devolver datos al emulador; Los datos de entrada son un par&amp;aacute;metro de cadena para &lt;code&gt;connect&lt;/code&gt; y &lt;code&gt;select&lt;/code&gt; . Los datos devueltos consisten en t&amp;eacute;rminos de Erlang.</target>
        </trans-unit>
        <trans-unit id="014d84a4d3abb1236ee92db9f5f0d5547ff6a186" translate="yes" xml:space="preserve">
          <source>We use the function &lt;code&gt;Rep&lt;/code&gt; to denote the mapping from an Erlang source construct &lt;code&gt;C&lt;/code&gt; to its abstract format representation &lt;code&gt;R&lt;/code&gt;, and write &lt;code&gt;R = Rep(C)&lt;/code&gt;.</source>
          <target state="translated">Usamos la funci&amp;oacute;n &lt;code&gt;Rep&lt;/code&gt; para denotar el mapeo de una construcci&amp;oacute;n fuente de Erlang &lt;code&gt;C&lt;/code&gt; a su representaci&amp;oacute;n de formato abstracto &lt;code&gt;R&lt;/code&gt; , y escribimos &lt;code&gt;R = Rep(C)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b955b8cc53f04946e7906d8bccd83ad77bc547a4" translate="yes" xml:space="preserve">
          <source>We use the same internal form for both the binary and text encoding. Our internal form of Megaco/H.248 messages is heavily influenced by the internal format used by ASN.1 encoders/decoders:</source>
          <target state="translated">Utilizamos la misma forma interna para la codificación binaria y de texto.Nuestra forma interna de los mensajes Megaco/H.248 está fuertemente influenciada por el formato interno usado por los codificadores/decodificadores ASN.1:</target>
        </trans-unit>
        <trans-unit id="09eafdf76bfe34feacf5ab1510c6a7720bed3f57" translate="yes" xml:space="preserve">
          <source>We use the simplest possible &lt;code&gt;sys.config&lt;/code&gt;, which we store in &lt;code&gt;releases/FIRST&lt;/code&gt;:</source>
          <target state="translated">Usamos el &lt;code&gt;sys.config&lt;/code&gt; m&amp;aacute;s simple posible , que almacenamos en &lt;code&gt;releases/FIRST&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="b0d8589e4a15b7a5013c9800a611e86facb44e60" translate="yes" xml:space="preserve">
          <source>We very much welcome user feedback - even wishlists! If you notice anything weird, especially if Dialyzer reports any discrepancy that is a false positive, please send an error report describing the symptoms and how to reproduce them.</source>
          <target state="translated">Agradecemos mucho los comentarios de los usuarios,¡incluso las listas de deseos! Si notan algo raro,especialmente si Dialyzer reporta alguna discrepancia que sea un falso positivo,por favor envíen un reporte de error describiendo los síntomas y cómo reproducirlos.</target>
        </trans-unit>
        <trans-unit id="c5f285e2cc8e54c3430820d9c7f8e8768e8a5b79" translate="yes" xml:space="preserve">
          <source>We want a locking mechanism that gives no race conditions, to be sure if another Erlang node uses the listen socket name we require or if the file is only left there from a previous (crashed) session.</source>
          <target state="translated">Queremos un mecanismo de bloqueo que no dé condiciones de carrera,para estar seguros de que si otro nodo de Erlang usa el nombre del socket de escucha que requerimos o si el archivo sólo queda allí de una sesión anterior (estrellada).</target>
        </trans-unit>
        <trans-unit id="b3d62af079f72041cf5e740a82dc4dbd33004d95" translate="yes" xml:space="preserve">
          <source>We want to find the reduction of the closure of the function graph to modules. The direct expression for doing that would be &lt;code&gt;(Mod)&amp;nbsp;(closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;AM)&lt;/code&gt;, but then we would have to represent all of the transitive closure of E in memory. Instead the number of indirectly used modules is found for each analyzed module, and the sum over all modules is calculated.</source>
          <target state="translated">Queremos encontrar la reducci&amp;oacute;n del cierre del gr&amp;aacute;fico de funciones a m&amp;oacute;dulos. La expresi&amp;oacute;n directa para hacer eso ser&amp;iacute;a &lt;code&gt;(Mod)&amp;nbsp;(closure&amp;nbsp;E&amp;nbsp;|&amp;nbsp;AM)&lt;/code&gt; , pero entonces tendr&amp;iacute;amos que representar todo el cierre transitivo de E en la memoria. En su lugar, se encuentra el n&amp;uacute;mero de m&amp;oacute;dulos usados ​​indirectamente para cada m&amp;oacute;dulo analizado y se calcula la suma de todos los m&amp;oacute;dulos.</target>
        </trans-unit>
        <trans-unit id="70463b6b569fc0648d3d04d1de5cd8aeaea41835" translate="yes" xml:space="preserve">
          <source>We will also need to define a specific instruction and an implementation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3e5e22774ee70e0f2042f44b9bc134daa843dc9" translate="yes" xml:space="preserve">
          <source>We will describe a few of the most useful macros here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1cec4b25e7ec82e4a29c249c1772265612c2f98" translate="yes" xml:space="preserve">
          <source>We will first go through the &lt;code&gt;configure&lt;/code&gt;/&lt;code&gt;make&lt;/code&gt; build procedure which people probably are most familiar with.</source>
          <target state="translated">Primero veremos el procedimiento &lt;code&gt;configure&lt;/code&gt; / &lt;code&gt;make&lt;/code&gt; build con el que la gente probablemente est&amp;eacute; m&amp;aacute;s familiarizada.</target>
        </trans-unit>
        <trans-unit id="0576d6764bbcae3841fb03ef32241effb70e7bed" translate="yes" xml:space="preserve">
          <source>We will go through each line in turn.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e92a721ff1fb03d81cf679fa0c2700795b3ef20" translate="yes" xml:space="preserve">
          <source>We will go through the lines that are new or have changed compared to &lt;code&gt;move_cx&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1922b9b72d1fce0784918b07377d42edc5816c5e" translate="yes" xml:space="preserve">
          <source>We will look at the code for each specific instruction in turn. To make the code easier to understand, let's first look at the memory layout for the instruction &lt;code&gt;{move,{atom,id},{x,5}}&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e5ff38c2602baf56bc8c3440d3937fb894b7ad10" translate="yes" xml:space="preserve">
          <source>We will not be bug-compatible. A bug fix might introduce incompatible changes. This kind of incompatibility might occur in a patch.</source>
          <target state="translated">No seremos compatibles con los insectos.Una corrección de errores podría introducir cambios incompatibles.Este tipo de incompatibilidad podría ocurrir en un parche.</target>
        </trans-unit>
        <trans-unit id="4a8371df807c1d9828677bbee6ed0833eeb9de70" translate="yes" xml:space="preserve">
          <source>We will now check if the &lt;code&gt;&lt;a href=&quot;ssh#type-modify_algorithms_common_option&quot;&gt;modify_algorithms&lt;/a&gt;&lt;/code&gt; on a lower level is applied to a &lt;code&gt;&lt;a href=&quot;ssh#type-preferred_algorithms_common_option&quot;&gt;preferred_algorithms&lt;/a&gt;&lt;/code&gt; on a higher level. We will do that by enabling the &lt;code&gt;ssh-dss&lt;/code&gt; algorithm that is supported, but not in the default set.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aad9e6cc5dd978296e9f3155b1fac5bd4e904894" translate="yes" xml:space="preserve">
          <source>We will see more details of this later. If you want to experiment with distributed Erlang, but you only have one computer to work on, you can start two separate Erlang systems on the same computer but give them different names. Each Erlang system running on a computer is called an &lt;strong&gt;Erlang node&lt;/strong&gt;.</source>
          <target state="translated">Veremos m&amp;aacute;s detalles de esto m&amp;aacute;s adelante. Si desea experimentar con Erlang distribuido, pero solo tiene una computadora para trabajar, puede iniciar dos sistemas Erlang separados en la misma computadora, pero as&amp;iacute;gneles nombres diferentes. Cada sistema Erlang que se ejecuta en una computadora se denomina &lt;strong&gt;nodo Erlang&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="003f9e7ef78da8c0f188a6f92bd1faf2dec2b304" translate="yes" xml:space="preserve">
          <source>We will start looking at the patterns on the left side of the arrow.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d9436898fb9eadec20c9220ce4b0c6a8fef0ef4" translate="yes" xml:space="preserve">
          <source>We would have to change the order of the operands so that the two operands that are different are placed first:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6fd397370c00ee4d81771bc1a4690627c9a9c47d" translate="yes" xml:space="preserve">
          <source>We would recommend using 1.0.2d.</source>
          <target state="translated">Recomendamos usar 1.0.2d.</target>
        </trans-unit>
        <trans-unit id="843043fadfaea89e297baed2f38224161728a8fc" translate="yes" xml:space="preserve">
          <source>We write it using &lt;code&gt;ets:fun2ms/1&lt;/code&gt;:</source>
          <target state="translated">Lo escribimos usando &lt;code&gt;ets:fun2ms/1&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2d11ec20af5e84fd81824db4ba0a8cd93159b8e2" translate="yes" xml:space="preserve">
          <source>We've tried up to 1.0, but the latest version should do. Make sure you download the &lt;code&gt;mingw-w64-bin_i686-mingw_&amp;lt;something&amp;gt;.zip&lt;/code&gt;, not a linux version. You unzip the package on top of your MinGW installation (&lt;code&gt;c:\MinGW&lt;/code&gt;) and that's it.</source>
          <target state="translated">Hemos probado hasta la 1.0, pero la &amp;uacute;ltima versi&amp;oacute;n deber&amp;iacute;a funcionar. Aseg&amp;uacute;rese de descargar &lt;code&gt;mingw-w64-bin_i686-mingw_&amp;lt;something&amp;gt;.zip&lt;/code&gt; , no una versi&amp;oacute;n de Linux. Descomprime el paquete en la parte superior de la instalaci&amp;oacute;n de MinGW ( &lt;code&gt;c:\MinGW&lt;/code&gt; ) y eso es todo.</target>
        </trans-unit>
        <trans-unit id="b8eef6e94eb7100a713ed2ea56c1d7018de92907" translate="yes" xml:space="preserve">
          <source>We've used this build procedure for a couple of releases, and it has worked fine for us. Still, there might be all sorts of troubles on different machines and with different setups. We'll try to give hints wherever we've encountered difficulties, but please share your experiences by using the &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;erlang-questions&lt;/a&gt;&lt;/code&gt; mailing list. We cannot, of course, help everyone with all their issues, so please try to solve such issues and submit solutions/workarounds.</source>
          <target state="translated">Hemos utilizado este procedimiento de compilaci&amp;oacute;n en un par de versiones y nos ha funcionado bien. A&amp;uacute;n as&amp;iacute;, puede haber todo tipo de problemas en diferentes m&amp;aacute;quinas y con diferentes configuraciones. Intentaremos dar pistas dondequiera que encontremos dificultades, pero comparta sus experiencias utilizando la lista de correo de &lt;code&gt;&lt;a href=&quot;http://www.erlang.org/static/doc/mailinglist.html&quot;&gt;erlang-questions&lt;/a&gt;&lt;/code&gt; . Por supuesto, no podemos ayudar a todos con todos sus problemas, as&amp;iacute; que intente resolverlos y env&amp;iacute;e soluciones / soluciones.</target>
        </trans-unit>
        <trans-unit id="b36b032611690f561af6ed7868e7f249080a2d29" translate="yes" xml:space="preserve">
          <source>Web server users without server administrative privileges that need to manage authentication of web pages that are local to their user can use the per-directory runtime configurable user-authentication scheme &lt;code&gt;htaccess&lt;/code&gt;. It works as follows:</source>
          <target state="translated">Los usuarios del servidor web sin privilegios administrativos del servidor que necesiten administrar la autenticaci&amp;oacute;n de las p&amp;aacute;ginas web que son locales para su usuario pueden usar el esquema de autenticaci&amp;oacute;n de usuario configurable en tiempo de ejecuci&amp;oacute;n por directorio &lt;code&gt;htaccess&lt;/code&gt; . Funciona de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="3ee3b99c66ed2c1f02ee33b7f98ce7fdcb23b424" translate="yes" xml:space="preserve">
          <source>Welcome to Erlang/OTP, a complete development environment for concurrent programming.</source>
          <target state="translated">Bienvenido a Erlang/OTP,un completo entorno de desarrollo para la programación concurrente.</target>
        </trans-unit>
        <trans-unit id="c37fc88b34e83873604a95298f56f654eb5124b8" translate="yes" xml:space="preserve">
          <source>What do these different configurations do and when should we use them? Let's start by going through what happens when one Erlang process sends a message to another. The sending process needs to do a couple of things:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="91a06e19576dea4a7c8ca9f09d25418575cf2e86" translate="yes" xml:space="preserve">
          <source>What is a printable character in this case is determined by startup flag &lt;code&gt;+pc&lt;/code&gt; to the Erlang VM; see &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt; io:printable_range/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22c886918035c78f6182ee187f960d0ece83d0bb" translate="yes" xml:space="preserve">
          <source>What is a printable character in this case is determined by startup flag &lt;code&gt;+pc&lt;/code&gt; to the Erlang VM; see &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt;io:printable_range/0&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;erl(1)&lt;/code&gt;.</source>
          <target state="translated">Lo que es un car&amp;aacute;cter imprimible en este caso se determina mediante el indicador de inicio &lt;code&gt;+pc&lt;/code&gt; en la m&amp;aacute;quina virtual Erlang; consulte &lt;code&gt;&lt;a href=&quot;io#printable_range-0&quot;&gt;io:printable_range/0&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;erl(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4edfb9d438187e25e8117b3d96348c8b942d6ff3" translate="yes" xml:space="preserve">
          <source>What is captured in this example is the part of the work the shell does while interpreting the command line that occurs between the actual calls to &lt;code&gt;cprof:start()&lt;/code&gt; and &lt;code&gt;cprof:analyse()&lt;/code&gt;.</source>
          <target state="translated">Lo que se captura en este ejemplo es la parte del trabajo que realiza el shell mientras interpreta la l&amp;iacute;nea de comando que ocurre entre las llamadas reales a &lt;code&gt;cprof:start()&lt;/code&gt; y &lt;code&gt;cprof:analyse()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="46a5d2a876a396d12b70584eeaf74dfeaa79d06c" translate="yes" xml:space="preserve">
          <source>What is the difference between them, if any? They provide an overlapping definition for resource identifiers and they are not compatible. The &lt;code&gt;uri_string&lt;/code&gt; module implements &lt;code&gt;&lt;a href=&quot;https://www.ietf.org/rfc/rfc3986.txt&quot;&gt;RFC 3986&lt;/a&gt;&lt;/code&gt; and the term URI will be used throughout this document. A URI is an identifier, a string of characters that identifies a particular resource.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8308f9197a4bcfd38df815152af92e5bca4b765b" translate="yes" xml:space="preserve">
          <source>What makes the &lt;code&gt;Mnesia&lt;/code&gt; data model an extended relational model is the ability to store arbitrary Erlang terms in the attribute fields. One attribute value can, for example, be a whole tree of OIDs leading to other terms in other tables. This type of record is difficult to model in traditional relational DBMSs.</source>
          <target state="translated">Lo que hace que el modelo de datos de &lt;code&gt;Mnesia&lt;/code&gt; sea un modelo relacional extendido es la capacidad de almacenar t&amp;eacute;rminos Erlang arbitrarios en los campos de atributos. Un valor de atributo puede, por ejemplo, ser un &amp;aacute;rbol completo de OID que conducen a otros t&amp;eacute;rminos en otras tablas. Este tipo de registro es dif&amp;iacute;cil de modelar en los DBMS relacionales tradicionales.</target>
        </trans-unit>
        <trans-unit id="ed11d038ec16d30b3bea2a7475ee3a6b9b40a0e1" translate="yes" xml:space="preserve">
          <source>What makes the graphs provided here non-proper directed graphs is that multiple edges between vertices are allowed. However, the customary definition of directed graphs is used here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3e54b84bf8a59386ffce97008e70cfe702e204e" translate="yes" xml:space="preserve">
          <source>What more can you do? A simple answer is: see the documentation of &lt;code&gt;match specifications&lt;/code&gt; in ERTS User's Guide. However, the following is a brief overview of the most useful &quot;built-in functions&quot; that you can use when the fun is to be translated into a match specification by &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt; ets:fun2ms/1&lt;/a&gt;&lt;/code&gt;. It is not possible to call other functions than those allowed in match specifications. No &quot;usual&quot; Erlang code can be executed by the fun that is translated by &lt;code&gt;ets:fun2ms/1&lt;/code&gt;. The fun is limited exactly to the power of the match specifications, which is unfortunate, but the price one must pay for the execution speed of &lt;code&gt;ets:select/2&lt;/code&gt; compared to &lt;code&gt;ets:foldl/foldr&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="405eee64426a95cf4618da03e92872e8805137ae" translate="yes" xml:space="preserve">
          <source>What more can you do? A simple answer is: see the documentation of &lt;code&gt;match specifications&lt;/code&gt; in ERTS User's Guide. However, the following is a brief overview of the most useful &quot;built-in functions&quot; that you can use when the fun is to be translated into a match specification by &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt;. It is not possible to call other functions than those allowed in match specifications. No &quot;usual&quot; Erlang code can be executed by the fun that is translated by &lt;code&gt;ets:fun2ms/1&lt;/code&gt;. The fun is limited exactly to the power of the match specifications, which is unfortunate, but the price one must pay for the execution speed of &lt;code&gt;ets:select/2&lt;/code&gt; compared to &lt;code&gt;ets:foldl/foldr&lt;/code&gt;.</source>
          <target state="translated">Que mas puedes hacer? Una respuesta simple es: consulte la documentaci&amp;oacute;n de las &lt;code&gt;match specifications&lt;/code&gt; de los partidos en la Gu&amp;iacute;a del usuario de ERTS. Sin embargo, la siguiente es una breve descripci&amp;oacute;n de las &quot;funciones integradas&quot; m&amp;aacute;s &amp;uacute;tiles que puede utilizar cuando la diversi&amp;oacute;n se va a traducir en una especificaci&amp;oacute;n de coincidencia mediante &lt;code&gt;&lt;a href=&quot;ets#fun2ms-1&quot;&gt;ets:fun2ms/1&lt;/a&gt;&lt;/code&gt; . No es posible llamar a otras funciones que las permitidas en las especificaciones de coincidencia. Ning&amp;uacute;n c&amp;oacute;digo Erlang &quot;habitual&quot; puede ser ejecutado por la diversi&amp;oacute;n traducida por &lt;code&gt;ets:fun2ms/1&lt;/code&gt; . La diversi&amp;oacute;n se limita exactamente a la potencia de las especificaciones del partido, lo cual es lamentable, pero el precio que uno debe pagar por la velocidad de ejecuci&amp;oacute;n de &lt;code&gt;ets:select/2&lt;/code&gt; en comparaci&amp;oacute;n con &lt;code&gt;ets:foldl/foldr&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f64087ee8c6f485b57fb883b43af5c4cc87d95a" translate="yes" xml:space="preserve">
          <source>What options are valid depend both on &lt;code&gt;Level&lt;/code&gt; and on what kind of socket it is (&lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;protocol&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a27731ebf65f31807af372a7113b45b9d6de2d" translate="yes" xml:space="preserve">
          <source>What properties are valid depend both on &lt;code&gt;Level&lt;/code&gt; and on what kind of socket it is (&lt;code&gt;domain&lt;/code&gt;, &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;protocol&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9abe5ff356944e50659de71982880b18848dd6" translate="yes" xml:space="preserve">
          <source>What reservation of physical memory means, highly depends on the operating system, and how it is configured. For example, different memory overcommit settings on Linux drastically change the behavior.</source>
          <target state="translated">Lo que significa reserva de memoria física,depende en gran medida del sistema operativo y de cómo esté configurado.Por ejemplo,diferentes configuraciones de sobrecompromiso de memoria en Linux cambian drásticamente el comportamiento.</target>
        </trans-unit>
        <trans-unit id="587af77c14f789357e51980e72003df91f480665" translate="yes" xml:space="preserve">
          <source>What the &lt;code&gt;qlc&lt;/code&gt; module primarily adds to list comprehensions is that data can be read from QLC tables in small chunks. A QLC table is created by calling &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Usually &lt;code&gt;qlc:table/2&lt;/code&gt; is not called directly from the query but through an interface function of some data structure. Erlang/OTP includes a few examples of such functions: &lt;code&gt;mnesia:table/1,2&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;ets#table-1&quot;&gt;ets:table/1,2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;dets#table-1&quot;&gt;dets:table/1,2&lt;/a&gt;&lt;/code&gt;. For a given data structure, many functions can create QLC tables, but common for these functions is that they return a query handle created by &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt;. Using the QLC tables provided by Erlang/OTP is usually probably sufficient, but for the more advanced user section &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; describes the implementation of a function calling &lt;code&gt;qlc:table/2&lt;/code&gt;.</source>
          <target state="translated">Lo que el m&amp;oacute;dulo &lt;code&gt;qlc&lt;/code&gt; agrega principalmente a las listas por comprensi&amp;oacute;n es que los datos se pueden leer de las tablas QLC en peque&amp;ntilde;os fragmentos. Se crea una tabla QLC llamando a &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt; . Por &lt;code&gt;qlc:table/2&lt;/code&gt; general, qlc: table / 2 no se llama directamente desde la consulta sino a trav&amp;eacute;s de una funci&amp;oacute;n de interfaz de alguna estructura de datos. Erlang / OTP incluye algunos ejemplos de tales funciones: &lt;code&gt;mnesia:table/1,2&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;ets#table-1&quot;&gt;ets:table/1,2&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;dets#table-1&quot;&gt;dets:table/1,2&lt;/a&gt;&lt;/code&gt; . Para una estructura de datos dada, muchas funciones pueden crear tablas QLC, pero lo com&amp;uacute;n para estas funciones es que devuelven un identificador de consulta creado por &lt;code&gt;&lt;a href=&quot;#table-2&quot;&gt;qlc:table/2&lt;/a&gt;&lt;/code&gt; . El uso de las tablas QLC proporcionadas por Erlang / OTP es probablemente suficiente, pero para la secci&amp;oacute;n de usuarios m&amp;aacute;s avanzados &lt;code&gt;&lt;a href=&quot;#implementing_a_qlc_table&quot;&gt;Implementing a QLC Table&lt;/a&gt;&lt;/code&gt; describe la implementaci&amp;oacute;n de una funci&amp;oacute;n que llama a &lt;code&gt;qlc:table/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e307252350d5f0ef992b3ab620b890f8bd198517" translate="yes" xml:space="preserve">
          <source>What the I/O server sends when there is no data.</source>
          <target state="translated">Lo que el servidor de E/S envía cuando no hay datos.</target>
        </trans-unit>
        <trans-unit id="1804d21d5ef8f5b8cb1f89c4e94fe07aef9672aa" translate="yes" xml:space="preserve">
          <source>What this means, if anything, is implementation dependent.</source>
          <target state="translated">Lo que esto significa,en todo caso,depende de la aplicación.</target>
        </trans-unit>
        <trans-unit id="7351aa821dda7989c82c251abb71293dcac3c00b" translate="yes" xml:space="preserve">
          <source>What to log and how</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a86e62a665b180d594c01dd61c21371b36d33af5" translate="yes" xml:space="preserve">
          <source>What you have to do in such cases is to write your metavariable in a syntactically valid position, and use lifting markers to denote where it should really apply, as in:</source>
          <target state="translated">Lo que hay que hacer en estos casos es escribir la metavariable en una posición sintácticamente válida,y utilizar marcadores de elevación para indicar dónde debería aplicarse realmente,como por ejemplo:</target>
        </trans-unit>
        <trans-unit id="c5c621a34cc77c693f796b9c9a4e0202b514808a" translate="yes" xml:space="preserve">
          <source>Whatever added by &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; in the test suite.</source>
          <target state="translated">Lo que sea agregado por &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;common_test#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; en el conjunto de pruebas.</target>
        </trans-unit>
        <trans-unit id="24d7dba872f239c3722291e671d97f08fe9ef4ae" translate="yes" xml:space="preserve">
          <source>Whatever added by &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_suite-1&quot;&gt;init_per_suite/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;ct_suite#Module:init_per_testcase-2&quot;&gt;init_per_testcase/2&lt;/a&gt;&lt;/code&gt; in the test suite.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e65ac25edcc6a715cbfb229eba192595c676d46" translate="yes" xml:space="preserve">
          <source>When (*SKIP) has an associated name, its behavior is modified:</source>
          <target state="translated">Cuando (*SKIP)tiene un nombre asociado,su comportamiento se modifica:</target>
        </trans-unit>
        <trans-unit id="04fe958830198355cc811da35c494d7c1c3c2d18" translate="yes" xml:space="preserve">
          <source>When (finally?) everything is in order with the locale settings, fonts. and the terminal emulator, you have probably found a way to input characters in the script you desire. For testing, the simplest way is to add some keyboard mappings for other languages, usually done with some applet in your desktop environment.</source>
          <target state="translated">Cuando (¿finalmente?)todo esté en orden con los ajustes de localización,las fuentes y el emulador de terminal,probablemente hayas encontrado la forma de introducir los caracteres en el guión que desees.Para probar,la forma más simple es añadir algunas asignaciones de teclado para otros idiomas,normalmente hechas con algún applet en tu entorno de escritorio.</target>
        </trans-unit>
        <trans-unit id="de541ea3fda63c5a944619402b0a682059a1f89d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;logger#get_config-0&quot;&gt; logger:get_config/0&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#get_handler_config-0&quot;&gt; logger:get_handler_config/0,1&lt;/a&gt;&lt;/code&gt; is called, Logger calls &lt;code&gt;HModule:filter_config(Config)&lt;/code&gt;. This function must return the handler configuration where internal data is removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b0d566142bbb33f59317bb4f642875e3ad38999" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt; logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt; logger:update_handler_config/2,3&lt;/a&gt;&lt;/code&gt; is called, Logger calls &lt;code&gt;HModule:changing_config(SetOrUpdate, OldConfig, NewConfig)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,NewConfig1}&lt;/code&gt;, Logger writes &lt;code&gt;NewConfig1&lt;/code&gt; to the configuration database.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c61293396a0994c6191d7911346e57c38611cf9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt;logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt;logger:update_handler_config/2&lt;/a&gt;&lt;/code&gt; is called, Logger calls &lt;code&gt;HModule:changing_config(OldConfig, NewConfig)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,NewConfig1}&lt;/code&gt;, Logger writes &lt;code&gt;NewConfig1&lt;/code&gt; to the configuration database.</source>
          <target state="translated">Cuando se &lt;code&gt;&lt;a href=&quot;logger#set_handler_config-2&quot;&gt;logger:set_handler_config/2,3&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;logger#update_handler_config-2&quot;&gt;logger:update_handler_config/2&lt;/a&gt;&lt;/code&gt; , Logger llama a &lt;code&gt;HModule:changing_config(OldConfig, NewConfig)&lt;/code&gt; . Si esta funci&amp;oacute;n devuelve &lt;code&gt;{ok,NewConfig1}&lt;/code&gt; , Logger escribe &lt;code&gt;NewConfig1&lt;/code&gt; en la base de datos de configuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="93e75014a8819db24d123ffe574cf1058af1d7b3" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Addr&lt;/code&gt; does not contain a port number, the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="translated">Cuando &lt;code&gt;Addr&lt;/code&gt; no contiene un n&amp;uacute;mero de &lt;code&gt;port&lt;/code&gt; se usa el valor de puerto .</target>
        </trans-unit>
        <trans-unit id="af3df4cc98d21f4d7157a7f5c03ed4afe7255c29" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;false&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, the &lt;code&gt;Result&lt;/code&gt; is returned by &lt;code&gt;erlang:cancel_timer()&lt;/code&gt;. otherwise &lt;code&gt;ok&lt;/code&gt; is returned.</source>
          <target state="translated">Cuando &lt;code&gt;Async&lt;/code&gt; es &lt;code&gt;false&lt;/code&gt; : si &lt;code&gt;Info&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , el &lt;code&gt;Result&lt;/code&gt; es devuelto por &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; . de lo contrario, se devuelve &lt;code&gt;ok&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3c3055751c190947148414125cb3febf1e8f6f5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Async&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;: if &lt;code&gt;Info&lt;/code&gt; is &lt;code&gt;true&lt;/code&gt;, a message on the form &lt;code&gt;{cancel_timer, TimerRef, Result}&lt;/code&gt; is sent to the caller of &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; when the cancellation operation has been performed, otherwise no message is sent.</source>
          <target state="translated">Cuando &lt;code&gt;Async&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; : si &lt;code&gt;Info&lt;/code&gt; es &lt;code&gt;true&lt;/code&gt; , se env&amp;iacute;a un mensaje con el formato &lt;code&gt;{cancel_timer, TimerRef, Result}&lt;/code&gt; a la persona que llama de &lt;code&gt;erlang:cancel_timer()&lt;/code&gt; cuando se ha realizado la operaci&amp;oacute;n de cancelaci&amp;oacute;n; de lo contrario, no se env&amp;iacute;a ning&amp;uacute;n mensaje.</target>
        </trans-unit>
        <trans-unit id="166a240b6e5cc60a7634b1583a60930de57018f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Common Test&lt;/code&gt; starts, it automatically attempts to compile any suites included in the specified tests. If particular suites are specified, only those suites are compiled. If a particular test object directory is specified (meaning all suites in this directory are to be part of the test), &lt;code&gt;Common Test&lt;/code&gt; runs function &lt;code&gt;make:all/1&lt;/code&gt; in the directory to compile the suites.</source>
          <target state="translated">Cuando se inicia &lt;code&gt;Common Test&lt;/code&gt; , autom&amp;aacute;ticamente intenta compilar cualquier suite incluida en las pruebas especificadas. Si se especifican suites en particular, solo se compilan esas suites. Si se especifica un directorio de objeto de prueba en particular (lo que significa que todas las suites en este directorio deben ser parte de la prueba), &lt;code&gt;Common Test&lt;/code&gt; ejecuta la funci&amp;oacute;n &lt;code&gt;make:all/1&lt;/code&gt; en el directorio para compilar las suites.</target>
        </trans-unit>
        <trans-unit id="8573ae20e451ce0821967cc87eca07cfcbab6866" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Mnesia&lt;/code&gt; loads many tables, the default load order is used. However, the load order can be affected, by explicitly changing property &lt;code&gt;load_order&lt;/code&gt; for the tables, with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt; mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;LoadOrder&lt;/code&gt; is by default &lt;code&gt;0&lt;/code&gt; for all tables, but it can be set to any integer. The table with the highest &lt;code&gt;load_order&lt;/code&gt; is loaded first. Changing the load order is especially useful for applications that need to ensure early availability of fundamental tables. Large peripheral tables are to have a low load order value, perhaps less than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42507199eef19752873563b14392dfa940c65fc9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Mnesia&lt;/code&gt; loads many tables, the default load order is used. However, the load order can be affected, by explicitly changing property &lt;code&gt;load_order&lt;/code&gt; for the tables, with the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt;mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;LoadOrder&lt;/code&gt; is by default &lt;code&gt;0&lt;/code&gt; for all tables, but it can be set to any integer. The table with the highest &lt;code&gt;load_order&lt;/code&gt; is loaded first. Changing the load order is especially useful for applications that need to ensure early availability of fundamental tables. Large peripheral tables are to have a low load order value, perhaps less than &lt;code&gt;0&lt;/code&gt;</source>
          <target state="translated">Cuando &lt;code&gt;Mnesia&lt;/code&gt; carga muchas tablas, se usa el orden de carga predeterminado. Sin embargo, el orden de carga puede verse afectado, cambiando expl&amp;iacute;citamente la propiedad &lt;code&gt;load_order&lt;/code&gt; para las tablas, con la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#change_table_load_order-2&quot;&gt;mnesia:change_table_load_order(Tab, LoadOrder)&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;LoadOrder&lt;/code&gt; es &lt;code&gt;0&lt;/code&gt; por defecto para todas las tablas, pero se puede establecer en cualquier n&amp;uacute;mero entero. La tabla con el &lt;code&gt;load_order&lt;/code&gt; m&amp;aacute;s alto se carga primero. Cambiar el orden de carga es especialmente &amp;uacute;til para aplicaciones que necesitan garantizar la disponibilidad temprana de tablas fundamentales. Las tablas de perif&amp;eacute;ricos grandes deben tener un valor de orden de carga bajo, quiz&amp;aacute;s menos de &lt;code&gt;0&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="69de3dae19f69610dd34e83bd997df060a7428e7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Module&lt;/code&gt;, &lt;code&gt;Function&lt;/code&gt;, and &lt;code&gt;Arguments&lt;/code&gt; are provided, we apply it and do the same with the result as if the data was provided directly.</source>
          <target state="translated">Cuando se proporcionan &lt;code&gt;Module&lt;/code&gt; , &lt;code&gt;Function&lt;/code&gt; y &lt;code&gt;Arguments&lt;/code&gt; , lo aplicamos y hacemos lo mismo con el resultado como si los datos se hubieran proporcionado directamente.</target>
        </trans-unit>
        <trans-unit id="c52ee13a4dcb299f5a385cfe15fc42403a860bc7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; calls a traced function. The return values of calls are never supplied, only the call and its arguments.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; llama a una funci&amp;oacute;n rastreada. Los valores de retorno de las llamadas nunca se proporcionan, solo la llamada y sus argumentos.</target>
        </trans-unit>
        <trans-unit id="323d59db6fafd89e5c07401fb7993540b99d690e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits &lt;strong&gt;from&lt;/strong&gt; the specified function because of an exception. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with an &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; sale &lt;strong&gt;de&lt;/strong&gt; la funci&amp;oacute;n especificada debido a una excepci&amp;oacute;n. Este mensaje de rastreo se env&amp;iacute;a si se establece una &lt;code&gt;call&lt;/code&gt; bandera y la funci&amp;oacute;n tiene una especificaci&amp;oacute;n de coincidencia con una acci&amp;oacute;n de rastreo de &lt;code&gt;exception_trace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc3d1426688af7f3815ab8ffb8557afa8cf69def" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; exits with reason &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; sale con raz&amp;oacute;n &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6a10c0e2595bc6a45b793e623dbb1d7e74c4840d" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled out. The process was running in function {M, F, Arity}. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; est&amp;aacute; programado. El proceso se estaba ejecutando en la funci&amp;oacute;n {M, F, Arity}. En algunas raras ocasiones, no se puede determinar la funci&amp;oacute;n actual, entonces el &amp;uacute;ltimo elemento es &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="885b32e12e9f0ba67537b4a0349bf3e528dd7008" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is scheduled to run. The process runs in function &lt;code&gt;{M, F, Arity}&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Cu&amp;aacute;ndo est&amp;aacute; programado que se ejecute &lt;code&gt;Pid&lt;/code&gt; . El proceso se ejecuta en la funci&amp;oacute;n &lt;code&gt;{M, F, Arity}&lt;/code&gt; . En algunas raras ocasiones, no se puede determinar la funci&amp;oacute;n actual, entonces el &amp;uacute;ltimo elemento es &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2579456f2ac4547aa51c7500a5011980e64fed27" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; is spawned by process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; es generado por el proceso &lt;code&gt;Pid2&lt;/code&gt; con la llamada de funci&amp;oacute;n especificada como punto de entrada.</target>
        </trans-unit>
        <trans-unit id="ee6d840360c675d28fb4189ea75bcf500ea96744" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; links to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; se vincula a un proceso &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0d2e5fb513b27fbae59d57a8659f003a4ecf83" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; opens a new port &lt;code&gt;Port&lt;/code&gt; with the running &lt;code&gt;Driver&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; abre un nuevo puerto &lt;code&gt;Port&lt;/code&gt; con el &lt;code&gt;Driver&lt;/code&gt; ejecuci&amp;oacute;n .</target>
        </trans-unit>
        <trans-unit id="14ed889ebc9aca15515c2b45ca1a374fd67cf415" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; removes the link from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; elimina el enlace de un proceso &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5751eed2112a0c8b568fa52ffcbeb3e9cb0f2b8a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;from&lt;/strong&gt; the specified function. This trace message is sent if flag &lt;code&gt;call&lt;/code&gt; is set, and the function has a match specification with a &lt;code&gt;return_trace&lt;/code&gt; or &lt;code&gt;exception_trace&lt;/code&gt; action.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; regresa &lt;strong&gt;de&lt;/strong&gt; la funci&amp;oacute;n especificada. Este mensaje de rastreo se env&amp;iacute;a si se establece una &lt;code&gt;call&lt;/code&gt; bandera y la funci&amp;oacute;n tiene una especificaci&amp;oacute;n de coincidencia con una acci&amp;oacute;n &lt;code&gt;return_trace&lt;/code&gt; o &lt;code&gt;exception_trace&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fcbfdb05819ccf5c6584d296609a8e52d12c64f1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; returns &lt;strong&gt;to&lt;/strong&gt; the specified function. This trace message is sent if both the flags &lt;code&gt;call&lt;/code&gt; and &lt;code&gt;return_to&lt;/code&gt; are set, and the function is set to be traced on &lt;strong&gt;local&lt;/strong&gt; function calls. The message is only sent when returning from a chain of tail recursive function calls, where at least one call generated a &lt;code&gt;call&lt;/code&gt; trace message (that is, the functions match specification matched, and &lt;code&gt;{message, false}&lt;/code&gt; was not an action).</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; vuelve &lt;strong&gt;a&lt;/strong&gt; la funci&amp;oacute;n especificada. Este mensaje de rastreo se env&amp;iacute;a si se establecen tanto las banderas &lt;code&gt;call&lt;/code&gt; como &lt;code&gt;return_to&lt;/code&gt; , y la funci&amp;oacute;n est&amp;aacute; configurada para ser rastreada en llamadas de funciones &lt;strong&gt;locales&lt;/strong&gt; . El mensaje solo se env&amp;iacute;a cuando se regresa de una cadena de llamadas de funci&amp;oacute;n recursivas de cola, donde al menos una llamada gener&amp;oacute; un mensaje de rastreo de &lt;code&gt;call&lt;/code&gt; (es decir, las funciones coinciden con la especificaci&amp;oacute;n y &lt;code&gt;{message, false}&lt;/code&gt; no era una acci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="ba46a646e37ed8b7d35c674ed3b3e32924ba03e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Pid&lt;/code&gt; spawns a new process &lt;code&gt;Pid2&lt;/code&gt; with the specified function call as entry point.</source>
          <target state="translated">Cuando &lt;code&gt;Pid&lt;/code&gt; genera un nuevo proceso &lt;code&gt;Pid2&lt;/code&gt; con la llamada a la funci&amp;oacute;n especificada como punto de entrada.</target>
        </trans-unit>
        <trans-unit id="5cc371b2356f9951c5abbb937169272313d56c71" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets linked to a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;PidPort&lt;/code&gt; se vincula a un proceso &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="972a925137e0ccb08bc5aeffdfecb3782e3bc889" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; registered.</source>
          <target state="translated">Cuando &lt;code&gt;PidPort&lt;/code&gt; obtiene el nombre &lt;code&gt;RegName&lt;/code&gt; registrado.</target>
        </trans-unit>
        <trans-unit id="162e33555c86a661514ef9d4a857ec534b5a22a4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets the name &lt;code&gt;RegName&lt;/code&gt; unregistered. This is done automatically when a registered process or port exits.</source>
          <target state="translated">Cuando &lt;code&gt;PidPort&lt;/code&gt; obtiene el nombre &lt;code&gt;RegName&lt;/code&gt; sin registrar. Esto se hace autom&amp;aacute;ticamente cuando sale un proceso o puerto registrado.</target>
        </trans-unit>
        <trans-unit id="feb1d708bf63c2940ea863c472a540929d8d0a03" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; gets unlinked from a process &lt;code&gt;Pid2&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;PidPort&lt;/code&gt; se desvincula de un proceso, &lt;code&gt;Pid2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96a6470e961b2d5912dd59eb5021ef79f690f562" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; receives message &lt;code&gt;Msg&lt;/code&gt;. If &lt;code&gt;Msg&lt;/code&gt; is set to time-out, a receive statement can have timed out, or the process received a message with the payload &lt;code&gt;timeout&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;PidPort&lt;/code&gt; recibe el mensaje &lt;code&gt;Msg&lt;/code&gt; . Si &lt;code&gt;Msg&lt;/code&gt; se establece en el tiempo de espera, una instrucci&amp;oacute;n de recepci&amp;oacute;n puede haber agotado el tiempo de espera o el proceso recibi&amp;oacute; un mensaje con el &lt;code&gt;timeout&lt;/code&gt; la carga &amp;uacute;til .</target>
        </trans-unit>
        <trans-unit id="e87cde17521c68e2a936fe17936bf5ceeb2c3d14" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;PidPort&lt;/code&gt; env&amp;iacute;a el mensaje &lt;code&gt;Msg&lt;/code&gt; para procesar &lt;code&gt;To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d61e6201a42785b41b69c2b7a25abb9b7fd4f07c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;PidPort&lt;/code&gt; sends message &lt;code&gt;Msg&lt;/code&gt; to the non-existing process &lt;code&gt;To&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;PidPort&lt;/code&gt; env&amp;iacute;a el mensaje &lt;code&gt;Msg&lt;/code&gt; al proceso no existente &lt;code&gt;To&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15233790daaa8247a54c54b5c9b5074f4bf171a9" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; closes with &lt;code&gt;Reason&lt;/code&gt;.</source>
          <target state="translated">Cuando el &lt;code&gt;Port&lt;/code&gt; cierra con &lt;code&gt;Reason&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80787715e672faf25567796cfbe4be1ecff2d7f7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled out. The last command run was &lt;code&gt;Command&lt;/code&gt;. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;. &lt;code&gt;Command&lt;/code&gt; can contain the same commands as &lt;code&gt;in&lt;/code&gt;</source>
          <target state="translated">Cuando el &lt;code&gt;Port&lt;/code&gt; est&amp;aacute; programado. El &amp;uacute;ltimo comando ejecutado fue &lt;code&gt;Command&lt;/code&gt; . En algunas raras ocasiones, no se puede determinar la funci&amp;oacute;n actual, entonces el &amp;uacute;ltimo elemento es &lt;code&gt;0&lt;/code&gt; . &lt;code&gt;Command&lt;/code&gt; puede contener los mismos comandos que &lt;code&gt;in&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="d9ef0bd2183c0bb797164fa66a45ee2bd8c3d2cf" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;Port&lt;/code&gt; is scheduled to run. &lt;code&gt;Command&lt;/code&gt; is the first thing the port will execute, it can however run several commands before being scheduled out. On some rare occasions, the current function cannot be determined, then the last element is &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Cuando el &lt;code&gt;Port&lt;/code&gt; est&amp;aacute; programado para ejecutarse. &lt;code&gt;Command&lt;/code&gt; es lo primero que ejecutar&amp;aacute; el puerto, sin embargo, puede ejecutar varios comandos antes de ser programado. En algunas raras ocasiones, no se puede determinar la funci&amp;oacute;n actual, entonces el &amp;uacute;ltimo elemento es &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="763a821ae322d45ebff08f1076aa08fd98dc4152" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;accept&lt;/code&gt; is issued, the values of the listening socket options are inherited. No such application variable is therefore needed for &lt;code&gt;accept&lt;/code&gt;.</source>
          <target state="translated">Cuando se emite &lt;code&gt;accept&lt;/code&gt; , se heredan los valores de las opciones de socket de escucha. Por lo tanto, no se necesita tal variable de aplicaci&amp;oacute;n para &lt;code&gt;accept&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1a84fa4a21d8059b923917b5063cf77ca5a084f4" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/2,3&lt;/code&gt; is used with wrap logs, the returned continuation might not be valid in the next call to &lt;code&gt;chunk()&lt;/code&gt;. This is because the log can wrap and delete the file into which the continuation points. To prevent this, the log can be blocked during the search.</source>
          <target state="translated">Cuando se usa &lt;code&gt;chunk/2,3&lt;/code&gt; con registros de ajuste, la continuaci&amp;oacute;n devuelta podr&amp;iacute;a no ser v&amp;aacute;lida en la siguiente llamada a &lt;code&gt;chunk()&lt;/code&gt; . Esto se debe a que el registro puede ajustar y eliminar el archivo en el que apunta la continuaci&amp;oacute;n. Para evitar esto, el registro se puede bloquear durante la b&amp;uacute;squeda.</target>
        </trans-unit>
        <trans-unit id="b575a5e86459930acb9d9587352f01c78bb4d138" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 64 kilobyte chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that the end of the file is reached.</source>
          <target state="translated">Cuando se llama a &lt;code&gt;chunk/3&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; controla el n&amp;uacute;mero m&amp;aacute;ximo de t&amp;eacute;rminos que se leen del registro en cada fragmento. El valor predeterminado es &lt;code&gt;infinity&lt;/code&gt; , lo que significa que se leen todos los t&amp;eacute;rminos contenidos en el fragmento de 64 kilobytes. Si se devuelven menos de &lt;code&gt;N&lt;/code&gt; t&amp;eacute;rminos, esto no significa necesariamente que se haya alcanzado el final del archivo.</target>
        </trans-unit>
        <trans-unit id="ea8aa73939a31b631da4d86b608b56e6f570baca" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;chunk/3&lt;/code&gt; is called, &lt;code&gt;N&lt;/code&gt; controls the maximum number of terms that are read from the log in each chunk. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which means that all the terms contained in the 8K chunk are read. If less than &lt;code&gt;N&lt;/code&gt; terms are returned, this does not necessarily mean that end of file is reached.</source>
          <target state="translated">Cuando se llama a &lt;code&gt;chunk/3&lt;/code&gt; , &lt;code&gt;N&lt;/code&gt; controla el n&amp;uacute;mero m&amp;aacute;ximo de t&amp;eacute;rminos que se leen del registro en cada fragmento. El valor predeterminado es &lt;code&gt;infinity&lt;/code&gt; , lo que significa que se leen todos los t&amp;eacute;rminos contenidos en el fragmento de 8K. Si se devuelven menos de &lt;code&gt;N&lt;/code&gt; t&amp;eacute;rminos, esto no significa necesariamente que se haya alcanzado el final del archivo.</target>
        </trans-unit>
        <trans-unit id="e99ff5779b67a6b782f749fc2ebb582cf983dde5" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;erlang:system_flag(scheduler_bind_type, How)&lt;/code&gt; is called, an asynchronous signal is sent to all schedulers online, causing them to try to bind or unbind as requested.</source>
          <target state="translated">Cuando se &lt;code&gt;erlang:system_flag(scheduler_bind_type, How)&lt;/code&gt; , se env&amp;iacute;a una se&amp;ntilde;al asincr&amp;oacute;nica a todos los programadores en l&amp;iacute;nea, lo que hace que intenten vincularse o desvincularse seg&amp;uacute;n lo solicitado.</target>
        </trans-unit>
        <trans-unit id="0f7f20feb6d8e86e2be7182c1146591f5b2c10e6" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;float/1&lt;/code&gt; is used in an expression in a guard, such as '&lt;code&gt;float(A) == 4.0&lt;/code&gt;', it converts a number as described earlier.</source>
          <target state="translated">Cuando se usa &lt;code&gt;float/1&lt;/code&gt; en una expresi&amp;oacute;n en una guarda, como ' &lt;code&gt;float(A) == 4.0&lt;/code&gt; ', convierte un n&amp;uacute;mero como se describi&amp;oacute; anteriormente.</target>
        </trans-unit>
        <trans-unit id="71613609aa61c62cf20cbe58dfba008b2ab16c3a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;format_temps&lt;/code&gt; is called the first time, &lt;code&gt;City&lt;/code&gt; gets the value &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; and &lt;code&gt;Rest&lt;/code&gt; is the rest of the list. So the function &lt;code&gt;print_temp(convert_to_celsius({moscow,{c,-10}}))&lt;/code&gt; is called.</source>
          <target state="translated">Cuando se llama a &lt;code&gt;format_temps&lt;/code&gt; por primera vez, &lt;code&gt;City&lt;/code&gt; obtiene el valor &lt;code&gt;{moscow,{c,-10}}&lt;/code&gt; y &lt;code&gt;Rest&lt;/code&gt; es el resto de la lista. Entonces se &lt;code&gt;print_temp(convert_to_celsius({moscow,{c,-10}}))&lt;/code&gt; la funci&amp;oacute;n print_temp (convert_to_celsius ({moscow, {c, -10}})) .</target>
        </trans-unit>
        <trans-unit id="6ea5dd9189f31e33453342ece25ebb3fb4b7a42c" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;gen_statem&lt;/code&gt; receives a process message it is converted into an event and the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is called with the event as two arguments: type and content. When the &lt;code&gt;&lt;a href=&quot;#state%20callback&quot;&gt;&lt;strong&gt;state callback&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; has processed the event it returns to &lt;code&gt;gen_statem&lt;/code&gt; which does a &lt;strong&gt;state transition&lt;/strong&gt;. If this &lt;strong&gt;state transition&lt;/strong&gt; is to a different state, that is: &lt;code&gt;NextState =/= State&lt;/code&gt;, it is a &lt;strong&gt;state change&lt;/strong&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5bb83110e8f27a779d6f37f6cb1a70e2e21776a8" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;handle_connect/2,3&lt;/code&gt; is triggered by an explicit call to &lt;code&gt;megaco:connect/4,5&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;handle_connect/2,3&lt;/code&gt; se activa mediante una llamada expl&amp;iacute;cita a &lt;code&gt;megaco:connect/4,5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="672bdd7739faf4a0068adc26b9d59100e10bc739" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;httpd&lt;/code&gt; is shut down, it tries to execute &lt;code&gt;remove/1&lt;/code&gt; in each Erlang web server callback module. The programmer can use this function to clean up resources created in the store function.</source>
          <target state="translated">Cuando se apaga &lt;code&gt;httpd&lt;/code&gt; , intenta ejecutar &lt;code&gt;remove/1&lt;/code&gt; en cada m&amp;oacute;dulo de devoluci&amp;oacute;n de llamada del servidor web Erlang. El programador puede utilizar esta funci&amp;oacute;n para limpiar los recursos creados en la funci&amp;oacute;n de tienda.</target>
        </trans-unit>
        <trans-unit id="953b87367aa11437e3573afbb763a3b56ad3bf87" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;logger_std_h&lt;/code&gt; logs to a file, it reads the file information of the log file prior to each write operation. This is to make sure the file still exists and has the same inode as when it was opened. This implies some performance loss, but ensures that no log events are lost in the case when the file has been removed or renamed by an external actor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e34c8eb52d34fbd9a9b37c654c599a9d1639ad3b" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;make install&lt;/code&gt; has finished, change directory into &lt;code&gt;$DESTDIR&lt;/code&gt;, package the system, move it to the target machine, and unpack it. Note that the installation will only be working on the target machine at the location determined by &lt;code&gt;configure&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;make install&lt;/code&gt; ha terminado, el cambio en el directorio &lt;code&gt;$DESTDIR&lt;/code&gt; , empaquetar el sistema, moverlo a la m&amp;aacute;quina de destino, y descomprimirlo. Tenga en cuenta que la instalaci&amp;oacute;n solo funcionar&amp;aacute; en la m&amp;aacute;quina de destino en la ubicaci&amp;oacute;n determinada por &lt;code&gt;configure&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="795f2365565d6c490bd1604318e59071672d2fc1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;save&lt;/code&gt; is specified a new connection will be negotiated and saved for later reuse. The session ID can be fetched with &lt;code&gt;&lt;a href=&quot;#connection_information-2&quot;&gt;connection_information/2&lt;/a&gt;&lt;/code&gt; and used with the client option &lt;code&gt;&lt;a href=&quot;#type-client_reuse_session&quot;&gt;reuse_session&lt;/a&gt;&lt;/code&gt; The boolean value true specifies that if possible, automatized session reuse will be performed. If a new session is created, and is unique in regard to previous stored sessions, it will be saved for possible later reuse. Since OTP-21.3</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6458c29bc8527ea3593b744f1b95db5d14bc00a1" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;schema_location&lt;/code&gt; is set to &lt;code&gt;opt_disc&lt;/code&gt;, the function &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/3&lt;/a&gt;&lt;/code&gt; can be used to change the storage type of the schema. This is illustrated as follows:</source>
          <target state="translated">Cuando &lt;code&gt;schema_location&lt;/code&gt; se establece en &lt;code&gt;opt_disc&lt;/code&gt; , la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#change_table_copy_type-3&quot;&gt;mnesia:change_table_copy_type/3&lt;/a&gt;&lt;/code&gt; se puede utilizar para cambiar el tipo de almacenamiento del esquema. Esto se ilustra como sigue:</target>
        </trans-unit>
        <trans-unit id="8f7039593357562dd4f3df83c986379cb1c6cf4e" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;sys:get_status/1,2&lt;/code&gt; is called, &lt;code&gt;gen_event&lt;/code&gt; ensures that its return value contains &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="translated">Cuando se llama a &lt;code&gt;sys:get_status/1,2&lt;/code&gt; , &lt;code&gt;gen_event&lt;/code&gt; asegura que su valor de retorno contenga &lt;code&gt;Status&lt;/code&gt; en lugar del t&amp;eacute;rmino de estado del controlador de eventos.</target>
        </trans-unit>
        <trans-unit id="5455489a72db154806b1402161102765e042f513" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_ack_maxcount&lt;/code&gt; number of ack's has been received.</source>
          <target state="translated">Cuando se ha recibido &lt;code&gt;trans_ack_maxcount&lt;/code&gt; el n&amp;uacute;mero de ack.</target>
        </trans-unit>
        <trans-unit id="2d6f023a935d787f78f929b26ccb79c057c7e544" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_req_maxcount&lt;/code&gt; number of requests's has been received.</source>
          <target state="translated">Cuando se ha recibido &lt;code&gt;trans_req_maxcount&lt;/code&gt; n&amp;uacute;mero de solicitudes.</target>
        </trans-unit>
        <trans-unit id="4691b74e02fcb2a43c31be2ce08725b89f8c00a7" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trans_timer&lt;/code&gt; expires.</source>
          <target state="translated">Cuando expira &lt;code&gt;trans_timer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f62e8b515ecdd9f175ebeef24a151629f33f401" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;true&lt;/code&gt;, exit signals arriving to a process are converted to &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; messages, which can be received as ordinary messages. If &lt;code&gt;trap_exit&lt;/code&gt; is set to &lt;code&gt;false&lt;/code&gt;, the process exits if it receives an exit signal other than &lt;code&gt;normal&lt;/code&gt; and the exit signal is propagated to its linked processes. Application processes are normally not to trap exits.</source>
          <target state="translated">Cuando &lt;code&gt;trap_exit&lt;/code&gt; se establece en &lt;code&gt;true&lt;/code&gt; , las se&amp;ntilde;ales de salida que llegan a un proceso se convierten en mensajes &lt;code&gt;{'EXIT', From, Reason}&lt;/code&gt; , que se pueden recibir como mensajes normales. Si &lt;code&gt;trap_exit&lt;/code&gt; se establece en &lt;code&gt;false&lt;/code&gt; , el proceso sale si recibe una se&amp;ntilde;al de salida diferente a la &lt;code&gt;normal&lt;/code&gt; y la se&amp;ntilde;al de salida se propaga a sus procesos vinculados. Los procesos de solicitud normalmente no son para atrapar salidas.</target>
        </trans-unit>
        <trans-unit id="fb45a25cdcc4004483ae5e0296eb6055f647d85a" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;true&lt;/code&gt;, sent multicast packets are looped back to the local sockets.</source>
          <target state="translated">Cuando es &lt;code&gt;true&lt;/code&gt; , los paquetes de multidifusi&amp;oacute;n enviados se devuelven a los sockets locales.</target>
        </trans-unit>
        <trans-unit id="10db437ea36ac965fd403789d69242cf01a29208" translate="yes" xml:space="preserve">
          <source>When &lt;code&gt;{active, true}&lt;/code&gt;, data is delivered on the form &lt;code&gt;port&lt;/code&gt; : &lt;code&gt;{S, {data, [H1,..Hsz | Data]}}&lt;/code&gt; or &lt;code&gt;term&lt;/code&gt; : &lt;code&gt;{tcp, S, [H1..Hsz | Data]}&lt;/code&gt;.</source>
          <target state="translated">Cuando &lt;code&gt;{active, true}&lt;/code&gt; , los datos se entregan en el &lt;code&gt;port&lt;/code&gt; del formulario : &lt;code&gt;{S, {data, [H1,..Hsz | Data]}}&lt;/code&gt; o &lt;code&gt;term&lt;/code&gt; : &lt;code&gt;{tcp, S, [H1..Hsz | Data]}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="50818e5b2ee1eb06b98eca2c46320af1c49650c8" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;ActualReason&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="translated">Cuando el &lt;strong&gt;Reason&lt;/strong&gt; es &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; significa que el proceso net_if no pudo enviar el mensaje. Esto podr&amp;iacute;a suceder por varias razones, es decir, un error de codificaci&amp;oacute;n. &lt;strong&gt;ActualReason&lt;/strong&gt; es el motivo real en este caso.</target>
        </trans-unit>
        <trans-unit id="9f41f432bb6d6b04eaeac809774055cb313c3684" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;Reason&lt;/strong&gt; is &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; it means that the net_if process failed to send the message. This could happen because of any number of reasons, i.e. encoding error. &lt;strong&gt;R&lt;/strong&gt; is the actual reason in this case.</source>
          <target state="translated">Cuando el &lt;strong&gt;Reason&lt;/strong&gt; es &lt;strong&gt;{send_failed, ...}&lt;/strong&gt; significa que el proceso net_if no pudo enviar el mensaje. Esto podr&amp;iacute;a suceder por varias razones, es decir, un error de codificaci&amp;oacute;n. &lt;strong&gt;R&lt;/strong&gt; es la raz&amp;oacute;n real en este caso.</target>
        </trans-unit>
        <trans-unit id="9d855525f98d05d9b1e2a2b3d4a3caa31ede7338" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;scan stop&lt;/strong&gt; marker &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1103&quot;&gt;catches up&lt;/a&gt;&lt;/code&gt; to the &lt;strong&gt;scan start&lt;/strong&gt; marker, the garbage collection is done. At this point we can &lt;code&gt;&lt;a href=&quot;https://github.com/erlang/otp/blob/OTP-18.0/erts/emulator/beam/erl_gc.c#L1206&quot;&gt;deallocate&lt;/a&gt;&lt;/code&gt; the entire &lt;strong&gt;from space&lt;/strong&gt; and therefore reclaim the entire young heap.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8aec189a88e9a30ca27fcd657c83b4b7d31fa73" translate="yes" xml:space="preserve">
          <source>When &lt;strong&gt;var_and_val()&lt;/strong&gt; is &lt;strong&gt;{oid(), value()}&lt;/strong&gt;, the manager makes an educated guess based on the loaded mibs.</source>
          <target state="translated">Cuando &lt;strong&gt;var_and_val ()&lt;/strong&gt; es &lt;strong&gt;{oid (), value ()}&lt;/strong&gt; , el administrador hace una conjetura basada en los mibs cargados.</target>
        </trans-unit>
        <trans-unit id="ccaef80e646aaabd78d92b0630d31df5f39a479a" translate="yes" xml:space="preserve">
          <source>When Cover is stopped, all Cover compiled modules are unloaded.</source>
          <target state="translated">Cuando la Cubierta se detenga,todos los módulos compilados de la Cubierta se descargarán.</target>
        </trans-unit>
        <trans-unit id="ce23e1563e5351f589159eb5b770cd3cbd2e8d8c" translate="yes" xml:space="preserve">
          <source>When Debugger is started in global mode (which is the default, see &lt;code&gt;&lt;a href=&quot;debugger#start-0&quot;&gt;debugger:start/0&lt;/a&gt;&lt;/code&gt;), modules added (or deleted) for interpretation are added (or deleted) on all known Erlang nodes.</source>
          <target state="translated">Cuando el depurador se inicia en modo global (que es el predeterminado, consulte &lt;code&gt;&lt;a href=&quot;debugger#start-0&quot;&gt;debugger:start/0&lt;/a&gt;&lt;/code&gt; ), los m&amp;oacute;dulos agregados (o eliminados) para la interpretaci&amp;oacute;n se agregan (o eliminan) en todos los nodos de Erlang conocidos.</target>
        </trans-unit>
        <trans-unit id="ab8c9662238adfc3364171ed2abae67b6db526e0" translate="yes" xml:space="preserve">
          <source>When EDNS is enabled (resolver option &lt;code&gt;edns&lt;/code&gt; is set to the EDNS version (that is, &lt;code&gt;0&lt;/code&gt; instead of &lt;code&gt;false&lt;/code&gt;), resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; sets the limit. If a name server replies with the TC bit set (truncation), indicating that the answer is incomplete, the query is retried to that name server using TCP. Resolver option &lt;code&gt;udp_payload_size&lt;/code&gt; also sets the advertised size for the maximum allowed reply size, if EDNS is enabled, otherwise the name server uses the limit 512 bytes. If the reply is larger, it gets truncated, forcing a TCP requery.</source>
          <target state="translated">Cuando EDNS est&amp;aacute; habilitado (la opci&amp;oacute;n de resoluci&amp;oacute;n &lt;code&gt;edns&lt;/code&gt; se establece en la versi&amp;oacute;n de EDNS (es decir, &lt;code&gt;0&lt;/code&gt; en lugar de &lt;code&gt;false&lt;/code&gt; ), la opci&amp;oacute;n de resoluci&amp;oacute;n &lt;code&gt;udp_payload_size&lt;/code&gt; establece el l&amp;iacute;mite. Si un servidor de nombres responde con el bit TC establecido (truncamiento), indica que la respuesta es incompleta, la consulta se vuelve a intentar en ese servidor de nombres mediante TCP. La opci&amp;oacute;n de &lt;code&gt;udp_payload_size&lt;/code&gt; tambi&amp;eacute;n establece el tama&amp;ntilde;o anunciado para el tama&amp;ntilde;o m&amp;aacute;ximo de respuesta permitido, si EDNS est&amp;aacute; habilitado; de lo contrario, el servidor de nombres utiliza el l&amp;iacute;mite de 512 bytes. Si la respuesta es mayor, se trunca, lo que obliga a una nueva consulta de TCP.</target>
        </trans-unit>
        <trans-unit id="360f7568d87827777af3aa56a826957938118e43" translate="yes" xml:space="preserve">
          <source>When EUnit traverses the test representation in order to run the tests, the new generator will not be called to produce the next test until the previous test has been executed.</source>
          <target state="translated">Cuando EUnit atraviesa la representación de la prueba para ejecutar las pruebas,el nuevo generador no será llamado para producir la siguiente prueba hasta que la prueba anterior haya sido ejecutada.</target>
        </trans-unit>
        <trans-unit id="f08e2448799430bb11532279edecae41a087b4a7" translate="yes" xml:space="preserve">
          <source>When Erlang is started with &lt;code&gt;-oldshell&lt;/code&gt; or &lt;code&gt;-noshell&lt;/code&gt;, the I/O server for &lt;code&gt;standard_io&lt;/code&gt; is by default set to bytewise encoding, while an interactive shell defaults to what the environment variables says.</source>
          <target state="translated">Cuando Erlang se inicia con &lt;code&gt;-oldshell&lt;/code&gt; o &lt;code&gt;-noshell&lt;/code&gt; , el servidor de E / S para &lt;code&gt;standard_io&lt;/code&gt; est&amp;aacute; configurado de forma predeterminada para la codificaci&amp;oacute;n por bytes, mientras que un shell interactivo toma de forma predeterminada lo que dicen las variables de entorno.</target>
        </trans-unit>
        <trans-unit id="e501fa18494f297571df6ce7eaf406fc86c93dea" translate="yes" xml:space="preserve">
          <source>When Erlang starts up it reads the Kernel variable &lt;code&gt;inetrc&lt;/code&gt;, which, if defined, is to specify the location and name of a user configuration file. Example:</source>
          <target state="translated">Cuando Erlang se inicia, lee la variable del n&amp;uacute;cleo &lt;code&gt;inetrc&lt;/code&gt; , que, si se define, es para especificar la ubicaci&amp;oacute;n y el nombre de un archivo de configuraci&amp;oacute;n de usuario. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="128caf28b58716150fb0bb58c207dbe8dd83fd4e" translate="yes" xml:space="preserve">
          <source>When Erlang was designed, it was assumed that the wall clock time in the system showed a monotonic time moving forward at exactly the same pace as the definition of time. This more or less meant that an atomic clock (or better time source) was expected to be attached to your hardware and that the hardware was then expected to be locked away from any human tinkering forever. While this can be a compelling thought, it is simply never the case.</source>
          <target state="translated">Cuando se diseñó Erlang,se asumió que el tiempo del reloj de pared en el sistema mostraba un tiempo monótono que avanzaba exactamente al mismo ritmo que la definición del tiempo.Esto significaba más o menos que se esperaba que un reloj atómico (o una mejor fuente de tiempo)estuviera conectado a su hardware y que el hardware se esperaba entonces que estuviera bloqueado para siempre de cualquier juguete humano.Mientras que esto puede ser un pensamiento convincente,simplemente nunca es el caso.</target>
        </trans-unit>
        <trans-unit id="50fa1c320969db01352828d7fe383abc4a1895e0" translate="yes" xml:space="preserve">
          <source>When Erlang/OTP is started, the system searches for a file named &lt;code&gt;.erlang&lt;/code&gt; in the user's home directory.</source>
          <target state="translated">Cuando se inicia Erlang / OTP, el sistema busca un archivo llamado &lt;code&gt;.erlang&lt;/code&gt; en el directorio de inicio del usuario.</target>
        </trans-unit>
        <trans-unit id="f3f71d6c7e7a2c0c5ada3244d6eb663b401f9b01" translate="yes" xml:space="preserve">
          <source>When PER is used, there is a significant difference in the encoding scheme between &lt;code&gt;OCTET STRING&lt;/code&gt;s and other strings. The constraints specified for a type are especially important for PER, where they affect the encoding.</source>
          <target state="translated">Cuando se usa PER, existe una diferencia significativa en el esquema de codificaci&amp;oacute;n entre &lt;code&gt;OCTET STRING&lt;/code&gt; sy otras cadenas. Las restricciones especificadas para un tipo son especialmente importantes para PER, donde afectan la codificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="13cc1571f4013c1520479bbd9847106a62e42744" translate="yes" xml:space="preserve">
          <source>When SSH tries to log in to a host, the ssh protocol communicates the user name (as a string) and a password. The remote ssh server checks that there is such a user defined and that the provided password is acceptable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b03f5d92803d36900a526928289b233412ad464" translate="yes" xml:space="preserve">
          <source>When SSL/TLS performs certificate path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; it should also perform CRL validation checks. To enable the CRL checks the application needs access to CRLs. A database of CRLs can be set up in many different ways. This module provides the behavior of the API needed to integrate an arbitrary CRL cache with the erlang ssl application. It is also used by the application itself to provide a simple default implementation of a CRL cache.</source>
          <target state="translated">Cuando SSL / TLS realiza la validaci&amp;oacute;n de la ruta del certificado de acuerdo con &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; , tambi&amp;eacute;n debe realizar comprobaciones de validaci&amp;oacute;n de CRL. Para habilitar las comprobaciones de CRL, la aplicaci&amp;oacute;n necesita acceder a las CRL. Una base de datos de CRL se puede configurar de muchas formas diferentes. Este m&amp;oacute;dulo proporciona el comportamiento de la API necesaria para integrar una cach&amp;eacute; de CRL arbitraria con la aplicaci&amp;oacute;n erlang ssl. Tambi&amp;eacute;n lo utiliza la propia aplicaci&amp;oacute;n para proporcionar una implementaci&amp;oacute;n predeterminada simple de una cach&amp;eacute; de CRL.</target>
        </trans-unit>
        <trans-unit id="08b49640b8a294ef0b72bc78a8a9c77ce925f456" translate="yes" xml:space="preserve">
          <source>When TLS performs certificate path validation according to &lt;code&gt;&lt;a href=&quot;http://www.ietf.org/rfc/rfc5280.txt&quot;&gt;RFC 5280 &lt;/a&gt;&lt;/code&gt; it should also perform CRL validation checks. To enable the CRL checks the application needs access to CRLs. A database of CRLs can be set up in many different ways. This module provides the behavior of the API needed to integrate an arbitrary CRL cache with the erlang ssl application. It is also used by the application itself to provide a simple default implementation of a CRL cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36c5c5eb2f1ebd77389873e38508774785cdb365" translate="yes" xml:space="preserve">
          <source>When a (complex) term is deleted (using &lt;code&gt;&lt;a href=&quot;#erase-1&quot;&gt;erase/1&lt;/a&gt;&lt;/code&gt;) or replaced by another (using &lt;code&gt;&lt;a href=&quot;#put-2&quot;&gt;put/2&lt;/a&gt;&lt;/code&gt;), a global garbage collection is initiated. It works like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d27327d683c2a19be0af9413a3ffb06c50231cc3" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;Addr&lt;/code&gt; is not specified i.e by using only a &lt;code&gt;Domain&lt;/code&gt; atom, the host's name is resolved to find the IP address, and the value of &lt;code&gt;port&lt;/code&gt; is used.</source>
          <target state="translated">Cuando un &lt;code&gt;Addr&lt;/code&gt; no se especifica es decir, utilizando s&amp;oacute;lo un &lt;code&gt;Domain&lt;/code&gt; &amp;aacute;tomo, nombre del host es resuelto para encontrar la direcci&amp;oacute;n IP, y el valor del &lt;code&gt;port&lt;/code&gt; se utiliza.</target>
        </trans-unit>
        <trans-unit id="2dab5adc2b60fbe4714b50e24055b1753a3e2460" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;CHOICE&lt;/code&gt; contains an extension marker and the decoder detects an unknown alternative of the &lt;code&gt;CHOICE&lt;/code&gt;, the value is represented as follows:</source>
          <target state="translated">Cuando un &lt;code&gt;CHOICE&lt;/code&gt; contiene un marcador de extensi&amp;oacute;n y el decodificador detecta una alternativa desconocida del &lt;code&gt;CHOICE&lt;/code&gt; , el valor se representa de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="8d1d4d39dc5b42bbde592ff2e91a12f51026609b" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;SEQUENCE&lt;/code&gt; or &lt;code&gt;SET&lt;/code&gt; contains an extension marker and extension components as the following, the type can get more components in newer versions of the ASN.1 spec:</source>
          <target state="translated">Cuando una &lt;code&gt;SEQUENCE&lt;/code&gt; o &lt;code&gt;SET&lt;/code&gt; contiene un marcador de extensi&amp;oacute;n y componentes de extensi&amp;oacute;n como los siguientes, el tipo puede obtener m&amp;aacute;s componentes en versiones m&amp;aacute;s recientes de la especificaci&amp;oacute;n ASN.1:</target>
        </trans-unit>
        <trans-unit id="6259eac0d0652866c8be2d5774deb52d326c9816" translate="yes" xml:space="preserve">
          <source>When a &lt;code&gt;process&lt;/code&gt; or &lt;code&gt;port&lt;/code&gt; monitor is triggered, a &lt;code&gt;'DOWN'&lt;/code&gt; message is sent that has the following pattern:</source>
          <target state="translated">Cuando se activa un monitor de &lt;code&gt;process&lt;/code&gt; o &lt;code&gt;port&lt;/code&gt; , se env&amp;iacute;a un mensaje &lt;code&gt;'DOWN'&lt;/code&gt; que tiene el siguiente patr&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="dabb982d5bde66066a06ee6a787d40663b30219a" translate="yes" xml:space="preserve">
          <source>When a NETCONF server receives a &lt;code&gt;close-session&lt;/code&gt; request, it gracefully closes the session. The server releases any locks and resources associated with the session and gracefully closes any associated connections. Any NETCONF requests received after a &lt;code&gt;close-session&lt;/code&gt; request are ignored.</source>
          <target state="translated">Cuando un servidor NETCONF recibe una solicitud de &lt;code&gt;close-session&lt;/code&gt; , cierra correctamente la sesi&amp;oacute;n. El servidor libera todos los bloqueos y recursos asociados con la sesi&amp;oacute;n y cierra con elegancia cualquier conexi&amp;oacute;n asociada. Se ignoran todas las solicitudes NETCONF recibidas despu&amp;eacute;s de una solicitud de &lt;code&gt;close-session&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6aef919ab5c9d7ca0a1f781798e898aede6e2d15" translate="yes" xml:space="preserve">
          <source>When a NIF library is built, information about the NIF API version is compiled into the library. When a NIF library is loaded, the runtime system verifies that the library is of a compatible version. &lt;code&gt;erl_nif.h&lt;/code&gt; defines the following:</source>
          <target state="translated">Cuando se crea una biblioteca NIF, la informaci&amp;oacute;n sobre la versi&amp;oacute;n de la API NIF se compila en la biblioteca. Cuando se carga una biblioteca NIF, el sistema de ejecuci&amp;oacute;n verifica que la biblioteca sea de una versi&amp;oacute;n compatible. &lt;code&gt;erl_nif.h&lt;/code&gt; define lo siguiente:</target>
        </trans-unit>
        <trans-unit id="d3817362b42209950451aa710a170de1764e4ae2" translate="yes" xml:space="preserve">
          <source>When a TLS/DTLS socket is in active mode (the default), data from the socket is delivered to the owner of the socket in the form of messages as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="618a279b6e67c1feb5bfb9caf244cc07fcd0fd4b" translate="yes" xml:space="preserve">
          <source>When a capturing subpattern is repeated, the value captured is the substring that matched the final iteration. For example, after</source>
          <target state="translated">Cuando se repite un subpatrón de captura,el valor capturado es la subcadena que coincidió con la iteración final.Por ejemplo,después de</target>
        </trans-unit>
        <trans-unit id="8960db8cbc60fbad0889c97d7dc8dbc2ed095e75" translate="yes" xml:space="preserve">
          <source>When a carrier becomes empty, it will be deallocated. Carrier deallocation is always done by the owner that allocated the carrier. By doing this, the underlying functionality of allocating and deallocating carriers can remain simple and doesn't have to bother about multiple threads. In a NUMA system we will also not mix carriers originating from multiple NUMA nodes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b2f68f94834caf1f15745e0db7a8ee40b6d20cae" translate="yes" xml:space="preserve">
          <source>When a carrier is being removed from a pool, we mark it with a thread progress value that needs to be reached before we are allowed to modify the &lt;code&gt;next&lt;/code&gt; and &lt;code&gt;prev&lt;/code&gt; fields. That is, until we reach this thread progress we are not allowed to insert the carrier into the pool again, and we are not allowed to deallocate the carrier. This ensures that threads inspecting the pool always will be able to traverse the pool and reach valid elements. Once we have reached the thread progress value that the carrier was tagged with, we know that no threads may have references to it via the pool.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b986ca062e5cbe2bd3af1261b097a64c49e1e7a8" translate="yes" xml:space="preserve">
          <source>When a carrier is deallocated a free memory segment will be created inside the corresponding area, unless the carrier was at the very top (in &lt;code&gt;sa&lt;/code&gt;) or bottom (in &lt;code&gt;sua&lt;/code&gt;) in which case the area will just shrink down or up.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080131fee2275102365afd60d1617478b9f8e7d4" translate="yes" xml:space="preserve">
          <source>When a carrier is empty, i.e. contains only one large free block, it is deallocated. Since multi-block carriers can contain both allocated blocks and free blocks at the same time, an allocator instance might be stuck with a large amount of poorly utilized carriers if the memory load decreases. After a peak in memory usage it is expected that not all memory can be returned since the blocks still allocated are likely to be dispersed over multiple carriers. Such poorly utilized carriers can usually be reused if the memory load increases again. However, since each scheduler thread manages its own set of allocator instances, and memory load is not necessarily correlated to CPU load, we might get into a situation where there are lots of poorly utilized multi-block carriers on some allocator instances while we need to allocate new multi-block carriers on other allocator instances. In scenarios like this, the demand for multi-block carriers in the system might increase at the same time as the actual memory demand in the system has decreased which is both unwanted and quite unexpected for the end user.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a65b284abe74e6a02c174667276a95aa7be67345" translate="yes" xml:space="preserve">
          <source>When a client checks a server certificate there are a number of checks available like checks that the certificate is not revoked, not forged or not out-of-date.</source>
          <target state="translated">Cuando un cliente comprueba un certificado de servidor,hay una serie de comprobaciones disponibles,como la comprobación de que el certificado no está revocado,no está falsificado o no está desactualizado.</target>
        </trans-unit>
        <trans-unit id="3aadc5d6a9fff7e5e64260bfe5a84b55671b941b" translate="yes" xml:space="preserve">
          <source>When a combining transaction writes with &quot;dirty_reads&quot;, that is, the functions &lt;code&gt;dirty_match_object&lt;/code&gt;, &lt;code&gt;dirty_read&lt;/code&gt;, &lt;code&gt;dirty_index_read&lt;/code&gt;, &lt;code&gt;dirty_select&lt;/code&gt;, and so on.</source>
          <target state="translated">Cuando una transacci&amp;oacute;n de combinaci&amp;oacute;n escribe con &quot;dirty_reads&quot;, es decir, las funciones &lt;code&gt;dirty_match_object&lt;/code&gt; , &lt;code&gt;dirty_read&lt;/code&gt; , &lt;code&gt;dirty_index_read&lt;/code&gt; , &lt;code&gt;dirty_select&lt;/code&gt; , etc.</target>
        </trans-unit>
        <trans-unit id="1a2b39b4ebe51a72b88123d3bad51bb926bc1540" translate="yes" xml:space="preserve">
          <source>When a complete sequence of valid events has been received, the result is returned as a list of letters.</source>
          <target state="translated">Cuando se ha recibido una secuencia completa de eventos válidos,el resultado se devuelve como una lista de letras.</target>
        </trans-unit>
        <trans-unit id="3ab3080f29934aab21a3904dcbbbf54ca9667260" translate="yes" xml:space="preserve">
          <source>When a configuration function fails (that is, terminates unexpectedly), the test cases depending on the configuration function are skipped automatically by &lt;code&gt;Common Test&lt;/code&gt;. The status of the test cases is then &quot;auto-skipped&quot;. Test cases are also &quot;auto-skipped&quot; by &lt;code&gt;Common Test&lt;/code&gt; if the required configuration data is unavailable at runtime.</source>
          <target state="translated">Cuando falla una funci&amp;oacute;n de configuraci&amp;oacute;n (es decir, termina inesperadamente), &lt;code&gt;Common Test&lt;/code&gt; omite autom&amp;aacute;ticamente los casos de prueba que dependen de la funci&amp;oacute;n de configuraci&amp;oacute;n . El estado de los casos de prueba se &quot;omite autom&amp;aacute;ticamente&quot;. &lt;code&gt;Common Test&lt;/code&gt; tambi&amp;eacute;n &quot;omite autom&amp;aacute;ticamente&quot; los casos de prueba si los datos de configuraci&amp;oacute;n requeridos no est&amp;aacute;n disponibles en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a5b5a638207ad9c6b58bc05153489fdb31694f0d" translate="yes" xml:space="preserve">
          <source>When a configuration variable name is used as reference to the data specifying the connection, the handle returned as a result of opening the connection must be used in all subsequent calls (also for closing the connection). Repeated calls to the open function with the same variable name as reference results in multiple connections being opened. This can be useful, for example, if a test case needs to open multiple connections to the same server on the target node (using the same configuration data for each connection).</source>
          <target state="translated">Cuando se utiliza un nombre de variable de configuración como referencia a los datos que especifican la conexión,el mango devuelto como resultado de la apertura de la conexión debe utilizarse en todas las llamadas posteriores (también para cerrar la conexión).Las llamadas repetidas a la función de apertura con el mismo nombre de la variable como referencia dan como resultado la apertura de múltiples conexiones.Esto puede ser útil,por ejemplo,si un caso de prueba necesita abrir múltiples conexiones al mismo servidor en el nodo de destino (utilizando los mismos datos de configuración para cada conexión).</target>
        </trans-unit>
        <trans-unit id="e5c050aa3f173823d46ef7ab459ceb273e450e96" translate="yes" xml:space="preserve">
          <source>When a connection is accepted, a new context for the accepted connection should be created and &lt;code&gt;*ctx&lt;/code&gt; should be updated to point to the new context for the accepted connection. When called &lt;code&gt;addr&lt;/code&gt; points to an uninitialized address structure of lenght &lt;code&gt;*len&lt;/code&gt;. Uppon return this callback should have updated this structure with information about the client address. &lt;code&gt;*len&lt;/code&gt; should be updated to reflect the size of &lt;code&gt;*addr&lt;/code&gt; updated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a40f1ad1022ce7c7ff4a72defc83b1ece3312d0f" translate="yes" xml:space="preserve">
          <source>When a correct code has been given, the door is unlocked and the following tuple is returned from &lt;code&gt;locked/2&lt;/code&gt;:</source>
          <target state="translated">Cuando se ha proporcionado un c&amp;oacute;digo correcto, la puerta se desbloquea y se devuelve la siguiente tupla de &lt;code&gt;locked/2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6c237674f28de05213f857e3fa04838ee21db142" translate="yes" xml:space="preserve">
          <source>When a directory is added to the code path and when the entire code path is (re)set, the code server decides which subdirectories in an application that are to be read from the archive and which that are to be read as regular files. If directories are added or removed afterwards, the file access can fail if the code path is not updated (possibly to the same path as before, to trigger the directory resolution update).</source>
          <target state="translated">Cuando se agrega un directorio a la ruta de código y cuando se (re)establece la ruta de código completa,el servidor de código decide qué subdirectorios de una aplicación deben ser leídos desde el archivo y cuáles deben ser leídos como archivos regulares.Si se agregan o eliminan directorios posteriormente,el acceso al archivo puede fallar si la ruta del código no se actualiza (posiblemente a la misma ruta que antes,para activar la actualización de la resolución del directorio).</target>
        </trans-unit>
        <trans-unit id="08512ee349a9c8aac50037692c41425ea5af4861" translate="yes" xml:space="preserve">
          <source>When a disk log is opened in read-write mode, any existing log file is checked for. If there is none, a new empty log is created, otherwise the existing file is opened at the position after the last logged item, and the logging of items starts from there. If the format is &lt;code&gt;internal&lt;/code&gt; and the existing file is not recognized as an internally formatted log, a tuple &lt;code&gt;{error, {not_a_log_file, FileName}}&lt;/code&gt; is returned.</source>
          <target state="translated">Cuando se abre un registro de disco en modo lectura-escritura, se comprueba cualquier archivo de registro existente. Si no hay ninguno, se crea un nuevo registro vac&amp;iacute;o; de lo contrario, el archivo existente se abre en la posici&amp;oacute;n posterior al &amp;uacute;ltimo elemento registrado y el registro de elementos comienza desde all&amp;iacute;. Si el formato es &lt;code&gt;internal&lt;/code&gt; y el archivo existente no se reconoce como un registro formateado internamente, se devuelve una tupla &lt;code&gt;{error, {not_a_log_file, FileName}}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dd89c709c241e9c3808c6d9ef3bbf0c663231656" translate="yes" xml:space="preserve">
          <source>When a distributed node is started it registers itself in the EPMD. The message &lt;code&gt;ALIVE2_REQ&lt;/code&gt; described below is sent from the node to the EPMD. The response from the EPMD is &lt;code&gt;ALIVE2_RESP&lt;/code&gt;.</source>
          <target state="translated">Cuando se inicia un nodo distribuido, se registra en la EPMD. El mensaje &lt;code&gt;ALIVE2_REQ&lt;/code&gt; que se describe a continuaci&amp;oacute;n se env&amp;iacute;a desde el nodo a la EPMD. La respuesta de la EPMD es &lt;code&gt;ALIVE2_RESP&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e19066774d0292834ea4eb6c62d86023ec350ebc" translate="yes" xml:space="preserve">
          <source>When a distributed node is started it registers itself in the EPMD. The message &lt;code&gt;ALIVE2_REQ&lt;/code&gt; described below is sent from the node to the EPMD. The response from the EPMD is &lt;code&gt;ALIVE2_X_RESP&lt;/code&gt; (or &lt;code&gt;ALIVE2_RESP&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a52fed0cfcde5066a985fe2bdb039481aa8004a" translate="yes" xml:space="preserve">
          <source>When a driver creates a monitor for a process, a &lt;code&gt;ErlDrvMonitor&lt;/code&gt; is filled in. This is an opaque data type that can be assigned to, but not compared without using the supplied compare function (that is, it behaves like a struct).</source>
          <target state="translated">Cuando un controlador crea un monitor para un proceso, se completa un &lt;code&gt;ErlDrvMonitor&lt;/code&gt; . Este es un tipo de datos opaco que puede asignarse, pero no compararse, sin usar la funci&amp;oacute;n de comparaci&amp;oacute;n proporcionada (es decir, se comporta como una estructura).</target>
        </trans-unit>
        <trans-unit id="7d91cc2fa6325a0dec9adb1ac103e1c55c09f52b" translate="yes" xml:space="preserve">
          <source>When a driver is loaded it is executed in the context of the emulator, shares the same memory and the same thread. This means that all operations in the driver must be non-blocking, and that any crash in the driver brings the whole emulator down. In short, be careful.</source>
          <target state="translated">Cuando se carga un controlador se ejecuta en el contexto del emulador,comparte la misma memoria y el mismo hilo.Esto significa que todas las operaciones en el conductor deben ser no-bloqueantes,y que cualquier choque en el conductor hace caer todo el emulador.En resumen,ten cuidado.</target>
        </trans-unit>
        <trans-unit id="23ef058276dd33859a9cf8494fcadec228e0e9ee" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for input. This callback is called when the emulator detects input on a file descriptor that the driver has marked for monitoring by using the interface &lt;code&gt;driver_select&lt;/code&gt;. The mechanism of driver select makes it possible to read non-blocking from file descriptors by calling &lt;code&gt;driver_select&lt;/code&gt; when reading is needed, and then do the reading in this callback (when reading is possible). The typical scenario is that &lt;code&gt;driver_select&lt;/code&gt; is called when an Erlang process orders a read operation, and that this routine sends the answer when data is available on the file descriptor.</source>
          <target state="translated">Cuando se indica la entrada de un descriptor de archivo. Esta devoluci&amp;oacute;n de llamada se llama cuando el emulador detecta una entrada en un descriptor de archivo que el controlador ha marcado para monitorear mediante la interfaz &lt;code&gt;driver_select&lt;/code&gt; . El mecanismo de selecci&amp;oacute;n de controlador hace posible leer sin bloqueo de descriptores de archivo llamando a &lt;code&gt;driver_select&lt;/code&gt; cuando se necesita leer, y luego hacer la lectura en esta devoluci&amp;oacute;n de llamada (cuando la lectura es posible). El escenario t&amp;iacute;pico es que se llama a &lt;code&gt;driver_select&lt;/code&gt; cuando un proceso Erlang ordena una operaci&amp;oacute;n de lectura y que esta rutina env&amp;iacute;a la respuesta cuando hay datos disponibles en el descriptor de archivo.</target>
        </trans-unit>
        <trans-unit id="a679df0f77926839147106039935be1d682ca28a" translate="yes" xml:space="preserve">
          <source>When a file descriptor is signaled for output. This callback is called in a similar way as the previous, but when writing to a file descriptor is possible. The usual scenario is that Erlang orders writing on a file descriptor and that the driver calls &lt;code&gt;driver_select&lt;/code&gt;. When the descriptor is ready for output, this callback is called and the driver can try to send the output. Queuing can be involved in such operations, and there are convenient queue routines available to the driver writer to use.</source>
          <target state="translated">Cuando se indica un descriptor de archivo para su salida. Esta devoluci&amp;oacute;n de llamada se llama de forma similar a la anterior, pero cuando es posible escribir en un descriptor de archivo. El escenario habitual es que Erlang ordena escribir en un descriptor de archivo y que el controlador llame a &lt;code&gt;driver_select&lt;/code&gt; . Cuando el descriptor est&amp;aacute; listo para la salida, se llama a esta devoluci&amp;oacute;n de llamada y el controlador puede intentar enviar la salida. La puesta en cola puede estar involucrada en tales operaciones, y existen pr&amp;aacute;cticas rutinas de cola disponibles para que las utilice el escritor del controlador.</target>
        </trans-unit>
        <trans-unit id="cff5a25a671ee65d3e016e0e72ebcef87ec1e190" translate="yes" xml:space="preserve">
          <source>When a file is saved the name in the &lt;code&gt;-module().&lt;/code&gt; line is checked against the file name. Should they mismatch Emacs can change the module specifier so that it matches the file name. By default, the user is asked before the change is performed.</source>
          <target state="translated">Cuando se guarda un archivo, el nombre en el &lt;code&gt;-module().&lt;/code&gt; La l&amp;iacute;nea se compara con el nombre del archivo. En caso de que no coincidan, Emacs puede cambiar el especificador del m&amp;oacute;dulo para que coincida con el nombre del archivo. De forma predeterminada, se pregunta al usuario antes de realizar el cambio.</target>
        </trans-unit>
        <trans-unit id="3f363e70739be22c64648901764e5ee5e3346b81" translate="yes" xml:space="preserve">
          <source>When a filter includes the &lt;code&gt;no&lt;/code&gt; atom, it excludes the reports that match that filter.</source>
          <target state="translated">Cuando un filtro incluye el &lt;code&gt;no&lt;/code&gt; &amp;aacute;tomo, excluye los informes que coinciden con ese filtro.</target>
        </trans-unit>
        <trans-unit id="e330f04c70993b25abdd0ad93b28b509d5140f2d" translate="yes" xml:space="preserve">
          <source>When a foreign allocator instance abandons a carrier back into the pool, it will also pass it back to its &lt;strong&gt;owner&lt;/strong&gt; using the delayed dealloc queue. When doing this it will set the HOMECOMING bit flag to mark it as &quot;enqueued&quot;. The owner will later clear the HOMECOMING bit when the carrier is dequeued. This mechanism prevents a carrier from being enqueued again before it has been dequeued.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b080dca26694157c4bd883a5fe6d59a076fa4f" translate="yes" xml:space="preserve">
          <source>When a function &lt;code&gt;m:f/N&lt;/code&gt; is called, first the code for the function is located. If the function cannot be found, an &lt;code&gt;undef&lt;/code&gt; runtime error occurs. Notice that the function must be exported to be visible outside the module it is defined in.</source>
          <target state="translated">Cuando se llama a una funci&amp;oacute;n &lt;code&gt;m:f/N&lt;/code&gt; , primero se localiza el c&amp;oacute;digo para la funci&amp;oacute;n. Si no se puede encontrar la funci&amp;oacute;n, se produce un error de tiempo de ejecuci&amp;oacute;n &lt;code&gt;undef&lt;/code&gt; . Tenga en cuenta que la funci&amp;oacute;n debe exportarse para que sea visible fuera del m&amp;oacute;dulo en el que est&amp;aacute; definida.</target>
        </trans-unit>
        <trans-unit id="74208e09de14be7d14103a45ed652bc9fc053707" translate="yes" xml:space="preserve">
          <source>When a function defined elsewhere is used as a fun, it can be referred to as &lt;code&gt;Function/Arity&lt;/code&gt; (remember that &lt;code&gt;Arity&lt;/code&gt; = number of arguments). So in the &lt;code&gt;map&lt;/code&gt;-call &lt;code&gt;lists:map(fun convert_to_c/1, List)&lt;/code&gt; is written. As shown, &lt;code&gt;convert_list_to_c&lt;/code&gt; becomes much shorter and easier to understand.</source>
          <target state="translated">Cuando una funci&amp;oacute;n definida en otro lugar se usa como una diversi&amp;oacute;n, se puede denominar &lt;code&gt;Function/Arity&lt;/code&gt; (recuerde que &lt;code&gt;Arity&lt;/code&gt; = n&amp;uacute;mero de argumentos). Entonces en el &lt;code&gt;map&lt;/code&gt; a -call &lt;code&gt;lists:map(fun convert_to_c/1, List)&lt;/code&gt; est&amp;aacute; escrito. Como se muestra, &lt;code&gt;convert_list_to_c&lt;/code&gt; se vuelve mucho m&amp;aacute;s corto y m&amp;aacute;s f&amp;aacute;cil de entender.</target>
        </trans-unit>
        <trans-unit id="74001e8b9e330c78c97c92b41f6d0fc8532d215e" translate="yes" xml:space="preserve">
          <source>When a function is inlined, the original function is kept if it is exported (either by an explicit export or if the option &lt;code&gt;export_all&lt;/code&gt; was given) or if not all calls to the function are inlined.</source>
          <target state="translated">Cuando una funci&amp;oacute;n est&amp;aacute; en l&amp;iacute;nea, la funci&amp;oacute;n original se mantiene si se exporta (ya sea mediante una exportaci&amp;oacute;n expl&amp;iacute;cita o si se proporcion&amp;oacute; la opci&amp;oacute;n &lt;code&gt;export_all&lt;/code&gt; ) o si no todas las llamadas a la funci&amp;oacute;n est&amp;aacute;n en l&amp;iacute;nea.</target>
        </trans-unit>
        <trans-unit id="f80601e5580fc09c93533fc9ff760c5048491df1" translate="yes" xml:space="preserve">
          <source>When a functional module has been changed, for example, if a new function has been added or a bug has been corrected, simple code replacement is sufficient, for example:</source>
          <target state="translated">Cuando se ha cambiado un módulo funcional,por ejemplo,si se ha añadido una nueva función o se ha corregido un error,basta con una simple sustitución de código,por ejemplo:</target>
        </trans-unit>
        <trans-unit id="177c42f544b61e4f56d8eebb388d0ad5082dd374" translate="yes" xml:space="preserve">
          <source>When a grammar rule is used by the parser to parse (part of) the input string as a grammatical phrase, the associated code is evaluated, and the value of the last expression becomes the value of the parsed phrase. This value may be used by the parser later to build structures that are values of higher phrases of which the current phrase is a part. The values initially associated with terminal category phrases, i.e. input tokens, are the token tuples themselves.</source>
          <target state="translated">Cuando el analizador utiliza una regla gramatical para analizar (parte de)la cadena de entrada como una frase gramatical,se evalúa el código asociado y el valor de la última expresión se convierte en el valor de la frase analizada.Este valor puede ser utilizado por el analizador posteriormente para construir estructuras que son valores de frases superiores de las que la frase actual forma parte.Los valores inicialmente asociados a las frases de categoría terminal,es decir,las fichas de entrada,son las propias fichas.</target>
        </trans-unit>
        <trans-unit id="b974112391a6bf5f0b5186bac330512807e3d96c" translate="yes" xml:space="preserve">
          <source>When a group of subtrees (as e.g., the argument list of an &lt;code&gt;application&lt;/code&gt; node) is at the specified depth, and there are two or more subtrees in the group, these will be collectively replaced by &lt;code&gt;Node&lt;/code&gt; even if they are leaf nodes. Groups of subtrees that are above the specified depth will be limited in size, as if each subsequent tree in the group were one level deeper than the previous. E.g., if &lt;code&gt;Tree&lt;/code&gt; represents a list of integers &quot;&lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt;&quot;, the result of &lt;code&gt;limit(Tree, 5)&lt;/code&gt; will represent &lt;code&gt;[1, 2, 3, 4, ...]&lt;/code&gt;.</source>
          <target state="translated">Cuando un grupo de sub&amp;aacute;rboles (como por ejemplo, la lista de argumentos de un nodo de &lt;code&gt;application&lt;/code&gt; ) est&amp;aacute; a la profundidad especificada, y hay dos o m&amp;aacute;s sub&amp;aacute;rboles en el grupo, estos ser&amp;aacute;n reemplazados colectivamente por &lt;code&gt;Node&lt;/code&gt; incluso si son nodos hoja. Los grupos de sub&amp;aacute;rboles que est&amp;aacute;n por encima de la profundidad especificada tendr&amp;aacute;n un tama&amp;ntilde;o limitado, como si cada &amp;aacute;rbol subsiguiente del grupo fuera un nivel m&amp;aacute;s profundo que el anterior. Por ejemplo, si &lt;code&gt;Tree&lt;/code&gt; representa una lista de n&amp;uacute;meros enteros &quot; &lt;code&gt;[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]&lt;/code&gt; &quot;, el resultado de &lt;code&gt;limit(Tree, 5)&lt;/code&gt; representar&amp;aacute; &lt;code&gt;[1, 2, 3, 4, ...]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="546a7cd5ad3598834756b341e22241b28b75ab4c" translate="yes" xml:space="preserve">
          <source>When a halt log has reached its maximum size, all attempts to log more items are rejected. Defaults to &lt;code&gt;infinity&lt;/code&gt;, which for halt implies that there is no maximum size.</source>
          <target state="translated">Cuando un registro de detenci&amp;oacute;n ha alcanzado su tama&amp;ntilde;o m&amp;aacute;ximo, se rechazan todos los intentos de registrar m&amp;aacute;s elementos. El valor predeterminado es &lt;code&gt;infinity&lt;/code&gt; , lo que para detener implica que no hay un tama&amp;ntilde;o m&amp;aacute;ximo.</target>
        </trans-unit>
        <trans-unit id="c1c98f68dda1e070c7b87a7615f91fa26ae95480" translate="yes" xml:space="preserve">
          <source>When a handler is added, by for example a call to &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt; logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt;, Logger first calls &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,Config1}&lt;/code&gt;, Logger writes &lt;code&gt;Config1&lt;/code&gt; to the configuration database, and the &lt;code&gt;logger:add_handler/3&lt;/code&gt; call returns. After this, the handler is installed and must be ready to receive log events as calls to &lt;code&gt;HModule:log/2&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0173ad86ffa8dc5a72f7880331dbb41cadacb3d5" translate="yes" xml:space="preserve">
          <source>When a handler is added, by for example a call to &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt;, Logger first calls &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt;. If this function returns &lt;code&gt;{ok,Config1}&lt;/code&gt;, Logger writes &lt;code&gt;Config1&lt;/code&gt; to the configuration database, and the &lt;code&gt;logger:add_handler/3&lt;/code&gt; call returns. After this, the handler is installed and must be ready to receive log events as calls to &lt;code&gt;HModule:log/2&lt;/code&gt;.</source>
          <target state="translated">Cuando se agrega un controlador, por ejemplo, mediante una llamada a &lt;code&gt;&lt;a href=&quot;logger#add_handler-3&quot;&gt;logger:add_handler(Id, HModule, Config)&lt;/a&gt;&lt;/code&gt; , Logger llama primero a &lt;code&gt;HModule:adding_handler(Config)&lt;/code&gt; . Si esta funci&amp;oacute;n devuelve &lt;code&gt;{ok,Config1}&lt;/code&gt; , Logger escribe &lt;code&gt;Config1&lt;/code&gt; en la base de datos de configuraci&amp;oacute;n y la llamada &lt;code&gt;logger:add_handler/3&lt;/code&gt; regresa. Despu&amp;eacute;s de esto, el controlador se instala y debe estar listo para recibir eventos de registro como llamadas a &lt;code&gt;HModule:log/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b3fa26b8c4473c5e6353f135f20edbe40b9dc4c" translate="yes" xml:space="preserve">
          <source>When a line ending is defined as a single character, dot never matches that character. When the two-character sequence CRLF is used, dot does not match CR if it is immediately followed by LF, otherwise it matches all characters (including isolated CRs and LFs). When any Unicode line endings are recognized, dot does not match CR, LF, or any of the other line-ending characters.</source>
          <target state="translated">Cuando el final de una línea se define como un solo carácter,el punto nunca coincide con ese carácter.Cuando se utiliza la secuencia de dos caracteres CRLF,el punto no coincide con el CR si va seguido inmediatamente por el LF,de lo contrario coincide con todos los caracteres (incluyendo los CR y LF aislados).Cuando se reconoce cualquier terminación de línea Unicode,el punto no coincide con CR,LF o cualquiera de los otros caracteres de terminación de línea.</target>
        </trans-unit>
        <trans-unit id="c40d296ef828ecaf94ab88122caa6be54ba75b8f" translate="yes" xml:space="preserve">
          <source>When a list of binaries is specified, it denotes a set of alternative binaries to search for. For example, if &lt;code&gt;[&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;]&lt;/code&gt; is specified as &lt;code&gt;Pattern&lt;/code&gt;, this means either &lt;code&gt;&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;&lt;/code&gt;&quot;. The pattern is a set of alternatives; when only a single binary is specified, the set has only one element. The order of alternatives in a pattern is not significant.</source>
          <target state="translated">Cuando se especifica una lista de binarios, denota un conjunto de binarios alternativos para buscar. Por ejemplo, si se especifica &lt;code&gt;[&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;,&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;]&lt;/code&gt; como &lt;code&gt;Pattern&lt;/code&gt; , esto significa &lt;code&gt;&amp;lt;&amp;lt;&quot;functional&quot;&amp;gt;&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;lt;&amp;lt;&quot;programming&quot;&amp;gt;&amp;gt;&lt;/code&gt; &quot;. El patr&amp;oacute;n es un conjunto de alternativas, cuando se especifica un solo binario, el conjunto tiene un solo elemento El orden de las alternativas en un patr&amp;oacute;n no es significativo.</target>
        </trans-unit>
        <trans-unit id="02499167e2c00f5483adfce488f74d0d03997387" translate="yes" xml:space="preserve">
          <source>When a log event is issued on a process which has its group leader on a remote node, Logger automatically forwards the log event to the group leader's node. To achieve this, it first sends the log event as an Erlang message from the original client process to the proxy on the local node, and the proxy in turn forwards the event to the proxy on the remote node.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e35511e71a7b0fd611ce8579dd128d7b017ba30" translate="yes" xml:space="preserve">
          <source>When a log file is opened (for appending or created), a time stamp is written to the file. If nothing has been written to the log files for 15 minutes, a record is inserted that says that we are still alive.</source>
          <target state="translated">Cuando se abre un archivo de registro (para añadir o crear),se escribe una marca de tiempo en el archivo.Si no se ha escrito nada en los archivos de registro durante 15 minutos,se inserta un registro que dice que seguimos vivos.</target>
        </trans-unit>
        <trans-unit id="06e4937e775c2f940892fdab2739edda1362aa4d" translate="yes" xml:space="preserve">
          <source>When a log macro is used, Logger also inserts location information:</source>
          <target state="translated">Cuando se utiliza una macro de registro,Logger también inserta información de localización:</target>
        </trans-unit>
        <trans-unit id="aad0f82e057ba4854abcfc52c2eb835c19bd6591" translate="yes" xml:space="preserve">
          <source>When a managed object is referenced in an SNMP operation, the associated &lt;code&gt;{Module, Function, ListOfExtraArguments}&lt;/code&gt; is called. The function is applied to some standard arguments (for example, the operation type) and the extra arguments supplied by the user.</source>
          <target state="translated">Cuando se hace referencia a un objeto gestionado en una operaci&amp;oacute;n SNMP, se llama al &lt;code&gt;{Module, Function, ListOfExtraArguments}&lt;/code&gt; . La funci&amp;oacute;n se aplica a algunos argumentos est&amp;aacute;ndar (por ejemplo, el tipo de operaci&amp;oacute;n) y los argumentos adicionales proporcionados por el usuario.</target>
        </trans-unit>
        <trans-unit id="1bea9285e0f879b126068ba7917e2a2ade25429d" translate="yes" xml:space="preserve">
          <source>When a manager makes a request to the agent, the following illustrates the situation:</source>
          <target state="translated">Cuando un gerente hace una solicitud al agente,lo siguiente ilustra la situación:</target>
        </trans-unit>
        <trans-unit id="092784e3d7c652eb428c18ea5b4a28b1c8500ff7" translate="yes" xml:space="preserve">
          <source>When a match succeeds, the name of the last encountered (*MARK:NAME), (*PRUNE:NAME), or (*THEN:NAME) on the matching path is passed back to the caller as described in section &quot;Extra data for &lt;code&gt;pcre_exec()&lt;/code&gt;&quot; in the &lt;code&gt;pcreapi&lt;/code&gt; documentation. In the following example of &lt;code&gt;pcretest&lt;/code&gt; output, the /K modifier requests the retrieval and outputting of (*MARK) data:</source>
          <target state="translated">Cuando una coincidencia tiene &amp;eacute;xito, el nombre del &amp;uacute;ltimo encontrado (* MARK: NAME), (* PRUNE: NAME) o (* THEN: NAME) en la ruta coincidente se devuelve a la persona que llama como se describe en la secci&amp;oacute;n &quot;Datos adicionales para &lt;code&gt;pcre_exec()&lt;/code&gt; &quot;en la documentaci&amp;oacute;n de &lt;code&gt;pcreapi&lt;/code&gt; . En el siguiente ejemplo de salida &lt;code&gt;pcretest&lt;/code&gt; , el modificador / K solicita la recuperaci&amp;oacute;n y salida de datos (* MARK):</target>
        </trans-unit>
        <trans-unit id="b9ff74687968e879951bb5da792862457fd61b73" translate="yes" xml:space="preserve">
          <source>When a message has been received, it is the caller's responsibility to free the received message &lt;code&gt;emsg.msg&lt;/code&gt; and &lt;code&gt;emsg.to&lt;/code&gt; or &lt;code&gt;emsg.from&lt;/code&gt;, depending on the type of message received.</source>
          <target state="translated">Cuando se recibe un mensaje, es responsabilidad de la persona que llama liberar el mensaje recibido &lt;code&gt;emsg.msg&lt;/code&gt; y &lt;code&gt;emsg.to&lt;/code&gt; o &lt;code&gt;emsg.from&lt;/code&gt; , seg&amp;uacute;n el tipo de mensaje recibido.</target>
        </trans-unit>
        <trans-unit id="40d636d4574d28e3506b270ee7f22e76179c5d66" translate="yes" xml:space="preserve">
          <source>When a message has been received, it is the caller's responsibility to free the received message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ed264eb2a6ed34dada4086d909002ae020169ab" translate="yes" xml:space="preserve">
          <source>When a message is received</source>
          <target state="translated">Cuando se recibe un mensaje</target>
        </trans-unit>
        <trans-unit id="8503be402b4e5542f8b3e1bb21c05d662a4228ff" translate="yes" xml:space="preserve">
          <source>When a message is sent to a process on another Erlang node, it is first encoded to the Erlang External Format before being sent through a TCP/IP socket. The receiving Erlang node decodes the message and distributes it to the correct process.</source>
          <target state="translated">Cuando se envía un mensaje a un proceso en otro nodo Erlang,primero se codifica en el formato externo Erlang antes de enviarlo a través de un zócalo TCP/IP.El nodo Erlang receptor decodifica el mensaje y lo distribuye al proceso correcto.</target>
        </trans-unit>
        <trans-unit id="551c8d852b503a0a48471c3cded481149fff350c" translate="yes" xml:space="preserve">
          <source>When a module is Cover compiled, it is also loaded using the normal code loading mechanism of Erlang. This means that if a Cover compiled module is re-loaded during a Cover session, for example using &lt;code&gt;c(Module)&lt;/code&gt;, it will no longer be Cover compiled.</source>
          <target state="translated">Cuando se compila un m&amp;oacute;dulo Cover, tambi&amp;eacute;n se carga utilizando el mecanismo de carga de c&amp;oacute;digo normal de Erlang. Esto significa que si un m&amp;oacute;dulo compilado de Cover se vuelve a cargar durante una sesi&amp;oacute;n de Cover, por ejemplo, usando &lt;code&gt;c(Module)&lt;/code&gt; , ya no se compilar&amp;aacute; Cover.</target>
        </trans-unit>
        <trans-unit id="072f598e1ef5d76264967426b11622ee9dff185e" translate="yes" xml:space="preserve">
          <source>When a module is to be updated, the release handler finds which processes that are &lt;strong&gt;using&lt;/strong&gt; the module by traversing the supervision tree of each running application and checking all the child specifications:</source>
          <target state="translated">Cuando se va a actualizar un m&amp;oacute;dulo, el administrador de versiones encuentra qu&amp;eacute; procesos est&amp;aacute;n &lt;strong&gt;usando&lt;/strong&gt; el m&amp;oacute;dulo atravesando el &amp;aacute;rbol de supervisi&amp;oacute;n de cada aplicaci&amp;oacute;n en ejecuci&amp;oacute;n y verificando todas las especificaciones secundarias:</target>
        </trans-unit>
        <trans-unit id="9033ba75ed69bf751fa6e5b051720381187f258c" translate="yes" xml:space="preserve">
          <source>When a new OTP release is released it will have an OTP version on the form &lt;code&gt;&amp;lt;Major&amp;gt;.0&lt;/code&gt; where the major OTP version number equals the release number. The major version number is increased one step since the last major version. All other OTP versions with the same major OTP version number are patches on that OTP release.</source>
          <target state="translated">Cuando se lanza una nueva versi&amp;oacute;n de OTP, tendr&amp;aacute; una versi&amp;oacute;n de OTP en el formulario &lt;code&gt;&amp;lt;Major&amp;gt;.0&lt;/code&gt; donde el n&amp;uacute;mero de versi&amp;oacute;n principal de OTP es igual al n&amp;uacute;mero de versi&amp;oacute;n. El n&amp;uacute;mero de la versi&amp;oacute;n principal se incrementa un paso desde la &amp;uacute;ltima versi&amp;oacute;n principal. Todas las dem&amp;aacute;s versiones de OTP con el mismo n&amp;uacute;mero de versi&amp;oacute;n principal de OTP son parches de esa versi&amp;oacute;n de OTP.</target>
        </trans-unit>
        <trans-unit id="cbbb4bde17a561149622c0549faa70bd0cd996df" translate="yes" xml:space="preserve">
          <source>When a new fun is defined in the shell, the value of the fun is printed as &lt;code&gt;Fun#&amp;lt;erl_eval&amp;gt;&lt;/code&gt;:</source>
          <target state="translated">Cuando se define una nueva diversi&amp;oacute;n en el shell, el valor de la diversi&amp;oacute;n se imprime como &lt;code&gt;Fun#&amp;lt;erl_eval&amp;gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="1a3c0fc498149078e34911c14f7a085c035bd806" translate="yes" xml:space="preserve">
          <source>When a new version of a release is installed, the application specifications are automatically updated for all loaded applications.</source>
          <target state="translated">Cuando se instala una nueva versión de un lanzamiento,las especificaciones de la aplicación se actualizan automáticamente para todas las aplicaciones cargadas.</target>
        </trans-unit>
        <trans-unit id="1659bff51ef846577db0a731a65e27f0a6975ea2" translate="yes" xml:space="preserve">
          <source>When a node gets overloaded, it is not possible to issue &lt;code&gt;ttb:p/2&lt;/code&gt; or any command from the &lt;code&gt;ttb:tp/2,3,4&lt;/code&gt; family, as it would lead to inconsistent tracing state (different trace specifications on different nodes).</source>
          <target state="translated">Cuando un nodo se sobrecarga, no es posible emitir &lt;code&gt;ttb:p/2&lt;/code&gt; o cualquier comando de la &lt;code&gt;ttb:tp/2,3,4&lt;/code&gt; , ya que conducir&amp;iacute;a a un estado de rastreo inconsistente (diferentes especificaciones de rastreo en diferentes nodos).</target>
        </trans-unit>
        <trans-unit id="9107c7e3a2ab54b42fe2aa4f90dbf2f0ef91d069" translate="yes" xml:space="preserve">
          <source>When a node tries to connect to another node, the magic cookies are compared. If they do not match, the connected node rejects the connection.</source>
          <target state="translated">Cuando un nodo intenta conectarse a otro nodo,se comparan las galletas mágicas.Si no coinciden,el nodo conectado rechaza la conexión.</target>
        </trans-unit>
        <trans-unit id="91dc7db1911778980d1a145028f56ea061e34c24" translate="yes" xml:space="preserve">
          <source>When a parenthesized subpattern is quantified with a minimum repeat count that is &amp;gt; 1 or with a limited maximum, more memory is required for the compiled pattern, in proportion to the size of the minimum or maximum.</source>
          <target state="translated">Cuando se cuantifica un subpatr&amp;oacute;n entre par&amp;eacute;ntesis con un recuento m&amp;iacute;nimo de repeticiones que es&amp;gt; 1 o con un m&amp;aacute;ximo limitado, se requiere m&amp;aacute;s memoria para el patr&amp;oacute;n compilado, en proporci&amp;oacute;n al tama&amp;ntilde;o del m&amp;iacute;nimo o m&amp;aacute;ximo.</target>
        </trans-unit>
        <trans-unit id="17163b128ce2d3940abc9e287d9eb3065dfe4943" translate="yes" xml:space="preserve">
          <source>When a part in the version number increases, all less significant parts are set to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="translated">Cuando una parte en el n&amp;uacute;mero de versi&amp;oacute;n aumenta, todas las partes menos significativas se establecen en &lt;code&gt;0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="414ecb7481a0e4a00ed77662f92beb6946aca44b" translate="yes" xml:space="preserve">
          <source>When a pattern contains an unlimited repeat inside a subpattern that can itself be repeated an unlimited number of times, the use of an atomic group is the only way to avoid some failing matches taking a long time. The pattern</source>
          <target state="translated">Cuando un patrón contiene una repetición ilimitada dentro de un subpatrón que a su vez puede repetirse un número ilimitado de veces,el uso de un grupo atómico es la única manera de evitar que algunos partidos que fallan lleven mucho tiempo.El patrón</target>
        </trans-unit>
        <trans-unit id="ca6c00c70d6d587bfac21cf87c7afe2ad1eacd1f" translate="yes" xml:space="preserve">
          <source>When a pending message is received, and the &lt;code&gt;long_request_timer&lt;/code&gt; is &lt;strong&gt;not&lt;/strong&gt; &quot;on its final leg&quot;, the timer will be restarted, and, if &lt;code&gt;long_request_resend = true&lt;/code&gt;, the request will be re-sent.</source>
          <target state="translated">Cuando se recibe un mensaje pendiente, y &lt;code&gt;long_request_timer&lt;/code&gt; &lt;strong&gt;no&lt;/strong&gt; est&amp;aacute; &quot;en su tramo final&quot;, el temporizador se reiniciar&amp;aacute; y, si &lt;code&gt;long_request_resend = true&lt;/code&gt; , la solicitud se volver&amp;aacute; a enviar.</target>
        </trans-unit>
        <trans-unit id="f75f183f6a0a339836141c5520bd7b12114dfb3c" translate="yes" xml:space="preserve">
          <source>When a pending message is received, the timer is cancelled and the &lt;code&gt;long_request_timer&lt;/code&gt; is started instead (see below). No resends will be performed from this point (since we now know that the other side has received the request).</source>
          <target state="translated">Cuando se recibe un mensaje pendiente, el temporizador se cancela y en su &lt;code&gt;long_request_timer&lt;/code&gt; se inicia long_request_timer (ver m&amp;aacute;s abajo). No se realizar&amp;aacute;n reenv&amp;iacute;os desde este punto (ya que ahora sabemos que el otro lado ha recibido la solicitud).</target>
        </trans-unit>
        <trans-unit id="caca1f590c83f0cbc730079b288c0a340c8795e2" translate="yes" xml:space="preserve">
          <source>When a pending transaction is sent.</source>
          <target state="translated">Cuando se envía una transacción pendiente.</target>
        </trans-unit>
        <trans-unit id="9309b1e58646bc0004532eb714a09afd5a498a84" translate="yes" xml:space="preserve">
          <source>When a port is closed, either by an Erlang process or by the driver calling one of the &lt;code&gt;driver_failure_XXX&lt;/code&gt; routines. This routine is to clean up everything connected to one particular port. When other callbacks call a &lt;code&gt;driver_failure_XXX&lt;/code&gt; routine, this routine is immediately called. The callback routine issuing the error can make no more use of the data structures for the port, as this routine surely has freed all associated data and closed all file descriptors. If the queue utility available to driver writer is used, this routine is however &lt;strong&gt;not&lt;/strong&gt; called until the queue is empty.</source>
          <target state="translated">Cuando se cierra un puerto, ya sea por un proceso de Erlang o por el controlador que llama a una de las rutinas &lt;code&gt;driver_failure_XXX&lt;/code&gt; . Esta rutina es para limpiar todo lo conectado a un puerto en particular. Cuando otras devoluciones de llamada llaman a una rutina &lt;code&gt;driver_failure_XXX&lt;/code&gt; , esta rutina se llama inmediatamente. La rutina de devoluci&amp;oacute;n de llamada que emite el error no puede hacer m&amp;aacute;s uso de las estructuras de datos para el puerto, ya que esta rutina seguramente ha liberado todos los datos asociados y cerrado todos los descriptores de archivos. Si se utiliza la utilidad de cola disponible para el escritor del controlador, &lt;strong&gt;no se&lt;/strong&gt; llama a esta rutina hasta que la cola est&amp;eacute; vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="cab97407457bdcec73d321074e9305a6e73487c1" translate="yes" xml:space="preserve">
          <source>When a port to the driver is opened (by a &lt;code&gt;open_port&lt;/code&gt; call from Erlang). This routine is to set up internal data structures and return an opaque data entity of the type &lt;code&gt;ErlDrvData&lt;/code&gt;, which is a data type large enough to hold a pointer. The pointer returned by this function is the first argument to all other callbacks concerning this particular port. It is usually called the port handle. The emulator only stores the handle and does never try to interpret it, why it can be virtually anything (anything not larger than a pointer that is) and can point to anything if it is a pointer. Usually this pointer refers to a structure holding information about the particular port, as it does in the example.</source>
          <target state="translated">Cuando se abre un puerto al controlador (mediante una llamada &lt;code&gt;open_port&lt;/code&gt; de Erlang). Esta rutina es para configurar estructuras de datos internas y devolver una entidad de datos opaca del tipo &lt;code&gt;ErlDrvData&lt;/code&gt; , que es un tipo de datos lo suficientemente grande como para contener un puntero. El puntero devuelto por esta funci&amp;oacute;n es el primer argumento para todas las dem&amp;aacute;s devoluciones de llamada relacionadas con este puerto en particular. Por lo general, se denomina identificador de puerto. El emulador solo almacena el identificador y nunca intenta interpretarlo, por qu&amp;eacute; puede ser pr&amp;aacute;cticamente cualquier cosa (cualquier cosa que no sea m&amp;aacute;s grande que un puntero) y puede apuntar a cualquier cosa si es un puntero. Por lo general, este puntero se refiere a una estructura que contiene informaci&amp;oacute;n sobre el puerto en particular, como lo hace en el ejemplo.</target>
        </trans-unit>
        <trans-unit id="cdb990fabcbc7a603b9ecf0828ba52dca55f301b" translate="yes" xml:space="preserve">
          <source>When a process has become runnable, for example due to reception of a message, we need to determine which run queue to enqueue it in. Previously this at least involved locking the run queue that the process currently was assigned to while holding the status lock on the process. Depending on load we sometimes also had to acquire a lock on another run queue in order to be able to determine if it should be migrated to that run queue or not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddcdaeb5fb7f860c3cd40b383288f0699c60e450" translate="yes" xml:space="preserve">
          <source>When a process is killed by &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt; max_heap_size&lt;/a&gt;&lt;/code&gt;, it is killed before the garbage collection is complete and thus no large heap message is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6c6008e1040993823cc1153b9087a328f65c269" translate="yes" xml:space="preserve">
          <source>When a process is killed by &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;max_heap_size&lt;/a&gt;&lt;/code&gt;, it is killed before the garbage collection is complete and thus no large heap message is sent.</source>
          <target state="translated">Cuando &lt;code&gt;&lt;a href=&quot;#process_flag_max_heap_size&quot;&gt;max_heap_size&lt;/a&gt;&lt;/code&gt; mata un proceso , se mata antes de que se complete la recolecci&amp;oacute;n de basura y, por lo tanto, no se env&amp;iacute;a ning&amp;uacute;n mensaje de mont&amp;oacute;n grande.</target>
        </trans-unit>
        <trans-unit id="54c7049ba92415c934270df93ecc40c6ff49a6de" translate="yes" xml:space="preserve">
          <source>When a process is trapping exits, it does not terminate when an exit signal is received. Instead, the signal is transformed into a message &lt;code&gt;{'EXIT',FromPid,Reason}&lt;/code&gt;, which is put into the mailbox of the process, just like a regular message.</source>
          <target state="translated">Cuando un proceso est&amp;aacute; atrapando salidas, no termina cuando se recibe una se&amp;ntilde;al de salida. En cambio, la se&amp;ntilde;al se transforma en un mensaje &lt;code&gt;{'EXIT',FromPid,Reason}&lt;/code&gt; , que se coloca en el buz&amp;oacute;n del proceso, como un mensaje normal.</target>
        </trans-unit>
        <trans-unit id="f894aeebc67996f11b9c7ed1100aea86a6d270d1" translate="yes" xml:space="preserve">
          <source>When a process reaches a breakpoint, only that process is stopped. Other processes are not affected.</source>
          <target state="translated">Cuando un proceso alcanza un punto de ruptura,sólo se detiene ese proceso.Los demás procesos no se ven afectados.</target>
        </trans-unit>
        <trans-unit id="f5fe92890350a386281d849d2308c2fdf32b6229" translate="yes" xml:space="preserve">
          <source>When a process terminates, it always terminates with an &lt;strong&gt;exit reason&lt;/strong&gt;. The reason can be any term.</source>
          <target state="translated">Cuando un proceso termina, siempre termina con un &lt;strong&gt;motivo de salida&lt;/strong&gt; . La raz&amp;oacute;n puede ser cualquier t&amp;eacute;rmino.</target>
        </trans-unit>
        <trans-unit id="653aa417b590e598fcc2e1e4dbaa971f684c769a" translate="yes" xml:space="preserve">
          <source>When a process terminates, it terminates with an &lt;strong&gt;exit reason&lt;/strong&gt; as explained in &lt;code&gt;&lt;a href=&quot;#term&quot;&gt; Process Termination&lt;/a&gt;&lt;/code&gt;. This exit reason is emitted in an &lt;strong&gt;exit signal&lt;/strong&gt; to all linked processes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a33255f3d61f1a754c180593962f65ef23e96913" translate="yes" xml:space="preserve">
          <source>When a process terminates, it terminates with an &lt;strong&gt;exit reason&lt;/strong&gt; as explained in &lt;code&gt;&lt;a href=&quot;#term&quot;&gt;Process Termination&lt;/a&gt;&lt;/code&gt;. This exit reason is emitted in an &lt;strong&gt;exit signal&lt;/strong&gt; to all linked processes.</source>
          <target state="translated">Cuando un proceso termina, termina con un &lt;strong&gt;motivo de salida&lt;/strong&gt; como se explica en &lt;code&gt;&lt;a href=&quot;#term&quot;&gt;Process Termination&lt;/a&gt;&lt;/code&gt; . Este motivo de salida se emite en una &lt;strong&gt;se&amp;ntilde;al de salida&lt;/strong&gt; a todos los procesos vinculados.</target>
        </trans-unit>
        <trans-unit id="1c16084eb81edfdc05085ad57d93b734d5862e39" translate="yes" xml:space="preserve">
          <source>When a process terminates, we mark the process as terminated in the process structure, the counter of number of processes in the table is decreased, and the reference to the process structure is removed by writing a &lt;code&gt;NULL&lt;/code&gt; pointer into the corresponding slot. The scheduler thread performing this then schedule a thread progress later job which will do the final cleanup and deallocate the process structure. The thread progress functionality will make sure that this job will not execute until it is certain that all managed threads have dropped all references to the process structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f438ecf00c74cada65672d3aca9158bdc88f9b65" translate="yes" xml:space="preserve">
          <source>When a process that is started using &lt;code&gt;proc_lib&lt;/code&gt; terminates abnormally (that is, with another exit reason than &lt;code&gt;normal&lt;/code&gt;, &lt;code&gt;shutdown&lt;/code&gt;, or &lt;code&gt;{shutdown,Term}&lt;/code&gt;), a &lt;strong&gt;crash report&lt;/strong&gt; is generated, which is written to terminal by the default logger handler setup by Kernel. For more information about how crash reports were logged prior to Erlang/OTP 21.0, see &lt;code&gt;SASL Error Logging&lt;/code&gt; in the SASL User's Guide.</source>
          <target state="translated">Cuando un proceso que se inicia con &lt;code&gt;proc_lib&lt;/code&gt; finaliza de forma anormal (es decir, con una raz&amp;oacute;n de salida diferente a la &lt;code&gt;normal&lt;/code&gt; , &lt;code&gt;shutdown&lt;/code&gt; o &lt;code&gt;{shutdown,Term}&lt;/code&gt; ), se genera un &lt;strong&gt;informe de&lt;/strong&gt; fallas, que se escribe en la terminal mediante la configuraci&amp;oacute;n predeterminada del controlador de registro por Kernel . Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre c&amp;oacute;mo se registraban los informes de fallos antes de Erlang / OTP 21.0, consulte &lt;code&gt;SASL Error Logging&lt;/code&gt; en la Gu&amp;iacute;a del usuario de SASL.</target>
        </trans-unit>
        <trans-unit id="620e45b56f249c1dbe8f129dc957582dac227989" translate="yes" xml:space="preserve">
          <source>When a program runs in the service context, it must handle the control events that are sent to every program in the system when the interactive user logs off. This is done in different ways for programs running in the console subsystem and programs running as window applications. An application running in the console subsystem (normal for port programs) uses the win32 function &lt;code&gt;SetConsoleCtrlHandler&lt;/code&gt; to register a control handler that returns &lt;code&gt;true&lt;/code&gt; in answer to the &lt;code&gt;CTRL_LOGOFF_EVENT&lt;/code&gt; and &lt;code&gt;CTRL_SHUTDOWN_EVENT&lt;/code&gt; events. Other applications only forward &lt;code&gt;WM_ENDSESSION&lt;/code&gt; and &lt;code&gt;WM_QUERYENDSESSION&lt;/code&gt; to the default window procedure.</source>
          <target state="translated">Cuando un programa se ejecuta en el contexto de servicio, debe manejar los eventos de control que se env&amp;iacute;an a todos los programas del sistema cuando el usuario interactivo cierra la sesi&amp;oacute;n. Esto se hace de diferentes formas para los programas que se ejecutan en el subsistema de la consola y los programas que se ejecutan como aplicaciones de ventana. Una aplicaci&amp;oacute;n que se ejecuta en el subsistema de la consola (normal para los programas de puerto) usa la funci&amp;oacute;n &lt;code&gt;SetConsoleCtrlHandler&lt;/code&gt; para registrar un controlador de control que devuelve &lt;code&gt;true&lt;/code&gt; en respuesta a los eventos &lt;code&gt;CTRL_LOGOFF_EVENT&lt;/code&gt; y &lt;code&gt;CTRL_SHUTDOWN_EVENT&lt;/code&gt; . Otras aplicaciones solo reenv&amp;iacute;an &lt;code&gt;WM_ENDSESSION&lt;/code&gt; y &lt;code&gt;WM_QUERYENDSESSION&lt;/code&gt; al procedimiento de ventana predeterminado.</target>
        </trans-unit>
        <trans-unit id="19ffb1b5dfb2cc8d3c94f0461fc310cb105f6b53" translate="yes" xml:space="preserve">
          <source>When a rekeying is done, both the timer and the byte counter are restarted. Defaults to one hour and one GByte.</source>
          <target state="translated">Cuando se hace un cambio de clave,tanto el temporizador como el contador de bytes se reinician.Por defecto es una hora y un GByte.</target>
        </trans-unit>
        <trans-unit id="160df15be10c112ef08e1b12460eb364b392a9a7" translate="yes" xml:space="preserve">
          <source>When a reply &lt;code&gt;Reply&lt;/code&gt; is received from the &lt;code&gt;gen_server&lt;/code&gt; process at a node &lt;code&gt;Node&lt;/code&gt;, &lt;code&gt;{Node,Reply}&lt;/code&gt; is added to &lt;code&gt;Replies&lt;/code&gt;. &lt;code&gt;Reply&lt;/code&gt; is defined in the return value of &lt;code&gt;Module:handle_call/3&lt;/code&gt;.</source>
          <target state="translated">Cuando se recibe una respuesta &lt;code&gt;Reply&lt;/code&gt; del proceso &lt;code&gt;gen_server&lt;/code&gt; en un nodo &lt;code&gt;Node&lt;/code&gt; , se agrega &lt;code&gt;{Node,Reply}&lt;/code&gt; a &lt;code&gt;Replies&lt;/code&gt; . &lt;code&gt;Reply&lt;/code&gt; se define en el valor de retorno del &lt;code&gt;Module:handle_call/3&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3612568b6d1bd1adf395a8924394d4f1cda79d" translate="yes" xml:space="preserve">
          <source>When a reply transaction is sent.</source>
          <target state="translated">Cuando se envía una transacción de respuesta.</target>
        </trans-unit>
        <trans-unit id="6b9676d76432236d4be5a23bf4ca85a4c81230e6" translate="yes" xml:space="preserve">
          <source>When a request is received, some info related to the reply is store internally (e.g. the binary of the reply). This info will live until either an ack is received or this timer expires. For instance, if the same request is received again (e.g. a request with the same transaction id), the (stored) reply will be (re-) sent automatically by megaco.</source>
          <target state="translated">Cuando se recibe una solicitud,se almacena internamente alguna información relacionada con la respuesta (por ejemplo,el binario de la respuesta).Esta información vivirá hasta que se reciba una respuesta o hasta que este temporizador expire.Por ejemplo,si se vuelve a recibir la misma solicitud (por ejemplo,una solicitud con el mismo id de transacción),la respuesta (almacenada)será (re)enviada automáticamente por megaco.</target>
        </trans-unit>
        <trans-unit id="b6b06f9b88824f92a821ddd40390c63201a38782" translate="yes" xml:space="preserve">
          <source>When a request is sent using the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call/3&lt;/a&gt;&lt;/code&gt; function, a proxy process is started to handle all replies. When the reply has been received and delivered to the user, the proxy process continue to exist for as long as this option specifies. Any received messages, is passed on to the user via the &lt;code&gt;&lt;a href=&quot;megaco_user#handle_unexpected_trans&quot;&gt;handle_unexpected_trans&lt;/a&gt;&lt;/code&gt; callback function.</source>
          <target state="translated">Cuando se env&amp;iacute;a una solicitud utilizando la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call/3&lt;/a&gt;&lt;/code&gt; , se inicia un proceso de proxy para manejar todas las respuestas. Cuando la respuesta ha sido recibida y entregada al usuario, el proceso de proxy contin&amp;uacute;a existiendo mientras esta opci&amp;oacute;n lo especifique. Cualquier mensaje recibido se transmite al usuario a trav&amp;eacute;s de la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;&lt;a href=&quot;megaco_user#handle_unexpected_trans&quot;&gt;handle_unexpected_trans&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c88f71ef842c681d045f4cae79da80397386486a" translate="yes" xml:space="preserve">
          <source>When a run-time error occurs, that is an exception of class &lt;code&gt;error&lt;/code&gt;. The exit reason is a tuple &lt;code&gt;{Reason,Stack}&lt;/code&gt;, where &lt;code&gt;Reason&lt;/code&gt; is a term indicating the type of error:</source>
          <target state="translated">Cuando se produce un error en tiempo de ejecuci&amp;oacute;n, es una excepci&amp;oacute;n al &lt;code&gt;error&lt;/code&gt; de clase . El motivo de salida es una tupla &lt;code&gt;{Reason,Stack}&lt;/code&gt; , donde &lt;code&gt;Reason&lt;/code&gt; es un t&amp;eacute;rmino que indica el tipo de error:</target>
        </trans-unit>
        <trans-unit id="25b12f8bd1c57b6ce9840c0a7b9fe58cbedb898d" translate="yes" xml:space="preserve">
          <source>When a run-time error or generated error occurs in Erlang, execution for the process that evaluated the erroneous expression is stopped. This is referred to as a &lt;strong&gt;failure&lt;/strong&gt;, that execution or evaluation &lt;strong&gt;fails&lt;/strong&gt;, or that the process &lt;strong&gt;fails&lt;/strong&gt;, &lt;strong&gt;terminates&lt;/strong&gt;, or &lt;strong&gt;exits&lt;/strong&gt;. Notice that a process can terminate/exit for other reasons than a failure.</source>
          <target state="translated">Cuando ocurre un error en tiempo de ejecuci&amp;oacute;n o un error generado en Erlang, se detiene la ejecuci&amp;oacute;n del proceso que evalu&amp;oacute; la expresi&amp;oacute;n err&amp;oacute;nea. Esto se conoce como &lt;strong&gt;falla&lt;/strong&gt; , que la ejecuci&amp;oacute;n o evaluaci&amp;oacute;n &lt;strong&gt;falla&lt;/strong&gt; , o que el proceso &lt;strong&gt;falla&lt;/strong&gt; , &lt;strong&gt;termina&lt;/strong&gt; o &lt;strong&gt;sale&lt;/strong&gt; . Tenga en cuenta que un proceso puede terminar / salir por otras razones que no sean una falla.</target>
        </trans-unit>
        <trans-unit id="fc42ebfd4ba19de1bfcb638ee30764a1aea0ba3e" translate="yes" xml:space="preserve">
          <source>When a send event and corresponding receive event do not both correspond to ordinary Erlang messages, the &lt;code&gt;Message&lt;/code&gt; part of the trace messages may not be identical. This since all information not necessarily are available when generating the trace messages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6222adda532a7ba95811b3f47ed6b592bce7369e" translate="yes" xml:space="preserve">
          <source>When a socket in &lt;code&gt;{active, N}&lt;/code&gt; mode (see &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; for details), transitions to passive (&lt;code&gt;{active, false}&lt;/code&gt;) mode, the controlling process is notified by a message of the following form:</source>
          <target state="translated">Cuando un conector en modo &lt;code&gt;{active, N}&lt;/code&gt; (ver &lt;code&gt;&lt;a href=&quot;inet#setopts-2&quot;&gt;inet:setopts/2&lt;/a&gt;&lt;/code&gt; para m&amp;aacute;s detalles), pasa al modo pasivo ( &lt;code&gt;{active, false}&lt;/code&gt; ), el proceso de control es notificado por un mensaje de la siguiente forma:</target>
        </trans-unit>
        <trans-unit id="32c8173f4ed70b1d0dd242e1d68441ff570b2c43" translate="yes" xml:space="preserve">
          <source>When a socket is created (with &lt;code&gt;&lt;a href=&quot;#open-2&quot;&gt;open&lt;/a&gt;&lt;/code&gt;), it has no address assigned to it. &lt;code&gt;bind&lt;/code&gt; assigns the address specified by the &lt;code&gt;Addr&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20d80a95245c078756343c02b99f486003551e30" translate="yes" xml:space="preserve">
          <source>When a specific instruction has a &lt;code&gt;d&lt;/code&gt; operand, early during execution of the instruction, a pointer will be initialized to point to the X or Y register in question.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ad380e3a94ebd517a8a93bc527d1a2a8c42ac9d" translate="yes" xml:space="preserve">
          <source>When a sticky write lock is acquired, all nodes are informed which node is locked. Then, sticky lock requests from the same node are performed as a local operation without any communication with other nodes. The sticky lock lingers on the node even after the transaction ends. For details, see the User's Guide.</source>
          <target state="translated">Cuando se adquiere un bloqueo de escritura pegajosa,todos los nodos son informados de qué nodo está bloqueado.Entonces,las solicitudes de bloqueo de escritura adhesiva del mismo nodo se realizan como una operación local sin ninguna comunicación con otros nodos.El sticky lock permanece en el nodo incluso después de que la transacción termina.Para más detalles,véase la Guía del usuario.</target>
        </trans-unit>
        <trans-unit id="f8a9afc8539f723b3d906fa063814442e45d9210" translate="yes" xml:space="preserve">
          <source>When a table is SNMP ordered, modifications are more expensive than usual, O(logN). Also, more memory is used.</source>
          <target state="translated">Cuando se ordena una tabla SNMP,las modificaciones son más caras de lo habitual,O(logN).Además,se utiliza más memoria.</target>
        </trans-unit>
        <trans-unit id="e32c49ff2c55c4db480cbc70d03e1794493e4e31" translate="yes" xml:space="preserve">
          <source>When a table is fixed, a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls are guaranteed to succeed even if keys are removed during the traversal. The keys for objects inserted or deleted during a traversal may or may not be returned by &lt;code&gt;next/2&lt;/code&gt; depending on the ordering of keys within the table and if the key exists at the time &lt;code&gt;next/2&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09de174e5f27981b5d536ae7d587e5f775467043" translate="yes" xml:space="preserve">
          <source>When a table is fixed, a sequence of &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; calls are guaranteed to succeed, and each object in the table is returned only once, even if objects are removed or inserted during the traversal. The keys for new objects inserted during the traversal &lt;strong&gt;can&lt;/strong&gt; be returned by &lt;code&gt;next/2&lt;/code&gt; (it depends on the internal ordering of the keys).</source>
          <target state="translated">Cuando una tabla es fija, se garantiza el &amp;eacute;xito de una secuencia de llamadas &lt;code&gt;&lt;a href=&quot;#first-1&quot;&gt;first/1&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#next-2&quot;&gt;next/2&lt;/a&gt;&lt;/code&gt; , y cada objeto de la tabla se devuelve solo una vez, incluso si los objetos se eliminan o insertan durante el recorrido. Las claves para los nuevos objetos insertados durante el recorrido &lt;strong&gt;se&lt;/strong&gt; pueden devolver mediante &lt;code&gt;next/2&lt;/code&gt; (depende del orden interno de las claves).</target>
        </trans-unit>
        <trans-unit id="f25502d9a8f67791267ea14f5c70c734251d290a" translate="yes" xml:space="preserve">
          <source>When a target name is used for referencing the configuration data (that specifies the connection to be opened), the same name can be used as connection identity in all subsequent calls related to the connection (also for closing it). Only one open connection per target name is possible. If you attempt to open a new connection using a name already associated with an open connection, &lt;code&gt;Common Test&lt;/code&gt; returns the already existing handle so the previously opened connection is used. This feature makes it possible to call the function for opening a particular connection whenever useful. An action like this does not necessarily open any new connections unless it is required (which could be the case if, for example, the previous connection has been closed unexpectedly by the server). Using named connections also removes the need to pass handle references around in the suite for these connections.</source>
          <target state="translated">Cuando se utiliza un nombre de destino para hacer referencia a los datos de configuraci&amp;oacute;n (que especifica la conexi&amp;oacute;n que se abrir&amp;aacute;), el mismo nombre se puede utilizar como identidad de conexi&amp;oacute;n en todas las llamadas posteriores relacionadas con la conexi&amp;oacute;n (tambi&amp;eacute;n para cerrarla). Solo es posible una conexi&amp;oacute;n abierta por nombre de destino. Si intenta abrir una nueva conexi&amp;oacute;n con un nombre ya asociado con una conexi&amp;oacute;n abierta, &lt;code&gt;Common Test&lt;/code&gt; devuelve el identificador ya existente, por lo que se utiliza la conexi&amp;oacute;n abierta anteriormente. Esta caracter&amp;iacute;stica permite llamar a la funci&amp;oacute;n para abrir una conexi&amp;oacute;n en particular siempre que sea &amp;uacute;til. Una acci&amp;oacute;n como esta no abre necesariamente nuevas conexiones a menos que sea necesario (lo que podr&amp;iacute;a ser el caso si, por ejemplo, el servidor ha cerrado inesperadamente la conexi&amp;oacute;n anterior). El uso de conexiones con nombre tambi&amp;eacute;n elimina la necesidad de pasar referencias de identificador en la suite para estas conexiones.</target>
        </trans-unit>
        <trans-unit id="8b832ad499cefe25ddc82f36d870e896057644d6" translate="yes" xml:space="preserve">
          <source>When a term is passed as the initial process arguments in the &lt;code&gt;spawn&lt;/code&gt; call</source>
          <target state="translated">Cuando se pasa un t&amp;eacute;rmino como argumentos del proceso inicial en la llamada de &lt;code&gt;spawn&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="6e389307b8d59483ef3d7e87b6dfe90a060b042c" translate="yes" xml:space="preserve">
          <source>When a term is sent to another process</source>
          <target state="translated">Cuando un término es enviado a otro proceso</target>
        </trans-unit>
        <trans-unit id="b733aebb93dce74a8914341750d479f7d8a549ed" translate="yes" xml:space="preserve">
          <source>When a term is stored in an Ets table</source>
          <target state="translated">Cuando un término se almacena en una tabla de Ets</target>
        </trans-unit>
        <trans-unit id="0c7ebdcd78a12cc7bd8bd97eb29bacb32f39549b" translate="yes" xml:space="preserve">
          <source>When a test case group is repeated, the configuration functions &lt;code&gt;init_per_group/2&lt;/code&gt; and &lt;code&gt;end_per_group/2&lt;/code&gt; are also always called with each repetition.</source>
          <target state="translated">Cuando se repite un grupo de casos de prueba, las funciones de configuraci&amp;oacute;n &lt;code&gt;init_per_group/2&lt;/code&gt; y &lt;code&gt;end_per_group/2&lt;/code&gt; tambi&amp;eacute;n se llaman siempre con cada repetici&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2be9bace113be2bd43525f396f001fb603a47ce4" translate="yes" xml:space="preserve">
          <source>When a test case group is specified, the resulting test executes function &lt;code&gt;init_per_group&lt;/code&gt;, followed by all test cases and subgroups (including their configuration functions), and finally function &lt;code&gt;end_per_group&lt;/code&gt;. Also, if particular test cases in a group are specified, &lt;code&gt;init_per_group&lt;/code&gt; and &lt;code&gt;end_per_group&lt;/code&gt;, for the group in question, are called. If a group defined (in &lt;code&gt;Suite:group/0&lt;/code&gt;) as a subgroup of another group, is specified (or if particular test cases of a subgroup are), &lt;code&gt;Common Test&lt;/code&gt; calls the configuration functions for the top-level groups and for the subgroup in question (making it possible to pass configuration data all the way from &lt;code&gt;init_per_suite&lt;/code&gt; down to the test cases in the subgroup).</source>
          <target state="translated">Cuando se especifica un grupo de casos de prueba, la prueba resultante ejecuta la funci&amp;oacute;n &lt;code&gt;init_per_group&lt;/code&gt; , seguida de todos los casos de prueba y subgrupos (incluidas sus funciones de configuraci&amp;oacute;n) y finalmente la funci&amp;oacute;n &lt;code&gt;end_per_group&lt;/code&gt; . Adem&amp;aacute;s, si se especifican casos de prueba particulares en un grupo, se &lt;code&gt;init_per_group&lt;/code&gt; y &lt;code&gt;end_per_group&lt;/code&gt; , para el grupo en cuesti&amp;oacute;n. Si se especifica un grupo definido (en &lt;code&gt;Suite:group/0&lt;/code&gt; ) como un subgrupo de otro grupo (o si se especifican casos de prueba particulares de un subgrupo), &lt;code&gt;Common Test&lt;/code&gt; llama a las funciones de configuraci&amp;oacute;n para los grupos de nivel superior y para el subgrupo en pregunta (haciendo posible pasar datos de configuraci&amp;oacute;n desde &lt;code&gt;init_per_suite&lt;/code&gt; hasta los casos de prueba en el subgrupo).</target>
        </trans-unit>
        <trans-unit id="7eab1460f1347d0c73cb3c3a8b4439b39091de4a" translate="yes" xml:space="preserve">
          <source>When a test case is skipped, it is noted as &lt;code&gt;SKIPPED&lt;/code&gt; in the HTML log.</source>
          <target state="translated">Cuando se omite un caso de prueba, se indica como &lt;code&gt;SKIPPED&lt;/code&gt; en el registro HTML.</target>
        </trans-unit>
        <trans-unit id="40f7d1ac6c7251f44715ccdcb8e5eca59fd62f4e" translate="yes" xml:space="preserve">
          <source>When a thread calls &lt;code&gt;my_val = erts_thr_progress_later()&lt;/code&gt; and waits for &lt;code&gt;erts_thr_progress_has_reached(my_val)&lt;/code&gt; to return a non zero value it knows that thread progress has been made.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a076c9a80ae846b71f117a3d44b9cb45870c233b" translate="yes" xml:space="preserve">
          <source>When a time-out is started any running time-out of the same type; &lt;code&gt;state_timeout&lt;/code&gt;, &lt;code&gt;{timeout, Name}&lt;/code&gt; or &lt;code&gt;timeout&lt;/code&gt;, is cancelled, that is, the time-out is restarted with the new time.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7277815e7b5fc7d7307a8ad2c9b5d0b7fee5390" translate="yes" xml:space="preserve">
          <source>When a timer expires. The driver can set timers with the function &lt;code&gt;driver_set_timer&lt;/code&gt;. When such timers expire, a specific callback function is called. No timers are used in the example.</source>
          <target state="translated">Cuando expira un temporizador. El conductor puede configurar temporizadores con la funci&amp;oacute;n &lt;code&gt;driver_set_timer&lt;/code&gt; . Cuando estos temporizadores expiran, se llama a una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada espec&amp;iacute;fica. En el ejemplo no se utilizan temporizadores.</target>
        </trans-unit>
        <trans-unit id="01248c84705afaa8d22118ccef5dc76865736320" translate="yes" xml:space="preserve">
          <source>When a transaction acknowledgement is received it is possible that user has decided not to bother about the acknowledgement. But in case the return value from UserMod:handle_trans_request/3 indicates that the acknowledgement is important the following callback function will be invoked:</source>
          <target state="translated">Cuando se recibe un acuse de recibo de una transacción,es posible que el usuario haya decidido no preocuparse por el acuse de recibo.Pero en caso de que el valor de retorno de UserMod:handle_trans_request/3 indique que el acuse de recibo es importante,se invocará la siguiente función de devolución de llamada:</target>
        </trans-unit>
        <trans-unit id="163b7a94b619edcfd4f6cd93b3333d250e24a1fb" translate="yes" xml:space="preserve">
          <source>When a user (MG/MGC) is distributed over several nodes, it is required that the node hosting the connection already has activated the connection and that it is in the &quot;normal&quot; state. The RemoteMid must be a real Megaco MID and not a preliminary_mid.</source>
          <target state="translated">Cuando un usuario (MG/MGC)está distribuido en varios nodos,se requiere que el nodo que alberga la conexión ya haya activado la conexión y que esté en el estado &quot;normal&quot;.El RemoteMid debe ser un verdadero Megaco MID y no un Preliminary_mid.</target>
        </trans-unit>
        <trans-unit id="19eb5cc222fe8477b606be0ecb93b47faec2127d" translate="yes" xml:space="preserve">
          <source>When a valid request reaches &lt;code&gt;httpd&lt;/code&gt;, it calls &lt;code&gt;do/1&lt;/code&gt; in each module, defined by the configuration option of &lt;code&gt;Module&lt;/code&gt;. The function can generate data for other modules or a response that can be sent back to the client.</source>
          <target state="translated">Cuando una solicitud v&amp;aacute;lida llega a &lt;code&gt;httpd&lt;/code&gt; , llama a &lt;code&gt;do/1&lt;/code&gt; en cada m&amp;oacute;dulo, definido por la opci&amp;oacute;n de configuraci&amp;oacute;n del &lt;code&gt;Module&lt;/code&gt; . La funci&amp;oacute;n puede generar datos para otros m&amp;oacute;dulos o una respuesta que se puede enviar al cliente.</target>
        </trans-unit>
        <trans-unit id="988284baf01c48f0333363a5420ee041f8e80f73" translate="yes" xml:space="preserve">
          <source>When accessing single attributes in a record, it is not necessary, or even recommended, to hard code any attribute names as atoms. Use construct &lt;code&gt;record_info(fields, RecordName)&lt;/code&gt; instead. It can be used for records of type &lt;code&gt;RecordName&lt;/code&gt;.</source>
          <target state="translated">Cuando se accede a atributos individuales en un registro, no es necesario, ni siquiera recomendado, codificar de forma r&amp;iacute;gida los nombres de los atributos como &amp;aacute;tomos. Use construir &lt;code&gt;record_info(fields, RecordName)&lt;/code&gt; lugar. Se puede utilizar para registros de tipo &lt;code&gt;RecordName&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a069a06056d1779ba3b73665e6912fd948d0893" translate="yes" xml:space="preserve">
          <source>When adding or removing an application, no &lt;code&gt;.appup&lt;/code&gt; file is needed. When generating &lt;code&gt;relup&lt;/code&gt;, the &lt;code&gt;.rel&lt;/code&gt; files are compared and the &lt;code&gt;add_application&lt;/code&gt; and &lt;code&gt;remove_application&lt;/code&gt; instructions are added automatically.</source>
          <target state="translated">Al agregar o eliminar una aplicaci&amp;oacute;n, no se necesita ning&amp;uacute;n archivo &lt;code&gt;.appup&lt;/code&gt; . Al generar &lt;code&gt;relup&lt;/code&gt; , los archivos &lt;code&gt;.rel&lt;/code&gt; se comparan y las instrucciones &lt;code&gt;add_application&lt;/code&gt; y &lt;code&gt;remove_application&lt;/code&gt; se agregan autom&amp;aacute;ticamente.</target>
        </trans-unit>
        <trans-unit id="d7dcf974a69ad2af0b183e9640143a16ca26c965" translate="yes" xml:space="preserve">
          <source>When adding processes or ports, a window with trace options is displayed. The chosen options are set for the selected processes/ports. To change the options, right-click the process or port and select &lt;strong&gt;Edit process options&lt;/strong&gt;. To remove a process or port from the list, right-click and select &lt;strong&gt;Remove process&lt;/strong&gt; or &lt;strong&gt;Remove port&lt;/strong&gt;, respectively.</source>
          <target state="translated">Al agregar procesos o puertos, se muestra una ventana con opciones de seguimiento. Las opciones elegidas se establecen para los procesos / puertos seleccionados. Para cambiar las opciones, haga clic con el bot&amp;oacute;n derecho en el proceso o puerto y seleccione &lt;strong&gt;Editar opciones de proceso&lt;/strong&gt; . Para eliminar un proceso o puerto de la lista, haga clic con el bot&amp;oacute;n derecho y seleccione &lt;strong&gt;Eliminar proceso&lt;/strong&gt; o &lt;strong&gt;Eliminar puerto&lt;/strong&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="8ed50d489e165b74cf018acee993218839df9d7b" translate="yes" xml:space="preserve">
          <source>When all involved (mandatory) nodes have been started, the distributed application can be started by calling &lt;code&gt;application:start(Application)&lt;/code&gt; at &lt;strong&gt;all of these nodes.&lt;/strong&gt;</source>
          <target state="translated">Cuando se hayan iniciado todos los nodos involucrados (obligatorios), la aplicaci&amp;oacute;n distribuida se puede iniciar llamando a &lt;code&gt;application:start(Application)&lt;/code&gt; en &lt;strong&gt;todos estos nodos.&lt;/strong&gt;</target>
        </trans-unit>
        <trans-unit id="cd73cca48ba2b286c66fc15f791c382c884ddbc5" translate="yes" xml:space="preserve">
          <source>When all nodes are operational, &lt;code&gt;myapp&lt;/code&gt; can be started. This is achieved by calling &lt;code&gt;application:start(myapp)&lt;/code&gt; at all three nodes. It is then started at &lt;code&gt;cp1&lt;/code&gt;, as shown in the following figure:</source>
          <target state="translated">Cuando todos los nodos est&amp;aacute;n operativos, se puede iniciar &lt;code&gt;myapp&lt;/code&gt; . Esto se logra llamando a &lt;code&gt;application:start(myapp)&lt;/code&gt; en los tres nodos. Luego se inicia en &lt;code&gt;cp1&lt;/code&gt; , como se muestra en la siguiente figura:</target>
        </trans-unit>
        <trans-unit id="efd0a7b9eacf13a1791c55c3dbd5596c2928ca10" translate="yes" xml:space="preserve">
          <source>When all objects of the table have been matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">Cuando todos los objetos de la tabla coinciden, se devuelve &lt;code&gt;'$end_of_table'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa1c6e68ed8acc251646eddfa314228262bb5f3b" translate="yes" xml:space="preserve">
          <source>When all table objects are matched, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">Cuando todos los objetos de la tabla coinciden, se devuelve &lt;code&gt;'$end_of_table'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="63d12a87e8eebf1261797e6037583c36c38618e3" translate="yes" xml:space="preserve">
          <source>When allocating a new MBC we first search after a free segment in &lt;code&gt;sa&lt;/code&gt;, then try to raise &lt;code&gt;sa.top&lt;/code&gt;, and then as a fallback try to search after a free segment in &lt;code&gt;sua&lt;/code&gt;. When an MBC is allocated in &lt;code&gt;sua&lt;/code&gt;, a larger segment is allocated which is then trimmed to obtain the right alignment. Allocation search for an SBC is done in reverse order. When an SBC is allocated in &lt;code&gt;sa&lt;/code&gt;, the size is aligned up to super aligned size.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c62a1cbadf2c2b8976473d30ec9850b0e30154" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;escript&lt;/code&gt; file contains an archive, there are no restrictions on the name of the &lt;code&gt;escript&lt;/code&gt; and no restrictions on how many applications that can be stored in the embedded archive. Single Beam files can also reside on the top level in the archive. At startup, the top directory in the embedded archive and all (second level) &lt;code&gt;ebin&lt;/code&gt; directories in the embedded archive are added to the code path. See &lt;code&gt;erts:escript(1)&lt;/code&gt;.</source>
          <target state="translated">Cuando un archivo &lt;code&gt;escript&lt;/code&gt; contiene un archivo, no hay restricciones sobre el nombre del &lt;code&gt;escript&lt;/code&gt; ni restricciones sobre la cantidad de aplicaciones que se pueden almacenar en el archivo incrustado. Los archivos Single Beam tambi&amp;eacute;n pueden residir en el nivel superior del archivo. Al inicio, el directorio superior del archivo integrado y todos los directorios &lt;code&gt;ebin&lt;/code&gt; (segundo nivel) del archivo integrado se agregan a la ruta del c&amp;oacute;digo. Ver &lt;code&gt;erts:escript(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9936eae6e93ab6d5c78b6480d03e1af10ab7148" translate="yes" xml:space="preserve">
          <source>When an &lt;code&gt;usm_entry()&lt;/code&gt; tuple (or a list of such tuples) is returned, this data is then added to the &lt;code&gt;usmUserTable&lt;/code&gt; by the (master-) agent.</source>
          <target state="translated">Cuando se &lt;code&gt;usm_entry()&lt;/code&gt; una tupla usm_entry () (o una lista de dichas tuplas), el agente (maestro-) agrega estos datos a &lt;code&gt;usmUserTable&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b976e99904fcceb1196e74093f891273ad96adf" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled with option &lt;code&gt;ber&lt;/code&gt;, the &lt;code&gt;asn1rt_nif&lt;/code&gt; module and the NIF library in &lt;code&gt;asn1/priv_dir&lt;/code&gt; are needed at runtime.</source>
          <target state="translated">Cuando se compila una especificaci&amp;oacute;n ASN.1 con la opci&amp;oacute;n &lt;code&gt;ber&lt;/code&gt; , el m&amp;oacute;dulo &lt;code&gt;asn1rt_nif&lt;/code&gt; y la biblioteca NIF en &lt;code&gt;asn1/priv_dir&lt;/code&gt; son necesarios en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="5c483462464501bc7953de399a743714b5061e30" translate="yes" xml:space="preserve">
          <source>When an ASN.1 specification is compiled, all defined types of type &lt;code&gt;SET&lt;/code&gt; or &lt;code&gt;SEQUENCE&lt;/code&gt; result in a corresponding record in the generated &lt;code&gt;.hrl&lt;/code&gt; file. This is because the values for &lt;code&gt;SET&lt;/code&gt; and &lt;code&gt;SEQUENCE&lt;/code&gt; are represented as records by default.</source>
          <target state="translated">Cuando se compila una especificaci&amp;oacute;n ASN.1, todos los tipos definidos de tipo &lt;code&gt;SET&lt;/code&gt; o &lt;code&gt;SEQUENCE&lt;/code&gt; dan como resultado un registro correspondiente en el archivo &lt;code&gt;.hrl&lt;/code&gt; generado . Esto se debe a que los valores de &lt;code&gt;SET&lt;/code&gt; y &lt;code&gt;SEQUENCE&lt;/code&gt; se representan como registros de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="31932f1867f6d60bbc033269d0dec3fc07011233" translate="yes" xml:space="preserve">
          <source>When an Erlang process calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt; erlang:port_control/3&lt;/a&gt;&lt;/code&gt;, which is a synchronous interface to drivers. The control interface is used to set driver options, change states of ports, and so on. This interface is used a lot in the example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e9c8df5e2566ccd5d9fbe4734d8fd9d613779aa" translate="yes" xml:space="preserve">
          <source>When an Erlang process calls &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt;, which is a synchronous interface to drivers. The control interface is used to set driver options, change states of ports, and so on. This interface is used a lot in the example.</source>
          <target state="translated">Cuando un proceso de Erlang llama a &lt;code&gt;&lt;a href=&quot;erlang#port_control-3&quot;&gt;erlang:port_control/3&lt;/a&gt;&lt;/code&gt; , que es una interfaz s&amp;iacute;ncrona para los controladores. La interfaz de control se utiliza para configurar las opciones del controlador, cambiar los estados de los puertos, etc. Esta interfaz se usa mucho en el ejemplo.</target>
        </trans-unit>
        <trans-unit id="2b618715bb8bb03bc07feda65b3a85bb43cb72de" translate="yes" xml:space="preserve">
          <source>When an Erlang process sends data to the port. The data arrives as a buffer of bytes, the interpretation is not defined, but is up to the implementor. This callback returns nothing to the caller, answers are sent to the caller as messages (using a routine called &lt;code&gt;driver_output&lt;/code&gt; available to all drivers). There is also a way to talk in a synchronous way to drivers, described below. There can be an additional callback function for handling data that is fragmented (sent in a deep io-list). That interface gets the data in a form suitable for Unix &lt;code&gt;writev&lt;/code&gt; rather than in a single buffer. There is no need for a distribution driver to implement such a callback, so we will not.</source>
          <target state="translated">Cuando un proceso de Erlang env&amp;iacute;a datos al puerto. Los datos llegan como un b&amp;uacute;fer de bytes, la interpretaci&amp;oacute;n no est&amp;aacute; definida, sino que depende del implementador. Esta devoluci&amp;oacute;n de llamada no devuelve nada a la persona que llama, las respuestas se env&amp;iacute;an a la persona que llama como mensajes (usando una rutina llamada &lt;code&gt;driver_output&lt;/code&gt; disponible para todos los conductores). Tambi&amp;eacute;n hay una forma de hablar de forma sincronizada con los conductores, que se describe a continuaci&amp;oacute;n. Puede haber una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada adicional para manejar datos fragmentados (enviados en una lista io profunda). Esa interfaz obtiene los datos en una forma adecuada para Unix &lt;code&gt;writev&lt;/code&gt; en lugar de en un solo b&amp;uacute;fer. No es necesario que un controlador de distribuci&amp;oacute;n implemente dicha devoluci&amp;oacute;n de llamada, por lo que no lo haremos.</target>
        </trans-unit>
        <trans-unit id="fcd682219ed27952353a789f2a95e93eae1b95ef" translate="yes" xml:space="preserve">
          <source>When an Erlang runtime system is started, a number of processes are started as part of the Kernel application. One of these processes is the &lt;strong&gt;application controller&lt;/strong&gt; process, registered as &lt;code&gt;application_controller&lt;/code&gt;.</source>
          <target state="translated">Cuando se inicia un sistema de ejecuci&amp;oacute;n de Erlang, se inician varios procesos como parte de la aplicaci&amp;oacute;n Kernel. Uno de estos procesos es el proceso del &lt;strong&gt;controlador de&lt;/strong&gt; la &lt;strong&gt;aplicaci&amp;oacute;n&lt;/strong&gt; , registrado como &lt;code&gt;application_controller&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f6e9cd273f9f4e055a8524b92a57509f35b9cee" translate="yes" xml:space="preserve">
          <source>When an I/O server receives an &lt;code&gt;io_request&lt;/code&gt; tuple, it acts upon the &lt;code&gt;Request&lt;/code&gt; part and eventually sends an &lt;code&gt;io_reply&lt;/code&gt; tuple with the corresponding &lt;code&gt;Reply&lt;/code&gt; part.</source>
          <target state="translated">Cuando un servidor de E / S recibe una tupla &lt;code&gt;io_request&lt;/code&gt; , act&amp;uacute;a sobre la parte de &lt;code&gt;Request&lt;/code&gt; y finalmente env&amp;iacute;a una tupla &lt;code&gt;io_reply&lt;/code&gt; con la parte de &lt;code&gt;Reply&lt;/code&gt; correspondiente .</target>
        </trans-unit>
        <trans-unit id="c97830caeadaae0c71c4a6641f2b72ee5a3a4441" translate="yes" xml:space="preserve">
          <source>When an MIB is compiled, the compiler detects if several managed objects use the same &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt;. If that is the case, it issues an error message. However, the compiler cannot detect Oid conflicts between different MIBs. These kinds of conflicts generate an error at load time. To avoid this, the following function can be used to do consistency checking between MIBs:</source>
          <target state="translated">Cuando se compila una MIB, el compilador detecta si varios objetos gestionados utilizan el mismo &lt;code&gt;OBJECT IDENTIFIER&lt;/code&gt; . Si ese es el caso, emite un mensaje de error. Sin embargo, el compilador no puede detectar conflictos de Oid entre diferentes MIB. Este tipo de conflictos generan un error en el momento de la carga. Para evitar esto, la siguiente funci&amp;oacute;n se puede utilizar para realizar una comprobaci&amp;oacute;n de coherencia entre MIB:</target>
        </trans-unit>
        <trans-unit id="db011fd2eddc67aaa683180ce280cb84fa7377af" translate="yes" xml:space="preserve">
          <source>When an TLS/DTLS socket is in active mode (the default), data from the socket is delivered to the owner of the socket in the form of messages:</source>
          <target state="translated">Cuando un socket TLS/DTLS está en modo activo (el predeterminado),los datos del socket se entregan al propietario del mismo en forma de mensajes:</target>
        </trans-unit>
        <trans-unit id="996325d55085b77e5910030169e95fa9280c37bb" translate="yes" xml:space="preserve">
          <source>When an accept sequence has been completed the acceptor process is expected to continue accepting further requests.</source>
          <target state="translated">Cuando se ha completado una secuencia de aceptación,se espera que el proceso de aceptación siga aceptando nuevas solicitudes.</target>
        </trans-unit>
        <trans-unit id="75461cd7ae2ccbf7a584f95a468ce12ee8f87375" translate="yes" xml:space="preserve">
          <source>When an allocator instance needs more carrier space, it inspects the pool. If no carrier could be fetched from the pool, it will allocate a new carrier. Regardless of where the allocator instance gets the carrier from, it just links in the carrier into its data structure of free blocks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="709fa60f17ba558cd057f2a6b62757eac692ee54" translate="yes" xml:space="preserve">
          <source>When an application executes on several nodes and wants to be sure that the update is performed on the remote nodes before a remote process is spawned or a message is sent to a remote process.</source>
          <target state="translated">Cuando una aplicación se ejecuta en varios nodos y quiere asegurarse de que la actualización se realiza en los nodos remotos antes de que se produzca un proceso remoto o se envíe un mensaje a un proceso remoto.</target>
        </trans-unit>
        <trans-unit id="6c28abc5b0d379d3a8ba44dbcc2c9763e0be3b27" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on other nodes.</source>
          <target state="translated">Cuando una aplicaci&amp;oacute;n realiza actualizaciones frecuentes o voluminosas que pueden sobrecargar &lt;code&gt;Mnesia&lt;/code&gt; en otros nodos.</target>
        </trans-unit>
        <trans-unit id="a47a8128b591f9e03e1d7bb3a8b71505f2177f47" translate="yes" xml:space="preserve">
          <source>When an application performs frequent or voluminous updates that can overload &lt;code&gt;Mnesia&lt;/code&gt; on the nodes.</source>
          <target state="translated">Cuando una aplicaci&amp;oacute;n realiza actualizaciones frecuentes o voluminosas que pueden sobrecargar &lt;code&gt;Mnesia&lt;/code&gt; en los nodos.</target>
        </trans-unit>
        <trans-unit id="8091d18c34c7568e437ad61e1779d1db887806b5" translate="yes" xml:space="preserve">
          <source>When an event handler terminates abnormally, &lt;code&gt;gen_event&lt;/code&gt; logs &lt;code&gt;Status&lt;/code&gt; in place of the state term of the event handler.</source>
          <target state="translated">Cuando un controlador de eventos termina de forma anormal, &lt;code&gt;gen_event&lt;/code&gt; registra el &lt;code&gt;Status&lt;/code&gt; en lugar del t&amp;eacute;rmino de estado del controlador de eventos.</target>
        </trans-unit>
        <trans-unit id="3b856ad79c467961efb9c09f4c8c68ce2f0ae4ff" translate="yes" xml:space="preserve">
          <source>When an event manager is stopped, it gives each of the installed event handlers the chance to clean up by calling &lt;code&gt;terminate/2&lt;/code&gt;, the same way as when deleting a handler.</source>
          <target state="translated">Cuando se detiene un administrador de eventos, le da a cada uno de los controladores de eventos instalados la oportunidad de realizar una limpieza llamando a &lt;code&gt;terminate/2&lt;/code&gt; , de la misma manera que cuando se elimina un controlador.</target>
        </trans-unit>
        <trans-unit id="a2f914353111b5a9e0f8ff47f4ec0a5a28de2e0a" translate="yes" xml:space="preserve">
          <source>When an executing port runs out of work to execute in the private task data structure, it moves the public task queue into the private task data structure while holding the lock. Once tasks has been moved to the private data structure no lock protects them. This way the port can continue working on tasks in the private data structure without having to fight for the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecb64233649623988df5a15e4320b8e35507f15" translate="yes" xml:space="preserve">
          <source>When an installed release is made permanent, the system process &lt;code&gt;init&lt;/code&gt; is set to point out the new &lt;code&gt;sys.config&lt;/code&gt;.</source>
          <target state="translated">Cuando una versi&amp;oacute;n instalada se convierte en permanente, el proceso del sistema &lt;code&gt;init&lt;/code&gt; se configura para se&amp;ntilde;alar el nuevo &lt;code&gt;sys.config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b00873013d7a25ee81fef530c37b0fd219bde2fd" translate="yes" xml:space="preserve">
          <source>When an integer-value is specified, &lt;code&gt;TLS/DTLS-connection&lt;/code&gt; goes into hibernation after the specified number of milliseconds of inactivity, thus reducing its memory footprint. When &lt;code&gt;undefined&lt;/code&gt; is specified (this is the default), the process never goes into hibernation.</source>
          <target state="translated">Cuando se especifica un valor entero, &lt;code&gt;TLS/DTLS-connection&lt;/code&gt; entra en hibernaci&amp;oacute;n despu&amp;eacute;s del n&amp;uacute;mero especificado de milisegundos de inactividad, lo que reduce su huella de memoria. Cuando se especifica &lt;code&gt;undefined&lt;/code&gt; (este es el valor predeterminado), el proceso nunca entra en hibernaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="bc796970d718582f543a7db2afb490e94eada2a5" translate="yes" xml:space="preserve">
          <source>When an unmanaged thread increment the &lt;code&gt;current&lt;/code&gt; counter it will not prevent the next increment of the global counter, but instead the increment after that. This is sufficient since the global counter needs to be incremented two times before thread progress has been made. It is also desirable not to prevent the first increment, since the likelihood increases that the delay is withdrawn before any increment of the global counter is delayed. That is, the operation will cause as little disruption as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd630c54a2a673edbcdeb121843359b4c127f6e0" translate="yes" xml:space="preserve">
          <source>When analysing code coverage, the result for &lt;code&gt;m1&lt;/code&gt; can be seen in the cover log in the &lt;code&gt;s1&lt;/code&gt; test result.</source>
          <target state="translated">Al analizar la cobertura del c&amp;oacute;digo, el resultado de &lt;code&gt;m1&lt;/code&gt; se puede ver en el registro de cobertura en el resultado de la prueba &lt;code&gt;s1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="89c824ef18f1155e6eb73bb5f1e6f145e288eb6a" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the &lt;code&gt;include_dir&lt;/code&gt; to Dialyzer. (**)</source>
          <target state="translated">Al analizar desde la fuente, pase el &lt;code&gt;include_dir&lt;/code&gt; a Dialyzer. (**)</target>
        </trans-unit>
        <trans-unit id="6d86eb0ccd83bcc9cd8e9fc364281c878af586ee" translate="yes" xml:space="preserve">
          <source>When analyzing from source, pass the define to Dialyzer. (**)</source>
          <target state="translated">Cuando analice desde la fuente,pase la definición a Dialyzer.(**)</target>
        </trans-unit>
        <trans-unit id="ac42477caf4c3ea1c573d88619291bc09d0583f2" translate="yes" xml:space="preserve">
          <source>When analyzing from source, you might have to supply Dialyzer with a list of include directories and macro definitions (as you can do with the &lt;code&gt;erlc&lt;/code&gt; flags &lt;code&gt;-I&lt;/code&gt; and &lt;code&gt;-D&lt;/code&gt;). This can be done either by starting Dialyzer with these flags from the command line as in:</source>
          <target state="translated">Al analizar desde la fuente, es posible que deba proporcionar a Dialyzer una lista de directorios de inclusi&amp;oacute;n y definiciones de macros (como puede hacer con los indicadores &lt;code&gt;erlc&lt;/code&gt; &lt;code&gt;-I&lt;/code&gt; y &lt;code&gt;-D&lt;/code&gt; ). Esto se puede hacer iniciando Dialyzer con estos indicadores desde la l&amp;iacute;nea de comando como en:</target>
        </trans-unit>
        <trans-unit id="658b2374a8aacc4b9e6927fe3e6096361c317c2b" translate="yes" xml:space="preserve">
          <source>When analyzing the result file from the profiling activity, look for functions that are called many times and have a long &quot;own&quot; execution time (time excluding calls to other functions). Functions that are called a lot of times can also be interesting, as even small things can add up to quite a bit if repeated often. Also ask yourself what you can do to reduce this time. The following are appropriate types of questions to ask yourself:</source>
          <target state="translated">Al analizar el archivo de resultados de la actividad de elaboración de perfiles,busque las funciones que se llaman muchas veces y que tienen un largo tiempo de ejecución &quot;propio&quot; (tiempo que excluye las llamadas a otras funciones).Las funciones que son llamadas muchas veces también pueden ser interesantes,ya que incluso las cosas pequeñas pueden sumar bastante si se repiten a menudo.También pregúntese qué puede hacer para reducir este tiempo.Los siguientes son tipos de preguntas apropiadas para hacerse a sí mismo:</target>
        </trans-unit>
        <trans-unit id="806459f8533827481672dc572cf1bf7921931e0f" translate="yes" xml:space="preserve">
          <source>When appending to a binary as follows, only the binary returned from the latest append operation will support further cheap append operations:</source>
          <target state="translated">Cuando se añade a un binario de la siguiente manera,sólo el binario devuelto de la última operación de apéndice apoyará otras operaciones de apéndice baratas:</target>
        </trans-unit>
        <trans-unit id="a512d102468fee77b47b8323833438033b394ad0" translate="yes" xml:space="preserve">
          <source>When atoms or other terms that fit in one machine word are deleted, no global GC is needed. Therefore, persistent terms that have atoms as their values can be updated more frequently, but note that updating such persistent terms is still much more expensive than reading them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="228cd4e5a8bc6e5b7fee2e6123af719e572f533e" translate="yes" xml:space="preserve">
          <source>When building in a Git working directory you also have to have a GNU &lt;code&gt;autoconf&lt;/code&gt; of at least version 2.59 on your system, because you need to generate the &lt;code&gt;configure&lt;/code&gt; scripts before you can start building.</source>
          <target state="translated">Al compilar en un directorio de trabajo de Git, tambi&amp;eacute;n debe tener una &lt;code&gt;autoconf&lt;/code&gt; de GNU de al menos la versi&amp;oacute;n 2.59 en su sistema, porque necesita generar los scripts de &lt;code&gt;configure&lt;/code&gt; antes de comenzar a compilar.</target>
        </trans-unit>
        <trans-unit id="eaf8c1d8b7925ac8c617463eca8b72a76f666d34" translate="yes" xml:space="preserve">
          <source>When building the documentation you need a full Erlang/OTP-21.0 system in the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="translated">Al crear la documentaci&amp;oacute;n, necesita un sistema Erlang / OTP-21.0 completo en &lt;code&gt;$PATH&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c0cffe21bf826ba6055606784d159ee73a759d5c" translate="yes" xml:space="preserve">
          <source>When building the documentation you need a full Erlang/OTP-23.2 system in the &lt;code&gt;$PATH&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f23b671fd08513b7a0eaff9f50d4ae1fef0eb3dc" translate="yes" xml:space="preserve">
          <source>When called &lt;code&gt;addr&lt;/code&gt; points to an address structure of lenght &lt;code&gt;len&lt;/code&gt; containing information on where to connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1fe5c4adb0aba58b536194f949a24424424eac9" translate="yes" xml:space="preserve">
          <source>When called &lt;code&gt;buf&lt;/code&gt; points to a buffer of length &lt;code&gt;*len&lt;/code&gt; containing the data to write on the socket. On success, this callback should set &lt;code&gt;*len&lt;/code&gt; to the amount of bytes successfully written on the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90530c4b0ae5b8364ccb16ac3ef25111d36b377f" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occurs, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">Cuando se llama con un argumento &lt;code&gt;read&lt;/code&gt; , se supone que la funci&amp;oacute;n &lt;code&gt;InitFun&lt;/code&gt; devuelve &lt;code&gt;end_of_input&lt;/code&gt; cuando no hay m&amp;aacute;s entrada, o &lt;code&gt;{Objects, Fun}&lt;/code&gt; , donde &lt;code&gt;Objects&lt;/code&gt; es una lista de objetos y &lt;code&gt;Fun&lt;/code&gt; es una nueva funci&amp;oacute;n de entrada. Cualquier otro valor &lt;code&gt;Value&lt;/code&gt; se devuelve como un error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt; . Cada funci&amp;oacute;n de entrada se llama exactamente una vez y, si se produce un error, se llama a la &amp;uacute;ltima funci&amp;oacute;n con el argumento &lt;code&gt;close&lt;/code&gt; , cuya respuesta se ignora.</target>
        </trans-unit>
        <trans-unit id="07cb85581936567b82cbd8ae581b4c6171786cd2" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;read&lt;/code&gt;, the function &lt;code&gt;InitFun&lt;/code&gt; is assumed to return &lt;code&gt;end_of_input&lt;/code&gt; when there is no more input, or &lt;code&gt;{Objects, Fun}&lt;/code&gt;, where &lt;code&gt;Objects&lt;/code&gt; is a list of objects and &lt;code&gt;Fun&lt;/code&gt; is a new input function. Any other value &lt;code&gt;Value&lt;/code&gt; is returned as an error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt;. Each input function is called exactly once, and if an error occur, the last function is called with argument &lt;code&gt;close&lt;/code&gt;, the reply of which is ignored.</source>
          <target state="translated">Cuando se llama con el argumento &lt;code&gt;read&lt;/code&gt; , se supone que la funci&amp;oacute;n &lt;code&gt;InitFun&lt;/code&gt; devuelve &lt;code&gt;end_of_input&lt;/code&gt; cuando no hay m&amp;aacute;s entrada, o &lt;code&gt;{Objects, Fun}&lt;/code&gt; , donde &lt;code&gt;Objects&lt;/code&gt; es una lista de objetos y &lt;code&gt;Fun&lt;/code&gt; es una nueva funci&amp;oacute;n de entrada. Cualquier otro valor &lt;code&gt;Value&lt;/code&gt; se devuelve como un error &lt;code&gt;{error, {init_fun, Value}}&lt;/code&gt; . Cada funci&amp;oacute;n de entrada se llama exactamente una vez y, si se produce un error, se llama a la &amp;uacute;ltima funci&amp;oacute;n con el argumento &lt;code&gt;close&lt;/code&gt; , cuya respuesta se ignora.</target>
        </trans-unit>
        <trans-unit id="364ba2a27b870da0b99015d17a3a2b5626ba1eeb" translate="yes" xml:space="preserve">
          <source>When called with argument &lt;code&gt;undefined&lt;/code&gt;, all system performance monitoring settings are cleared.</source>
          <target state="translated">Cuando se llama con un argumento &lt;code&gt;undefined&lt;/code&gt; , se borran todas las configuraciones de supervisi&amp;oacute;n del rendimiento del sistema.</target>
        </trans-unit>
        <trans-unit id="b44f8219d85b31453de272e6169e5dfa4f9585c9" translate="yes" xml:space="preserve">
          <source>When calling &lt;code&gt;qlc:q/1,2&lt;/code&gt; from the Erlang shell, the parse transform is automatically called. When this occurs, the fun substituted for the QLC is not compiled but is evaluated by &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt;. This is also true when expressions are evaluated by &lt;code&gt;file:eval/1,2&lt;/code&gt; or in the debugger.</source>
          <target state="translated">Al llamar a &lt;code&gt;qlc:q/1,2&lt;/code&gt; desde el shell de Erlang, se llama autom&amp;aacute;ticamente a la transformaci&amp;oacute;n de an&amp;aacute;lisis. Cuando esto ocurre, la diversi&amp;oacute;n sustituida por el QLC no se compila pero es evaluada por &lt;code&gt;&lt;a href=&quot;erl_eval&quot;&gt;erl_eval(3)&lt;/a&gt;&lt;/code&gt; . Esto tambi&amp;eacute;n es cierto cuando las expresiones se eval&amp;uacute;an mediante el &lt;code&gt;file:eval/1,2&lt;/code&gt; o en el depurador.</target>
        </trans-unit>
        <trans-unit id="0142d7dfddbd655a17b503f022ba1db92cd0ecd9" translate="yes" xml:space="preserve">
          <source>When calling BIFs that accept deep lists, such as &lt;code&gt;list_to_binary/1&lt;/code&gt; or &lt;code&gt;iolist_to_binary/1&lt;/code&gt;.</source>
          <target state="translated">Al llamar a BIF que aceptan listas profundas, como &lt;code&gt;list_to_binary/1&lt;/code&gt; o &lt;code&gt;iolist_to_binary/1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="814de6a52bbcc04dc1b80c48dfb06eef572da2a6" translate="yes" xml:space="preserve">
          <source>When calling a function, the return address is first stored in &lt;code&gt;E[0]&lt;/code&gt; (using the &lt;code&gt;$SAVE_CONTINUATION_POINTER()&lt;/code&gt; macro), and then control is transferred to the callee. Here is the generated code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18c494144b9a22a3f981a6afcba77050a11fcf18" translate="yes" xml:space="preserve">
          <source>When calling this function, &lt;code&gt;iovec&lt;/code&gt; should contain a pointer to &lt;code&gt;NULL&lt;/code&gt; or a ErlNifIOVec structure that should be used if possible. e.g.</source>
          <target state="translated">Al llamar a esta funci&amp;oacute;n, &lt;code&gt;iovec&lt;/code&gt; debe contener un puntero a &lt;code&gt;NULL&lt;/code&gt; o una estructura ErlNifIOVec que debe usarse si es posible. p.ej</target>
        </trans-unit>
        <trans-unit id="865c3803d266e89c17825224f1f9b63a82983678" translate="yes" xml:space="preserve">
          <source>When caseless matching is set, any letters in a class represent both their uppercase and lowercase versions. For example, a caseless &lt;code&gt;[aeiou]&lt;/code&gt; matches &quot;A&quot; and &quot;a&quot;, and a caseless &lt;code&gt;[^aeiou]&lt;/code&gt; does not match &quot;A&quot;, but a caseful version would. In a UTF mode, PCRE always understands the concept of case for characters whose values are &amp;lt; 256, so caseless matching is always possible. For characters with higher values, the concept of case is supported only if PCRE is compiled with Unicode property support. If you want to use caseless matching in a UTF mode for characters &amp;gt;=, ensure that PCRE is compiled with Unicode property support and with UTF support.</source>
          <target state="translated">Cuando se establece la coincidencia sin may&amp;uacute;sculas y min&amp;uacute;sculas, las letras de una clase representan sus versiones en may&amp;uacute;sculas y min&amp;uacute;sculas. Por ejemplo, un &lt;code&gt;[aeiou]&lt;/code&gt; sin may&amp;uacute;sculas y min&amp;uacute;sculas coincide con &quot;A&quot; y &quot;a&quot;, y un &lt;code&gt;[^aeiou]&lt;/code&gt; sin may&amp;uacute;sculas no coincide con &quot;A&quot;, pero una versi&amp;oacute;n con may&amp;uacute;sculas s&amp;iacute; lo har&amp;iacute;a. En un modo UTF, PCRE siempre entiende el concepto de may&amp;uacute;sculas y min&amp;uacute;sculas para los caracteres cuyos valores son &amp;lt;256, por lo que la coincidencia sin may&amp;uacute;sculas siempre es posible. Para caracteres con valores m&amp;aacute;s altos, el concepto de may&amp;uacute;sculas y min&amp;uacute;sculas solo se admite si PCRE se compila con el soporte de propiedad Unicode. Si desea utilizar la coincidencia sin may&amp;uacute;sculas y min&amp;uacute;sculas en un modo UTF para caracteres&amp;gt; =, aseg&amp;uacute;rese de que PCRE est&amp;eacute; compilado con soporte de propiedad Unicode y con soporte UTF.</target>
        </trans-unit>
        <trans-unit id="1fa07acc11a720ed656be365e748b1e786d781a3" translate="yes" xml:space="preserve">
          <source>When caseless matching is specified (option &lt;code&gt;caseless&lt;/code&gt;), letters are matched independently of case.</source>
          <target state="translated">Cuando se especifica la &lt;code&gt;caseless&lt;/code&gt; may&amp;uacute;sculas y min&amp;uacute;sculas (opci&amp;oacute;n sin may&amp;uacute;sculas ), las letras se emparejan independientemente de las may&amp;uacute;sculas y min&amp;uacute;sculas.</target>
        </trans-unit>
        <trans-unit id="37ae8050f70165954f23ba0ebf3fbda68196592f" translate="yes" xml:space="preserve">
          <source>When changing this flag messages will be moved. This work has been initiated but not completed when this function call returns.</source>
          <target state="translated">Al cambiar esta bandera los mensajes se moverán.Este trabajo se ha iniciado pero no se ha completado cuando esta llamada de función regrese.</target>
        </trans-unit>
        <trans-unit id="1c283832835fc69a63d88192d48cfa2b0fe0ad55" translate="yes" xml:space="preserve">
          <source>When changing to state &lt;code&gt;open&lt;/code&gt;, the collected buttons are reset, the lock unlocked, and a state timer for 10 s is started.</source>
          <target state="translated">Cuando se cambia al estado &lt;code&gt;open&lt;/code&gt; , los botones recopilados se restablecen, el bloqueo se desbloquea y se inicia un temporizador de estado durante 10 s.</target>
        </trans-unit>
        <trans-unit id="44d2f7b0ec39f0b334cd93ff69fd7523f8653774" translate="yes" xml:space="preserve">
          <source>When comparing an integer to a float, the term with the lesser precision is converted into the type of the other term, unless the operator is one of &lt;code&gt;=:=&lt;/code&gt; or &lt;code&gt;=/=&lt;/code&gt;. A float is more precise than an integer until all significant figures of the float are to the left of the decimal point. This happens when the float is larger/smaller than +/-9007199254740992.0. The conversion strategy is changed depending on the size of the float because otherwise comparison of large floats and integers would lose their transitivity.</source>
          <target state="translated">Al comparar un n&amp;uacute;mero entero con un flotante, el t&amp;eacute;rmino con menor precisi&amp;oacute;n se convierte en el tipo del otro t&amp;eacute;rmino, a menos que el operador sea uno de &lt;code&gt;=:=&lt;/code&gt; o &lt;code&gt;=/=&lt;/code&gt; . Un flotador es m&amp;aacute;s preciso que un n&amp;uacute;mero entero hasta que todas las cifras significativas del flotador est&amp;eacute;n a la izquierda del punto decimal. Esto sucede cuando el flotador es mayor / menor que +/- 9007199254740992.0. La estrategia de conversi&amp;oacute;n se cambia dependiendo del tama&amp;ntilde;o del flotante porque, de lo contrario, la comparaci&amp;oacute;n de n&amp;uacute;meros enteros y flotantes grandes perder&amp;iacute;a su transitividad.</target>
        </trans-unit>
        <trans-unit id="057fdbcf9c89dcfcef51fc5e8e497f10a792cf05" translate="yes" xml:space="preserve">
          <source>When comparing external sets, operator &lt;code&gt;==/2&lt;/code&gt; is used.</source>
          <target state="translated">Al comparar conjuntos externos, se usa el operador &lt;code&gt;==/2&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7fc0d77de42806fcc3f093559352b14f83658b4e" translate="yes" xml:space="preserve">
          <source>When comparing two version numbers that have an order, one compare each part as ordinary integers from the most significant part to less significant parts. The order is defined by the first parts of the same significance that differ. An OTP version with a larger version includes all changes that are part of a smaller OTP version. The same goes for application versions.</source>
          <target state="translated">Cuando se comparan dos números de versión que tienen un orden,se compara cada parte como enteros ordinarios de la parte más significativa con las partes menos significativas.El orden se define por las primeras partes del mismo significado que difieren.Una versión OTP con una versión más grande incluye todos los cambios que son parte de una versión OTP más pequeña.Lo mismo ocurre con las versiones de aplicación.</target>
        </trans-unit>
        <trans-unit id="652b52bac7a7e326263b30fa8ceb237c7bcb235a" translate="yes" xml:space="preserve">
          <source>When comparing with a locked approach, at least one heavy weight memory barrier will be issued when locking the lock on most, if not all, hardware architectures (including x86/x86_64), and often some kind of light weight memory barrier will be issued when unlocking the lock.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7045558361dff4148b294c98385164fc4d95e222" translate="yes" xml:space="preserve">
          <source>When compilation is involved, exception &lt;code&gt;badarg&lt;/code&gt; is thrown if a compilation error occurs. Call &lt;code&gt;compile/2&lt;/code&gt; to get information about the location of the error in the regular expression.</source>
          <target state="translated">Cuando la compilaci&amp;oacute;n est&amp;aacute; involucrada, se lanza una excepci&amp;oacute;n &lt;code&gt;badarg&lt;/code&gt; si ocurre un error de compilaci&amp;oacute;n. Llame a &lt;code&gt;compile/2&lt;/code&gt; para obtener informaci&amp;oacute;n sobre la ubicaci&amp;oacute;n del error en la expresi&amp;oacute;n regular.</target>
        </trans-unit>
        <trans-unit id="70f94aaa056c45f783cd020ccfb0c871d028ac6c" translate="yes" xml:space="preserve">
          <source>When connections gets broken (that is explicitly by megaco:disconnect/2 or when its controlling process dies) a user callback function is invoked in order to allow the user to re-establish the connection. The internal state of kept messages, re-send timers etc. is not affected by this. A few re-sends will of course fail while the connection is down, but the automatic re-send algorithm does not bother about this and eventually when the connection is up and running the messages will be delivered if the timeouts are set to be long enough. The user has the option of explicitly invoking megaco:cancel/2 to cancel all messages for a connection.</source>
          <target state="translated">Cuando se rompen las conexiones (es decir,explícitamente por megaco:desconexión/2 o cuando su proceso de control muere)se invoca una función de devolución de llamada al usuario para permitirle restablecer la conexión.El estado interno de los mensajes guardados,los temporizadores de reenvío,etc.no se ve afectado por esto.Por supuesto,algunos reenvíos fallarán mientras la conexión esté caída,pero el algoritmo de reenvío automático no se preocupa por ello y,eventualmente,cuando la conexión esté en funcionamiento,los mensajes serán entregados si los tiempos de espera se establecen lo suficientemente largos.El usuario tiene la opción de invocar explícitamente megaco:cancel/2 para cancelar todos los mensajes de una conexión.</target>
        </trans-unit>
        <trans-unit id="eee80008193ca8beab002b82928ea575e05d44fd" translate="yes" xml:space="preserve">
          <source>When constructing a segment of a &lt;code&gt;utf&lt;/code&gt; type, &lt;code&gt;Value&lt;/code&gt; must be an integer in the range 0..16#D7FF or 16#E000....16#10FFFF. Construction fails with a &lt;code&gt;badarg&lt;/code&gt; exception if &lt;code&gt;Value&lt;/code&gt; is outside the allowed ranges. The size of the resulting binary segment depends on the type or &lt;code&gt;Value&lt;/code&gt;, or both:</source>
          <target state="translated">Al construir un segmento de tipo &lt;code&gt;utf&lt;/code&gt; , &lt;code&gt;Value&lt;/code&gt; debe ser un n&amp;uacute;mero entero en el rango 0..16 # D7FF o 16 # E000 .... 16 # 10FFFF. La construcci&amp;oacute;n falla con una excepci&amp;oacute;n de &lt;code&gt;badarg&lt;/code&gt; si el &lt;code&gt;Value&lt;/code&gt; est&amp;aacute; fuera de los rangos permitidos. El tama&amp;ntilde;o del segmento binario resultante depende del tipo o &lt;code&gt;Value&lt;/code&gt; , o de ambos:</target>
        </trans-unit>
        <trans-unit id="2dfba87ba5340bf590a9719ae92123f1780ed535" translate="yes" xml:space="preserve">
          <source>When constructing binaries, &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; can be any Erlang expression. However, for syntactical reasons, both &lt;code&gt;Value&lt;/code&gt; and &lt;code&gt;Size&lt;/code&gt; must be enclosed in parenthesis if the expression consists of anything more than a single literal or a variable. The following gives a compiler syntax error:</source>
          <target state="translated">Al construir binarios, &lt;code&gt;Value&lt;/code&gt; y &lt;code&gt;Size&lt;/code&gt; pueden ser cualquier expresi&amp;oacute;n de Erlang. Sin embargo, por razones sint&amp;aacute;cticas, tanto el &lt;code&gt;Value&lt;/code&gt; como el &lt;code&gt;Size&lt;/code&gt; deben ir entre par&amp;eacute;ntesis si la expresi&amp;oacute;n consta de algo m&amp;aacute;s que un solo literal o una variable. Lo siguiente da un error de sintaxis del compilador:</target>
        </trans-unit>
        <trans-unit id="a4d4be88f085f6842045d6bb85ffd60f1c5e2495" translate="yes" xml:space="preserve">
          <source>When constructing binaries, if the size &lt;code&gt;N&lt;/code&gt; of an integer segment is too small to contain the given integer, the most significant bits of the integer are silently discarded and only the &lt;code&gt;N&lt;/code&gt; least significant bits are put into the binary.</source>
          <target state="translated">Al construir binarios, si el tama&amp;ntilde;o &lt;code&gt;N&lt;/code&gt; de un segmento entero es demasiado peque&amp;ntilde;o para contener el entero dado, los bits m&amp;aacute;s significativos del entero se descartan silenciosamente y solo los &lt;code&gt;N&lt;/code&gt; bits menos significativos se colocan en el binario.</target>
        </trans-unit>
        <trans-unit id="ed7c4511bca13fde6765438ddbde809cac5d3478" translate="yes" xml:space="preserve">
          <source>When constructing, a literal string can be given followed by one of the UTF types, for example: &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;/utf8&amp;gt;&amp;gt;&lt;/code&gt; which is syntactic sugar for &lt;code&gt;&amp;lt;&amp;lt;$a/utf8,$b/utf8,$c/utf8&amp;gt;&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">Al construir, se puede dar una cadena literal seguida de uno de los tipos UTF, por ejemplo: &lt;code&gt;&amp;lt;&amp;lt;&quot;abc&quot;/utf8&amp;gt;&amp;gt;&lt;/code&gt; que es az&amp;uacute;car sint&amp;aacute;ctico para &lt;code&gt;&amp;lt;&amp;lt;$a/utf8,$b/utf8,$c/utf8&amp;gt;&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="14ed84f016fc083dab3c16b2cd6e8fe5dee14cdb" translate="yes" xml:space="preserve">
          <source>When creating a record to be used in a select/match operation, you want most of the fields to have the value &quot;_&quot;. The easiest and fastest way to do that is as follows:</source>
          <target state="translated">Cuando se crea un registro para ser usado en una operación de selección/encuentro,se quiere que la mayoría de los campos tengan el valor &quot;_&quot;.La forma más fácil y rápida de hacerlo es la siguiente:</target>
        </trans-unit>
        <trans-unit id="0be878ceb74375986a99208578a50205223bc154" translate="yes" xml:space="preserve">
          <source>When creating a system using Erlang/OTP, the simplest way is to install Erlang/OTP somewhere, install the application-specific code somewhere else, and then start the Erlang runtime system, making sure the code path includes the application-specific code.</source>
          <target state="translated">Cuando se crea un sistema usando Erlang/OTP,la forma más simple es instalar Erlang/OTP en algún lugar,instalar el código específico de la aplicación en otro lugar,y luego iniciar el sistema de tiempo de ejecución Erlang,asegurándose de que la ruta del código incluya el código específico de la aplicación.</target>
        </trans-unit>
        <trans-unit id="f9a48110445b8b431b0a819b4efed940d95979f9" translate="yes" xml:space="preserve">
          <source>When creating test suites, it is strongly recommended to not create dependencies between test cases, that is, letting test cases depend on the result of previous test cases. There are various reasons for this, such as, the following:</source>
          <target state="translated">Al crear los conjuntos de pruebas,se recomienda encarecidamente no crear dependencias entre los casos de prueba,es decir,dejar que los casos de prueba dependan del resultado de los casos de prueba anteriores.Hay varias razones para ello,como las siguientes:</target>
        </trans-unit>
        <trans-unit id="26cf28e2e1bf20fe1af4eb848b0d0a7d334f0f8b" translate="yes" xml:space="preserve">
          <source>When debugging a process with the functions of this module, the process generates &lt;strong&gt;system_events&lt;/strong&gt;, which are then treated in the debug function. For example, &lt;code&gt;trace&lt;/code&gt; formats the system events to the terminal.</source>
          <target state="translated">Al depurar un proceso con las funciones de este m&amp;oacute;dulo, el proceso genera &lt;strong&gt;system_events&lt;/strong&gt; , que luego se tratan en la funci&amp;oacute;n de depuraci&amp;oacute;n. Por ejemplo, &lt;code&gt;trace&lt;/code&gt; formatea los eventos del sistema en la terminal.</target>
        </trans-unit>
        <trans-unit id="f636b27b7770791a083db3563a557efb2923ba0e" translate="yes" xml:space="preserve">
          <source>When decoding &lt;code&gt;property_group()&lt;/code&gt; or &lt;code&gt;property_groups()&lt;/code&gt;, those property parameter constructs that cannot be decoded (either because of decode error or because they are unknown), will be returned as a two-tuple. The first element of which will be the (undecoded) property parameter and the other the actual reason. This means that the caller of this function has to expect not only sdp-records, but also this two-tuple construct.</source>
          <target state="translated">Al decodificar &lt;code&gt;property_group()&lt;/code&gt; o &lt;code&gt;property_groups()&lt;/code&gt; , aquellas construcciones de par&amp;aacute;metros de propiedad que no se pueden decodificar (ya sea debido a un error de decodificaci&amp;oacute;n o porque son desconocidas), se devolver&amp;aacute;n como dos tuplas. El primer elemento del cual ser&amp;aacute; el par&amp;aacute;metro de propiedad (no codificado) y el otro el motivo real. Esto significa que la persona que llama a esta funci&amp;oacute;n tiene que esperar no solo sdp-records, sino tambi&amp;eacute;n esta construcci&amp;oacute;n de dos tuplas.</target>
        </trans-unit>
        <trans-unit id="17f3e727c9b04040e7e330882d55b9758d892ab6" translate="yes" xml:space="preserve">
          <source>When decoding a type that uses an extensible set constraint, it is always possible that the value in field &lt;code&gt;UNIQUE&lt;/code&gt; is unknown (that is, the type has been encoded with a later version of the ASN.1 specification). The unencoded data is then returned wrapped in a tuple as follows:</source>
          <target state="translated">Al decodificar un tipo que utiliza una restricci&amp;oacute;n de conjunto extensible, siempre es posible que el valor en el campo &lt;code&gt;UNIQUE&lt;/code&gt; sea ​​desconocido (es decir, el tipo se ha codificado con una versi&amp;oacute;n posterior de la especificaci&amp;oacute;n ASN.1). Los datos no codificados se devuelven envueltos en una tupla de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="15c1a9e3a07dbc42bbebe73b1a8cb57a2a65f591" translate="yes" xml:space="preserve">
          <source>When decoding binaries from untrusted sources, consider using &lt;code&gt;binary_to_term/2&lt;/code&gt; to prevent Denial of Service attacks.</source>
          <target state="translated">Al decodificar binarios de fuentes no confiables, considere usar &lt;code&gt;binary_to_term/2&lt;/code&gt; para prevenir ataques de denegaci&amp;oacute;n de servicio.</target>
        </trans-unit>
        <trans-unit id="d0e0e586b31755d07f5d7b42305304a2d4527232" translate="yes" xml:space="preserve">
          <source>When decoding, optional fields will be omitted from the map:</source>
          <target state="translated">Al decodificar,los campos opcionales serán omitidos del mapa:</target>
        </trans-unit>
        <trans-unit id="e2aad35acaab6959e7cb6145c3615cfd817ae41a" translate="yes" xml:space="preserve">
          <source>When describing a set of functions (that is, a module, a part of a module, or an application), executing in a process and wanting to use a ddll-driver, we use the term &lt;strong&gt;user&lt;/strong&gt;. A process can have many users (different modules needing the same driver) and many processes running the same code, making up many &lt;strong&gt;users&lt;/strong&gt; of a driver.</source>
          <target state="translated">Cuando describimos un conjunto de funciones (es decir, un m&amp;oacute;dulo, una parte de un m&amp;oacute;dulo o una aplicaci&amp;oacute;n), la ejecuci&amp;oacute;n de un proceso y queremos utilizar un controlador ddll, usamos el t&amp;eacute;rmino &lt;strong&gt;usuario&lt;/strong&gt; . Un proceso puede tener muchos usuarios (diferentes m&amp;oacute;dulos que necesitan el mismo controlador) y muchos procesos que ejecutan el mismo c&amp;oacute;digo, lo que constituye muchos &lt;strong&gt;usuarios&lt;/strong&gt; de un controlador.</target>
        </trans-unit>
        <trans-unit id="37ad55aab42043a1210e11879b193d589f2174c4" translate="yes" xml:space="preserve">
          <source>When determining which run queue to choose we need to read the fixed balancing information that we moved out of the run queues. This information is global, read only between load balancing operations, but will be changed during a load balancing. We do not want to introduce a global lock that needs to be acquired when accessing this information. A reader optimized rwlock could avoid some of the overhead since the data is most frequently read, but it would unavoidably cause disruption during load balancing, since this information is very frequently read. The likelihood of a large disruption due to this also increase as number of schedulers grows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d599e465efb7551b80d5232a1bfe503d0d783500" translate="yes" xml:space="preserve">
          <source>When developing with Erlang/OTP you usually test your programs from the interactive shell (see &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;) where you can call individual functions. There is also a number of tools available, such as the graphical &lt;a href=&quot;lib/debugger-4.2.5/doc/html/index&quot;&gt;Debugger&lt;/a&gt; and the &lt;a href=&quot;lib/observer-2.8/doc/html/index&quot;&gt;Observer tool&lt;/a&gt; for inspection of system information, ets and mnesia tables etc.</source>
          <target state="translated">Al desarrollar con Erlang / OTP, normalmente prueba sus programas desde el shell interactivo (consulte &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt;Introducci&amp;oacute;n a Erlang&lt;/a&gt; ) donde puede llamar a funciones individuales. Tambi&amp;eacute;n hay una serie de herramientas disponibles, como el &lt;a href=&quot;lib/debugger-4.2.5/doc/html/index&quot;&gt;depurador&lt;/a&gt; gr&amp;aacute;fico y la &lt;a href=&quot;lib/observer-2.8/doc/html/index&quot;&gt;herramienta Observer&lt;/a&gt; para la inspecci&amp;oacute;n de la informaci&amp;oacute;n del sistema, tablas ets y mnesia, etc.</target>
        </trans-unit>
        <trans-unit id="421fcf6b7523386346f2d7d3a8c1e4d4d970c3ce" translate="yes" xml:space="preserve">
          <source>When developing with Erlang/OTP you usually test your programs from the interactive shell (see &lt;a href=&quot;doc/getting_started/users_guide&quot;&gt; Getting Started With Erlang&lt;/a&gt;) where you can call individual functions. There is also a number of tools available, such as the graphical &lt;a href=&quot;lib/debugger-5.0/doc/html/index&quot;&gt;Debugger&lt;/a&gt; and the &lt;a href=&quot;lib/observer-2.9.5/doc/html/index&quot;&gt;Observer tool&lt;/a&gt; for inspection of system information, ets and mnesia tables etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf2dfb99c11e0b6eebdf245aebada381fb9ab39" translate="yes" xml:space="preserve">
          <source>When disabling trace, the option must match the type of trace set on the function. That is, local tracing must be disabled with option &lt;code&gt;local&lt;/code&gt; and global tracing with option &lt;code&gt;global&lt;/code&gt; (or no option), and so on.</source>
          <target state="translated">Al deshabilitar el rastreo, la opci&amp;oacute;n debe coincidir con el tipo de rastreo establecido en la funci&amp;oacute;n. Es decir, el rastreo local debe deshabilitarse con la opci&amp;oacute;n rastreo &lt;code&gt;local&lt;/code&gt; y global con la opci&amp;oacute;n &lt;code&gt;global&lt;/code&gt; (o sin opci&amp;oacute;n), y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="8e262a7b92cfd57af3c5fc673b211db44e0d61d2" translate="yes" xml:space="preserve">
          <source>When doing &lt;code&gt;make install&lt;/code&gt; and the default installation prefix is used, relative symbolic links will be created from &lt;code&gt;/usr/local/bin&lt;/code&gt; to all public Erlang/OTP executables in &lt;code&gt;/usr/local/lib/erlang/bin&lt;/code&gt;. The installation phase will try to create relative symbolic links as long as &lt;code&gt;--bindir&lt;/code&gt; and the Erlang bin directory, located under &lt;code&gt;--libdir&lt;/code&gt;, both have &lt;code&gt;--exec-prefix&lt;/code&gt; as prefix. Where &lt;code&gt;--exec-prefix&lt;/code&gt; defaults to &lt;code&gt;--prefix&lt;/code&gt;. &lt;code&gt;--prefix&lt;/code&gt;, &lt;code&gt;--exec-prefix&lt;/code&gt;, &lt;code&gt;--bindir&lt;/code&gt;, and &lt;code&gt;--libdir&lt;/code&gt; are all arguments that can be passed to &lt;code&gt;configure&lt;/code&gt;. One can force relative, or absolute links by passing &lt;code&gt;BINDIR_SYMLINKS=relative|absolute&lt;/code&gt; as arguments to &lt;code&gt;make&lt;/code&gt; during the install phase. Note that such a request might cause a failure if the request cannot be satisfied.</source>
          <target state="translated">Al hacer &lt;code&gt;make install&lt;/code&gt; y se usa el prefijo de instalaci&amp;oacute;n predeterminado, se crear&amp;aacute;n enlaces simb&amp;oacute;licos relativos desde &lt;code&gt;/usr/local/bin&lt;/code&gt; a todos los ejecutables p&amp;uacute;blicos de Erlang / OTP en &lt;code&gt;/usr/local/lib/erlang/bin&lt;/code&gt; . La fase de instalaci&amp;oacute;n intentar&amp;aacute; crear enlaces simb&amp;oacute;licos relativos siempre que &lt;code&gt;--bindir&lt;/code&gt; y el directorio bin de Erlang, ubicado bajo &lt;code&gt;--libdir&lt;/code&gt; , tengan ambos &lt;code&gt;--exec-prefix&lt;/code&gt; como prefijo. Donde &lt;code&gt;--exec-prefix&lt;/code&gt; tiene como valor predeterminado &lt;code&gt;--prefix&lt;/code&gt; . &lt;code&gt;--prefix&lt;/code&gt; , &lt;code&gt;--exec-prefix&lt;/code&gt; , &lt;code&gt;--bindir&lt;/code&gt; y &lt;code&gt;--libdir&lt;/code&gt; son todos argumentos que se pueden pasar para &lt;code&gt;configure&lt;/code&gt; . Se pueden forzar enlaces relativos o absolutos pasando &lt;code&gt;BINDIR_SYMLINKS=relative|absolute&lt;/code&gt; como argumentos para &lt;code&gt;make&lt;/code&gt; durante la fase de instalaci&amp;oacute;n. Tenga en cuenta que dicha solicitud puede provocar un error si no se puede satisfacer la solicitud.</target>
        </trans-unit>
        <trans-unit id="a2786f78387349e137e785c359068f69a038e2e9" translate="yes" xml:space="preserve">
          <source>When dumping the table, some information about the table is dumped to a header at the beginning of the dump. This information contains data about the table type, name, protection, size, version, and if it is a named table. It also contains notes about what extended information is added to the file, which can be a count of the objects in the file or a MD5 sum of the header and records in the file.</source>
          <target state="translated">Cuando se vuelca la tabla,alguna información sobre la tabla se vuelca en un encabezado al principio del volcado.Esta información contiene datos sobre el tipo de tabla,el nombre,la protección,el tamaño,la versión y si se trata de una tabla con nombre.También contiene notas sobre la información extendida que se agrega al archivo,que puede ser un recuento de los objetos del archivo o una suma MD5 del encabezado y los registros del archivo.</target>
        </trans-unit>
        <trans-unit id="8bb8dc80e08844ad0426660bafbab7a03b0891ac" translate="yes" xml:space="preserve">
          <source>When editing normal text in text mode you can let Emacs reformat the text by the &lt;code&gt;fill-paragraph&lt;/code&gt; command. This command will not work for comments since it will treat the comment characters as words.</source>
          <target state="translated">Al editar texto normal en modo texto, puede permitir que Emacs vuelva a formatear el texto con el comando de &lt;code&gt;fill-paragraph&lt;/code&gt; . Este comando no funcionar&amp;aacute; para comentarios ya que tratar&amp;aacute; los caracteres de comentario como palabras.</target>
        </trans-unit>
        <trans-unit id="a631e39dc1cabb5e02c4412996c54930451ee0dc" translate="yes" xml:space="preserve">
          <source>When elements are continuously inserted by threads not owning the allocator instance, the thread owning the allocator instance will be able to work more or less undisturbed by other threads at the head end of the list. At the tail end large amounts of simultaneous inserts may cause contention, but we reduce such contention by spreading inserts of new elements near the end instead of requiring all new elements to be inserted at the end.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="385563ac3b6af3039b39f79f5505ddf536cbbbf9" translate="yes" xml:space="preserve">
          <source>When enabled, it prevents decoding data that can be used to attack the Erlang system. In the event of receiving unsafe data, decoding fails with a &lt;code&gt;badarg&lt;/code&gt; error.</source>
          <target state="translated">Cuando est&amp;aacute; habilitado, evita la decodificaci&amp;oacute;n de datos que se pueden usar para atacar el sistema Erlang. En el caso de recibir datos no seguros, la decodificaci&amp;oacute;n falla con un error de &lt;code&gt;badarg&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e911575fa07d922476972d70c313e02f9b293dc" translate="yes" xml:space="preserve">
          <source>When enabling an &lt;code&gt;Item&lt;/code&gt; that represents a group of processes, the &lt;code&gt;Item&lt;/code&gt; is enabled on all nodes added with the &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Cuando se habilita un &lt;code&gt;Item&lt;/code&gt; que representa un grupo de procesos, el &lt;code&gt;Item&lt;/code&gt; se habilita en todos los nodos agregados con la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;#n-1&quot;&gt;n/1&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;#tracer-3&quot;&gt;tracer/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="961f18823d723f8de73592aaed24463820242f21" translate="yes" xml:space="preserve">
          <source>When encoding action requests for one transaction, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When encoding action requests for several transactions, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="translated">Al codificar solicitudes de acci&amp;oacute;n para una transacci&amp;oacute;n, las &lt;code&gt;Actions&lt;/code&gt; deben ser &lt;code&gt;action_reqs()&lt;/code&gt; . Al codificar solicitudes de acci&amp;oacute;n para varias transacciones, las &lt;code&gt;Actions&lt;/code&gt; deben ser &lt;code&gt;[action_reqs()]&lt;/code&gt; . Cada elemento de la lista es parte de una transacci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c3e08a1905a5b3e0dc65abec6d55dd6312a7226f" translate="yes" xml:space="preserve">
          <source>When evaluating a digit map, a state machine waits for timeouts and letters reported by megaco:report_digit_event/2. The length of the various timeouts are defined in the digit_map_value() record.</source>
          <target state="translated">Cuando se evalúa un mapa de dígitos,una máquina de estado espera por los tiempos de espera y las letras reportadas por megaco:report_digit_event/2.La duración de los distintos tiempos de espera se definen en el registro digit_map_value().</target>
        </trans-unit>
        <trans-unit id="bd3c6596324fcf3c283be7c0b3555d1b46a28bd6" translate="yes" xml:space="preserve">
          <source>When evaluating an expression, the operator with the highest priority is evaluated first. Operators with the same priority are evaluated according to their associativity.</source>
          <target state="translated">Al evaluar una expresión,se evalúa primero el operador de mayor prioridad.Los operadores con la misma prioridad se evalúan según su asociatividad.</target>
        </trans-unit>
        <trans-unit id="1250bb19a7c4cde6aa87a09dc8b61c235001dd61" translate="yes" xml:space="preserve">
          <source>When executing in an emulator thread, it is &lt;strong&gt;very important&lt;/strong&gt; that you unlock &lt;strong&gt;all&lt;/strong&gt; locks you have locked before letting the thread out of your control; otherwise you are &lt;strong&gt;very likely&lt;/strong&gt; to deadlock the whole emulator.</source>
          <target state="translated">Cuando se ejecuta en un subproceso de emulador, es &lt;strong&gt;muy importante&lt;/strong&gt; que desbloquee &lt;strong&gt;todos los&lt;/strong&gt; bloqueos que ha bloqueado antes de dejar el subproceso fuera de su control; de lo contrario, es &lt;strong&gt;muy probable&lt;/strong&gt; que se bloquee todo el emulador.</target>
        </trans-unit>
        <trans-unit id="3d063e02c2be3b7faac0250e13934a29e88d4cb4" translate="yes" xml:space="preserve">
          <source>When executing the &lt;code&gt;etop&lt;/code&gt; script, configuration parameters can be specified as command-line options, for example, &lt;code&gt;etop -node testnode@myhost -setcookie MyCookie&lt;/code&gt;. The following configuration parameters exist for the tool:</source>
          <target state="translated">Al ejecutar el script &lt;code&gt;etop&lt;/code&gt; , los par&amp;aacute;metros de configuraci&amp;oacute;n se pueden especificar como opciones de l&amp;iacute;nea de comandos, por ejemplo, &lt;code&gt;etop -node testnode@myhost -setcookie MyCookie&lt;/code&gt; . Existen los siguientes par&amp;aacute;metros de configuraci&amp;oacute;n para la herramienta:</target>
        </trans-unit>
        <trans-unit id="9eb714d64a16860edb9466fdec5e16164e92007d" translate="yes" xml:space="preserve">
          <source>When executing within a CTH, all timetraps are shut off. So if your CTH never returns, the entire test run is stalled.</source>
          <target state="translated">Cuando se ejecuta dentro de un CTH,todas las trampas de tiempo se cierran.Así que si tu CTH nunca regresa,toda la ejecución de la prueba se paraliza.</target>
        </trans-unit>
        <trans-unit id="da9d0d440af4853f4323fd874ba74d7e15beec93" translate="yes" xml:space="preserve">
          <source>When expanding macros, &lt;strong&gt;beam_makeops&lt;/strong&gt; wraps the expansion in a &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt; wrapper unless &lt;strong&gt;beam_makeops&lt;/strong&gt; can clearly see that no wrapper is needed. In this case, the wrapper is needed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407f5e1130fa4448aafc45d4cd243aed3adf7a96" translate="yes" xml:space="preserve">
          <source>When failing, all three functions set &lt;code&gt;erl_errno&lt;/code&gt; to one of:</source>
          <target state="translated">Cuando falla, las tres funciones establecen &lt;code&gt;erl_errno&lt;/code&gt; en una de las siguientes:</target>
        </trans-unit>
        <trans-unit id="400a4d66676f58ccbe4f8fa4a7575a4ce987604e" translate="yes" xml:space="preserve">
          <source>When fetching a carrier from the pool, employment may change and further deallocations in the carrier will be redirected to the new employer using the delayed dealloc functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b47ee65ea9b082b925d4c051f321ad5844fe95" translate="yes" xml:space="preserve">
          <source>When fragments are added or deleted, &lt;code&gt;Mnesia&lt;/code&gt; automatically propagates the operation to all fragmented tables that have a foreign key referring to this table. Instead of using the record key to determine which fragment to access, the value of field &lt;code&gt;Attr&lt;/code&gt; is used. This feature makes it possible to colocate records automatically in different tables to the same node. &lt;code&gt;foreign_key&lt;/code&gt; defaults to &lt;code&gt;undefined&lt;/code&gt;. However, if the foreign key is set to something else, it causes the default values of the other fragmentation properties to be the same values as the actual fragmentation properties of the foreign table.</source>
          <target state="translated">Cuando se agregan o eliminan &lt;code&gt;Mnesia&lt;/code&gt; , Mnesia propaga autom&amp;aacute;ticamente la operaci&amp;oacute;n a todas las tablas fragmentadas que tienen una clave externa que hace referencia a esta tabla. En lugar de utilizar la clave de registro para determinar a qu&amp;eacute; fragmento acceder, se utiliza el valor del campo &lt;code&gt;Attr&lt;/code&gt; . Esta caracter&amp;iacute;stica permite colocar registros autom&amp;aacute;ticamente en diferentes tablas en el mismo nodo. &lt;code&gt;foreign_key&lt;/code&gt; predeterminado &lt;code&gt;undefined&lt;/code&gt; . Sin embargo, si la clave externa se establece en otra cosa, hace que los valores predeterminados de las otras propiedades de fragmentaci&amp;oacute;n sean los mismos valores que las propiedades de fragmentaci&amp;oacute;n reales de la tabla externa.</target>
        </trans-unit>
        <trans-unit id="fd8c83393a4a4d4f9084b92af713908505d82502" translate="yes" xml:space="preserve">
          <source>When garbage collecting a heap (young or old) all literals are left in place and not copied. To figure out if a term should be copied or not when doing a garbage collection the following pseudo code is used:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="333f980f252538f0da8f8c81fee6306212deb2e4" translate="yes" xml:space="preserve">
          <source>When generating the &lt;code&gt;relup&lt;/code&gt; file, &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; ensures that there is only one &lt;code&gt;restart_emulator&lt;/code&gt; instruction and that it is the last instruction in the &lt;code&gt;relup&lt;/code&gt; file.</source>
          <target state="translated">Al generar el archivo &lt;code&gt;relup&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;systools#make_relup-3&quot;&gt;systools:make_relup/3,4&lt;/a&gt;&lt;/code&gt; asegura que solo haya una instrucci&amp;oacute;n &lt;code&gt;restart_emulator&lt;/code&gt; y que sea la &amp;uacute;ltima instrucci&amp;oacute;n en el archivo &lt;code&gt;relup&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80c099bc81dcbffa43792d0bf735abab5b902a73" translate="yes" xml:space="preserve">
          <source>When implementing a &lt;code&gt;ssh&lt;/code&gt; subsystem for daemons, use &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;-behaviour(ssh_server_channel)&lt;/a&gt;&lt;/code&gt; (Replaces ssh_daemon_channel) instead.</source>
          <target state="translated">Al implementar un subsistema &lt;code&gt;ssh&lt;/code&gt; para demonios, utilice &lt;code&gt;&lt;a href=&quot;ssh_server_channel&quot;&gt;-behaviour(ssh_server_channel)&lt;/a&gt;&lt;/code&gt; (Reemplaza ssh_daemon_channel) en su lugar.</target>
        </trans-unit>
        <trans-unit id="f6478258292a96422b7f4fde5f2a8507d5b2f75a" translate="yes" xml:space="preserve">
          <source>When implementing a client subsystem handler, use &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;-behaviour(ssh_client_channel)&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">Al implementar un controlador de subsistema de cliente, utilice &lt;code&gt;&lt;a href=&quot;ssh_client_channel&quot;&gt;-behaviour(ssh_client_channel)&lt;/a&gt;&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="9c88931238cddc153c190e4becfbe016ac63c629" translate="yes" xml:space="preserve">
          <source>When implementing this there are a couple of important properties that we either need, or want to preserve:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0817fdff736a7fb006dde9156f2e254a826ee1a2" translate="yes" xml:space="preserve">
          <source>When importing MIBs, ensure that the imported MIBs as well as the importing MIB are compiled using the same version of the SNMP-compiler.</source>
          <target state="translated">Cuando se importen MIB,asegúrese de que tanto las MIB importadas como las MIB de importación se compilen con la misma versión del compilador SNMP.</target>
        </trans-unit>
        <trans-unit id="f3533c679bf3bb0ac2f26fbc98c32fe5665f503a" translate="yes" xml:space="preserve">
          <source>When information is received. This is typically when a received message is matched out in a receive expression, but also when information is received in other ways.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d86af8d65c195f9b07f8aefb0aff8be5ef9554d" translate="yes" xml:space="preserve">
          <source>When inputting data using sql_query/[2,3] the values will always be in string format as they are part of an SQL-query. Example:</source>
          <target state="translated">Cuando se introducen datos utilizando sql_query/[2,3]los valores siempre estarán en formato de cadena ya que forman parte de una consulta SQL.Ejemplo:</target>
        </trans-unit>
        <trans-unit id="e9d487ff83b4df8e77a1b3e23e8b5d610747cfbb" translate="yes" xml:space="preserve">
          <source>When inserting a new element we search for a place to insert the element by only following &lt;code&gt;next&lt;/code&gt; pointers, and we always begin by skipping the first element encountered. When trying to fetch an element we do the same thing, but instead only follow &lt;code&gt;prev&lt;/code&gt; pointers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7655025ad787fb06a2ece92051383c668f2e0772" translate="yes" xml:space="preserve">
          <source>When inserting an element one will try to write a pointer to the new element in the next pointer of the element pointed to by the last pointer. This is done using an atomic compare and swap that expects the next pointer to be &lt;code&gt;NULL&lt;/code&gt;. If this succeeds the thread performing this operation moves the last pointer to point to the newly inserted element.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a61084660618420bf57899c1e143bbdfd319d4" translate="yes" xml:space="preserve">
          <source>When installing a release, the application specifications are automatically updated before evaluating the &lt;code&gt;relup&lt;/code&gt; script. Thus, no instructions are needed in the &lt;code&gt;.appup&lt;/code&gt; file:</source>
          <target state="translated">Al instalar una versi&amp;oacute;n, las especificaciones de la aplicaci&amp;oacute;n se actualizan autom&amp;aacute;ticamente antes de evaluar el script de &lt;code&gt;relup&lt;/code&gt; . Por lo tanto, no se necesitan instrucciones en el archivo &lt;code&gt;.appup&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ab36faf918b13f9650566e7cda312d53b2b058cb" translate="yes" xml:space="preserve">
          <source>When instrumentation of the emulator is enabled, the emulator uses more memory and runs slower.</source>
          <target state="translated">Cuando se habilita la instrumentación del emulador,éste utiliza más memoria y funciona más lentamente.</target>
        </trans-unit>
        <trans-unit id="613cb49badd27e8334ffae06e691a346b0c3156f" translate="yes" xml:space="preserve">
          <source>When interpreting the data for a process, it is helpful to know that anonymous function objects (funs) are given the following:</source>
          <target state="translated">Al interpretar los datos de un proceso,es útil saber que a los objetos de función anónima (divertidos)se les da lo siguiente:</target>
        </trans-unit>
        <trans-unit id="a7a1e6f2364e14a4f8731ff03ef081c6c153b8e5" translate="yes" xml:space="preserve">
          <source>When it comes to pure encode/decode performance, it turns out that:</source>
          <target state="translated">Cuando se trata de puro rendimiento de codificación/decodificación,resulta que:</target>
        </trans-unit>
        <trans-unit id="fdb9a1b728613db78be0dae343529296127017c3" translate="yes" xml:space="preserve">
          <source>When it is guaranteed that all trace messages are delivered to the tracer up to the point that &lt;code&gt;Tracee&lt;/code&gt; reached at the time of the call to &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt;, then a &lt;code&gt;{trace_delivered, Tracee, Ref}&lt;/code&gt; message is sent to the caller of &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; .</source>
          <target state="translated">Cuando se garantiza que todos los mensajes de seguimiento se env&amp;iacute;an al trazador hasta el punto que &lt;code&gt;Tracee&lt;/code&gt; alcanz&amp;oacute; en el momento de la llamada a &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; , se &lt;code&gt;{trace_delivered, Tracee, Ref}&lt;/code&gt; un mensaje {trace_delivered, Tracee, Ref} a la persona que llama de &lt;code&gt;erlang:trace_delivered(Tracee)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6efe9163e0ae5672fec51b923b5f0a3fddf22450" translate="yes" xml:space="preserve">
          <source>When libraries and escripts are expanded, the names of their contained applications will be displayed. Double click on an application name to launch an application window.</source>
          <target state="translated">Cuando se amplíen las bibliotecas y los escripts,se mostrarán los nombres de las aplicaciones que contienen.Haga doble clic en el nombre de una aplicación para abrir una ventana de aplicación.</target>
        </trans-unit>
        <trans-unit id="8ec607efa45c31ad1357f20a7d66c6c141bb9cf2" translate="yes" xml:space="preserve">
          <source>When linking:</source>
          <target state="translated">Al vincularse:</target>
        </trans-unit>
        <trans-unit id="b2385c5f14aa595da46fbd07c32eb8cdc1c9ac6f" translate="yes" xml:space="preserve">
          <source>When list of processes is passed as &lt;code&gt;PidOrPids&lt;/code&gt;, function returns &lt;code&gt;not_joined&lt;/code&gt; only when all processes of the list are not joined.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d08f2f18c94939c7eb816f59b144c9e39119701b" translate="yes" xml:space="preserve">
          <source>When loading, function &lt;code&gt;load/2&lt;/code&gt; returns &lt;code&gt;ok&lt;/code&gt; when any instance of the driver is present. Thus, if a driver is waiting to get unloaded (because of open ports), it simply changes state to no longer need unloading.</source>
          <target state="translated">Al cargar, la funci&amp;oacute;n &lt;code&gt;load/2&lt;/code&gt; devuelve &lt;code&gt;ok&lt;/code&gt; cuando hay una instancia del controlador presente. Por lo tanto, si un controlador est&amp;aacute; esperando descargarse (debido a puertos abiertos), simplemente cambia de estado para que ya no necesite descargarse.</target>
        </trans-unit>
        <trans-unit id="24765533bb74fe1f717eba248fca4a267e2412ee" translate="yes" xml:space="preserve">
          <source>When looking at memory usage in a running system the most basic function to get information from is &lt;code&gt; erlang:memory()&lt;/code&gt;. It returns the current memory usage of the system. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of where memory is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65fab8b9afb79981ea75c2c9f545c0487fc0a213" translate="yes" xml:space="preserve">
          <source>When looking at memory usage in a running system the most basic function to get information from is &lt;code&gt;erlang:memory()&lt;/code&gt;. It returns the current memory usage of the system. &lt;code&gt;instrument(3)&lt;/code&gt; can be used to get a more detailed breakdown of where memory is used.</source>
          <target state="translated">Al observar el uso de la memoria en un sistema en ejecuci&amp;oacute;n, la funci&amp;oacute;n m&amp;aacute;s b&amp;aacute;sica para obtener informaci&amp;oacute;n es &lt;code&gt;erlang:memory()&lt;/code&gt; . Devuelve el uso de memoria actual del sistema. &lt;code&gt;instrument(3)&lt;/code&gt; se puede utilizar para obtener un desglose m&amp;aacute;s detallado de d&amp;oacute;nde se utiliza la memoria.</target>
        </trans-unit>
        <trans-unit id="48de25c51d5ee0ecfba79d1f31f96c3371dd4574" translate="yes" xml:space="preserve">
          <source>When looking at this very simple solution with very little overhead you might wonder why we didn't implement it this way from the beginning. It all boils down to the read operation of the pointer. We need some way to know that it is safe to access the memory pointed to. One way of doing this is to place a reference counter in the process structure. Increment of the reference counter at lookup needs to be done atomically with the lookup. A lock can typically provide this service for us, which was the approach we previously used. Another approach could be to co-locate the reference counter with the pointer in the table. The major problem with this approach is the modifications of the reference counter. This since these modification would have to be communicated between all involved processor cause contention on the cache line containing the reference counter. The new lookup approach above is possible since we can use the &quot;thread progress&quot; functionality in order to determine when it is safe to deallocate the process structure. We'll get back to this when describing deletion in the table.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afc0303546ea4a5cee3b6a223eb3288b9d2ea037" translate="yes" xml:space="preserve">
          <source>When macros are expanded in expressions the macro calls are replaced by the macro value without any form of quoting or enclosing in parentheses.</source>
          <target state="translated">Cuando las macros se expanden en expresiones,las llamadas de macro son reemplazadas por el valor de macro sin ninguna forma de citar o encerrar entre paréntesis.</target>
        </trans-unit>
        <trans-unit id="6e14461d99df8d7f5bd6dbaee93c610c2ce18da3" translate="yes" xml:space="preserve">
          <source>When many types (or another ASN.1 entity) only differ in some minor cases, but the structure of the types is similar, only one general type can be defined and the differences can be supplied through parameters.</source>
          <target state="translated">Cuando muchos tipos (u otra entidad ASN.1)sólo difieren en algunos casos menores,pero la estructura de los tipos es similar,sólo se puede definir un tipo general y las diferencias pueden ser suministradas a través de parámetros.</target>
        </trans-unit>
        <trans-unit id="e3e3f53fcfe03af37581eeb29d3a1f8a21d06868" translate="yes" xml:space="preserve">
          <source>When matched against a term, both &lt;code&gt;Pattern1&lt;/code&gt; and &lt;code&gt;Pattern2&lt;/code&gt; are matched against the term. The idea behind this feature is to avoid reconstruction of terms.</source>
          <target state="translated">Cuando se comparan con un t&amp;eacute;rmino, tanto el &lt;code&gt;Pattern1&lt;/code&gt; como el &lt;code&gt;Pattern2&lt;/code&gt; se comparan con el t&amp;eacute;rmino. La idea detr&amp;aacute;s de esta caracter&amp;iacute;stica es evitar la reconstrucci&amp;oacute;n de t&amp;eacute;rminos.</target>
        </trans-unit>
        <trans-unit id="70ef1970aabf29043b85da367698cefcc4f383ae" translate="yes" xml:space="preserve">
          <source>When matching &lt;code&gt;Value&lt;/code&gt;, value must be either a variable or an integer, or a floating point literal. Expressions are not allowed.</source>
          <target state="translated">Al hacer coincidir el &lt;code&gt;Value&lt;/code&gt; , el valor debe ser una variable o un entero, o un literal de coma flotante. No se permiten expresiones.</target>
        </trans-unit>
        <trans-unit id="919226a6786be88542935b4ae72b62f44ea75480" translate="yes" xml:space="preserve">
          <source>When matching strings, the following is a valid pattern:</source>
          <target state="translated">Cuando se comparan las cuerdas,el siguiente es un patrón válido:</target>
        </trans-unit>
        <trans-unit id="d1c82c501be92ba824ae89344ef75c4d9af9bf67" translate="yes" xml:space="preserve">
          <source>When megaco fails to send the reply (see &lt;code&gt;&lt;a href=&quot;#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt;), for whatever reason.</source>
          <target state="translated">Cuando megaco no env&amp;iacute;a la respuesta (ver &lt;code&gt;&lt;a href=&quot;#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; ), por cualquier motivo.</target>
        </trans-unit>
        <trans-unit id="acae380ca138d49866a8d2225bb9fdf2866a8ef8" translate="yes" xml:space="preserve">
          <source>When messages are &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;passed between connected nodes&lt;/a&gt;&lt;/code&gt; and a &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; is used, the first byte containing the version number (131) is omitted from the terms that follow the distribution header. This is because the version number is implied by the version number in the distribution header.</source>
          <target state="translated">Cuando se &lt;code&gt;&lt;a href=&quot;erl_dist_protocol#connected_nodes&quot;&gt;passed between connected nodes&lt;/a&gt;&lt;/code&gt; mensajes entre nodos conectados y se usa un &lt;code&gt;&lt;a href=&quot;#distribution_header&quot;&gt;distribution header&lt;/a&gt;&lt;/code&gt; , el primer byte que contiene el n&amp;uacute;mero de versi&amp;oacute;n (131) se omite de los t&amp;eacute;rminos que siguen al encabezado de distribuci&amp;oacute;n. Esto se debe a que el n&amp;uacute;mero de versi&amp;oacute;n est&amp;aacute; impl&amp;iacute;cito en el n&amp;uacute;mero de versi&amp;oacute;n en el encabezado de distribuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="787e404397583f253bb775c283cf222bacb2db6c" translate="yes" xml:space="preserve">
          <source>When monitoring is requested, and a corresponding &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt; would be returned, the function instead returns a tuple &lt;code&gt;{ok, PendingStatus, reference()}&lt;/code&gt; and the process then gets a monitor message later, when the driver gets loaded. The monitor message to expect is described in the function description of &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando se solicita la supervisi&amp;oacute;n y se &lt;code&gt;{ok, pending_driver}&lt;/code&gt; un {ok, pendiente_controlador} o &lt;code&gt;{ok, pending_process}&lt;/code&gt; correspondiente, la funci&amp;oacute;n devuelve una tupla &lt;code&gt;{ok, PendingStatus, reference()}&lt;/code&gt; y el proceso recibe un mensaje de monitor m&amp;aacute;s tarde, el controlador se carga. El mensaje de monitor que se espera se describe en la descripci&amp;oacute;n de la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;#monitor-2&quot;&gt;monitor/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="efb7c3fa2502fdd9d0754635086f8f9899582889" translate="yes" xml:space="preserve">
          <source>When multiple test specification files are specified at startup (either with &lt;code&gt;ct_run -spec file1 file2 ...&lt;/code&gt; or &lt;code&gt;ct:run_test([{spec, [File1,File2,...]}])&lt;/code&gt;), &lt;code&gt;Common Test&lt;/code&gt; either executes one test run per specification file, or joins the files and performs all tests within one single test run. The first behavior is the default one. The latter requires that start flag/option &lt;code&gt;join_specs&lt;/code&gt; is provided, for example, &lt;code&gt;run_test -spec ./my_tests1.ts ./my_tests2.ts -join_specs&lt;/code&gt;.</source>
          <target state="translated">Cuando se especifican varios archivos de especificaci&amp;oacute;n de prueba al inicio (ya sea con &lt;code&gt;ct_run -spec file1 file2 ...&lt;/code&gt; o &lt;code&gt;ct:run_test([{spec, [File1,File2,...]}])&lt;/code&gt; ), &lt;code&gt;Common Test&lt;/code&gt; ejecuta una prueba por archivo de especificaci&amp;oacute;n, o une los archivos y realiza todas las pruebas en una &amp;uacute;nica ejecuci&amp;oacute;n de prueba. El primer comportamiento es el predeterminado. Esto &amp;uacute;ltimo requiere que se proporcione el indicador de inicio / opci&amp;oacute;n &lt;code&gt;join_specs&lt;/code&gt; , por ejemplo, &lt;code&gt;run_test -spec ./my_tests1.ts ./my_tests2.ts -join_specs&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86c9c01ac51912ffee582ab560019f3600e62f5e" translate="yes" xml:space="preserve">
          <source>When multiple threads access the same data structure you often need to know when all threads have completed their accesses. For example, in order to know when it is safe to deallocate the data structure. One simple way to accomplish this is to reference count all accesses to the data structure. The problem with this approach is that the cache line where the reference counter is located needs to be communicated between all involved processors. Such communication can become extremely expensive and will scale poorly if the reference counter is frequently accessed. That is, we want to use some other approach of keeping track of threads than reference counting.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d4d379ce1acc3e58649f3f6e5610dec08b734cc" translate="yes" xml:space="preserve">
          <source>When new nodes are added to the network, they are informed of the globally registered names that already exist. The network is also informed of any global names in newly connected nodes. If any name clashes are discovered, function &lt;code&gt;Resolve&lt;/code&gt; is called. Its purpose is to decide which pid is correct. If the function crashes, or returns anything other than one of the pids, the name is unregistered. This function is called once for each name clash.</source>
          <target state="translated">Cuando se agregan nuevos nodos a la red, se les informa de los nombres registrados globalmente que ya existen. La red tambi&amp;eacute;n recibe informaci&amp;oacute;n sobre cualquier nombre global en los nodos reci&amp;eacute;n conectados. Si se descubre alg&amp;uacute;n conflicto de nombres, se llama a la funci&amp;oacute;n &lt;code&gt;Resolve&lt;/code&gt; r . Su prop&amp;oacute;sito es decidir qu&amp;eacute; pid es correcto. Si la funci&amp;oacute;n falla o devuelve algo que no sea uno de los pids, se anula el registro del nombre. Esta funci&amp;oacute;n se llama una vez por cada conflicto de nombres.</target>
        </trans-unit>
        <trans-unit id="78f8bd0d1896a4dff8f44b290b2a56e3f9fcb215" translate="yes" xml:space="preserve">
          <source>When one node wants to connect to another node it starts with a &lt;code&gt;PORT_PLEASE2_REQ&lt;/code&gt; request to the EPMD on the host where the node resides to get the distribution port that the node listens to.</source>
          <target state="translated">Cuando un nodo quiere conectarse a otro nodo, comienza con una solicitud &lt;code&gt;PORT_PLEASE2_REQ&lt;/code&gt; al EPMD en el host donde reside el nodo para obtener el puerto de distribuci&amp;oacute;n que escucha el nodo.</target>
        </trans-unit>
        <trans-unit id="733930eec7fc5b747c5c2817c8d2e79c6f4e243c" translate="yes" xml:space="preserve">
          <source>When one of these option changes occurs at top-level (that is, not inside subpattern parentheses), the change applies to the remainder of the pattern that follows.</source>
          <target state="translated">Cuando uno de estos cambios de opción se produce en el nivel superior (es decir,no dentro de los paréntesis del subpatrón),el cambio se aplica al resto del patrón que sigue.</target>
        </trans-unit>
        <trans-unit id="b86cd46910a6aa214f7f42e5ee8633b337f649a0" translate="yes" xml:space="preserve">
          <source>When opening an existing wrap log, it is not necessary to supply a value for option &lt;code&gt;Size&lt;/code&gt;, but any supplied value must equal the current log size, otherwise the tuple &lt;code&gt;{error, {size_mismatch, CurrentSize, NewSize}}&lt;/code&gt; is returned.</source>
          <target state="translated">Al abrir un registro de ajuste existente, no es necesario proporcionar un valor para la opci&amp;oacute;n &lt;code&gt;Size&lt;/code&gt; , pero cualquier valor proporcionado debe ser igual al tama&amp;ntilde;o del registro actual; de lo contrario &lt;code&gt;{error, {size_mismatch, CurrentSize, NewSize}}&lt;/code&gt; la tupla {error, {size_mismatch, CurrentSize, NewSize}} .</target>
        </trans-unit>
        <trans-unit id="2c7edf9e74339539f6cc3b3080ee90687bd35019" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;global&lt;/code&gt; is speciified, the &lt;code&gt;capture&lt;/code&gt; specification affects each match separately, so that:</source>
          <target state="translated">Cuando se especifica la opci&amp;oacute;n &lt;code&gt;global&lt;/code&gt; , la especificaci&amp;oacute;n de &lt;code&gt;capture&lt;/code&gt; afecta a cada coincidencia por separado, de modo que:</target>
        </trans-unit>
        <trans-unit id="35779093faa3e10fba6141595e13648b564ea182" translate="yes" xml:space="preserve">
          <source>When option &lt;code&gt;unicode&lt;/code&gt; is specified, the regular expression is to be specified as a valid Unicode &lt;code&gt;charlist()&lt;/code&gt;, otherwise as any valid &lt;code&gt;iodata()&lt;/code&gt;.</source>
          <target state="translated">Cuando se especifica la opci&amp;oacute;n &lt;code&gt;unicode&lt;/code&gt; , la expresi&amp;oacute;n regular debe especificarse como una lista de caracteres Unicode v&amp;aacute;lida &lt;code&gt;charlist()&lt;/code&gt; , de lo contrario, como cualquier &lt;code&gt;iodata()&lt;/code&gt; v&amp;aacute;lido .</target>
        </trans-unit>
        <trans-unit id="55a165a455c0fbb6c5fe22fe047dc9f316e166c5" translate="yes" xml:space="preserve">
          <source>When ordered to shut down, the &lt;code&gt;gen_statem&lt;/code&gt; then calls callback function &lt;code&gt;terminate(shutdown, State, Data)&lt;/code&gt;.</source>
          <target state="translated">Cuando se le ordena que se apague, &lt;code&gt;gen_statem&lt;/code&gt; luego llama a la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;terminate(shutdown, State, Data)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a6c0af6f0c64d162765f0e344a6e84e0addaa2a2" translate="yes" xml:space="preserve">
          <source>When packaging code using &lt;code&gt;systools&lt;/code&gt;, the code for each application is placed in a separate directory, &lt;code&gt;lib/Application-Vsn&lt;/code&gt;, where &lt;code&gt;Vsn&lt;/code&gt; is the version number.</source>
          <target state="translated">Cuando se empaqueta el c&amp;oacute;digo utilizando &lt;code&gt;systools&lt;/code&gt; , el c&amp;oacute;digo de cada aplicaci&amp;oacute;n se coloca en un directorio separado, &lt;code&gt;lib/Application-Vsn&lt;/code&gt; , donde &lt;code&gt;Vsn&lt;/code&gt; es el n&amp;uacute;mero de versi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9753680bda30c348a14a4334e6baee4da1b60e94" translate="yes" xml:space="preserve">
          <source>When parsing a URI with an unknown scheme (that is, a scheme not found in the scheme defaults), a port number must be provided, otherwise the parsing fails.</source>
          <target state="translated">Al analizar un URI con un esquema desconocido (es decir,un esquema que no se encuentra en los valores predeterminados del esquema),debe proporcionarse un número de puerto;de lo contrario,el análisis fallará.</target>
        </trans-unit>
        <trans-unit id="710f52128840cdac154a523eb3c58c2968f8b895" translate="yes" xml:space="preserve">
          <source>When parts of the MIB are implemented, you recompile it and continue on by using default functions. With this approach, the SNMP agent can be developed incrementally.</source>
          <target state="translated">Cuando se implementan partes de la MIB,se recompila y se continúa usando las funciones predeterminadas.Con este enfoque,el agente SNMP puede desarrollarse de forma incremental.</target>
        </trans-unit>
        <trans-unit id="e91864f69e3643249c414a5ca6b0b38fdf0614ca" translate="yes" xml:space="preserve">
          <source>When performance is of highest priority and you are interested in a limited part of the ASN.1 encoded message before deciding what to do with the rest of it, an option is to decode only this small part. The situation can be a server that has to decide the addressee of a message. The addressee can be interested in the entire message, but the server can be a bottleneck that you want to spare any unnecessary load.</source>
          <target state="translated">Cuando el rendimiento es de máxima prioridad y usted está interesado en una parte limitada del mensaje codificado ASN.1 antes de decidir qué hacer con el resto,una opción es decodificar sólo esta pequeña parte.La situación puede ser que un servidor tenga que decidir el destinatario de un mensaje.El destinatario puede estar interesado en todo el mensaje,pero el servidor puede ser un cuello de botella que quiere evitar cualquier carga innecesaria.</target>
        </trans-unit>
        <trans-unit id="00f8fec10d66dd9849d5606b35c3bae4eb0e24b0" translate="yes" xml:space="preserve">
          <source>When performing a GC, this is the max number of cache entries that will be deleted from the cache.</source>
          <target state="translated">Cuando se realiza una GC,este es el número máximo de entradas de la caché que se borrarán de la misma.</target>
        </trans-unit>
        <trans-unit id="41cd934c42ca149b995fdeb861721924fd54af23" translate="yes" xml:space="preserve">
          <source>When performing lookups in the table we do not need to bother about the locking at all, but when modifying the table we read lock the rwlock protecting the table which allows for multiple writers during normal operation. When the BIF that iterates over the table need access to the table it write locks the rwlock and reads content of the table. The BIF do not read the whole table in one go but instead read small chunks at time only write locking while reading. The actual implementation of the BIFs is out of the scope of this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c12910634b83422602cdf82ac5e1d4a0b08ca569" translate="yes" xml:space="preserve">
          <source>When positioning in a file with other &lt;code&gt;encoding&lt;/code&gt; than &lt;code&gt;latin1&lt;/code&gt;, caution must be taken to set the position on a correct character boundary. For details, see &lt;code&gt;&lt;a href=&quot;#position-2&quot;&gt;position/2&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Al colocar en un archivo con otra &lt;code&gt;encoding&lt;/code&gt; que no sea &lt;code&gt;latin1&lt;/code&gt; , se debe tener cuidado de establecer la posici&amp;oacute;n en un l&amp;iacute;mite de caracteres correcto. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte la &lt;code&gt;&lt;a href=&quot;#position-2&quot;&gt;position/2&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e7dd480431060a65f68203a547b3153b86e9f6c0" translate="yes" xml:space="preserve">
          <source>When printing variable names, they must have the form of proper Core Erlang variables and function names. E.g., a name represented by an integer such as &lt;code&gt;42&lt;/code&gt; could be formatted as &quot;&lt;code&gt;_42&lt;/code&gt;&quot;, an atom &lt;code&gt;'Xxx'&lt;/code&gt; simply as &quot;&lt;code&gt;Xxx&lt;/code&gt;&quot;, and an atom &lt;code&gt;foo&lt;/code&gt; as &quot;&lt;code&gt;_foo&lt;/code&gt;&quot;. However, one must assure that any two valid distinct names are never mapped to the same strings. Tuples such as &lt;code&gt;{foo, 2}&lt;/code&gt; representing function names can simply by formatted as &quot;&lt;code&gt;'foo'/2&lt;/code&gt;&quot;, with no risk of conflicts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1edc83622335984eb1eafacb2b7c60d225676ad9" translate="yes" xml:space="preserve">
          <source>When reading and writing to Unicode-aware entities, like a file opened for Unicode translation, you probably want to format text strings using the functions in the &lt;code&gt;io&lt;/code&gt; module or the &lt;code&gt;io_lib&lt;/code&gt; module. For backward compatibility reasons, these functions do not accept any list as a string, but require a special &lt;strong&gt;translation modifier&lt;/strong&gt; when working with Unicode texts. The modifier is &lt;code&gt;t&lt;/code&gt;. When applied to control character &lt;code&gt;s&lt;/code&gt; in a formatting string, it accepts all Unicode code points and expects binaries to be in UTF-8:</source>
          <target state="translated">Al leer y escribir en entidades compatibles con Unicode, como un archivo abierto para traducci&amp;oacute;n Unicode, probablemente desee formatear cadenas de texto usando las funciones del m&amp;oacute;dulo &lt;code&gt;io&lt;/code&gt; o el m&amp;oacute;dulo &lt;code&gt;io_lib&lt;/code&gt; . Por razones de compatibilidad con versiones anteriores, estas funciones no aceptan ninguna lista como cadena, pero requieren un &lt;strong&gt;modificador de traducci&amp;oacute;n&lt;/strong&gt; especial cuando se trabaja con textos Unicode. El modificador es &lt;code&gt;t&lt;/code&gt; . Cuando se aplica al control de car&amp;aacute;cter &lt;code&gt;s&lt;/code&gt; en un formato de cadenas, acepta todos los puntos de c&amp;oacute;digo Unicode binarios y espera estar en UTF-8:</target>
        </trans-unit>
        <trans-unit id="3c0dca0646e1e96c639e0ef95ed64c16af0abe48" translate="yes" xml:space="preserve">
          <source>When receiving a log event, either from the emulator or from a remote node, the proxy calls the Logger API to log the event.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8c1dd8823b82718c750f6e4752dce919973fd1c" translate="yes" xml:space="preserve">
          <source>When receiving data from untrusted sources, use option &lt;code&gt;ERL_NIF_BIN2TERM_SAFE&lt;/code&gt;.</source>
          <target state="translated">Cuando reciba datos de fuentes no confiables, use la opci&amp;oacute;n &lt;code&gt;ERL_NIF_BIN2TERM_SAFE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="caaa8dcd0a5b73778282496efd8b85cdbc96febe" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler clears the latest received alarm with id &lt;code&gt;AlarmId&lt;/code&gt;.</source>
          <target state="translated">Al recibir este evento, el controlador simple predeterminado borra la &amp;uacute;ltima alarma recibida con id &lt;code&gt;AlarmId&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9e62ca61b001221600279b3875635215766f5030" translate="yes" xml:space="preserve">
          <source>When receiving this event, the default simple handler stores the alarm. &lt;code&gt;AlarmId&lt;/code&gt; identifies the alarm and is used when the alarm is cleared.</source>
          <target state="translated">Al recibir este evento, el controlador simple predeterminado almacena la alarma. &lt;code&gt;AlarmId&lt;/code&gt; identifica la alarma y se utiliza cuando se borra la alarma.</target>
        </trans-unit>
        <trans-unit id="cab9fe9e9b48ff6bfb268655c0f4e10837898a9b" translate="yes" xml:space="preserve">
          <source>When recompiling with &lt;code&gt;gcc&lt;/code&gt;, use flag &lt;code&gt;-Wstrict-prototypes&lt;/code&gt; to get better warnings. Try to find a similar flag if you use another compiler.</source>
          <target state="translated">Al recompilar con &lt;code&gt;gcc&lt;/code&gt; , use flag &lt;code&gt;-Wstrict-prototypes&lt;/code&gt; para obtener mejores advertencias. Intente encontrar una bandera similar si usa otro compilador.</target>
        </trans-unit>
        <trans-unit id="5fa55ded95f5c996f7f21886e99692b06c59dfaf" translate="yes" xml:space="preserve">
          <source>When recursing and building a list, it is important to ensure that you attach the new elements to the beginning of the list. In this way, you will build &lt;strong&gt;one&lt;/strong&gt; list, not hundreds or thousands of copies of the growing result list.</source>
          <target state="translated">Al volver a buscar y crear una lista, es importante asegurarse de adjuntar los nuevos elementos al principio de la lista. De esta manera, crear&amp;aacute; &lt;strong&gt;una&lt;/strong&gt; lista, no cientos o miles de copias de la lista de resultados en crecimiento.</target>
        </trans-unit>
        <trans-unit id="d8bab5f0a38ad7351ef92518566a8a66e14c70a0" translate="yes" xml:space="preserve">
          <source>When restricted shell mode is activated or deactivated, new jobs started on the node run in restricted or normal mode, respectively.</source>
          <target state="translated">Cuando se activa o desactiva el modo de shell restringido,los nuevos trabajos iniciados en el nodo se ejecutan en modo restringido o normal,respectivamente.</target>
        </trans-unit>
        <trans-unit id="5c2049b6ccaf60623aba58c7816db28baba978c3" translate="yes" xml:space="preserve">
          <source>When run as above (this will take some time), the measurement process is done as follows:</source>
          <target state="translated">Cuando se ejecuta como arriba (esto tomará algún tiempo),el proceso de medición se hace de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="bcae0656877ffa6ebb4290ed9f508d93d062de30" translate="yes" xml:space="preserve">
          <source>When run on Linux, &lt;code&gt;cpu_sup&lt;/code&gt; assumes that the &lt;code&gt;/proc&lt;/code&gt; file system is present and accessible by &lt;code&gt;cpu_sup&lt;/code&gt;. If it is not, &lt;code&gt;cpu_sup&lt;/code&gt; will terminate.</source>
          <target state="translated">Cuando se ejecuta en Linux, &lt;code&gt;cpu_sup&lt;/code&gt; asume que el sistema de archivos &lt;code&gt;/proc&lt;/code&gt; est&amp;aacute; presente y es accesible por &lt;code&gt;cpu_sup&lt;/code&gt; . Si no es as&amp;iacute;, &lt;code&gt;cpu_sup&lt;/code&gt; terminar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="4cf54f8998c8d68cc207a24a295ffc4553d6eff1" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;high&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; are selected for execution. Notice however that this does &lt;strong&gt;not&lt;/strong&gt; mean that no processes on priority &lt;code&gt;low&lt;/code&gt; or &lt;code&gt;normal&lt;/code&gt; can run when processes are running on priority &lt;code&gt;high&lt;/code&gt;. When using multiple schedulers, more processes can be running in parallel than processes on priority &lt;code&gt;high&lt;/code&gt;. That is, a &lt;code&gt;low&lt;/code&gt; and a &lt;code&gt;high&lt;/code&gt; priority process can execute at the same time.</source>
          <target state="translated">Cuando existen procesos ejecutables con prioridad &lt;code&gt;high&lt;/code&gt; , no se selecciona ning&amp;uacute;n proceso con prioridad &lt;code&gt;low&lt;/code&gt; o &lt;code&gt;normal&lt;/code&gt; para su ejecuci&amp;oacute;n. Sin embargo, tenga en cuenta que esto &lt;strong&gt;no&lt;/strong&gt; significa que ning&amp;uacute;n proceso con prioridad &lt;code&gt;low&lt;/code&gt; o &lt;code&gt;normal&lt;/code&gt; pueda ejecutarse cuando los procesos se ejecutan con prioridad &lt;code&gt;high&lt;/code&gt; . Cuando se utilizan varios programadores, se pueden ejecutar m&amp;aacute;s procesos en paralelo que los procesos con prioridad &lt;code&gt;high&lt;/code&gt; . Es decir, un proceso de &lt;code&gt;high&lt;/code&gt; y &lt;code&gt;low&lt;/code&gt; prioridad puede ejecutarse al mismo tiempo.</target>
        </trans-unit>
        <trans-unit id="bac375c5ce5278df5f7742eba36c446680185abe" translate="yes" xml:space="preserve">
          <source>When runnable processes on priority &lt;code&gt;max&lt;/code&gt; exist, no processes on priority &lt;code&gt;low&lt;/code&gt;, &lt;code&gt;normal&lt;/code&gt;, or &lt;code&gt;high&lt;/code&gt; are selected for execution. As with priority &lt;code&gt;high&lt;/code&gt;, processes on lower priorities can execute in parallel with processes on priority &lt;code&gt;max&lt;/code&gt;.</source>
          <target state="translated">Cuando existen procesos ejecutables con prioridad &lt;code&gt;max&lt;/code&gt; , no se selecciona ning&amp;uacute;n proceso con prioridad &lt;code&gt;low&lt;/code&gt; , &lt;code&gt;normal&lt;/code&gt; o &lt;code&gt;high&lt;/code&gt; para su ejecuci&amp;oacute;n. Al igual que con la prioridad &lt;code&gt;high&lt;/code&gt; , los procesos de prioridad m&amp;aacute;s baja se pueden ejecutar en paralelo con los procesos de prioridad &lt;code&gt;max&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="680e4c2820f1533afc4212ad58a52897fa7b6ea9" translate="yes" xml:space="preserve">
          <source>When running SMP erlang on a multi-core machine the &quot;throughput&quot; is significantly higher. The mstone1 test is an extreme test, but it shows what is gained by using the reentrant flex-scanner.</source>
          <target state="translated">Cuando se ejecuta SMP erlang en una máquina multi-núcleo el &quot;rendimiento&quot; es significativamente mayor.La prueba mstone1 es una prueba extrema,pero muestra lo que se gana al usar el flex-scanner reentrante.</target>
        </trans-unit>
        <trans-unit id="bb8603cea37568d4ea95955c8c7cd5ad79e8fceb" translate="yes" xml:space="preserve">
          <source>When running a distributed system with two or more participating nodes, the function &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; must be executed on each participating node. This would typically be part of the boot script in an embedded environment. In a test environment or an interactive environment, &lt;code&gt;mnesia:start()&lt;/code&gt; can also be used either from the Erlang shell or another program.</source>
          <target state="translated">Cuando se ejecuta un sistema distribuido con dos o m&amp;aacute;s nodos participantes, la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#start-0&quot;&gt;mnesia:start()&lt;/a&gt;&lt;/code&gt; debe ejecutarse en cada nodo participante. Normalmente, esto ser&amp;iacute;a parte del script de arranque en un entorno integrado. En un entorno de prueba o un entorno interactivo, &lt;code&gt;mnesia:start()&lt;/code&gt; tambi&amp;eacute;n se puede utilizar desde el shell de Erlang o desde otro programa.</target>
        </trans-unit>
        <trans-unit id="65e9a6705c8969bac7cd69e2170ef9d9d0ac1c6a" translate="yes" xml:space="preserve">
          <source>When running in &lt;code&gt;utf8&lt;/code&gt; mode, functions &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link-1&quot;&gt;read_link/1&lt;/a&gt;&lt;/code&gt; never return raw filenames. To return all filenames including raw filenames, use functions &lt;code&gt;&lt;a href=&quot;#list_dir_all&quot;&gt;list_dir_all/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#read_link_all&quot;&gt;read_link_all/1&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando se ejecuta en modo &lt;code&gt;utf8&lt;/code&gt; , las funciones &lt;code&gt;&lt;a href=&quot;#list_dir-1&quot;&gt;list_dir/1&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#read_link-1&quot;&gt;read_link/1&lt;/a&gt;&lt;/code&gt; nunca devuelven nombres de archivo sin formato . Para devolver todos los nombres de archivo, incluidos los nombres de archivo sin &lt;code&gt;&lt;a href=&quot;#list_dir_all&quot;&gt;list_dir_all/1&lt;/a&gt;&lt;/code&gt; , utilice las funciones list_dir_all / 1 y &lt;code&gt;&lt;a href=&quot;#read_link_all&quot;&gt;read_link_all/1&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfdc638646c31aefd08c7b469c60f917c3f883df" translate="yes" xml:space="preserve">
          <source>When running on OSs lacking support for monotonic time, &lt;code&gt;heart&lt;/code&gt; is susceptible to system clock adjustments of more than &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; seconds. When this happens, &lt;code&gt;heart&lt;/code&gt; times out and tries to reboot the system. This can occur, for example, if the system clock is adjusted automatically by use of the Network Time Protocol (NTP).</source>
          <target state="translated">Cuando se ejecuta en sistemas operativos que no admiten el tiempo mon&amp;oacute;tono, el &lt;code&gt;heart&lt;/code&gt; es susceptible a ajustes del reloj del sistema de m&amp;aacute;s de &lt;code&gt;HEART_BEAT_TIMEOUT&lt;/code&gt; segundos. Cuando esto sucede, el &lt;code&gt;heart&lt;/code&gt; agota e intenta reiniciar el sistema. Esto puede ocurrir, por ejemplo, si el reloj del sistema se ajusta autom&amp;aacute;ticamente mediante el uso del Protocolo de tiempo de red (NTP).</target>
        </trans-unit>
        <trans-unit id="5ecb6729e649e0c2e3875d3412d7df6f9ff2fc1b" translate="yes" xml:space="preserve">
          <source>When running on Windows, suppresses creation of a new console window when spawning the port program. (This option has no effect on other platforms.)</source>
          <target state="translated">Cuando se ejecuta en Windows,suprime la creación de una nueva ventana de consola al generar el programa de puerto.(Esta opción no tiene efecto en otras plataformas).</target>
        </trans-unit>
        <trans-unit id="309f93ce0de6e0564170b1380609d0ba9cb4ea04" translate="yes" xml:space="preserve">
          <source>When running some simple benchmarks where contention only occur due to I/O signals contending with signals from one single process we got a speedup of 5-15%. When multiple processes send signals to one single port the improvements can be much larger, but the scenario with one process contending with I/O is the most common one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd983c16ed2802c7407abf4ca24b358fab081cd5" translate="yes" xml:space="preserve">
          <source>When running the chameneosredux benchmark, schedulers frequently run out of work trying to steal work from each other. That is, either succeeding in migrating, or trying to migrate processes which is a scenario which we wanted to optimize. By the introduction of these improvements, we got a speedup of 25-35% when running this benchmark on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40fef19bf4ae7d5149805c66d2c79ab1ccaa7133" translate="yes" xml:space="preserve">
          <source>When running the ehb benchmark, large amount of messages are passed around between schedulers. All message passing will in some way or the other cause memory allocation and deallocation. Since messages are passed between different schedulers we will get contention on the allocator instances where messages were allocated. By the introduction of the delayed dealloc feature, we got a speedup of between 25-45%, depending on configuration of the benchmark, when running on a relatively new machine with an Intel i7 quad core processor with hyper-threading using 8 schedulers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63711eb9fd97d3b4dc00231599c84305bd3a055a" translate="yes" xml:space="preserve">
          <source>When schedulers need to read this information, they read the pointer to currently used information using an atomic read operation, and then issue a data dependency read barrier, which on most architectures is a no-op. That is, it is very little overhead getting access to this information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63b602ea12cff6b347850ec520a992d2e4051e4a" translate="yes" xml:space="preserve">
          <source>When selecting data from a table, all data types are returned from the database to the ODBC driver as an ODBC data type. The tables below shows the mapping between those data types and what is returned by the Erlang API.</source>
          <target state="translated">Cuando se seleccionan los datos de una tabla,todos los tipos de datos se devuelven de la base de datos al controlador ODBC como un tipo de datos ODBC.En las tablas siguientes se muestra el mapeo entre esos tipos de datos y lo que devuelve la API de Erlang.</target>
        </trans-unit>
        <trans-unit id="5028404a77ebb05ae66aa4cdb0300c35b354c2d2" translate="yes" xml:space="preserve">
          <source>When sending data to a port. Ports understand deep lists so there is no reason to flatten the list before sending it to the port.</source>
          <target state="translated">Cuando se envían datos a un puerto.Los puertos entienden las listas profundas,así que no hay razón para aplanar la lista antes de enviarla al puerto.</target>
        </trans-unit>
        <trans-unit id="f6655794aac8234bda9f3cc8627542cf28e39cd7" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;user_reply()&lt;/code&gt;). When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt; (&lt;code&gt;UserReply&lt;/code&gt; will then be &lt;code&gt;[user_reply()]&lt;/code&gt;). Each element of the list is part of one transaction.</source>
          <target state="translated">Al enviar una transacci&amp;oacute;n en un mensaje, las &lt;code&gt;Actions&lt;/code&gt; deben ser &lt;code&gt;action_reqs()&lt;/code&gt; ( &lt;code&gt;UserReply&lt;/code&gt; ser&amp;aacute; &lt;code&gt;user_reply()&lt;/code&gt; ). Al enviar varias transacciones en un mensaje, las &lt;code&gt;Actions&lt;/code&gt; deben ser &lt;code&gt;[action_reqs()]&lt;/code&gt; ( &lt;code&gt;UserReply&lt;/code&gt; ser&amp;aacute; entonces &lt;code&gt;[user_reply()]&lt;/code&gt; ). Cada elemento de la lista es parte de una transacci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="342bdd47df4ec30e4e5a4ebaa64afc70c7b8eea1" translate="yes" xml:space="preserve">
          <source>When sending one transaction in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;action_reqs()&lt;/code&gt;. When sending several transactions in a message, &lt;code&gt;Actions&lt;/code&gt; should be &lt;code&gt;[action_reqs()]&lt;/code&gt;. Each element of the list is part of one transaction.</source>
          <target state="translated">Al enviar una transacci&amp;oacute;n en un mensaje, las &lt;code&gt;Actions&lt;/code&gt; deben ser &lt;code&gt;action_reqs()&lt;/code&gt; . Al enviar varias transacciones en un mensaje, las &lt;code&gt;Actions&lt;/code&gt; deben ser &lt;code&gt;[action_reqs()]&lt;/code&gt; . Cada elemento de la lista es parte de una transacci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9e875fa8988ecf27835b249f9b398d7327be21c9" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system logs an error event via &lt;code&gt; logger&lt;/code&gt;, containing details about the process when the maximum heap size is reached. One log event is sent each time the limit is reached.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75b19f5e353d16bcbf308a2928e10b271ad77a7b" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system logs an error event via &lt;code&gt;logger&lt;/code&gt;, containing details about the process when the maximum heap size is reached. One log event is sent each time the limit is reached.</source>
          <target state="translated">Cuando se establece en &lt;code&gt;true&lt;/code&gt; , el sistema en tiempo de ejecuci&amp;oacute;n registra un evento de error a trav&amp;eacute;s del &lt;code&gt;logger&lt;/code&gt; , que contiene detalles sobre el proceso cuando se alcanza el tama&amp;ntilde;o m&amp;aacute;ximo de pila. Se env&amp;iacute;a un evento de registro cada vez que se alcanza el l&amp;iacute;mite.</target>
        </trans-unit>
        <trans-unit id="a7a9f29c7c04f56d28d9864f8634905c97f0d23f" translate="yes" xml:space="preserve">
          <source>When set to &lt;code&gt;true&lt;/code&gt;, the runtime system sends an untrappable exit signal with reason &lt;code&gt;kill&lt;/code&gt; to the process if the maximum heap size is reached. The garbage collection that triggered the &lt;code&gt;kill&lt;/code&gt; is not completed, instead the process exits as soon as possible. When set to &lt;code&gt;false&lt;/code&gt;, no exit signal is sent to the process, instead it continues executing.</source>
          <target state="translated">Cuando se establece en &lt;code&gt;true&lt;/code&gt; , el sistema de tiempo de ejecuci&amp;oacute;n env&amp;iacute;a una se&amp;ntilde;al de salida untrappable con la raz&amp;oacute;n &lt;code&gt;kill&lt;/code&gt; al proceso si se alcanza el tama&amp;ntilde;o m&amp;aacute;ximo del mont&amp;oacute;n. La recolecci&amp;oacute;n de basura que desencaden&amp;oacute; la &lt;code&gt;kill&lt;/code&gt; no se completa, sino que el proceso finaliza lo antes posible. Cuando se establece en &lt;code&gt;false&lt;/code&gt; , no se env&amp;iacute;a ninguna se&amp;ntilde;al de salida al proceso, sino que contin&amp;uacute;a ejecut&amp;aacute;ndose.</target>
        </trans-unit>
        <trans-unit id="1535dfcd1ada0e5df2bfdd93f8582a8fb9db2211" translate="yes" xml:space="preserve">
          <source>When set, informs the peer to use &lt;code&gt;{IP, Port}&lt;/code&gt; as the primary address of the local endpoint for the association specified by &lt;code&gt;assoc_id&lt;/code&gt;.</source>
          <target state="translated">Cuando se establece, informa al par que use &lt;code&gt;{IP, Port}&lt;/code&gt; como la direcci&amp;oacute;n principal del punto final local para la asociaci&amp;oacute;n especificada por &lt;code&gt;assoc_id&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a09fa3690c8e86bcc1ad44fbac6fe4381cfc8c36" translate="yes" xml:space="preserve">
          <source>When set, requests that the local endpoint uses the value specified by &lt;code&gt;adaptation_ind&lt;/code&gt; as the Adaptation Indication parameter for establishing new associations. For details, see &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extenstions for SCTP&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando se establece, solicita que el punto extremo local utilice el valor especificado por &lt;code&gt;adaptation_ind&lt;/code&gt; como el par&amp;aacute;metro de indicaci&amp;oacute;n de adaptaci&amp;oacute;n para establecer nuevas asociaciones. Para obtener m&amp;aacute;s informaci&amp;oacute;n, consulte &lt;code&gt;&lt;a href=&quot;http://www.rfc-archive.org/getrfc.php?rfc=2960&quot;&gt;RFC 2960&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;http://tools.ietf.org/html/draft-ietf-tsvwg-sctpsocket-13&quot;&gt;Sockets API Extenstions for SCTP&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="35268e3a52547204a88309f957a19dbdd29a75e6" translate="yes" xml:space="preserve">
          <source>When setting up a trace, the following features can also be activated:</source>
          <target state="translated">Cuando se configura un rastreo,las siguientes características también pueden ser activadas:</target>
        </trans-unit>
        <trans-unit id="bc86d8be157ab5b84c3a61f949941d9549419fe9" translate="yes" xml:space="preserve">
          <source>When something is to be sent, everything is packed into one message, unless the trigger was a reply transaction and the added size of the reply and all the requests is greater then &lt;code&gt;trans_req_maxsize&lt;/code&gt;, in which case the stored transactions are sent first in a separate message and the reply in another message.</source>
          <target state="translated">Cuando se va a enviar algo, todo se empaqueta en un mensaje, a menos que el desencadenante sea una transacci&amp;oacute;n de respuesta y el tama&amp;ntilde;o agregado de la respuesta y todas las solicitudes sea mayor que &lt;code&gt;trans_req_maxsize&lt;/code&gt; , en cuyo caso las transacciones almacenadas se env&amp;iacute;an primero en un mensaje separado y la respuesta en otro mensaje.</target>
        </trans-unit>
        <trans-unit id="5c6669a85ba52eabed1bcac71536c7df178c1e61" translate="yes" xml:space="preserve">
          <source>When sorting or merging files, only the first of a sequence of terms that compare equal (&lt;code&gt;==&lt;/code&gt;) is output if this option is set to &lt;code&gt;true&lt;/code&gt;. Defaults to &lt;code&gt;false&lt;/code&gt;, which implies that all terms that compare equal are output. When checking files for sortedness, a check that no pair of consecutive terms compares equal is done if this option is set to &lt;code&gt;true&lt;/code&gt;.</source>
          <target state="translated">Al ordenar o fusionar archivos, solo se emite el primero de una secuencia de t&amp;eacute;rminos que se comparan igual ( &lt;code&gt;==&lt;/code&gt; ) si esta opci&amp;oacute;n se establece en &lt;code&gt;true&lt;/code&gt; . El valor predeterminado es &lt;code&gt;false&lt;/code&gt; , lo que implica que todos los t&amp;eacute;rminos que se comparan son iguales. Al verificar la clasificaci&amp;oacute;n de los archivos, se realiza una verificaci&amp;oacute;n de que ning&amp;uacute;n par de t&amp;eacute;rminos consecutivos se comparen igual si esta opci&amp;oacute;n se establece en &lt;code&gt;true&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eeaa657839317430e892985c6edb0950f60958c4" translate="yes" xml:space="preserve">
          <source>When specifying &lt;code&gt;Level&lt;/code&gt; as an integer, and therefor using &quot;native mode&quot;, it is *currently* up to the caller to know how to encode the &lt;code&gt;Value&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e0970cdbf2a1a1d933db58200b846160d61b1a" translate="yes" xml:space="preserve">
          <source>When specifying &lt;code&gt;Level&lt;/code&gt; as an integer, and therefor using &quot;native mode&quot;, it is *currently* up to the caller to know how to interpret the result.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0d9a5c9e89c06fc7a1af4210b3e4aef4fd2191a" translate="yes" xml:space="preserve">
          <source>When specifying an atom constraint, the atom is written as it would be in the C source code. That is, it needs an &lt;code&gt;am_&lt;/code&gt; prefix, and it must be listed in &lt;code&gt;atom.names&lt;/code&gt;. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8c34b332981b8e474e02ef63bcc500fd0757ef2" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can be used.</source>
          <target state="translated">Cuando se inicia &lt;code&gt;stand_alone&lt;/code&gt; , solo se puede usar el pid.</target>
        </trans-unit>
        <trans-unit id="b66f134384d3cc9012959c5c579272f12c941335" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt; only the pid can used.</source>
          <target state="translated">Cuando se inicia &lt;code&gt;stand_alone&lt;/code&gt; , solo se puede usar el pid.</target>
        </trans-unit>
        <trans-unit id="a9910d3d66f8237ea301a1cc0a52c4d81c8b1682" translate="yes" xml:space="preserve">
          <source>When started &lt;code&gt;stand_alone&lt;/code&gt;.</source>
          <target state="translated">Cuando se inici&amp;oacute; &lt;code&gt;stand_alone&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a4ce6035e3ae59d7f18987449985901fd92e494f" translate="yes" xml:space="preserve">
          <source>When started, the node waits for all nodes specified by &lt;code&gt;sync_nodes_mandatory&lt;/code&gt; and &lt;code&gt;sync_nodes_optional&lt;/code&gt; to come up. When all nodes are up, or when all mandatory nodes are up and the time specified by &lt;code&gt;sync_nodes_timeout&lt;/code&gt; has elapsed, all applications start. If not all mandatory nodes are up, the node terminates.</source>
          <target state="translated">Cuando se inicia, el nodo espera a que &lt;code&gt;sync_nodes_mandatory&lt;/code&gt; todos los nodos especificados por sync_nodes_mandatory y &lt;code&gt;sync_nodes_optional&lt;/code&gt; . Cuando todos los nodos est&amp;aacute;n &lt;code&gt;sync_nodes_timeout&lt;/code&gt; , o cuando todos los nodos obligatorios est&amp;aacute;n activos y ha transcurrido el tiempo especificado por sync_nodes_timeout , se inician todas las aplicaciones. Si no todos los nodos obligatorios est&amp;aacute;n activos, el nodo termina.</target>
        </trans-unit>
        <trans-unit id="4f35884d86e4f1c2ac96377ac4d8d3d8958cc289" translate="yes" xml:space="preserve">
          <source>When started, the supervisor does not start any child processes. Instead, all child processes are added dynamically by calling:</source>
          <target state="translated">Cuando se inicia,el supervisor no inicia ningún proceso infantil.En su lugar,todos los procesos hijo se añaden dinámicamente por llamada:</target>
        </trans-unit>
        <trans-unit id="af782a2bcb2a4b2a362bed6616a129bcc6a72b52" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;Mnesia&lt;/code&gt;, a &lt;code&gt;.LOG&lt;/code&gt; file called &lt;code&gt;LATEST.LOG&lt;/code&gt; is created and placed in the database directory. This file is used by &lt;code&gt;Mnesia&lt;/code&gt; to log disc-based transactions. This includes all transactions that write at least one record in a table that is of storage type &lt;code&gt;disc_copies&lt;/code&gt; or &lt;code&gt;disc_only_copies&lt;/code&gt;. The file also includes all operations that manipulate the schema itself, such as creating new tables. The log format can vary with different implementations of &lt;code&gt;Mnesia&lt;/code&gt;. The &lt;code&gt;Mnesia&lt;/code&gt; log is currently implemented in the standard library module &lt;code&gt;disk_log&lt;/code&gt; in &lt;code&gt;Kernel&lt;/code&gt;.</source>
          <target state="translated">Al iniciar &lt;code&gt;Mnesia&lt;/code&gt; , se crea un archivo &lt;code&gt;.LOG&lt;/code&gt; llamado &lt;code&gt;LATEST.LOG&lt;/code&gt; y se coloca en el directorio de la base de datos. &lt;code&gt;Mnesia&lt;/code&gt; utiliza este archivo para registrar transacciones basadas en disco. Esto incluye todas las transacciones que escriben al menos un registro en una tabla que es de tipo de almacenamiento &lt;code&gt;disc_copies&lt;/code&gt; o &lt;code&gt;disc_only_copies&lt;/code&gt; . El archivo tambi&amp;eacute;n incluye todas las operaciones que manipulan el esquema en s&amp;iacute;, como la creaci&amp;oacute;n de nuevas tablas. El formato de registro puede variar con diferentes implementaciones de &lt;code&gt;Mnesia&lt;/code&gt; . El registro de &lt;code&gt;Mnesia&lt;/code&gt; est&amp;aacute; actualmente implementado en el m&amp;oacute;dulo de biblioteca est&amp;aacute;ndar &lt;code&gt;disk_log&lt;/code&gt; en &lt;code&gt;Kernel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cbcc2618bb75c573fc25f8a846a8fe36e4ed8763" translate="yes" xml:space="preserve">
          <source>When starting &lt;code&gt;prim_app&lt;/code&gt; as defined above, the application controller calls the following callback functions before &lt;code&gt;application:start(prim_app)&lt;/code&gt; returns a value:</source>
          <target state="translated">Al iniciar &lt;code&gt;prim_app&lt;/code&gt; como se defini&amp;oacute; anteriormente, el controlador de la aplicaci&amp;oacute;n llama a las siguientes funciones de devoluci&amp;oacute;n de llamada antes de la &lt;code&gt;application:start(prim_app)&lt;/code&gt; devuelve un valor:</target>
        </trans-unit>
        <trans-unit id="4cd4f1a6e7e43123fc3118e6461ff8abe900204f" translate="yes" xml:space="preserve">
          <source>When starting Erlang in embedded mode, it is assumed that exactly one system configuration file is used, named &lt;code&gt;sys.config&lt;/code&gt;. This file is to be located in &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt;, where &lt;code&gt;$ROOT&lt;/code&gt; is the Erlang/OTP root installation directory and &lt;code&gt;Vsn&lt;/code&gt; is the release version.</source>
          <target state="translated">Al iniciar Erlang en modo incrustado, se asume que se usa exactamente un archivo de configuraci&amp;oacute;n del sistema, llamado &lt;code&gt;sys.config&lt;/code&gt; . Este archivo se ubicar&amp;aacute; en &lt;code&gt;$ROOT/releases/Vsn&lt;/code&gt; , donde &lt;code&gt;$ROOT&lt;/code&gt; es el directorio de instalaci&amp;oacute;n ra&amp;iacute;z de Erlang / OTP y &lt;code&gt;Vsn&lt;/code&gt; es la versi&amp;oacute;n de lanzamiento.</target>
        </trans-unit>
        <trans-unit id="b5ddbb5d78d831c78a317496e7e2a2d2c40076a3" translate="yes" xml:space="preserve">
          <source>When starting Erlang/OTP using the boot script, all applications from the &lt;code&gt;.rel&lt;/code&gt; file are automatically loaded and started:</source>
          <target state="translated">Al iniciar Erlang / OTP usando el script de arranque, todas las aplicaciones del archivo &lt;code&gt;.rel&lt;/code&gt; se cargan e inician autom&amp;aacute;ticamente:</target>
        </trans-unit>
        <trans-unit id="b604ec38ae2b79479f9ec0cb1378442b00d5b576" translate="yes" xml:space="preserve">
          <source>When starting a primary application with included applications, the primary application is started the normal way, that is:</source>
          <target state="translated">Cuando se inicia una aplicación primaria con las aplicaciones incluidas,la aplicación primaria se inicia de la manera normal,es decir:</target>
        </trans-unit>
        <trans-unit id="ed0f727403d7e975b13ca3d05489c37f1a495f5a" translate="yes" xml:space="preserve">
          <source>When starting an Erlang node, the default behaviour is that all log events on level &lt;code&gt;notice&lt;/code&gt; or more severe, are logged to the terminal via the default handler. To also log info events, you can either change the primary log level to &lt;code&gt;info&lt;/code&gt;:</source>
          <target state="translated">Al iniciar un nodo Erlang, el comportamiento predeterminado es que todos los eventos de registro en el nivel de &lt;code&gt;notice&lt;/code&gt; o m&amp;aacute;s graves se registran en el terminal a trav&amp;eacute;s del controlador predeterminado. Para registrar tambi&amp;eacute;n eventos de informaci&amp;oacute;n, puede cambiar el nivel de registro principal a &lt;code&gt;info&lt;/code&gt; rmaci&amp;oacute;n :</target>
        </trans-unit>
        <trans-unit id="d267d7fc52461e3316cc2f612f2db868d98e7a72" translate="yes" xml:space="preserve">
          <source>When starting external programs on Solaris, the system call &lt;code&gt;vfork&lt;/code&gt; is used in preference to &lt;code&gt;fork&lt;/code&gt; for performance reasons, although it has a history of being less robust. If there are problems using &lt;code&gt;vfork&lt;/code&gt;, setting environment variable &lt;code&gt;ERL_NO_VFORK&lt;/code&gt; to any value causes &lt;code&gt;fork&lt;/code&gt; to be used instead.</source>
          <target state="translated">Al iniciar programas externos en Solaris, la llamada al sistema &lt;code&gt;vfork&lt;/code&gt; se usa con preferencia a &lt;code&gt;fork&lt;/code&gt; por razones de rendimiento, aunque tiene un historial de ser menos robusto. Si hay problemas al usar &lt;code&gt;vfork&lt;/code&gt; , establecer la variable de entorno &lt;code&gt;ERL_NO_VFORK&lt;/code&gt; en cualquier valor hace que se use &lt;code&gt;fork&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="6eba2c0286e1f80a8b6d2f783a23106deb0b2394" translate="yes" xml:space="preserve">
          <source>When starting snmpa_local_db it always tries to open an existing database. If &lt;code&gt;false&lt;/code&gt;, and some errors occur, a new database is created instead. If &lt;code&gt;true&lt;/code&gt;, an existing file will be repaired. If &lt;code&gt;force&lt;/code&gt;, the table will be repaired even if it was properly closed.</source>
          <target state="translated">Al iniciar snmpa_local_db, siempre intenta abrir una base de datos existente. Si es &lt;code&gt;false&lt;/code&gt; y se producen algunos errores, se crea una nueva base de datos. Si es &lt;code&gt;true&lt;/code&gt; , se reparar&amp;aacute; un archivo existente. Si se &lt;code&gt;force&lt;/code&gt; , la mesa se reparar&amp;aacute; incluso si se cerr&amp;oacute; correctamente.</target>
        </trans-unit>
        <trans-unit id="c1c86792af0c1fc90a287c8a9c5bae64d2165932" translate="yes" xml:space="preserve">
          <source>When starting the &lt;code&gt;Inets&lt;/code&gt; application, a manager process for the default profile is started. The functions in this API that do not explicitly use a profile accesses the default profile. A profile keeps track of proxy options, cookies, and other options that can be applied to more than one request.</source>
          <target state="translated">Al iniciar la aplicaci&amp;oacute;n &lt;code&gt;Inets&lt;/code&gt; , se inicia un proceso de administrador para el perfil predeterminado. Las funciones de esta API que no utilizan expl&amp;iacute;citamente un perfil acceden al perfil predeterminado. Un perfil realiza un seguimiento de las opciones de proxy, cookies y otras opciones que se pueden aplicar a m&amp;aacute;s de una solicitud.</target>
        </trans-unit>
        <trans-unit id="cd05c53bfd126defe810f3a187a5cf1551a34b96" translate="yes" xml:space="preserve">
          <source>When starting the flex scanner a port to the linked in driver is created. This port has to be owned by a process. This process must not die. If it does the port will also terminate. Therefor:</source>
          <target state="translated">Al iniciar el escáner flexible,se crea un puerto para el controlador de enlace.Este puerto tiene que ser propiedad de un proceso.Este proceso no debe morir.Si lo hace,el puerto también terminará.Por lo tanto:</target>
        </trans-unit>
        <trans-unit id="6d9ab8ee43c8cd162c696fc7f8c9882054157b9c" translate="yes" xml:space="preserve">
          <source>When starting this release, three things must be specified:</source>
          <target state="translated">Al iniciar este lanzamiento,deben especificarse tres cosas:</target>
        </trans-unit>
        <trans-unit id="b5e8349f617cc19cb94845c2b5a433d10397c346" translate="yes" xml:space="preserve">
          <source>When starting with Unicode, one often stumbles over some common issues. This section describes some methods of dealing with Unicode data.</source>
          <target state="translated">Cuando se empieza con el Unicode,uno a menudo se tropieza con algunos problemas comunes.En esta sección se describen algunos métodos para tratar los datos de Unicode.</target>
        </trans-unit>
        <trans-unit id="63dac761d2448700171ff70d4839175c0009a766" translate="yes" xml:space="preserve">
          <source>When stopped, the application is still loaded.</source>
          <target state="translated">Cuando se detiene,la aplicación sigue cargada.</target>
        </trans-unit>
        <trans-unit id="6bcf5a7b78ff49a4689ff94e30fd3cc2e19a3b3d" translate="yes" xml:space="preserve">
          <source>When streaming to the calling processes using option &lt;code&gt;{self, once}&lt;/code&gt;, the first message has an extra element, that is, &lt;code&gt;{http, {RequestId, stream_start, Headers, Pid}}&lt;/code&gt;. This is the process id to be used as an argument to &lt;code&gt;httpc:stream_next/1&lt;/code&gt; to trigger the next message to be sent to the calling process.</source>
          <target state="translated">Cuando se transmite a los procesos de llamada usando la opci&amp;oacute;n &lt;code&gt;{self, once}&lt;/code&gt; , el primer mensaje tiene un elemento adicional, es decir, &lt;code&gt;{http, {RequestId, stream_start, Headers, Pid}}&lt;/code&gt; . Este es el ID de proceso que se utilizar&amp;aacute; como argumento para &lt;code&gt;httpc:stream_next/1&lt;/code&gt; para activar el siguiente mensaje que se enviar&amp;aacute; al proceso de llamada.</target>
        </trans-unit>
        <trans-unit id="715fec6e13a0abfe20ee555a6324b0802bfff927" translate="yes" xml:space="preserve">
          <source>When string or binary objects are stored in the registry it is important that some simple guidelines are followed.</source>
          <target state="translated">Cuando se almacenan objetos de cadena o binarios en el registro es importante que se sigan algunas pautas simples.</target>
        </trans-unit>
        <trans-unit id="9879a39d7048a88467f14f974e9672e4f402cb5c" translate="yes" xml:space="preserve">
          <source>When tables are forcefully loaded from the local disc, all operations that were performed on the replicated table while the local node was down, and the remote replica was alive, are lost. This can cause the database to become inconsistent.</source>
          <target state="translated">Cuando las mesas se cargan a la fuerza desde el disco local,todas las operaciones que se realizaron en la mesa replicada mientras el nodo local estaba caído,y la réplica remota estaba viva,se pierden.Esto puede causar que la base de datos se vuelva inconsistente.</target>
        </trans-unit>
        <trans-unit id="bc9c626bcd30b7f8ecf9ddc823a493152c649dd7" translate="yes" xml:space="preserve">
          <source>When tests start, &lt;code&gt;Common Test&lt;/code&gt; Master displays information to console about the involved nodes. &lt;code&gt;Common Test&lt;/code&gt; Master also reports when tests finish, successfully or unsuccessfully. If connection is lost to a node, the test on that node is considered finished. &lt;code&gt;Common Test&lt;/code&gt; Master does not attempt to re-establish contact with the failing node.</source>
          <target state="translated">Cuando comienzan las pruebas, &lt;code&gt;Common Test&lt;/code&gt; Master muestra informaci&amp;oacute;n a la consola sobre los nodos involucrados. &lt;code&gt;Common Test&lt;/code&gt; Master tambi&amp;eacute;n informa cuando las pruebas terminan, con &amp;eacute;xito o sin &amp;eacute;xito. Si se pierde la conexi&amp;oacute;n con un nodo, la prueba en ese nodo se considera finalizada. &lt;code&gt;Common Test&lt;/code&gt; Master no intenta restablecer el contacto con el nodo que falla.</target>
        </trans-unit>
        <trans-unit id="3a6b1d7b2952e82ddb54a9aed1dcf8f6fa4d10a5" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;'CHANGE'&lt;/code&gt; message has been received you are guaranteed not to retrieve the old time offset when calling &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt; erlang:time_offset()&lt;/a&gt;&lt;/code&gt;. Notice that you can observe the change of the time offset when calling &lt;code&gt;erlang:time_offset()&lt;/code&gt; before you get the &lt;code&gt;'CHANGE'&lt;/code&gt; message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c0e15e615fec1bfe62b38c3373f94e44765c1055" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;'CHANGE'&lt;/code&gt; message has been received you are guaranteed not to retrieve the old time offset when calling &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt;. Notice that you can observe the change of the time offset when calling &lt;code&gt;erlang:time_offset()&lt;/code&gt; before you get the &lt;code&gt;'CHANGE'&lt;/code&gt; message.</source>
          <target state="translated">Cuando se recibe el mensaje &lt;code&gt;'CHANGE'&lt;/code&gt; , se le garantiza que no recuperar&amp;aacute; el desplazamiento de tiempo anterior al llamar a &lt;code&gt;&lt;a href=&quot;#time_offset-0&quot;&gt;erlang:time_offset()&lt;/a&gt;&lt;/code&gt; . Tenga en cuenta que puede observar el cambio de la compensaci&amp;oacute;n de tiempo al llamar a &lt;code&gt;erlang:time_offset()&lt;/code&gt; antes de recibir el mensaje &lt;code&gt;'CHANGE'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="45f99df5f87ec987bc32aa4d5b3c9a0f98e87177" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term and the &lt;strong&gt;state callback&lt;/strong&gt; name is &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="389c67d197284147820c964a147bf25f89168f89" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;handle_event_function&lt;/code&gt;, the state can be any term and the state callback name is &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt;. This makes it easy to branch depending on state or event as you desire. Be careful about which events you handle in which states so that you do not accidentally postpone an event forever creating an infinite busy loop.</source>
          <target state="translated">Cuando el &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;handle_event_function&lt;/code&gt; , el estado puede ser cualquier t&amp;eacute;rmino y el nombre de la devoluci&amp;oacute;n de llamada del estado es &lt;code&gt;&lt;a href=&quot;#Module:handle_event-4&quot;&gt;Module:handle_event/4&lt;/a&gt;&lt;/code&gt; . Esto facilita la ramificaci&amp;oacute;n seg&amp;uacute;n el estado o evento que desee. Tenga cuidado con los eventos que maneja en qu&amp;eacute; estados para que no posponga accidentalmente un evento para siempre creando un bucle ocupado infinito.</target>
        </trans-unit>
        <trans-unit id="99984eee00cd2e7cfb5f8bd18b13829e21931a35" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom and is used as the &lt;strong&gt;state callback&lt;/strong&gt; name; see &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;. This co-locates all code for a specific state in one function as the &lt;code&gt;gen_statem&lt;/code&gt; engine branches depending on state name. Note the fact that the callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; makes the state name &lt;code&gt;terminate&lt;/code&gt; unusable in this mode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c771ceccfcda3b957b4a4bb8455365fc3a48832" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; is &lt;code&gt;state_functions&lt;/code&gt;, the state must be an atom and is used as the state callback name; see &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt;. This co-locates all code for a specific state in one function as the &lt;code&gt;gen_statem&lt;/code&gt; engine branches depending on state name. Note the fact that the callback function &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; makes the state name &lt;code&gt;terminate&lt;/code&gt; unusable in this mode.</source>
          <target state="translated">Cuando el &lt;code&gt;&lt;a href=&quot;#type-callback_mode&quot;&gt;&lt;strong&gt;callback mode&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt; es &lt;code&gt;state_functions&lt;/code&gt; , el estado debe ser un &amp;aacute;tomo y se utiliza como nombre de devoluci&amp;oacute;n de llamada del estado; ver &lt;code&gt;&lt;a href=&quot;#Module:StateName-3&quot;&gt;Module:StateName/3&lt;/a&gt;&lt;/code&gt; . Esto co-ubica todo el c&amp;oacute;digo para un estado espec&amp;iacute;fico en una funci&amp;oacute;n a medida que el motor &lt;code&gt;gen_statem&lt;/code&gt; se ramifica seg&amp;uacute;n el nombre del estado. Tenga en cuenta el hecho de que la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;&lt;a href=&quot;#Module:terminate-3&quot;&gt;Module:terminate/3&lt;/a&gt;&lt;/code&gt; hace que el nombre del estado &lt;code&gt;terminate&lt;/code&gt; inutilizable en este modo.</target>
        </trans-unit>
        <trans-unit id="7bd23a20d36b333c46d925b8fd401de86fe841dc" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Addr&lt;/code&gt; value does not contain a port number, the value of &lt;code&gt;intAgentUDPPort&lt;/code&gt; is used.</source>
          <target state="translated">Cuando el valor de &lt;code&gt;Addr&lt;/code&gt; no contiene un n&amp;uacute;mero de puerto, se utiliza el valor de &lt;code&gt;intAgentUDPPort&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cfc2f3efdf3b11daa32eb0ee2af5782916973648" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;Key&lt;/code&gt; is a single &lt;code&gt;Item&lt;/code&gt;, the result is a single &lt;code&gt;InfoTuple&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a451ad7b9fddbd477a4eb701e170b27602528366" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;erl_tar&lt;/code&gt; core wants to, for example, write a piece of &lt;code&gt;Data&lt;/code&gt;, it would call &lt;code&gt;ExampleFun(write, {UserData,Data})&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22814bccf02caaf2232de9c743157f0b7348ee14" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;erl_tar&lt;/code&gt; core wants to, for example, write a piece of &lt;code&gt;Data&lt;/code&gt;, it would call &lt;code&gt;ExampleFun(write, {UserPrivate,Data})&lt;/code&gt;.</source>
          <target state="translated">Cuando el n&amp;uacute;cleo de &lt;code&gt;erl_tar&lt;/code&gt; quiere, por ejemplo, escribir un fragmento de &lt;code&gt;Data&lt;/code&gt; , llamar&amp;iacute;a &lt;code&gt;ExampleFun(write, {UserPrivate,Data})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b84a2f0be01530772a20ac645af7f54b604dbf79" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;fprof&lt;/code&gt; server is stopped the collected raw profile data is lost.</source>
          <target state="translated">Cuando se detiene el servidor &lt;code&gt;fprof&lt;/code&gt; , se pierden los datos de perfil sin procesar recopilados.</target>
        </trans-unit>
        <trans-unit id="280e6fc91e95ee5c827fb2cc1667b778ccb86d7b" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;&lt;strong&gt;state enter calls&lt;/strong&gt;&lt;/a&gt;&lt;/code&gt;, these functions are also called with arguments &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; during every &lt;strong&gt;state change&lt;/strong&gt;. In this case there are some restrictions on the &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; that may be returned: &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is not allowed since a &lt;strong&gt;state enter call&lt;/strong&gt; is not an event so there is no event to postpone, and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; is not allowed since using &lt;strong&gt;state enter calls&lt;/strong&gt; should not affect how events are consumed and produced. You may also not change states from this call. Should you return &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; with &lt;code&gt;NextState =/= State&lt;/code&gt; the &lt;code&gt;gen_statem&lt;/code&gt; crashes. Note that it is actually allowed to use &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; although it makes little sense since you immediately will be called again with a new &lt;strong&gt;state enter call&lt;/strong&gt; making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update &lt;code&gt;NewData&lt;/code&gt; and have some loop termination condition, or if you use &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; or &lt;code&gt;repeat_state_and_data&lt;/code&gt; you have an infinite loop! You are advised to use &lt;code&gt;{keep_state,...}&lt;/code&gt;, &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; or &lt;code&gt;keep_state_and_data&lt;/code&gt; since changing states from a &lt;strong&gt;state enter call&lt;/strong&gt; is not possible anyway.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e37d26017c607226a4f422562f10e0bd5f4835e3" translate="yes" xml:space="preserve">
          <source>When the &lt;code&gt;gen_statem&lt;/code&gt; runs with &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt;, these functions are also called with arguments &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; whenever the state changes. In this case there are some restrictions on the &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; that may be returned: &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; is not allowed since a &lt;strong&gt;state enter call&lt;/strong&gt; is not an event so there is no event to postpone, and &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; is not allowed since using &lt;strong&gt;state enter calls&lt;/strong&gt; should not affect how events are consumed and produced. You may also not change states from this call. Should you return &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; with &lt;code&gt;NextState =/= State&lt;/code&gt; the &lt;code&gt;gen_statem&lt;/code&gt; crashes. Note that it is actually allowed to use &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; although it makes little sense since you immediately will be called again with a new &lt;strong&gt;state enter call&lt;/strong&gt; making this just a weird way of looping, and there are better ways to loop in Erlang. If you do not update &lt;code&gt;NewData&lt;/code&gt; and have some loop termination condition, or if you use &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; or &lt;code&gt;repeat_state_and_data&lt;/code&gt; you have an infinite loop! You are advised to use &lt;code&gt;{keep_state,...}&lt;/code&gt;, &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; or &lt;code&gt;keep_state_and_data&lt;/code&gt; since changing states from a &lt;strong&gt;state enter call&lt;/strong&gt; is not possible anyway.</source>
          <target state="translated">Cuando &lt;code&gt;gen_statem&lt;/code&gt; se ejecuta con &lt;code&gt;&lt;a href=&quot;#type-state_enter&quot;&gt;state enter calls&lt;/a&gt;&lt;/code&gt; , estas funciones tambi&amp;eacute;n se llaman con argumentos &lt;code&gt;(enter, OldState, ...)&lt;/code&gt; siempre que cambia el estado. En este caso, existen algunas restricciones sobre las &lt;code&gt;&lt;a href=&quot;#type-enter_action&quot;&gt;actions&lt;/a&gt;&lt;/code&gt; que se pueden devolver: &lt;code&gt;&lt;a href=&quot;#type-postpone&quot;&gt;postpone()&lt;/a&gt;&lt;/code&gt; no est&amp;aacute; permitido ya que una &lt;strong&gt;llamada de entrada de estado&lt;/strong&gt; no es un evento, por lo que no hay ning&amp;uacute;n evento para posponer, y &lt;code&gt;&lt;a href=&quot;#type-action&quot;&gt;{next_event,_,_}&lt;/a&gt;&lt;/code&gt; no est&amp;aacute; permitido desde El uso de &lt;strong&gt;llamadas de ingreso de estado&lt;/strong&gt; no deber&amp;iacute;a afectar la forma en que se consumen y producen los eventos. Tampoco puede cambiar de estado desde esta llamada. &amp;iquest;Deber&amp;iacute;a devolver &lt;code&gt;{next_state,NextState, ...}&lt;/code&gt; con &lt;code&gt;NextState =/= State&lt;/code&gt; the &lt;code&gt;gen_statem&lt;/code&gt; se bloquea. Tenga en cuenta que en realidad est&amp;aacute; permitido usar &lt;code&gt;{repeat_state, NewData, ...}&lt;/code&gt; aunque tiene poco sentido ya que se le volver&amp;aacute; a llamar inmediatamente con un nuevo &lt;strong&gt;estado enter call,&lt;/strong&gt; lo que lo convierte en una forma extra&amp;ntilde;a de bucle, y hay mejores formas de bucle en Erlang. Si no actualiza &lt;code&gt;NewData&lt;/code&gt; y tiene alguna condici&amp;oacute;n de terminaci&amp;oacute;n de ciclo, o si usa &lt;code&gt;{repeat_state_and_data, _}&lt;/code&gt; o &lt;code&gt;repeat_state_and_data&lt;/code&gt; , &amp;iexcl;tiene un ciclo infinito! Se le recomienda usar &lt;code&gt;{keep_state,...}&lt;/code&gt; , &lt;code&gt;{keep_state_and_data,_}&lt;/code&gt; o &lt;code&gt;keep_state_and_data&lt;/code&gt; ya que cambiar los estados de una &lt;strong&gt;llamada de entrada de estado&lt;/strong&gt; no es posible de todos modos.</target>
        </trans-unit>
        <trans-unit id="88a1846d28e7d4cd1692423afe0396a4f961fecf" translate="yes" xml:space="preserve">
          <source>When the Cover analysis is ready, Cover is stopped and all Cover compiled modules are &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;unloaded&lt;/a&gt;&lt;/code&gt;. The code for &lt;code&gt;channel&lt;/code&gt; is now loaded as usual from a &lt;code&gt;.beam&lt;/code&gt; file in the current path.</source>
          <target state="translated">Cuando el an&amp;aacute;lisis de Cover est&amp;aacute; listo, Cover se detiene y todos los m&amp;oacute;dulos compilados de Cover se &lt;code&gt;&lt;a href=&quot;#loading&quot;&gt;unloaded&lt;/a&gt;&lt;/code&gt; . El c&amp;oacute;digo para el &lt;code&gt;channel&lt;/code&gt; ahora se carga como de costumbre desde un archivo &lt;code&gt;.beam&lt;/code&gt; en la ruta actual.</target>
        </trans-unit>
        <trans-unit id="5e678693029d9376dee27d1a3e9cecfc3eb0694b" translate="yes" xml:space="preserve">
          <source>When the Erlang function &lt;code&gt;t/1&lt;/code&gt; was applied to an Xref server loaded with the current version of OTP, the returned value was close to 84 (percent). This means that the number of indirectly used modules is approximately six times greater when using the module graph. So the answer to the above stated question is that it is definitely worth while using the function graph for this particular analysis. Finally, note that in the presence of unresolved calls, the graphs may be incomplete, which means that there may be indirectly used modules that do not show up.</source>
          <target state="translated">Cuando se aplic&amp;oacute; la funci&amp;oacute;n Erlang &lt;code&gt;t/1&lt;/code&gt; a un servidor Xref cargado con la versi&amp;oacute;n actual de OTP, el valor devuelto fue cercano al 84 (porcentaje). Esto significa que el n&amp;uacute;mero de m&amp;oacute;dulos usados ​​indirectamente es aproximadamente seis veces mayor cuando se usa el gr&amp;aacute;fico de m&amp;oacute;dulo. Entonces, la respuesta a la pregunta anterior es que definitivamente vale la pena usar la gr&amp;aacute;fica de funci&amp;oacute;n para este an&amp;aacute;lisis en particular. Por &amp;uacute;ltimo, tenga en cuenta que en presencia de llamadas no resueltas, los gr&amp;aacute;ficos pueden estar incompletos, lo que significa que puede haber m&amp;oacute;dulos usados ​​indirectamente que no aparecen.</target>
        </trans-unit>
        <trans-unit id="ef14100f6973eec9a2da0c5aac1b652a8be07c43" translate="yes" xml:space="preserve">
          <source>When the Erlang mode is correctly installed, it is automatically activated when a file ending in &lt;code&gt;.erl&lt;/code&gt; or &lt;code&gt;.hrl&lt;/code&gt; is opened in Emacs.</source>
          <target state="translated">Cuando el modo Erlang est&amp;aacute; instalado correctamente, se activa autom&amp;aacute;ticamente cuando se abre un archivo que termina en &lt;code&gt;.erl&lt;/code&gt; o &lt;code&gt;.hrl&lt;/code&gt; en Emacs.</target>
        </trans-unit>
        <trans-unit id="064005753816c68987f62de4089ac63432bbee7f" translate="yes" xml:space="preserve">
          <source>When the Erlang runtime system is automatically started from the &lt;code&gt;S75otp.system&lt;/code&gt; script, the &lt;code&gt;TERM&lt;/code&gt; environment variable must be set. The following is a minimal setting:</source>
          <target state="translated">Cuando el sistema de ejecuci&amp;oacute;n de Erlang se inicia autom&amp;aacute;ticamente desde el script &lt;code&gt;S75otp.system&lt;/code&gt; , se debe establecer la variable de entorno &lt;code&gt;TERM&lt;/code&gt; . La siguiente es una configuraci&amp;oacute;n m&amp;iacute;nima:</target>
        </trans-unit>
        <trans-unit id="e452b2fde57d622fa0997d4cb19e28e4a65d9107" translate="yes" xml:space="preserve">
          <source>When the MGC receives its first message, the Service Change Request, the Megaco application will automatically establish the connection by using the MG MID found in the message header as remote mid.</source>
          <target state="translated">Cuando el MGC reciba su primer mensaje,la Solicitud de Cambio de Servicio,la aplicación Megaco establecerá automáticamente la conexión utilizando el MG MID que se encuentra en el encabezado del mensaje como medio remoto.</target>
        </trans-unit>
        <trans-unit id="0bc1904c9d30ade44fccd694ce928f2cb4a5ad23" translate="yes" xml:space="preserve">
          <source>When the MIB definition work is finished, there are two major issues left.</source>
          <target state="translated">Cuando el trabajo de definición de la MIB esté terminado,quedarán dos cuestiones importantes.</target>
        </trans-unit>
        <trans-unit id="8e36ed72ceac42895c73ec727502a81f2596dcdf" translate="yes" xml:space="preserve">
          <source>When the SASL application is started, it adds a Logger handler that formats and writes these reports, as specified in the &lt;code&gt;configuration parameters for SASL&lt;/code&gt;.</source>
          <target state="translated">Cuando se inicia la aplicaci&amp;oacute;n SASL, agrega un controlador Logger que formatea y escribe estos informes, como se especifica en los &lt;code&gt;configuration parameters for SASL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b73a5fb29f56921e69c0ac4a2cd6ca545f386dd" translate="yes" xml:space="preserve">
          <source>When the SNMP manager has crashed, the dependent client application has to wait for the SNMP manager to be restarted before it can &lt;strong&gt;reconnect&lt;/strong&gt;.</source>
          <target state="translated">Cuando el administrador SNMP falla, la aplicaci&amp;oacute;n cliente dependiente debe esperar a que se reinicie el administrador SNMP antes de que pueda &lt;strong&gt;volver a conectarse&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="a13e96b0328435d455e574296b3ea29ea96cf675" translate="yes" xml:space="preserve">
          <source>When the agent receives a request, it keeps the request ID for one second after the response is sent. If the agent receives another request with the same request ID during this time, from the same IP address and UDP port, that request will be discarded. This mechanism has nothing to do with the function &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt;.</source>
          <target state="translated">Cuando el agente recibe una solicitud, conserva la ID de la solicitud durante un segundo despu&amp;eacute;s de que se env&amp;iacute;a la respuesta. Si el agente recibe otra solicitud con el mismo ID de solicitud durante este tiempo, desde la misma direcci&amp;oacute;n IP y puerto UDP, esa solicitud ser&amp;aacute; descartada. Este mecanismo no tiene nada que ver con la funci&amp;oacute;n &lt;code&gt;snmpa:current_request_id/0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c76ffb17b2706d88d3e12e2091f84905c555d5ff" translate="yes" xml:space="preserve">
          <source>When the agent receives the same get-request as above, a call will be made to &lt;code&gt;generic_access(get,&lt;/code&gt;'&lt;code&gt;IPADR')&lt;/code&gt;.</source>
          <target state="translated">Cuando el agente recibe la misma solicitud de obtenci&amp;oacute;n que la anterior, se realizar&amp;aacute; una llamada a &lt;code&gt;generic_access(get,&lt;/code&gt; ' &lt;code&gt;IPADR')&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e30c9dfb86cccb490ec9efbc09dc8bd03f78db74" translate="yes" xml:space="preserve">
          <source>When the async operation is done, &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt; ready_async&lt;/a&gt;&lt;/code&gt; driver entry function is called. If &lt;code&gt;ready_async&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt; in the driver entry, the &lt;code&gt;async_free&lt;/code&gt; function is called instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93278d10a2e49a183a4771ee8ba18b8f11a4c78" translate="yes" xml:space="preserve">
          <source>When the async operation is done, &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt;ready_async&lt;/a&gt;&lt;/code&gt; driver entry function is called. If &lt;code&gt;ready_async&lt;/code&gt; is &lt;code&gt;NULL&lt;/code&gt; in the driver entry, the &lt;code&gt;async_free&lt;/code&gt; function is called instead.</source>
          <target state="translated">Cuando se realiza la operaci&amp;oacute;n as&amp;iacute;ncrona, se llama a la funci&amp;oacute;n de entrada del controlador &lt;code&gt;&lt;a href=&quot;driver_entry#ready_async&quot;&gt;ready_async&lt;/a&gt;&lt;/code&gt; . Si &lt;code&gt;ready_async&lt;/code&gt; es &lt;code&gt;NULL&lt;/code&gt; en la entrada del controlador, en su &lt;code&gt;async_free&lt;/code&gt; se llama a la funci&amp;oacute;n async_free .</target>
        </trans-unit>
        <trans-unit id="6e4fc871235561b9de4001b6afe210bb33b42832" translate="yes" xml:space="preserve">
          <source>When the atom cache is setup correctly the control message is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="45fda767b9fff4af850e8e6b34bac5b879c78132" translate="yes" xml:space="preserve">
          <source>When the choice of directories in the code path is &lt;code&gt;strict&lt;/code&gt;, the directory that ends up in the code path is exactly the stated one. This means that if, for example, the directory &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7/ebin&lt;/code&gt; is explicitly added to the code path, the code server does not load files from &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt;.</source>
          <target state="translated">Cuando la elecci&amp;oacute;n de directorios en la ruta del c&amp;oacute;digo es &lt;code&gt;strict&lt;/code&gt; , el directorio que termina en la ruta del c&amp;oacute;digo es exactamente el indicado. Esto significa que si, por ejemplo, el directorio &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7/ebin&lt;/code&gt; se agrega expl&amp;iacute;citamente a la ruta del c&amp;oacute;digo, el servidor de c&amp;oacute;digos no carga archivos de &lt;code&gt;$OTPROOT/lib/mnesia-4.4.7.ez/mnesia-4.4.7/ebin&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="595027e4761ef02fd4bdabf68a245651bb72bd11" translate="yes" xml:space="preserve">
          <source>When the command running at the other end terminates, the following message can be sent to return the exit status of the command. A zero &lt;code&gt;exit_status&lt;/code&gt; usually means that the command terminated successfully. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt; ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85eceed499c5d35cfe880d316d8beaf6cbb94efc" translate="yes" xml:space="preserve">
          <source>When the command running at the other end terminates, the following message can be sent to return the exit status of the command. A zero &lt;code&gt;exit_status&lt;/code&gt; usually means that the command terminated successfully. This event is sent as a result of calling &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt;ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Cuando finaliza el comando que se ejecuta en el otro extremo, se puede enviar el siguiente mensaje para devolver el estado de salida del comando. Un &lt;code&gt;exit_status&lt;/code&gt; cero generalmente significa que el comando termin&amp;oacute; con &amp;eacute;xito. Este evento se env&amp;iacute;a como resultado de llamar a &lt;code&gt;&lt;a href=&quot;ssh_connection#exit_status-3&quot;&gt;ssh_connection:exit_status/3&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cb875869619254295ad4372b7bde936078bc212a" translate="yes" xml:space="preserve">
          <source>When the compile server is enabled, &lt;code&gt;erlc&lt;/code&gt; will automatically use the server if it is started and start the server if has not already started. The server will terminate itself when it has been idle for some number of seconds.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3d64a299ff94a9ee47249f94cefcc624dd35a6f" translate="yes" xml:space="preserve">
          <source>When the compiler encounters the module attribute &lt;code&gt;-behaviour(Behaviour).&lt;/code&gt; in a module &lt;code&gt;Mod&lt;/code&gt;, it calls &lt;code&gt;Behaviour:behaviour_info(callbacks)&lt;/code&gt; and compares the result with the set of functions actually exported from &lt;code&gt;Mod&lt;/code&gt;, and issues a warning if any callback function is missing.</source>
          <target state="translated">Cuando el compilador encuentra el atributo del m&amp;oacute;dulo &lt;code&gt;-behaviour(Behaviour).&lt;/code&gt; en un m&amp;oacute;dulo &lt;code&gt;Mod&lt;/code&gt; , llama &lt;code&gt;Behaviour:behaviour_info(callbacks)&lt;/code&gt; y compara el resultado con el conjunto de funciones realmente exportadas desde &lt;code&gt;Mod&lt;/code&gt; , y emite una advertencia si falta alguna funci&amp;oacute;n de devoluci&amp;oacute;n de llamada.</target>
        </trans-unit>
        <trans-unit id="844a9525ff66b482554dce5aa81432bba7df925d" translate="yes" xml:space="preserve">
          <source>When the data has passed through an Ets table, &lt;code&gt;erts_debug:size/1&lt;/code&gt; and &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; return the same value. Sharing has been lost.</source>
          <target state="translated">Cuando los datos han pasado por una tabla de Ets, &lt;code&gt;erts_debug:size/1&lt;/code&gt; y &lt;code&gt;erts_debug:flat_size/1&lt;/code&gt; devuelven el mismo valor. Se ha perdido el compartir.</target>
        </trans-unit>
        <trans-unit id="0180fd29af0af06f5eb68c4a08485d210bd536c3" translate="yes" xml:space="preserve">
          <source>When the data is returned, we deallocate our data.</source>
          <target state="translated">Cuando se devuelven los datos,los distribuimos.</target>
        </trans-unit>
        <trans-unit id="b841886acb544968ed7c8d220277846a17d2018c" translate="yes" xml:space="preserve">
          <source>When the driver has passed the &lt;code&gt;driver_entry&lt;/code&gt; over to the emulator, the driver is &lt;strong&gt;not&lt;/strong&gt; allowed to modify the &lt;code&gt;driver_entry&lt;/code&gt;.</source>
          <target state="translated">Cuando el controlador ha pasado &lt;code&gt;driver_entry&lt;/code&gt; al emulador, el controlador &lt;strong&gt;no&lt;/strong&gt; puede modificar el &lt;code&gt;driver_entry&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ff1b7d404a057ddcb6ce2d59d8b2bdb057597c3d" translate="yes" xml:space="preserve">
          <source>When the driver is implemented, one would preferably write an Erlang interface for the driver to be able to test the functionality of the driver separately. This interface can then be used by the distribution module, which will cover the details of the protocol from the &lt;code&gt;net_kernel&lt;/code&gt;.</source>
          <target state="translated">Cuando se implementa el controlador, es preferible escribir una interfaz Erlang para que el controlador pueda probar la funcionalidad del controlador por separado. Luego, esta interfaz puede ser utilizada por el m&amp;oacute;dulo de distribuci&amp;oacute;n, que cubrir&amp;aacute; los detalles del protocolo del &lt;code&gt;net_kernel&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f7f8ef65dc76d982cfe0dc69232e4e5827bba12" translate="yes" xml:space="preserve">
          <source>When the driver is loaded. This callback must have a special name and inform the emulator of what callbacks are to be used by returning a pointer to a &lt;code&gt;ErlDrvEntry&lt;/code&gt; struct, which is to be properly filled in (see below).</source>
          <target state="translated">Cuando se carga el controlador. Esta devoluci&amp;oacute;n de llamada debe tener un nombre especial e informar al emulador de qu&amp;eacute; devoluciones de llamada se utilizar&amp;aacute;n devolviendo un puntero a una estructura &lt;code&gt;ErlDrvEntry&lt;/code&gt; , que se debe completar correctamente (ver m&amp;aacute;s abajo).</target>
        </trans-unit>
        <trans-unit id="68f883c088fbc777f98b15d9733f9e21c9a4e592" translate="yes" xml:space="preserve">
          <source>When the emulator is run with instrumentation, the &lt;code&gt;system&lt;/code&gt; value is more accurate, but memory directly allocated for &lt;code&gt;malloc&lt;/code&gt; (and friends) is still not part of the &lt;code&gt;system&lt;/code&gt; value. Direct calls to &lt;code&gt;malloc&lt;/code&gt; are only done from OS-specific runtime libraries and perhaps from user-implemented Erlang drivers that do not use the memory allocation functions in the driver interface.</source>
          <target state="translated">Cuando el emulador se ejecuta con instrumentaci&amp;oacute;n, el valor del &lt;code&gt;system&lt;/code&gt; es m&amp;aacute;s preciso, pero la memoria asignada directamente para &lt;code&gt;malloc&lt;/code&gt; (y amigos) a&amp;uacute;n no forma parte del valor del &lt;code&gt;system&lt;/code&gt; . Las llamadas directas a &lt;code&gt;malloc&lt;/code&gt; solo se realizan desde bibliotecas de tiempo de ejecuci&amp;oacute;n espec&amp;iacute;ficas del sistema operativo y quiz&amp;aacute;s desde controladores Erlang implementados por el usuario que no utilizan las funciones de asignaci&amp;oacute;n de memoria en la interfaz del controlador.</target>
        </trans-unit>
        <trans-unit id="77fa82a9f2b1030c7423dea145244305c2d9ec50" translate="yes" xml:space="preserve">
          <source>When the end of the binary is reached and the second clause matches, the match context will simply be discarded (removed in the next garbage collection, as there is no longer any reference to it).</source>
          <target state="translated">Cuando se llegue al final del binario y la segunda cláusula coincida,el contexto de la coincidencia simplemente se descartará (se eliminará en la siguiente recogida de basura,ya que ya no hay ninguna referencia a él).</target>
        </trans-unit>
        <trans-unit id="6749f7e62fded072722b2a6ba9f855671542a797" translate="yes" xml:space="preserve">
          <source>When the external process connected to the port exits, a message of the form &lt;code&gt;{Port,{exit_status,Status}}&lt;/code&gt; is sent to the connected process, where &lt;code&gt;Status&lt;/code&gt; is the exit status of the external process. If the program aborts on Unix, the same convention is used as the shells do (that is, 128+signal).</source>
          <target state="translated">Cuando el proceso externo conectado al puerto sale, se env&amp;iacute;a un mensaje de la forma &lt;code&gt;{Port,{exit_status,Status}}&lt;/code&gt; al proceso conectado, donde &lt;code&gt;Status&lt;/code&gt; es el estado de salida del proceso externo. Si el programa aborta en Unix, se usa la misma convenci&amp;oacute;n que las shells (es decir, se&amp;ntilde;al 128 +).</target>
        </trans-unit>
        <trans-unit id="df6072405416eb31c392fea08909d3e8e4bb8601" translate="yes" xml:space="preserve">
          <source>When the first SMP support was implemented, the table still was kept more or less the same way, but protected by two types of locks. One lock that protected the whole table against modifications and an array of locks protecting different parts of the table. The exact locking strategy previously used isn't interesting. What is interesting is that it suffered from heavy lock contention especially when lots of modifications was being made, but also when only performing lookups.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4264b7112b0cfbe36495f0cf35a65dd07c402f" translate="yes" xml:space="preserve">
          <source>When the function &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; cannot be used, &lt;code&gt;Mnesia&lt;/code&gt; provides the programmer with several functions for matching records against a pattern. The most useful ones are the following:</source>
          <target state="translated">Cuando no se puede usar la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;mnesia#read-3&quot;&gt;mnesia:read/3&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;Mnesia&lt;/code&gt; proporciona al programador varias funciones para comparar registros con un patr&amp;oacute;n. Los m&amp;aacute;s &amp;uacute;tiles son los siguientes:</target>
        </trans-unit>
        <trans-unit id="0a19808ffaca3fd048abe14ac1422112fae7f8be" translate="yes" xml:space="preserve">
          <source>When the function returns &lt;code&gt;{ok, pending_driver}&lt;/code&gt; or &lt;code&gt;{ok, pending_process}&lt;/code&gt;, one can get information about when the driver is &lt;strong&gt;actually&lt;/strong&gt; loaded by using option &lt;code&gt;{monitor, MonitorOption}&lt;/code&gt;.</source>
          <target state="translated">Cuando la funci&amp;oacute;n devuelve &lt;code&gt;{ok, pending_driver}&lt;/code&gt; o &lt;code&gt;{ok, pending_process}&lt;/code&gt; , se puede obtener informaci&amp;oacute;n sobre cu&amp;aacute;ndo se carga &lt;strong&gt;realmente&lt;/strong&gt; el controlador utilizando la opci&amp;oacute;n &lt;code&gt;{monitor, MonitorOption}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f1ba8ad7fadddd0bcf392a93e44763cd846c6e5a" translate="yes" xml:space="preserve">
          <source>When the indexed set is a set of subsets of a set X, we call x a &lt;strong id=&quot;family&quot;&gt;family of subsets&lt;/strong&gt; of X.</source>
          <target state="translated">Cuando el conjunto indexado es un conjunto de subconjuntos de un conjunto X, llamamos x una &lt;strong id=&quot;family&quot;&gt;familia de subconjuntos&lt;/strong&gt; de X.</target>
        </trans-unit>
        <trans-unit id="b2e8e9476aa05c51f4eed310e674f5ac07849f6f" translate="yes" xml:space="preserve">
          <source>When the initial message arrives the transport service forwards it to the protocol engine which automatically sets up the connection and invokes UserMod:handle_connect/2 before it invokes UserMod:handle_trans_request/3 with the Service Change Request like this:</source>
          <target state="translated">Cuando llega el mensaje inicial,el servicio de transporte lo reenvía al motor de protocolo que establece automáticamente la conexión e invoca UserMod:handle_connect/2 antes de invocar UserMod:handle_trans_request/3 con la solicitud de cambio de servicio de esta manera:</target>
        </trans-unit>
        <trans-unit id="0b479e3b528c8dff428a540e36a91f070ee36f40" translate="yes" xml:space="preserve">
          <source>When the instrumentation function for the distributed table is called, the request should be forwarded to the table coordinator. The coordinator finds the requested information among the table holders and then returns the answer to the instrumentation function. The SNMP toolkit contains no support for coordination of tables since this must be independent of the implementation.</source>
          <target state="translated">Cuando se llame a la función de instrumentación para la mesa distribuida,la solicitud debe ser enviada al coordinador de la mesa.El coordinador encuentra la información solicitada entre los poseedores de la mesa y luego devuelve la respuesta a la función de instrumentación.El juego de instrumentos del SNMP no contiene ningún apoyo para la coordinación de las mesas,ya que ésta debe ser independiente de la aplicación.</target>
        </trans-unit>
        <trans-unit id="ed66203a9ff8a8d98b96888faa38dea3f3883c7b" translate="yes" xml:space="preserve">
          <source>When the leader threads is about to increment the global thread progress counter it verifies that the &lt;code&gt;waiting&lt;/code&gt; counter is zero before doing so. If not zero, the leader isn't allowed to increment the global counter, and needs to wait before it can do this. When it is zero, it swaps the &lt;code&gt;waiting&lt;/code&gt; and &lt;code&gt;current&lt;/code&gt; counters before increasing the global counter. From now on the new &lt;code&gt;waiting&lt;/code&gt; counter will decrease, so that it eventually will reach zero, making it possible to increment the global counter the next time. If we only used one reference counter it would potentially be held above zero for ever by different unmanaged threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbdd5b69553712e53dab4940441e84bad5a0b9c4" translate="yes" xml:space="preserve">
          <source>When the loader has found a match and replaced the matched instructions, it will match the new instructions against the transformation rules. Because of that, we can define the rule for a &lt;code&gt;move3/6&lt;/code&gt; instruction as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da9cfdd647592377ae23a5bc7ddcc96274b2c1de" translate="yes" xml:space="preserve">
          <source>When the loader translates a generic instruction a specific instruction, it will choose the most specific instruction that will fit the types. Consider the following two instructions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d4612fb76d339a555d7ce395426dfd7559ca7e3" translate="yes" xml:space="preserve">
          <source>When the logs are full, &lt;code&gt;run_erl&lt;/code&gt; deletes and reuses the oldest log file.</source>
          <target state="translated">Cuando los registros est&amp;aacute;n llenos, &lt;code&gt;run_erl&lt;/code&gt; elimina y reutiliza el archivo de registro m&amp;aacute;s antiguo.</target>
        </trans-unit>
        <trans-unit id="981906d024a846c5ad60dd39439e2525942f2a29" translate="yes" xml:space="preserve">
          <source>When the message queue grows larger than this threshold, the handler switches to a mode in which it drops all new events that senders want to log. Dropping an event in this mode means that the call to the log function never results in a message being sent to the handler, but the function returns without taking any action. The handler keeps logging the events that are already in its message queue, and when the length of the message queue is reduced to a level below the threshold, synchronous or asynchronous mode is resumed. Notice that when the handler activates or deactivates drop mode, information about it is printed in the log.</source>
          <target state="translated">Cuando la cola de mensajes crece por encima de este umbral,el manejador cambia a un modo en el que deja caer todos los nuevos eventos que los remitentes quieren registrar.Dejar caer un evento en este modo significa que la llamada a la función de registro nunca da lugar a que se envíe un mensaje al manejador,sino que la función regresa sin realizar ninguna acción.El manejador sigue registrando los eventos que ya están en su cola de mensajes,y cuando la longitud de la cola de mensajes se reduce a un nivel inferior al umbral,se reanuda el modo síncrono o asíncrono.Observe que cuando el manejador activa o desactiva el modo drop,la información sobre él se imprime en el registro.</target>
        </trans-unit>
        <trans-unit id="377865ca162dc01a005c1cf33711bbbcf3cf6d3a" translate="yes" xml:space="preserve">
          <source>When the modifier &lt;code&gt;l&lt;/code&gt; is specified, no detection of printable character lists takes place, for example:</source>
          <target state="translated">Cuando se especifica el modificador &lt;code&gt;l&lt;/code&gt; , no tiene lugar ninguna detecci&amp;oacute;n de listas de caracteres imprimibles, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="28bc31ee472c6a6f71d309884c8eb89c306960b4" translate="yes" xml:space="preserve">
          <source>When the monitor is triggered a &lt;code&gt;'CHANGE'&lt;/code&gt; message is sent to the monitoring process. A &lt;code&gt;'CHANGE'&lt;/code&gt; message has the following pattern:</source>
          <target state="translated">Cuando se activa el monitor, se env&amp;iacute;a un mensaje de &lt;code&gt;'CHANGE'&lt;/code&gt; al proceso de monitorizaci&amp;oacute;n. Un mensaje de &lt;code&gt;'CHANGE'&lt;/code&gt; tiene el siguiente patr&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="3d47c0ec76e9a52aa79d01cf4b6274b0076998f6" translate="yes" xml:space="preserve">
          <source>When the number of schedulers is less than or equal to the limit, each scheduler has its own group. When the number of schedulers is larger than the groups limit, schedulers share groups. Shared groups degrade the performance for updating counters while many reader groups degrade the performance for reading counters. So, the limit is a tradeoff between performance for update operations and performance for read operations. Each group consumes 64 bytes in each counter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6576c399613f943fdf757c4457a0db8dddece67" translate="yes" xml:space="preserve">
          <source>When the number of schedulers is less than or equal to the reader groups limit, each scheduler has its own reader group. When the number of schedulers is larger than the reader groups limit, schedulers share reader groups. Shared reader groups degrade read lock and read unlock performance while many reader groups degrade write lock performance. So, the limit is a tradeoff between performance for read operations and performance for write operations. Each reader group consumes 64 byte in each read/write lock.</source>
          <target state="translated">Cuando el número de programadores es menor o igual al límite de grupos de lectores,cada programador tiene su propio grupo de lectores.Cuando el número de programadores es mayor que el límite de grupos de lectores,los programadores comparten grupos de lectores.Los grupos de lectura compartidos degradan el rendimiento de bloqueo de lectura y desbloqueo de lectura mientras que muchos grupos de lectura degradan el rendimiento de bloqueo de escritura.Por lo tanto,el límite es un compromiso entre el rendimiento de las operaciones de lectura y el rendimiento de las operaciones de escritura.Cada grupo de lectores consume 64 bytes en cada bloqueo de lectura/escritura.</target>
        </trans-unit>
        <trans-unit id="36226219dde60c8da7ee7e2f3ead5fe94e62e1f9" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;maps&lt;/code&gt; is given, no &lt;code&gt;.hrl&lt;/code&gt; files will be generated. The rest of this section describes the behavior of the compiler when &lt;code&gt;maps&lt;/code&gt; is not used.</source>
          <target state="translated">Cuando se dan los &lt;code&gt;maps&lt;/code&gt; opciones , no se &lt;code&gt;.hrl&lt;/code&gt; archivos .hrl . El resto de esta secci&amp;oacute;n describe el comportamiento del compilador cuando no se utilizan &lt;code&gt;maps&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3aa9d256c6870da7786d0742b3407e51201c5bd" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be performed in addition to the usual x509-path validation checks. If the check fails the error {bad_cert, hostname_check_failed} will be propagated to the path validation fun &lt;code&gt;&lt;a href=&quot;#type-custom_verify&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;, where it is possible to do customized checks by using the full possibilities of the &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; API. When the option &lt;code&gt;server_name_indication&lt;/code&gt; is provided, its value (the DNS name) will be used as &lt;code&gt;ReferenceID&lt;/code&gt; to &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;. When no &lt;code&gt;server_name_indication&lt;/code&gt; option is given, the &lt;code&gt;Host&lt;/code&gt; argument will be used as Server Name Indication extension. The &lt;code&gt;Host&lt;/code&gt; argument will also be used for the &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; check and if the &lt;code&gt;Host&lt;/code&gt; argument is an &lt;code&gt;inet:ip_address()&lt;/code&gt; the &lt;code&gt;ReferenceID&lt;/code&gt; used for the check will be &lt;code&gt;{ip, Host}&lt;/code&gt; otherwise &lt;code&gt;dns_id&lt;/code&gt; will be assumed with a fallback to &lt;code&gt;ip&lt;/code&gt; if that fails.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54a21311cf0fcf49981af7057a09551734c3f7b1" translate="yes" xml:space="preserve">
          <source>When the option &lt;code&gt;verify&lt;/code&gt; is set to &lt;code&gt;verify_peer&lt;/code&gt; the check &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; will be performed in addition to the usual x509-path validation checks. If the check fails the error {bad_cert, hostname_check_failed} will be propagated to the path validation fun &lt;code&gt;&lt;a href=&quot;#verify_fun&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt;, where it is possible to do customized checks by using the full possibilities of the &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; API. When the option &lt;code&gt;server_name_indication&lt;/code&gt; is provided, its value (the DNS name) will be used as &lt;code&gt;ReferenceID&lt;/code&gt; to &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt;. When no &lt;code&gt;server_name_indication&lt;/code&gt; option is given, the &lt;code&gt;Host&lt;/code&gt; argument will be used as Server Name Indication extension. The &lt;code&gt;Host&lt;/code&gt; argument will also be used for the &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; check and if the &lt;code&gt;Host&lt;/code&gt; argument is an &lt;code&gt;inet:ip_address()&lt;/code&gt; the &lt;code&gt;ReferenceID&lt;/code&gt; used for the check will be &lt;code&gt;{ip, Host}&lt;/code&gt; otherwise &lt;code&gt;dns_id&lt;/code&gt; will be assumed with a fallback to &lt;code&gt;ip&lt;/code&gt; if that fails.</source>
          <target state="translated">Cuando la opci&amp;oacute;n &lt;code&gt;verify&lt;/code&gt; se establece en &lt;code&gt;verify_peer&lt;/code&gt; el cheque &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; se llevar&amp;aacute; a cabo, adem&amp;aacute;s de los controles habituales de validaci&amp;oacute;n x509-path. Si la comprobaci&amp;oacute;n falla, el error {bad_cert, hostname_check_failed} se propagar&amp;aacute; a la ruta de validaci&amp;oacute;n fun &lt;code&gt;&lt;a href=&quot;#verify_fun&quot;&gt;verify_fun&lt;/a&gt;&lt;/code&gt; , donde es posible realizar comprobaciones personalizadas utilizando todas las posibilidades de la &lt;code&gt;public_key:pkix_verify_hostname/3&lt;/code&gt; . Cuando se proporciona la opci&amp;oacute;n &lt;code&gt;server_name_indication&lt;/code&gt; , su valor (el nombre DNS) se utilizar&amp;aacute; como &lt;code&gt;ReferenceID&lt;/code&gt; para &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; . Cuando no se proporciona la opci&amp;oacute;n &lt;code&gt;server_name_indication&lt;/code&gt; , la &lt;code&gt;Host&lt;/code&gt; argumento de host se utilizar&amp;aacute; como extensi&amp;oacute;n de indicaci&amp;oacute;n de nombre de servidor. El argumento de &lt;code&gt;Host&lt;/code&gt; tambi&amp;eacute;n se usar&amp;aacute; para la &lt;code&gt;public_key:pkix_verify_hostname/2&lt;/code&gt; y si el argumento de &lt;code&gt;Host&lt;/code&gt; es un &lt;code&gt;inet:ip_address()&lt;/code&gt; el &lt;code&gt;ReferenceID&lt;/code&gt; usado para la verificaci&amp;oacute;n ser&amp;aacute; &lt;code&gt;{ip, Host}&lt;/code&gt; contrario, &lt;code&gt;dns_id&lt;/code&gt; se asumir&amp;aacute; con un respaldo a &lt;code&gt;ip&lt;/code&gt; si eso falla.</target>
        </trans-unit>
        <trans-unit id="a93a77e10e8decc9a9a5af353d5ffa646066813a" translate="yes" xml:space="preserve">
          <source>When the port has been opened, the driver can be called. In the &lt;code&gt;pg_sync&lt;/code&gt; example, we do not have any data from the port, only the return value from the &lt;code&gt;port_control&lt;/code&gt;.</source>
          <target state="translated">Cuando se ha abierto el puerto, se puede llamar al conductor. En el ejemplo de &lt;code&gt;pg_sync&lt;/code&gt; , no tenemos ning&amp;uacute;n dato del puerto, solo el valor de retorno de &lt;code&gt;port_control&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fc2960ec142372aacf524e3c02cb29b3deda53c6" translate="yes" xml:space="preserve">
          <source>When the port is in &lt;code&gt;data&lt;/code&gt; mode, all data is sent to Erlang in a format that suits the distribution. In fact, the raw data will never reach any Erlang process, but will be translated/interpreted by the emulator itself and then delivered in the correct format to the correct processes. In the current emulator version, received data is to be tagged with a single byte of 100. That is what the macro &lt;code&gt;DIST_MAGIC_RECV_TAG&lt;/code&gt; is defined to. The tagging of data in the distribution can be changed in the future.</source>
          <target state="translated">Cuando el puerto est&amp;aacute; en modo de &lt;code&gt;data&lt;/code&gt; , todos los datos se env&amp;iacute;an a Erlang en un formato que se adapta a la distribuci&amp;oacute;n. De hecho, los datos sin procesar nunca llegar&amp;aacute;n a ning&amp;uacute;n proceso de Erlang, pero ser&amp;aacute;n traducidos / interpretados por el propio emulador y luego entregados en el formato correcto a los procesos correctos. En la versi&amp;oacute;n actual del emulador, los datos recibidos deben etiquetarse con un solo byte de 100. Eso es lo que define la macro &lt;code&gt;DIST_MAGIC_RECV_TAG&lt;/code&gt; . El etiquetado de datos en la distribuci&amp;oacute;n se puede cambiar en el futuro.</target>
        </trans-unit>
        <trans-unit id="14aeddf1e34ec4456d4c5825309b75866f73f2c8" translate="yes" xml:space="preserve">
          <source>When the ports internal output queue size becomes larger than or equal to &lt;code&gt;High&lt;/code&gt; bytes, it enters the busy state. When it becomes less than &lt;code&gt;Low&lt;/code&gt; bytes it leaves the busy state. When the port is in the busy state, processes sending commands to it will be suspended until the port leaves the busy state. Commands are in this context either &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; or &lt;code&gt;port_command/[2,3]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59898e3066f19ccd1cc5fc312adea30ee33171ba" translate="yes" xml:space="preserve">
          <source>When the ports message queue size becomes larger than or equal to &lt;code&gt;High&lt;/code&gt; bytes it enters the busy state. When it becomes less than &lt;code&gt;Low&lt;/code&gt; bytes it leaves the busy state. When the port message queue is in the busy state, processes sending commands to it will be suspended until the port message queue leaves the busy state. Commands are in this context either &lt;code&gt;Port ! {Owner, {command, Data}}&lt;/code&gt; or &lt;code&gt;port_command/[2,3]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98a5fc45c74e8bc2edca91ff415618981adda324" translate="yes" xml:space="preserve">
          <source>When the protocol is available to Erlang through a driver and an Erlang interface module, a distribution module can be written. The distribution module is a module with well-defined callbacks, much like a &lt;code&gt;gen_server&lt;/code&gt; (there is no compiler support for checking the callbacks, though). This module implements:</source>
          <target state="translated">Cuando el protocolo est&amp;aacute; disponible para Erlang a trav&amp;eacute;s de un controlador y un m&amp;oacute;dulo de interfaz Erlang, se puede escribir un m&amp;oacute;dulo de distribuci&amp;oacute;n. El m&amp;oacute;dulo de distribuci&amp;oacute;n es un m&amp;oacute;dulo con devoluciones de llamada bien definidas, muy parecido a &lt;code&gt;gen_server&lt;/code&gt; ( aunque no hay soporte de compilador para verificar las devoluciones de llamada). Este m&amp;oacute;dulo implementa:</target>
        </trans-unit>
        <trans-unit id="be29dce95eec97a67e2087b38e94bd51a5e3dde0" translate="yes" xml:space="preserve">
          <source>When the queue contains data, the driver does not close until the queue is empty.</source>
          <target state="translated">Cuando la cola contiene datos,el conductor no se cierra hasta que la cola está vacía.</target>
        </trans-unit>
        <trans-unit id="21ba1599707f578e6da25bafa5c66c03f204937f" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it first generates a temporary boot file, which starts the new versions of the emulator and the core applications, and the old version of all other applications. Then it shuts down the current emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system is rebooted by the &lt;code&gt;heart&lt;/code&gt; program, using the temporary boot file. After the reboot, the rest of the relup instructions are executed. This is done as a part of the temporary boot script.</source>
          <target state="translated">Cuando el controlador de versi&amp;oacute;n encuentra la instrucci&amp;oacute;n, primero genera un archivo de inicio temporal, que inicia las nuevas versiones del emulador y las aplicaciones principales, y la versi&amp;oacute;n anterior de todas las dem&amp;aacute;s aplicaciones. Luego apaga el emulador actual llamando a &lt;code&gt;init:reboot()&lt;/code&gt; , vea la p&amp;aacute;gina de manual &lt;code&gt;init(3)&lt;/code&gt; en Kernel. Todos los procesos terminan correctamente y el programa del &lt;code&gt;heart&lt;/code&gt; reinicia el sistema , utilizando el archivo de inicio temporal. Despu&amp;eacute;s del reinicio, se ejecutan el resto de las instrucciones de actualizaci&amp;oacute;n. Esto se hace como parte del script de arranque temporal.</target>
        </trans-unit>
        <trans-unit id="cee98f8753d15dee1e12f17349a48be34b074873" translate="yes" xml:space="preserve">
          <source>When the release handler encounters the instruction, it shuts down the emulator by calling &lt;code&gt;init:reboot()&lt;/code&gt;, see the &lt;code&gt;init(3)&lt;/code&gt; manual page in Kernel. All processes are terminated gracefully and the system can then be rebooted by the &lt;code&gt;heart&lt;/code&gt; program using the new release version. No more upgrade instruction is executed after the restart.</source>
          <target state="translated">Cuando el controlador de lanzamiento encuentra la instrucci&amp;oacute;n, apaga el emulador llamando a &lt;code&gt;init:reboot()&lt;/code&gt; , vea la p&amp;aacute;gina de manual &lt;code&gt;init(3)&lt;/code&gt; en Kernel. Todos los procesos se terminan correctamente y el programa del &lt;code&gt;heart&lt;/code&gt; puede reiniciar el sistema con la nueva versi&amp;oacute;n de lanzamiento. No se ejecutan m&amp;aacute;s instrucciones de actualizaci&amp;oacute;n despu&amp;eacute;s del reinicio.</target>
        </trans-unit>
        <trans-unit id="a250d269026a9e3f5fca66518f55dd84f05c8c5d" translate="yes" xml:space="preserve">
          <source>When the request is received, the &lt;code&gt;gen_server&lt;/code&gt; calls &lt;code&gt;handle_cast(Request, State)&lt;/code&gt;, which is expected to return a tuple &lt;code&gt;{noreply,State1}&lt;/code&gt;. &lt;code&gt;State1&lt;/code&gt; is a new value for the state of the &lt;code&gt;gen_server&lt;/code&gt;.</source>
          <target state="translated">Cuando se recibe la solicitud, &lt;code&gt;gen_server&lt;/code&gt; llama a &lt;code&gt;handle_cast(Request, State)&lt;/code&gt; , que se espera que devuelva una tupla &lt;code&gt;{noreply,State1}&lt;/code&gt; . &lt;code&gt;State1&lt;/code&gt; es un nuevo valor para el estado de &lt;code&gt;gen_server&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="8d57c2ee62a9879fde2097882cf19d4663d2b600" translate="yes" xml:space="preserve">
          <source>When the restricted shell evaluates an expression and encounters a function call or an operator application, it calls a callback function (with information about the function call in question). This callback function returns &lt;code&gt;true&lt;/code&gt; to let the shell go ahead with the evaluation, or &lt;code&gt;false&lt;/code&gt; to abort it. There are two possible callback functions for the user to implement:</source>
          <target state="translated">Cuando el shell restringido eval&amp;uacute;a una expresi&amp;oacute;n y encuentra una llamada de funci&amp;oacute;n o una aplicaci&amp;oacute;n de operador, llama a una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada (con informaci&amp;oacute;n sobre la llamada de funci&amp;oacute;n en cuesti&amp;oacute;n). Esta funci&amp;oacute;n de devoluci&amp;oacute;n de llamada devuelve &lt;code&gt;true&lt;/code&gt; para permitir que el shell siga adelante con la evaluaci&amp;oacute;n, o &lt;code&gt;false&lt;/code&gt; para cancelarla. Hay dos posibles funciones de devoluci&amp;oacute;n de llamada que puede implementar el usuario:</target>
        </trans-unit>
        <trans-unit id="c54c402919b78665c1c8f198f292bab9fc59cd16" translate="yes" xml:space="preserve">
          <source>When the server is asked to provide a document type that cannot be determined by the MIME Type Settings, the server uses this default type.</source>
          <target state="translated">Cuando se le pide al servidor que proporcione un tipo de documento que no puede ser determinado por la configuración del tipo de MIME,el servidor utiliza este tipo predeterminado.</target>
        </trans-unit>
        <trans-unit id="bb82b8ca8c5a5957509c8e72df7e62feb33df317" translate="yes" xml:space="preserve">
          <source>When the shell starts, it starts a single evaluator process. This process, together with any local processes that it spawns, is referred to as a &lt;code&gt;job&lt;/code&gt;. Only the current job, which is said to be &lt;code&gt;connected&lt;/code&gt;, can perform operations with standard I/O. All other jobs, which are said to be &lt;code&gt;detached&lt;/code&gt;, are &lt;code&gt;blocked&lt;/code&gt; if they attempt to use standard I/O.</source>
          <target state="translated">Cuando se inicia el shell, comienza un proceso de evaluador &amp;uacute;nico. Este proceso, junto con los procesos locales que genera, se conoce como &lt;code&gt;job&lt;/code&gt; . Solo el trabajo actual, que se dice que est&amp;aacute; &lt;code&gt;connected&lt;/code&gt; , puede realizar operaciones con E / S est&amp;aacute;ndar. Todos los dem&amp;aacute;s trabajos, que se dice que est&amp;aacute;n &lt;code&gt;detached&lt;/code&gt; , se &lt;code&gt;blocked&lt;/code&gt; si intentan utilizar E / S est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="3c74035ba1de254b56bab74be22512784e14aa0a" translate="yes" xml:space="preserve">
          <source>When the size of all received requests exceeds &lt;code&gt;trans_req_maxsize&lt;/code&gt;.</source>
          <target state="translated">Cuando el tama&amp;ntilde;o de todas las solicitudes recibidas excede &lt;code&gt;trans_req_maxsize&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf7ff81cd7bcbcf93265972ba220ec58a44a2621" translate="yes" xml:space="preserve">
          <source>When the specified event occurs, the function &lt;code&gt;Function&lt;/code&gt; is called as:</source>
          <target state="translated">Cuando ocurre el evento especificado, la funci&amp;oacute;n &lt;code&gt;Function&lt;/code&gt; se llama como:</target>
        </trans-unit>
        <trans-unit id="a9b740db20f360e56cbaf192b02a625103f61f81" translate="yes" xml:space="preserve">
          <source>When the supervisor terminates, then the next higher-level supervisor takes some action. It either restarts the terminated supervisor or terminates itself.</source>
          <target state="translated">Cuando el supervisor termina,entonces el siguiente supervisor de nivel superior toma alguna acción.Reinicia al supervisor despedido o se despide él mismo.</target>
        </trans-unit>
        <trans-unit id="4bf56603de100efc3ae31dee0fc9c437fdd57542" translate="yes" xml:space="preserve">
          <source>When the thread progress functionality had been introduced, we could remove the code implementing the &quot;confirm deletion&quot; jobs, and then just schedule a thread progress later operation which deallocates the structure. Besides simplifying the code a lot, we got an increase of more than 10% of the number of transactions per second handled on a mnesia tpcb benchmark executing on a quad core machine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f021b23bfe2cd55d1b599da584871e714016f843" translate="yes" xml:space="preserve">
          <source>When the timer finally expires, a &quot;megaco segments not received&quot; (459) error message is sent to the other side and the user is notified with a &lt;code&gt;segment timeout&lt;/code&gt;&lt;code&gt;UserReply&lt;/code&gt; in either the &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; callback function or the return value of the &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Cuando el temporizador finalmente expira, se env&amp;iacute;a un mensaje de error &quot;megaco segmentos no recibidos&quot; (459) al otro lado y se notifica al usuario con un &lt;code&gt;segment timeout&lt;/code&gt; &lt;code&gt;UserReply&lt;/code&gt; en la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;&lt;a href=&quot;megaco_user#trans_reply&quot;&gt;handle_trans_reply&lt;/a&gt;&lt;/code&gt; o en el valor de retorno de la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;megaco#call&quot;&gt;call&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="10342b65ac706e0b7d9b742b8194ae1261e8bece" translate="yes" xml:space="preserve">
          <source>When the timer reaches &lt;code&gt;0&lt;/code&gt; and expires, the driver entry function &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt; timeout&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bf973279da0cedc632ba88c183b69c62e648346" translate="yes" xml:space="preserve">
          <source>When the timer reaches &lt;code&gt;0&lt;/code&gt; and expires, the driver entry function &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; is called.</source>
          <target state="translated">Cuando el temporizador llega a &lt;code&gt;0&lt;/code&gt; y expira, se llama al &lt;code&gt;&lt;a href=&quot;driver_entry#timeout&quot;&gt;timeout&lt;/a&gt;&lt;/code&gt; funci&amp;oacute;n de entrada del controlador .</target>
        </trans-unit>
        <trans-unit id="9a9f3b6a59efe7a46474fcba7bb50d20a40f5897" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the request is resent and the timer is restarted.</source>
          <target state="translated">Cuando el temporizador llega a un vencimiento intermedio,se vuelve a enviar la solicitud y se reinicia el temporizador.</target>
        </trans-unit>
        <trans-unit id="fd4e877095aa4be1ada9827ad7529e4bc18e2c51" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer is restarted.</source>
          <target state="translated">Cuando el temporizador alcanza un vencimiento intermedio,el temporizador se reinicia.</target>
        </trans-unit>
        <trans-unit id="157d3bfb09cfc45ece6b6d5a8c11a2c6035409d0" translate="yes" xml:space="preserve">
          <source>When the timer reaches an intermediate expire, the timer restarted.</source>
          <target state="translated">Cuando el temporizador llega a un vencimiento intermedio,el temporizador se reinicia.</target>
        </trans-unit>
        <trans-unit id="e2702c4a29cb7ffd2d62635fddc60ffda837b937" translate="yes" xml:space="preserve">
          <source>When the timer reaches the final expire, either the function &lt;code&gt;megaco:call&lt;/code&gt; will return with &lt;code&gt;{error, timeout}&lt;/code&gt; or the callback function &lt;code&gt;handle_trans_reply&lt;/code&gt; will be called with &lt;code&gt;UserReply = {error, timeout}&lt;/code&gt; (if &lt;code&gt;megaco:cast&lt;/code&gt; was used).</source>
          <target state="translated">Cuando el temporizador llega al vencimiento final, la funci&amp;oacute;n &lt;code&gt;megaco:call&lt;/code&gt; regresar&amp;aacute; con &lt;code&gt;{error, timeout}&lt;/code&gt; o la funci&amp;oacute;n de devoluci&amp;oacute;n de llamada &lt;code&gt;handle_trans_reply&lt;/code&gt; se llamar&amp;aacute; con &lt;code&gt;UserReply = {error, timeout}&lt;/code&gt; (si se &lt;code&gt;megaco:cast&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5d489b1aa41c1da0731c58c4d8333c65b8fb249f" translate="yes" xml:space="preserve">
          <source>When the tracing is completed, stop the tracer with &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0,1&lt;/a&gt;&lt;/code&gt; and format the trace log with &lt;code&gt;&lt;a href=&quot;ttb#format-1&quot;&gt;ttb:format/1,2&lt;/a&gt;&lt;/code&gt; (if there is anything to format).</source>
          <target state="translated">Cuando se complete el rastreo, detenga el rastreador con &lt;code&gt;&lt;a href=&quot;ttb#stop-0&quot;&gt;ttb:stop/0,1&lt;/a&gt;&lt;/code&gt; y formatee el registro de rastreo con &lt;code&gt;&lt;a href=&quot;ttb#format-1&quot;&gt;ttb:format/1,2&lt;/a&gt;&lt;/code&gt; (si hay algo que formatear).</target>
        </trans-unit>
        <trans-unit id="c36338011eef64525211dd65889fb16a9937ec35" translate="yes" xml:space="preserve">
          <source>When the transaction sender receives a request which is already &quot;in storage&quot; (indicated by the transaction id) it is assumed to be a resend and everything stored is sent. This could happen if the values of the &lt;code&gt;trans_timer&lt;/code&gt; and the &lt;code&gt;request_timer&lt;/code&gt; is not properly chosen.</source>
          <target state="translated">Cuando el remitente de la transacci&amp;oacute;n recibe una solicitud que ya est&amp;aacute; &quot;almacenada&quot; (indicado por el ID de la transacci&amp;oacute;n), se asume que es un reenv&amp;iacute;o y se env&amp;iacute;a todo lo almacenado. Esto podr&amp;iacute;a ocurrir si los valores de la &lt;code&gt;trans_timer&lt;/code&gt; y la &lt;code&gt;request_timer&lt;/code&gt; no se haya realizado correctamente.</target>
        </trans-unit>
        <trans-unit id="7862d7ec18f93027c83a7039d6cf2d951465703f" translate="yes" xml:space="preserve">
          <source>When the user has processed a transaction request in its callback function, the Megaco application assembles a transaction reply, encodes it using the selected encoding module and sends the message back by invoking the callback function:</source>
          <target state="translated">Cuando el usuario ha procesado una solicitud de transacción en su función de devolución de llamada,la aplicación Megaco ensambla una respuesta de transacción,la codifica utilizando el módulo de codificación seleccionado y devuelve el mensaje invocando la función de devolución de llamada:</target>
        </trans-unit>
        <trans-unit id="17fcbf724175dd6197cb33c7a80fb993e93fef84" translate="yes" xml:space="preserve">
          <source>When the web server is started at application start time, the properties are to be fetched from a configuration file that can consist of a regular Erlang property list, that is, &lt;code&gt;[{Option, Value}]&lt;/code&gt;, where &lt;code&gt;Option = property()&lt;/code&gt; and &lt;code&gt;Value = term()&lt;/code&gt;, followed by a full stop, or for backwards compatibility, an Apache-like configuration file. If the web server is started dynamically at runtime, a file can still be specified but also the complete property list.</source>
          <target state="translated">Cuando el servidor web se inicia en el momento de inicio de la aplicaci&amp;oacute;n, las propiedades deben obtenerse de un archivo de configuraci&amp;oacute;n que puede consistir en una lista de propiedades Erlang regular, es decir, &lt;code&gt;[{Option, Value}]&lt;/code&gt; , donde &lt;code&gt;Option = property()&lt;/code&gt; y &lt;code&gt;Value = term()&lt;/code&gt; , seguido de un punto, o para compatibilidad con versiones anteriores, un archivo de configuraci&amp;oacute;n similar a Apache. Si el servidor web se inicia din&amp;aacute;micamente en tiempo de ejecuci&amp;oacute;n, a&amp;uacute;n se puede especificar un archivo, pero tambi&amp;eacute;n la lista de propiedades completa.</target>
        </trans-unit>
        <trans-unit id="0f19d5cdc9a0560a6838aca779192793025acf9d" translate="yes" xml:space="preserve">
          <source>When the web server is started at application start time, the properties are to be fetched from a configuration file that can consist of a regular Erlang property list, that is, &lt;code&gt;[{Option, Value}]&lt;/code&gt;, where &lt;code&gt;Option = property()&lt;/code&gt; and &lt;code&gt;Value = term()&lt;/code&gt;, followed by a full stop. If the web server is started dynamically at runtime, a file can still be specified but also the complete property list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8385f08e883f730c6d6877fd915bdc9c53f2091" translate="yes" xml:space="preserve">
          <source>When the whole driver is unloaded. Every resource allocated by the driver is to be freed.</source>
          <target state="translated">Cuando todo el conductor esté descargado.Cada recurso asignado por el conductor debe ser liberado.</target>
        </trans-unit>
        <trans-unit id="1864bbfe1bb4da0ed39ef620a0d58a044889dcf3" translate="yes" xml:space="preserve">
          <source>When the window (terminal) size changes on the client side, it &lt;strong&gt;can&lt;/strong&gt; send a message to the server side to inform it of the new dimensions. No API function generates this event.</source>
          <target state="translated">Cuando el tama&amp;ntilde;o de la ventana (terminal) cambia en el lado del cliente, &lt;strong&gt;puede&lt;/strong&gt; enviar un mensaje al lado del servidor para informarle de las nuevas dimensiones. Ninguna funci&amp;oacute;n de API genera este evento.</target>
        </trans-unit>
        <trans-unit id="6ae6cb0d1aeff4baecd961c38c7a0d0343bce682" translate="yes" xml:space="preserve">
          <source>When there are no generators or bit string generators, a list comprehension returns either a list with one element (the result of evaluating &lt;code&gt;Expr&lt;/code&gt;) if all filters are true or an empty list otherwise.</source>
          <target state="translated">Cuando no hay generadores o generadores de cadenas de bits, una lista por comprensi&amp;oacute;n devuelve una lista con un elemento (el resultado de evaluar &lt;code&gt;Expr&lt;/code&gt; ) si todos los filtros son verdaderos o una lista vac&amp;iacute;a en caso contrario.</target>
        </trans-unit>
        <trans-unit id="68c8a10137c4675b33b04fc152e8dd169fb08630" translate="yes" xml:space="preserve">
          <source>When there are no more objects in the table, &lt;code&gt;'$end_of_table'&lt;/code&gt; is returned.</source>
          <target state="translated">Cuando no hay m&amp;aacute;s objetos en la tabla, se devuelve &lt;code&gt;'$end_of_table'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="745f9cd3851e711d348b63ccc23a8f52273edfe7" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, &lt;code&gt;qlc&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;dets#lookup-2&quot;&gt;dets:lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="translated">Cuando solo hay restricciones simples en la posici&amp;oacute;n de la clave, &lt;code&gt;qlc&lt;/code&gt; usa &lt;code&gt;&lt;a href=&quot;dets#lookup-2&quot;&gt;dets:lookup/2&lt;/a&gt;&lt;/code&gt; para buscar las claves. Cuando eso no es posible, se atraviesa toda la tabla. Opci&amp;oacute;n &lt;code&gt;traverse&lt;/code&gt; determina c&amp;oacute;mo se hace esto:</target>
        </trans-unit>
        <trans-unit id="a97d09e0174e7ebcd752be249e317734288c7fe5" translate="yes" xml:space="preserve">
          <source>When there are only simple restrictions on the key position, QLC uses &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; to look up the keys. When that is not possible, the whole table is traversed. Option &lt;code&gt;traverse&lt;/code&gt; determines how this is done:</source>
          <target state="translated">Cuando solo hay restricciones simples en la posici&amp;oacute;n de la clave, QLC usa &lt;code&gt;&lt;a href=&quot;#lookup-2&quot;&gt;lookup/2&lt;/a&gt;&lt;/code&gt; para buscar las claves. Cuando eso no es posible, se atraviesa toda la tabla. Opci&amp;oacute;n &lt;code&gt;traverse&lt;/code&gt; determina c&amp;oacute;mo se hace esto:</target>
        </trans-unit>
        <trans-unit id="1432344868741e2698e6a9b96d60c2837b98772c" translate="yes" xml:space="preserve">
          <source>When there is no risk of confusion, elements of Sets are identified with the sets they represent. For example, if U is the result of calling &lt;code&gt;&lt;a href=&quot;#union-2&quot;&gt;union/2&lt;/a&gt;&lt;/code&gt; with S1 and S2 as arguments, then U is said to be the union of S1 and S2. A more precise formulation is that Set(U) is the union of Set(S1) and Set(S2).</source>
          <target state="translated">Cuando no hay riesgo de confusi&amp;oacute;n, los elementos de los Conjuntos se identifican con los conjuntos que representan. Por ejemplo, si U es el resultado de llamar a &lt;code&gt;&lt;a href=&quot;#union-2&quot;&gt;union/2&lt;/a&gt;&lt;/code&gt; con S1 y S2 como argumentos, entonces se dice que U es la uni&amp;oacute;n de S1 y S2. Una formulaci&amp;oacute;n m&amp;aacute;s precisa es que Set (U) es la uni&amp;oacute;n de Set (S1) y Set (S2).</target>
        </trans-unit>
        <trans-unit id="3340db1e6247a69837f2ad75c699140be306fabf" translate="yes" xml:space="preserve">
          <source>When this argument is removed, a final CPU topology to use is determined at emulator boot time.</source>
          <target state="translated">Cuando se elimina este argumento,se determina la topología final de la CPU a utilizar en el momento del arranque del emulador.</target>
        </trans-unit>
        <trans-unit id="2478ca4237a9acca28df2597c10ba062104b18b0" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the linked-in driver must manually acknowledge that the port has been successfully started using &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt; erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt;. This allows the implementor to make the &lt;code&gt;erlang:open_port&lt;/code&gt; exit with &lt;code&gt;badarg&lt;/code&gt; after some initial asynchronous initialization has been done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b43ec86ba8c916251f60d0bb263cce04f4688f6" translate="yes" xml:space="preserve">
          <source>When this flag is specified, the linked-in driver must manually acknowledge that the port has been successfully started using &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt;erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt;. This allows the implementor to make the &lt;code&gt;erlang:open_port&lt;/code&gt; exit with &lt;code&gt;badarg&lt;/code&gt; after some initial asynchronous initialization has been done.</source>
          <target state="translated">Cuando se especifica este indicador, el controlador vinculado debe reconocer manualmente que el puerto se ha iniciado correctamente utilizando &lt;code&gt;&lt;a href=&quot;erl_driver#erl_drv_init_ack&quot;&gt;erl_driver:erl_drv_init_ack()&lt;/a&gt;&lt;/code&gt; . Esto permite al implementador hacer que &lt;code&gt;erlang:open_port&lt;/code&gt; salga con &lt;code&gt;badarg&lt;/code&gt; despu&amp;eacute;s de que se haya realizado una inicializaci&amp;oacute;n asincr&amp;oacute;nica inicial.</target>
        </trans-unit>
        <trans-unit id="a6c9e4e469cc7c78f5cf4d1f7fdc335fb16bb6a9" translate="yes" xml:space="preserve">
          <source>When this function executes within a transaction, several processes running on different nodes can concurrently execute the function &lt;code&gt;raise/2&lt;/code&gt; without interfering with each other.</source>
          <target state="translated">Cuando esta funci&amp;oacute;n se ejecuta dentro de una transacci&amp;oacute;n, varios procesos que se ejecutan en diferentes nodos pueden ejecutar simult&amp;aacute;neamente la funci&amp;oacute;n &lt;code&gt;raise/2&lt;/code&gt; sin interferir entre s&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="25a15353480dd77dab8bbc5928bb6f70d413dc62" translate="yes" xml:space="preserve">
          <source>When this function is called the initiating &lt;code&gt;erlang:open_port&lt;/code&gt; call is returned as if the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt; start&lt;/a&gt;&lt;/code&gt; function had just been called. It can only be used when flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt; ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; has been set on the linked-in driver.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f5be18c956ae3c742f6fbc74a81c84e27f37de5" translate="yes" xml:space="preserve">
          <source>When this function is called the initiating &lt;code&gt;erlang:open_port&lt;/code&gt; call is returned as if the &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; function had just been called. It can only be used when flag &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; has been set on the linked-in driver.</source>
          <target state="translated">Cuando se llama a esta funci&amp;oacute;n, se &lt;code&gt;erlang:open_port&lt;/code&gt; llamada erlang: open_port de &lt;code&gt;&lt;a href=&quot;driver_entry#start&quot;&gt;start&lt;/a&gt;&lt;/code&gt; como si se acabara de llamar a la funci&amp;oacute;n de inicio . Solo se puede utilizar cuando se ha establecido el indicador &lt;code&gt;&lt;a href=&quot;driver_entry#driver_flags&quot;&gt;ERL_DRV_FLAG_USE_INIT_ACK&lt;/a&gt;&lt;/code&gt; en el controlador vinculado.</target>
        </trans-unit>
        <trans-unit id="9f1d28b41ff3a8afa6eef2cd6d49d478529957d0" translate="yes" xml:space="preserve">
          <source>When this function is called with a list of certificate options; it generates a configuration with just one node certificate where &lt;code&gt;cacerts&lt;/code&gt; contains the root cert and the intermediate certs that should be presented to a peer. In this case the same root cert must be used for all peers. This is useful in for example an Erlang distributed cluster where any node, towards another node, acts either as a server or as a client depending on who connects to whom. The generated certificate contains a subject altname, which is not needed in a client certificate, but makes the certificate useful for both roles.</source>
          <target state="translated">Cuando se llama a esta funci&amp;oacute;n con una lista de opciones de certificado; genera una configuraci&amp;oacute;n con un solo certificado de nodo donde &lt;code&gt;cacerts&lt;/code&gt; contiene el certificado ra&amp;iacute;z y los certificados intermedios que deben presentarse a un par. En este caso, se debe usar el mismo certificado ra&amp;iacute;z para todos los pares. Esto es &amp;uacute;til, por ejemplo, en un cl&amp;uacute;ster distribuido de Erlang donde cualquier nodo, hacia otro nodo, act&amp;uacute;a como servidor o como cliente dependiendo de qui&amp;eacute;n se conecta a qui&amp;eacute;n. El certificado generado contiene un nombre alternativo de sujeto, que no es necesario en un certificado de cliente, pero hace que el certificado sea &amp;uacute;til para ambos roles.</target>
        </trans-unit>
        <trans-unit id="08efe32cecc8061ee565bbd96c13cef9c271f062" translate="yes" xml:space="preserve">
          <source>When this function is called with a map containing client and server chain specifications; it generates both a client and a server certificate chain where the &lt;code&gt;cacerts&lt;/code&gt; returned for the server contains the root cert the server should trust and the intermediate certificates the server should present to connecting clients. The root cert the server should trust is the one used as root of the client certificate chain. Vice versa applies to the &lt;code&gt;cacerts&lt;/code&gt; returned for the client. The root cert(s) can either be pre-generated with &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt; pkix_test_root_cert/2 &lt;/a&gt;&lt;/code&gt;, or if options are specified; it is (they are) generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe0dc82b5ddcdc81bd48ff82e4659150dc801ef9" translate="yes" xml:space="preserve">
          <source>When this function is called with a map containing client and server chain specifications; it generates both a client and a server certificate chain where the &lt;code&gt;cacerts&lt;/code&gt; returned for the server contains the root cert the server should trust and the intermediate certificates the server should present to connecting clients. The root cert the server should trust is the one used as root of the client certificate chain. Vice versa applies to the &lt;code&gt;cacerts&lt;/code&gt; returned for the client. The root cert(s) can either be pre-generated with &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt;, or if options are specified; it is (they are) generated.</source>
          <target state="translated">Cuando se llama a esta funci&amp;oacute;n con un mapa que contiene especificaciones de la cadena del cliente y del servidor; genera una cadena de certificados de cliente y de servidor donde los &lt;code&gt;cacerts&lt;/code&gt; devueltos para el servidor contienen el certificado ra&amp;iacute;z en el que el servidor debe confiar y los certificados intermedios que el servidor debe presentar a los clientes que se conectan. El certificado ra&amp;iacute;z en el que debe confiar el servidor es el que se utiliza como ra&amp;iacute;z de la cadena de certificados del cliente. Viceversa se aplica a los &lt;code&gt;cacerts&lt;/code&gt; devueltos por el cliente. Los certificados ra&amp;iacute;z se pueden generar &lt;code&gt;&lt;a href=&quot;#pkix_test_root_cert-2&quot;&gt;pkix_test_root_cert/2&lt;/a&gt;&lt;/code&gt; con pkix_test_root_cert / 2 , o si se especifican opciones; es (son) generados.</target>
        </trans-unit>
        <trans-unit id="ef9a4bfdea86e7e0384f0eb8ca04b745e4df80d6" translate="yes" xml:space="preserve">
          <source>When this function is called, &lt;code&gt;*value_size&lt;/code&gt; is to contain the size of the &lt;code&gt;value&lt;/code&gt; buffer.</source>
          <target state="translated">Cuando se llama a esta funci&amp;oacute;n, &lt;code&gt;*value_size&lt;/code&gt; debe contener el tama&amp;ntilde;o del b&amp;uacute;fer de &lt;code&gt;value&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4f0658a8caa71ae8ec3af2aaa874893698a63c04" translate="yes" xml:space="preserve">
          <source>When this function is executed inside a transaction-context, it returns &lt;code&gt;true&lt;/code&gt;, otherwise &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="translated">Cuando esta funci&amp;oacute;n se ejecuta dentro de un contexto de transacci&amp;oacute;n, devuelve &lt;code&gt;true&lt;/code&gt; , de lo contrario &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dcdfcd8239bab330841cc445bcf6b51860555e6e" translate="yes" xml:space="preserve">
          <source>When this is triggered, the previous path through the pattern is searched for the most recent (*MARK) that has the same name. If one is found, the &quot;bumpalong&quot; advance is to the subject position that corresponds to that (*MARK) instead of to where (*SKIP) was encountered. If no (*MARK) with a matching name is found, (*SKIP) is ignored.</source>
          <target state="translated">Cuando esto se activa,se busca en el camino anterior a través del patrón el más reciente (*MARCA)que tenga el mismo nombre.Si se encuentra uno,el avance &quot;bumpalong&quot; es a la posición del sujeto que corresponde a esa (*MARCA)en vez de a donde (*SKIP)se encontró.Si no se encuentra ninguna (*MARCA)con un nombre que coincida,(*SKIP)se ignora.</target>
        </trans-unit>
        <trans-unit id="d7db68b788b90d41b1ce4140671c7e956cf1dfc1" translate="yes" xml:space="preserve">
          <source>When this mapping is used, insertion and deletion in the original Mnesia table is slower, with a factor O(log n). The read access is not affected.</source>
          <target state="translated">Cuando se utiliza este mapeo,la inserción y eliminación en la tabla original de Mnesia es más lenta,con un factor O(log n).El acceso de lectura no se ve afectado.</target>
        </trans-unit>
        <trans-unit id="c4aed8d8cd7303661b0a5b4d380d742f046b6a10" translate="yes" xml:space="preserve">
          <source>When this option is enabled the counters for the table size and memory consumption are distributed over several cache lines and the scheduling threads are mapped to one of those cache lines. The &lt;code&gt;erl&lt;/code&gt; option &lt;code&gt;+dcg&lt;/code&gt; can be used to control the number of cache lines that the counters are distributed over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb494176e860d606fcf89bbbcaf477ac48b4e483" translate="yes" xml:space="preserve">
          <source>When this option is set to &lt;code&gt;false&lt;/code&gt;, which is default, an RST received from the TCP peer is treated as a normal close (as though an FIN was sent). A caller to &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2&lt;/a&gt;&lt;/code&gt; gets &lt;code&gt;{error, closed}&lt;/code&gt;. In active mode, the controlling process receives a &lt;code&gt;{tcp_closed, Socket}&lt;/code&gt; message, indicating that the peer has closed the connection.</source>
          <target state="translated">Cuando esta opci&amp;oacute;n se establece en &lt;code&gt;false&lt;/code&gt; , que es el valor predeterminado, un RST recibido del par TCP se trata como un cierre normal (como si se hubiera enviado un FIN). Una persona que llama a &lt;code&gt;&lt;a href=&quot;gen_tcp#recv-2&quot;&gt;gen_tcp:recv/2&lt;/a&gt;&lt;/code&gt; obtiene &lt;code&gt;{error, closed}&lt;/code&gt; . En modo activo, el proceso de control recibe un &lt;code&gt;{tcp_closed, Socket}&lt;/code&gt; , que indica que el par ha cerrado la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cbf5b5ed25d2d89a0cbf4701083cbe10925b03a5" translate="yes" xml:space="preserve">
          <source>When this option is set to &lt;code&gt;true&lt;/code&gt;, the table is optimized for frequent concurrent calls to operations that modify the tables size and/or its memory consumption (e.g., &lt;code&gt;&lt;a href=&quot;#insert-2&quot;&gt;insert/2&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#delete-2&quot;&gt;delete/2&lt;/a&gt;&lt;/code&gt;). The drawback is that calls to &lt;code&gt;&lt;a href=&quot;#info-1&quot;&gt;info/1&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;#info-2&quot;&gt;info/2&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;size&lt;/code&gt; or &lt;code&gt;memory&lt;/code&gt; as the second argument can get much slower when the &lt;code&gt;decentralized_counters&lt;/code&gt; option is turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7f5c99c2ce601b738e1cbcc7fe8e59a1211a42" translate="yes" xml:space="preserve">
          <source>When this option is specified, the &quot;start of line&quot; and &quot;end of line&quot; constructs match immediately following or immediately before internal newlines in the subject string, respectively, as well as at the very start and end. This is equivalent to Perl option &lt;code&gt;/m&lt;/code&gt; and can be changed within a pattern by a &lt;code&gt;(?m)&lt;/code&gt; option setting. If there are no newlines in a subject string, or no occurrences of &lt;code&gt;^&lt;/code&gt; or &lt;code&gt;$&lt;/code&gt; in a pattern, setting &lt;code&gt;multiline&lt;/code&gt; has no effect.</source>
          <target state="translated">Cuando se especifica esta opci&amp;oacute;n, las construcciones de &quot;inicio de l&amp;iacute;nea&quot; y &quot;final de l&amp;iacute;nea&quot; coinciden inmediatamente despu&amp;eacute;s o inmediatamente antes de las nuevas l&amp;iacute;neas internas en la cadena de asunto, respectivamente, as&amp;iacute; como al principio y al final. Esto es equivalente a la opci&amp;oacute;n Perl &lt;code&gt;/m&lt;/code&gt; y se puede cambiar dentro de un patr&amp;oacute;n mediante una configuraci&amp;oacute;n de opci&amp;oacute;n &lt;code&gt;(?m)&lt;/code&gt; . Si no hay saltos de l&amp;iacute;nea en una cadena de asunto, o no hay ocurrencias de &lt;code&gt;^&lt;/code&gt; o &lt;code&gt;$&lt;/code&gt; en un patr&amp;oacute;n, el establecimiento &lt;code&gt;multiline&lt;/code&gt; no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="675f8d886654247d43dbcd4fe8a49b4d5b32073b" translate="yes" xml:space="preserve">
          <source>When this option is used, the result of &lt;code&gt;write/2&lt;/code&gt; calls can prematurely be reported as successful, and if a write error occurs, the error is reported as the result of the next file operation, which is not executed.</source>
          <target state="translated">Cuando se usa esta opci&amp;oacute;n, el resultado de las llamadas de &lt;code&gt;write/2&lt;/code&gt; se puede informar prematuramente como exitoso, y si ocurre un error de escritura, el error se informa como resultado de la siguiente operaci&amp;oacute;n de archivo, que no se ejecuta.</target>
        </trans-unit>
        <trans-unit id="79ca6f02ce20af0f54bdfcd5b4887c4b78fe59ff" translate="yes" xml:space="preserve">
          <source>When those instructions are loaded, the loader rewrites them to specific instructions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efc30def2e6a5147d2d890feeb73645cc382d513" translate="yes" xml:space="preserve">
          <source>When time-out occurs, &lt;code&gt;Common Test&lt;/code&gt; never aborts the ongoing test case, as this can leave the SUT in an undefined, and possibly bad, state. Instead &lt;code&gt;Common Test&lt;/code&gt;, by default, finishes the current test run before stopping. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified, &lt;code&gt;Common Test&lt;/code&gt; stops when the current test job is finished. If flag &lt;code&gt;force_stop&lt;/code&gt; is specified with &lt;code&gt;skip_rest&lt;/code&gt;, &lt;code&gt;Common Test&lt;/code&gt; only completes the current test case and skips the remaining tests in the test job.</source>
          <target state="translated">Cuando se agota el tiempo de espera, &lt;code&gt;Common Test&lt;/code&gt; nunca aborta el caso de prueba en curso, ya que esto puede dejar el SUT en un estado indefinido y posiblemente malo. En su lugar, &lt;code&gt;Common Test&lt;/code&gt; , de forma predeterminada, finaliza la ejecuci&amp;oacute;n de prueba actual antes de detenerse. Si se especifica el indicador &lt;code&gt;force_stop&lt;/code&gt; , &lt;code&gt;Common Test&lt;/code&gt; se detiene cuando finaliza el trabajo de prueba actual. Si el indicador &lt;code&gt;force_stop&lt;/code&gt; se especifica con &lt;code&gt;skip_rest&lt;/code&gt; , &lt;code&gt;Common Test&lt;/code&gt; solo completa el caso de prueba actual y omite las pruebas restantes en el trabajo de prueba.</target>
        </trans-unit>
        <trans-unit id="3b02470ac02b8a82a85b03a86594d121edb6f2f0" translate="yes" xml:space="preserve">
          <source>When to Use Mnesia</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7496cb290358c83d75813f93e436cc9aa7801dbd" translate="yes" xml:space="preserve">
          <source>When to use a Sub-agent</source>
          <target state="translated">Cuándo utilizar un subagente</target>
        </trans-unit>
        <trans-unit id="25981ff4244a1ee87a90be438c90aa93aa36e1ed" translate="yes" xml:space="preserve">
          <source>When trace flag &lt;code&gt;call&lt;/code&gt; is set on a process, function calls are traced on that process if a trace pattern is set for the called function.</source>
          <target state="translated">Cuando se establece una &lt;code&gt;call&lt;/code&gt; marca de seguimiento en un proceso, las llamadas de funci&amp;oacute;n se realizan en ese proceso si se establece un patr&amp;oacute;n de seguimiento para la funci&amp;oacute;n llamada.</target>
        </trans-unit>
        <trans-unit id="c8613cbf9cc57a98765708cdc22f9ed8559f964a" translate="yes" xml:space="preserve">
          <source>When trace output is desired, &lt;code&gt;debug&lt;/code&gt; is to be defined when the module &lt;code&gt;m&lt;/code&gt; is compiled:</source>
          <target state="translated">Cuando se desea la salida de seguimiento, la &lt;code&gt;debug&lt;/code&gt; se debe definir cuando se compila el m&amp;oacute;dulo &lt;code&gt;m&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="256e90d704880ae674edcafcdfe9548c1c7249cd" translate="yes" xml:space="preserve">
          <source>When tracing a system of Mnesia applications it is useful to be able to interleave Mnesia own events with application-related events that give information about the application context.</source>
          <target state="translated">Cuando se rastrea un sistema de aplicaciones de Mnesia es útil poder intercalar los eventos propios de Mnesia con los eventos relacionados con la aplicación que dan información sobre el contexto de la aplicación.</target>
        </trans-unit>
        <trans-unit id="e113da41d29c2c3638afdbda456737663befd306" translate="yes" xml:space="preserve">
          <source>When tracing diskless nodes, &lt;code&gt;ttb&lt;/code&gt; must be started from an external &quot;trace control node&quot; with disk access, and &lt;code&gt;Client&lt;/code&gt; must be &lt;code&gt;{local, File}&lt;/code&gt;. All trace information is then sent to the trace control node where it is written to file.</source>
          <target state="translated">Al rastrear nodos sin disco, &lt;code&gt;ttb&lt;/code&gt; debe iniciarse desde un &quot;nodo de control de rastreo&quot; externo con acceso al disco, y el &lt;code&gt;Client&lt;/code&gt; e debe ser &lt;code&gt;{local, File}&lt;/code&gt; . A continuaci&amp;oacute;n, toda la informaci&amp;oacute;n de seguimiento se env&amp;iacute;a al nodo de control de seguimiento donde se escribe en el archivo.</target>
        </trans-unit>
        <trans-unit id="6193e77c0b9e8850c79e56437a7ff2bfa89554ed" translate="yes" xml:space="preserve">
          <source>When tracing function calls on a group leader process (an IO process), there is risk of causing a deadlock. This will happen if a group leader process generates a trace message and the tracer process, by calling the trace handler function, sends an IO request to the same group leader. The problem can only occur if the trace handler prints to tty using an &lt;code&gt;io&lt;/code&gt; function such as &lt;code&gt;format/2&lt;/code&gt;. Note that when &lt;code&gt;dbg:p(all,call)&lt;/code&gt; is called, IO processes are also traced. Here's an example:</source>
          <target state="translated">Cuando la funci&amp;oacute;n de seguimiento llama a un proceso de l&amp;iacute;der de grupo (un proceso de E / S), existe el riesgo de provocar un punto muerto. Esto suceder&amp;aacute; si un proceso de l&amp;iacute;der de grupo genera un mensaje de seguimiento y el proceso de seguimiento, al llamar a la funci&amp;oacute;n del controlador de seguimiento, env&amp;iacute;a una solicitud IO al mismo l&amp;iacute;der de grupo. El problema solo puede ocurrir si el controlador de seguimiento imprime en tty usando una funci&amp;oacute;n &lt;code&gt;io&lt;/code&gt; como &lt;code&gt;format/2&lt;/code&gt; . Tenga en cuenta que cuando se llama a &lt;code&gt;dbg:p(all,call)&lt;/code&gt; , los procesos IO tambi&amp;eacute;n se rastrean. He aqu&amp;iacute; un ejemplo:</target>
        </trans-unit>
        <trans-unit id="466360c3c9707d034db5517f5ba6f1db58ddb4ed" translate="yes" xml:space="preserve">
          <source>When tracing live systems, always take special care to not overload a node with too heavy tracing. &lt;code&gt;ttb&lt;/code&gt; provides option &lt;code&gt;overload&lt;/code&gt; to address this problem.</source>
          <target state="translated">Al rastrear sistemas activos, siempre tenga especial cuidado de no sobrecargar un nodo con un rastreo demasiado pesado. &lt;code&gt;ttb&lt;/code&gt; proporciona una &lt;code&gt;overload&lt;/code&gt; opciones para solucionar este problema.</target>
        </trans-unit>
        <trans-unit id="1d713a6d3abef0dc19e9fef42b12e8d6a635ed21" translate="yes" xml:space="preserve">
          <source>When tracing there is no return value to produce, the match specification either matches or does not. The effect when the expression matches is a trace message rather than a returned term. The &lt;code&gt;ActionTerm&lt;/code&gt;s are executed as in an imperative language, that is, for their side effects. Functions with side effects are also allowed when tracing.</source>
          <target state="translated">Cuando se rastrea, no hay valor de retorno que producir, la especificaci&amp;oacute;n de coincidencia coincide o no. El efecto cuando la expresi&amp;oacute;n coincide es un mensaje de seguimiento en lugar de un t&amp;eacute;rmino devuelto. Los &lt;code&gt;ActionTerm&lt;/code&gt; se ejecutan como en un lenguaje imperativo, es decir, por sus efectos secundarios. Tambi&amp;eacute;n se permiten funciones con efectos secundarios al rastrear.</target>
        </trans-unit>
        <trans-unit id="58e093b3869faaa26b1860581c9f3af042ac8ce5" translate="yes" xml:space="preserve">
          <source>When tracing to shell or &lt;code&gt;{local,File}&lt;/code&gt;, an ip trace driver is used internally. The ip trace driver has a queue of maximum &lt;code&gt;QueueSize&lt;/code&gt; messages waiting to be delivered. If the driver cannot deliver messages as fast as they are produced, the queue size might be exceeded and messages are dropped. This parameter is optional, and is only useful if many &lt;code&gt;{drop,N}&lt;/code&gt; trace messages are received by the trace handler. It has no meaning if shell or &lt;code&gt;{local,File}&lt;/code&gt; is not used. See &lt;code&gt;dbg:trace_port/2&lt;/code&gt; for more information about the ip trace driver.</source>
          <target state="translated">Cuando se rastrea a shell o &lt;code&gt;{local,File}&lt;/code&gt; , se usa internamente un controlador de rastreo de IP. El controlador de rastreo de IP tiene una cola de mensajes &lt;code&gt;QueueSize&lt;/code&gt; m&amp;aacute;ximos en espera de ser entregados. Si el controlador no puede entregar mensajes tan r&amp;aacute;pido como se producen, es posible que se exceda el tama&amp;ntilde;o de la cola y se descarten los mensajes. Este par&amp;aacute;metro es opcional y solo es &amp;uacute;til si el controlador de seguimiento recibe muchos mensajes de seguimiento &lt;code&gt;{drop,N}&lt;/code&gt; . No tiene ning&amp;uacute;n significado si no se utiliza shell o &lt;code&gt;{local,File}&lt;/code&gt; . Consulte &lt;code&gt;dbg:trace_port/2&lt;/code&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre el controlador ip trace.</target>
        </trans-unit>
        <trans-unit id="093fdd62c1610e46d6f27c6de1ab5ef2750cca76" translate="yes" xml:space="preserve">
          <source>When traversing the contents of &lt;code&gt;sys.config&lt;/code&gt; and a filename is encountered, its contents are read and merged with the result so far. When an application configuration tuple &lt;code&gt;{Application, Env}&lt;/code&gt; is found, it is merged with the result so far. Merging means that new parameters are added and existing parameter values overwritten.</source>
          <target state="translated">Cuando se recorre el contenido de &lt;code&gt;sys.config&lt;/code&gt; y se encuentra un nombre de archivo, su contenido se lee y se fusiona con el resultado hasta ahora. Cuando se encuentra una tupla de configuraci&amp;oacute;n de la aplicaci&amp;oacute;n &lt;code&gt;{Application, Env}&lt;/code&gt; , se fusiona con el resultado hasta ahora. Fusionar significa que se agregan nuevos par&amp;aacute;metros y se sobrescriben los valores de los par&amp;aacute;metros existentes.</target>
        </trans-unit>
        <trans-unit id="5c1a00c1646659dc3c25c531f96cba51c37aa323" translate="yes" xml:space="preserve">
          <source>When unregister the subagent using an &lt;code&gt;oid()&lt;/code&gt;, the &lt;code&gt;pid()&lt;/code&gt; of the process handling the sub-tree is also returned.</source>
          <target state="translated">Cuando anula el registro del subagente usando un &lt;code&gt;oid()&lt;/code&gt; , tambi&amp;eacute;n se devuelve el &lt;code&gt;pid()&lt;/code&gt; del proceso que maneja el sub&amp;aacute;rbol.</target>
        </trans-unit>
        <trans-unit id="799f766e20f87f2dca4b1fd3e86f764dcd6d6a7e" translate="yes" xml:space="preserve">
          <source>When upgrading the emulator from a version older than OTP R15, an attempt is made to load new application beam code into the old emulator. Sometimes the new beam format cannot be read by the old emulator, so the code loading fails and the complete upgrade is terminated. To overcome this problem, the new application code is to be compiled with the old emulator. For more information about emulator upgrade from pre OTP R15 versions, see &lt;code&gt;Design Principles&lt;/code&gt; in &lt;strong&gt;System Documentation&lt;/strong&gt;.</source>
          <target state="translated">Al actualizar el emulador desde una versi&amp;oacute;n anterior a OTP R15, se intenta cargar un nuevo c&amp;oacute;digo de transmisi&amp;oacute;n de la aplicaci&amp;oacute;n en el antiguo emulador. A veces, el emulador antiguo no puede leer el nuevo formato de haz, por lo que la carga del c&amp;oacute;digo falla y finaliza la actualizaci&amp;oacute;n completa. Para superar este problema, el nuevo c&amp;oacute;digo de la aplicaci&amp;oacute;n se compilar&amp;aacute; con el antiguo emulador. Para obtener m&amp;aacute;s informaci&amp;oacute;n sobre la actualizaci&amp;oacute;n del emulador desde versiones anteriores a OTP R15, consulte &lt;code&gt;Design Principles&lt;/code&gt; en la &lt;strong&gt;documentaci&amp;oacute;n del sistema&lt;/strong&gt; .</target>
        </trans-unit>
        <trans-unit id="d17b5ae381bac399583f6528ad1df0f425329627" translate="yes" xml:space="preserve">
          <source>When used together with a &lt;code&gt; Tracer Module&lt;/code&gt;, any message sent in the trace callback is guaranteed to have reached its recipient before the &lt;code&gt;trace_delivered&lt;/code&gt; message is sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c936186cbb39bacc2e228da8dc8dbbfc6f98893" translate="yes" xml:space="preserve">
          <source>When used together with a &lt;code&gt;Tracer Module&lt;/code&gt;, any message sent in the trace callback is guaranteed to have reached its recipient before the &lt;code&gt;trace_delivered&lt;/code&gt; message is sent.</source>
          <target state="translated">Cuando se utiliza junto con un &lt;code&gt;Tracer Module&lt;/code&gt; , se garantiza que cualquier mensaje enviado en la devoluci&amp;oacute;n de llamada de seguimiento ha llegado a su destinatario antes de que se &lt;code&gt;trace_delivered&lt;/code&gt; mensaje trace_delivered .</target>
        </trans-unit>
        <trans-unit id="79aeb596bfcda207847ddb49137293b64e87d84d" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;systools&lt;/code&gt;, the Erlang/OTP tools for packaging code (see Section &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt;), the keys &lt;code&gt;description&lt;/code&gt;, &lt;code&gt;vsn&lt;/code&gt;, &lt;code&gt;modules&lt;/code&gt;, &lt;code&gt;registered&lt;/code&gt;, and &lt;code&gt;applications&lt;/code&gt; are also to be specified:</source>
          <target state="translated">Cuando se utilizan &lt;code&gt;systools&lt;/code&gt; , tambi&amp;eacute;n se deben especificar las herramientas Erlang / OTP para el c&amp;oacute;digo de empaquetado (consulte la secci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;release_structure&quot;&gt;Releases&lt;/a&gt;&lt;/code&gt; ), la &lt;code&gt;description&lt;/code&gt; las claves , &lt;code&gt;vsn&lt;/code&gt; , &lt;code&gt;modules&lt;/code&gt; , &lt;code&gt;registered&lt;/code&gt; y &lt;code&gt;applications&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="aa09303e43191324a1721cf4208f1cd806ff1214" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;ttb&lt;/code&gt;, do not use module &lt;code&gt;dbg&lt;/code&gt; in application Runtime_Tools in parallel.</source>
          <target state="translated">Cuando use &lt;code&gt;ttb&lt;/code&gt; , no use el m&amp;oacute;dulo &lt;code&gt;dbg&lt;/code&gt; en la aplicaci&amp;oacute;n Runtime_Tools en paralelo.</target>
        </trans-unit>
        <trans-unit id="dced03c330435f63fc32590f93a202225ef052df" translate="yes" xml:space="preserve">
          <source>When using &lt;code&gt;{active, once}&lt;/code&gt; or &lt;code&gt;{active, N}&lt;/code&gt;, the socket changes behavior automatically when data is received. This can be confusing in combination with connection-oriented sockets (that is, &lt;code&gt;gen_tcp&lt;/code&gt;), as a socket with &lt;code&gt;{active, false}&lt;/code&gt; behavior reports closing differently than a socket with &lt;code&gt;{active, true}&lt;/code&gt; behavior. To simplify programming, a socket where the peer closed, and this is detected while in &lt;code&gt;{active, false}&lt;/code&gt; mode, still generates message &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt; when set to &lt;code&gt;{active, once}&lt;/code&gt;, &lt;code&gt;{active, true}&lt;/code&gt;, or &lt;code&gt;{active, N}&lt;/code&gt; mode. It is therefore safe to assume that message &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt;, possibly followed by socket port termination (depending on option &lt;code&gt;exit_on_close&lt;/code&gt;) eventually appears when a socket changes back and forth between &lt;code&gt;{active, true}&lt;/code&gt; and &lt;code&gt;{active, false}&lt;/code&gt; mode. However, &lt;strong&gt;when&lt;/strong&gt; peer closing is detected it is all up to the underlying TCP/IP stack and protocol.</source>
          <target state="translated">Cuando se usa &lt;code&gt;{active, once}&lt;/code&gt; o &lt;code&gt;{active, N}&lt;/code&gt; , el socket cambia su comportamiento autom&amp;aacute;ticamente cuando se reciben datos. Esto puede resultar confuso en combinaci&amp;oacute;n con sockets orientados a la conexi&amp;oacute;n (es decir, &lt;code&gt;gen_tcp&lt;/code&gt; ), ya que un socket con comportamiento &lt;code&gt;{active, false}&lt;/code&gt; informa cerrarse de manera diferente que un socket con comportamiento &lt;code&gt;{active, true}&lt;/code&gt; . Para simplificar la programaci&amp;oacute;n, un socket donde el par se cerr&amp;oacute;, y esto se detecta mientras est&amp;aacute; en modo &lt;code&gt;{active, false}&lt;/code&gt; , a&amp;uacute;n genera el mensaje &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt; cuando se establece en &lt;code&gt;{active, once}&lt;/code&gt; , &lt;code&gt;{active, true}&lt;/code&gt; o &lt;code&gt;{active, N}&lt;/code&gt; modo. Por tanto, es seguro asumir que el mensaje &lt;code&gt;{tcp_closed,Socket}&lt;/code&gt; , posiblemente seguido por la terminaci&amp;oacute;n del puerto del socket (dependiendo de la opci&amp;oacute;n &lt;code&gt;exit_on_close&lt;/code&gt; ) eventualmente aparece cuando un socket cambia entre el modo &lt;code&gt;{active, true}&lt;/code&gt; y &lt;code&gt;{active, false}&lt;/code&gt; . Sin embargo, &lt;strong&gt;cuando&lt;/strong&gt; se detecta el cierre de pares, todo depende de la pila y el protocolo TCP / IP subyacentes.</target>
        </trans-unit>
        <trans-unit id="2fcb6b502d0fb8883fe722b0fb211f708e76b4ea" translate="yes" xml:space="preserve">
          <source>When using Dialyzer from the command line, output the raw analysis results (Erlang terms) instead of the formatted result. The raw format is easier to post-process (for example, to filter warnings or to output HTML pages).</source>
          <target state="translated">Al utilizar el Dialyzer desde la línea de comandos,se obtienen los resultados del análisis crudo (términos de Erlang)en lugar del resultado formateado.El formato crudo es más fácil de post-procesar (por ejemplo,para filtrar las advertencias o para dar salida a páginas HTML).</target>
        </trans-unit>
        <trans-unit id="895bf807f2bce58c7df0a72cbf3fb93cefba69cf" translate="yes" xml:space="preserve">
          <source>When using Dialyzer from the command line, send the analysis results to the specified outfile rather than to &lt;code&gt;stdout&lt;/code&gt;.</source>
          <target state="translated">Cuando utilice Dialyzer desde la l&amp;iacute;nea de comandos, env&amp;iacute;e los resultados del an&amp;aacute;lisis al archivo de salida especificado en lugar de a la &lt;code&gt;stdout&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="da094abac8d6ebe76a11e697f4e1c5d8c383f3e5" translate="yes" xml:space="preserve">
          <source>When using Eprof, expect a slowdown in program execution.</source>
          <target state="translated">Cuando use Eprof,espere una ralentización en la ejecución del programa.</target>
        </trans-unit>
        <trans-unit id="8ac2072110b05033591debd298147443f0f01fa0" translate="yes" xml:space="preserve">
          <source>When using a &lt;code&gt;&lt;a href=&quot;erl_tracer&quot;&gt;tracer module&lt;/a&gt;&lt;/code&gt;, the module must be loaded before the match specification is executed. If it is not loaded, the match fails.</source>
          <target state="translated">Cuando se utiliza un &lt;code&gt;&lt;a href=&quot;erl_tracer&quot;&gt;tracer module&lt;/a&gt;&lt;/code&gt; , el m&amp;oacute;dulo debe cargarse antes de que se ejecute la especificaci&amp;oacute;n de coincidencia. Si no est&amp;aacute; cargado, el partido falla.</target>
        </trans-unit>
        <trans-unit id="82031895868366a3e224c3ba1db5a77162e4744a" translate="yes" xml:space="preserve">
          <source>When using a cover specification in the testing of an OTP application itself, there is a special incl_app directive that includes the applications modules for the cover compilation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1061184d8334715a1b4b165eee90f4c38b81216b" translate="yes" xml:space="preserve">
          <source>When using binary encoding, the structure of the termination id's needs to be specified.</source>
          <target state="translated">Cuando se utiliza la codificación binaria,es necesario especificar la estructura de las identificaciones de terminación.</target>
        </trans-unit>
        <trans-unit id="2deedd12939c511eb728d0649b35683b342623a7" translate="yes" xml:space="preserve">
          <source>When using explicit session reuse, it is up to the client to make sure that the session being reused is for the correct server and has been verified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05cb8889170e86b20dbe5a37d8a1c94a4de731e5" translate="yes" xml:space="preserve">
          <source>When using long node names, the code is slightly different as shown in the following example:</source>
          <target state="translated">Cuando se utilizan nombres de nodos largos,el código es ligeramente diferente como se muestra en el siguiente ejemplo:</target>
        </trans-unit>
        <trans-unit id="f2766f8a1c9c5b824a82d01d204ba0da23305f93" translate="yes" xml:space="preserve">
          <source>When using one of the specialized decodes, exclusive or selective decode, instructions must be given in a configuration file. Option &lt;code&gt;asn1config&lt;/code&gt; enables specialized decodes and takes the configuration file in concern. The configuration file has the same name as the ASN.1 specification, but with extension &lt;code&gt;.asn1config&lt;/code&gt;.</source>
          <target state="translated">Cuando se utiliza una de las decodificaciones especializadas, decodificaci&amp;oacute;n exclusiva o selectiva, se deben dar instrucciones en un archivo de configuraci&amp;oacute;n. La opci&amp;oacute;n &lt;code&gt;asn1config&lt;/code&gt; habilita decodificaciones especializadas y toma en consideraci&amp;oacute;n el archivo de configuraci&amp;oacute;n. El archivo de configuraci&amp;oacute;n tiene el mismo nombre que la especificaci&amp;oacute;n ASN.1, pero con la extensi&amp;oacute;n &lt;code&gt;.asn1config&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="db0b593e72759555e6318e54e37fd3dd78c4b583" translate="yes" xml:space="preserve">
          <source>When using text encoding(s), there is actually two different configs controlling what software to use:</source>
          <target state="translated">Cuando se utiliza la(s)codificación(es)de texto,en realidad hay dos configuraciones diferentes que controlan el software a utilizar:</target>
        </trans-unit>
        <trans-unit id="af478005c5fd2f7e42461532e879633e9b4ea1f1" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;aoffcaobf&lt;/code&gt; or &lt;code&gt;aoff&lt;/code&gt; strategies compared to &lt;code&gt;gf&lt;/code&gt; or &lt;code&gt;bf&lt;/code&gt;, we loose some performance since we get more modifications in the data structure of free blocks. This performance penalty is however reduced using the &lt;code&gt;aoffcbf&lt;/code&gt; strategy. A trade off between memory consumption and performance is however inevitable, and it is up to the user to decide what is most important.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b22551cdbafd14a01ac76572f423a143928c5aa" translate="yes" xml:space="preserve">
          <source>When using the &lt;code&gt;load/unload&lt;/code&gt; interfaces, the driver is not unloaded until the &lt;strong&gt;last port&lt;/strong&gt; using the driver is closed. Function &lt;code&gt;unload/1&lt;/code&gt; can return immediately, as the &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; have no interrest in when the unloading occurs. The driver is unloaded when no one needs it any longer.</source>
          <target state="translated">Cuando se utilizan las interfaces de &lt;code&gt;load/unload&lt;/code&gt; , el controlador no se descarga hasta que se cierra el &lt;strong&gt;&amp;uacute;ltimo puerto que&lt;/strong&gt; usa el controlador. La funci&amp;oacute;n &lt;code&gt;unload/1&lt;/code&gt; puede regresar inmediatamente, ya que los &lt;code&gt;&lt;a href=&quot;#users&quot;&gt;users&lt;/a&gt;&lt;/code&gt; no tienen inter&amp;eacute;s en cu&amp;aacute;ndo ocurre la descarga. El conductor se descarga cuando ya nadie lo necesita.</target>
        </trans-unit>
        <trans-unit id="3ebfa3ee9cf60736bbe38ab4cca43cd168ab98e8" translate="yes" xml:space="preserve">
          <source>When using the default configuration, the data to pass over a connection needs to be delivered as is to the node on the receiving end in the &lt;strong&gt;exact same order&lt;/strong&gt;, with no loss of data what so ever, as sent from the sending node.</source>
          <target state="translated">Cuando se utiliza la configuraci&amp;oacute;n predeterminada, los datos que se transmiten a trav&amp;eacute;s de una conexi&amp;oacute;n deben entregarse tal cual al nodo en el extremo receptor en el &lt;strong&gt;mismo orden exacto&lt;/strong&gt; , sin p&amp;eacute;rdida de datos, tal como se env&amp;iacute;a desde el nodo emisor.</target>
        </trans-unit>
        <trans-unit id="0c053c5fc182ecd19f8594a98a6d280896669e6b" translate="yes" xml:space="preserve">
          <source>When using the internal format for logs, use functions &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;#alog-2&quot;&gt;alog/2&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;#alog_terms-2&quot;&gt;alog_terms/2&lt;/a&gt;&lt;/code&gt;. These functions log one or more Erlang terms. By prefixing each of the functions with a &lt;code&gt;b&lt;/code&gt; (for &quot;binary&quot;), we get the corresponding &lt;code&gt;blog()&lt;/code&gt; functions for the external format. These functions log one or more chunks of bytes. For example, to log the string &lt;code&gt;&quot;hello&quot;&lt;/code&gt; in ASCII format, you can use &lt;code&gt;disk_log:blog(Log, &quot;hello&quot;)&lt;/code&gt;, or &lt;code&gt;disk_log:blog(Log, list_to_binary(&quot;hello&quot;))&lt;/code&gt;. The two alternatives are equally efficient.</source>
          <target state="translated">Cuando utilice el formato interno para los registros, utilice las funciones &lt;code&gt;&lt;a href=&quot;#log-2&quot;&gt;log/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#log_terms-2&quot;&gt;log_terms/2&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;#alog-2&quot;&gt;alog/2&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;#alog_terms-2&quot;&gt;alog_terms/2&lt;/a&gt;&lt;/code&gt; . Estas funciones registran uno o m&amp;aacute;s t&amp;eacute;rminos de Erlang. Al prefijar cada una de las funciones con una &lt;code&gt;b&lt;/code&gt; (para &quot;binario&quot;), obtenemos las funciones &lt;code&gt;blog()&lt;/code&gt; correspondientes para el formato externo. Estas funciones registran uno o m&amp;aacute;s fragmentos de bytes. Por ejemplo, para registrar la cadena &lt;code&gt;&quot;hello&quot;&lt;/code&gt; en formato ASCII, puede usar &lt;code&gt;disk_log:blog(Log, &quot;hello&quot;)&lt;/code&gt; , o &lt;code&gt;disk_log:blog(Log, list_to_binary(&quot;hello&quot;))&lt;/code&gt; . Las dos alternativas son igualmente eficientes.</target>
        </trans-unit>
        <trans-unit id="c6d8f8b78cb976ae93a575ca1c85babf22c1877d" translate="yes" xml:space="preserve">
          <source>When using the state object from this function the &lt;code&gt;rand&lt;/code&gt; functions using it may raise exception &lt;code&gt;error:low_entropy&lt;/code&gt; in case the random generator failed due to lack of secure &quot;randomness&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4a43444e4a47c6747c01683f8434e4d77e198b9" translate="yes" xml:space="preserve">
          <source>When using the state object from this function the &lt;code&gt;rand&lt;/code&gt; functions using it may throw exception &lt;code&gt;low_entropy&lt;/code&gt; in case the random generator failed due to lack of secure &quot;randomness&quot;.</source>
          <target state="translated">Cuando se usa el objeto de estado de esta funci&amp;oacute;n, las funciones &lt;code&gt;rand&lt;/code&gt; que lo usan pueden &lt;code&gt;low_entropy&lt;/code&gt; excepci&amp;oacute;n low_entropy en caso de que el generador aleatorio falle debido a la falta de &quot;aleatoriedad&quot; segura.</target>
        </trans-unit>
        <trans-unit id="f9cf555c8604c8a038c91aab86896c66a21405ac" translate="yes" xml:space="preserve">
          <source>When using version 3, then (at least one) &lt;strong&gt;usm user&lt;/strong&gt; has to be registered.</source>
          <target state="translated">Cuando se usa la versi&amp;oacute;n 3, entonces (al menos un) &lt;strong&gt;usuario de usm&lt;/strong&gt; debe estar registrado.</target>
        </trans-unit>
        <trans-unit id="1bccd3c3f97050ab7f7ff6c15e170f7f244907e0" translate="yes" xml:space="preserve">
          <source>When we insert a new element in the table we do the following:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38121095ce4330813b7271ee6f5a6273d4823735" translate="yes" xml:space="preserve">
          <source>When we search our &lt;code&gt;pooled_tree&lt;/code&gt; and find a carrier that is no longer in the pool, we remove that carrier from &lt;code&gt;pooled_tree&lt;/code&gt; and mark it as TRAITOR, as it is now employed by a foreign allocator. We will not find any carriers in &lt;code&gt;pooled_tree&lt;/code&gt; that are marked as BUSY by other threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec7bdbbb710766593c75e9261e59e0df0f24c88d" translate="yes" xml:space="preserve">
          <source>When white-box testing an Erlang application, it is useful to be able to measure the code coverage of the test. &lt;code&gt;Common Test&lt;/code&gt; provides simple access to the OTP Cover tool for this purpose. &lt;code&gt;Common Test&lt;/code&gt; handles all necessary communication with the Cover tool (starting, compiling, analysing, and so on). The &lt;code&gt;Common Test&lt;/code&gt; user only needs to specify the extent of the code coverage analysis.</source>
          <target state="translated">Cuando se realiza una prueba de caja blanca en una aplicaci&amp;oacute;n Erlang, es &amp;uacute;til poder medir la cobertura del c&amp;oacute;digo de la prueba. &lt;code&gt;Common Test&lt;/code&gt; proporciona acceso sencillo a la herramienta OTP Cover para este prop&amp;oacute;sito. &lt;code&gt;Common Test&lt;/code&gt; maneja toda la comunicaci&amp;oacute;n necesaria con la herramienta Cover (inicio, compilaci&amp;oacute;n, an&amp;aacute;lisis, etc.). El usuario de &lt;code&gt;Common Test&lt;/code&gt; solo necesita especificar el alcance del an&amp;aacute;lisis de cobertura de c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="9f214ea79f2660a8546905638532084bd1af76b3" translate="yes" xml:space="preserve">
          <source>When working with binaries, you can get the horrible &quot;double UTF-8 encoding&quot;, where strange characters are encoded in your binaries or files. In other words, you can get a UTF-8 encoded binary that for the second time is encoded as UTF-8. A common situation is where you read a file, byte by byte, but the content is already UTF-8. If you then convert the bytes to UTF-8, using, for example, the &lt;code&gt;unicode&lt;/code&gt; module, or by writing to a file opened with option &lt;code&gt;{encoding,utf8}&lt;/code&gt;, you have each &lt;strong&gt;byte&lt;/strong&gt; in the input file encoded as UTF-8, not each character of the original text (one character can have been encoded in many bytes). There is no real remedy for this other than to be sure of which data is encoded in which format, and never convert UTF-8 data (possibly read byte by byte from a file) into UTF-8 again.</source>
          <target state="translated">Al trabajar con binarios, puede obtener la horrible &quot;codificaci&amp;oacute;n doble UTF-8&quot;, donde se codifican caracteres extra&amp;ntilde;os en sus binarios o archivos. En otras palabras, puede obtener un binario codificado en UTF-8 que por segunda vez est&amp;aacute; codificado como UTF-8. Una situaci&amp;oacute;n com&amp;uacute;n es cuando lee un archivo, byte a byte, pero el contenido ya es UTF-8. Si luego convierte los bytes a UTF-8, usando, por ejemplo, el m&amp;oacute;dulo &lt;code&gt;unicode&lt;/code&gt; , o escribiendo en un archivo abierto con la opci&amp;oacute;n &lt;code&gt;{encoding,utf8}&lt;/code&gt; , tiene cada &lt;strong&gt;byte&lt;/strong&gt;en el archivo de entrada codificado como UTF-8, no cada car&amp;aacute;cter del texto original (un car&amp;aacute;cter puede haber sido codificado en muchos bytes). No hay ning&amp;uacute;n remedio real para esto que no sea estar seguro de qu&amp;eacute; datos est&amp;aacute;n codificados en qu&amp;eacute; formato y nunca convertir datos UTF-8 (posiblemente le&amp;iacute;dos byte por byte de un archivo) a UTF-8 nuevamente.</target>
        </trans-unit>
        <trans-unit id="18992adf85d2ee51008faf55cc74f4f07c241bef" translate="yes" xml:space="preserve">
          <source>When would we want to turn off the prefetch in practice?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8aa37a649829db83e3c9dedf652e7985f8d65bf" translate="yes" xml:space="preserve">
          <source>When writing a driver in C++, the driver entry is to be of &lt;code&gt;&quot;C&quot;&lt;/code&gt; linkage. One way to do this is to put the following line somewhere before the driver entry:</source>
          <target state="translated">Al escribir un controlador en C ++, la entrada del controlador debe ser de enlace &lt;code&gt;&quot;C&quot;&lt;/code&gt; . Una forma de hacer esto es poner la siguiente l&amp;iacute;nea en alg&amp;uacute;n lugar antes de la entrada del controlador:</target>
        </trans-unit>
        <trans-unit id="0855b2f59cc7fd85a55a378f3ac199542a22335d" translate="yes" xml:space="preserve">
          <source>When writing a driver to make a communications protocol available to Erlang, one should know just about everything worth knowing about that particular protocol. All operation must be non-blocking and all possible situations are to be accounted for in the driver. A non-stable driver will affect and/or crash the whole Erlang runtime system.</source>
          <target state="translated">Cuando se escribe un controlador para poner un protocolo de comunicaciones a disposición de Erlang,uno debe saber casi todo lo que vale la pena saber sobre ese protocolo en particular.Toda la operación debe ser sin bloqueo y todas las situaciones posibles deben ser contabilizadas en el controlador.Un conductor no estable afectará y/o bloqueará todo el sistema de tiempo de ejecución de Erlang.</target>
        </trans-unit>
        <trans-unit id="a72c2f5d7c0d4febcd9848b5e2d40ba7cee9b091" translate="yes" xml:space="preserve">
          <source>When writing data it's generally more efficient to write a list of binaries rather than a list of integers. It is not needed to flatten a deep list before writing. On Unix hosts, scatter output, which writes a set of buffers in one operation, is used when possible. In this way &lt;code&gt;write(FD, [Bin1, Bin2 | Bin3])&lt;/code&gt; writes the contents of the binaries without copying the data at all, except for perhaps deep down in the operating system kernel.</source>
          <target state="translated">Al escribir datos, generalmente es m&amp;aacute;s eficiente escribir una lista de binarios en lugar de una lista de enteros. No es necesario aplanar una lista profunda antes de escribir. En los hosts Unix, cuando es posible, se usa la salida de dispersi&amp;oacute;n, que escribe un conjunto de b&amp;uacute;feres en una operaci&amp;oacute;n. De esta manera &lt;code&gt;write(FD, [Bin1, Bin2 | Bin3])&lt;/code&gt; escribe el contenido de los binarios sin copiar los datos en absoluto, excepto quiz&amp;aacute;s en lo m&amp;aacute;s profundo del kernel del sistema operativo.</target>
        </trans-unit>
        <trans-unit id="3b93d4af25f4cfa6e840871298ee7870c462c231" translate="yes" xml:space="preserve">
          <source>When writing new event handlers for the alarm handler, the following events must be handled:</source>
          <target state="translated">Cuando se escriben nuevos manejadores de eventos para el manejador de la alarma,se deben manejar los siguientes eventos:</target>
        </trans-unit>
        <trans-unit id="373413f347fd7c204258c00e02a894b57247817b" translate="yes" xml:space="preserve">
          <source>When writing recursive functions, it is preferable to make them tail-recursive so that they can execute in constant memory space:</source>
          <target state="translated">Cuando se escriben funciones recursivas,es preferible hacerlas recursivas en la cola para que puedan ejecutarse en un espacio de memoria constante:</target>
        </trans-unit>
        <trans-unit id="aa2d5599c173fb1e0df9df6db989c552f2a87193" translate="yes" xml:space="preserve">
          <source>When writing tests, the programmer may discover dependencies (in order to get the tests to run) that ought not to be there, and which need to be abstracted away to get a cleaner design. This helps eliminate bad dependencies before they spread throughout the code.</source>
          <target state="translated">Al escribir las pruebas,el programador puede descubrir dependencias (para hacer que las pruebas funcionen)que no deberían estar ahí,y que necesitan ser abstraídas para obtener un diseño más limpio.Esto ayuda a eliminar las malas dependencias antes de que se propaguen por el código.</target>
        </trans-unit>
        <trans-unit id="3af0ab66421941647abf2fd21f2bc78b64c5b301" translate="yes" xml:space="preserve">
          <source>When you are finished with a registry, close it to remove all the objects and free the memory back to the system:</source>
          <target state="translated">Cuando termines con un registro,ciérralo para eliminar todos los objetos y liberar la memoria de nuevo al sistema:</target>
        </trans-unit>
        <trans-unit id="81517dd740949b1006611dd1f8a8b5246c788490" translate="yes" xml:space="preserve">
          <source>When you do application:start(odbc) the only thing that happens is that a supervisor process is started. For each call to the API function connect/2 a process is spawned and added as a child to the Erlang ODBC supervisor. The supervisors only tasks are to provide error-log reports, if a child process should die abnormally, and the possibility to do a code change. Only the client process has the knowledge to decide if this connection managing process should be restarted.</source>
          <target state="translated">Cuando haces application:start(odbc)lo único que pasa es que se inicia un proceso de supervisión.Por cada llamada a la función API connect/2 se genera un proceso y se añade como un niño al supervisor ODBC de Erlang.Las únicas tareas de los supervisores son proporcionar informes de registro de errores,si un proceso hijo muere de forma anormal,y la posibilidad de hacer un cambio de código.Sólo el proceso cliente tiene el conocimiento para decidir si este proceso de gestión de conexiones debe ser reiniciado.</target>
        </trans-unit>
        <trans-unit id="7400e1e45c6bbbe2f2d319b38f4bbb29db5b56b8" translate="yes" xml:space="preserve">
          <source>When you have covered all scenarios, call &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config/1&lt;/a&gt;&lt;/code&gt; in order to create a configuration. The configuration is written to a file that you have chosen. This configuration file can later be read by an Erlang runtime-system at startup. Pass the command line argument &lt;code&gt;-args_file FileName&lt;/code&gt; to the &lt;code&gt;erl(1)&lt;/code&gt; command.</source>
          <target state="translated">Cuando haya cubierto todos los escenarios, llame a &lt;code&gt;&lt;a href=&quot;#make_config-1&quot;&gt;make_config/1&lt;/a&gt;&lt;/code&gt; para crear una configuraci&amp;oacute;n. La configuraci&amp;oacute;n se escribe en un archivo que ha elegido. Este archivo de configuraci&amp;oacute;n puede ser le&amp;iacute;do m&amp;aacute;s tarde por un sistema en tiempo de ejecuci&amp;oacute;n de Erlang al inicio. Pase el argumento de la l&amp;iacute;nea de comando &lt;code&gt;-args_file FileName&lt;/code&gt; al &lt;code&gt;erl(1)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d53da3f7d650259d1f729b92236227077a1d6a9" translate="yes" xml:space="preserve">
          <source>When you have made a new version of a release, a release package can be created with this new version and transferred to the target environment.</source>
          <target state="translated">Cuando se ha hecho una nueva versión de un lanzamiento,se puede crear un paquete de lanzamiento con esta nueva versión y transferirlo al entorno de destino.</target>
        </trans-unit>
        <trans-unit id="aefe043fafd90a506fefaff1bdc21fce94c6f9bc" translate="yes" xml:space="preserve">
          <source>When you have written code implementing some specific functionality you might want to make the code into an &lt;strong&gt;application&lt;/strong&gt;, that is, a component that can be started and stopped as a unit, and which can also be reused in other systems.</source>
          <target state="translated">Cuando haya escrito c&amp;oacute;digo que implemente alguna funcionalidad espec&amp;iacute;fica, es posible que desee convertir el c&amp;oacute;digo en una &lt;strong&gt;aplicaci&amp;oacute;n&lt;/strong&gt; , es decir, un componente que se puede iniciar y detener como una unidad, y que tambi&amp;eacute;n se puede reutilizar en otros sistemas.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
