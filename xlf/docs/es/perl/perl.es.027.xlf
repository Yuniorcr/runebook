<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="82587c5990d27962027bcd8f44009a394aa03c6d" translate="yes" xml:space="preserve">
          <source>BENCHMARKS</source>
          <target state="translated">BENCHMARKS</target>
        </trans-unit>
        <trans-unit id="3eb8dc2707d319cff39e903c8f9e907ffde6faaa" translate="yes" xml:space="preserve">
          <source>BEST PRACTICE</source>
          <target state="translated">MEJORES PRÁCTICAS</target>
        </trans-unit>
        <trans-unit id="9971e7204a8b08d861ca7fadb789c6c4fe6817b8" translate="yes" xml:space="preserve">
          <source>BINARY_LOCATION</source>
          <target state="translated">BINARY_LOCATION</target>
        </trans-unit>
        <trans-unit id="d6b920160b07e6d8ef62aeb966afe0559c1c4da6" translate="yes" xml:space="preserve">
          <source>BINMODE</source>
          <target state="translated">BINMODE</target>
        </trans-unit>
        <trans-unit id="5d021fda0b6b8ed6bd452bf1168689693b7edba7" translate="yes" xml:space="preserve">
          <source>BINMODE this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf55ddd9725aa1a87e415a1396e069c8d47b25d1" translate="yes" xml:space="preserve">
          <source>BLOCK</source>
          <target state="translated">BLOCK</target>
        </trans-unit>
        <trans-unit id="457d9dafbbea9f5d194f2f920ae5f010432f75b2" translate="yes" xml:space="preserve">
          <source>BLOCKDEV</source>
          <target state="translated">BLOCKDEV</target>
        </trans-unit>
        <trans-unit id="b09c96efee066cc539728b4e2b0f68b4e32a0350" translate="yes" xml:space="preserve">
          <source>BOM as integer when fetched in network byte order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fcc9dd1e6686a3a9e94d9fb16092a9ef3f9ef8" translate="yes" xml:space="preserve">
          <source>BOM_UTF8</source>
          <target state="translated">BOM_UTF8</target>
        </trans-unit>
        <trans-unit id="9afa89ba4b3340d7bc1c3e18c656cfc5abf6d9a7" translate="yes" xml:space="preserve">
          <source>BOOLEAN = less-&amp;gt;of( FEATURE )</source>
          <target state="translated">BOOLEAN = menos-&amp;gt; de (FUNCI&amp;Oacute;N)</target>
        </trans-unit>
        <trans-unit id="3e4c26e4f6f8343f03e02567a3c22dbf6978ed5f" translate="yes" xml:space="preserve">
          <source>BOTTOM_GV</source>
          <target state="translated">BOTTOM_GV</target>
        </trans-unit>
        <trans-unit id="5538bef04345694943fc69521fc1c479110399bf" translate="yes" xml:space="preserve">
          <source>BOTTOM_NAME</source>
          <target state="translated">BOTTOM_NAME</target>
        </trans-unit>
        <trans-unit id="247befebedd2ed6823933439f49eb30a07d09dca" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION</source>
          <target state="translated">NOTACIÓN DE PARÉNTESIS</target>
        </trans-unit>
        <trans-unit id="17d26d9e28cc4c16fe9b307dc7f0b75e8a9d3b1b" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION SECURITY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25e7baf0562de8891b5c53dde5e9d802f4a0b6e" translate="yes" xml:space="preserve">
          <source>BREAKOUT_AT</source>
          <target state="translated">BREAKOUT_AT</target>
        </trans-unit>
        <trans-unit id="e7772b5b926c191f6bd98767963948f3ffc93baa" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIX no admite la notaci&amp;oacute;n shebang ( &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), por lo que debe usar las siguientes l&amp;iacute;neas:</target>
        </trans-unit>
        <trans-unit id="900c916101719763ca728f26535d16592b2fec22" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt;), so you have to use the following lines instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f442b9234477d8def500a9840cec8cff9ed97e5a" translate="yes" xml:space="preserve">
          <source>BSD</source>
          <target state="translated">BSD</target>
        </trans-unit>
        <trans-unit id="664c8d2ddb2e4dc2ea085ed16d6df4504ec03ee2" translate="yes" xml:space="preserve">
          <source>BSD::Resource on Solaris</source>
          <target state="translated">BSD::Recurso en Solaris</target>
        </trans-unit>
        <trans-unit id="df51adc50ecdca424b6145ec6164f8c39197a14c" translate="yes" xml:space="preserve">
          <source>BSD::Resource versions earlier than 1.09 do not compile on Solaris with perl 5.6.0 and higher, for the same reasons as Proc::ProcessTable. BSD::Resource versions starting from 1.09 have a workaround for the problem.</source>
          <target state="translated">BSD::Las versiones de recursos anteriores a la 1.09 no compilan en Solaris con perl 5.6.0 y superior,por las mismas razones que Proc::ProcessTable.BSD::Las versiones de recursos a partir de la 1.09 tienen una solución para el problema.</target>
        </trans-unit>
        <trans-unit id="d7fe8d7ec43bafda1404b3733deb73b25528fcbd" translate="yes" xml:space="preserve">
          <source>BSLOADLIBS</source>
          <target state="translated">BSLOADLIBS</target>
        </trans-unit>
        <trans-unit id="502dbddd3b35610af6911c0fbc9ca3be4bfe6d63" translate="yes" xml:space="preserve">
          <source>BTW. Beware too of pressure from managers who see you speed a program up by 50% of the runtime once, only to get a request one month later to do the same again (true story) - you'll just have to point out you're only human, even if you are a Perl programmer, and you'll see what you can do...</source>
          <target state="translated">POR CIERTO.Ten cuidado con la presión de los gerentes que te ven acelerar un programa en un 50% del tiempo de ejecución una vez,sólo para obtener una solicitud un mes después para hacer lo mismo de nuevo (historia real)-sólo tendrás que señalar que eres sólo un humano,incluso si eres un programador de Perl,y verás lo que puedes hacer...</target>
        </trans-unit>
        <trans-unit id="78253234498ab9f80f071ee0cf6c83a489538d17" translate="yes" xml:space="preserve">
          <source>BUFFERED VS UNBUFFERED (OR STREAMED)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95da7d5f97af571f044d5a433d68877d16ba4a5" translate="yes" xml:space="preserve">
          <source>BUFFERS</source>
          <target state="translated">BUFFERS</target>
        </trans-unit>
        <trans-unit id="8b9146b4f38600ca0e41fb96135f743cfdb11eec" translate="yes" xml:space="preserve">
          <source>BUG REPORTING</source>
          <target state="translated">REPORTE DE BUGS</target>
        </trans-unit>
        <trans-unit id="664f572fef857b1dfc7d6e286d22026a2508e1e5" translate="yes" xml:space="preserve">
          <source>BUG REPORTS</source>
          <target state="translated">INFORMES DE INSECTOS</target>
        </trans-unit>
        <trans-unit id="5dda8c520f4fbfda1830a8a497556d722a3fd113" translate="yes" xml:space="preserve">
          <source>BUGS</source>
          <target state="translated">BUGS</target>
        </trans-unit>
        <trans-unit id="9f989473548a594a947b969757db7fc06ca6a262" translate="yes" xml:space="preserve">
          <source>BUGS AND CAVEATS</source>
          <target state="translated">BICHOS Y ADVERTENCIAS</target>
        </trans-unit>
        <trans-unit id="fe771929835192040a55c6b146d4bbdcf0038546" translate="yes" xml:space="preserve">
          <source>BUGS AND IRRITATIONS</source>
          <target state="translated">BICHOS E IRRITACIONES</target>
        </trans-unit>
        <trans-unit id="affef23bcfe821a649489c10e4d45ae3607b1ccb" translate="yes" xml:space="preserve">
          <source>BUGS AND LIMITATIONS</source>
          <target state="translated">ERRORES Y LIMITACIONES</target>
        </trans-unit>
        <trans-unit id="118a34d613c11c790c196c946968113aa8bc32aa" translate="yes" xml:space="preserve">
          <source>BUGS AND PITFALLS</source>
          <target state="translated">BICHOS Y TRAMPAS</target>
        </trans-unit>
        <trans-unit id="a16fd7f9de623a809defab1d94048e0eded9677b" translate="yes" xml:space="preserve">
          <source>BUGS AND WARNINGS</source>
          <target state="translated">BICHOS Y ADVERTENCIAS</target>
        </trans-unit>
        <trans-unit id="2f8e6e225c82badf6f8a92aed6ef242d4dc4d03b" translate="yes" xml:space="preserve">
          <source>BUGS ON CYGWIN</source>
          <target state="translated">BUGS EN CYGWIN</target>
        </trans-unit>
        <trans-unit id="11f69a17d772a3f0d39aa116f097397dc1dac971" translate="yes" xml:space="preserve">
          <source>BUGS and CAVEATS</source>
          <target state="translated">BUGS y CUEVAS</target>
        </trans-unit>
        <trans-unit id="6c450a35b54bd0a62e732cbab24c3d7221d9a194" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use &lt;a href=&quot;mailto:perl5-porters@perl.org&quot;&gt;mailto:perl5-porters@perl.org&lt;/a&gt;. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=%24ModuleName&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=$ModuleName&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccf8d27dca59cf8914b7de42279bcf54b381c80d" translate="yes" xml:space="preserve">
          <source>BUGS is an email or url to post bug reports. For modules with UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org appears to automatically provide a URL for CPAN modules; any value given here overrides the default: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt;$ModuleName</source>
          <target state="translated">BUGS es un correo electr&amp;oacute;nico o URL para publicar informes de errores. Para m&amp;oacute;dulos con UPSTREAM =&amp;gt; 'blead', use perl5-porters@perl.org. rt.cpan.org parece proporcionar autom&amp;aacute;ticamente una URL para los m&amp;oacute;dulos CPAN; cualquier valor dado aqu&amp;iacute; anula el predeterminado: &lt;a href=&quot;http://rt.cpan.org/Public/Dist/Display.html?Name=&quot;&gt;http://rt.cpan.org/Public/Dist/Display.html?Name=&lt;/a&gt; $ ModuleName</target>
        </trans-unit>
        <trans-unit id="4fa4a173033ffa9b27f16cd2d7b309c255617591" translate="yes" xml:space="preserve">
          <source>BUGS/CAVEATS/etc</source>
          <target state="translated">BUGS/CAVEATS/etc</target>
        </trans-unit>
        <trans-unit id="9b8dfdff736c5b1dbf956b89d8a9d4fd925dacd2" translate="yes" xml:space="preserve">
          <source>BUILD</source>
          <target state="translated">BUILD</target>
        </trans-unit>
        <trans-unit id="0e162e98df920882beaaa37c9fd3fd9860be2bff" translate="yes" xml:space="preserve">
          <source>BUILD AND INSTALL</source>
          <target state="translated">CONSTRUIR E INSTALAR</target>
        </trans-unit>
        <trans-unit id="80ef3501d89bb441f42a9aac769a351966bde435" translate="yes" xml:space="preserve">
          <source>BUILD NEW EXTENSIONS</source>
          <target state="translated">CONSTRUIR NUEVAS EXTENSIONES</target>
        </trans-unit>
        <trans-unit id="915ac3e12b39990a3ff0eb519c7c070afd799641" translate="yes" xml:space="preserve">
          <source>BUILDING</source>
          <target state="translated">BUILDING</target>
        </trans-unit>
        <trans-unit id="a5d9fc029fc161e583884fa605ea5dd4bf5b0226" translate="yes" xml:space="preserve">
          <source>BUILDING AND INSTALLING MODULES ON DOS</source>
          <target state="translated">CONSTRUYENDO E INSTALANDO MÓDULOS EN DOS</target>
        </trans-unit>
        <trans-unit id="68c9d11aacf08e68cf9222616220471f55a4230e" translate="yes" xml:space="preserve">
          <source>BUILDING PERL FOR OPENVOS</source>
          <target state="translated">CONSTRUYENDO PERL PARA OPENVOS</target>
        </trans-unit>
        <trans-unit id="b603dd0f789cea0b71cf17b9cadf6a885369ee6d" translate="yes" xml:space="preserve">
          <source>BUILDING PERL ON AMIGAOS</source>
          <target state="translated">CONSTRUYENDO PERL EN AMIGAOS</target>
        </trans-unit>
        <trans-unit id="d40a175e7a653e9eaa67c4da87c76fc937184284" translate="yes" xml:space="preserve">
          <source>BUILD_REQUIRES</source>
          <target state="translated">BUILD_REQUIRES</target>
        </trans-unit>
        <trans-unit id="d5bdc31108d4219c97e8c1b7e29e0629da746aa9" translate="yes" xml:space="preserve">
          <source>BUNDLES</source>
          <target state="translated">BUNDLES</target>
        </trans-unit>
        <trans-unit id="92b48cc3d13ac12b362038111cf08e5cf8b03696" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="translated">Antes de que Perl tuviera el sistema XS para conectarse con bibliotecas C, los programadores sol&amp;iacute;an obtener constantes de biblioteca leyendo los archivos de encabezado C. Es posible que todav&amp;iacute;a vea &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 'syscall.ph'&lt;/code&gt; o similar alrededor - el</target>
        </trans-unit>
        <trans-unit id="a14d8f418667d750d655e37f8fb2aa536926510a" translate="yes" xml:space="preserve">
          <source>Back before Perl had the XS system for connecting with C libraries, programmers used to get library constants by reading through the C header files. You may still see &lt;code&gt;require 'syscall.ph'&lt;/code&gt; or similar around - the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a3e95e64a0aa298ba1dcd060974643f7be2839b" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper
half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower
half of a character&lt;/code&gt; . That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="translated">En aquel entonces, no se asign&amp;oacute; el rango 0xD800-0xDFFF. Dividamos ese rango por la mitad y usemos la primera mitad para representar la &lt;code&gt;upper half of a character&lt;/code&gt; y la segunda mitad para representar la &lt;code&gt;lower half of a character&lt;/code&gt; . De esa forma, puede representar 1024 * 1024 = 1048576 caracteres m&amp;aacute;s. Ahora podemos almacenar rangos de caracteres hasta \ x {10ffff} incluso con codificaciones de 16 bits. Este par de medio car&amp;aacute;cter ahora se llama</target>
        </trans-unit>
        <trans-unit id="8b862d333105bea92e016a8abca6974a21d6cf0e" translate="yes" xml:space="preserve">
          <source>Back then, the range 0xD800-0xDFFF was not allocated. Let's split that range in half and use the first half to represent the &lt;code&gt;upper half of a character&lt;/code&gt; and the second half to represent the &lt;code&gt;lower half of a character&lt;/code&gt;. That way, you can represent 1024 * 1024 = 1048576 more characters. Now we can store character ranges up to \x{10ffff} even with 16-bit encodings. This pair of half-character is now called a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bbe6515e366531ac45779e3d5c9b5a456560e812" translate="yes" xml:space="preserve">
          <source>Back to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f9a2a8bbfa8f04b97f0739e8cee87c19e9a7b1a" translate="yes" xml:space="preserve">
          <source>Back to converting data. If you have (or want) data in your system's native 8-bit encoding (e.g. Latin-1, EBCDIC, etc.), you can use pack/unpack to convert to/from Unicode.</source>
          <target state="translated">Volvamos a la conversión de datos.Si tienes (o quieres)datos en la codificación nativa de 8 bits de tu sistema (por ejemplo,Latin-1,EBCDIC,etc.),puedes usar pack/despack para convertir a/desde Unicode.</target>
        </trans-unit>
        <trans-unit id="917eb438525299e66d70b4deb11770f40a27eeaa" translate="yes" xml:space="preserve">
          <source>Backend for building test libraries</source>
          <target state="translated">Backend para la construcción de bibliotecas de prueba</target>
        </trans-unit>
        <trans-unit id="60865a55d575470308929e5970d44edcbdb31366" translate="yes" xml:space="preserve">
          <source>Background Processes</source>
          <target state="translated">Procesos de fondo</target>
        </trans-unit>
        <trans-unit id="777d367a0813af1945dd6a57f416558fa99c5a72" translate="yes" xml:space="preserve">
          <source>Background and PERL_IMPLICIT_CONTEXT</source>
          <target state="translated">Antecedentes y PERL_IMPLICIT_CONTEXT</target>
        </trans-unit>
        <trans-unit id="82139f465e7bfd51be69bcd2ba2252de65152f38" translate="yes" xml:space="preserve">
          <source>Background yourself like this:</source>
          <target state="translated">Ponte en el fondo así:</target>
        </trans-unit>
        <trans-unit id="fec43a1301d416fe4b43d921e7178671d812a1b8" translate="yes" xml:space="preserve">
          <source>Background: &lt;code&gt;atoi&lt;/code&gt; has severe problems with illegal inputs, it cannot be used for incremental parsing, and therefore should be avoided &lt;code&gt;atoi&lt;/code&gt; and &lt;code&gt;strtol&lt;/code&gt; are also affected by locale settings, which can also be seen as a bug (global state controlled by user environment).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eced385684cc6954de21105c9b174aaf3bba4295" translate="yes" xml:space="preserve">
          <source>Backported version unknown</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="422ea69f009b9513c410e1c50a5058f352b88507" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7bd776caf410341796f267d0b5a33a3e4a0364" translate="yes" xml:space="preserve">
          <source>Backreference to a named capture group. Equivalent to &lt;code&gt;\g{NAME}&lt;/code&gt; .</source>
          <target state="translated">Referencia inversa a un grupo de captura con nombre. Equivalente a &lt;code&gt;\g{NAME}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b67830d6a194880657acd61864c65e3027fb02e" translate="yes" xml:space="preserve">
          <source>Backreferences</source>
          <target state="translated">Backreferences</target>
        </trans-unit>
        <trans-unit id="89d9017aad56d057f4819297fea6ec35a3d1c796" translate="yes" xml:space="preserve">
          <source>Backreferences in substitutions use &quot;$&quot; rather than &quot;\&quot;.</source>
          <target state="translated">Las referencias en las sustituciones usan &quot;$&quot; en lugar de &quot;\&quot;.</target>
        </trans-unit>
        <trans-unit id="f6f78ea4ce7c5612a0f7211383bd0176dfc079e5" translate="yes" xml:space="preserve">
          <source>Backslash Operator</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5cf510bfb36856574ecae34fa00822be8b9c589" translate="yes" xml:space="preserve">
          <source>Backslash Sequences</source>
          <target state="translated">Secuencias de barra invertida</target>
        </trans-unit>
        <trans-unit id="db35629fab3798cdd79f1bf42fa413127bebc425" translate="yes" xml:space="preserve">
          <source>Backslash is used, as usual, to escape the next character.</source>
          <target state="translated">La barra invertida se utiliza,como de costumbre,para escapar del siguiente personaje.</target>
        </trans-unit>
        <trans-unit id="046c786ef212957156a16429eb6f369b2064b79d" translate="yes" xml:space="preserve">
          <source>Backslash sequence character classes cannot form one of the endpoints of a range. Thus, you can't say:</source>
          <target state="translated">Las clases de caracteres de secuencia de barra invertida no pueden formar uno de los puntos finales de un rango.Por lo tanto,no se puede decir:</target>
        </trans-unit>
        <trans-unit id="9900e3acb0e0a2eba6b592f80668e5cc6828f6c1" translate="yes" xml:space="preserve">
          <source>Backslash sequences</source>
          <target state="translated">Secuencias de retroceso</target>
        </trans-unit>
        <trans-unit id="c61c0b16c1836e4070c1986f40a121b830a65cf5" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt; ). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt; -style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="translated">Los caracteres con barra invertida se reemplazan con cadenas literales correspondientes (como con &lt;code&gt;\{&lt;/code&gt; ), o bien generan nodos especiales en el aut&amp;oacute;mata finito (como con &lt;code&gt;\b&lt;/code&gt; ). Los caracteres especiales del motor RE (como &lt;code&gt;|&lt;/code&gt; ) generan los nodos o grupos de nodos correspondientes. &lt;code&gt;(?#...)&lt;/code&gt; los comentarios se ignoran. Todo el resto se convierte en cadenas literales para que coincidan, o bien se ignora (al igual que los espacios en blanco y los comentarios de estilo &lt;code&gt;#&lt;/code&gt; si &lt;code&gt;/x&lt;/code&gt; est&amp;aacute; presente).</target>
        </trans-unit>
        <trans-unit id="5aeb8eb150f9b708f4b9ee0e63969a864d6fc87f" translate="yes" xml:space="preserve">
          <source>Backslashed characters are either replaced with corresponding literal strings (as with &lt;code&gt;\{&lt;/code&gt;), or else they generate special nodes in the finite automaton (as with &lt;code&gt;\b&lt;/code&gt;). Characters special to the RE engine (such as &lt;code&gt;|&lt;/code&gt;) generate corresponding nodes or groups of nodes. &lt;code&gt;(?#...)&lt;/code&gt; comments are ignored. All the rest is either converted to literal strings to match, or else is ignored (as is whitespace and &lt;code&gt;#&lt;/code&gt;-style comments if &lt;code&gt;/x&lt;/code&gt; is present).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396b0c95d21c97a92647624c67163f81645740c9" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like \\, \(, \), \[, \], \{, or \} is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="translated">Los metacaracteres con barra invertida en Perl son alfanum&amp;eacute;ricos, como &lt;code&gt;\b&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; . A diferencia de otros lenguajes de expresi&amp;oacute;n regular, no hay s&amp;iacute;mbolos con barra invertida que no sean alfanum&amp;eacute;ricos. Entonces, cualquier cosa que se parezca a \\, \ (, \), \ [, \], \ {o \} siempre se interpreta como un car&amp;aacute;cter literal, no como un metacar&amp;aacute;cter. Esto se us&amp;oacute; una vez en un idioma com&amp;uacute;n para deshabilitar o citar los significados especiales de los metacaracteres de expresi&amp;oacute;n regular en una cadena que desea usar para un patr&amp;oacute;n. Simplemente cite todos los caracteres que no sean &quot;palabras&quot;:</target>
        </trans-unit>
        <trans-unit id="a9e4564a4cffc22857c4489a19486bf89ae25eff" translate="yes" xml:space="preserve">
          <source>Backslashed metacharacters in Perl are alphanumeric, such as &lt;code&gt;\b&lt;/code&gt;, &lt;code&gt;\w&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;. Unlike some other regular expression languages, there are no backslashed symbols that aren't alphanumeric. So anything that looks like &lt;code&gt;\\&lt;/code&gt;, &lt;code&gt;\(&lt;/code&gt;, &lt;code&gt;\)&lt;/code&gt;, &lt;code&gt;\[&lt;/code&gt;, &lt;code&gt;\]&lt;/code&gt;, &lt;code&gt;\{&lt;/code&gt;, or &lt;code&gt;\}&lt;/code&gt; is always interpreted as a literal character, not a metacharacter. This was once used in a common idiom to disable or quote the special meanings of regular expression metacharacters in a string that you want to use for a pattern. Simply quote all non-&quot;word&quot; characters:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ad3bd6856b2f78166ba432a9cdf4da8413a4090" translate="yes" xml:space="preserve">
          <source>Backslashes parentheses &lt;code&gt;()&lt;/code&gt; in command line arguments. Doesn't handle recursive Makefile &lt;code&gt;$(...)&lt;/code&gt; constructs, but handles simple ones.</source>
          <target state="translated">Barra invertida entre par&amp;eacute;ntesis &lt;code&gt;()&lt;/code&gt; en los argumentos de la l&amp;iacute;nea de comandos. No maneja construcciones recursivas Makefile &lt;code&gt;$(...)&lt;/code&gt; , pero maneja construcciones simples.</target>
        </trans-unit>
        <trans-unit id="a44d458ea8adc4ce2457e80d59480bf2444b0e2c" translate="yes" xml:space="preserve">
          <source>Backticks</source>
          <target state="translated">Backticks</target>
        </trans-unit>
        <trans-unit id="cada2d153702b188c804c9ed93a320132370a768" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ef1c0d1318e1460dedacce3731d309fc7ffbb8a" translate="yes" xml:space="preserve">
          <source>Backticks &lt;code&gt;``&lt;/code&gt; (see &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;) with the command which contains redirection or shell meta-characters;</source>
          <target state="translated">Backticks &lt;code&gt;``&lt;/code&gt; (ver &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;Operadores de E / S en perlop&lt;/a&gt; ) con el comando que contiene metacaracteres de redirecci&amp;oacute;n o shell;</target>
        </trans-unit>
        <trans-unit id="6e2b605f65ba36a3d929c62881915b96a794f8f1" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified.</source>
          <target state="translated">Las comillas invertidas crean un subproceso y le pasan la cadena adjunta para que se ejecute como un comando DCL. Dado que el subproceso se crea directamente a trav&amp;eacute;s de &lt;code&gt;lib$spawn()&lt;/code&gt; , se puede especificar cualquier cadena de comando DCL v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="93a46463866e4337a557918eb7f92cb737fcdb4d" translate="yes" xml:space="preserve">
          <source>Backticks create a subprocess, and pass the enclosed string to it for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt;, any valid DCL command string may be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34532d18ad2d0f70e2d7b957fabc96ee06bc62fe" translate="yes" xml:space="preserve">
          <source>Backtracking</source>
          <target state="translated">Backtracking</target>
        </trans-unit>
        <trans-unit id="6e522c194b60635ece31d387544d1195051e629c" translate="yes" xml:space="preserve">
          <source>Backtracking control verbs</source>
          <target state="translated">Retroceder los verbos de control</target>
        </trans-unit>
        <trans-unit id="14496432005368ea983df3ea81b1252443b8ee8b" translate="yes" xml:space="preserve">
          <source>Backtracking during the relentless search for a match may be a waste of time, particularly when the match is bound to fail. Consider the simple pattern</source>
          <target state="translated">Retroceder durante la búsqueda implacable de una coincidencia puede ser una pérdida de tiempo,especialmente cuando la coincidencia está destinada a fallar.Considere el simple patrón</target>
        </trans-unit>
        <trans-unit id="0bce7971052281b2bb5edb4f3a21f79dd6904b31" translate="yes" xml:space="preserve">
          <source>Backtracking is more efficient than repeated tries with different regular expressions. If there are several regular expressions and a match with any of them is acceptable, then it is possible to combine them into a set of alternatives. If the individual expressions are input data, this can be done by programming a join operation. We'll exploit this idea in an improved version of the &lt;code&gt;simple_grep&lt;/code&gt; program: a program that matches multiple patterns:</source>
          <target state="translated">El retroceso es m&amp;aacute;s eficiente que los intentos repetidos con diferentes expresiones regulares. Si hay varias expresiones regulares y una coincidencia con alguna de ellas es aceptable, entonces es posible combinarlas en un conjunto de alternativas. Si las expresiones individuales son datos de entrada, esto se puede hacer programando una operaci&amp;oacute;n de combinaci&amp;oacute;n. Aprovecharemos esta idea en una versi&amp;oacute;n mejorada del programa &lt;code&gt;simple_grep&lt;/code&gt; : un programa que coincide con m&amp;uacute;ltiples patrones:</target>
        </trans-unit>
        <trans-unit id="fd4a1f65749d89056abcaeac3722a7b7a8fe75a1" translate="yes" xml:space="preserve">
          <source>Backward Compatibility</source>
          <target state="translated">Compatibilidad con el pasado</target>
        </trans-unit>
        <trans-unit id="23a7808b48afc84b0dceb9136590ca7bfdbb9b77" translate="yes" xml:space="preserve">
          <source>Backward compatibility</source>
          <target state="translated">Compatibilidad inversa</target>
        </trans-unit>
        <trans-unit id="ec09211f4889a2c8a77bac08067eb8783a4cd974" translate="yes" xml:space="preserve">
          <source>Backward compatible boilerplate</source>
          <target state="translated">Placa de calderas compatible con el pasado</target>
        </trans-unit>
        <trans-unit id="8fd78925dba59eef91afba0cdabe923520e5ee69" translate="yes" xml:space="preserve">
          <source>Backwards compatibility</source>
          <target state="translated">Rétrocompatibilité</target>
        </trans-unit>
        <trans-unit id="7d01557ea44942b942393d66060697fec065318a" translate="yes" xml:space="preserve">
          <source>Bad arg length for %s, is %u, should be %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="165656139a26613694c64dbf201f062c5151055a" translate="yes" xml:space="preserve">
          <source>Bad color mapping %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="71ab08a2349cea719fd65e95a92efa2f68979a67" translate="yes" xml:space="preserve">
          <source>Bad escape sequence %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97e53bd47a32a9c5ca5b26c7f73e5af6cefd27e1" translate="yes" xml:space="preserve">
          <source>Bad evalled substitution pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cec2366e742bda57450610acf903181d2989bf8" translate="yes" xml:space="preserve">
          <source>Bad example:</source>
          <target state="translated">Mal ejemplo:</target>
        </trans-unit>
        <trans-unit id="6b1ede25e2d280b57ab0ce582f6faf1b35cf90a7" translate="yes" xml:space="preserve">
          <source>Bad exit or wait status</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="390acb944960513fda956a00da4e57aecfbdc40d" translate="yes" xml:space="preserve">
          <source>Bad filehandle: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2545bb8b8757d12600ee0fd7c8d21fd5ad24ec74" translate="yes" xml:space="preserve">
          <source>Bad free() ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d801fbd5f10bc4ae72d676efa25b3f102ac7bc5e" translate="yes" xml:space="preserve">
          <source>Bad hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e025cf017a8d1ec1929f0fe963368b8537306db" translate="yes" xml:space="preserve">
          <source>Bad name after %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc9adf2eb1c251e659c032b900434bcbefd880c7" translate="yes" xml:space="preserve">
          <source>Bad plugin affecting keyword '%s'</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec81356ab8541823884a0a82a618613aa9cbd7b4" translate="yes" xml:space="preserve">
          <source>Bad realloc() ignored</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6da31fb3200e756607d3e2e50254f7cea20fa96d" translate="yes" xml:space="preserve">
          <source>Bad subroutine name for Fatal: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42447de9c1418f0e2c311d00634195d77eb4c7e0" translate="yes" xml:space="preserve">
          <source>Bad symbol for array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d65b92f2abbe5aa53ce089c4d6d379ebd454bfc3" translate="yes" xml:space="preserve">
          <source>Bad symbol for dirhandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b66844a23804f5fa9fb3dbb57550acc9e7e5e7dd" translate="yes" xml:space="preserve">
          <source>Bad symbol for filehandle</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7f407c0868b2e3ed85e66aedb4e0f3e18c18e11" translate="yes" xml:space="preserve">
          <source>Bad symbol for hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08cf554f79f8dc5600aa8436990c34983c96cb70" translate="yes" xml:space="preserve">
          <source>Bad symbol for scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1bd2e42ef1c41d1f7a37013a433505cff6f0d53" translate="yes" xml:space="preserve">
          <source>Badly placed ()'s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f60e950209318c3cca05ba1dcb8123b97e1b18f" translate="yes" xml:space="preserve">
          <source>Bailout</source>
          <target state="translated">Bailout</target>
        </trans-unit>
        <trans-unit id="55cc23ba5301ba2564daa62213188ebb8c917e57" translate="yes" xml:space="preserve">
          <source>Bailout result token.</source>
          <target state="translated">Un resultado de rescate simbólico.</target>
        </trans-unit>
        <trans-unit id="2e1aced5d91a77947ec0c1e15905db2c6dabdd2d" translate="yes" xml:space="preserve">
          <source>Bailout!</source>
          <target state="translated">Bailout!</target>
        </trans-unit>
        <trans-unit id="c9c7caaefe38d5bc0e42cffe87236c93a6e055ee" translate="yes" xml:space="preserve">
          <source>Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</source>
          <target state="translated">Bal&amp;aacute;zs Szab&amp;oacute; (dLux), dlux@kapu.hu</target>
        </trans-unit>
        <trans-unit id="fa6c3752cd00f7f1277fd7e5604ab8d2edaf26b8" translate="yes" xml:space="preserve">
          <source>Bangladesh</source>
          <target state="translated">Bangladesh</target>
        </trans-unit>
        <trans-unit id="528dadc6eada08b37b8564a84bbd615fedfa3a6d" translate="yes" xml:space="preserve">
          <source>Bar.pm</source>
          <target state="translated">Bar.pm</target>
        </trans-unit>
        <trans-unit id="991cc000e0ed51287d06994419ec5b5150b2fbbf" translate="yes" xml:space="preserve">
          <source>Bar.xs</source>
          <target state="translated">Bar.xs</target>
        </trans-unit>
        <trans-unit id="38e31cd750cd9c5c8abfa83e3cc07bbe5eb34dbc" translate="yes" xml:space="preserve">
          <source>Bare here-document terminators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f2f9eceeee98d7bac9099dfb477548bd0d00fe3" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; not allowed while &quot;strict subs&quot; in use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74184baa622016b052c2c66c26dc81d35681d05a" translate="yes" xml:space="preserve">
          <source>Bareword &quot;%s&quot; refers to nonexistent package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3f9425456098bc5db3b65fe0b670ee4dc328cf5" translate="yes" xml:space="preserve">
          <source>Bareword found in conditional</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c6c09ca8e54434a9e30a3ee7363deeca4c4687" translate="yes" xml:space="preserve">
          <source>Bareword in require contains &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99617bf4b7525e79f27dc14c638f75b9b86decd2" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to disallowed filename &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e217673de1982c957abdb450217720b611015045" translate="yes" xml:space="preserve">
          <source>Bareword in require maps to empty filename</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b08d7d96976813240018e31332af5b98b35fa0d" translate="yes" xml:space="preserve">
          <source>Bareword in require must not start with a double-colon: &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1ae41c7e90ad9133f0cec4b012d051f81574f4" translate="yes" xml:space="preserve">
          <source>Barewords</source>
          <target state="translated">Barewords</target>
        </trans-unit>
        <trans-unit id="6be542a3a79d103a3744357ed20ec40db010c97c" translate="yes" xml:space="preserve">
          <source>Barewords are not covered by overloaded string constants.</source>
          <target state="translated">Las palabras clave no están cubiertas por constantes de cadena sobrecargadas.</target>
        </trans-unit>
        <trans-unit id="a58b8ede3c3c15995119146605014af774c7bcd7" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Compress modules</source>
          <target state="translated">Clase base para IO::Módulos de compresión</target>
        </trans-unit>
        <trans-unit id="1aecc52f6145193c99cc41e745488c8d94f4db0b" translate="yes" xml:space="preserve">
          <source>Base Class for IO::Uncompress modules</source>
          <target state="translated">Clase base para IO::Módulos de descompresión</target>
        </trans-unit>
        <trans-unit id="9410f6a2867439548603d6c52d5c59ef4562fa7b" translate="yes" xml:space="preserve">
          <source>Base Structures</source>
          <target state="translated">Estructuras de base</target>
        </trans-unit>
        <trans-unit id="082fae7b28f65e5cb911e0f3f3f15b07bb66cbb1" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied handles</source>
          <target state="translated">Definiciones de clase base para asas atadas</target>
        </trans-unit>
        <trans-unit id="007ee9121a8b9e57fcd866ceebd36b23a00f0fde" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied hashes</source>
          <target state="translated">Definiciones de clase base para los hashes atados</target>
        </trans-unit>
        <trans-unit id="b6b455ad8f579493b53af2265bc184f2ba6c6cbb" translate="yes" xml:space="preserve">
          <source>Base class definitions for tied scalars</source>
          <target state="translated">Definiciones de clase base para los escalares atados</target>
        </trans-unit>
        <trans-unit id="9cae4a150d12d8ffc0b3fa77692959a6c4bfb799" translate="yes" xml:space="preserve">
          <source>Base class for ALL classes (blessed references)</source>
          <target state="translated">Clase base para TODAS las clases (benditas referencias)</target>
        </trans-unit>
        <trans-unit id="35cd310da77bd29a53a2d4932d2eb92ae62a2b7e" translate="yes" xml:space="preserve">
          <source>Base class for CPAN shell extensions</source>
          <target state="translated">Clase de base para las extensiones de los proyectiles CPAN</target>
        </trans-unit>
        <trans-unit id="c3e0f91a5e302404f6913115b1263f4db4575024" translate="yes" xml:space="preserve">
          <source>Base class for ExtUtils::Constant objects</source>
          <target state="translated">Clase base para las Extintas::Objetos constantes</target>
        </trans-unit>
        <trans-unit id="5ce69fa0ba6f632f7e9c5c2e2e7602e063a7c7a9" translate="yes" xml:space="preserve">
          <source>Base class for TAP source iterators</source>
          <target state="translated">Clase base para los iteradores de la fuente TAP</target>
        </trans-unit>
        <trans-unit id="37eb343993cd16220ab0f185a716f5c376429394" translate="yes" xml:space="preserve">
          <source>Base class for TAP::Parser output objects</source>
          <target state="translated">Clase base para TAP::Objetos de salida del analizador</target>
        </trans-unit>
        <trans-unit id="a0880f8d682b9138475bd47a938947c12338445c" translate="yes" xml:space="preserve">
          <source>Base class for Test2 IPC drivers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cde81f5a0639d96966be94bffabdcc2cee72d19" translate="yes" xml:space="preserve">
          <source>Base class for all event facets.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28ab0f65808322aafffdf4f4c4569b0ca559cecd" translate="yes" xml:space="preserve">
          <source>Base class for all event objects that get passed through &lt;a href=&quot;test2&quot;&gt;Test2&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8befc5059605409ade42b4d099e397b207c906b" translate="yes" xml:space="preserve">
          <source>Base class for creating POD filters and translators</source>
          <target state="translated">Clase base para crear filtros y traductores POD</target>
        </trans-unit>
        <trans-unit id="78eefd2e412b4d4df740ff4fbfcce92bad174022" translate="yes" xml:space="preserve">
          <source>Base class for different TAP source handlers</source>
          <target state="translated">Clase base para diferentes manejadores de fuentes TAP</target>
        </trans-unit>
        <trans-unit id="6d6b96a9e4df11d307d7125ce342fa82d8eb0fc3" translate="yes" xml:space="preserve">
          <source>Base class for events</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4dfc8dbeda31aa613f1ab98bcf6af5cdb80223d" translate="yes" xml:space="preserve">
          <source>Base class for harness output delegates</source>
          <target state="translated">Clase base para los delegados de salida del arnés</target>
        </trans-unit>
        <trans-unit id="7a74e67740b1a1d00bee0be3088f31fbc10821ea" translate="yes" xml:space="preserve">
          <source>Base class for test modules</source>
          <target state="translated">Clase base para los módulos de prueba</target>
        </trans-unit>
        <trans-unit id="78996d2c61d5e3e13d981dd6371495a7dc1b0695" translate="yes" xml:space="preserve">
          <source>Base class for tied arrays</source>
          <target state="translated">Clase base para matrices atadas</target>
        </trans-unit>
        <trans-unit id="4c8eae847ee205298317c9b96e374f69e5e9feb1" translate="yes" xml:space="preserve">
          <source>Base class package &quot;%s&quot; is empty.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5134fdf6155e7a9843c83a26849d1aff846f4d88" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8811ba419e75aa7afad3c58a4392ff34e2f70b65" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to &lt;a href=&quot;tap/parser&quot;&gt;TAP::Parser&lt;/a&gt;</source>
          <target state="translated">Clase base que proporciona una funcionalidad com&amp;uacute;n a &lt;a href=&quot;tap/parser&quot;&gt;TAP :: Parser&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="0808d28ca43c79c7220c0b66b8832ca8877ecfdc" translate="yes" xml:space="preserve">
          <source>Base class that provides common functionality to all &lt;code&gt;TAP::*&lt;/code&gt; modules</source>
          <target state="translated">Clase base que proporciona una funcionalidad com&amp;uacute;n a todos los m&amp;oacute;dulos &lt;code&gt;TAP::*&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="7a76be2c1588f2035fb74a3a61c2be909fdefa70" translate="yes" xml:space="preserve">
          <source>Base for Pod::Perldoc formatters</source>
          <target state="translated">Base para el Pod::Formateadores de Perldoc</target>
        </trans-unit>
        <trans-unit id="bf06e03b88934d434a87ce7787240b8e99aae0b0" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2291e71c9ac6320d0a4640a773f789651e805f6a" translate="yes" xml:space="preserve">
          <source>Based on Stevan Little's &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;Class::C3&lt;/a&gt;</source>
          <target state="translated">Basado en la &lt;a href=&quot;http://search.cpan.org/perldoc/Class::C3&quot;&gt;clase de&lt;/a&gt; Stevan Little : C3</target>
        </trans-unit>
        <trans-unit id="560c120ffa51ce8d2dc3b95d35311dd465a3c278" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text()&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Basado en el c&amp;oacute;digo de &lt;b&gt;Pod :: Text :: pod2text ()&lt;/b&gt; escrito por Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="25b805dbff71baab76550b6af4db1656526ccb89" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text::pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Basado en el c&amp;oacute;digo de &lt;b&gt;Pod :: Text :: pod2text (1)&lt;/b&gt; escrito por Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="b781efd9c14a9bf17ea0a940b2c65ad0a21bc5c6" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;Pod::Text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Basado en el c&amp;oacute;digo de &lt;b&gt;Pod :: Texto&lt;/b&gt; escrito por Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="d91768d646bf2b1ba37683cf7ff89c9b306d5b4f" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text(1)&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Basado en el c&amp;oacute;digo para &lt;b&gt;pod2text (1)&lt;/b&gt; escrito por Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e809a71bc55e573d735398064fa73868c841b25e" translate="yes" xml:space="preserve">
          <source>Based on code for &lt;b&gt;pod2text&lt;/b&gt; written by Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</source>
          <target state="translated">Basado en c&amp;oacute;digo para &lt;b&gt;pod2text&lt;/b&gt; escrito por Tom Christiansen &amp;lt;tchrist@mox.perl.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="23082a2ee1ef553f8b8e9cc56e439b97636f01bf" translate="yes" xml:space="preserve">
          <source>Based on code written by Shigio Yamaguchi.</source>
          <target state="translated">Basado en el código escrito por Shigio Yamaguchi.</target>
        </trans-unit>
        <trans-unit id="8e0d5bb83e47c2192346afc47fe774052eb51e39" translate="yes" xml:space="preserve">
          <source>Based on example that was initially added to MIME::QuotedPrint.pm for the 5.8.0 distribution of Perl.</source>
          <target state="translated">Basado en el ejemplo que se añadió inicialmente a MIME::QuotedPrint.pm para la distribución 5.8.0 de Perl.</target>
        </trans-unit>
        <trans-unit id="a800ab4559098c87aba7a8e90188704683d129b8" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; and</source>
          <target state="translated">Basado en ideas de Tim Bunce &amp;lt; &lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt; &amp;gt; y</target>
        </trans-unit>
        <trans-unit id="01bb16997fde52e47c429c6fd628c8c4ddf3054c" translate="yes" xml:space="preserve">
          <source>Based on ideas from Tim Bunce &amp;lt;&lt;code&gt;Tim.Bunce@ig.co.uk&lt;/code&gt;&amp;gt; and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef4b57022699f0d3f5da98a8d57cddc66db361df" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;:perlio&lt;/code&gt; layer.</source>
          <target state="translated">Basado en la capa &lt;code&gt;:perlio&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6189eca4d6c06b60af97bb9ce0c1f1fc615c134d" translate="yes" xml:space="preserve">
          <source>Based on the &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; code by Larry Wall and the Perl 5 Porters, which was released under the same license terms.</source>
          <target state="translated">Basado en el c&amp;oacute;digo &lt;code&gt;ExtUtils::xsubpp&lt;/code&gt; de Larry Wall y Perl 5 Porters, que fue lanzado bajo los mismos t&amp;eacute;rminos de licencia.</target>
        </trans-unit>
        <trans-unit id="da8636da22477810e470724d83ddc721d3335da8" translate="yes" xml:space="preserve">
          <source>Based on the Glossary of</source>
          <target state="translated">Basado en el Glosario de</target>
        </trans-unit>
        <trans-unit id="f28c9a8ac3d744f82801c7cfbb9de24801e7c563" translate="yes" xml:space="preserve">
          <source>Based on xsubpp code, written by Larry Wall.</source>
          <target state="translated">Basado en el código xsubpp,escrito por Larry Wall.</target>
        </trans-unit>
        <trans-unit id="02905231fdcd4472df63f80b291fb153344c31cd" translate="yes" xml:space="preserve">
          <source>Basic BLOCKs</source>
          <target state="translated">BLOQUES BÁSICOS</target>
        </trans-unit>
        <trans-unit id="901e56ace2d31ac4485efe2aa588116787957443" translate="yes" xml:space="preserve">
          <source>Basic IO operations</source>
          <target state="translated">Operaciones IO básicas</target>
        </trans-unit>
        <trans-unit id="8422cb1795fcef709d3e089320f56308fec39046" translate="yes" xml:space="preserve">
          <source>Basic Multilingual Plane</source>
          <target state="translated">Plano básico multilingüe</target>
        </trans-unit>
        <trans-unit id="ccecd116866361404babdb87c039096fbb71e99c" translate="yes" xml:space="preserve">
          <source>Basic Structure</source>
          <target state="translated">Estructura básica</target>
        </trans-unit>
        <trans-unit id="39bbc4bee9f4a75c10797a6d328f733ea1124880" translate="yes" xml:space="preserve">
          <source>Basic Thread Support</source>
          <target state="translated">Soporte de hilo básico</target>
        </trans-unit>
        <trans-unit id="17f89c170a632afd0c0b0383dacf728c05a89851" translate="yes" xml:space="preserve">
          <source>Basic Utilities for Programmers</source>
          <target state="translated">Utilidades básicas para los programadores</target>
        </trans-unit>
        <trans-unit id="148d2121cd077901af2d5cbf9aa363677304a06b" translate="yes" xml:space="preserve">
          <source>Basic commands:</source>
          <target state="translated">Comandos básicos:</target>
        </trans-unit>
        <trans-unit id="7308cb8418c068204c128968b5967fdf3606cc09" translate="yes" xml:space="preserve">
          <source>Basic methods</source>
          <target state="translated">Métodos básicos</target>
        </trans-unit>
        <trans-unit id="874d9df75ebdafc19870b90059bb69c04cb1fce7" translate="yes" xml:space="preserve">
          <source>Basic read operation.</source>
          <target state="translated">Operación de lectura básica.</target>
        </trans-unit>
        <trans-unit id="c4901220ad10be08f037f204182ab7f0bb55ef8b" translate="yes" xml:space="preserve">
          <source>Basic semaphores</source>
          <target state="translated">Semáforos básicos</target>
        </trans-unit>
        <trans-unit id="cf61d93532db2a473529a2856c70f230829513f8" translate="yes" xml:space="preserve">
          <source>Basic syntax overview</source>
          <target state="translated">Resumen de la sintaxis básica</target>
        </trans-unit>
        <trans-unit id="ce7944aa05e48b110f9c5b8903d70aed90358355" translate="yes" xml:space="preserve">
          <source>Basic utilities for writing tests.</source>
          <target state="translated">Utilidades básicas para los exámenes de escritura.</target>
        </trans-unit>
        <trans-unit id="62b9ac85afbcfa7bd7a8e867b1f51756e30ca7d7" translate="yes" xml:space="preserve">
          <source>Basic write operation.</source>
          <target state="translated">Operación de escritura básica.</target>
        </trans-unit>
        <trans-unit id="04e2b1373d1c985716d261c139c35de4bc421d62" translate="yes" xml:space="preserve">
          <source>Basically, Intel and VAX CPUs are little-endian, while everybody else, including Motorola m68k/88k, PPC, Sparc, HP PA, Power, and Cray, are big-endian. Alpha and MIPS can be either: Digital/Compaq uses (well, used) them in little-endian mode, but SGI/Cray uses them in big-endian mode.</source>
          <target state="translated">Básicamente,las CPUs Intel y VAX son little-endian,mientras que todas las demás,incluyendo las Motorola m68k/88k,PPC,Sparc,HP PA,Power y Cray,son big-endian.Alfa y MIPS pueden ser cualquiera de ellas:Digital/Compaq los usa (bueno,los usa)en modo little-endian,pero SGI/Cray los usa en modo big-endian.</target>
        </trans-unit>
        <trans-unit id="1f10fe5797c3d1f7733a7eb604c9de17cf9d91ac" translate="yes" xml:space="preserve">
          <source>Basically, you fetch individual results from the TAP. The six types, with examples of each, are as follows:</source>
          <target state="translated">Básicamente,se obtienen resultados individuales del TAP.Los seis tipos,con ejemplos de cada uno,son los siguientes:</target>
        </trans-unit>
        <trans-unit id="5fcebeefad3cdbbf8733aa928160dec7dc90c1a1" translate="yes" xml:space="preserve">
          <source>Basics</source>
          <target state="translated">Basics</target>
        </trans-unit>
        <trans-unit id="4beb8f757ba4e13e29ffb8c6a2d654b5eee3dc8e" translate="yes" xml:space="preserve">
          <source>Baud rate values</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3764ce6b277261088796ef6723dbaafdda0e32f0" translate="yes" xml:space="preserve">
          <source>Be aware of two important points:</source>
          <target state="translated">Tenga en cuenta dos puntos importantes:</target>
        </trans-unit>
        <trans-unit id="9042cbc9bb8a8748d18e82d265eee86b54008013" translate="yes" xml:space="preserve">
          <source>Be aware that all exceptions are stringified during construction.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4436a305cd04dc72f8078b037e6c2a662f1fa1d" translate="yes" xml:space="preserve">
          <source>Be aware that all filenames returned from File::Glob are tainted.</source>
          <target state="translated">Tengan en cuenta que todos los nombres de archivo devueltos de File::Glob están contaminados.</target>
        </trans-unit>
        <trans-unit id="3297ac638d07f74b1cf62949925d4b3e23422ec7" translate="yes" xml:space="preserve">
          <source>Be aware that many files in the distribution are derivative--avoid patching them, because git won't see the changes to them, and the build process will overwrite them. Patch the originals instead. Most utilities (like perldoc) are in this category, i.e. patch</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60f217633ac67f75e40713203caa69acc0ee5347" translate="yes" xml:space="preserve">
          <source>Be aware that setting &lt;code&gt;@DB::args&lt;/code&gt; is</source>
          <target state="translated">Tenga en cuenta que la configuraci&amp;oacute;n de &lt;code&gt;@DB::args&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="667b9a553537bba23ef30dd15f8a2bf40c9a72d6" translate="yes" xml:space="preserve">
          <source>Be aware that the digest routines silently convert UTF-8 input into its equivalent byte sequence in the native encoding (cf. utf8::downgrade). This side effect influences only the way Perl stores the data internally, but otherwise leaves the actual value of the data intact.</source>
          <target state="translated">Tenga en cuenta que las rutinas de digestión convierten silenciosamente la entrada UTF-8 en su secuencia de bytes equivalente en la codificación nativa (cf.utf8::downgrade).Este efecto secundario sólo influye en la forma en que Perl almacena los datos internamente,pero por lo demás deja intacto el valor real de los datos.</target>
        </trans-unit>
        <trans-unit id="167d28f752fc336f0724d4becf42fb8c17cf60ad" translate="yes" xml:space="preserve">
          <source>Be aware that the file's type/creator and resource fork will be lost, which is usually what you want in cross-platform archives.</source>
          <target state="translated">Tenga en cuenta que el tipo/creador del archivo y la horquilla de recursos se perderán,que suele ser lo que se quiere en los archivos multiplataforma.</target>
        </trans-unit>
        <trans-unit id="64b3ff265c6f33aa278b5fc7ab5adbd6a628d376" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a627d6aeb5bb9832269cd11d71094ebccabe8d0" translate="yes" xml:space="preserve">
          <source>Be aware that the main value of this module is its simplicity. Note that there are already more ambitious modules out there, such as &lt;a href=&quot;test/more&quot;&gt;Test::More&lt;/a&gt; and &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test::Unit&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que el principal valor de este m&amp;oacute;dulo es su simplicidad. Tenga en cuenta que ya existen m&amp;oacute;dulos m&amp;aacute;s ambiciosos, como &lt;a href=&quot;test/more&quot;&gt;Test :: More&lt;/a&gt; y &lt;a href=&quot;http://search.cpan.org/perldoc/Test::Unit&quot;&gt;Test :: Unit&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f073a8ab4396a4ea1a82c329831db3a4c81e7bb9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; had a chance to get the information. That means that &lt;code&gt;caller(N)&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt;. In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31de5d87ee0c0608b86806f39ac15e28011be167" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">Tenga en cuenta que el optimizador podr&amp;iacute;a haber optimizado los marcos de &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; antes de que la persona que llama tuviera la oportunidad de obtener la informaci&amp;oacute;n. Eso significa que es posible que la &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; que llama (N) no devuelva informaci&amp;oacute;n sobre el marco de llamada que espera, para &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . En particular, &lt;code&gt;@DB::args&lt;/code&gt; puede tener informaci&amp;oacute;n de la &amp;uacute;ltima vez que se llam&amp;oacute; al &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="956f008e111339a547685e28f223bd6fbcba83d9" translate="yes" xml:space="preserve">
          <source>Be aware that the optimizer might have optimized call frames away before &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; had a chance to get the information. That means that &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; might not return information about the call frame you expect it to, for &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . In particular, &lt;code&gt;@DB::args&lt;/code&gt; might have information from the previous time &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">Tenga en cuenta que el optimizador podr&amp;iacute;a haber optimizado los marcos de &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; antes de que la persona que llama tuviera la oportunidad de obtener la informaci&amp;oacute;n. Eso significa que es posible que la &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller(N)&lt;/a&gt;&lt;/code&gt; que llama (N) no devuelva informaci&amp;oacute;n sobre el marco de llamada que espera, para &lt;code&gt;N &amp;gt; 1&lt;/code&gt; . En particular, &lt;code&gt;@DB::args&lt;/code&gt; puede tener informaci&amp;oacute;n de la &amp;uacute;ltima vez que se llam&amp;oacute; al &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fd6d74606bcc17d1eb7f4b9d0cbb233b2fce04be" translate="yes" xml:space="preserve">
          <source>Be aware that the option to follow symbolic links can be dangerous. Depending on the structure of the directory tree (including symbolic links to directories) you might traverse a given (physical) directory more than once (only if &lt;code&gt;follow_fast&lt;/code&gt; is in effect). Furthermore, deleting or changing files in a symbolically linked directory might cause very unpleasant surprises, since you delete or change files in an unknown directory.</source>
          <target state="translated">Tenga en cuenta que la opci&amp;oacute;n de seguir enlaces simb&amp;oacute;licos puede ser peligrosa. Dependiendo de la estructura del &amp;aacute;rbol de directorios (incluidos los enlaces simb&amp;oacute;licos a directorios), puede atravesar un directorio (f&amp;iacute;sico) determinado m&amp;aacute;s de una vez (solo si &lt;code&gt;follow_fast&lt;/code&gt; est&amp;aacute; en vigor). Adem&amp;aacute;s, eliminar o cambiar archivos en un directorio vinculado simb&amp;oacute;licamente puede causar sorpresas muy desagradables, ya que elimina o cambia archivos en un directorio desconocido.</target>
        </trans-unit>
        <trans-unit id="b81ba14d3ce3de8180275845ca38e42a572b2c9a" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems.</source>
          <target state="translated">Tenga en cuenta que estas operaciones son bifurcaciones completas de Unix,lo que significa que pueden no estar correctamente implementadas en todos los sistemas alienígenas.</target>
        </trans-unit>
        <trans-unit id="edbf362a8476b23d76d24466d122396a40549047" translate="yes" xml:space="preserve">
          <source>Be aware that these operations are full Unix forks, which means they may not be correctly implemented on all alien systems. See &lt;a href=&quot;perlport#open&quot;&gt;&quot;open&quot; in perlport&lt;/a&gt; for portability details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d4c04a6ec8f48645b28a87376c9f6999c39b61b" translate="yes" xml:space="preserve">
          <source>Be aware that this option makes you accept invalid JSON texts as if they were valid!</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9573a203063d54f5dc27408bed7844c1be7ddce6" translate="yes" xml:space="preserve">
          <source>Be aware that this will export ANSI_COLORS_DISABLED to any child processes of your program as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9011ae4d69e158b2d5d9fa7d3f0fa4181ed416ab" translate="yes" xml:space="preserve">
          <source>Be aware that writing a multi-threaded application will not be portable to a platform which lacks the native thread-safe locale support. On systems that do have it, you automatically get this behavior for threaded perls, without having to do anything. If for some reason, you don't want to use this capability (perhaps the POSIX 2008 support is buggy on your system), you can manually compile Perl to use the old non-thread-safe implementation by passing the argument &lt;code&gt;-Accflags='-DNO_THREAD_SAFE_LOCALE'&lt;/code&gt; to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dac6d64c1feff1fddea48f799c315f06283805b" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source must be properly declared unless it is US-ASCII or Latin-1. POD input without an &lt;code&gt;=encoding&lt;/code&gt; command will be assumed to be in Latin-1, and if it's actually in UTF-8, the output will be double-encoded. See</source>
          <target state="translated">Tenga en cuenta que, al usar esta opci&amp;oacute;n, la codificaci&amp;oacute;n de entrada de su fuente POD debe declararse correctamente a menos que sea US-ASCII o Latin-1. Se supondr&amp;aacute; que la entrada de POD sin un comando de &lt;code&gt;=encoding&lt;/code&gt; est&amp;aacute; en Latin-1, y si realmente est&amp;aacute; en UTF-8, la salida tendr&amp;aacute; doble codificaci&amp;oacute;n. Ver</target>
        </trans-unit>
        <trans-unit id="112ebc66d2bbad303aae87da4af1076cd40b1dbe" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will produce warnings. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14539a0200a018d8bfd0c01f3ce67edac22b2e5e" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2man&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b528c0888545102ae09966c077f548f42a0a07e8" translate="yes" xml:space="preserve">
          <source>Be aware that, when using this option, the input encoding of your POD source should be properly declared unless it's US-ASCII. Pod::Simple will attempt to guess the encoding and may be successful if it's Latin-1 or UTF-8, but it will warn, which by default results in a &lt;b&gt;pod2text&lt;/b&gt; failure. Use the &lt;code&gt;=encoding&lt;/code&gt; command to declare the encoding. See &lt;a href=&quot;http://man.he.net/man1/perlpod&quot;&gt;perlpod(1)&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e54fdab18656cd50e15f88c4bd2cd505cbcafa9" translate="yes" xml:space="preserve">
          <source>Be aware, moreover, that even among Unix-ish systems there are variations.</source>
          <target state="translated">Tenga en cuenta,además,que incluso entre los sistemas de tipo Unix hay variaciones.</target>
        </trans-unit>
        <trans-unit id="56eaa37568b649078a87e40ea7bc8697501ac281" translate="yes" xml:space="preserve">
          <source>Be careful about the syntax,</source>
          <target state="translated">Tengan cuidado con la sintaxis,</target>
        </trans-unit>
        <trans-unit id="f8fdb4158175acb38dcf577960ceb71bd1d96eb9" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;a href=&quot;#formline-PICTURE%2CLIST&quot;&gt;&lt;code&gt;formline&lt;/code&gt;&lt;/a&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3f347eeb5e9dd5ad6442952b1aeb5c318d4fa11" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">Tenga cuidado si coloca comillas dobles alrededor de la imagen, porque un car&amp;aacute;cter &lt;code&gt;@&lt;/code&gt; puede interpretarse como el comienzo de un nombre de matriz. &lt;code&gt;&lt;a href=&quot;formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; siempre devuelve verdadero. Vea &lt;a href=&quot;../perlform&quot;&gt;perlform&lt;/a&gt; para otros ejemplos.</target>
        </trans-unit>
        <trans-unit id="6906a7867a27a79ea2a227d91624d262e203f04e" translate="yes" xml:space="preserve">
          <source>Be careful if you put double quotes around the picture, because an &lt;code&gt;@&lt;/code&gt; character may be taken to mean the beginning of an array name. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; always returns true. See &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; for other examples.</source>
          <target state="translated">Tenga cuidado si coloca comillas dobles alrededor de la imagen, porque un car&amp;aacute;cter &lt;code&gt;@&lt;/code&gt; puede interpretarse como el comienzo de un nombre de matriz. &lt;code&gt;&lt;a href=&quot;functions/formline&quot;&gt;formline&lt;/a&gt;&lt;/code&gt; siempre devuelve verdadero. Vea &lt;a href=&quot;perlform&quot;&gt;perlform&lt;/a&gt; para otros ejemplos.</target>
        </trans-unit>
        <trans-unit id="4aaaf54937dcd1947fa04a848c937575a75bb3aa" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; after a failed system call. Using &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; for anything else than displaying it as output is doubtful (though see the &lt;a href=&quot;errno&quot;&gt;&lt;code&gt;Errno&lt;/code&gt;&lt;/a&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9293d7623c3a63a2528c6144b0e2f16fd9c21b7" translate="yes" xml:space="preserve">
          <source>Be careful in the tests you supply with your module or programs. Module code may be fully portable, but its tests might not be. This often happens when tests spawn off other processes or call external programs to aid in the testing, or when (as noted above) the tests assume certain things about the filesystem and paths. Be careful not to depend on a specific output style for errors, such as when checking &lt;code&gt;$!&lt;/code&gt; after a failed system call. Using &lt;code&gt;$!&lt;/code&gt; for anything else than displaying it as output is doubtful (though see the &lt;code&gt;Errno&lt;/code&gt; module for testing reasonably portably for error value). Some platforms expect a certain output format, and Perl on those platforms may have been adjusted accordingly. Most specifically, don't anchor a regex when testing an error value.</source>
          <target state="translated">Tenga cuidado en las pruebas que proporciona con su m&amp;oacute;dulo o programas. El c&amp;oacute;digo del m&amp;oacute;dulo puede ser completamente port&amp;aacute;til, pero sus pruebas pueden no serlo. Esto sucede a menudo cuando las pruebas generan otros procesos o llaman a programas externos para ayudar en las pruebas, o cuando (como se indic&amp;oacute; anteriormente) las pruebas asumen ciertas cosas sobre el sistema de archivos y las rutas. Tenga cuidado de no depender de un estilo de salida espec&amp;iacute;fico para errores, como cuando se comprueba &lt;code&gt;$!&lt;/code&gt; despu&amp;eacute;s de una llamada al sistema fallida. Usando &lt;code&gt;$!&lt;/code&gt; para cualquier otra cosa que no sea mostrarlo como salida es dudoso (aunque vea el m&amp;oacute;dulo &lt;code&gt;Errno&lt;/code&gt; para probar razonablemente el valor de error). Algunas plataformas esperan un determinado formato de salida y es posible que Perl en esas plataformas se haya ajustado en consecuencia. M&amp;aacute;s espec&amp;iacute;ficamente, no ancle una expresi&amp;oacute;n regular al probar un valor de error.</target>
        </trans-unit>
        <trans-unit id="ae93e14e0d1be510a7665d0a55ac6aa4f668df14" translate="yes" xml:space="preserve">
          <source>Be careful to check that what you pass to chdir() is defined and not blank, else you might find yourself in your home directory.</source>
          <target state="translated">Ten cuidado de comprobar que lo que pasas a chdir()está definido y no en blanco,de lo contrario podrías encontrarte en tu directorio de inicio.</target>
        </trans-unit>
        <trans-unit id="c85ebb348de7431489e7e78b8e62158b4eaa9740" translate="yes" xml:space="preserve">
          <source>Be careful to check the return values from both open() and close(). If you're</source>
          <target state="translated">Ten cuidado de comprobar los valores de retorno tanto de open()como de close().Si usted está</target>
        </trans-unit>
        <trans-unit id="aee2df458bcc4bef02091d782f8436bc138473c7" translate="yes" xml:space="preserve">
          <source>Be careful to repeat this procedure every time you recompile an extension, unless you are sure the AFS installation directories are still valid.</source>
          <target state="translated">Tenga cuidado de repetir este procedimiento cada vez que recompile una extensión,a menos que esté seguro de que los directorios de instalación del AFS siguen siendo válidos.</target>
        </trans-unit>
        <trans-unit id="fe76e94f1a35b852ed4a509f3683ff3f6a306181" translate="yes" xml:space="preserve">
          <source>Be careful when using the branch reset pattern in combination with named captures. Named captures are implemented as being aliases to numbered groups holding the captures, and that interferes with the implementation of the branch reset pattern. If you are using named captures in a branch reset pattern, it's best to use the same names, in the same order, in each of the alternations:</source>
          <target state="translated">Tengan cuidado cuando usen el patrón de restablecimiento de rama en combinación con las capturas con nombre.Las capturas con nombre se implementan como alias a grupos numerados que mantienen las capturas,y eso interfiere con la implementación del patrón de restablecimiento de ramas.Si utiliza capturas con nombre en un patrón de restablecimiento de ramas,es mejor utilizar los mismos nombres,en el mismo orden,en cada una de las alternancias:</target>
        </trans-unit>
        <trans-unit id="8f8df673aaa9f753cd8e9cf23c8cbbd3b2574c49" translate="yes" xml:space="preserve">
          <source>Be careful, though, to never combine text strings with binary strings. If you need text in a binary stream, encode your text strings first using the appropriate encoding, then join them with binary strings. See also: &quot;What if I don't encode?&quot;.</source>
          <target state="translated">Pero ten cuidado de no combinar nunca cadenas de texto con cadenas binarias.Si necesitas texto en un flujo binario,codifica tus cadenas de texto primero usando la codificación apropiada,y luego únelas con cadenas binarias.Ver también:&quot;¿Qué pasa si no codifico?&quot;.</target>
        </trans-unit>
        <trans-unit id="cef4ef62c32e58e84f80436ec819bfd5a7afa02c" translate="yes" xml:space="preserve">
          <source>Be careful: qx(), system(), and some modules for calling external commands do a fork(), then wait() for the result. Thus, your signal handler will be called. Because wait() was already called by system() or qx(), the wait() in the signal handler will see no more zombies and will therefore block.</source>
          <target state="translated">Tengan cuidado:qx(),system(),y algunos módulos para llamar a comandos externos hacen un fork(),y luego esperan()por el resultado.De esta manera,su manejador de señales será llamado.Debido a que wait()ya fue llamado por system()o qx(),el wait()en el manejador de señales no verá más zombis y por lo tanto se bloqueará.</target>
        </trans-unit>
        <trans-unit id="02350f9e1a884f10cacbddf6be8d623a44b68fcb" translate="yes" xml:space="preserve">
          <source>Be consistent with existing modules.</source>
          <target state="translated">Sea coherente con los módulos existentes.</target>
        </trans-unit>
        <trans-unit id="8f9f60dfc3f60d9409a16936419f8f9c34030221" translate="yes" xml:space="preserve">
          <source>Be consistent.</source>
          <target state="translated">Sé consecuente.</target>
        </trans-unit>
        <trans-unit id="0657b8fedf171a48206a6318d37358a77e53c6fb" translate="yes" xml:space="preserve">
          <source>Be descriptive (i.e. accurately describes the purpose of the module).</source>
          <target state="translated">Ser descriptivo (es decir,describir con precisión el propósito del módulo).</target>
        </trans-unit>
        <trans-unit id="4866ce84e5913e3bbf14d1ef419eb24f1d72a52e" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="translated">Ya sea &lt;code&gt;Compress::Zlib&lt;/code&gt; , &lt;code&gt;Apache::Request&lt;/code&gt; o cualquier extensi&amp;oacute;n que no mencione Unicode en la p&amp;aacute;gina de manual, debe asegurarse de que el indicador UTF8 est&amp;eacute; eliminado. Tenga en cuenta que al momento de escribir este art&amp;iacute;culo (enero de 2012), los m&amp;oacute;dulos mencionados no son compatibles con UTF-8. Consulte la documentaci&amp;oacute;n para verificar si esto sigue siendo cierto.</target>
        </trans-unit>
        <trans-unit id="9583b4e268c09c5404dc953e2a7280e9a611066c" translate="yes" xml:space="preserve">
          <source>Be it &lt;code&gt;Compress::Zlib&lt;/code&gt;, &lt;code&gt;Apache::Request&lt;/code&gt; or any extension that has no mention of Unicode in the manpage, you need to make sure that the UTF8 flag is stripped off. Note that at the time of this writing (January 2012) the mentioned modules are not UTF-8-aware. Please check the documentation to verify if this is still true.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fec8bd9db93426cc5f677cbbc44d58f990b4ce4f" translate="yes" xml:space="preserve">
          <source>Be nice.</source>
          <target state="translated">Sé amable.</target>
        </trans-unit>
        <trans-unit id="455d700825e4b9a7601c1ce54b47786ce81ebe18" translate="yes" xml:space="preserve">
          <source>Be sure not to use a bareword as the name of a signal handler, lest you inadvertently call it.</source>
          <target state="translated">Asegúrate de no usar una palabra clave como nombre de un manejador de señales,no sea que lo llames inadvertidamente.</target>
        </trans-unit>
        <trans-unit id="adcfe790c3214b8902aa2d9bdbc7f166d3aa2497" translate="yes" xml:space="preserve">
          <source>Be sure that your yacc installation is in place including any necessary parser template files. If you have not already done so then be sure to:</source>
          <target state="translated">Asegúrate de que la instalación de tu yacc esté en su sitio incluyendo cualquier archivo de plantilla de análisis necesario.Si aún no lo ha hecho,entonces asegúrese de hacerlo:</target>
        </trans-unit>
        <trans-unit id="7a2fea634f3d3c3b87d0ddfbb5348eeeda046aad" translate="yes" xml:space="preserve">
          <source>Be sure to adequately comment your code. While commenting every line is unnecessary, anything that takes advantage of side effects of operators, that creates changes that will be felt outside of the function being patched, or that others may find confusing should be documented. If you are going to err, it is better to err on the side of adding too many comments than too few.</source>
          <target state="translated">Asegúrate de comentar adecuadamente tu código.Si bien es innecesario comentar cada línea,debe documentarse todo lo que aproveche los efectos secundarios de los operadores,que cree cambios que se sentirán fuera de la función que se está parcheando,o que otros puedan encontrar confuso.Si vas a equivocarte,es mejor equivocarse por el lado de añadir demasiados comentarios que por el de pocos.</target>
        </trans-unit>
        <trans-unit id="df103353e12184ad2bab2c528d00c711c155c484" translate="yes" xml:space="preserve">
          <source>Be sure to include the &lt;b&gt;exact&lt;/b&gt; error messages, if any. &quot;Perl gave an error&quot; is not an exact error message.</source>
          <target state="translated">Aseg&amp;uacute;rese de incluir los mensajes de error &lt;b&gt;exactos&lt;/b&gt; , si los hay. &quot;Perl dio un error&quot; no es un mensaje de error exacto.</target>
        </trans-unit>
        <trans-unit id="fb3f786d0833cb9684920951669ea14a5f8c452b" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;&quot;ENCODING&quot;&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5cbd612657dfbf7a92d6606e16853c43b77addf" translate="yes" xml:space="preserve">
          <source>Be sure to read &lt;a href=&quot;#ENCODING&quot;&gt;ENCODING&lt;/a&gt; if your Pod contains non-ASCII characters.</source>
          <target state="translated">Aseg&amp;uacute;rese de leer &lt;a href=&quot;#ENCODING&quot;&gt;CODIFICACI&amp;Oacute;N&lt;/a&gt; si su Pod contiene caracteres que no son ASCII.</target>
        </trans-unit>
        <trans-unit id="2984603dd54138b13d352a1e3fd61b6408be6b9f" translate="yes" xml:space="preserve">
          <source>Be sure to read the instructions near the top of the makefiles carefully.</source>
          <target state="translated">Asegúrese de leer cuidadosamente las instrucciones que se encuentran en la parte superior de los archivos.</target>
        </trans-unit>
        <trans-unit id="7f00ff2068b10342c9156aa44f6e62fb9656c3bb" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; of &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; for details.</source>
          <target state="translated">Aseg&amp;uacute;rese de especificar los requisitos de la versi&amp;oacute;n de Perl en Makefile.PL o Build.PL y con &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; 5.6.1&lt;/code&gt; o similar. Consulte la secci&amp;oacute;n sobre la &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; VERSION&lt;/code&gt; de &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; de &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="395569931cbd630cae76e8ec72604be440821c6b" translate="yes" xml:space="preserve">
          <source>Be sure to specify Perl version requirements both in Makefile.PL or Build.PL and with &lt;code&gt;require 5.6.1&lt;/code&gt; or similar. See the section on &lt;code&gt;use VERSION&lt;/code&gt; of &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c733e8a30868a3838b1dfa41af03cf511ee097ca" translate="yes" xml:space="preserve">
          <source>Be sure to use a tar program compiled under Solaris (not SunOS 4.x) to extract the perl-5.x.x.tar.gz file. Do not use GNU tar compiled for SunOS4 on Solaris. (GNU tar compiled for Solaris should be fine.) When you run SunOS4 binaries on Solaris, the run-time system magically alters pathnames matching m#lib/locale# so that when tar tries to create lib/locale.pm, a file named lib/oldlocale.pm gets created instead. If you found this advice too late and used a SunOS4-compiled tar anyway, you must find the incorrectly renamed file and move it back to lib/locale.pm.</source>
          <target state="translated">Asegúrese de usar un programa de alquitrán compilado bajo Solaris (no SunOS 4.x)para extraer el archivo perl-5.x.x.tar.gz.No use el tar GNU compilado para SunOS4 en Solaris.(GNU tar compilado para Solaris debería estar bien.)Cuando ejecutas binarios de SunOS4 en Solaris,el sistema en tiempo de ejecución altera mágicamente las rutas que coinciden con m#lib/locale#de modo que cuando tar intenta crear lib/locale.pm,en su lugar se crea un archivo llamado lib/oldlocale.pm.Si encontraste este consejo demasiado tarde y usaste un tar compilado por SunOS4 de todos modos,debes encontrar el archivo renombrado incorrectamente y moverlo de vuelta a lib/locale.pm.</target>
        </trans-unit>
        <trans-unit id="5d818ab86968387d2a89aaa4ecb39ab429064672" translate="yes" xml:space="preserve">
          <source>Be sure to use the libraries and modules shipped with the version being tested, not those that were already installed.</source>
          <target state="translated">Asegúrese de usar las bibliotecas y módulos que se envían con la versión que se está probando,no los que ya están instalados.</target>
        </trans-unit>
        <trans-unit id="e3d356b4e65052f33c752664cb97b29222d4870b" translate="yes" xml:space="preserve">
          <source>Be very careful with Perl operations that change the value of the variable. Appending something to the variable, for instance, might require reallocation of its storage, leaving you with a pointer into no-man's land.</source>
          <target state="translated">Tenga mucho cuidado con las operaciones Perl que cambian el valor de la variable.Añadir algo a la variable,por ejemplo,podría requerir la reasignación de su almacenamiento,dejándote con un puntero en tierra de nadie.</target>
        </trans-unit>
        <trans-unit id="a9df705eca9ff235f56efac76a8ae2aff600e09f" translate="yes" xml:space="preserve">
          <source>Be warned that neither creation nor deletion of files is guaranteed to be an atomic operation over NFS. That is, two processes might both successfully create or unlink the same file! Therefore O_EXCL isn't as exclusive as you might wish.</source>
          <target state="translated">Se advierte que no se garantiza que la creación o eliminación de archivos sea una operación atómica sobre NFS.Es decir,¡dos procesos pueden crear o desvincular con éxito el mismo archivo! Por lo tanto,O_EXCL no es tan exclusivo como podría desearse.</target>
        </trans-unit>
        <trans-unit id="15b58e5a1a4863b537d4c8fb01a3a9bfffd23c29" translate="yes" xml:space="preserve">
          <source>Be warned that proxying an &lt;code&gt;https&lt;/code&gt; connection opens you to the risk of a man-in-the-middle attack by the proxy server.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7184ad30ab6a73d32aaec035835bc55ad15b3389" translate="yes" xml:space="preserve">
          <source>Be warned that some formatters cannot reliably render characters outside 32-126; and many are able to handle 32-126 and 160-255, but nothing above 255.</source>
          <target state="translated">Se advierte que algunos formateadores no pueden renderizar de forma fiable los caracteres fuera de 32-126;y muchos son capaces de manejar 32-126 y 160-255,pero nada por encima de 255.</target>
        </trans-unit>
        <trans-unit id="8235118c9cdc1cd037bd4ff9c8b6234c4eceb334" translate="yes" xml:space="preserve">
          <source>Be warned that this feature is considered experimental, and may be changed without notice.</source>
          <target state="translated">Se advierte que esta característica se considera experimental,y puede ser cambiada sin previo aviso.</target>
        </trans-unit>
        <trans-unit id="f60dd616afaa8860904852bce46c16c4c9385db0" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="translated">Sin embargo, tenga en cuenta que, a diferencia de las expresiones regulares, si la plantilla de &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; no coincide con los datos entrantes, Perl gritar&amp;aacute; y morir&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="02d6d74dc9a4db2057c5683472b9fbbb7012f2b3" translate="yes" xml:space="preserve">
          <source>Be warned, though, that unlike regular expressions, if the &lt;code&gt;unpack&lt;/code&gt; template doesn't match the incoming data, Perl will scream and die.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f34bea745032a10b52d62f12a9de185a88d00d76" translate="yes" xml:space="preserve">
          <source>Be warned: just as the C-preprocessor doesn't know C, the Debug filter doesn't know Perl. It can be fooled quite easily:</source>
          <target state="translated">Atención:así como el preprocesador C no conoce el C,el filtro Debug no conoce el Perl.Puede ser engañado muy fácilmente:</target>
        </trans-unit>
        <trans-unit id="29bff63d2a655090d41ce27755886c450bf1e989" translate="yes" xml:space="preserve">
          <source>BeOS is BeOS.</source>
          <target state="translated">BeOS es BeOS.</target>
        </trans-unit>
        <trans-unit id="7127634cd20ce1300143c5a508c993ef4fdbd8f4" translate="yes" xml:space="preserve">
          <source>Because &quot;perlio.h&quot; is a thin layer (for efficiency) the semantics of these functions are somewhat dependent on the underlying implementation. Where these variations are understood they are noted below.</source>
          <target state="translated">Dado que &quot;perlio.h&quot; es una capa delgada (por eficiencia)la semántica de estas funciones depende en cierta medida de la aplicación subyacente.Cuando se entienden estas variaciones,se señalan a continuación.</target>
        </trans-unit>
        <trans-unit id="370f88e98782bfa7f114dbe532b100225210e150" translate="yes" xml:space="preserve">
          <source>Because 1 + 1 is 2, it prints:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e172ead13ccd2d2e8aa5c2a8960bb8d1e75406d" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#scalar-EXPR&quot;&gt;&lt;code&gt;scalar&lt;/code&gt;&lt;/a&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3b453ad82fa85092fb1368c3fb85257f0cedd1e" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;a href=&quot;#use-Module-VERSION-LIST&quot;&gt;&lt;code&gt;use&lt;/code&gt;&lt;/a&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ddac942d8eb120d517202681a1ab56648b51a75" translate="yes" xml:space="preserve">
          <source>Because &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; is a global variable, be careful that analyzing an exception caught by &lt;code&gt;eval&lt;/code&gt; doesn't replace the reference in the global variable. It's easiest to make a local copy of the reference before any manipulations. Here's an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b63ce495f650d704c02d64d23b111efdfe40cd61" translate="yes" xml:space="preserve">
          <source>Because &lt;b&gt;perldoc&lt;/b&gt; does not run properly tainted, and is known to have security issues, when run as the superuser it will attempt to drop privileges by setting the effective and real IDs to nobody's or nouser's account, or -2 if unavailable. If it cannot relinquish its privileges, it will not run.</source>
          <target state="translated">Debido a que &lt;b&gt;perldoc&lt;/b&gt; no se ejecuta correctamente contaminado y se sabe que tiene problemas de seguridad, cuando se ejecuta como superusuario, intentar&amp;aacute; eliminar los privilegios configurando las ID efectivas y reales en la cuenta de nadie o de ning&amp;uacute;n usuario, o -2 si no est&amp;aacute; disponible. Si no puede renunciar a sus privilegios, no se ejecutar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="400d81a8582d02a7d364c167bb3655c111853cb4" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; trigger interpolation, you'll need to use something like &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; to match them literally.</source>
          <target state="translated">Debido a que &lt;code&gt;$&lt;/code&gt; o &lt;code&gt;@&lt;/code&gt; activan la interpolaci&amp;oacute;n, necesitar&amp;aacute; usar algo como &lt;code&gt;/\Quser\E\@\Qhost/&lt;/code&gt; para hacer coincidirlos literalmente.</target>
        </trans-unit>
        <trans-unit id="b667c475fa92312c7083687d2886a12150dc73b8" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when the &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="translated">Debido a que &lt;code&gt;$sv&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; cuando se le aplica el operador &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; , la transliteraci&amp;oacute;n no se ejecutar&amp;aacute; realmente y el programa no &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . Esto es diferente a c&amp;oacute;mo se comportaron 5.8 y versiones anteriores, ya que las variables de captura eran variables READONLY entonces; ahora simplemente morir&amp;aacute;n cuando se les asigne en el motor predeterminado.</target>
        </trans-unit>
        <trans-unit id="6c984d748d72c5bb3b2196996f098ba27134cde9" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;$sv&lt;/code&gt; is &lt;code&gt;undef&lt;/code&gt; when the &lt;code&gt;y///&lt;/code&gt; operator is applied to it, the transliteration won't actually execute and the program won't &lt;code&gt;die&lt;/code&gt;. This is different to how 5.8 and earlier versions behaved since the capture variables were READONLY variables then; now they'll just die when assigned to in the default engine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b914e32b809fa7c48d9ec627188d82ebed09a33b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt;. The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt;s from the input list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5addc5234910932f591ed79ef1118cfac8717e21" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">Debido a que &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; devuelve &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; cuando cualquiera de los operandos es &lt;code&gt;NaN&lt;/code&gt; (no un n&amp;uacute;mero), tenga cuidado al ordenar con una funci&amp;oacute;n de comparaci&amp;oacute;n como &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; cualquier lista que pueda contener un &lt;code&gt;NaN&lt;/code&gt; . El siguiente ejemplo aprovecha que &lt;code&gt;NaN != NaN&lt;/code&gt; para eliminar cualquier &lt;code&gt;NaN&lt;/code&gt; de la lista de entrada.</target>
        </trans-unit>
        <trans-unit id="dbfd747a0cfe35cb8ad11b2926956f99d4f77a54" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; when either operand is &lt;code&gt;NaN&lt;/code&gt; (not-a-number), be careful when sorting with a comparison function like &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; any lists that might contain a &lt;code&gt;NaN&lt;/code&gt; . The following example takes advantage that &lt;code&gt;NaN != NaN&lt;/code&gt; to eliminate any &lt;code&gt;NaN&lt;/code&gt; s from the input list.</source>
          <target state="translated">Debido a que &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; devuelve &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; cuando cualquiera de los operandos es &lt;code&gt;NaN&lt;/code&gt; (no un n&amp;uacute;mero), tenga cuidado al ordenar con una funci&amp;oacute;n de comparaci&amp;oacute;n como &lt;code&gt;$a &amp;lt;=&amp;gt; $b&lt;/code&gt; cualquier lista que pueda contener un &lt;code&gt;NaN&lt;/code&gt; . El siguiente ejemplo aprovecha que &lt;code&gt;NaN != NaN&lt;/code&gt; para eliminar cualquier &lt;code&gt;NaN&lt;/code&gt; de la lista de entrada.</target>
        </trans-unit>
        <trans-unit id="89d0f8e67a21f5d12b3d2f9f3bbfa73cf7cb9115" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; is special in regular expressions, and can match any single character, the regex &lt;code&gt;P.&lt;/code&gt; here has matched the &amp;lt;Pl&amp;gt; in the original string.</source>
          <target state="translated">Porque &lt;code&gt;.&lt;/code&gt; es especial en expresiones regulares y puede coincidir con cualquier car&amp;aacute;cter, la expresi&amp;oacute;n regular &lt;code&gt;P.&lt;/code&gt; aqu&amp;iacute; ha coincidido con &amp;lt;Pl&amp;gt; en la cadena original.</target>
        </trans-unit>
        <trans-unit id="19a20b9f3a218df5a7c84d8e40e3cdca6928cac3" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;.&lt;/code&gt; was in use as a directory separator and filenames could not be assumed to be unique after 10 characters, Acorn implemented the C compiler to strip the trailing &lt;code&gt;.c&lt;/code&gt;&lt;code&gt;.h&lt;/code&gt;&lt;code&gt;.s&lt;/code&gt; and &lt;code&gt;.o&lt;/code&gt; suffix from filenames specified in source code and store the respective files in subdirectories named after the suffix. Hence files are translated:</source>
          <target state="translated">Porque &lt;code&gt;.&lt;/code&gt; estaba en uso como un separador de directorio y no se pod&amp;iacute;a suponer que los nombres de archivo fueran &amp;uacute;nicos despu&amp;eacute;s de 10 caracteres, Acorn implement&amp;oacute; el compilador de C para eliminar el sufijo &lt;code&gt;.c&lt;/code&gt; &lt;code&gt;.h&lt;/code&gt; &lt;code&gt;.s&lt;/code&gt; y &lt;code&gt;.o&lt;/code&gt; final de los nombres de archivo especificados en el c&amp;oacute;digo fuente y almacenar los archivos respectivos en subdirectorios con el nombre del sufijo. Por lo tanto, los archivos se traducen:</target>
        </trans-unit>
        <trans-unit id="daf7ef166b9a7929b988f6a60b2c3afc2523b46d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="translated">Debido a que &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; es un operador en tiempo de ejecuci&amp;oacute;n, se ejecuta cada vez a trav&amp;eacute;s de un bucle. En consecuencia, es m&amp;aacute;s eficiente localizar sus variables fuera del ciclo.</target>
        </trans-unit>
        <trans-unit id="2f69348654d069c347e7c5732088634fa13b4fd6" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">Debido a que &lt;code&gt;&lt;a href=&quot;functions/scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; es un operador unario, si accidentalmente usa una lista entre par&amp;eacute;ntesis para el EXPR, esto se comporta como una expresi&amp;oacute;n de coma escalar, evaluando todos menos el &amp;uacute;ltimo elemento en contexto vac&amp;iacute;o y devolviendo el elemento final evaluado en contexto escalar. Esto rara vez es lo que quieres.</target>
        </trans-unit>
        <trans-unit id="f2af4d959eb62b1a9bf83d9e5254d41aa11be74b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">Debido a que el &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; tiene efecto en el momento de la compilaci&amp;oacute;n, no respeta el control de flujo ordinario del c&amp;oacute;digo que se est&amp;aacute; compilando. En particular, poner un &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; dentro de la rama falsa de un condicional no evita que se procese. Si un m&amp;oacute;dulo o pragma solo necesita cargarse condicionalmente, esto se puede hacer usando &lt;a href=&quot;if&quot;&gt;if&lt;/a&gt; pragma:</target>
        </trans-unit>
        <trans-unit id="4bb9a434db491939507421e019d5c81a08c7de9d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; is a unary operator, if you accidentally use a parenthesized list for the EXPR, this behaves as a scalar comma expression, evaluating all but the last element in void context and returning the final element evaluated in scalar context. This is seldom what you want.</source>
          <target state="translated">Debido a que &lt;code&gt;&lt;a href=&quot;scalar&quot;&gt;scalar&lt;/a&gt;&lt;/code&gt; es un operador unario, si accidentalmente usa una lista entre par&amp;eacute;ntesis para el EXPR, esto se comporta como una expresi&amp;oacute;n de coma escalar, evaluando todos menos el &amp;uacute;ltimo elemento en contexto vac&amp;iacute;o y devolviendo el elemento final evaluado en contexto escalar. Esto rara vez es lo que quieres.</target>
        </trans-unit>
        <trans-unit id="c409d5f2e3bc5948e94957a82aeec5c28556f99d" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; takes effect at compile time, it doesn't respect the ordinary flow control of the code being compiled. In particular, putting a &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; inside the false branch of a conditional doesn't prevent it from being processed. If a module or pragma only needs to be loaded conditionally, this can be done using the &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</source>
          <target state="translated">Debido a que el &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; tiene efecto en el momento de la compilaci&amp;oacute;n, no respeta el control de flujo ordinario del c&amp;oacute;digo que se est&amp;aacute; compilando. En particular, poner un &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; dentro de la rama falsa de un condicional no evita que se procese. Si un m&amp;oacute;dulo o pragma solo necesita cargarse condicionalmente, esto se puede hacer usando &lt;a href=&quot;../if&quot;&gt;if&lt;/a&gt; pragma:</target>
        </trans-unit>
        <trans-unit id="3f563a9178b31c7b0b34b9e11ab4a6bde66fbd45" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global status variables that might be set by anything you do in your &lt;code&gt;DESTROY&lt;/code&gt; method. If you are in doubt about a particular status variable, it doesn't hurt to localize it. There are five global status variables, and the safest way is to localize all five of them:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7ea34c50bf47a71dd29a5e22af22a7376e9666b" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;DESTROY&lt;/code&gt; methods can be called at any time, you should localize any global variables you might update in your &lt;code&gt;DESTROY&lt;/code&gt; . In particular, if you use &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; you should localize &lt;code&gt;$@&lt;/code&gt; , and if you use &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or backticks you should localize &lt;code&gt;$?&lt;/code&gt; .</source>
          <target state="translated">Debido a que los m&amp;eacute;todos &lt;code&gt;DESTROY&lt;/code&gt; se pueden llamar en cualquier momento, debe localizar cualquier variable global que pueda actualizar en su &lt;code&gt;DESTROY&lt;/code&gt; . En particular, si usa &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; debe localizar &lt;code&gt;$@&lt;/code&gt; , y si usa &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; o comillas invertidas, debe localizar &lt;code&gt;$?&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b1a7e8c9b3926d0057e1f91a59eec1bca6ac0fe" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt; prove passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even when prove is run in taint mode.</source>
          <target state="translated">Debido a que &lt;code&gt;PERL5LIB&lt;/code&gt; se usa a menudo durante las pruebas para agregar directorios de &lt;code&gt;@INC&lt;/code&gt; a @INC, prueba pasa los nombres de los directorios que se encuentran en &lt;code&gt;PERL5LIB&lt;/code&gt; como conmutadores -I. El efecto neto de esto es que &lt;code&gt;PERL5LIB&lt;/code&gt; se respeta incluso cuando se ejecuta la prueba en modo taint.</target>
        </trans-unit>
        <trans-unit id="8d8b86b2aa791fa81fa4a800514b6911cd4cea09" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PERL5LIB&lt;/code&gt; is often used during testing to add build directories to &lt;code&gt;@INC&lt;/code&gt;&lt;code&gt;Test::Harness&lt;/code&gt; passes the names of any directories found in &lt;code&gt;PERL5LIB&lt;/code&gt; as -I switches. The net effect of this is that &lt;code&gt;PERL5LIB&lt;/code&gt; is honoured even in taint mode.</source>
          <target state="translated">Debido a que &lt;code&gt;PERL5LIB&lt;/code&gt; se usa a menudo durante las pruebas para agregar directorios de &lt;code&gt;@INC&lt;/code&gt; a @INC &lt;code&gt;Test::Harness&lt;/code&gt; pasa los nombres de los directorios que se encuentran en &lt;code&gt;PERL5LIB&lt;/code&gt; como conmutadores -I. El efecto neto de esto es que &lt;code&gt;PERL5LIB&lt;/code&gt; se respeta incluso en el modo de contaminaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="528ed40a74786c9daeb579970bad493df64c4a75" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;PL_restartop&lt;/code&gt; is non-null, &lt;code&gt;run_body&lt;/code&gt; starts a new runops loop and execution continues.</source>
          <target state="translated">Debido a que &lt;code&gt;PL_restartop&lt;/code&gt; no es nulo, &lt;code&gt;run_body&lt;/code&gt; inicia un nuevo ciclo de runops y la ejecuci&amp;oacute;n contin&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="add12825d3665c5532bcf2a78d2469e31a8a7e9f" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;STORABLE_attach&lt;/code&gt; is passed the class (rather than an object), it also returns the object directly, rather than modifying the passed object.</source>
          <target state="translated">Debido a que &lt;code&gt;STORABLE_attach&lt;/code&gt; se pasa la clase (en lugar de un objeto), tambi&amp;eacute;n devuelve el objeto directamente, en lugar de modificar el objeto pasado.</target>
        </trans-unit>
        <trans-unit id="65e2bf1b173528f8a073f03b46510698c20426ce" translate="yes" xml:space="preserve">
          <source>Because &lt;code&gt;local&lt;/code&gt; is a run-time operator, it gets executed each time through a loop. Consequently, it's more efficient to localize your variables outside the loop.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="308ec40cfa786d712d62a1e76733c4c3028b3e68" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt; ) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="translated">Debido a que Acorns usa ASCII con l&amp;iacute;neas nuevas ( &lt;code&gt;\n&lt;/code&gt; ) en archivos de texto como &lt;code&gt;\012&lt;/code&gt; como Unix, y debido a que la emulaci&amp;oacute;n de nombre de archivo Unix est&amp;aacute; activada de forma predeterminada, la mayor&amp;iacute;a de los scripts simples probablemente funcionar&amp;aacute;n &quot;fuera de la caja&quot;. El sistema de archivos nativo es modular, y los sistemas de archivos individuales son libres de distinguir entre may&amp;uacute;sculas y min&amp;uacute;sculas y, por lo general, conservan entre may&amp;uacute;sculas y min&amp;uacute;sculas. Algunos sistemas de archivos nativos tienen l&amp;iacute;mites de longitud de nombres, cuyos nombres de archivos y directorios se truncan silenciosamente para ajustarse. Los scripts deben tener en cuenta que el sistema de archivos est&amp;aacute;ndar actualmente tiene un l&amp;iacute;mite de longitud de nombre de &lt;b&gt;10&lt;/b&gt; caracteres, con hasta 77 elementos en un directorio, pero otros sistemas de archivos pueden no imponer tales limitaciones.</target>
        </trans-unit>
        <trans-unit id="28c382ede78c908c2143af19dbf455bab6188b9c" translate="yes" xml:space="preserve">
          <source>Because Acorns use ASCII with newlines (&lt;code&gt;\n&lt;/code&gt;) in text files as &lt;code&gt;\012&lt;/code&gt; like Unix, and because Unix filename emulation is turned on by default, most simple scripts will probably work &quot;out of the box&quot;. The native filesystem is modular, and individual filesystems are free to be case-sensitive or insensitive, and are usually case-preserving. Some native filesystems have name length limits, which file and directory names are silently truncated to fit. Scripts should be aware that the standard filesystem currently has a name length limit of &lt;b&gt;10&lt;/b&gt; characters, with up to 77 items in a directory, but other filesystems may not impose such limitations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="828cb90cec8613e5d83ab546b1c59479cecb4072" translate="yes" xml:space="preserve">
          <source>Because C has no builtin function for integer exponentiation, let's make Perl's ** operator available to it (this is less useful than it sounds, because Perl implements ** with C's</source>
          <target state="translated">Debido a que C no tiene una función incorporada para la exponenciación de números enteros,vamos a poner el operador de Perl **a su disposición (esto es menos útil de lo que parece,porque Perl implementa **con C's</target>
        </trans-unit>
        <trans-unit id="9459aa14a3cec514837284733b6c7f9c5dcb8910" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="translated">Debido a que Perl le permite usar palabras simples para nombres de paquetes y nombres de subrutinas, a veces interpreta incorrectamente el significado de una palabra clave. Por ejemplo, el constructo &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; puede interpretarse como &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; o &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt; . En ingl&amp;eacute;s, esa segunda interpretaci&amp;oacute;n se lee como &quot;llamar a una subrutina llamada Class (), luego llamar a new () como un m&amp;eacute;todo en el valor de retorno de Class ()&quot;. Si hay una subrutina llamada &lt;code&gt;Class()&lt;/code&gt; en el espacio de nombres actual, Perl siempre interpretar&amp;aacute; &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; como la segunda alternativa: una llamada a &lt;code&gt;new()&lt;/code&gt; en el objeto devuelto por una llamada a &lt;code&gt;Class()&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="e0ebaa0b26d8e2869e78f420c4e273d09ec93726" translate="yes" xml:space="preserve">
          <source>Because Perl allows you to use barewords for package names and subroutine names, it sometimes interprets a bareword's meaning incorrectly. For example, the construct &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; can be interpreted as either &lt;code&gt;'Class'-&amp;gt;new()&lt;/code&gt; or &lt;code&gt;Class()-&amp;gt;new()&lt;/code&gt;. In English, that second interpretation reads as &quot;call a subroutine named Class(), then call new() as a method on the return value of Class()&quot;. If there is a subroutine named &lt;code&gt;Class()&lt;/code&gt; in the current namespace, Perl will always interpret &lt;code&gt;Class-&amp;gt;new()&lt;/code&gt; as the second alternative: a call to &lt;code&gt;new()&lt;/code&gt; on the object returned by a call to &lt;code&gt;Class()&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aadc88ee4df674055a8e46229f25dab587fc29ec" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;../overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Debido a que Perl encadena los mensajes de excepci&amp;oacute;n no detectados antes de que se muestren, probablemente desee sobrecargar las operaciones de encadenamiento en los objetos de excepci&amp;oacute;n. Consulte la &lt;a href=&quot;../overload&quot;&gt;sobrecarga&lt;/a&gt; para obtener detalles al respecto.</target>
        </trans-unit>
        <trans-unit id="e1c5024f83c23d4c6dafd0e63d9f2e92824de07b" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that.</source>
          <target state="translated">Debido a que Perl encadena los mensajes de excepci&amp;oacute;n no detectados antes de que se muestren, probablemente desee sobrecargar las operaciones de encadenamiento en los objetos de excepci&amp;oacute;n. Consulte la &lt;a href=&quot;overload&quot;&gt;sobrecarga&lt;/a&gt; para obtener detalles al respecto.</target>
        </trans-unit>
        <trans-unit id="451d2525676f60927dbbc662f71037a75004b879" translate="yes" xml:space="preserve">
          <source>Because Perl stringifies uncaught exception messages before display, you'll probably want to overload stringification operations on exception objects. See &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt; for details about that. The stringified message should be non-empty, and should end in a newline, in order to fit in with the treatment of string exceptions. Also, because an exception object reference cannot be stringified without destroying it, Perl doesn't attempt to append location or other information to a reference exception. If you want location information with a complex exception object, you'll have to arrange to put the location information into the object yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2faaff7512cd20cbdff5d0e25efe8bfe139f7156" translate="yes" xml:space="preserve">
          <source>Because Perl uses doubles (or long doubles, if configured) internally for all numeric calculation, converting from double into float and thence to double again loses precision, so &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt;) will not in general equal $foo.</source>
          <target state="translated">Debido a que Perl usa dobles (o dobles largos, si est&amp;aacute; configurado) internamente para todos los c&amp;aacute;lculos num&amp;eacute;ricos, la conversi&amp;oacute;n de doble a flotante y luego a doble pierde precisi&amp;oacute;n, por lo que &lt;code&gt;unpack(&quot;f&quot;, pack(&quot;f&quot;, $foo)&lt;/code&gt; ) no lo har&amp;aacute;. en general igual a $ foo.</target>
        </trans-unit>
        <trans-unit id="398f8b38f72125ad882bed6f196a0775e260d2ad" translate="yes" xml:space="preserve">
          <source>Because UTF-8 is one of Perl's internal formats, you can often just skip the encoding or decoding step, and manipulate the UTF8 flag directly.</source>
          <target state="translated">Debido a que el UTF-8 es uno de los formatos internos de Perl,a menudo puedes saltarte el paso de codificación o decodificación,y manipular la bandera del UTF-8 directamente.</target>
        </trans-unit>
        <trans-unit id="6847617d71c84ec40d27c1365086ed8c20f1449c" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (and NOT something like &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declares the the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="translated">Debido a que UTF-EBCDIC es tan similar a UTF-8, las diferencias en su mayor&amp;iacute;a est&amp;aacute;n ocultas para usted; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; (y NO algo como &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utfebcdic&lt;/code&gt; ) declara que el script est&amp;aacute; en la codificaci&amp;oacute;n &quot;nativa&quot; de 8 bits de Unicode de la plataforma. (De manera similar para la capa &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="f78470b23c3e4057a6f3bfa3fb579763a7c89c67" translate="yes" xml:space="preserve">
          <source>Because UTF-EBCDIC is so similar to UTF-8, the differences are mostly hidden from you; &lt;code&gt;use utf8&lt;/code&gt; (and NOT something like &lt;code&gt;use utfebcdic&lt;/code&gt;) declares the script is in the platform's &quot;native&quot; 8-bit encoding of Unicode. (Similarly for the &lt;code&gt;&quot;:utf8&quot;&lt;/code&gt; layer.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="237849b1b007b545cf9244e10de8226da0ca3773" translate="yes" xml:space="preserve">
          <source>Because VMS's exit codes are much, much different than the rest of the universe, and perl does horrible mangling to them that gets in my way, it works like this on VMS.</source>
          <target state="translated">Debido a que los códigos de salida del VMS son muy,muy diferentes al resto del universo,y Perl les hace un horrible destrozo que se interpone en mi camino,funciona así en el VMS.</target>
        </trans-unit>
        <trans-unit id="815d9b38e08d4ff6dad9bd30fba64b1ec6e8aeb8" translate="yes" xml:space="preserve">
          <source>Because XS modules require re-linking of the perl binary, you need both the perl binary distribution and the perl source distribution to build an XS extension module. In addition, you will have to have built your perl binary from the source distribution so that all of the components of the perl binary are available for the required link step.</source>
          <target state="translated">Debido a que los módulos XS requieren la re-ligadura del binario de perl,se necesita tanto la distribución binaria de perl como la distribución de la fuente de perl para construir un módulo de extensión XS.Además,tendrá que haber construido su binario de perl a partir de la distribución fuente para que todos los componentes del binario de perl estén disponibles para el paso de enlace requerido.</target>
        </trans-unit>
        <trans-unit id="b57c6e3153bc9c89950406d1bdb5e4a01632a292" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">Debido a que una coincidencia de &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; fallida no restablece el desplazamiento, el retorno de &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; tampoco cambiar&amp;aacute; en este caso. Ver &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; y &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aac46af0a65c30c1278fb04116da06849260131d" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; match doesn't reset the offset, the return from &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; won't change either in this case. See &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">Debido a que una coincidencia de &lt;code&gt;&lt;a href=&quot;m&quot;&gt;m//gc&lt;/a&gt;&lt;/code&gt; fallida no restablece el desplazamiento, el retorno de &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; tampoco cambiar&amp;aacute; en este caso. Ver &lt;a href=&quot;../perlre&quot;&gt;perlre&lt;/a&gt; y &lt;a href=&quot;../perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f7ae901f4727ecaa2d777b8bd8dde60ff479daae" translate="yes" xml:space="preserve">
          <source>Because a failed &lt;code&gt;m//gc&lt;/code&gt; match doesn't reset the offset, the return from &lt;a href=&quot;#pos-SCALAR&quot;&gt;&lt;code&gt;pos&lt;/code&gt;&lt;/a&gt; won't change either in this case. See &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb2a05168485f04f9e352bc656013c7106c3b67" translate="yes" xml:space="preserve">
          <source>Because a list of potential candidates is returned, the &lt;code&gt;while&lt;/code&gt; loop tries each in turn until it finds one that succeeds both the socket() and connect() calls.</source>
          <target state="translated">Debido a que se devuelve una lista de posibles candidatos, el &lt;code&gt;while&lt;/code&gt; bucle de prueba cada vez, hasta que encuentra uno que tiene &amp;eacute;xito tanto a la toma () y conectar) (llamadas.</target>
        </trans-unit>
        <trans-unit id="93bb95979fc3bb902bf7566626913de80d560dcc" translate="yes" xml:space="preserve">
          <source>Because a name correction may be added in future Unicode releases, the name that &lt;code&gt;viacode&lt;/code&gt; returns may change as a result. This is a rare event, but it does happen.</source>
          <target state="translated">Debido a que se puede agregar una correcci&amp;oacute;n de nombre en futuras versiones de Unicode, el nombre que devuelve &lt;code&gt;viacode&lt;/code&gt; puede cambiar como resultado. Este es un evento raro, pero sucede.</target>
        </trans-unit>
        <trans-unit id="284e0db6a72cf3c4c7c4890513562109eb2a9995" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt; ; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt; . Think DeMorgan's laws.</source>
          <target state="translated">Debido a que un per&amp;iacute;odo es un metacar&amp;aacute;cter, debe escaparse para que coincida con un per&amp;iacute;odo ordinario. Dado que, por ejemplo, &lt;code&gt;\d&lt;/code&gt; y &lt;code&gt;\w&lt;/code&gt; son conjuntos de caracteres, es incorrecto pensar en &lt;code&gt;[^\d\w]&lt;/code&gt; como &lt;code&gt;[\D\W]&lt;/code&gt; ; de hecho, &lt;code&gt;[^\d\w]&lt;/code&gt; es lo mismo que &lt;code&gt;[^\w]&lt;/code&gt; , que es lo mismo que &lt;code&gt;[\W]&lt;/code&gt; . Piense en las leyes de DeMorgan.</target>
        </trans-unit>
        <trans-unit id="7b8b1120df9a594afd2813233aa665ec7f417ba1" translate="yes" xml:space="preserve">
          <source>Because a period is a metacharacter, it needs to be escaped to match as an ordinary period. Because, for example, &lt;code&gt;\d&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; are sets of characters, it is incorrect to think of &lt;code&gt;[^\d\w]&lt;/code&gt; as &lt;code&gt;[\D\W]&lt;/code&gt;; in fact &lt;code&gt;[^\d\w]&lt;/code&gt; is the same as &lt;code&gt;[^\w]&lt;/code&gt;, which is the same as &lt;code&gt;[\W]&lt;/code&gt;. Think DeMorgan's laws.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4df556755141c60db4ee1a86c658450735dbe881" translate="yes" xml:space="preserve">
          <source>Because a url like &lt;code&gt;http://myrepo.example.com/&lt;/code&gt; is ambiguous as to type, producers should provide a &lt;code&gt;type&lt;/code&gt; whenever a &lt;code&gt;url&lt;/code&gt; key is given. The &lt;code&gt;type&lt;/code&gt; field should be the name of the most common program used to work with the repository, e.g. &lt;code&gt;git&lt;/code&gt;, &lt;code&gt;svn&lt;/code&gt;, &lt;code&gt;cvs&lt;/code&gt;, &lt;code&gt;darcs&lt;/code&gt;, &lt;code&gt;bzr&lt;/code&gt; or &lt;code&gt;hg&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="934c60da6f18a9def8d944b8bcb6ee8755c35fe6" translate="yes" xml:space="preserve">
          <source>Because access() does not invoke stat() (at least not in a way visible to Perl), &lt;b&gt;the stat result cache &quot;_&quot; is not set&lt;/b&gt;. This means that the outcome of the following two tests is different. The first has the stat bits of</source>
          <target state="translated">Debido a que access () no invoca stat () (al menos no de una manera visible para Perl), &lt;b&gt;la cach&amp;eacute; de resultados de estad&amp;iacute;sticas &quot;_&quot; no est&amp;aacute; configurada&lt;/b&gt; . Esto significa que el resultado de las siguientes dos pruebas es diferente. El primero tiene los bits de estad&amp;iacute;sticas de</target>
        </trans-unit>
        <trans-unit id="390a39256a176624bc85b17cecc4ce28e0fc7e67" translate="yes" xml:space="preserve">
          <source>Because assignment of a reference to a typeglob creates an alias, this can be used to create what is effectively a local function, or at least, a local alias.</source>
          <target state="translated">Debido a que la asignación de una referencia a un typeglob crea un alias,esto puede ser usado para crear lo que es efectivamente una función local,o al menos,un alias local.</target>
        </trans-unit>
        <trans-unit id="0fe40d9c5df21e57c6ec455bae627177153c51cf" translate="yes" xml:space="preserve">
          <source>Because backticks do not affect standard error, use shell file descriptor syntax (assuming the shell supports this) if you care to address this. To capture a command's STDERR and STDOUT together:</source>
          <target state="translated">Dado que los backticks no afectan al error estándar,utilice la sintaxis del descriptor del archivo de shell (suponiendo que el shell lo soporte)si quiere solucionarlo.Para capturar el STDERR y STDOUT de un comando juntos:</target>
        </trans-unit>
        <trans-unit id="58a3a4b137a2ac3042f5ce6d5ed31ccf52919b18" translate="yes" xml:space="preserve">
          <source>Because both CRLF and LF end in LF, the input record separator can be set to LF and any CR stripped later. Better to write:</source>
          <target state="translated">Debido a que tanto el CRLF como el LF terminan en LF,el separador de registros de entrada puede ser configurado en LF y cualquier CR puede ser eliminado más tarde.Es mejor escribir:</target>
        </trans-unit>
        <trans-unit id="a49e08801e09e4ade1a0feed4948dfc00925efc8" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="translated">Debido a que las llaves (llaves) se utilizan para varias otras cosas, incluidos los BLOQUES, es posible que ocasionalmente tenga que eliminar la ambig&amp;uuml;edad de las llaves al comienzo de una declaraci&amp;oacute;n colocando un &lt;code&gt;+&lt;/code&gt; o un &lt;code&gt;&lt;a href=&quot;functions/return&quot;&gt;return&lt;/a&gt;&lt;/code&gt; al frente para que Perl se d&amp;eacute; cuenta de que la llave de apertura no est&amp;aacute; iniciando un BLOQUE. . La econom&amp;iacute;a y el valor mnem&amp;oacute;nico de usar curlies se considera que vale la pena esta molestia adicional ocasional.</target>
        </trans-unit>
        <trans-unit id="06e52ad8990a21a081873c75e0650e648002cb3f" translate="yes" xml:space="preserve">
          <source>Because curly brackets (braces) are used for several other things including BLOCKs, you may occasionally have to disambiguate braces at the beginning of a statement by putting a &lt;code&gt;+&lt;/code&gt; or a &lt;code&gt;return&lt;/code&gt; in front so that Perl realizes the opening brace isn't starting a BLOCK. The economy and mnemonic value of using curlies is deemed worth this occasional extra hassle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7b830bba46d3c56bd91aa88ed2e25a2ca316287" translate="yes" xml:space="preserve">
          <source>Because depending on a directory to just ensure it exists doesn't work too well (the modified time changes too often) dir_target() creates a .exists file in the created directory. It is this you should depend on. For portability purposes you should use the $(DIRFILESEP) macro rather than a '/' to separate the directory from the file.</source>
          <target state="translated">Porque depender de un directorio para asegurarse de que existe no funciona demasiado bien (el tiempo de modificación cambia con demasiada frecuencia)dir_target()crea un archivo .exists en el directorio creado.Es de esto de lo que debes depender.Para propósitos de portabilidad debes usar la macro $(DIRFILESEP)en vez de un '/' para separar el directorio del archivo.</target>
        </trans-unit>
        <trans-unit id="e43a24b825ab27b01432c41cd607e2f4d3328c51" translate="yes" xml:space="preserve">
          <source>Because each operand is evaluated in integer form, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; will return two elements in list context.</source>
          <target state="translated">Debido a que cada operando se eval&amp;uacute;a en forma de entero, &lt;code&gt;2.18 .. 3.14&lt;/code&gt; devolver&amp;aacute; dos elementos en el contexto de lista.</target>
        </trans-unit>
        <trans-unit id="d594331311925ecf9da3e16eb2cdc66b10c06327" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="translated">Porque incluso en los puertos que no son Unix, la funci&amp;oacute;n glob de Perl sigue la sem&amp;aacute;ntica globbing est&amp;aacute;ndar de Unix. Necesitar&amp;aacute; &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob(&quot;*&quot;)&lt;/a&gt;&lt;/code&gt; para obtener todos los archivos (no ocultos). Esto hace que glob () sea port&amp;aacute;til incluso para sistemas heredados. Su puerto tambi&amp;eacute;n puede incluir funciones de globbing patentadas. Consulte su documentaci&amp;oacute;n para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="4527823ffed4457ee7db37d2aeb7752e646692c1" translate="yes" xml:space="preserve">
          <source>Because even on non-Unix ports, Perl's glob function follows standard Unix globbing semantics. You'll need &lt;code&gt;glob(&quot;*&quot;)&lt;/code&gt; to get all (non-hidden) files. This makes glob() portable even to legacy systems. Your port may include proprietary globbing functions as well. Check its documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a019fec3551e537f7d797537de86770f8cb583e9" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;a href=&quot;#-Idirectory&quot;&gt;-I&lt;/a&gt; switch could also cause odd results.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2981f551145cc9ed169b464d8c0a095e7cf58a72" translate="yes" xml:space="preserve">
          <source>Because historically some operating systems silently chopped off kernel interpretation of the &lt;code&gt;#!&lt;/code&gt; line after 32 characters, some switches may be passed in on the command line, and some may not; you could even get a &quot;-&quot; without its letter, if you're not careful. You probably want to make sure that all your switches fall either before or after that 32-character boundary. Most switches don't actually care if they're processed redundantly, but getting a &quot;-&quot; instead of a complete switch could cause Perl to try to execute standard input instead of your program. And a partial &lt;b&gt;-I&lt;/b&gt; switch could also cause odd results.</source>
          <target state="translated">Porque hist&amp;oacute;ricamente algunos sistemas operativos cortaron silenciosamente la interpretaci&amp;oacute;n del kernel de &lt;code&gt;#!&lt;/code&gt; l&amp;iacute;nea despu&amp;eacute;s de 32 caracteres, algunos modificadores pueden pasarse en la l&amp;iacute;nea de comando y otros no; incluso podr&amp;iacute;a obtener un &quot;-&quot; sin su letra, si no tiene cuidado. Probablemente desee asegurarse de que todos sus conmutadores caigan antes o despu&amp;eacute;s de ese l&amp;iacute;mite de 32 caracteres. A la mayor&amp;iacute;a de los conmutadores en realidad no les importa si se procesan de forma redundante, pero obtener un &quot;-&quot; en lugar de un cambio completo podr&amp;iacute;a hacer que Perl intente ejecutar una entrada est&amp;aacute;ndar en lugar de su programa. Y un cambio &lt;b&gt;-I&lt;/b&gt; parcial tambi&amp;eacute;n podr&amp;iacute;a causar resultados extra&amp;ntilde;os.</target>
        </trans-unit>
        <trans-unit id="0e93d867e0e61a9f65c5551095616b09fa36af42" translate="yes" xml:space="preserve">
          <source>Because if _1 is one, you get &quot;1 document &lt;b&gt;were&lt;/b&gt; matched&quot;. An acceptable hack here is to do something like this:</source>
          <target state="translated">Porque si _1 es uno, que se obtiene &quot;1 documento &lt;b&gt;se&lt;/b&gt; corresponde&quot;. Un truco aceptable aqu&amp;iacute; es hacer algo como esto:</target>
        </trans-unit>
        <trans-unit id="14e83724617636cdff52bc89c9135eb24a32b2c3" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , to instruct perl.</source>
          <target state="translated">Debido a que no es posible distinguir UTF-8 de forma confiable a partir de codificaciones nativas de 8 bits, necesita una marca de orden de bytes al comienzo de su c&amp;oacute;digo fuente o &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8;&lt;/code&gt; , para instruir a perl.</target>
        </trans-unit>
        <trans-unit id="ad4161b2b0cababc93ea492bc495fcb997c97d88" translate="yes" xml:space="preserve">
          <source>Because it is not possible to reliably tell UTF-8 from native 8 bit encodings, you need either a Byte Order Mark at the beginning of your source code, or &lt;code&gt;use utf8;&lt;/code&gt;, to instruct perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2126d70bfd6541291d6dfdce3ec02ad289bb688a" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, &lt;code&gt;NEXT&lt;/code&gt; has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c9a76f6de0976ec0aec1cbf80b933b451074248" translate="yes" xml:space="preserve">
          <source>Because it's a module, not an integral part of the interpreter, NEXT.pm has to guess where the surrounding call was found in the method look-up sequence. In the presence of diamond inheritance patterns it occasionally guesses wrong.</source>
          <target state="translated">Debido a que es un módulo,no una parte integral del intérprete,el próximo día tiene que adivinar dónde se encontró la llamada circundante en la secuencia de búsqueda del método.En presencia de patrones de herencia de diamantes,ocasionalmente adivina mal.</target>
        </trans-unit>
        <trans-unit id="24e659fa848838e6ef33ca050446877416a84202" translate="yes" xml:space="preserve">
          <source>Because literal conversions also work on empty strings, it may surprise some people:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b07afd521e75a07298e5e250bb27a3b27578dea" translate="yes" xml:space="preserve">
          <source>Because loading in the &lt;code&gt;IO::Handle&lt;/code&gt; class is an expensive operation, you should learn how to use the regular built-in variables.</source>
          <target state="translated">Debido a que cargar en la clase &lt;code&gt;IO::Handle&lt;/code&gt; es una operaci&amp;oacute;n costosa, debe aprender a utilizar las variables integradas habituales.</target>
        </trans-unit>
        <trans-unit id="fb1b328dbd0a94624aa3c89dafc392fc30581afd" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt; . The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="translated">Debido a que muchos sistemas operativos permiten que cualquier persona con acceso de lectura al archivo de programa de Perl haga una copia, parchee la copia y luego ejecute la copia, el programador de Perl consciente de la seguridad debe tener cuidado de invocar la copia instalada de perl, no la copia referenciado por &lt;code&gt;$^X&lt;/code&gt; . Las siguientes declaraciones logran este objetivo y producen un nombre de ruta que puede invocarse como un comando o referenciarse como un archivo.</target>
        </trans-unit>
        <trans-unit id="dd84b64cdc62e50ad281c65222f1464d48cdcca2" translate="yes" xml:space="preserve">
          <source>Because many operating systems permit anyone with read access to the Perl program file to make a copy of it, patch the copy, and then execute the copy, the security-conscious Perl programmer should take care to invoke the installed copy of perl, not the copy referenced by &lt;code&gt;$^X&lt;/code&gt;. The following statements accomplish this goal, and produce a pathname that can be invoked as a command or referenced as a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9fda5ef27e15d5bae07e31ec0802921ed805374c" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; , or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="translated">Debido a que los identificadores de archivos del sistema operativo nativo son globales y actualmente se asignan por debajo de 255, siendo 0 un valor reservado, la biblioteca de emulaci&amp;oacute;n de Unix emula los identificadores de archivos de Unix. En consecuencia, no puede confiar en pasar &lt;code&gt;STDIN&lt;/code&gt; , &lt;code&gt;STDOUT&lt;/code&gt; o &lt;code&gt;STDERR&lt;/code&gt; a sus hijos.</target>
        </trans-unit>
        <trans-unit id="775710224a556c9491575c5fd5adccb463f6fd25" translate="yes" xml:space="preserve">
          <source>Because native operating system filehandles are global and are currently allocated down from 255, with 0 being a reserved value, the Unix emulation library emulates Unix filehandles. Consequently, you can't rely on passing &lt;code&gt;STDIN&lt;/code&gt;, &lt;code&gt;STDOUT&lt;/code&gt;, or &lt;code&gt;STDERR&lt;/code&gt; to your children.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5e62ec9329120e24ef0d8c20f22f5389de7c7e2" translate="yes" xml:space="preserve">
          <source>Because objects in Perl are implemented as references, it's possible to have circular references with objects as well. Imagine a TreeNode class where each node references its parent and child nodes. Any node with a parent will be part of a circular reference.</source>
          <target state="translated">Debido a que los objetos en Perl se implementan como referencias,es posible tener referencias circulares con los objetos también.Imagine una clase TreeNode donde cada nodo hace referencia a sus nodos padre e hijo.Cualquier nodo con un padre será parte de una referencia circular.</target>
        </trans-unit>
        <trans-unit id="0bd5958f518c949c2219a905e834fb00df87ae4a" translate="yes" xml:space="preserve">
          <source>Because of DST changes, there are many time zones where the same local time occurs for two different GMT times on the same day. For example, in the &quot;Europe/Paris&quot; time zone, the local time of 2001-10-28 02:30:00 can represent either 2001-10-28 00:30:00 GMT, &lt;b&gt;or&lt;/b&gt; 2001-10-28 01:30:00 GMT.</source>
          <target state="translated">Debido a los cambios de horario de verano, hay muchas zonas horarias en las que se produce la misma hora local para dos horas GMT diferentes en el mismo d&amp;iacute;a. Por ejemplo, en la zona horaria &quot;Europa / Par&amp;iacute;s&quot;, la hora local de 2001-10-28 02:30:00 puede representar 2001-10-28 00:30:00 GMT &lt;b&gt;o&lt;/b&gt; 2001-10-28 01: 30:00 GMT.</target>
        </trans-unit>
        <trans-unit id="65864a7a85dc93ea309cdec582c118e5dd979f14" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt; . Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="translated">Debido a un error en perl (# 19213), al menos en la versi&amp;oacute;n 5.6.1, tenemos que codificar el separador de ruta para que un requerimiento en Win32 sea &lt;code&gt;/&lt;/code&gt; , como en Unix en lugar de Win32 &lt;code&gt;\&lt;/code&gt; . De lo contrario, perl no leer&amp;aacute; sus propios archivos% INC de carga doble con precisi&amp;oacute;n si son necesarios de nuevo o, en el peor de los casos, si se realiza un volcado del n&amp;uacute;cleo.</target>
        </trans-unit>
        <trans-unit id="bddbdae97f197ffe17554a082cd1e7f07c2861e6" translate="yes" xml:space="preserve">
          <source>Because of a bug in perl (#19213), at least in version 5.6.1, we have to hardcode the path separator for a require on Win32 to be &lt;code&gt;/&lt;/code&gt;, like on Unix rather than the Win32 &lt;code&gt;\&lt;/code&gt;. Otherwise perl will not read its own %INC accurately double load files if they are required again, or in the worst case, core dump.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f334a2266086aa81e3afdad8578b63a9a352bf3" translate="yes" xml:space="preserve">
          <source>Because of a lack of anything better, this module uses its own routines to pack and unpack ICMP packets. It would be better for a separate module to be written which understands all of the different kinds of ICMP packets.</source>
          <target state="translated">Debido a la falta de algo mejor,este módulo utiliza sus propias rutinas para empaquetar y desempaquetar paquetes ICMP.Sería mejor que se escribiera un módulo separado que comprendiera todos los diferentes tipos de paquetes ICMP.</target>
        </trans-unit>
        <trans-unit id="c6dcc7b169aa07008925e53db149a044f2ea93db" translate="yes" xml:space="preserve">
          <source>Because of all the alias issues, and because in the general case encodings have state, &quot;Encode&quot; uses an encoding object internally once an operation is in progress.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c50ff3946dd738899f690c4bd5e562356a6223d1" translate="yes" xml:space="preserve">
          <source>Because of all these problems, starting in v5.22, Perl will raise a warning if a multi-byte (hence Unicode) code point is used when a single-byte locale is in effect. (Although it doesn't check for this if doing so would unreasonably slow execution down.)</source>
          <target state="translated">Debido a todos estos problemas,a partir de la v5.22,Perl emitirá una advertencia si se utiliza un punto de código de varios bytes (por lo tanto,Unicode)cuando una localidad de un solo byte está en efecto.(Aunque no comprueba esto si al hacerlo se ralentizaría injustificadamente la ejecución).</target>
        </trans-unit>
        <trans-unit id="7eca024239d85bdb38cb09ea249ea5b41add05bc" translate="yes" xml:space="preserve">
          <source>Because of backward compatibility with legacy encodings, the &quot;a unique number for every character&quot; idea breaks down a bit: instead, there is &quot;at least one number for every character&quot;. The same character could be represented differently in several legacy encodings. The converse is not true: some code points do not have an assigned character. Firstly, there are unallocated code points within otherwise used blocks. Secondly, there are special Unicode control characters that do not represent true characters.</source>
          <target state="translated">Debido a la compatibilidad con las codificaciones anteriores,la idea de &quot;un número único para cada personaje&quot; se rompe un poco:en cambio,hay &quot;al menos un número para cada personaje&quot;.El mismo carácter podría ser representado de forma diferente en varias codificaciones heredadas.Lo contrario no es cierto:algunos puntos de código no tienen un carácter asignado.En primer lugar,hay puntos de código no asignados dentro de bloques utilizados de otra manera.En segundo lugar,hay caracteres de control especiales de Unicode que no representan caracteres verdaderos.</target>
        </trans-unit>
        <trans-unit id="6c5cc2c32fa019382bf3152d3598a8ccd6be4473" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt; , people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="translated">Debido a que se pueden omitir los curlies para el caso simple de &lt;code&gt;$$x&lt;/code&gt; , las personas a menudo cometen el error de ver los s&amp;iacute;mbolos de desreferenciaci&amp;oacute;n como operadores adecuados y se preguntan sobre su precedencia. Sin embargo, si lo fueran, podr&amp;iacute;a usar par&amp;eacute;ntesis en lugar de llaves. Ese no es el caso. Considere la diferencia a continuaci&amp;oacute;n; el caso 0 es una versi&amp;oacute;n abreviada del caso 1,</target>
        </trans-unit>
        <trans-unit id="e8951f412eada97de516eafdeec177d3c0f76b4b" translate="yes" xml:space="preserve">
          <source>Because of being able to omit the curlies for the simple case of &lt;code&gt;$$x&lt;/code&gt;, people often make the mistake of viewing the dereferencing symbols as proper operators, and wonder about their precedence. If they were, though, you could use parentheses instead of braces. That's not the case. Consider the difference below; case 0 is a short-hand version of case 1,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e900a4e123821bf1949cbdd4fb9b5da407117914" translate="yes" xml:space="preserve">
          <source>Because of clock granularity, expiration times may occur up to one second sooner than you expect. For example, suppose you store a value with a lifetime of ten seconds, and you store it at 12:00:00.998 on a certain day. Memoize will look at the clock and see 12:00:00. Then 9.01 seconds later, at 12:00:10.008 you try to read it back. Memoize will look at the clock and see 12:00:10 and conclude that the value has expired. This will probably not occur if you have &lt;code&gt;Time::HiRes&lt;/code&gt; installed.</source>
          <target state="translated">Debido a la granularidad del reloj, los tiempos de caducidad pueden ocurrir hasta un segundo antes de lo esperado. Por ejemplo, suponga que almacena un valor con una duraci&amp;oacute;n de diez segundos y lo almacena a las 12:00: 00,998 de un d&amp;iacute;a determinado. Memoize mirar&amp;aacute; el reloj y ver&amp;aacute; 12:00:00. Luego, 9.01 segundos despu&amp;eacute;s, a las 12: 00: 10.008, intentas leerlo. Memoize mirar&amp;aacute; el reloj y ver&amp;aacute; 12:00:10 y concluir&amp;aacute; que el valor ha expirado. Esto probablemente no ocurrir&amp;aacute; si tiene &lt;code&gt;Time::HiRes&lt;/code&gt; instalado.</target>
        </trans-unit>
        <trans-unit id="c6e7a0449744f95f7025dc0e8c4838b8d0860c99" translate="yes" xml:space="preserve">
          <source>Because of idiosyncrasies of OS/2 one cannot have all the eggs in the same basket (though EMX environment tries hard to overcome this limitations, so the situation may somehow improve). There are 4 executables for Perl provided by the distribution:</source>
          <target state="translated">Debido a la idiosincrasia del OS/2 no se pueden tener todos los huevos en la misma cesta (aunque el entorno del EMX se esfuerza por superar estas limitaciones,por lo que la situación puede mejorar de alguna manera).Hay 4 ejecutables para Perl proporcionados por la distribución:</target>
        </trans-unit>
        <trans-unit id="38b54108e9558724b240349ad9589f54bf027fa2" translate="yes" xml:space="preserve">
          <source>Because of its global effect, this setting should not be used inside modules or the like.</source>
          <target state="translated">Debido a su efecto global,este ajuste no debe utilizarse dentro de los módulos o similares.</target>
        </trans-unit>
        <trans-unit id="cc4be6e39aa524fd29878685a03b1168c2bf5d9f" translate="yes" xml:space="preserve">
          <source>Because of our problems with the native yacc we used GNU bison to generate a pure (=reentrant) parser for perly.y. So our yacc is really the following script:</source>
          <target state="translated">Debido a nuestros problemas con el yacc nativo usamos GNU bisonte para generar un analizador puro (=reentrante)para perly.y.Así que nuestro yacc es realmente el siguiente guión:</target>
        </trans-unit>
        <trans-unit id="57e65a7490f61f523f42c4deffd151e416a21006" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;-ing to locations you got from &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; (and no others), and you are usually free to use &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; even in &quot;text&quot; mode. Using &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; or other file operations may be non-portable. If you use &lt;a href=&quot;perlfunc#binmode-FILEHANDLE&quot;&gt;&lt;code&gt;binmode&lt;/code&gt;&lt;/a&gt; on a file, however, you can usually &lt;a href=&quot;perlfunc#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlfunc#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; with arbitrary values safely.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9835e5c9cd0a637bdd223f60f76a72232d5d4783" translate="yes" xml:space="preserve">
          <source>Because of the &quot;text&quot; mode translation, DOSish perls have limitations in using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; on a file accessed in &quot;text&quot; mode. Stick to &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;-ing to locations you got from &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (and no others), and you are usually free to use &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; even in &quot;text&quot; mode. Using &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; or other file operations may be non-portable. If you use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; on a file, however, you can usually &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; with arbitrary values safely.</source>
          <target state="translated">Debido a la traducci&amp;oacute;n en modo &quot;texto&quot;, las perls de DOSish tienen limitaciones en el uso de &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; en un archivo al que se accede en modo &quot;texto&quot;. C&amp;iacute;&amp;ntilde;ete a la &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; de ubicaciones que obtuviste de &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; (y ninguna otra), y por lo general eres libre de usar &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; incluso en modo &quot;texto&quot;. El uso de &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; u otras operaciones de archivo puede no ser port&amp;aacute;til. Sin embargo, si usa &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; en un archivo, generalmente puede &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; con valores arbitrarios de manera segura.</target>
        </trans-unit>
        <trans-unit id="86b041b8cdbf2e2a44b563d3f9086435ec867343" translate="yes" xml:space="preserve">
          <source>Because of the 16-bitness, UTF-16 is byte-order dependent. UTF-16 itself can be used for in-memory computations, but if storage or transfer is required either UTF-16BE (big-endian) or UTF-16LE (little-endian) encodings must be chosen.</source>
          <target state="translated">Debido a los 16 bits,el UTF-16 depende del orden de los bytes.El UTF-16 en sí mismo puede ser usado para cálculos en memoria,pero si se requiere almacenamiento o transferencia,deben elegirse codificaciones UTF-16BE (big-endian)o UTF-16LE (little-endian).</target>
        </trans-unit>
        <trans-unit id="ddcee3f7b2710d631ab7d25c7c6ccf7f643a3fe9" translate="yes" xml:space="preserve">
          <source>Because of the algorithm used, ISO-8859 series and other single-byte encodings do not work well unless either one of ISO-8859 is the only one suspect (besides ascii and utf8).</source>
          <target state="translated">Debido al algoritmo utilizado,las series ISO-8859 y otras codificaciones de un solo byte no funcionan bien,a menos que alguno de los ISO-8859 sea el único sospechoso (además de ascii y utf8).</target>
        </trans-unit>
        <trans-unit id="5cf1c92c7c06c92a6e6b33e7b9bd233615db8e45" translate="yes" xml:space="preserve">
          <source>Because of the nature of the Perl parsing and tokenizing routines, certain initialization values &lt;b&gt;must&lt;/b&gt; be quoted in order to correctly parse as the intended version, especially when using the &lt;code&gt;declare&lt;/code&gt; or &lt;a href=&quot;#qv%28%29&quot;&gt;&quot;qv()&quot;&lt;/a&gt; methods. While you do not have to quote decimal numbers when creating version objects, it is always safe to quote &lt;b&gt;all&lt;/b&gt; initial values when using version.pm methods, as this will ensure that what you type is what is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e124c1c916c9b7a769264558af430e4f129d0a7" translate="yes" xml:space="preserve">
          <source>Because of the nature of the features it enables, forward compatibility can not be guaranteed in any way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89787285641f86ade5feb7e0702432198446d5b1" translate="yes" xml:space="preserve">
          <source>Because of the overhead associated with obtaining the list of defined symbols for the tied hash iterator, it is only done once, and the list is reused for subsequent iterations. Changes to symbols made through this package are recorded, but in the rare event that someone changes the process' symbol table from outside (as is possible using some software from the net), the iterator will be out of sync with the symbol table. If you expect this to happen, you can reset the cache by calling this method. In addition, if you pass a FALSE value as the first argument, caching will be disabled. It can be re-enabled later by calling &lt;code&gt;clearcache&lt;/code&gt; again with a TRUE value as the first argument. It returns TRUE or FALSE to indicate whether caching was previously enabled or disabled, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46fd1b6b9fa8982a77e6c457f5e31e6dd1a8e6bb" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only explicitly use it to maintain weird backward compatibilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11b9a9053f80eaf386518a04692ab13e4782146b" translate="yes" xml:space="preserve">
          <source>Because of the unexpected behaviors associated with this modifier, you probably should only use it to maintain weird backward compatibilities.</source>
          <target state="translated">Debido a los comportamientos inesperados asociados con este modificador,probablemente sólo deberías usarlo para mantener extrañas compatibilidades hacia atrás.</target>
        </trans-unit>
        <trans-unit id="033d419ed47a31e5b1999d8b2e6265eaff662dc3" translate="yes" xml:space="preserve">
          <source>Because of their special use by sort(), the variables $a and $b are exempted from this check.</source>
          <target state="translated">Debido a su uso especial por sort(),las variables $a y $b están exentas de este cheque.</target>
        </trans-unit>
        <trans-unit id="79393165c5e367768108e6eb51a718f96e4510a4" translate="yes" xml:space="preserve">
          <source>Because of this fallback feature of JSON.pm, JSON::PP tries not to be more JavaScript-friendly than JSON::XS (i.e. not to escape extra characters such as U+2028 and U+2029, etc), in order for you not to lose such JavaScript-friendliness silently when you use JSON.pm and install JSON::XS for speed or by accident. If you need JavaScript-friendly RFC7159-compliant pure perl module, try &lt;a href=&quot;JSON::Tiny&quot;&gt;JSON::Tiny&lt;/a&gt;, which is derived from &lt;a href=&quot;mojolicious&quot;&gt;Mojolicious&lt;/a&gt; web framework and is also smaller and faster than JSON::PP.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4c8809b3046a08b3452bb5931521fe0616806ce" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;d and not &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;d.</source>
          <target state="translated">Debido a este mecanismo, es importante que el &lt;b&gt;Autocargador&lt;/b&gt; siempre se &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; dy no &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; d.</target>
        </trans-unit>
        <trans-unit id="915eb569e5cd5ca772dbf6184e1e9e7f7c40e009" translate="yes" xml:space="preserve">
          <source>Because of this mechanism it is important that &lt;b&gt;AutoLoader&lt;/b&gt; is always &lt;code&gt;use&lt;/code&gt;d and not &lt;code&gt;require&lt;/code&gt;d.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf9b61922d31b09cb33aab7bed1a50c499c2933e" translate="yes" xml:space="preserve">
          <source>Because of those two, the code paging approach used use in ucm-based Encoding SOMETIMES fails so this module was written.</source>
          <target state="translated">Debido a estos dos,el enfoque de paginación de código usado en la codificación basada en ucm SOMETIMES falla,por lo que este módulo fue escrito.</target>
        </trans-unit>
        <trans-unit id="4732978c8da8f3cf527ff9f22b157a0776b9721a" translate="yes" xml:space="preserve">
          <source>Because patterns are processed as double-quoted strings, the following also work:</source>
          <target state="translated">Debido a que los patrones se procesan como cadenas de doble cita,lo siguiente también funciona:</target>
        </trans-unit>
        <trans-unit id="e94cf9546dd5c84d3c599b01ef4e83754d69c340" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="translated">Debido a que perl necesita analizar el script antes de aplicar este pragma, codificaciones como Shift_JIS y Big-5 que pueden contener &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt; ) en el segundo byte fallan porque el segundo byte puede escapar accidentalmente del car&amp;aacute;cter entre comillas que sigue.</target>
        </trans-unit>
        <trans-unit id="e3192cbde985ba3a61564abae80a07c49199034c" translate="yes" xml:space="preserve">
          <source>Because perl needs to parse the script before applying this pragma, such encodings as Shift_JIS and Big-5 that may contain &lt;code&gt;'\'&lt;/code&gt; (BACKSLASH; &lt;code&gt;\x5c&lt;/code&gt;) in the second byte fail because the second byte may accidentally escape the quoting character that follows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00d20d737f3e8559e674f183083581c5bd074a26" translate="yes" xml:space="preserve">
          <source>Because pointer size does not necessarily equal integer size, use the follow macros to do it right.</source>
          <target state="translated">Debido a que el tamaño del puntero no necesariamente es igual al tamaño del entero,usa las siguientes macros para hacerlo bien.</target>
        </trans-unit>
        <trans-unit id="1ab7d92c18b253929d90277eb1a2787d5ea83ae7" translate="yes" xml:space="preserve">
          <source>Because scripts differ in their directionality (Hebrew and Arabic are written right to left, for example) Unicode supplies a &lt;code&gt;Bidi_Class&lt;/code&gt; property. Some of the values this property can have are:</source>
          <target state="translated">Debido a que los scripts difieren en su direccionalidad (el hebreo y el &amp;aacute;rabe se escriben de derecha a izquierda, por ejemplo), Unicode proporciona una propiedad &lt;code&gt;Bidi_Class&lt;/code&gt; . Algunos de los valores que puede tener esta propiedad son:</target>
        </trans-unit>
        <trans-unit id="5783acfed14f8a18cb2ce82232df112d8f4b39d0" translate="yes" xml:space="preserve">
          <source>Because taintedness is associated with each scalar value, some elements of an array or hash can be tainted and others not. The keys of a hash are &lt;b&gt;never&lt;/b&gt; tainted.</source>
          <target state="translated">Debido a que la contaminaci&amp;oacute;n est&amp;aacute; asociada con cada valor escalar, algunos elementos de una matriz o hash pueden estar contaminados y otros no. Las claves de un hash &lt;b&gt;nunca&lt;/b&gt; est&amp;aacute;n contaminadas.</target>
        </trans-unit>
        <trans-unit id="43efff829e58f5a1345657268ce9125ae02a8e64" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="translated">Debido a que el valor &lt;code&gt;&lt;a href=&quot;../functions/chomp&quot;&gt;chomp&lt;/a&gt;&lt;/code&gt; tendr&amp;aacute; el separador vuelto a adjuntar cuando se vuelva a escribir en el archivo. No hay forma de crear un archivo en el que falte la cadena separadora de registros finales.</target>
        </trans-unit>
        <trans-unit id="1a39cf872a3f7b6aa066ba9c7802115aead55d6e" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="translated">Debido a que la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;&lt;/code&gt; devuelve &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; al final del archivo o en caso de error, a veces ver&amp;aacute; que se usa de esta manera:</target>
        </trans-unit>
        <trans-unit id="2d7cdbb67a74f8d2c9c047551149590e9752d672" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt;. With &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; you can get into this problem:</source>
          <target state="translated">Debido a que la declaraci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; implica un bloque &lt;code&gt;BEGIN&lt;/code&gt; , la importaci&amp;oacute;n de la sem&amp;aacute;ntica ocurre tan pronto como se compila la declaraci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , antes de que se compile el resto del archivo. As&amp;iacute; es como puede funcionar como un mecanismo pragma, y ​​tambi&amp;eacute;n c&amp;oacute;mo los m&amp;oacute;dulos pueden declarar subrutinas que luego son visibles como lista o operadores unarios para el resto del archivo actual. Esto no funcionar&amp;aacute; si usa &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; en lugar de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; . Con &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; puedes meterte en este problema:</target>
        </trans-unit>
        <trans-unit id="3c3e36ebc253e6320dfa90cfe5b728b065ce3f37" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;chomp&lt;/code&gt;ed value will have the separator reattached when it is written back to the file. There is no way to create a file whose trailing record separator string is missing.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af2ba8c1f36d75fd963bdb6706751e36d03bae43" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt; ; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="translated">Debido a que &lt;code&gt;here&lt;/code&gt; est&amp;aacute; antes del &lt;code&gt;.*&lt;/code&gt; En el patr&amp;oacute;n, su posici&amp;oacute;n se puede determinar exactamente. Sin embargo, eso no es cierto para el &lt;code&gt;there&lt;/code&gt; ; podr&amp;iacute;a aparecer en cualquier punto despu&amp;eacute;s de donde apareci&amp;oacute; la cuerda anclada. Perl usa ambos para sus optimizaciones, prefiriendo el m&amp;aacute;s largo o, si son iguales, el flotante.</target>
        </trans-unit>
        <trans-unit id="fef986661cf1ec507db2ffa4c44fc0d6ca39bba4" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;here&lt;/code&gt; is before the &lt;code&gt;.*&lt;/code&gt; in the pattern, its position can be determined exactly. That's not true, however, for the &lt;code&gt;there&lt;/code&gt;; it could appear at any point after where the anchored string appeared. Perl uses both for its optimisations, preferring the longer, or, if they are equal, the floating.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2431412f653ac2d48b2590f72b1ae7bed247322" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;mark&lt;/code&gt; variable is converted to a pointer on the value stack, extra care must be taken if &lt;code&gt;EXTEND&lt;/code&gt; or any of the &lt;code&gt;XPUSH&lt;/code&gt; macros are invoked within the function, because the stack may need to be moved to extend it and so the existing pointer will now be invalid. If this may be a problem, a possible solution is to track the mark offset as an integer and track the mark itself later on after the stack had been moved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="28a1dea2b8dc5fa2f3798b76ce3f11a720999a6b" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;readline&lt;/code&gt; function returns &lt;code&gt;undef&lt;/code&gt; at end of file or upon error, you will sometimes see it used this way:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="206300e9a9cae7d4d33910fad6d81cd5f5d5cc80" translate="yes" xml:space="preserve">
          <source>Because the &lt;code&gt;use&lt;/code&gt; statement implies a &lt;code&gt;BEGIN&lt;/code&gt; block, the importing of semantics happens as soon as the &lt;code&gt;use&lt;/code&gt; statement is compiled, before the rest of the file is compiled. This is how it is able to function as a pragma mechanism, and also how modules are able to declare subroutines that are then visible as list or unary operators for the rest of the current file. This will not work if you use &lt;code&gt;require&lt;/code&gt; instead of &lt;code&gt;use&lt;/code&gt;. With &lt;code&gt;require&lt;/code&gt; you can get into this problem:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cb97ff89f00546d3eb19d15e7c154022a6e40c9" translate="yes" xml:space="preserve">
          <source>Because the L&amp;lt;...&amp;gt; is the most complex construct in the language, it should not surprise you that the events it generates are the most complex in the language. Most of complexity is hidden away in the attribute values, so for those of you writing a Pod formatter that produces a non-hypertextual format, you can just ignore the attributes and treat an L event structure like a formatting element that (presumably) doesn't actually produce a change in formatting. That is, the content of the L event structure (as opposed to its attributes) is always what text should be displayed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe1ecaef6dcc4b2b01535ebf9f55c2fce3a55dd0" translate="yes" xml:space="preserve">
          <source>Because the arithmetic operators all have fixed arity and are postfixed, there is no need for operator precedence, nor for a grouping operator to override precedence. This is half of the point of RPN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="77f9c95f62f2ca8f51dfcabf085dd8aa40d54fc6" translate="yes" xml:space="preserve">
          <source>Because the assignment copies the values, this also has the effect of turning call-by-reference into call-by-value. Otherwise a function is free to do in-place modifications of &lt;code&gt;@_&lt;/code&gt; and change its caller's values.</source>
          <target state="translated">Dado que la asignaci&amp;oacute;n copia los valores, esto tambi&amp;eacute;n tiene el efecto de convertir la llamada por referencia en una llamada por valor. De lo contrario, una funci&amp;oacute;n es libre de realizar modificaciones in situ de &lt;code&gt;@_&lt;/code&gt; y cambiar los valores de su llamador.</target>
        </trans-unit>
        <trans-unit id="ef6e720933c8cfb7b84641d15fcb0ddf15b2f13b" translate="yes" xml:space="preserve">
          <source>Because the bytes pragma breaks encapsulation (i.e. it exposes the innards of how the perl executable currently happens to store a string), the byte values that result are in an unspecified encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c5cdf7c11299fa442df7b9179d8baed60991f7f" translate="yes" xml:space="preserve">
          <source>Because the conversion happens in place, the data to be converted cannot be a string constant: it must be a scalar variable.</source>
          <target state="translated">Debido a que la conversión ocurre en el lugar,los datos a ser convertidos no pueden ser una constante de cadena:debe ser una variable escalar.</target>
        </trans-unit>
        <trans-unit id="9be0ebeeed384a0006842b7e5b00f870be61a55a" translate="yes" xml:space="preserve">
          <source>Because the current implementation uses the table and key sizes for the hashing algorithm, there is no means by which to dynamically change the value of any of the initialization parameters.</source>
          <target state="translated">Dado que en la aplicación actual se utilizan los tamaños de la tabla y de la clave para el algoritmo de hashing,no hay medios para cambiar dinámicamente el valor de ninguno de los parámetros de inicialización.</target>
        </trans-unit>
        <trans-unit id="a16d069c72d0455b6bbcd09050d9c581b9a31d6b" translate="yes" xml:space="preserve">
          <source>Because the intent of this feature is primarily to let you define subroutines that work like built-in functions, here are prototypes for some other functions that parse almost exactly like the corresponding built-in.</source>
          <target state="translated">Debido a que la intención de esta característica es principalmente permitirle definir subrutinas que funcionen como funciones incorporadas,aquí hay prototipos de algunas otras funciones que analizan casi exactamente como la correspondiente incorporada.</target>
        </trans-unit>
        <trans-unit id="286b10724045d4807f7e79831cdfb01b70d2bd21" translate="yes" xml:space="preserve">
          <source>Because the internal format is often UTF-8, these bugs are hard to spot, because UTF-8 is usually the encoding you wanted! But don't be lazy, and don't use the fact that Perl's internal format is UTF-8 to your advantage. Encode explicitly to avoid weird bugs, and to show to maintenance programmers that you thought this through.</source>
          <target state="translated">Debido a que el formato interno es a menudo UTF-8,estos errores son difíciles de detectar,porque UTF-8 es por lo general la codificación que querías! Pero no seas perezoso,y no uses el hecho de que el formato interno de Perl es UTF-8 a tu favor.Codifica explícitamente para evitar errores extraños,y para mostrar a los programadores de mantenimiento que lo has pensado bien.</target>
        </trans-unit>
        <trans-unit id="92b5a68a7f930a6d97c59ffe2faa9fff5db40d0e" translate="yes" xml:space="preserve">
          <source>Because the magical increment only works on non-empty strings matching &lt;code&gt;/^[a-zA-Z]*[0-9]*\z/&lt;/code&gt;, the following will only return an alpha:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9f9af112f672f597ba8d8590f5548d9330b12e" translate="yes" xml:space="preserve">
          <source>Because the mode contains both the file type and its permissions, you should mask off the file type portion and (s)printf using a &lt;code&gt;&quot;%o&quot;&lt;/code&gt; if you want to see the real permissions.</source>
          <target state="translated">Debido a que el modo contiene tanto el tipo de archivo como sus permisos, debe enmascarar la parte del tipo de archivo y printf usando un &lt;code&gt;&quot;%o&quot;&lt;/code&gt; si desea ver los permisos reales.</target>
        </trans-unit>
        <trans-unit id="f2423ea47c406258a59791ed602061d34ce7d19b" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="translated">Debido a que el resultado de &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; tiene todos los metacaracteres citados, no hay forma de insertar un &lt;code&gt;$&lt;/code&gt; o &lt;code&gt;@&lt;/code&gt; literal dentro de un par &lt;code&gt;\Q\E&lt;/code&gt; Si est&amp;aacute; protegido por &lt;code&gt;\&lt;/code&gt; , &lt;code&gt;$&lt;/code&gt; se cotizar&amp;aacute; para convertirse en &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt; ; de lo contrario, se interpreta como el inicio de un escalar interpolado.</target>
        </trans-unit>
        <trans-unit id="097258c8be4cbb48ed4be0fc9859bc5c3825bc9a" translate="yes" xml:space="preserve">
          <source>Because the result of &lt;code&gt;&quot;\Q &lt;i&gt;STRING&lt;/i&gt; \E&quot;&lt;/code&gt; has all metacharacters quoted, there is no way to insert a literal &lt;code&gt;$&lt;/code&gt; or &lt;code&gt;@&lt;/code&gt; inside a &lt;code&gt;\Q\E&lt;/code&gt; pair. If protected by &lt;code&gt;\&lt;/code&gt;, &lt;code&gt;$&lt;/code&gt; will be quoted to become &lt;code&gt;&quot;\\\$&quot;&lt;/code&gt;; if not, it is interpreted as the start of an interpolated scalar.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d152f048af7d90769fe2fc306e54559a9ec00ef1" translate="yes" xml:space="preserve">
          <source>Because the smartmatch operator recurses on nested arrays, this will still report that &quot;red&quot; is in the array.</source>
          <target state="translated">Debido a que el operador del smartmatch recurre a las matrices anidadas,éste seguirá informando que el &quot;rojo&quot; está en la matriz.</target>
        </trans-unit>
        <trans-unit id="2efc41902e93fe5cc4de4d763dfe32a371a96fe2" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="translated">Porque el mensaje de falla est&amp;aacute;ndar que produce &lt;a href=&quot;../builder&quot;&gt;Test :: Builder&lt;/a&gt; cada vez que falla una prueba ser&amp;aacute; una ocurrencia com&amp;uacute;n en su salida de error de prueba, y porque ha cambiado entre las versiones de Test :: Builder, en lugar de forzarlo a llamar a &lt;code&gt;test_err&lt;/code&gt; con la cadena todos los tiempo as&amp;iacute;</target>
        </trans-unit>
        <trans-unit id="87490af32e5b48ef0bb10c89847f02a1cf0e7677" translate="yes" xml:space="preserve">
          <source>Because the standard failure message that &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; produces whenever a test fails will be a common occurrence in your test error output, and because it has changed between Test::Builder versions, rather than forcing you to call &lt;code&gt;test_err&lt;/code&gt; with the string all the time like so</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ad62b1bf690da795c5cc2f593aa204a22c3e54b" translate="yes" xml:space="preserve">
          <source>Because the target is reused, you must be careful when pushing multiple values on the stack. The following code will not do what you think:</source>
          <target state="translated">Debido a que el objetivo es reutilizado,debes tener cuidado al empujar múltiples valores en la pila.El siguiente código no hará lo que piensas:</target>
        </trans-unit>
        <trans-unit id="bdc28270d2ca87731131681df34d184cd0aea361" translate="yes" xml:space="preserve">
          <source>Because the transliteration table is built at compile time, neither the</source>
          <target state="translated">Debido a que la tabla de transliteración se construye en tiempo de compilación,ni la</target>
        </trans-unit>
        <trans-unit id="c4a2190965562aceb584191519393c161752b237" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt; may depend on the hardware architecture, it can vary more than the value of &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e5bc19b54b9930fd5e2dcb3e6dfb795d20462ff" translate="yes" xml:space="preserve">
          <source>Because the value of &lt;code&gt;$Config{archname}&lt;/code&gt; may depend on the hardware architecture, it can vary more than the value of &lt;code&gt;$^O&lt;/code&gt; .</source>
          <target state="translated">Debido a que el valor de &lt;code&gt;$Config{archname}&lt;/code&gt; puede depender de la arquitectura de hardware, que puede variar m&amp;aacute;s que el valor de &lt;code&gt;$^O&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e90ed527002ad403540a55eb78d4c5ab847fcd41" translate="yes" xml:space="preserve">
          <source>Because the values line may contain arbitrary expressions (for at fields, not caret fields), you can farm out more sophisticated processing to other functions, like sprintf() or one of your own. For example:</source>
          <target state="translated">Debido a que la línea de valores puede contener expresiones arbitrarias (para los campos de at,no para los campos de caret),puedes hacer un procesamiento más sofisticado para otras funciones,como sprintf()o una de las tuyas propias.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="d8bc8ec23c88de9efd45beeefb8be0639f500936" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">Debido a que la variable se vuelve legal inmediatamente bajo el &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , siempre que no haya ninguna variable con ese nombre en el alcance, puede hacer referencia a la variable del paquete nuevamente incluso dentro de la misma declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="da44b03f12b50aea312686ca3a3d0b93a5cee3d2" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="translated">Debido a que la variable se vuelve legal inmediatamente bajo el &lt;code&gt;&lt;a href=&quot;use&quot;&gt;use&lt;/a&gt; strict 'vars'&lt;/code&gt; , siempre que no haya ninguna variable con ese nombre en el alcance, puede hacer referencia a la variable del paquete nuevamente incluso dentro de la misma declaraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="10adcfecf1a02c362d02294237aa3b65ee35acfd" translate="yes" xml:space="preserve">
          <source>Because the variable becomes legal immediately under &lt;code&gt;use strict 'vars'&lt;/code&gt;, so long as there is no variable with that name is already in scope, you can then reference the package variable again even within the same statement.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1213676c8b2ebcfdeacd60c8eeb78e070a8906e8" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), forks the ps(1) command</source>
          <target state="translated">Debido a que hay más de tres argumentos para abrir(),se bifurca el comando ps(1)</target>
        </trans-unit>
        <trans-unit id="327e12e185eccd28ae382163925adec0406495ff" translate="yes" xml:space="preserve">
          <source>Because there are more than three arguments to open(), it forks the ps(1) command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63c371b01d835f1b3e60dfea4284b4178cc48a57" translate="yes" xml:space="preserve">
          <source>Because there are people who have their precise expectations about who may install where in the @INC path and who uses which @INC array. In fine tuned environments &lt;code&gt;UNINST=1&lt;/code&gt; can cause damage.</source>
          <target state="translated">Porque hay personas que tienen sus expectativas precisas sobre qui&amp;eacute;n puede instalar d&amp;oacute;nde en la ruta @INC y qui&amp;eacute;n usa qu&amp;eacute; matriz @INC. En entornos bien &lt;code&gt;UNINST=1&lt;/code&gt; , UNINST = 1 puede causar da&amp;ntilde;os.</target>
        </trans-unit>
        <trans-unit id="61339e91fc8e465df58897366d437a1f422fcc97" translate="yes" xml:space="preserve">
          <source>Because there is currently no way for a distribution to specify a dependency on an optional feature of another dependency, the use of &lt;code&gt;optional_feature&lt;/code&gt; is discouraged. Instead, create a separate, installable distribution that ensures the desired feature is available. For example, if &lt;code&gt;Foo::Bar&lt;/code&gt; has a &lt;code&gt;Baz&lt;/code&gt; feature, release a separate &lt;code&gt;Foo-Bar-Baz&lt;/code&gt; distribution that satisfies requirements for the feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b691163394a932e3f6d352ebd6e7cd633110d322" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt; , the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="translated">Debido a que estos objetos de recursos se consideran propiedad de todo el proceso / sistema, y ​​no la &quot;propiedad&quot; de lo que se est&amp;eacute; serializando, no se deben incluir referencias debajo del objeto en la cadena serializada. Por lo tanto, en cualquier clase que implemente &lt;code&gt;STORABLE_attach&lt;/code&gt; , el m&amp;eacute;todo &lt;code&gt;STORABLE_freeze&lt;/code&gt; no puede devolver ninguna referencia y &lt;code&gt;Storable&lt;/code&gt; arrojar&amp;aacute; un error si &lt;code&gt;STORABLE_freeze&lt;/code&gt; intenta devolver referencias.</target>
        </trans-unit>
        <trans-unit id="26af08e2f43bfef9b9e40cba2b2ed696b0549e29" translate="yes" xml:space="preserve">
          <source>Because these resource objects are considered to be owned by the entire process/system, and not the &quot;property&quot; of whatever is being serialized, no references underneath the object should be included in the serialized string. Thus, in any class that implements &lt;code&gt;STORABLE_attach&lt;/code&gt;, the &lt;code&gt;STORABLE_freeze&lt;/code&gt; method cannot return any references, and &lt;code&gt;Storable&lt;/code&gt; will throw an error if &lt;code&gt;STORABLE_freeze&lt;/code&gt; tries to return references.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e58a7f2a84e13b9fada5ed77ade53adda8ab6513" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</source>
          <target state="translated">Debido a que este comando es nuevo en algunos sentidos, se emite una advertencia si parece haber ingresado accidentalmente en un bloque. Si eso es lo que quiere hacer, escr&amp;iacute;balo como con &lt;code&gt;;{ ... }&lt;/code&gt; o incluso &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; { ... }&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="74266b6323d7ce62912d6c101e78cdb916449da7" translate="yes" xml:space="preserve">
          <source>Because this command is in some senses new, a warning is issued if you appear to have accidentally entered a block instead. If that's what you mean to do, write it as with &lt;code&gt;;{ ... }&lt;/code&gt; or even &lt;code&gt;do { ... }&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afe0d4d00dfd6cabe863bda5f9354b347e13a163" translate="yes" xml:space="preserve">
          <source>Because this construct compiles under &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt;, unrecognized escapes that generate warnings in normal classes are fatal errors here, as well as all other warnings from these class elements, as well as some practices that don't currently warn outside &lt;code&gt;re 'strict'&lt;/code&gt;. For example you cannot say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e618c1116f848d64cf69ade37db078db462072bd" translate="yes" xml:space="preserve">
          <source>Because this function operates at the byte level, and because of the inherent characteristics of UTF-8 (or UTF-EBCDIC), it will work properly if both the needle and the haystack are strings with the same UTF-8ness, but not if the UTF-8ness differs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="efa88e36be50b169e959caa4254fea74155063be" translate="yes" xml:space="preserve">
          <source>Because this function uses mktemp(), it can suffer from race conditions.</source>
          <target state="translated">Debido a que esta función utiliza mktemp(),puede sufrir condiciones de raza.</target>
        </trans-unit>
        <trans-unit id="2478181856508c1cc91e32c539a156e07c17eb63" translate="yes" xml:space="preserve">
          <source>Because this information is not stored within the perl executable itself it is possible (but unlikely) that the information does not relate to the actual perl binary which is being used to access it.</source>
          <target state="translated">Dado que esta información no está almacenada en el propio ejecutable de perl,es posible (pero improbable)que la información no se relacione con el binario de perl real que se está utilizando para acceder a él.</target>
        </trans-unit>
        <trans-unit id="ad52e097251691a48fd57b8bdbc852cffc9bb5f6" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Currently implemented pragmas are:</source>
          <target state="translated">Debido a que se trata de una interfaz abierta,las pragmas (directivas del compilador)también se implementan de esta manera.Las pragmas actualmente implementadas son:</target>
        </trans-unit>
        <trans-unit id="872c328b526f9b9864d2cfe0b4165fd06ef13624" translate="yes" xml:space="preserve">
          <source>Because this is a wide-open interface, pragmas (compiler directives) are also implemented this way. Some of the currently implemented pragmas are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8055a645160d58d1aa3758824d7f3046e3cd0a9" translate="yes" xml:space="preserve">
          <source>Because this operator produces an assignable result, using assignments without parentheses will get you in trouble. For example, this:</source>
          <target state="translated">Debido a que este operador produce un resultado asignable,el uso de asignaciones sin paréntesis te meterá en problemas.Por ejemplo,esto:</target>
        </trans-unit>
        <trans-unit id="cda353c8b2d143f02b4da6818d79c64f57fb0765" translate="yes" xml:space="preserve">
          <source>Because this promotes action at a distance, this counterintuitive behavior may be fixed in a future release.</source>
          <target state="translated">Debido a que esto promueve la acción a distancia,este comportamiento contrario a la intuición puede ser arreglado en una futura liberación.</target>
        </trans-unit>
        <trans-unit id="ece57b9cb9008cd6f8ed94726d6205b9428981dc" translate="yes" xml:space="preserve">
          <source>Because thread creation and thread joining may occur in different contexts, it may be desirable to state the context explicitly to the thread's entry point function. This may be done by calling &lt;code&gt;-&amp;gt;create()&lt;/code&gt; with a hash reference as the first argument:</source>
          <target state="translated">Debido a que la creaci&amp;oacute;n y la uni&amp;oacute;n de subprocesos pueden ocurrir en contextos diferentes, puede ser deseable establecer el contexto expl&amp;iacute;citamente en la funci&amp;oacute;n de punto de entrada del subproceso. Esto se puede hacer llamando a &lt;code&gt;-&amp;gt;create()&lt;/code&gt; con una referencia hash como primer argumento:</target>
        </trans-unit>
        <trans-unit id="a311abdd84d17ec36b9f35316e74bcbefa1ccdb8" translate="yes" xml:space="preserve">
          <source>Because variable references always start with '$', '@', or '%', the &quot;reserved&quot; words aren't in fact reserved with respect to variable names. They</source>
          <target state="translated">Debido a que las referencias a las variables siempre comienzan con &quot;$&quot;,&quot;@&quot; o &quot;%&quot;,las palabras &quot;reservadas&quot; no son de hecho reservadas con respecto a los nombres de las variables.Son</target>
        </trans-unit>
        <trans-unit id="cf7852aa0f7da3fa109ef4464da14b644fe19dd6" translate="yes" xml:space="preserve">
          <source>Because various errors may only be detected by close() (e.g. buffering could allow the &lt;code&gt;print&lt;/code&gt; in this example to return true even when the disk is full), it is dangerous to ignore its result. So when it happens implicitly, perl will signal errors by warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ac64477279b51b2f8ca41484de7b49285b3815c" translate="yes" xml:space="preserve">
          <source>Because we are now concerned with the return value from</source>
          <target state="translated">Porque ahora nos preocupa el valor de retorno de</target>
        </trans-unit>
        <trans-unit id="9befd612f9b4e3c124f9ec128a96394cb71cf6fb" translate="yes" xml:space="preserve">
          <source>Because we are using an SV to call</source>
          <target state="translated">Porque estamos usando un SV para llamar</target>
        </trans-unit>
        <trans-unit id="ded04a0cee8ca9e46b88306d00153b5faa51a410" translate="yes" xml:space="preserve">
          <source>Because we created temporary values (by means of sv_2mortal() calls) we will have to tidy up the Perl stack and dispose of mortal SVs.</source>
          <target state="translated">Debido a que creamos valores temporales (por medio de llamadas sv_2mortal())tendremos que ordenar la pila de Perl y deshacernos de los SVs mortales.</target>
        </trans-unit>
        <trans-unit id="aa34046474e322c81f9b04585e1a1d3d975224ac" translate="yes" xml:space="preserve">
          <source>Because we specified G_DISCARD, it is not necessary to check the value returned from</source>
          <target state="translated">Debido a que especificamos G_DISCARD,no es necesario comprobar el valor devuelto de</target>
        </trans-unit>
        <trans-unit id="941fe97debd1bfb6b702aacc07a44435ca4e56b7" translate="yes" xml:space="preserve">
          <source>Because when &lt;code&gt;autochomp&lt;/code&gt; is disabled, &lt;code&gt;$a[10]&lt;/code&gt; will read back as &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (or whatever the record separator string is.)</source>
          <target state="translated">Porque cuando &lt;code&gt;autochomp&lt;/code&gt; est&amp;aacute; deshabilitado, &lt;code&gt;$a[10]&lt;/code&gt; se leer&amp;aacute; como &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (o cualquiera que sea la cadena de separaci&amp;oacute;n de registros).</target>
        </trans-unit>
        <trans-unit id="b0a17ee4f4c080e1c09fd835e1c924855560fcaf" translate="yes" xml:space="preserve">
          <source>Because you just moved the existing &lt;b&gt;stdout&lt;/b&gt; to somewhere else.</source>
          <target state="translated">Porque acaba de mover la salida &lt;b&gt;est&amp;aacute;ndar&lt;/b&gt; existente a otro lugar.</target>
        </trans-unit>
        <trans-unit id="aa628e92b3c4d485e932ec48525c963ebb2f9c63" translate="yes" xml:space="preserve">
          <source>Because you're using something like this, which truncates the file</source>
          <target state="translated">Porque estás usando algo como esto,que trunca el archivo</target>
        </trans-unit>
        <trans-unit id="230b0b84c4580dce513ede6c977fdc5dbaffa5e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10, setting &lt;code&gt;$*&lt;/code&gt; to a true value globally enabled multi-line matching within a string. This relique from the past lost its special meaning in 5.10. Use of this variable will be a fatal error in Perl 5.30, freeing the variable up for a future special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="973ca6acb768a5dd6330a5eade0b5d4dbc53ee84" translate="yes" xml:space="preserve">
          <source>Before Perl 5.10.0 and 5.8.8, PERL5SHELL was not taint checked when running external commands. It is recommended that you explicitly set (or delete) &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; when running in taint mode under Windows.</source>
          <target state="translated">Antes de Perl 5.10.0 y 5.8.8, PERL5SHELL no se verificaba cuando se ejecutaban comandos externos. Se recomienda que establezca (o elimine) expl&amp;iacute;citamente &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; cuando se ejecuta en modo corrupto en Windows.</target>
        </trans-unit>
        <trans-unit id="ebab29b2af9a7a7c7ceefc18fae2257d84323d02" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;a href=&quot;perlvar#%24%40&quot;&gt;&lt;code&gt;$@&lt;/code&gt;&lt;/a&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some, but not all errors:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36d386f00504590e35abdcaf1bc115cbe7c02503" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the assignment to &lt;code&gt;$@&lt;/code&gt; occurred before restoration of localized variables, which means that for your code to run on older versions, a temporary is required if you want to mask some but not all errors:</source>
          <target state="translated">Antes de Perl 5.14, la asignaci&amp;oacute;n a &lt;code&gt;$@&lt;/code&gt; ocurr&amp;iacute;a antes de la restauraci&amp;oacute;n de las variables localizadas, lo que significa que para que su c&amp;oacute;digo se ejecute en versiones anteriores, se requiere un temporal si desea enmascarar algunos pero no todos los errores:</target>
        </trans-unit>
        <trans-unit id="512488ae279d498c1ee81f682f1f53229da4c6e2" translate="yes" xml:space="preserve">
          <source>Before Perl 5.14, the relation between overloading and tie()ing was broken. Overloading was triggered or not based on the</source>
          <target state="translated">Antes del Perl 5.14,la relación entre la sobrecarga y el amarre se rompió.La sobrecarga se desencadenaba o no en función de la</target>
        </trans-unit>
        <trans-unit id="b34cea36bce317a875588bd1ba293a621fd141d4" translate="yes" xml:space="preserve">
          <source>Before Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; assigned the value of</source>
          <target state="translated">Antes de Perl 5.18, &lt;code&gt;given(EXPR)&lt;/code&gt; asignado el valor de</target>
        </trans-unit>
        <trans-unit id="8ed431b288a3361b742578011935581f2edfcced" translate="yes" xml:space="preserve">
          <source>Before Perl 5.28, the returned values are unreliable for the &lt;code&gt;RADIXCHAR&lt;/code&gt; and &lt;code&gt;THOUSEP&lt;/code&gt; locale constants.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0ba6dd90f594f9b5d19255a91f0ae4487b358318" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;&quot;Typeglobs and Filehandles&quot; in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;&quot;Pass by Reference&quot; in perlsub&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54445efd0dc2c1e8891bd0fe2ff854e28637df1f" translate="yes" xml:space="preserve">
          <source>Before Perl 5.6, you had to use the &lt;code&gt;*FH&lt;/code&gt; or &lt;code&gt;\*FH&lt;/code&gt; notations. These are &quot;typeglobs&quot;--see &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs and Filehandles in perldata&lt;/a&gt; and especially &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference in perlsub&lt;/a&gt; for more information.</source>
          <target state="translated">Antes de Perl 5.6, ten&amp;iacute;a que usar las notaciones &lt;code&gt;*FH&lt;/code&gt; o &lt;code&gt;\*FH&lt;/code&gt; . Estos son &quot;typeglobs&quot; - vea &lt;a href=&quot;perldata#Typeglobs-and-Filehandles&quot;&gt;Typeglobs y Filehandles en perldata&lt;/a&gt; y especialmente &lt;a href=&quot;perlsub#Pass-by-Reference&quot;&gt;Pass by Reference en perlsub&lt;/a&gt; para m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2df4fb0a98f840a2555a3347deeff121cc142591" translate="yes" xml:space="preserve">
          <source>Before Perl 5.8.0, installing Perl code to deal with signals exposed you to danger from two things. First, few system library functions are re-entrant. If the signal interrupts while Perl is executing one function (like malloc(3) or printf(3)), and your signal handler then calls the same function again, you could get unpredictable behavior--often, a core dump. Second, Perl isn't itself re-entrant at the lowest levels. If the signal interrupts Perl while Perl is changing its own internal data structures, similarly unpredictable behavior may result.</source>
          <target state="translated">Antes de Perl 5.8.0,instalar el código Perl para tratar las señales te exponía al peligro de dos cosas.En primer lugar,pocas funciones de la biblioteca del sistema son reingresadas.Si la señal se interrumpe mientras Perl está ejecutando una función (como malloc(3)o printf(3)),y tu manejador de señales vuelve a llamar a la misma función,podrías obtener un comportamiento impredecible,a menudo,un volcado del núcleo.En segundo lugar,Perl no es en sí mismo reentrante en los niveles más bajos.Si la señal interrumpe el Perl mientras éste está cambiando sus propias estructuras internas de datos,puede resultar un comportamiento igualmente impredecible.</target>
        </trans-unit>
        <trans-unit id="870cc998eebf778ddd06bc7ed2f1805b37f31d55" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;
utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="translated">Antes de Perl v5.8.0, el uso de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; se usaba para declarar que las operaciones en el bloque o archivo actual ser&amp;iacute;an compatibles con Unicode. Se encontr&amp;oacute; que este modelo era incorrecto, o al menos torpe: el &quot;Unicodeness&quot; ahora se transporta con los datos, en lugar de estar adjunto a las operaciones. A partir de Perl v5.8.0, solo queda un caso en el que se necesita un &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; expl&amp;iacute;cito de utf8 : si su propio script de Perl est&amp;aacute; codificado en UTF-8, puede usar UTF-8 en los nombres de sus identificadores y en cadenas y expresiones regulares literales, diciendo &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; . Este no es el valor predeterminado porque los scripts con datos heredados de 8 bits se romper&amp;iacute;an. Ver &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4fa99c9f82e7be9fceb5a0c188011fae1cb7cad5" translate="yes" xml:space="preserve">
          <source>Before Perl v5.8.0, the use of &lt;code&gt;use utf8&lt;/code&gt; was used to declare that operations in the current block or file would be Unicode-aware. This model was found to be wrong, or at least clumsy: the &quot;Unicodeness&quot; is now carried with the data, instead of being attached to the operations. Starting with Perl v5.8.0, only one case remains where an explicit &lt;code&gt;use utf8&lt;/code&gt; is needed: if your Perl script itself is encoded in UTF-8, you can use UTF-8 in your identifier names, and in string and regular expression literals, by saying &lt;code&gt;use utf8&lt;/code&gt;. This is not the default because scripts with legacy 8-bit data in them would break. See &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04e04ef0cf482846e31d6720b49ae41928208ea3" translate="yes" xml:space="preserve">
          <source>Before Unicode, most encodings used 8 bits (a single byte) to encode each character. Thus a character was a byte, and a byte was a character, and there could be only 256 or fewer possible characters. &quot;Byte Semantics&quot; in the title of this section refers to this behavior. There was no need to distinguish between &quot;Byte&quot; and &quot;Character&quot;.</source>
          <target state="translated">Antes de Unicode,la mayoría de las codificaciones usaban 8 bits (un solo byte)para codificar cada carácter.Por lo tanto,un carácter era un byte,y un byte era un carácter,y sólo podía haber 256 o menos caracteres posibles.&quot;Semántica de bytes&quot; en el título de esta sección se refiere a este comportamiento.No había necesidad de distinguir entre &quot;Byte&quot; y &quot;Carácter&quot;.</target>
        </trans-unit>
        <trans-unit id="98f333eb7b1048c01de83e53fdf2f8f76121657f" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;a href=&quot;perllocale&quot;&gt;&lt;code&gt;use locale&lt;/code&gt;&lt;/a&gt;). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="290d67ae3ee387c5e4e99c79148af4efc4e204f2" translate="yes" xml:space="preserve">
          <source>Before Unicode, when a character was a byte was a character, Perl knew only about the 128 characters defined by ASCII, code points 0 through 127 (except for under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; ). That left the code points 128 to 255 as unassigned, and available for whatever use a program might want. The only semantics they have is their ordinal numbers, and that they are members of none of the non-negative character classes. None are considered to match &lt;code&gt;\w&lt;/code&gt; for example, but all match &lt;code&gt;\W&lt;/code&gt; .</source>
          <target state="translated">Antes de Unicode, cuando un car&amp;aacute;cter era un byte era un car&amp;aacute;cter, Perl solo conoc&amp;iacute;a los 128 caracteres definidos por ASCII, puntos de c&amp;oacute;digo 0 a 127 (excepto para la &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; en &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; ). Eso dej&amp;oacute; los puntos de c&amp;oacute;digo 128 a 255 sin asignar y disponibles para cualquier uso que un programa pudiera desear. La &amp;uacute;nica sem&amp;aacute;ntica que tienen son sus n&amp;uacute;meros ordinales y que no son miembros de ninguna de las clases de caracteres no negativos. Ninguno se consideran para que coincida con &lt;code&gt;\w&lt;/code&gt; por ejemplo, pero todo el partido &lt;code&gt;\W&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d690a12b540a565baadfa57c599d5a868691200d" translate="yes" xml:space="preserve">
          <source>Before any command has executed or if an unexpected error occurs &lt;code&gt;code()&lt;/code&gt; will return &quot;421&quot; (temporary connection failure) and &lt;code&gt;message()&lt;/code&gt; will return undef.</source>
          <target state="translated">Antes de que se haya ejecutado cualquier comando o si ocurre un error inesperado, el &lt;code&gt;code()&lt;/code&gt; devolver&amp;aacute; &quot;421&quot; (falla de conexi&amp;oacute;n temporal) y el &lt;code&gt;message()&lt;/code&gt; devolver&amp;aacute; undef.</target>
        </trans-unit>
        <trans-unit id="752f8552c1f4e0b002a40cffe2d75752a7a074d6" translate="yes" xml:space="preserve">
          <source>Before anything else, you need a testing plan. This basically declares how many tests your script is going to run to protect against premature failure.</source>
          <target state="translated">Antes que nada,necesitas un plan de pruebas.Esto básicamente declara cuántas pruebas va a ejecutar tu guión para protegerse de un fallo prematuro.</target>
        </trans-unit>
        <trans-unit id="62bd9b6df52b51e065387fd43e36061f890b0944" translate="yes" xml:space="preserve">
          <source>Before calling copy() or move() on a filehandle, the caller should close or flush() the file to avoid writes being lost. Note that this is the case even for move(), because it may actually copy the file, depending on the OS-specific implementation, and the underlying filesystem(s).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4bb0c278106c5fac84e8a238d47e490b85a41fa5" translate="yes" xml:space="preserve">
          <source>Before installing the patches to the IBM C-compiler you need to know the level of patching for the Operating System. IBM's command 'oslevel' will show the base, but is not always complete (in this example oslevel shows 4.3.NULL, whereas the system might run most of 4.3.THREE):</source>
          <target state="translated">Antes de instalar los parches en el compilador C de IBM necesitas saber el nivel de parcheo para el Sistema Operativo.El comando 'oslevel' de IBM mostrará la base,pero no siempre está completo (en este ejemplo oslevel muestra 4.3.NULL,mientras que el sistema podría ejecutar la mayor parte de 4.3.TRES):</target>
        </trans-unit>
        <trans-unit id="b46ac14ab9ac97916ee87fb2735b65fa3bcb3084" translate="yes" xml:space="preserve">
          <source>Before perl5.6, you had to deal with various typeglob idioms which you may see in older code.</source>
          <target state="translated">Antes del perl5.6,tenías que lidiar con varios modismos tipográficos que puedes ver en códigos antiguos.</target>
        </trans-unit>
        <trans-unit id="cb7ffbda991b922f283aad1fac8b7fea6f1f3918" translate="yes" xml:space="preserve">
          <source>Before pushing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="84ceb0c5361b0c57292563baaff9c21803203fbb" translate="yes" xml:space="preserve">
          <source>Before pushing any change to a maint version, make sure you've satisfied the steps in &lt;a href=&quot;#Committing-to-blead&quot;&gt;&quot;Committing to blead&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d24253ab2fd2c805f0d6bcaca41ee8bd8627285" translate="yes" xml:space="preserve">
          <source>Before release 5 of Perl it was difficult to represent complex data structures, because all references had to be symbolic--and even then it was difficult to refer to a variable instead of a symbol table entry. Perl now not only makes it easier to use symbolic references to variables, but also lets you have &quot;hard&quot; references to any piece of data or code. Any scalar may hold a hard reference. Because arrays and hashes contain scalars, you can now easily build arrays of arrays, arrays of hashes, hashes of arrays, arrays of hashes of functions, and so on.</source>
          <target state="translated">Antes de la versión 5 de Perl era difícil representar estructuras de datos complejas,porque todas las referencias tenían que ser simbólicas...e incluso entonces era difícil referirse a una variable en lugar de una entrada de tabla de símbolos.Ahora Perl no sólo facilita el uso de referencias simbólicas a las variables,sino que también permite tener referencias &quot;duras&quot; a cualquier dato o código.Cualquier escalar puede contener una referencia dura.Debido a que las matrices y hashes contienen escalares,ahora se pueden construir fácilmente matrices de matrices,matrices de hashes,hashes de matrices,matrices de hashes de funciones,y así sucesivamente.</target>
        </trans-unit>
        <trans-unit id="ef266fb9e8f6dafd9b23077a1b88d8327a3a9667" translate="yes" xml:space="preserve">
          <source>Before submitting a bug, please make sure that the traditional method of building a Perl module package from a shell by following the installation instructions of that package still works in your environment.</source>
          <target state="translated">Antes de enviar un error,por favor asegúrese de que el método tradicional de construir un paquete de módulos Perl desde un shell siguiendo las instrucciones de instalación de ese paquete aún funciona en su entorno.</target>
        </trans-unit>
        <trans-unit id="852a62fb5185caad446c6f66da79350d77dac37e" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt; .</source>
          <target state="translated">Antes de terminar, la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n debe instalar expl&amp;iacute;citamente el filtro llamando a &lt;code&gt;filter_add&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c19a9bcc3d0fce58bd4d9d25f82f4cb8c5d35503" translate="yes" xml:space="preserve">
          <source>Before terminating, the &lt;code&gt;import&lt;/code&gt; function must explicitly install the filter by calling &lt;code&gt;filter_add&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f512253f81c2fd706ba28a9ad84dc13dc48c3eb8" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="translated">Antes de que el int&amp;eacute;rprete de Perl pueda ejecutar un script de Perl, primero debe leerlo de un archivo a la memoria para analizarlo y compilarlo. Si ese script en s&amp;iacute; incluye otros scripts con una instrucci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , entonces cada uno de esos scripts deber&amp;aacute; leerse tambi&amp;eacute;n de sus respectivos archivos.</target>
        </trans-unit>
        <trans-unit id="c6081a0bc2c6ca5d40e9bce0501b5e221be236ae" translate="yes" xml:space="preserve">
          <source>Before the Perl interpreter can execute a Perl script, it must first read it from a file into memory for parsing and compilation. If that script itself includes other scripts with a &lt;code&gt;use&lt;/code&gt; or &lt;code&gt;require&lt;/code&gt; statement, then each of those scripts will have to be read from their respective files as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7056378ac690eaab80565ece696557496384c5bd" translate="yes" xml:space="preserve">
          <source>Before the introduction of Unicode support in Perl, The &lt;code&gt;eq&lt;/code&gt; operator just compared the strings represented by two scalars. Beginning with Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compares two strings with simultaneous consideration of</source>
          <target state="translated">Antes de la introducci&amp;oacute;n del soporte Unicode en Perl, el operador &lt;code&gt;eq&lt;/code&gt; simplemente comparaba las cadenas representadas por dos escalares. A partir de Perl 5.8, &lt;code&gt;eq&lt;/code&gt; compara dos cadenas con la consideraci&amp;oacute;n simult&amp;aacute;nea de</target>
        </trans-unit>
        <trans-unit id="07d7d02c48129829b963f0f9c3efb3625c646877" translate="yes" xml:space="preserve">
          <source>Before the introduction of lexical warnings, Perl had two classes of warnings: mandatory and optional.</source>
          <target state="translated">Antes de la introducción de las advertencias léxicas,Perl tenía dos clases de advertencias:obligatorias y opcionales.</target>
        </trans-unit>
        <trans-unit id="759cf8f89c69b1e5d0ddf3e544f843b8c5c70ae3" translate="yes" xml:space="preserve">
          <source>Before we even start scraping out the code, there are a few things we'll want to do in advance.</source>
          <target state="translated">Antes de que empecemos a raspar el código,hay algunas cosas que queremos hacer por adelantado.</target>
        </trans-unit>
        <trans-unit id="a2896a2a84e6fb1618d5a02150eb4f976c910264" translate="yes" xml:space="preserve">
          <source>Before we go any further, you'll want to know how to quit the debugger: use just the letter '&lt;b&gt;q&lt;/b&gt;', not the words 'quit' or 'exit':</source>
          <target state="translated">Antes de continuar, querr&amp;aacute; saber c&amp;oacute;mo salir del depurador: use solo la letra ' &lt;b&gt;q&lt;/b&gt; ', no las palabras 'salir' o 'salir':</target>
        </trans-unit>
        <trans-unit id="10af6d27d8d05a680d682b1087a82d6e520c2fff" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;&quot;CAVEATS&quot;&lt;/a&gt; section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a4b62fae1d0e77e031397754824b30119b2b62a" translate="yes" xml:space="preserve">
          <source>Before writing XS, read the &lt;a href=&quot;#CAVEATS&quot;&gt;CAVEATS&lt;/a&gt; section below.</source>
          <target state="translated">Antes de escribir XS, lea la secci&amp;oacute;n &lt;a href=&quot;#CAVEATS&quot;&gt;AVISOS a&lt;/a&gt; continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1b5bba6a088484e3f244c7ed2d3c63206cbf13d5" translate="yes" xml:space="preserve">
          <source>Before you consider posting a bug report, please consult, and possibly post a message to the discussion forum to see if what you've encountered is a known problem.</source>
          <target state="translated">Antes de considerar la posibilidad de publicar un informe de fallo,por favor consulte,y posiblemente publique un mensaje en el foro de discusión para ver si lo que ha encontrado es un problema conocido.</target>
        </trans-unit>
        <trans-unit id="528e582d94b55449ac3523f64dd0d0e5c7486531" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt; ), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="translated">Antes de continuar, observe el orden de clasificaci&amp;oacute;n de las variables. En general, primero enumeramos las variables en orden casi lexigr&amp;aacute;fico que no distingue entre may&amp;uacute;sculas y min&amp;uacute;sculas (ignorando las palabras &lt;code&gt;{&lt;/code&gt; o &lt;code&gt;^&lt;/code&gt; precedentes, como en &lt;code&gt;${^UNICODE}&lt;/code&gt; o &lt;code&gt;$^T&lt;/code&gt; ), aunque &lt;code&gt;$_&lt;/code&gt; y &lt;code&gt;@_&lt;/code&gt; se mueven hacia arriba de la pila. Para las variables con el mismo identificador, las enumeramos en orden escalar, matriz, hash y palabra sin formato.</target>
        </trans-unit>
        <trans-unit id="e90a6f007e6fb64dd92c6079f36a3d06c252dda3" translate="yes" xml:space="preserve">
          <source>Before you continue, note the sort order for variables. In general, we first list the variables in case-insensitive, almost-lexigraphical order (ignoring the &lt;code&gt;{&lt;/code&gt; or &lt;code&gt;^&lt;/code&gt; preceding words, as in &lt;code&gt;${^UNICODE}&lt;/code&gt; or &lt;code&gt;$^T&lt;/code&gt;), although &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; move up to the top of the pile. For variables with the same identifier, we list it in order of scalar, array, hash, and bareword.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29b11945139a380af16d5d49212f0306507606fb" translate="yes" xml:space="preserve">
          <source>Before you decide to merge two hashes, you have to decide what to do if both hashes contain keys that are the same and if you want to leave the original hashes as they were.</source>
          <target state="translated">Antes de decidir fusionar dos hashes,hay que decidir qué hacer si ambos hashes contienen claves que son iguales y si se quiere dejar los hashes originales como estaban.</target>
        </trans-unit>
        <trans-unit id="7b25edaa05329b202d8bbb719df130a305f9a0e7" translate="yes" xml:space="preserve">
          <source>Before you do anything else, you can help yourself by ensuring that you let Perl tell you about problem areas in your code. By turning on warnings and strictures, you can head off many problems before they get too big. You can find out more about these in &lt;a href=&quot;strict&quot;&gt;strict&lt;/a&gt; and &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;.</source>
          <target state="translated">Antes de hacer cualquier otra cosa, puede ayudarse a s&amp;iacute; mismo asegur&amp;aacute;ndose de dejar que Perl le informe sobre las &amp;aacute;reas problem&amp;aacute;ticas en su c&amp;oacute;digo. Al activar las advertencias y restricciones, puede evitar muchos problemas antes de que sean demasiado grandes. Puede encontrar m&amp;aacute;s informaci&amp;oacute;n sobre estos en &lt;a href=&quot;strict&quot;&gt;estricta&lt;/a&gt; y &lt;a href=&quot;warnings&quot;&gt;advertencias&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="054a146795bb49c5d92e2d968e739a1f63c7604c" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt; , which returns the canonical name thereof. For example:</source>
          <target state="translated">Antes de hacer eso, primero aseg&amp;uacute;rese de que el alias no &lt;code&gt;resolve_alias()&lt;/code&gt; usando resolve_alias () , que devuelve el nombre can&amp;oacute;nico del mismo. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="9fa55498f41c7cd4663e8d59ae7b91ebb05c3bad" translate="yes" xml:space="preserve">
          <source>Before you do that, first make sure the alias is nonexistent using &lt;code&gt;resolve_alias()&lt;/code&gt;, which returns the canonical name thereof. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea4eb9d8b93fbec8607b4df5d4d1083567318fe5" translate="yes" xml:space="preserve">
          <source>Before you launch yourself head first into the rest of this document, it would be a good idea to have read the following two documents--&lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt;.</source>
          <target state="translated">Antes de lanzarse de cabeza al resto de este documento, ser&amp;iacute;a una buena idea haber le&amp;iacute;do los dos documentos siguientes: &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; y &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="dde9d3bcf2359cbba92e26ac6718964bcaacd3c3" translate="yes" xml:space="preserve">
          <source>Before you panic, know that many people do use &lt;code&gt;Moose&lt;/code&gt; for command-line tools and other startup-sensitive code. We encourage you to try &lt;code&gt;Moose&lt;/code&gt; out first before worrying about startup speed.</source>
          <target state="translated">Antes de que entre en p&amp;aacute;nico, sepa que muchas personas usan &lt;code&gt;Moose&lt;/code&gt; para herramientas de l&amp;iacute;nea de comandos y otro c&amp;oacute;digo sensible al inicio. Le recomendamos que pruebe &lt;code&gt;Moose&lt;/code&gt; primero antes de preocuparse por la velocidad de inicio.</target>
        </trans-unit>
        <trans-unit id="2c445dd5994fd48a7f879efa85cd15aa5394f95f" translate="yes" xml:space="preserve">
          <source>Before you start</source>
          <target state="translated">Antes de empezar</target>
        </trans-unit>
        <trans-unit id="fa35a8236ca3aecdca56f64d9f3832c8bf9e0996" translate="yes" xml:space="preserve">
          <source>Before you start, it's important to know a few things:</source>
          <target state="translated">Antes de empezar,es importante saber algunas cosas:</target>
        </trans-unit>
        <trans-unit id="85435e88ea012cea6ee5f0e38fd4d12329633e18" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory to which the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">Antes de empezar,deberías echar un vistazo al archivo README que se encuentra en el directorio de nivel superior al que se extrajo la distribución Perl.Asegúrese de leer y entender los términos bajo los cuales este software está siendo distribuido.</target>
        </trans-unit>
        <trans-unit id="82f236c12f0a7b2bfa05bcc6c77fce0d5554f74c" translate="yes" xml:space="preserve">
          <source>Before you start, you should glance through the README file found in the top-level directory where the Perl distribution was extracted. Make sure you read and understand the terms under which this software is being distributed.</source>
          <target state="translated">Antes de empezar,deberías echar un vistazo al archivo README que se encuentra en el directorio de nivel superior donde se extrajo la distribución Perl.Asegúrese de leer y comprender los términos bajo los cuales se distribuye este software.</target>
        </trans-unit>
        <trans-unit id="e6dc5aa054869bdc5776548930fba90056a049b5" translate="yes" xml:space="preserve">
          <source>Begin the retrieval of a file called &lt;code&gt;FILE&lt;/code&gt; from the remote server.</source>
          <target state="translated">Inicie la recuperaci&amp;oacute;n de un archivo llamado &lt;code&gt;FILE&lt;/code&gt; desde el servidor remoto.</target>
        </trans-unit>
        <trans-unit id="d1bae729fa6ba19a84ae13329bfa79bbfaf77e9b" translate="yes" xml:space="preserve">
          <source>Beginner note: In example 2, above &lt;code&gt;$columns&lt;/code&gt; is imported into the local namespace, and set locally. In example 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; is set in its own namespace without importing it.</source>
          <target state="translated">Nota para principiantes: en el ejemplo 2, las &lt;code&gt;$columns&lt;/code&gt; anteriores se importan al espacio de nombres local y se configuran localmente. En el ejemplo 3, &lt;code&gt;$Text::Wrap::columns&lt;/code&gt; se configura en su propio espacio de nombres sin importarlo.</target>
        </trans-unit>
        <trans-unit id="8c50d29cf088569a469311ef83bf39d51d30a011" translate="yes" xml:space="preserve">
          <source>Beginners often think they want to have a variable contain the name of a variable.</source>
          <target state="translated">Los principiantes a menudo piensan que quieren que una variable contenga el nombre de una variable.</target>
        </trans-unit>
        <trans-unit id="ddd5e0ea97f5ceda3171fdb3abe535bc421229c3" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt; &quot;, as a placeholder for code that you haven't implemented yet. This form of ellipsis, the unimplemented statement, should not be confused with the binary flip-flop &lt;code&gt;...&lt;/code&gt; operator. One is a statement and the other an operator. (Perl doesn't usually confuse them because usually Perl can tell whether it wants an operator or a statement, but see below for exceptions.)</source>
          <target state="translated">A partir de Perl 5.12, Perl acepta puntos suspensivos, &quot; &lt;code&gt;...&lt;/code&gt; &quot;, como marcador de posici&amp;oacute;n para el c&amp;oacute;digo que a&amp;uacute;n no ha implementado. Esta forma de elipsis, la declaraci&amp;oacute;n no implementada, no debe confundirse con el operador binario flip-flop &lt;code&gt;...&lt;/code&gt; Uno es una declaraci&amp;oacute;n y el otro un operador. (Perl generalmente no los confunde porque generalmente Perl puede decir si quiere un operador o una declaraci&amp;oacute;n, pero vea las excepciones a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="dc88deeacfc5c23c60a84d0e355d8d08bad0853c" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.12, Perl accepts an ellipsis, &quot;&lt;code&gt;...&lt;/code&gt;&quot;, as a placeholder for code that you haven't implemented yet. When Perl 5.12 or later encounters an ellipsis statement, it parses this without error, but if and when you should actually try to execute it, Perl throws an exception with the text &lt;code&gt;Unimplemented&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90c724bcc9cdece1aeab2aab45c2518eb7791435" translate="yes" xml:space="preserve">
          <source>Beginning in Perl 5.28, multi-threaded locale operation is supported on systems that implement either the POSIX 2008 or Windows-specific thread-safe locale operations. Many modern systems, such as various Unix variants and Darwin do have this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a346d69c5ac7465ea021c968ddc77fd7f137feb" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;&quot;Using References&quot;&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82d48c3b20d2f80bac7595523990a9132ad0e311" translate="yes" xml:space="preserve">
          <source>Beginning in v5.20.0, a postfix syntax for using references is available. It behaves as described in &lt;a href=&quot;#Using-References&quot;&gt;Using References&lt;/a&gt;, but instead of a prefixed sigil, a postfixed sigil-and-star is used.</source>
          <target state="translated">A partir de la v5.20.0, est&amp;aacute; disponible una sintaxis de sufijo para usar referencias. Se comporta como se describe en &lt;a href=&quot;#Using-References&quot;&gt;Uso de referencias&lt;/a&gt; , pero en lugar de un sigilo prefijado, se usa un sigilo y una estrella posfijos.</target>
        </trans-unit>
        <trans-unit id="e4fd9d1748abdc28d0efb1f242a157236c1c9529" translate="yes" xml:space="preserve">
          <source>Beginning in v5.22.0, the referencing operator can be assigned to. It performs an aliasing operation, so that the variable name referenced on the left-hand side becomes an alias for the thing referenced on the right-hand side:</source>
          <target state="translated">A partir de la v5.22.0,se puede asignar el operador de referencia.Realiza una operación de alias,de modo que el nombre de la variable referenciada en el lado izquierdo se convierte en un alias para la cosa referenciada en el lado derecho:</target>
        </trans-unit>
        <trans-unit id="ffa0956923ab92c4c7492c5469e046b41154fb80" translate="yes" xml:space="preserve">
          <source>Beginning in v5.26.0, the referencing operator can come after &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, &lt;code&gt;our&lt;/code&gt;, or &lt;code&gt;local&lt;/code&gt;. This syntax must be enabled with &lt;code&gt;use feature 'declared_refs'&lt;/code&gt;. It is experimental, and will warn by default unless &lt;code&gt;no warnings 'experimental::refaliasing'&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54f7bcfa82e1deb0e3342e8510b04a376681f2a5" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX 11.00, programs compiled under HP-UX can take advantage of the LP64 programming environment (LP64 means Longs and Pointers are 64 bits wide), in which scalar variables will be able to hold numbers larger than 2^32 with complete precision. Perl has proven to be consistent and reliable in 64bit mode since 5.8.1 on all HP-UX 11.xx.</source>
          <target state="translated">A partir de HP-UX 11.00,los programas compilados bajo HP-UX pueden aprovechar el entorno de programación LP64 (LP64 significa Longs y Pointers son de 64 bits de ancho),en el que las variables escalares serán capaces de contener números mayores de 2^32 con total precisión.Perl ha demostrado ser consistente y confiable en el modo de 64 bits desde 5.8.1 en todos los HP-UX 11.xx.</target>
        </trans-unit>
        <trans-unit id="7f252bceac885ebc51d1278ef820d426befd060f" translate="yes" xml:space="preserve">
          <source>Beginning with HP-UX version 10.20, files larger than 2GB (2^31 bytes) may be created and manipulated. Three separate methods of doing this are available. Of these methods, the best method for Perl is to compile using the -Duselargefiles flag to Configure. This causes Perl to be compiled using structures and functions in which these are 64 bits wide, rather than 32 bits wide. (Note that this will only work with HP's ANSI C compiler. If you want to compile Perl using gcc, you will have to get a version of the compiler that supports 64-bit operations. See above for where to find it.)</source>
          <target state="translated">A partir de la versión 10.20 de HP-UX,se pueden crear y manipular archivos de más de 2 GB (2^31 bytes).Existen tres métodos distintos para hacerlo.De estos métodos,el mejor para Perl es compilar usando la bandera -Duselargefiles para Configurar.Esto hace que Perl sea compilado usando estructuras y funciones en las que éstas tienen un ancho de 64 bits,en lugar de 32 bits.(Tengan en cuenta que esto sólo funcionará con el compilador ANSI C de HP.Si desea compilar Perl usando gcc,tendrá que obtener una versión del compilador que soporte operaciones de 64 bits.Ver arriba para saber dónde encontrarlo).</target>
        </trans-unit>
        <trans-unit id="7b1997a711dcb385772e62932a24b63be2ca5162" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword in place of &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="translated">A partir de Perl 5.10.0, puede declarar variables con la palabra clave &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; en lugar de &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; . Sin embargo, para que eso funcione, debe haber habilitado esa caracter&amp;iacute;stica de antemano, ya sea usando el pragma de &lt;code&gt;feature&lt;/code&gt; o usando &lt;code&gt;-E&lt;/code&gt; en una sola l&amp;iacute;nea (ver &lt;a href=&quot;feature&quot;&gt;caracter&amp;iacute;stica&lt;/a&gt; ). A partir de Perl 5.16, el formulario &lt;code&gt;CORE::state&lt;/code&gt; no requiere la &lt;code&gt;feature&lt;/code&gt; pragma.</target>
        </trans-unit>
        <trans-unit id="043ad372200ab11184230c8b464cbbec604d0f73" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.10.0, you can declare variables with the &lt;code&gt;state&lt;/code&gt; keyword in place of &lt;code&gt;my&lt;/code&gt;. For that to work, though, you must have enabled that feature beforehand, either by using the &lt;code&gt;feature&lt;/code&gt; pragma, or by using &lt;code&gt;-E&lt;/code&gt; on one-liners (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;). Beginning with Perl 5.16, the &lt;code&gt;CORE::state&lt;/code&gt; form does not require the &lt;code&gt;feature&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd848af5e7c989b28a26cc1aec55564025fc4af9" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;. As with state variables, the &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword is only available under &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; or higher.</source>
          <target state="translated">A partir de Perl 5.18, puede declarar una subrutina privada con &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; . Al igual que con las variables de estado, la palabra clave de &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; solo est&amp;aacute; disponible en la &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'state'&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; 'estado' o &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; 5.010&lt;/code&gt; o superior.</target>
        </trans-unit>
        <trans-unit id="4f40c1f7eb582d4b15076061b6d0a8e085b355dc" translate="yes" xml:space="preserve">
          <source>Beginning with Perl 5.18, you can declare a private subroutine with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt;. As with state variables, the &lt;code&gt;state&lt;/code&gt; keyword is only available under &lt;code&gt;use feature 'state'&lt;/code&gt; or &lt;code&gt;use 5.010&lt;/code&gt; or higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb06f268b9e85c6ee8127ae9f07256660624d8e4" translate="yes" xml:space="preserve">
          <source>Beginning with Perl version 5.26, a much simpler and cleaner way to write indented here documents has been added to the language: the tilde (~) modifier. See &lt;a href=&quot;perlop#Indented-Here-docs&quot;&gt;&quot;Indented Here-docs&quot; in perlop&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2eca9f03e4044bf99d10838840f25a5c4ae464b9" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="translated">A partir de perl 5.10.0, tambi&amp;eacute;n puede usar variables de &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; para tener l&amp;eacute;xicos que se inicializan solo una vez (ver &lt;a href=&quot;feature&quot;&gt;caracter&amp;iacute;stica&lt;/a&gt; ):</target>
        </trans-unit>
        <trans-unit id="62b599a702a0e45efa83ae9abd2c72ac9e40e2f7" translate="yes" xml:space="preserve">
          <source>Beginning with perl 5.10.0, you can also use &lt;code&gt;state&lt;/code&gt; variables to have lexicals that are initialized only once (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d269396692530a4c995cb59a2555fae5ff4dd172" translate="yes" xml:space="preserve">
          <source>Beginning with version 5.004, the following functions are also supported:</source>
          <target state="translated">A partir de la versión 5.004,también se soportan las siguientes funciones:</target>
        </trans-unit>
        <trans-unit id="5a1a2270a454451ac22b568bca58999ca2a57b3c" translate="yes" xml:space="preserve">
          <source>Beginning/End of line positions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2dfcf5f267b41370cad897910ad80d037ac22ab" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;#newCONSTSUB_flags&quot;&gt;&quot;newCONSTSUB_flags&quot;&lt;/a&gt;, except that &lt;code&gt;name&lt;/code&gt; is nul-terminated rather than of counted length, and no flags are set. (This means that &lt;code&gt;name&lt;/code&gt; is always interpreted as Latin-1.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b6fd5b0516beaff8d8429855f694694659eb195" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;a href=&quot;http://man.he.net/man2/wait&quot;&gt;wait(2)&lt;/a&gt; on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;perlvar#%24%7B%5ECHILD_ERROR_NATIVE%7D&quot;&gt;&lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt;&lt;/a&gt;. Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fb78858d773149c7141146370197d2f530d8902f" translate="yes" xml:space="preserve">
          <source>Behaves like &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34133685a790f2f2b5caab0cdf19417a300c4bef" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">Se comporta como wait (2) en su sistema: espera a que termine un proceso hijo y devuelve el pid del proceso fallecido, o &lt;code&gt;-1&lt;/code&gt; si no hay procesos hijo. El estado se devuelve en &lt;code&gt;$?&lt;/code&gt; y &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Tenga en cuenta que un valor de retorno de &lt;code&gt;-1&lt;/code&gt; podr&amp;iacute;a significar que los procesos secundarios se cosechan autom&amp;aacute;ticamente, como se describe en &lt;a href=&quot;../perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f0c5491ce914759629c95815e914e921b25062e" translate="yes" xml:space="preserve">
          <source>Behaves like wait(2) on your system: it waits for a child process to terminate and returns the pid of the deceased process, or &lt;code&gt;-1&lt;/code&gt; if there are no child processes. The status is returned in &lt;code&gt;$?&lt;/code&gt; and &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Note that a return value of &lt;code&gt;-1&lt;/code&gt; could mean that child processes are being automatically reaped, as described in &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt;.</source>
          <target state="translated">Se comporta como wait (2) en su sistema: espera a que termine un proceso hijo y devuelve el pid del proceso fallecido, o &lt;code&gt;-1&lt;/code&gt; si no hay procesos hijo. El estado se devuelve en &lt;code&gt;$?&lt;/code&gt; y &lt;code&gt;${^CHILD_ERROR_NATIVE}&lt;/code&gt; . Tenga en cuenta que un valor de retorno de &lt;code&gt;-1&lt;/code&gt; podr&amp;iacute;a significar que los procesos secundarios se cosechan autom&amp;aacute;ticamente, como se describe en &lt;a href=&quot;perlipc&quot;&gt;perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="756aaec531bd197c8baf40355b6e7560606340ee" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;&quot;croak&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be599b479dc1a9d62fd33cd4b25ae6147cf1069" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">Se comporta igual que &lt;a href=&quot;#croak&quot;&gt;croak&lt;/a&gt; , excepto por el tipo de retorno. Debe usarse solo donde se requiera el tipo de retorno &lt;code&gt;OP *&lt;/code&gt; . La funci&amp;oacute;n nunca regresa realmente.</target>
        </trans-unit>
        <trans-unit id="e3b8ea26eb4d496c3c9598880a77b0e504f2a647" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;&quot;croak_sv&quot;&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c49c08082a231774a342ac5391eebbc26cb4596" translate="yes" xml:space="preserve">
          <source>Behaves the same as &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt;, except for the return type. It should be used only where the &lt;code&gt;OP *&lt;/code&gt; return type is required. The function never actually returns.</source>
          <target state="translated">Se comporta igual que &lt;a href=&quot;#croak_sv&quot;&gt;croak_sv&lt;/a&gt; , excepto por el tipo de retorno. Debe usarse solo donde se requiera el tipo de retorno &lt;code&gt;OP *&lt;/code&gt; . La funci&amp;oacute;n nunca regresa realmente.</target>
        </trans-unit>
        <trans-unit id="fbf9c5863d4bbe3bd2490f1ad8ab93b461cdea43" translate="yes" xml:space="preserve">
          <source>Behavior of other Perl features in forked pseudo-processes</source>
          <target state="translated">El comportamiento de otras características de Perl en pseudo-procesos bifurcados</target>
        </trans-unit>
        <trans-unit id="546fd299e317f0cfab072f158d53c6046d080ef9" translate="yes" xml:space="preserve">
          <source>Behavior of this function varies wildly depending on your system implementation. For example, it will usually not work across file system boundaries, even though the system</source>
          <target state="translated">El comportamiento de esta función varía mucho dependiendo de la implementación de su sistema.Por ejemplo,normalmente no funcionará a través de los límites del sistema de archivos,aunque el sistema</target>
        </trans-unit>
        <trans-unit id="6296c0acaf0c68b8a708c260d5e620e45c188c21" translate="yes" xml:space="preserve">
          <source>Behaviour since version 2.11</source>
          <target state="translated">Comportamiento desde la versión 2.11</target>
        </trans-unit>
        <trans-unit id="fc99a03494d30ac32472278376507c26adfb39ce" translate="yes" xml:space="preserve">
          <source>Behind The Scenes</source>
          <target state="translated">Entre bastidores</target>
        </trans-unit>
        <trans-unit id="8e234f329fb33ee94403565f619b16d72bc67919" translate="yes" xml:space="preserve">
          <source>Behind the scenes the &lt;code&gt;globmap&lt;/code&gt; function does a combination of a file glob to match existing filenames followed by a substitute to create the new filenames.</source>
          <target state="translated">Detr&amp;aacute;s de escena, la funci&amp;oacute;n de &lt;code&gt;globmap&lt;/code&gt; hace una combinaci&amp;oacute;n de un archivo global para que coincida con los nombres de archivo existentes seguido de un sustituto para crear los nuevos nombres de archivo.</target>
        </trans-unit>
        <trans-unit id="4f88b0aecf2344cf177fb22c2c1e4809d60f491d" translate="yes" xml:space="preserve">
          <source>Being Perl-specific, this function has evolved along time. It can currently be called as follow:</source>
          <target state="translated">Siendo específica de Perl,esta función ha evolucionado a lo largo del tiempo.Actualmente se puede llamar así:</target>
        </trans-unit>
        <trans-unit id="0fc303a764ff6b60a94ad6969ea173a3382e1620" translate="yes" xml:space="preserve">
          <source>Being a mechanical process pl2pm is not bullet proof. The converted code will need careful checking, especially any package statements. Don't delete the original .pl file till the new .pm one works!</source>
          <target state="translated">Ser un proceso mecánico pl2pm no es a prueba de balas.El código convertido necesitará una revisión cuidadosa,especialmente cualquier declaración de paquete.¡No borre el archivo .pl original hasta que el nuevo .pm funcione!</target>
        </trans-unit>
        <trans-unit id="7f0407ad618a0bd51d559ec6185eae8ed67ffedb" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using &lt;a href=&quot;#flock-FILEHANDLE%2COPERATION&quot;&gt;&lt;code&gt;flock&lt;/code&gt;&lt;/a&gt;. If you do just &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;&quot;, $B)&lt;/code&gt;, the filehandle &lt;code&gt;$A&lt;/code&gt; will not have the same file descriptor as &lt;code&gt;$B&lt;/code&gt;, and therefore &lt;code&gt;flock($A)&lt;/code&gt; will not &lt;code&gt;flock($B)&lt;/code&gt; nor vice versa. But with &lt;code&gt;open(my $A, &quot;&amp;gt;&amp;gt;&amp;amp;=&quot;, $B)&lt;/code&gt;, the filehandles will share the same underlying system file descriptor.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e98f301c8128b87a5492d5177997df433005bc22" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">Ser parsimonioso en los identificadores de archivos tambi&amp;eacute;n es &amp;uacute;til (adem&amp;aacute;s de ser parsimonioso), por ejemplo, cuando algo depende de los descriptores de archivos, como por ejemplo, bloquear con flock (). Si simplemente &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , el identificador de archivo A no tendr&amp;aacute; el mismo descriptor de archivo que B, y por lo tanto flock (A) no flock (B) ni viceversa. Pero con &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , los identificadores de archivo compartir&amp;aacute;n el mismo descriptor de archivo del sistema subyacente.</target>
        </trans-unit>
        <trans-unit id="eb7d6ff0d012000fe6eccb3c989a4ceae1efb833" translate="yes" xml:space="preserve">
          <source>Being parsimonious on filehandles is also useful (besides being parsimonious) for example when something is dependent on file descriptors, like for example locking using flock(). If you do just &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , the filehandle A will not have the same file descriptor as B, and therefore flock(A) will not flock(B) nor vice versa. But with &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , the filehandles will share the same underlying system file descriptor.</source>
          <target state="translated">Ser parsimonioso en los identificadores de archivos tambi&amp;eacute;n es &amp;uacute;til (adem&amp;aacute;s de ser parsimonioso), por ejemplo, cuando algo depende de los descriptores de archivos, como por ejemplo, bloquear con flock (). Si simplemente &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;B&quot;)&lt;/code&gt; , el identificador de archivo A no tendr&amp;aacute; el mismo descriptor de archivo que B, y por lo tanto flock (A) no flock (B) ni viceversa. Pero con &lt;code&gt;&lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;(A, &quot;&amp;gt;&amp;gt;&amp;amp;=B&quot;)&lt;/code&gt; , los identificadores de archivo compartir&amp;aacute;n el mismo descriptor de archivo del sistema subyacente.</target>
        </trans-unit>
        <trans-unit id="027a12c2fc8568e8b70b07ff536faf288a013670" translate="yes" xml:space="preserve">
          <source>Belarus</source>
          <target state="translated">Belarus</target>
        </trans-unit>
        <trans-unit id="5cb4c9d828175ed3931ec52305b32f47173a8e04" translate="yes" xml:space="preserve">
          <source>Belgium</source>
          <target state="translated">Belgium</target>
        </trans-unit>
        <trans-unit id="1b8a9f965c18d647b7a7bff03b9e0c4a68361224" translate="yes" xml:space="preserve">
          <source>Bell sounds when word completion fails.</source>
          <target state="translated">La campana suena cuando falla la terminación de la palabra.</target>
        </trans-unit>
        <trans-unit id="74d2e1c77a10412bd2a923bb84c1c65e97a50e55" translate="yes" xml:space="preserve">
          <source>Below are a few examples of globmaps</source>
          <target state="translated">A continuación se presentan algunos ejemplos de globmaps</target>
        </trans-unit>
        <trans-unit id="8b537b36a224ab3855e5388cf5af4a7324861d08" translate="yes" xml:space="preserve">
          <source>Below comes a verbose discussion of these flags. Note that a &quot;codeset&quot; is simply an abstract set of character-codepoint pairs, while an encoding takes those codepoint numbers and</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6238547f660d516d0fdf40f8de1337807f2955e" translate="yes" xml:space="preserve">
          <source>Below is a</source>
          <target state="translated">A continuación se muestra un</target>
        </trans-unit>
        <trans-unit id="eab1a70d36b9d2b495b3781776947aeb4b2fc004" translate="yes" xml:space="preserve">
          <source>Below is a list of a few frameworks with comments which might help you in making a decision, depending on your specific requirements. Start by reading the docs, then ask questions on the relevant mailing list or IRC channel.</source>
          <target state="translated">A continuación figura una lista de algunos marcos con comentarios que podrían ayudarle a tomar una decisión,en función de sus necesidades específicas.Comience leyendo los documentos,luego haga preguntas en la lista de correo correspondiente o en el canal IRC.</target>
        </trans-unit>
        <trans-unit id="1f47cec9db1010fb960d67042b7e30d1824cca4b" translate="yes" xml:space="preserve">
          <source>Below is a list of the files in the Unicode data base that Perl doesn't currently use, along with very brief descriptions of their purposes. Some of the names of the files have been shortened from those that Unicode uses, in order to allow them to be distinguishable from similarly named files on file systems for which only the first 8 characters of a name are significant.</source>
          <target state="translated">A continuación se presenta una lista de los archivos de la base de datos Unicode que Perl no utiliza actualmente,junto con descripciones muy breves de sus propósitos.Algunos de los nombres de los archivos han sido acortados de los que utiliza Unicode,a fin de permitir que se distingan de los archivos con nombres similares en los sistemas de archivos para los que sólo los primeros 8 caracteres de un nombre son significativos.</target>
        </trans-unit>
        <trans-unit id="80905719173a37bfcc2cab267e8366cac44b82fa" translate="yes" xml:space="preserve">
          <source>Below is a list of the methods available.</source>
          <target state="translated">A continuación figura una lista de los métodos disponibles.</target>
        </trans-unit>
        <trans-unit id="a5ddbb5a4ded78a58dd050a0a7bd8f09a53b44f8" translate="yes" xml:space="preserve">
          <source>Below is a list of the valid options:</source>
          <target state="translated">A continuación se presenta una lista de las opciones válidas:</target>
        </trans-unit>
        <trans-unit id="f51c6d51b727cf7e1f4d3849980abd064bedf568" translate="yes" xml:space="preserve">
          <source>Below is a mapping of what utilities will be used in what order for what schemes, if available:</source>
          <target state="translated">A continuación se presenta un mapa de las utilidades que se usarán en qué orden para qué esquemas,si están disponibles:</target>
        </trans-unit>
        <trans-unit id="19c0c3663e2dbbc758912a1313a649285c7d7339" translate="yes" xml:space="preserve">
          <source>Below is a mod_perl Apache compression module, called &lt;code&gt;Apache::GZip&lt;/code&gt;, taken from &lt;a href=&quot;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&quot;&gt;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f862ff6bbb572fec192203e27062a9a60390a82a" translate="yes" xml:space="preserve">
          <source>Below is a mod_perl Apache compression module, called &lt;code&gt;Apache::GZip&lt;/code&gt;, taken from &lt;a href=&quot;https://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&quot;&gt;http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="beba98866f16c9dd2863b4a3ebd6b7ee815c3c45" translate="yes" xml:space="preserve">
          <source>Below is a possible implementation of a script to carry out the rename (error cases have been omitted)</source>
          <target state="translated">A continuación se presenta una posible implementación de un guión para llevar a cabo el renombramiento (se han omitido los casos de error)</target>
        </trans-unit>
        <trans-unit id="58a01ebfbc11cd115ad51487cc4a5f70ba63da00" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt; . It implements a very simple</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra un script que hace uso de &lt;code&gt;gzreadline&lt;/code&gt; . Implementa un muy simple</target>
        </trans-unit>
        <trans-unit id="dc35361ae28756350bcadeedc93fea7a717eda63" translate="yes" xml:space="preserve">
          <source>Below is a script which makes use of &lt;code&gt;gzreadline&lt;/code&gt;. It implements a very simple</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ffed42afdfaf25df4c7e5e8645b31ce92ca54e6" translate="yes" xml:space="preserve">
          <source>Below is a simple &quot;rename&quot; script that uses &lt;code&gt;globmap&lt;/code&gt; to determine the source and destination filenames.</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra un sencillo script de &quot;cambio de nombre&quot; que utiliza &lt;code&gt;globmap&lt;/code&gt; para determinar los nombres de archivo de origen y destino.</target>
        </trans-unit>
        <trans-unit id="1ec37797cdff4399757b58637d8bd54b7066dfec" translate="yes" xml:space="preserve">
          <source>Below is an example module that makes use of the macros.</source>
          <target state="translated">A continuación se muestra un módulo de ejemplo que hace uso de las macros.</target>
        </trans-unit>
        <trans-unit id="2be2899025a1fe4d200821c4ccbd79eabb3ab414" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt; , which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra un programa de ejemplo, &lt;code&gt;cpp_test&lt;/code&gt; , que utiliza este filtro. Se han agregado n&amp;uacute;meros de l&amp;iacute;nea para permitir que las l&amp;iacute;neas espec&amp;iacute;ficas sean referenciadas f&amp;aacute;cilmente.</target>
        </trans-unit>
        <trans-unit id="b304a8ff907f2b83be9fd715d004cdf9a531f584" translate="yes" xml:space="preserve">
          <source>Below is an example program, &lt;code&gt;cpp_test&lt;/code&gt;, which makes use of this filter. Line numbers have been added to allow specific lines to be referenced easily.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e2cc23005bf69f272f1f19d9851308543cafdff" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt; , which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt; . If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra solo un ejemplo, que ilustra el verbo de control &lt;code&gt;(*FAIL)&lt;/code&gt; , que puede abreviarse como &lt;code&gt;(*F)&lt;/code&gt; . Si esto se inserta en una expresi&amp;oacute;n regular, har&amp;aacute; que falle, tal como lo har&amp;iacute;a en una discrepancia entre el patr&amp;oacute;n y la cadena. El procesamiento de la expresi&amp;oacute;n regular contin&amp;uacute;a como lo har&amp;iacute;a despu&amp;eacute;s de cualquier falla &quot;normal&quot;, de modo que, por ejemplo, se probar&amp;aacute; la siguiente posici&amp;oacute;n en la cadena u otra alternativa. Dado que no hacer coincidir no preserva los grupos de captura ni produce resultados, puede ser necesario usar esto en combinaci&amp;oacute;n con el c&amp;oacute;digo incrustado.</target>
        </trans-unit>
        <trans-unit id="8dfcb4bdf0851e123d1da057d122d3eaadab35bd" translate="yes" xml:space="preserve">
          <source>Below is just one example, illustrating the control verb &lt;code&gt;(*FAIL)&lt;/code&gt;, which may be abbreviated as &lt;code&gt;(*F)&lt;/code&gt;. If this is inserted in a regexp it will cause it to fail, just as it would at some mismatch between the pattern and the string. Processing of the regexp continues as it would after any &quot;normal&quot; failure, so that, for instance, the next position in the string or another alternative will be tried. As failing to match doesn't preserve capture groups or produce results, it may be necessary to use this in combination with embedded code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="994ae30ab39b91782977e3601a4b1c5958c55b6d" translate="yes" xml:space="preserve">
          <source>Below is the sample of what to do to reproduce the configuration on my machine. In</source>
          <target state="translated">A continuación se muestra una muestra de lo que hay que hacer para reproducir la configuración en mi máquina.En</target>
        </trans-unit>
        <trans-unit id="8d0833a6280a2357c9ec993c9c38bf06fc8a81e8" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt; .</source>
          <target state="translated">A continuaci&amp;oacute;n se muestra un c&amp;oacute;digo t&amp;iacute;pico que muestra c&amp;oacute;mo utilizar &lt;code&gt;LimitOutput&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b7690c7bdc8f256fde6341fc38dc8edeb2bb2bde" translate="yes" xml:space="preserve">
          <source>Below is typical code that shows how to use &lt;code&gt;LimitOutput&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f28ac791ee08fb184476e4de12d634a0a1d7498" translate="yes" xml:space="preserve">
          <source>Ben Tilly</source>
          <target state="translated">Ben Tilly</target>
        </trans-unit>
        <trans-unit id="e231863abeba6b63203ae12c8ced1dd832bf1e27" translate="yes" xml:space="preserve">
          <source>Ben Tilly &amp;lt;btilly@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ed99e75a9b04f273de29c9fef2bd3fb53d2e2de" translate="yes" xml:space="preserve">
          <source>Benchmark</source>
          <target state="translated">Benchmark</target>
        </trans-unit>
        <trans-unit id="9a552526ddac8fc37648130a16d1381a6f9ad6fb" translate="yes" xml:space="preserve">
          <source>Benchmark - benchmark running times of Perl code</source>
          <target state="translated">Referencia:tiempos de ejecución de referencia del código Perl.</target>
        </trans-unit>
        <trans-unit id="c6133998f601e0eb9b2fbe0a853d3f9116d43ce3" translate="yes" xml:space="preserve">
          <source>Benchmark Object</source>
          <target state="translated">objeto de referencia</target>
        </trans-unit>
        <trans-unit id="0ff60c3e395ce6dcfa9869e330a91fa3d0e1a335" translate="yes" xml:space="preserve">
          <source>Benchmark inherits from no other class, except of course from Exporter.</source>
          <target state="translated">Benchmark no hereda de ninguna otra clase,excepto,por supuesto,del Exportador.</target>
        </trans-unit>
        <trans-unit id="bf40ff62878fab85612abb7b1055df933f606399" translate="yes" xml:space="preserve">
          <source>Benchmark running times of Perl code</source>
          <target state="translated">Los tiempos de referencia del código Perl</target>
        </trans-unit>
        <trans-unit id="4b02607a2ea9a6953d07f941016201f155b468af" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill.</source>
          <target state="translated">Benjamin Holzman contribuyó con el soporte de la variable atada,Andrew Ford contribuyó con el orden canónico para los hashes,y Gisle Aas arregló algunos malentendidos míos con respecto a los internos del perl,y optimizó la emisión de &quot;tags&quot; en los flujos de salida simplemente contando los objetos en lugar de etiquetarlos (lo que llevó a una incompatibilidad binaria para la imagen del Storable a partir de la versión 0.6-las imágenes antiguas,por supuesto,todavía se entienden correctamente).Murray Nesbitt hizo el hilo de Storable seguro.Marc Lehmann añadió la sobrecarga y las referencias al soporte de artículos atados.Benjamin Holzman añadió una mejora de rendimiento para las clases sobrecargadas;gracias a Grant Street Group por pagar la factura.</target>
        </trans-unit>
        <trans-unit id="97adf5b0f3e282d4b4c33cdd224636f12368207c" translate="yes" xml:space="preserve">
          <source>Benjamin Holzman contributed the tied variable support, Andrew Ford contributed the canonical order for hashes, and Gisle Aas fixed a few misunderstandings of mine regarding the perl internals, and optimized the emission of &quot;tags&quot; in the output streams by simply counting the objects instead of tagging them (leading to a binary incompatibility for the Storable image starting at version 0.6--older images are, of course, still properly understood). Murray Nesbitt made Storable thread-safe. Marc Lehmann added overloading and references to tied items support. Benjamin Holzman added a performance improvement for overloaded classes; thanks to Grant Street Group for footing the bill. Reini Urban took over maintainance from p5p, and added security fixes and huge object support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce63cc3b1fa95fc4c74ca1cad11a70531a58a69f" translate="yes" xml:space="preserve">
          <source>Benjamin Noggle &amp;lt;agwind@users.noreply.github.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75fc540bc0a50aa81831bc474ec860350d0bca6e" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="translated">Berkeley DB permite la creaci&amp;oacute;n de bases de datos en memoria utilizando NULL (es decir, un &lt;code&gt;(char *)0&lt;/code&gt; en C) en lugar del nombre del archivo. &lt;b&gt;DB_File&lt;/b&gt; usa &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; en lugar de NULL para proporcionar esta funcionalidad.</target>
        </trans-unit>
        <trans-unit id="b44f74f0eaff4623bb4f32a3bc9a77a5a293d873" translate="yes" xml:space="preserve">
          <source>Berkeley DB allows the creation of in-memory databases by using NULL (that is, a &lt;code&gt;(char *)0&lt;/code&gt; in C) in place of the filename. &lt;b&gt;DB_File&lt;/b&gt; uses &lt;code&gt;undef&lt;/code&gt; instead of NULL to provide this functionality.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9268b246582cb1f8cd7166d3bdd75afc5afe74a7" translate="yes" xml:space="preserve">
          <source>Berkeley DB is a C library which provides a consistent interface to a number of database formats. &lt;b&gt;DB_File&lt;/b&gt; provides an interface to all three of the database types currently supported by Berkeley DB.</source>
          <target state="translated">Berkeley DB es una biblioteca de C que proporciona una interfaz coherente para varios formatos de base de datos. &lt;b&gt;DB_File&lt;/b&gt; proporciona una interfaz para los tres tipos de bases de datos que actualmente admite Berkeley DB.</target>
        </trans-unit>
        <trans-unit id="434964490ac8a77af87035de9e77b760d4b578ea" translate="yes" xml:space="preserve">
          <source>Berkeley DB uses the function dbopen() to open or create a database. Here is the C prototype for dbopen():</source>
          <target state="translated">La base de datos de Berkeley utiliza la función dbopen()para abrir o crear una base de datos.Aquí está el prototipo de C para dbopen():</target>
        </trans-unit>
        <trans-unit id="cbcc04a4e53af70d968fb1854369b92c28068d53" translate="yes" xml:space="preserve">
          <source>BerkeleyDB is available for Cygwin.</source>
          <target state="translated">BerkeleyDB está disponible para Cygwin.</target>
        </trans-unit>
        <trans-unit id="994ccae3d03329e5f7c9f11ecf6157dc38d89408" translate="yes" xml:space="preserve">
          <source>Beside import() and AUTOLOAD() there are only a few other methods.</source>
          <target state="translated">Además de import()y AUTOLOAD()sólo hay algunos otros métodos.</target>
        </trans-unit>
        <trans-unit id="8eaf9c16309e0e030fec414bcececf296c9fd80c" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#Metacharacters&quot;&gt;&lt;code&gt;&quot;^&quot;&lt;/code&gt; and &lt;code&gt;&quot;$&quot;&lt;/code&gt;&lt;/a&gt;, Perl defines the following zero-width assertions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9ba06ebae884c8bbbcddfe487f2f73c4f3cbe88a" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;&quot;decode&quot;&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;&quot;encode&quot;&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cc3e4e79500c47fb5b02fd6bd36bb30830d4b93" translate="yes" xml:space="preserve">
          <source>Besides &lt;a href=&quot;#decode&quot;&gt;decode&lt;/a&gt; and &lt;a href=&quot;#encode&quot;&gt;encode&lt;/a&gt;, other methods are available as well. For instance, &lt;code&gt;name()&lt;/code&gt; returns the canonical name of the encoding object.</source>
          <target state="translated">Adem&amp;aacute;s de &lt;a href=&quot;#decode&quot;&gt;decodificar&lt;/a&gt; y &lt;a href=&quot;#encode&quot;&gt;codificar&lt;/a&gt; , tambi&amp;eacute;n hay otros m&amp;eacute;todos disponibles. Por ejemplo, &lt;code&gt;name()&lt;/code&gt; devuelve el nombre can&amp;oacute;nico del objeto de codificaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c3f604e026977938c21e0b164fdc42c9575f5038" translate="yes" xml:space="preserve">
          <source>Besides being a metacharacter, the &lt;code&gt;&quot;.&quot;&lt;/code&gt; is an example of a &quot;character class&quot;, something that can match any single character of a given set of them. In its case, the set is just about all possible characters. Perl predefines several character classes besides the &lt;code&gt;&quot;.&quot;&lt;/code&gt;; there is a separate reference page about just these, &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="212828aa9819262a5dba3e04d7db334b30f00e96" translate="yes" xml:space="preserve">
          <source>Besides being able to say &lt;code&gt;\p{Name=...}&lt;/code&gt;, the Name and Name_Aliases properties are accessible through the &lt;code&gt;\N{}&lt;/code&gt; interpolation in double-quoted strings and regular expressions; and functions &lt;code&gt;charnames::viacode()&lt;/code&gt;, &lt;code&gt;charnames::vianame()&lt;/code&gt;, and &lt;code&gt;charnames::string_vianame()&lt;/code&gt; (which require a &lt;code&gt;use charnames ();&lt;/code&gt; to be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a7e42697322af6c9745acd371b634a7d3de7f9ce" translate="yes" xml:space="preserve">
          <source>Besides checking existing XS code, the script can also be used to retrieve compatibility information for various API calls using the &lt;code&gt;--api-info&lt;/code&gt; command line switch. For example:</source>
          <target state="translated">Adem&amp;aacute;s de verificar el c&amp;oacute;digo XS existente, el script tambi&amp;eacute;n se puede usar para recuperar informaci&amp;oacute;n de compatibilidad para varias llamadas de API usando el interruptor de l&amp;iacute;nea de comando &lt;code&gt;--api-info&lt;/code&gt; . Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="38c540b359fe4177c8733f2554f7c8aac1cf7755" translate="yes" xml:space="preserve">
          <source>Besides many other tests, it will test every locale it finds on your system to see if they conform to the POSIX standard. If any have errors, it will include a summary near the end of the output of which locales passed all its tests, and which failed, and why.</source>
          <target state="translated">Además de muchas otras pruebas,probará cada local que encuentre en su sistema para ver si se ajustan al estándar POSIX.Si alguna tiene errores,incluirá un resumen cerca del final de la salida de qué locales pasaron todas sus pruebas,y cuáles fallaron,y por qué.</target>
        </trans-unit>
        <trans-unit id="eaf1b9544c43d438f9e6f77acb1ab9f9247ce8b8" translate="yes" xml:space="preserve">
          <source>Besides putting the cross-compiler and the rest of the toolchain in your PATH, this will also provide the QNX_TARGET variable, which we will pass to Configure through -Dsysroot.</source>
          <target state="translated">Además de poner el compilador cruzado y el resto de la cadena de herramientas en su PATH,esto también proporcionará la variable QNX_TARGET,que pasaremos a Configurar a través de -Dsysroot.</target>
        </trans-unit>
        <trans-unit id="8731a27dfb4cb7bb97f8e5e387722a8377af9b68" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt; , calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt; . Or you can just call this in void context.</source>
          <target state="translated">Adem&amp;aacute;s de guardar estos hash como los atributos &lt;code&gt;name2path&lt;/code&gt; y &lt;code&gt;path2name&lt;/code&gt; , llamar a esta funci&amp;oacute;n tambi&amp;eacute;n devuelve estos hashrefs. En el contexto de la lista, el valor de retorno de &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; es la lista &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt; . En contexto escalar, el valor de retorno es &lt;code&gt;\%name2path&lt;/code&gt; . O simplemente puede llamar a esto en contexto vac&amp;iacute;o.</target>
        </trans-unit>
        <trans-unit id="68eae0359edab349209444648a1ef905188cfbd0" translate="yes" xml:space="preserve">
          <source>Besides saving these hashes as the hashref attributes &lt;code&gt;name2path&lt;/code&gt; and &lt;code&gt;path2name&lt;/code&gt;, calling this function also returns these hashrefs. In list context, the return value of &lt;code&gt;$search-&amp;gt;survey&lt;/code&gt; is the list &lt;code&gt;(\%name2path, \%path2name)&lt;/code&gt;. In scalar context, the return value is &lt;code&gt;\%name2path&lt;/code&gt;. Or you can just call this in void context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db52c932112966f376fe8b88f42b909a1d77f94" translate="yes" xml:space="preserve">
          <source>Besides taking away the special meaning of a metacharacter, a prefixed backslash changes some letter and digit characters away from matching just themselves to instead have special meaning. These are called &quot;escape sequences&quot;, and all such are described in &lt;a href=&quot;perlrebackslash&quot;&gt;perlrebackslash&lt;/a&gt;. A backslash sequence (of a letter or digit) that doesn't currently have special meaning to Perl will raise a warning if warnings are enabled, as those are reserved for potential future use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d17cf41d34eb6f4b37b1b9cc872817585f3b1ca4" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="translated">Adem&amp;aacute;s del &lt;code&gt;$|&lt;/code&gt; variable especial, puede usar &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; para darle a su identificador de archivo una capa &lt;code&gt;:unix&lt;/code&gt; , que no tiene b&amp;uacute;fer:</target>
        </trans-unit>
        <trans-unit id="28b7e372985d4c31ff927994e7e34211eb124b71" translate="yes" xml:space="preserve">
          <source>Besides the &lt;code&gt;$|&lt;/code&gt; special variable, you can use &lt;code&gt;binmode&lt;/code&gt; to give your filehandle a &lt;code&gt;:unix&lt;/code&gt; layer, which is unbuffered:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c874def12573a04b6982ff2c45bf57742f038615" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="translated">Adem&amp;aacute;s del car&amp;aacute;cter NBSP mencionado anteriormente, se recuerda a los implementadores la existencia del otro car&amp;aacute;cter &quot;especial&quot; en Latin-1, el car&amp;aacute;cter de &quot;gui&amp;oacute;n suave&quot;, tambi&amp;eacute;n conocido como &quot;gui&amp;oacute;n discrecional&quot;, es decir, &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt; ). Este car&amp;aacute;cter expresa un punto de separaci&amp;oacute;n de s&amp;iacute;labas opcional. Es decir, normalmente se representa como nada, pero puede presentarse como un &quot;-&quot; si un formateador rompe la palabra en ese punto. Los formateadores de pod deben, seg&amp;uacute;n corresponda, realizar una de las siguientes acciones: 1) renderizar esto con un c&amp;oacute;digo con el mismo significado (p. Ej., &quot;\ -&quot; en RTF), 2) pasarlo con la expectativa de que el formateador entienda este car&amp;aacute;cter como tal, o 3) eliminarlo.</target>
        </trans-unit>
        <trans-unit id="fb9d8bd5854ba8b088687eedfedb188dbc42540c" translate="yes" xml:space="preserve">
          <source>Besides the NBSP character discussed above, implementors are reminded of the existence of the other &quot;special&quot; character in Latin-1, the &quot;soft hyphen&quot; character, also known as &quot;discretionary hyphen&quot;, i.e. &lt;code&gt;E&amp;lt;173&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;0xAD&amp;gt;&lt;/code&gt; = &lt;code&gt;E&amp;lt;shy&amp;gt;&lt;/code&gt;). This character expresses an optional hyphenation point. That is, it normally renders as nothing, but may render as a &quot;-&quot; if a formatter breaks the word at that point. Pod formatters should, as appropriate, do one of the following: 1) render this with a code with the same meaning (e.g., &quot;\-&quot; in RTF), 2) pass it through in the expectation that the formatter understands this character as such, or 3) delete it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="383f64e6a803d40e90542694df252e926486880e" translate="yes" xml:space="preserve">
          <source>Besides the normal array index looping, &lt;code&gt;for&lt;/code&gt; can lend itself to many other interesting applications. Here's one that avoids the problem you get into if you explicitly test for end-of-file on an interactive file descriptor causing your program to appear to hang.</source>
          <target state="translated">Adem&amp;aacute;s del bucle de &amp;iacute;ndice de matriz normal, &lt;code&gt;for&lt;/code&gt; puede prestarse a muchas otras aplicaciones interesantes. Aqu&amp;iacute; hay uno que evita el problema en el que se mete si prueba expl&amp;iacute;citamente el final del archivo en un descriptor de archivo interactivo que hace que su programa parezca bloquearse.</target>
        </trans-unit>
        <trans-unit id="b788aba9c107e5a4eaba0767ff3be57caf43c88d" translate="yes" xml:space="preserve">
          <source>Besides the obvious documents, source code can be instructive. Some pathological examples of the use of references can be found in the</source>
          <target state="translated">Además de los documentos obvios,el código fuente puede ser instructivo.Algunos ejemplos patológicos del uso de referencias pueden encontrarse en el</target>
        </trans-unit>
        <trans-unit id="3cd8fe6552552b50530c70ff871d9df229c4d203" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man also takes care of formatting func(), func(3), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; makes C++ look right, puts a little space between double underscores, makes ALLCAPS a teeny bit smaller in &lt;b&gt;troff&lt;/b&gt;, and escapes stuff that *roff treats as special so that you don't have to.</source>
          <target state="translated">Adem&amp;aacute;s de las obvias conversiones de pod, Pod :: Man tambi&amp;eacute;n se encarga de formatear func (), func (3) y referencias de variables simples como $ foo o @bar para que no tengas que usar c&amp;oacute;digos de escape para ellos; Sin embargo, las expresiones complejas como &lt;code&gt;$fred{'stuff'}&lt;/code&gt; a&amp;uacute;n deber&amp;aacute;n escaparse. Tambi&amp;eacute;n traduce los guiones que no se usan como guiones en guiones cortos, hace guiones largos, como este, en guiones em adecuados, corrige &quot;comillas emparejadas&quot;, hace que C ++ se vea bien, pone un poco de espacio entre guiones bajos dobles, hace ALLCAPS un poquito m&amp;aacute;s peque&amp;ntilde;o en &lt;b&gt;troff&lt;/b&gt; , y escapa de cosas que * roff trata como especiales para que t&amp;uacute; no tengas que hacerlo.</target>
        </trans-unit>
        <trans-unit id="5bb351a96d9e7856a11971d899903843a4ce13f1" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;Pod::Man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a063aa374e8d2e7cef3baa1877fd812efaeadbc4" translate="yes" xml:space="preserve">
          <source>Besides the obvious pod conversions, Pod::Man, and therefore pod2man also takes care of formatting func(), func(n), and simple variable references like $foo or @bar so you don't have to use code escapes for them; complex expressions like &lt;code&gt;$fred{'stuff'}&lt;/code&gt; will still need to be escaped, though. It also translates dashes that aren't used as hyphens into en dashes, makes long dashes--like this--into proper em dashes, fixes &quot;paired quotes,&quot; and takes care of several other troff-specific tweaks. See &lt;a href=&quot;pod/man&quot;&gt;Pod::Man&lt;/a&gt; for complete information.</source>
          <target state="translated">Adem&amp;aacute;s de las conversiones de pod obvias, Pod :: Man y, por lo tanto, pod2man tambi&amp;eacute;n se encarga de formatear func (), func (n) y referencias de variables simples como $ foo o @bar para que no tenga que usar escapes de c&amp;oacute;digo para ellos. ; Sin embargo, las expresiones complejas como &lt;code&gt;$fred{'stuff'}&lt;/code&gt; a&amp;uacute;n deber&amp;aacute;n escaparse. Tambi&amp;eacute;n traduce los guiones que no se usan como guiones en guiones cortos, convierte los guiones largos, como este, en guiones em adecuados, corrige &quot;comillas emparejadas&quot; y se encarga de varios otros ajustes espec&amp;iacute;ficos de troff. Consulte &lt;a href=&quot;pod/man&quot;&gt;Pod :: Man&lt;/a&gt; para obtener informaci&amp;oacute;n completa.</target>
        </trans-unit>
        <trans-unit id="2b7e5467e3e0ec9a6b2fff1ef3ee081c7b986017" translate="yes" xml:space="preserve">
          <source>Besides the well-known &quot;E&amp;lt;lt&amp;gt;&quot; and &quot;E&amp;lt;gt&amp;gt;&quot; codes for less-than and greater-than, Pod parsers must understand &quot;E&amp;lt;sol&amp;gt;&quot; for &quot;/&quot; (solidus, slash), and &quot;E&amp;lt;verbar&amp;gt;&quot; for &quot;|&quot; (vertical bar, pipe). Pod parsers should also understand &quot;E&amp;lt;lchevron&amp;gt;&quot; and &quot;E&amp;lt;rchevron&amp;gt;&quot; as legacy codes for characters 171 and 187, i.e., &quot;left-pointing double angle quotation mark&quot; = &quot;left pointing guillemet&quot; and &quot;right-pointing double angle quotation mark&quot; = &quot;right pointing guillemet&quot;. (These look like little &quot;&amp;lt;&amp;lt;&quot; and &quot;&amp;gt;&amp;gt;&quot;, and they are now preferably expressed with the HTML/XHTML codes &quot;E&amp;lt;laquo&amp;gt;&quot; and &quot;E&amp;lt;raquo&amp;gt;&quot;.)</source>
          <target state="translated">Adem&amp;aacute;s de los conocidos c&amp;oacute;digos &quot;E &amp;lt;lt&amp;gt;&quot; y &quot;E &amp;lt;gt&amp;gt;&quot; para menor que y mayor-que, los analizadores de pod deben entender &quot;E &amp;lt;sol&amp;gt;&quot; para &quot;/&quot; (solidus, barra) y &quot; E &amp;lt;verbar&amp;gt; &quot;para&quot; | &quot; (barra vertical, tubo). Los analizadores de pod tambi&amp;eacute;n deben entender &quot;E &amp;lt;lchevron&amp;gt;&quot; y &quot;E &amp;lt;rchevron&amp;gt;&quot; como c&amp;oacute;digos heredados para los caracteres 171 y 187, es decir, &quot;comillas de doble &amp;aacute;ngulo hacia la izquierda&quot; = &quot;guillemet hacia la izquierda&quot; y &quot;doble hacia la derecha comillas angulares &quot;=&quot; guillemet apuntando hacia la derecha &quot;. (Parecen peque&amp;ntilde;os &quot;&amp;lt;&amp;lt;&quot; y &quot;&amp;gt;&amp;gt;&quot;, y ahora se expresan preferiblemente con los c&amp;oacute;digos HTML / XHTML &quot;E &amp;lt;laquo&amp;gt;&quot; y &quot;E &amp;lt;raquo&amp;gt;&quot;).</target>
        </trans-unit>
        <trans-unit id="860a34f94eb6573e4bc9c4a64ff033a99b23eda5" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;Unicode::UCD#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b2158802b148a274c615dff49ad8ceaf2fe4a86" translate="yes" xml:space="preserve">
          <source>Besides these, all the Unicode character properties mentioned above (except for those marked as for internal use by Perl) are also accessible by &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">Adem&amp;aacute;s de estas, todas las propiedades de caracteres Unicode mencionadas anteriormente (excepto aquellas marcadas como para uso interno por Perl) tambi&amp;eacute;n son accesibles por &lt;a href=&quot;unicode/ucd#prop_invlist()&quot;&gt;prop_invlist () en Unicode :: UCD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="708a3f784c168edb7cbbe1a181dbe5bffd40a3cc" translate="yes" xml:space="preserve">
          <source>Besides whole phrases meant for output, anything language-dependent should be put into the class Projname::L10N::en_us, whether as methods, or as lexicon entries -- this is discussed in the section &quot;Entries in Each Lexicon&quot;, above.</source>
          <target state="translated">Además de las frases enteras destinadas a la salida,todo lo que dependa del lenguaje debe ser puesto en la clase Projname::L10N::en_us,ya sea como métodos,o como entradas en el léxico-esto se discute en la sección &quot;Entradas en cada léxico&quot;,arriba.</target>
        </trans-unit>
        <trans-unit id="ab1d9532fa300263b037333b93fafef9210c8c57" translate="yes" xml:space="preserve">
          <source>Besides, I don't know how to write the damned things.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd7916b96afe381cf04fb2aeca341eed5cca3a69" translate="yes" xml:space="preserve">
          <source>Best practices for making a new module.</source>
          <target state="translated">Las mejores prácticas para hacer un nuevo módulo.</target>
        </trans-unit>
        <trans-unit id="ae28545952ad516171bc8541be8a3d6e7dcf583f" translate="yes" xml:space="preserve">
          <source>Better diagnostics capabilities.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80d4f16c5fc7da807c79c20a2575508b93d90392" translate="yes" xml:space="preserve">
          <source>Between &lt;code&gt;pairs&lt;/code&gt; and &lt;code&gt;unpairs&lt;/code&gt;, a higher-order list function can be used to operate on the pairs as single scalars; such as the following near-equivalents of the other &lt;code&gt;pair*&lt;/code&gt; higher-order functions:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f9760622e022594213ec306985fb05bd7325740" translate="yes" xml:space="preserve">
          <source>Between Mac OS X 10.3 &quot;Panther&quot; and 10.6 &quot;Snow Leopard&quot;, the 'Command Line Tools' bundle was called 'unix tools', and was usually supplied with Mac OS install DVDs.</source>
          <target state="translated">Entre Mac OS X 10.3 &quot;Pantera&quot; y 10.6 &quot;Leopardo de las Nieves&quot;,el paquete de 'Herramientas de Línea de Comandos' se llamaba 'herramientas unix',y se suministraba normalmente con los DVDs de instalación de Mac OS.</target>
        </trans-unit>
        <trans-unit id="6249e6fb239ee6aed11ccf460f154f4ff6f24738" translate="yes" xml:space="preserve">
          <source>Between the &lt;code&gt;%&lt;/code&gt; and the format letter, you may specify several additional attributes controlling the interpretation of the format. In order, these are:</source>
          <target state="translated">Entre el &lt;code&gt;%&lt;/code&gt; y la letra del formato, puede especificar varios atributos adicionales que controlan la interpretaci&amp;oacute;n del formato. En orden, estos son:</target>
        </trans-unit>
        <trans-unit id="b8011f36b2088bc97398915695cf8abfb01b5b1d" translate="yes" xml:space="preserve">
          <source>Beware also of the order of more complicated expressions like:</source>
          <target state="translated">Cuidado también con el orden de expresiones más complicadas como:</target>
        </trans-unit>
        <trans-unit id="6cfef1757642ae2cc2b58e48199cf1ffe99563dc" translate="yes" xml:space="preserve">
          <source>Beware of casting the entire expression, as this would cast the result, at which point it is too late:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c100dc724a3253ddc31a97cdb43e9fdb264b604" translate="yes" xml:space="preserve">
          <source>Beware of simple &quot;casting&quot; the entire expression, this would only convert the already computed result:</source>
          <target state="translated">Cuidado con el simple &quot;vaciado&quot; de toda la expresión,esto sólo convertiría el resultado ya calculado:</target>
        </trans-unit>
        <trans-unit id="993aa75891c2224a1f9c297f58bf1ffa758e779f" translate="yes" xml:space="preserve">
          <source>Beware of the &quot;else syndrome&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a9c3aa0cee4b1c15e1e5a6a65e3ca3cde192e4e" translate="yes" xml:space="preserve">
          <source>Beware of using &lt;code&gt;&quot;$&quot;&lt;/code&gt; to indicate to match the end of the string. It can too easily be interpreted as being a punctuation variable, like &lt;code&gt;$/&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8bc77265aea976e7b646f3af43c05662f7e17da" translate="yes" xml:space="preserve">
          <source>Beware of:</source>
          <target state="translated">Cuidado:</target>
        </trans-unit>
        <trans-unit id="6bac55531c21ad380bc95de89addf1faea92b643" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt; , double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="translated">Tenga en cuenta que si coloca barras invertidas literales (las que no est&amp;aacute;n dentro de las variables interpoladas) entre &lt;code&gt;\Q&lt;/code&gt; y &lt;code&gt;\E&lt;/code&gt; , la interpolaci&amp;oacute;n de barras invertidas entre comillas dobles puede generar resultados confusos. Si tu</target>
        </trans-unit>
        <trans-unit id="eebfc88db53433dbd95a0208b9c35bedb078dc7e" translate="yes" xml:space="preserve">
          <source>Beware that if you put literal backslashes (those not inside interpolated variables) between &lt;code&gt;\Q&lt;/code&gt; and &lt;code&gt;\E&lt;/code&gt;, double-quotish backslash interpolation may lead to confusing results. If you</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5349c42e3fc571db11577ff5f6cb8d88af8429b8" translate="yes" xml:space="preserve">
          <source>Beware that in a UTF-8 locale, anything you pass to this function must be in UTF-8; and when not in a UTF-8 locale, anything passed must not be UTF-8 encoded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ca66f864461fdc36869edeb4abd6935993616b0" translate="yes" xml:space="preserve">
          <source>Beware that some command shells may place restrictions on the length of the command line. You must ensure your strings don't exceed this limit after any necessary interpolations. See the platform-specific release notes for more details about your particular environment.</source>
          <target state="translated">Tengan cuidado de que algunos proyectiles de comando pueden poner restricciones en la longitud de la línea de comando.Debe asegurarse de que sus cuerdas no excedan este límite después de cualquier interpolación necesaria.Consulte las notas de lanzamiento específicas de la plataforma para obtener más detalles sobre su entorno particular.</target>
        </trans-unit>
        <trans-unit id="9cd8d5856a80822f4c1d90c9c02e95de943bc843" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#join-EXPR%2CLIST&quot;&gt;&lt;code&gt;join&lt;/code&gt;&lt;/a&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bd1204f447158c3ff1bfbe82d9a707a81d4fa56" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; no toma un patr&amp;oacute;n como primer argumento. Compare &lt;a href=&quot;#split&quot;&gt;split&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc2144e8f71ac4bf9140995eea7dc924e6bdda59" translate="yes" xml:space="preserve">
          <source>Beware that unlike &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; doesn't take a pattern as its first argument. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;.</source>
          <target state="translated">Tenga en cuenta que, a diferencia de &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; no toma un patr&amp;oacute;n como primer argumento. Compare &lt;a href=&quot;split&quot;&gt;split&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c39aa460c8cfb8c3295132732d48ee06e763b200" translate="yes" xml:space="preserve">
          <source>Beware: This feature is not fully implemented yet.</source>
          <target state="translated">Tengan cuidado:Esta característica no se ha implementado completamente todavía.</target>
        </trans-unit>
        <trans-unit id="d3f2ff6e4b3a254c248f8c186f3f0868a1b1e7b1" translate="yes" xml:space="preserve">
          <source>Beware: This list is not complete.</source>
          <target state="translated">Tengan cuidado:Esta lista no está completa.</target>
        </trans-unit>
        <trans-unit id="85c248dc6ba19bfc8397a2d612c997c46ad24985" translate="yes" xml:space="preserve">
          <source>Beware: after this function returns, &lt;code&gt;ptr&lt;/code&gt; and SvPVX_const(sv) may no longer refer to the same chunk of data.</source>
          <target state="translated">Cuidado: despu&amp;eacute;s de que esta funci&amp;oacute;n regrese, es posible que &lt;code&gt;ptr&lt;/code&gt; y SvPVX_const (sv) ya no se refieran al mismo fragmento de datos.</target>
        </trans-unit>
        <trans-unit id="40ca4e03748bbc6d9d8fdf7c985dd464c29b4a02" translate="yes" xml:space="preserve">
          <source>Beyond Unicode code points</source>
          <target state="translated">Más allá de los puntos de código de Unicode</target>
        </trans-unit>
        <trans-unit id="8d2086dee2d46aa5a491374a05ac5325e10530d7" translate="yes" xml:space="preserve">
          <source>Beyond make test</source>
          <target state="translated">Más allá de hacer la prueba</target>
        </trans-unit>
        <trans-unit id="16881dc1b286f9fd89e3c68a1307509ea4208790" translate="yes" xml:space="preserve">
          <source>Beyond raw access to the API calls and related constants, this module handles smart buffer allocation and translation of return codes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7071855c582934ec0ec68ba51cead15591289a64" translate="yes" xml:space="preserve">
          <source>Beyond that help, the urllist config parameter is yours. You can add and remove sites at will. You should find out which sites have the best up-to-dateness, bandwidth, reliability, etc. and are topologically close to you. Some people prefer fast downloads, others up-to-dateness, others reliability. You decide which to try in which order.</source>
          <target state="translated">Más allá de esa ayuda,el parámetro de configuración del urlist es tuyo.Puedes añadir y eliminar sitios a voluntad.Debes averiguar qué sitios tienen la mejor actualización,ancho de banda,confiabilidad,etc.y están topológicamente cerca de ti.Algunas personas prefieren las descargas rápidas,otras la actualización,otras la fiabilidad.Usted decide cuál probar en qué orden.</target>
        </trans-unit>
        <trans-unit id="3f05839b089d755d215e2ff3af4aafe1ec68679d" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="translated">M&amp;aacute;s all&amp;aacute; de eso, el depurador m&amp;aacute;s simple es la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; . &amp;Uacute;selo para ver los valores mientras ejecuta su programa:</target>
        </trans-unit>
        <trans-unit id="cc8c0bdbbf061aa1132ad0db52bd5ab409c1d5c4" translate="yes" xml:space="preserve">
          <source>Beyond that, the simplest debugger is the &lt;code&gt;print&lt;/code&gt; function. Use it to look at values as you run your program:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3981fa65dd4a5a67077c84cbcab0e6d7e62ef4b1" translate="yes" xml:space="preserve">
          <source>Beyond that, you have to consider several things and decide which is best for you.</source>
          <target state="translated">Más allá de eso,tienes que considerar varias cosas y decidir cuál es la mejor para ti.</target>
        </trans-unit>
        <trans-unit id="44d69eda49b459248ce90b6917e4f918be54d8d4" translate="yes" xml:space="preserve">
          <source>Beyond the normal measures described to make general Perl programs faster or smaller, a CGI program has additional issues. It may be run several times per second. Given that each time it runs it will need to be re-compiled and will often allocate a megabyte or more of system memory, this can be a killer. Compiling into C &lt;b&gt;isn't going to help you&lt;/b&gt; because the process start-up overhead is where the bottleneck is.</source>
          <target state="translated">M&amp;aacute;s all&amp;aacute; de las medidas normales descritas para hacer que los programas generales de Perl sean m&amp;aacute;s r&amp;aacute;pidos o m&amp;aacute;s peque&amp;ntilde;os, un programa CGI tiene problemas adicionales. Puede ejecutarse varias veces por segundo. Dado que cada vez que se ejecuta, ser&amp;aacute; necesario volver a compilarlo y, a menudo, asignar&amp;aacute; un megabyte o m&amp;aacute;s de memoria del sistema, esto puede ser un desastre. La compilaci&amp;oacute;n en C &lt;b&gt;no lo ayudar&amp;aacute;&lt;/b&gt; porque la sobrecarga de inicio del proceso es donde est&amp;aacute; el cuello de botella.</target>
        </trans-unit>
        <trans-unit id="213d672c8ec1c5c132adb8f810eb6a5d6ae1c84f" translate="yes" xml:space="preserve">
          <source>Beyond the obvious problems that stem from giving special privileges to systems as flexible as scripts, on many versions of Unix, set-id scripts are inherently insecure right from the start. The problem is a race condition in the kernel. Between the time the kernel opens the file to see which interpreter to run and when the (now-set-id) interpreter turns around and reopens the file to interpret it, the file in question may have changed, especially if you have symbolic links on your system.</source>
          <target state="translated">Más allá de los problemas obvios que se derivan de dar privilegios especiales a sistemas tan flexibles como los scripts,en muchas versiones de Unix,los scripts set-id son inherentemente inseguros desde el principio.El problema es una condición de raza en el núcleo.Entre el momento en que el núcleo abre el archivo para ver qué intérprete debe ejecutar y cuando el intérprete (ahora establecido)se da la vuelta y vuelve a abrir el archivo para interpretarlo,el archivo en cuestión puede haber cambiado,especialmente si tiene enlaces simbólicos en su sistema.</target>
        </trans-unit>
        <trans-unit id="cfa5b349eaf3622485b4949d5b4c1629b7136aa6" translate="yes" xml:space="preserve">
          <source>BhkDISABLE</source>
          <target state="translated">BhkDISABLE</target>
        </trans-unit>
        <trans-unit id="097eaa76fb990cb3c085617a09bb68f2d2dd28d0" translate="yes" xml:space="preserve">
          <source>BhkENABLE</source>
          <target state="translated">BhkENABLE</target>
        </trans-unit>
        <trans-unit id="56657a5c49e88295c9fdbd426498620306255970" translate="yes" xml:space="preserve">
          <source>BhkENTRY</source>
          <target state="translated">BhkENTRY</target>
        </trans-unit>
        <trans-unit id="eed78c8324c929e21a7725f018dc13f233941d2d" translate="yes" xml:space="preserve">
          <source>BhkENTRY_set</source>
          <target state="translated">BhkENTRY_set</target>
        </trans-unit>
        <trans-unit id="6303b515a179b4880dfa9b0c5bdeef24554d4d0d" translate="yes" xml:space="preserve">
          <source>BhkFLAGS</source>
          <target state="translated">BhkFLAGS</target>
        </trans-unit>
        <trans-unit id="619d65e1ae1a2704aa306451ac2a75a0cde345a8" translate="yes" xml:space="preserve">
          <source>Bibliography</source>
          <target state="translated">Bibliography</target>
        </trans-unit>
        <trans-unit id="c81d74ec4f5774b83707b81c40273f9931cc6799" translate="yes" xml:space="preserve">
          <source>BidiCharacterTest.txt</source>
          <target state="translated">BidiCharacterTest.txt</target>
        </trans-unit>
        <trans-unit id="69ecda50c93df6838e91e9e521a5ea42b19e7e09" translate="yes" xml:space="preserve">
          <source>BidiTest.txt</source>
          <target state="translated">BidiTest.txt</target>
        </trans-unit>
        <trans-unit id="603c926318562657586c9e1146fc9dbe3c25c988" translate="yes" xml:space="preserve">
          <source>Bidirectional Character Types</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4412d2ae1aa691608b316e9ad2227f4c8f05c5f" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Another Process</source>
          <target state="translated">Comunicación bidireccional con otro proceso</target>
        </trans-unit>
        <trans-unit id="20453df9f611f7ce81199fe2171f3b15f7db6ba1" translate="yes" xml:space="preserve">
          <source>Bidirectional Communication with Yourself</source>
          <target state="translated">Comunicación bidireccional con usted mismo</target>
        </trans-unit>
        <trans-unit id="de1698114af4355c5ccd60424049fded636df6a2" translate="yes" xml:space="preserve">
          <source>Big5</source>
          <target state="translated">Big5</target>
        </trans-unit>
        <trans-unit id="aaec1a206ed8540735d6653165ead4690d690a5c" translate="yes" xml:space="preserve">
          <source>BigInt's bcmp() routine currently returns undef to signal that a NaN was involved in a comparison. However, the overload code turns that into either 1 or '' and thus operations like &lt;code&gt;NaN != NaN&lt;/code&gt; might return wrong values.</source>
          <target state="translated">La rutina bcmp () de BigInt actualmente devuelve undef para indicar que un NaN estuvo involucrado en una comparaci&amp;oacute;n. Sin embargo, el c&amp;oacute;digo de sobrecarga lo convierte en 1 o '' y, por lo tanto, operaciones como &lt;code&gt;NaN != NaN&lt;/code&gt; pueden devolver valores incorrectos.</target>
        </trans-unit>
        <trans-unit id="b68a65a4af953b7e6ff32f4e519ad10e0c7af47b" translate="yes" xml:space="preserve">
          <source>Bigger Numbers</source>
          <target state="translated">Números más grandes</target>
        </trans-unit>
        <trans-unit id="98032da695f3e799620752e98882e414e0196f49" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; returns true if the left argument is numerically not equal to the right argument.</source>
          <target state="translated">Binary &lt;code&gt;&quot;!=&quot;&lt;/code&gt; Devuelve verdadero si el argumento de la izquierda no es num&amp;eacute;ricamente igual al argumento de la derecha.</target>
        </trans-unit>
        <trans-unit id="0806ad998452d5851f139bbe3f01d7066c39cefd" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; is just like &lt;code&gt;&quot;=~&quot;&lt;/code&gt; except the return value is negated in the logical sense.</source>
          <target state="translated">El binario &lt;code&gt;&quot;!~&quot;&lt;/code&gt; Es como &lt;code&gt;&quot;=~&quot;&lt;/code&gt; excepto que el valor de retorno se niega en el sentido l&amp;oacute;gico.</target>
        </trans-unit>
        <trans-unit id="958b8a1169468f4a63917c7ca8496d2c631c8da0" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt;) or transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt;) is a syntax error.</source>
          <target state="translated">El binario &lt;code&gt;&quot;!~&quot;&lt;/code&gt; Con una sustituci&amp;oacute;n no destructiva ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; ) o transliteraci&amp;oacute;n ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///r&lt;/a&gt;&lt;/code&gt; ) es un error de sintaxis.</target>
        </trans-unit>
        <trans-unit id="669b5730a4de160e3201236f63831582ab97b4ad" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;!~&quot;&lt;/code&gt; with a non-destructive substitution (&lt;code&gt;s///r&lt;/code&gt;) or transliteration (&lt;code&gt;y///r&lt;/code&gt;) is a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f26c16627064dbaf94b2accf763da8c7ea571aa3" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; : If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt; . If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt; ) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt; . Note that when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="translated">El &lt;code&gt;&quot;%&quot;&lt;/code&gt; binario es el operador de m&amp;oacute;dulo, que calcula el resto de la divisi&amp;oacute;n de su primer argumento con respecto a su segundo argumento. Dada n&amp;uacute;mero entero operandos &lt;code&gt;$m&lt;/code&gt; y &lt;code&gt;$n&lt;/code&gt; : Si &lt;code&gt;$n&lt;/code&gt; es positivo, entonces &lt;code&gt;$m % $n&lt;/code&gt; es &lt;code&gt;$m&lt;/code&gt; , menos el m&amp;uacute;ltiplo m&amp;aacute;s grande de &lt;code&gt;$n&lt;/code&gt; menor que o igual a &lt;code&gt;$m&lt;/code&gt; . Si &lt;code&gt;$n&lt;/code&gt; es negativo, &lt;code&gt;$m % $n&lt;/code&gt; es &lt;code&gt;$m&lt;/code&gt; menos el m&amp;uacute;ltiplo m&amp;aacute;s peque&amp;ntilde;o de &lt;code&gt;$n&lt;/code&gt; que no sea menor que &lt;code&gt;$m&lt;/code&gt; (es decir, el resultado ser&amp;aacute; menor o igual a cero). Si los operandos &lt;code&gt;$m&lt;/code&gt; y &lt;code&gt;$n&lt;/code&gt; son valores de punto flotante y el valor absoluto de &lt;code&gt;$n&lt;/code&gt; (es decir &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ) es menor que &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , s&amp;oacute;lo la parte entera de &lt;code&gt;$m&lt;/code&gt; y &lt;code&gt;$n&lt;/code&gt; ser&amp;aacute; utilizado en la operaci&amp;oacute;n (Nota: aqu&amp;iacute; &lt;code&gt;UV_MAX&lt;/code&gt; significa el m&amp;aacute;ximo del tipo entero sin signo). Si el valor absoluto del operando derecho ( &lt;code&gt;&lt;a href=&quot;functions/abs&quot;&gt;abs($n)&lt;/a&gt;&lt;/code&gt; ) es mayor o igual que &lt;code&gt;(UV_MAX + 1)&lt;/code&gt; , &lt;code&gt;&quot;%&quot;&lt;/code&gt; calcula el resto de punto flotante &lt;code&gt;$r&lt;/code&gt; en la ecuaci&amp;oacute;n &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; donde &lt;code&gt;$i&lt;/code&gt; es un cierto n&amp;uacute;mero entero que hace que &lt;code&gt;$r&lt;/code&gt; tenga el mismo signo que el operando derecho &lt;code&gt;$n&lt;/code&gt; ( &lt;b&gt;no&lt;/b&gt; como el operando izquierdo &lt;code&gt;$m&lt;/code&gt; como la funci&amp;oacute;n C &lt;code&gt;fmod()&lt;/code&gt; ) y el valor absoluto es menor que el de &lt;code&gt;$n&lt;/code&gt; . Tenga en cuenta que cuando &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; integer&lt;/code&gt; est&amp;aacute; dentro del alcance, &lt;code&gt;&quot;%&quot;&lt;/code&gt; le da acceso directo al operador de m&amp;oacute;dulo implementado por su compilador de C. Este operador no est&amp;aacute; tan bien definido para operandos negativos, pero se ejecutar&amp;aacute; m&amp;aacute;s r&amp;aacute;pido.</target>
        </trans-unit>
        <trans-unit id="41e316d0ff24f3ca1a3464d44861dfcd88d324d8" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;%&quot;&lt;/code&gt; is the modulo operator, which computes the division remainder of its first argument with respect to its second argument. Given integer operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt;: If &lt;code&gt;$n&lt;/code&gt; is positive, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the largest multiple of &lt;code&gt;$n&lt;/code&gt; less than or equal to &lt;code&gt;$m&lt;/code&gt;. If &lt;code&gt;$n&lt;/code&gt; is negative, then &lt;code&gt;$m % $n&lt;/code&gt; is &lt;code&gt;$m&lt;/code&gt; minus the smallest multiple of &lt;code&gt;$n&lt;/code&gt; that is not less than &lt;code&gt;$m&lt;/code&gt; (that is, the result will be less than or equal to zero). If the operands &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; are floating point values and the absolute value of &lt;code&gt;$n&lt;/code&gt; (that is &lt;code&gt;abs($n)&lt;/code&gt;) is less than &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, only the integer portion of &lt;code&gt;$m&lt;/code&gt; and &lt;code&gt;$n&lt;/code&gt; will be used in the operation (Note: here &lt;code&gt;UV_MAX&lt;/code&gt; means the maximum of the unsigned integer type). If the absolute value of the right operand (&lt;code&gt;abs($n)&lt;/code&gt;) is greater than or equal to &lt;code&gt;(UV_MAX + 1)&lt;/code&gt;, &lt;code&gt;&quot;%&quot;&lt;/code&gt; computes the floating-point remainder &lt;code&gt;$r&lt;/code&gt; in the equation &lt;code&gt;($r = $m - $i*$n)&lt;/code&gt; where &lt;code&gt;$i&lt;/code&gt; is a certain integer that makes &lt;code&gt;$r&lt;/code&gt; have the same sign as the right operand &lt;code&gt;$n&lt;/code&gt; (&lt;b&gt;not&lt;/b&gt; as the left operand &lt;code&gt;$m&lt;/code&gt; like C function &lt;code&gt;fmod()&lt;/code&gt;) and the absolute value less than that of &lt;code&gt;$n&lt;/code&gt;. Note that when &lt;code&gt;use integer&lt;/code&gt; is in scope, &lt;code&gt;&quot;%&quot;&lt;/code&gt; gives you direct access to the modulo operator as implemented by your C compiler. This operator is not as well defined for negative operands, but it will execute faster.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8a326cd0bd8e1d3d414fab02e5019eeeb66d4b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;&quot;Bitwise String Operators&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68ed9e30d3d6543dd0a9f75b291cbc79357b65a9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; returns its operands ANDed together bit by bit. Although no warning is currently raised, the result is not well defined when this operation is performed on operands that aren't either numbers (see &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;) nor bitstrings (see &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Bitwise String Operators&lt;/a&gt;).</source>
          <target state="translated">Binary &lt;code&gt;&quot;&amp;amp;&quot;&lt;/code&gt; devuelve sus operandos AND juntos bit a bit. Aunque actualmente no se emite ninguna advertencia, el resultado no est&amp;aacute; bien definido cuando esta operaci&amp;oacute;n se realiza en operandos que no son n&amp;uacute;meros (consulte &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Aritm&amp;eacute;tica de enteros&lt;/a&gt; ) ni cadenas de bits (consulte &lt;a href=&quot;#Bitwise-String-Operators&quot;&gt;Operadores de cadenas de bits&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="c0937405123294a033856c6fea7344af89470f86" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; performs a short-circuit logical AND operation. That is, if the left operand is false, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">El &lt;code&gt;&quot;&amp;amp;&amp;amp;&quot;&lt;/code&gt; binario realiza una operaci&amp;oacute;n Y l&amp;oacute;gica de cortocircuito. Es decir, si el operando izquierdo es falso, el operando derecho ni siquiera se eval&amp;uacute;a. El contexto escalar o de lista se propaga hasta el operando derecho si se eval&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="1f3f00bc4d3f1107e73b1aeb90803d21d2f7f5a5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; returns true if the left argument is numerically greater than the right argument.</source>
          <target state="translated">Binario &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; devuelve verdadero si el argumento de la izquierda es num&amp;eacute;ricamente mayor que el de la derecha.</target>
        </trans-unit>
        <trans-unit id="7b8b841de5eb99d0ccb88b329de6ee433524b771" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a8e5f64ce960724d668657e4a1ad5261d933577" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; returns the value of its left argument shifted right by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">Binario &lt;code&gt;&quot;&amp;gt;&amp;gt;&quot;&lt;/code&gt; devuelve el valor de su argumento de la izquierda desplazado a la derecha por el n&amp;uacute;mero de bits especificado por el argumento de la derecha. Los argumentos deben ser n&amp;uacute;meros enteros. (Consulte tambi&amp;eacute;n &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Aritm&amp;eacute;tica de enteros&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="9de554883aaffe5a62d4c8a36deea3a837fcd80d" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; returns true if the left argument is numerically greater than or equal to the right argument.</source>
          <target state="translated">Binario &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; devuelve verdadero si el argumento de la izquierda es num&amp;eacute;ricamente mayor o igual que el argumento de la derecha.</target>
        </trans-unit>
        <trans-unit id="a7454742c96c82ff2ca0ce93cf67bcd19286a557" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; returns true if the left argument is numerically less than the right argument.</source>
          <target state="translated">Binario &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; devuelve verdadero si el argumento de la izquierda es num&amp;eacute;ricamente menor que el de la derecha.</target>
        </trans-unit>
        <trans-unit id="699e70a5fa87498319583ad7600759912b343d42" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;&quot;Integer Arithmetic&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6d03b55098c5e945a6cff21988ea84460d71573" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; returns the value of its left argument shifted left by the number of bits specified by the right argument. Arguments should be integers. (See also &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Integer Arithmetic&lt;/a&gt;.)</source>
          <target state="translated">Binario &lt;code&gt;&quot;&amp;lt;&amp;lt;&quot;&lt;/code&gt; devuelve el valor de su argumento izquierdo desplazado a la izquierda por el n&amp;uacute;mero de bits especificado por el argumento derecho. Los argumentos deben ser n&amp;uacute;meros enteros. (Consulte tambi&amp;eacute;n &lt;a href=&quot;#Integer-Arithmetic&quot;&gt;Aritm&amp;eacute;tica de enteros&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="b5e75cae74350bd47fe89e9c43a86148805f25b1" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; returns true if the left argument is numerically less than or equal to the right argument.</source>
          <target state="translated">Binario &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; devuelve verdadero si el argumento de la izquierda es num&amp;eacute;ricamente menor o igual que el argumento de la derecha.</target>
        </trans-unit>
        <trans-unit id="c4b96fdd4c2b42fee6d143e7f60bc5e53b9a1f53" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt; 's (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt; ), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="translated">Binario &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; devuelve -1, 0 o 1 dependiendo de si el argumento de la izquierda es num&amp;eacute;ricamente menor, igual o mayor que el argumento de la derecha. Si su plataforma admite &lt;code&gt;NaN&lt;/code&gt; (no n&amp;uacute;meros) como valores num&amp;eacute;ricos, usarlos con &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; devuelve indef. &lt;code&gt;NaN&lt;/code&gt; no es &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;==&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt; , &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; o &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; nada (incluso &lt;code&gt;NaN&lt;/code&gt; ), por lo que esos 5 devuelven falso. &lt;code&gt;NaN != NaN&lt;/code&gt; devuelve verdadero, al igual que &lt;code&gt;NaN !=&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="ac04a45698769168d1350bede297cc638685f279" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is numerically less than, equal to, or greater than the right argument. If your platform supports &lt;code&gt;NaN&lt;/code&gt;'s (not-a-numbers) as numeric values, using them with &lt;code&gt;&quot;&amp;lt;=&amp;gt;&quot;&lt;/code&gt; returns undef. &lt;code&gt;NaN&lt;/code&gt; is not &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;==&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;gt;&quot;&lt;/code&gt;, &lt;code&gt;&quot;&amp;lt;=&quot;&lt;/code&gt; or &lt;code&gt;&quot;&amp;gt;=&quot;&lt;/code&gt; anything (even &lt;code&gt;NaN&lt;/code&gt;), so those 5 return false. &lt;code&gt;NaN != NaN&lt;/code&gt; returns true, as does &lt;code&gt;NaN !=&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d0148c51849abf03e9b94e765faa605e272cbf6" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;*&quot;&lt;/code&gt; multiplies two numbers.</source>
          <target state="translated">Binario &lt;code&gt;&quot;*&quot;&lt;/code&gt; multiplica dos n&amp;uacute;meros.</target>
        </trans-unit>
        <trans-unit id="01756f918936276dfa8f0de39e3d878d679ba39b" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt; , not &lt;code&gt;(-2)**4&lt;/code&gt; . (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="translated">El binario &lt;code&gt;&quot;**&quot;&lt;/code&gt; es el operador de exponenciaci&amp;oacute;n. Se une a&amp;uacute;n m&amp;aacute;s fuertemente que el menos unario, por lo que &lt;code&gt;-2**4&lt;/code&gt; es &lt;code&gt;-(2**4)&lt;/code&gt; , no &lt;code&gt;(-2)**4&lt;/code&gt; . (Esto se implementa mediante la funci&amp;oacute;n &lt;code&gt;pow(3)&lt;/code&gt; C , que en realidad funciona en dobles internamente).</target>
        </trans-unit>
        <trans-unit id="ea1f5488b58109753bdbb42f40a1d426d3469962" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;**&quot;&lt;/code&gt; is the exponentiation operator. It binds even more tightly than unary minus, so &lt;code&gt;-2**4&lt;/code&gt; is &lt;code&gt;-(2**4)&lt;/code&gt;, not &lt;code&gt;(-2)**4&lt;/code&gt;. (This is implemented using C's &lt;code&gt;pow(3)&lt;/code&gt; function, which actually works on doubles internally.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e565dc6efc9becadb2f620e3b56356ece28d9ea9" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;+&quot;&lt;/code&gt; returns the sum of two numbers.</source>
          <target state="translated">Binario &lt;code&gt;&quot;+&quot;&lt;/code&gt; devuelve la suma de dos n&amp;uacute;meros.</target>
        </trans-unit>
        <trans-unit id="d264c2219fd49edff5b7c850ac6db5ce0ccf6345" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;,&quot;&lt;/code&gt; is the comma operator. In scalar context it evaluates its left argument, throws that value away, then evaluates its right argument and returns that value. This is just like C's comma operator.</source>
          <target state="translated">Binario &lt;code&gt;&quot;,&quot;&lt;/code&gt; es el operador de coma. En contexto escalar, eval&amp;uacute;a su argumento izquierdo, descarta ese valor, luego eval&amp;uacute;a su argumento derecho y devuelve ese valor. Esto es como el operador de coma de C.</target>
        </trans-unit>
        <trans-unit id="afc59f330a0626c101e37690bb504039ec265210" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;-&quot;&lt;/code&gt; returns the difference of two numbers.</source>
          <target state="translated">Binario &lt;code&gt;&quot;-&quot;&lt;/code&gt; devuelve la diferencia de dos n&amp;uacute;meros.</target>
        </trans-unit>
        <trans-unit id="843c8445f5431d5cdfeffedb703a08e101bb0fa7" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;.&quot;&lt;/code&gt; concatenates two strings.</source>
          <target state="translated">Binario &lt;code&gt;&quot;.&quot;&lt;/code&gt; concatena dos cadenas.</target>
        </trans-unit>
        <trans-unit id="20b0ad876d72e0a4e92413d3b855b37c16cdc3ee" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;..&quot;&lt;/code&gt; is the range operator, which is really two different operators depending on the context. In list context, it returns a list of values counting (up by ones) from the left value to the right value. If the left value is greater than the right value then it returns the empty list. The range operator is useful for writing &lt;code&gt;foreach (1..10)&lt;/code&gt; loops and for doing slice operations on arrays. In the current implementation, no temporary array is created when the range operator is used as the expression in &lt;code&gt;foreach&lt;/code&gt; loops, but older versions of Perl might burn a lot of memory when you write something like this:</source>
          <target state="translated">El binario &lt;code&gt;&quot;..&quot;&lt;/code&gt; es el operador de rango, que en realidad son dos operadores diferentes seg&amp;uacute;n el contexto. En el contexto de la lista, devuelve una lista de valores contando (de a uno) desde el valor de la izquierda al valor de la derecha. Si el valor de la izquierda es mayor que el valor de la derecha, devuelve la lista vac&amp;iacute;a. El operador de rango es &amp;uacute;til para escribir bucles &lt;code&gt;foreach (1..10)&lt;/code&gt; y para realizar operaciones de corte en matrices. En la implementaci&amp;oacute;n actual, no se crea una matriz temporal cuando el operador de rango se usa como expresi&amp;oacute;n en los bucles &lt;code&gt;foreach&lt;/code&gt; , pero las versiones anteriores de Perl pueden quemar mucha memoria cuando escribe algo como esto:</target>
        </trans-unit>
        <trans-unit id="11d1e4ec8e23351f5601e3a5d4e0c431e5c430e4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;/&quot;&lt;/code&gt; divides two numbers.</source>
          <target state="translated">El binario &lt;code&gt;&quot;/&quot;&lt;/code&gt; divide dos n&amp;uacute;meros.</target>
        </trans-unit>
        <trans-unit id="f0b12adb8c84721a8d6934894abc35e4121a8c82" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;==&quot;&lt;/code&gt; returns true if the left argument is numerically equal to the right argument.</source>
          <target state="translated">Binario &lt;code&gt;&quot;==&quot;&lt;/code&gt; devuelve verdadero si el argumento de la izquierda es num&amp;eacute;ricamente igual al argumento de la derecha.</target>
        </trans-unit>
        <trans-unit id="e8178e90952cecccc1b319f7d1d8a9d3454e685e" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt; . When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;) and transliteration (&lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="translated">Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; vincula una expresi&amp;oacute;n escalar a una coincidencia de patr&amp;oacute;n. Ciertas operaciones buscan o modifican la cadena &lt;code&gt;$_&lt;/code&gt; por defecto. Este operador hace que ese tipo de operaci&amp;oacute;n funcione en alguna otra cadena. El argumento correcto es un patr&amp;oacute;n de b&amp;uacute;squeda, sustituci&amp;oacute;n o transliteraci&amp;oacute;n. El argumento de la izquierda es lo que se supone que debe buscarse, sustituirse o transliterarse en lugar del &lt;code&gt;$_&lt;/code&gt; predeterminado . Cuando se usa en un contexto escalar, el valor de retorno generalmente indica el &amp;eacute;xito de la operaci&amp;oacute;n. Las excepciones son la sustituci&amp;oacute;n ( &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ) y la transliteraci&amp;oacute;n ( &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ) con la opci&amp;oacute;n &lt;code&gt;/r&lt;/code&gt; (no destructiva), que provocan la &lt;b&gt;r&lt;/b&gt;El valor de retorno ser&amp;aacute; el resultado de la sustituci&amp;oacute;n. El comportamiento en el contexto de la lista depende del operador en particular. Consulte &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;Operadores &lt;/a&gt;&lt;a href=&quot;perlretut&quot;&gt;similares&lt;/a&gt; a cotizaciones de Regexp para obtener m&amp;aacute;s detalles y perlretut para ver ejemplos que utilizan estos operadores.</target>
        </trans-unit>
        <trans-unit id="79a4495643878d498724e64ed7f89a0f4674d534" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;=~&quot;&lt;/code&gt; binds a scalar expression to a pattern match. Certain operations search or modify the string &lt;code&gt;$_&lt;/code&gt; by default. This operator makes that kind of operation work on some other string. The right argument is a search pattern, substitution, or transliteration. The left argument is what is supposed to be searched, substituted, or transliterated instead of the default &lt;code&gt;$_&lt;/code&gt;. When used in scalar context, the return value generally indicates the success of the operation. The exceptions are substitution (&lt;code&gt;s///&lt;/code&gt;) and transliteration (&lt;code&gt;y///&lt;/code&gt;) with the &lt;code&gt;/r&lt;/code&gt; (non-destructive) option, which cause the &lt;b&gt;r&lt;/b&gt;eturn value to be the result of the substitution. Behavior in list context depends on the particular operator. See &lt;a href=&quot;#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot;&lt;/a&gt; for details and &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; for examples using these operators.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa78120f553c43180d2a32604d493af25ed233d4" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;^&quot;&lt;/code&gt; returns its operands XORed together bit by bit.</source>
          <target state="translated">El binario &lt;code&gt;&quot;^&quot;&lt;/code&gt; devuelve sus operandos XOR juntos bit a bit.</target>
        </trans-unit>
        <trans-unit id="671e2c4625e970e48a9399520aaa4fa28b907022" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;and&quot;&lt;/code&gt; returns the logical conjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; except for the very low precedence. This means that it short-circuits: the right expression is evaluated only if the left expression is true.</source>
          <target state="translated">Binary &lt;code&gt;&quot;and&quot;&lt;/code&gt; devuelve la conjunci&amp;oacute;n l&amp;oacute;gica de las dos expresiones circundantes. Es equivalente a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; excepto por la muy baja precedencia. Esto significa que se produce un cortocircuito: la expresi&amp;oacute;n de la derecha se eval&amp;uacute;a solo si la expresi&amp;oacute;n de la izquierda es verdadera.</target>
        </trans-unit>
        <trans-unit id="d3c04971ab5e03274c19bebb1ecd8b4175eeef29" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; returns -1, 0, or 1 depending on whether the left argument is stringwise less than, equal to, or greater than the right argument.</source>
          <target state="translated">El &lt;code&gt;&quot;cmp&quot;&lt;/code&gt; binario devuelve -1, 0 o 1 dependiendo de si el argumento de la izquierda es menor, igual o mayor que el argumento de la derecha.</target>
        </trans-unit>
        <trans-unit id="1aa12faad44cec6a4de324dfb2d0d28e5041c165" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;eq&quot;&lt;/code&gt; returns true if the left argument is stringwise equal to the right argument.</source>
          <target state="translated">La &lt;code&gt;&quot;eq&quot;&lt;/code&gt; binaria devuelve verdadero si el argumento de la izquierda es igual en cadena al argumento de la derecha.</target>
        </trans-unit>
        <trans-unit id="72766e64c0f2ce882d1581bc9a5363e487361650" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ge&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than or equal to the right argument.</source>
          <target state="translated">El binario &lt;code&gt;&quot;ge&quot;&lt;/code&gt; devuelve verdadero si el argumento de la izquierda es mayor o igual que el argumento de la derecha.</target>
        </trans-unit>
        <trans-unit id="8cbbb7f7848eee7ea44e5adae43d5c8ad553b087" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;gt&quot;&lt;/code&gt; returns true if the left argument is stringwise greater than the right argument.</source>
          <target state="translated">El binario &lt;code&gt;&quot;gt&quot;&lt;/code&gt; devuelve verdadero si el argumento de la izquierda es m&amp;aacute;s grande que el de la derecha.</target>
        </trans-unit>
        <trans-unit id="cbde6b024ab1e652daab583508091dcc611a1886" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;le&quot;&lt;/code&gt; returns true if the left argument is stringwise less than or equal to the right argument.</source>
          <target state="translated">El &lt;code&gt;&quot;le&quot;&lt;/code&gt; binario devuelve verdadero si el argumento de la izquierda es menor o igual que el argumento de la derecha.</target>
        </trans-unit>
        <trans-unit id="98038977bb137332bb318c163315bf5cd770bdda" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;lt&quot;&lt;/code&gt; returns true if the left argument is stringwise less than the right argument.</source>
          <target state="translated">El binario &lt;code&gt;&quot;lt&quot;&lt;/code&gt; devuelve verdadero si el argumento de la izquierda es menor en sentido de cadena que el de la derecha.</target>
        </trans-unit>
        <trans-unit id="3426ef0b6b1032306f9e34d92f3217cb3cb8f9b5" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;ne&quot;&lt;/code&gt; returns true if the left argument is stringwise not equal to the right argument.</source>
          <target state="translated">El &lt;code&gt;&quot;ne&quot;&lt;/code&gt; binario devuelve verdadero si el argumento de la izquierda no es igual al argumento de la derecha.</target>
        </trans-unit>
        <trans-unit id="6e48afc6b41691d3b8112c62d6f3d75de7761a17" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;or&quot;&lt;/code&gt; returns the logical disjunction of the two surrounding expressions. It's equivalent to &lt;code&gt;||&lt;/code&gt; except for the very low precedence. This makes it useful for control flow:</source>
          <target state="translated">Binario &lt;code&gt;&quot;or&quot;&lt;/code&gt; devuelve la disyunci&amp;oacute;n l&amp;oacute;gica de las dos expresiones circundantes. Es equivalente a &lt;code&gt;||&lt;/code&gt; excepto por la muy baja precedencia. Esto lo hace &amp;uacute;til para controlar el flujo:</target>
        </trans-unit>
        <trans-unit id="6eadcc721bf945b4975372194a62fd2f4732fb22" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;x&quot;&lt;/code&gt; is the repetition operator. In scalar context or if the left operand is not enclosed in parentheses, it returns a string consisting of the left operand repeated the number of times specified by the right operand. In list context, if the left operand is enclosed in parentheses or is a list formed by &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt;, it repeats the list. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="translated">La &lt;code&gt;&quot;x&quot;&lt;/code&gt; binaria es el operador de repetici&amp;oacute;n. En contexto escalar o si el operando izquierdo no est&amp;aacute; encerrado entre par&amp;eacute;ntesis, devuelve una cadena que consiste en el operando izquierdo repetido el n&amp;uacute;mero de veces especificado por el operando derecho. En el contexto de la lista, si el operando de la izquierda est&amp;aacute; entre par&amp;eacute;ntesis o es una lista formada por &lt;code&gt;qw/&lt;i&gt;STRING&lt;/i&gt;/&lt;/code&gt; , repite la lista. Si el operando derecho es cero o negativo (generando una advertencia en negativo), devuelve una cadena vac&amp;iacute;a o una lista vac&amp;iacute;a, seg&amp;uacute;n el contexto.</target>
        </trans-unit>
        <trans-unit id="9999af54fad183fd5d0cedce55d894dad6f9d4fe" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;xor&quot;&lt;/code&gt; returns the exclusive-OR of the two surrounding expressions. It cannot short-circuit (of course).</source>
          <target state="translated">El binario &lt;code&gt;&quot;xor&quot;&lt;/code&gt; devuelve el OR exclusivo de las dos expresiones circundantes. No puede cortocircuitar (por supuesto).</target>
        </trans-unit>
        <trans-unit id="878a38ea354402b8caaeaced244837f05ba0dd57" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;|&quot;&lt;/code&gt; returns its operands ORed together bit by bit.</source>
          <target state="translated">Binario &lt;code&gt;&quot;|&quot;&lt;/code&gt; devuelve sus operandos OR juntos bit a bit.</target>
        </trans-unit>
        <trans-unit id="b1489d43a3216d7ad2c82c2a95acd60755df1162" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;||&quot;&lt;/code&gt; performs a short-circuit logical OR operation. That is, if the left operand is true, the right operand is not even evaluated. Scalar or list context propagates down to the right operand if it is evaluated.</source>
          <target state="translated">Binario &lt;code&gt;&quot;||&quot;&lt;/code&gt; realiza una operaci&amp;oacute;n OR l&amp;oacute;gica de cortocircuito. Es decir, si el operando izquierdo es verdadero, el operando derecho ni siquiera se eval&amp;uacute;a. El contexto escalar o de lista se propaga hasta el operando derecho si se eval&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="f92bb398898c648f24279f387f99c6d49704c347" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;&quot;~~&quot;&lt;/code&gt; does a smartmatch between its arguments. Smart matching is described in the next section.</source>
          <target state="translated">El binario &lt;code&gt;&quot;~~&quot;&lt;/code&gt; hace una coincidencia inteligente entre sus argumentos. La coincidencia inteligente se describe en la siguiente secci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="474b37cbe0d6e0c72ec20c7e955273bab42d36ef" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;isa&lt;/code&gt; evaluates to true when the left argument is an object instance of the class (or a subclass derived from that class) given by the right argument. If the left argument is not defined, not a blessed object instance, nor does not derive from the class given by the right argument, the operator evaluates as false. The right argument may give the class either as a bareword or a scalar expression that yields a string class name:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47cc7ad1e48a139eed3a38cd085aae1011cbc98f" translate="yes" xml:space="preserve">
          <source>Binary &lt;code&gt;x&lt;/code&gt; is the repetition operator. In scalar context, or if the left operand is neither enclosed in parentheses nor a &lt;code&gt;qw//&lt;/code&gt; list, it performs a string repetition. In that case it supplies scalar context to the left operand, and returns a string consisting of the left operand string repeated the number of times specified by the right operand. If the &lt;code&gt;x&lt;/code&gt; is in list context, and the left operand is either enclosed in parentheses or a &lt;code&gt;qw//&lt;/code&gt; list, it performs a list repetition. In that case it supplies list context to the left operand, and returns a list consisting of the left operand list repeated the number of times specified by the right operand. If the right operand is zero or negative (raising a warning on negative), it returns an empty string or an empty list, depending on the context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39d7bf96b3a657465e5f87b07b34fa4dafeb1ef4" translate="yes" xml:space="preserve">
          <source>Binary backward compatibility; this function is a macro but also has a &lt;code&gt;Perl_&lt;/code&gt; implementation (which is exported).</source>
          <target state="translated">Compatibilidad binaria con versiones anteriores; esta funci&amp;oacute;n es una macro pero tambi&amp;eacute;n tiene una implementaci&amp;oacute;n &lt;code&gt;Perl_&lt;/code&gt; (que se exporta).</target>
        </trans-unit>
        <trans-unit id="be16b35ee218fa359867cb0e97728996cffd42bc" translate="yes" xml:space="preserve">
          <source>Binary distributions for some proprietary platforms can be found &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; directory. Because these are not part of the standard distribution, they may and in fact do differ from the base perl port in a variety of ways. You'll have to check their respective release notes to see just what the differences are. These differences can be either positive (e.g. extensions for the features of the particular platform that are not supported in the source release of perl) or negative (e.g. might be based upon a less current source release of perl).</source>
          <target state="translated">Las distribuciones binarias para algunas plataformas propietarias se pueden encontrar en el directorio &lt;a href=&quot;http://www.cpan.org/ports/&quot;&gt;http://www.cpan.org/ports/&lt;/a&gt; . Debido a que estos no son parte de la distribuci&amp;oacute;n est&amp;aacute;ndar, pueden diferir y de hecho difieren del puerto perl base en una variedad de formas. Tendr&amp;aacute; que consultar sus respectivas notas de la versi&amp;oacute;n para ver cu&amp;aacute;les son las diferencias. Estas diferencias pueden ser positivas (por ejemplo, extensiones para las caracter&amp;iacute;sticas de la plataforma en particular que no son compatibles con la versi&amp;oacute;n de origen de perl) o negativas (por ejemplo, pueden basarse en una versi&amp;oacute;n de fuente de perl menos actual).</target>
        </trans-unit>
        <trans-unit id="55fd3c0a11bb58bb23e20465875244f2ca59b441" translate="yes" xml:space="preserve">
          <source>Binary installer also creates a folder on your desktop with some useful objects. If you need to change some aspects of the work of the binary installer, feel free to edit the file</source>
          <target state="translated">El instalador binario también crea una carpeta en el escritorio con algunos objetos útiles.Si necesita cambiar algunos aspectos del trabajo del instalador binario,no dude en editar el archivo</target>
        </trans-unit>
        <trans-unit id="b3b1f88d8a58f93a423339c57b3f74f2d820a432" translate="yes" xml:space="preserve">
          <source>Binary number &amp;gt; 0b11111111111111111111111111111111 non-portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1c1ba08fb761b34a695ec927e7b1037b80a83ca" translate="yes" xml:space="preserve">
          <source>Binary strings (byte strings)</source>
          <target state="translated">Cadenas binarias (cadenas de bytes)</target>
        </trans-unit>
        <trans-unit id="9a138af365fa894e34cab06b679f370e8157841c" translate="yes" xml:space="preserve">
          <source>Binding Operators</source>
          <target state="translated">Operadores de encuadernación</target>
        </trans-unit>
        <trans-unit id="73bb8553f0429ab1a4f3db6aa26eab8529fc1962" translate="yes" xml:space="preserve">
          <source>Binding together several statements in a macro</source>
          <target state="translated">Reuniendo varias declaraciones en una macro</target>
        </trans-unit>
        <trans-unit id="be19add4d0d70fd9e2b19a5940d1ed397561b92a" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;a href=&quot;http://man.he.net/man2/bind&quot;&gt;bind(2)&lt;/a&gt; does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee51bd7870301b5b50c94bd801894ab927735dc" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as &lt;code&gt;bind(2)&lt;/code&gt; does. Returns true if it succeeded, false otherwise. You should provide a packed address of the appropriate type for the socket.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5549ae8d615ef700c81551ae6af123d2f95aacb7" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Vincula una direcci&amp;oacute;n de red a un socket, tal como lo hace bind (2). Devuelve verdadero si tuvo &amp;eacute;xito, falso en caso contrario. NAME debe ser una direcci&amp;oacute;n empaquetada del tipo apropiado para el socket. Consulte los ejemplos en &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: comunicaci&amp;oacute;n cliente / servidor en perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="9fa331f367a4577bd9809395dd5e94974930bded" translate="yes" xml:space="preserve">
          <source>Binds a network address to a socket, just as bind(2) does. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Vincula una direcci&amp;oacute;n de red a un socket, tal como lo hace bind (2). Devuelve verdadero si tuvo &amp;eacute;xito, falso en caso contrario. NAME debe ser una direcci&amp;oacute;n empaquetada del tipo apropiado para el socket. Consulte los ejemplos en &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: comunicaci&amp;oacute;n cliente / servidor en perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1d4a984a59802112ea9e0afc9140f13f4e5333e8" translate="yes" xml:space="preserve">
          <source>Binmode</source>
          <target state="translated">Binmode</target>
        </trans-unit>
        <trans-unit id="6974d8c4576a73016b6ecc19f5a2ebc538fab746" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="translated">Birrell, Andrew D. Introducci&amp;oacute;n a la programaci&amp;oacute;n con subprocesos. Digital Equipment Corporation, 1989, DEC-SRC Research Report # 35 en l&amp;iacute;nea como &lt;a href=&quot;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&quot;&gt;ftp://ftp.dec.com/pub/DEC/SRC/research-reports/SRC-035.pdf&lt;/a&gt; (muy recomendado)</target>
        </trans-unit>
        <trans-unit id="36b5cf92c2fb97a05ef7bf770fab59d48c1cb050" translate="yes" xml:space="preserve">
          <source>Birrell, Andrew D. An Introduction to Programming with Threads. Digital Equipment Corporation, 1989, DEC-SRC Research Report #35 online as &lt;a href=&quot;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&quot;&gt;https://www.hpl.hp.com/techreports/Compaq-DEC/SRC-RR-35.pdf&lt;/a&gt; (highly recommended)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a110cc2137a88f53fa983eabf18c6a369cdd6cc9" translate="yes" xml:space="preserve">
          <source>Bisecting</source>
          <target state="translated">Bisecting</target>
        </trans-unit>
        <trans-unit id="f6106638b60c4b72e8832174afe58ef2d3da9922" translate="yes" xml:space="preserve">
          <source>Bit Complement Operator ~ And vec()</source>
          <target state="translated">Operador de Complemento de Bits ~ Y vec()</target>
        </trans-unit>
        <trans-unit id="c5e74747e30dab25d0878fbe61b78c61e44df4c0" translate="yes" xml:space="preserve">
          <source>Bit Strings</source>
          <target state="translated">Cuerdas de bits</target>
        </trans-unit>
        <trans-unit id="ba34e7ebde4a9f60d96348693e30b97a898d1671" translate="yes" xml:space="preserve">
          <source>Bit vector size &amp;gt; 32 non-portable</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="833619884d42232d65498c141d5b13c648753213" translate="yes" xml:space="preserve">
          <source>Bits are the atoms in the memory world. Access to individual bits may have to be used either as a last resort or because it is the most convenient way to handle your data. Bit string (un)packing converts between strings containing a series of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt; characters and a sequence of bytes each containing a group of 8 bits. This is almost as simple as it sounds, except that there are two ways the contents of a byte may be written as a bit string. Let's have a look at an annotated byte:</source>
          <target state="translated">Los bits son los &amp;aacute;tomos del mundo de la memoria. Es posible que deba utilizar el acceso a bits individuales como &amp;uacute;ltimo recurso o porque es la forma m&amp;aacute;s conveniente de manejar sus datos. El (des) empaquetado de cadenas de bits convierte cadenas que contienen una serie de &lt;code&gt;0&lt;/code&gt; y &lt;code&gt;1&lt;/code&gt; caracteres y una secuencia de bytes, cada una de las cuales contiene un grupo de 8 bits. Esto es casi tan simple como parece, excepto que hay dos formas en que el contenido de un byte puede escribirse como una cadena de bits. Echemos un vistazo a un byte anotado:</target>
        </trans-unit>
        <trans-unit id="8d8367155a1b407dd5a8766f2b3e58679136cc71" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="translated">Bits que el &lt;b&gt;propietario&lt;/b&gt; de un archivo establece o desarma para permitir o no permitir el acceso a otras personas. Estos bits de bandera son parte de la palabra de &lt;b&gt;modo&lt;/b&gt; devuelta por la &lt;code&gt;&lt;a href=&quot;functions/stat&quot;&gt;stat&lt;/a&gt;&lt;/code&gt; incorporada cuando pregunta sobre un archivo. En los sistemas Unix, puede comprobar el</target>
        </trans-unit>
        <trans-unit id="aca05ef0109989b493ae0975df5c4747401f63d8" translate="yes" xml:space="preserve">
          <source>Bits that the &lt;b&gt;owner&lt;/b&gt; of a file sets or unsets to allow or disallow access to other people. These flag bits are part of the &lt;b&gt;mode&lt;/b&gt; word returned by the &lt;code&gt;stat&lt;/code&gt; built-in when you ask about a file. On Unix systems, you can check the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9166fa867213d69681d8dc9ba4c66e0e28bd7ae5" translate="yes" xml:space="preserve">
          <source>Bitstrings of any size may be manipulated by the bitwise operators (&lt;code&gt;~ | &amp;amp; ^&lt;/code&gt;).</source>
          <target state="translated">Los operadores bit a bit ( &lt;code&gt;~ | &amp;amp; ^&lt;/code&gt; ) pueden manipular cadenas de bits de cualquier tama&amp;ntilde;o .</target>
        </trans-unit>
        <trans-unit id="55bcce66fdecceeb947a789cd32be9b93c7eca65" translate="yes" xml:space="preserve">
          <source>Bitwise And</source>
          <target state="translated">Un poco más inteligente y...</target>
        </trans-unit>
        <trans-unit id="b636b8ad1b24ac557aa4eb2c5b388de819e1c9dc" translate="yes" xml:space="preserve">
          <source>Bitwise Or and Exclusive Or</source>
          <target state="translated">Bitwise Or y Exclusive Or</target>
        </trans-unit>
        <trans-unit id="e12b00fd649b7b2d92cbde1fe11e2e094a03730b" translate="yes" xml:space="preserve">
          <source>Bitwise String Operators</source>
          <target state="translated">Operadores de cuerdas de bits</target>
        </trans-unit>
        <trans-unit id="60dab14d1038a5ab6653c6e814d064d60e1699d8" translate="yes" xml:space="preserve">
          <source>Bitwise methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dc97888788cc1b09dac9d2412a98d54e24f8b1e" translate="yes" xml:space="preserve">
          <source>Bitwise operators</source>
          <target state="translated">Los operadores de Bitwise</target>
        </trans-unit>
        <trans-unit id="8a7fb7c64ed6d34c679867c6172b911e0f987e0b" translate="yes" xml:space="preserve">
          <source>Bitwise operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6124b539fbe18e72605192e10e84abc660b435" translate="yes" xml:space="preserve">
          <source>Bizarre SvTYPE [%d]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6569857bf0d6ff7a8e148a4adb3a9e8ee5c017ec" translate="yes" xml:space="preserve">
          <source>Bizarre copy of %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d97eb984318634f0d968a3f61bf23fd2faf3f45b" translate="yes" xml:space="preserve">
          <source>Bizarre space in item</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea2480b20b616fff68feba2feb22ee1344013e9a" translate="yes" xml:space="preserve">
          <source>Blank lines between chunks that do different things.</source>
          <target state="translated">Líneas en blanco entre trozos que hacen cosas diferentes.</target>
        </trans-unit>
        <trans-unit id="920da8ab7902a7645d8456f5c8da1988c54e0d83" translate="yes" xml:space="preserve">
          <source>Blessed References and Class Objects</source>
          <target state="translated">Benditas referencias y objetos de clase</target>
        </trans-unit>
        <trans-unit id="68214e18c0b1867aaa68202e63eba7567e9b30a9" translate="yes" xml:space="preserve">
          <source>Blessed objects are not directly representable in JSON, but &lt;code&gt;JSON::PP&lt;/code&gt; allows various ways of handling objects. See &lt;a href=&quot;#OBJECT-SERIALISATION&quot;&gt;&quot;OBJECT SERIALISATION&quot;&lt;/a&gt;, below, for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79c23f408055d193d91f1b67442a45565695178a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;&lt;a href=&quot;#gv_stashpv&quot;&gt;&quot;gv_stashpv&quot;&lt;/a&gt;&lt;/code&gt;). The reference count of the SV is unaffected.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7954a73ad696d763789ec0de2fb44af6092e878a" translate="yes" xml:space="preserve">
          <source>Blesses an SV into a specified package. The SV must be an RV. The package must be designated by its stash (see &lt;code&gt;gv_stashpv()&lt;/code&gt; ). The reference count of the SV is unaffected.</source>
          <target state="translated">Bendice un SV en un paquete espec&amp;iacute;fico. El SV debe ser un RV. El paquete debe estar designado por su alijo (ver &lt;code&gt;gv_stashpv()&lt;/code&gt; ). El recuento de referencia del SV no se ve afectado.</target>
        </trans-unit>
        <trans-unit id="e54f1e0cbee429156b492ed8b4b751701cbcbd26" translate="yes" xml:space="preserve">
          <source>Blessing</source>
          <target state="translated">Blessing</target>
        </trans-unit>
        <trans-unit id="548174d374d3a6d330e0dce28420c09b6c8a9390" translate="yes" xml:space="preserve">
          <source>Blessing a shared item after it has been nested in another shared item does not propagate the blessing to the shared reference:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e84551f3c75d4af55438233d1c2c7909c862fc3b" translate="yes" xml:space="preserve">
          <source>Blindly passing va_list</source>
          <target state="translated">Pasando a ciegas la va_lista</target>
        </trans-unit>
        <trans-unit id="929de0b7c4802448411e951e5153fd25660c3b1f" translate="yes" xml:space="preserve">
          <source>Blindly using variadic macros</source>
          <target state="translated">Usando a ciegas macros variadas</target>
        </trans-unit>
        <trans-unit id="82dd2cdf36f9436d89f404454654ad3e53fd428d" translate="yes" xml:space="preserve">
          <source>Block</source>
          <target state="translated">Block</target>
        </trans-unit>
        <trans-unit id="3df7eee072ad8f186abf1b2d2565ea2787bb93b4" translate="yes" xml:space="preserve">
          <source>Block eval</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bf3b25756dcb70819ec2e3fa0ac57e7ce3a0990" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . Unlike most other properties, only a few block names have a Unicode-defined short name. But Perl does provide a (slight, no longer recommended) shortcut: You can say, for example &lt;code&gt;\p{In_Arrows}&lt;/code&gt; or &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</source>
          <target state="translated">Los nombres de los bloques se hacen coincidir en forma compuesta, como &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; o &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt; . A diferencia de la mayor&amp;iacute;a de las otras propiedades, solo unos pocos nombres de bloque tienen un nombre corto definido por Unicode. Pero Perl proporciona un atajo (leve, ya no recomendado): puede decir, por ejemplo, &lt;code&gt;\p{In_Arrows}&lt;/code&gt; o &lt;code&gt;\p{In_Hebrew}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="75cda6989df1a079fcf560c9e780003cd931ab30" translate="yes" xml:space="preserve">
          <source>Block names are matched in the compound form, like &lt;code&gt;\p{Block: Arrows}&lt;/code&gt; or &lt;code&gt;\p{Blk=Hebrew}&lt;/code&gt;. Unlike most other properties, only a few block names have a Unicode-defined short name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d785c0d4b3b9c24878b62f64a7bcf78e9506ab27" translate="yes" xml:space="preserve">
          <source>Blocking</source>
          <target state="translated">Blocking</target>
        </trans-unit>
        <trans-unit id="bbaa0510707f42633a5b2810cc339df2222d09f5" translate="yes" xml:space="preserve">
          <source>Blocking =&amp;gt; BOOL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54c45c033f5eb914fae27a646cbd9e23d3750d19" translate="yes" xml:space="preserve">
          <source>Blocks</source>
          <target state="translated">Blocks</target>
        </trans-unit>
        <trans-unit id="91c2278276bfdf926da91f0d87d6f0041b36f310" translate="yes" xml:space="preserve">
          <source>Blocks versus Scripts</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06992d2c6a4fd06aa405eff11e7109cec33fa12f" translate="yes" xml:space="preserve">
          <source>Blueprint</source>
          <target state="translated">Blueprint</target>
        </trans-unit>
        <trans-unit id="9febcf64ddd4a1c589fafb6acc27a333296a03c8" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the message.</source>
          <target state="translated">Cuerpo del informe. Si no est&amp;aacute; incluido en la l&amp;iacute;nea de comando, o en un archivo con &lt;b&gt;-f&lt;/b&gt; , tendr&amp;aacute; la oportunidad de editar el mensaje.</target>
        </trans-unit>
        <trans-unit id="b1b26c9b3704fe7427bfc6aa57886af38bc8fd15" translate="yes" xml:space="preserve">
          <source>Body of the report. If not included on the command line, or in a file with &lt;b&gt;-f&lt;/b&gt;, you will get a chance to edit the report.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2dcad692e8a39400b913368019fc7eef1d73269" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">Versi&amp;oacute;n en negrita cursiva (probablemente oblicua) de la fuente de ancho fijo. Pod :: Man no asume que tienes esto, y por defecto es &lt;code&gt;CB&lt;/code&gt; . Algunos sistemas (como Solaris) tienen esta fuente disponible como &lt;code&gt;CX&lt;/code&gt; . Solo importa para la salida de &lt;b&gt;troff&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="9e34e43ca3b41295b323939a7bd9811db605af24" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt; . Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">Versi&amp;oacute;n en negrita cursiva (probablemente oblicua) de la fuente de ancho fijo. Pod :: Man no asume que tienes esto, y por defecto es &lt;code&gt;CB&lt;/code&gt; . Algunos sistemas (como Solaris) tienen esta fuente disponible como &lt;code&gt;CX&lt;/code&gt; . Solo importa para la salida troff (1).</target>
        </trans-unit>
        <trans-unit id="feeb11edec497ca4f54c665a95df5130b4c829b2" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="302306e8a29ac5f2d9ddbda14d6dbb86f08c19c5" translate="yes" xml:space="preserve">
          <source>Bold italic (probably actually oblique) version of the fixed-width font. Pod::Man doesn't assume you have this, and defaults to &lt;code&gt;CB&lt;/code&gt;. Some systems (such as Solaris) have this font available as &lt;code&gt;CX&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9abc1cd480871c700b51d43c9a44b554d40d55c" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="translated">Versi&amp;oacute;n en negrita de la fuente de ancho fijo. Por defecto es &lt;code&gt;CB&lt;/code&gt; . Solo importa para la salida de &lt;b&gt;troff&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="73204c593462d6c14f32f02ba63b55da40420528" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt; . Only matters for troff(1) output.</source>
          <target state="translated">Versi&amp;oacute;n en negrita de la fuente de ancho fijo. Por defecto es &lt;code&gt;CB&lt;/code&gt; . Solo importa para la salida troff (1).</target>
        </trans-unit>
        <trans-unit id="4826fec0f048131f813dc8e60e9509d935802a38" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for &lt;b&gt;troff&lt;/b&gt; output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21be102197e929754c4d027624958a11458b8256" translate="yes" xml:space="preserve">
          <source>Bold version of the fixed-width font. Defaults to &lt;code&gt;CB&lt;/code&gt;. Only matters for troff(1) output.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3cddd25bd8f6bc4ce35a262e2e1398541ecf3d" translate="yes" xml:space="preserve">
          <source>Bookmarks</source>
          <target state="translated">Bookmarks</target>
        </trans-unit>
        <trans-unit id="fbe3448227f9beab3e352c0b7e28a363ba97c273" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="translated">Bool. Si este par&amp;aacute;metro es verdadero, no tener los m&amp;oacute;dulos requeridos (o las versiones correctas de los mismos) ser&amp;aacute; fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; va &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; en lugar de simplemente informar al usuario de las dependencias faltantes.</target>
        </trans-unit>
        <trans-unit id="aa02db7b0e1536fcc3f6de1b2a7dcf01412dc0c6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, failing to have the required modules (or the right versions thereof) will be fatal. &lt;code&gt;perl Makefile.PL&lt;/code&gt; will &lt;code&gt;die&lt;/code&gt; instead of simply informing the user of the missing dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a706d5f747a56fb59b2b20adabd115aadfc3ab6" translate="yes" xml:space="preserve">
          <source>Bool. If this parameter is true, the prerequisites will be printed to stdout and MakeMaker will exit. The output format is an evalable hash ref.</source>
          <target state="translated">Bool.Si este parámetro es verdadero,los prerrequisitos se imprimirán en stdout y MakeMaker saldrá.El formato de salida es un hash ref evaluable.</target>
        </trans-unit>
        <trans-unit id="b76ff4906f33c2dd97ddd929b9662ba8cac6174c" translate="yes" xml:space="preserve">
          <source>Boolean</source>
          <target state="translated">Boolean</target>
        </trans-unit>
        <trans-unit id="09eca632f0dfa4476bacf2f878b87c41a27eb16f" translate="yes" xml:space="preserve">
          <source>Boolean context</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02eefeb78b1690ec4b9fb5543382dba69c8c96d9" translate="yes" xml:space="preserve">
          <source>Boolean logic</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee421eba15aa24904646f6184653841c5c549d1" translate="yes" xml:space="preserve">
          <source>Boolean methods</source>
          <target state="translated">Métodos booleanos</target>
        </trans-unit>
        <trans-unit id="02774d2bd49b309c70bcbf1cd2d7f51fdc3d2b2f" translate="yes" xml:space="preserve">
          <source>Boolean operators</source>
          <target state="translated">Los operadores booleanos</target>
        </trans-unit>
        <trans-unit id="55aef5e3c5e0b75d499308ca6279e82ab808182b" translate="yes" xml:space="preserve">
          <source>Boolean operators &lt;code&gt;is_zero()&lt;/code&gt;, &lt;code&gt;is_one()&lt;/code&gt;, &lt;code&gt;is_inf()&lt;/code&gt;, etc. return true or false.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1e109ffb226c19879bd546df66c824f1e645625c" translate="yes" xml:space="preserve">
          <source>Boolean options:</source>
          <target state="translated">Opciones booleanas:</target>
        </trans-unit>
        <trans-unit id="c8c3f1d753ec555418a750eeff6d7eaeba2abf76" translate="yes" xml:space="preserve">
          <source>Boolean value. If false, disables the &lt;code&gt;X/Y&lt;/code&gt; test count which shows up while tests are running.</source>
          <target state="translated">Valor booleano. Si es falso, deshabilita el recuento de pruebas &lt;code&gt;X/Y&lt;/code&gt; que aparece mientras se est&amp;aacute;n ejecutando las pruebas.</target>
        </trans-unit>
        <trans-unit id="f6906832f4c5efb1eff6981bd8a551cf05deba12" translate="yes" xml:space="preserve">
          <source>Boolean which tells MakeMaker that it should include the rules to make a perl. This is handled automatically as a switch by MakeMaker. The user normally does not need it.</source>
          <target state="translated">Booleana que le dice a MakeMaker que debe incluir las reglas para hacer un perl.Esto es manejado automáticamente como un cambio por MakeMaker.El usuario normalmente no lo necesita.</target>
        </trans-unit>
        <trans-unit id="a3aa9ead54da3d9f1481bd131dbbec1f59ea0c12" translate="yes" xml:space="preserve">
          <source>Boolean. Attribute to inhibit descending into subdirectories.</source>
          <target state="translated">Booleana.Atributo para inhibir el descenso a subdirectorios.</target>
        </trans-unit>
        <trans-unit id="09273e0b3502cd35874b01a3ba91c106f87a667f" translate="yes" xml:space="preserve">
          <source>Bootstrapping</source>
          <target state="translated">Bootstrapping</target>
        </trans-unit>
        <trans-unit id="62ac59b7255ce5ff9fee8ac49157bdd9bc4445e2" translate="yes" xml:space="preserve">
          <source>Bosnia and Herzegovina</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7cf7bb36f8e532fed41b905555bc401b988f86c8" translate="yes" xml:space="preserve">
          <source>Boss/Worker</source>
          <target state="translated">Boss/Worker</target>
        </trans-unit>
        <trans-unit id="80bcf52e7840ffd18cf3865b5ebb50a306bef71b" translate="yes" xml:space="preserve">
          <source>Both &quot;objects&quot; which are blessed into the class &lt;code&gt;two_refs1&lt;/code&gt; are references to a reference to an array, thus references to a</source>
          <target state="translated">Ambos &quot;objetos&quot; que est&amp;aacute;n bendecidos en la clase &lt;code&gt;two_refs1&lt;/code&gt; son referencias a una referencia a una matriz, por lo tanto, referencias a una</target>
        </trans-unit>
        <trans-unit id="fdd5582984ca6c53c867eacfa38935bd769631ff" translate="yes" xml:space="preserve">
          <source>Both #1 and #2 make $data consist of a completely valid UTF-8 string, but only #2 turns the UTF8 flag on. #1 is equivalent to:</source>
          <target state="translated">Tanto el número 1 como el número 2 hacen que los $datos consistan en una cadena UTF-8 completamente válida,pero sólo el número 2 enciende la bandera UTF8.#El número 1 es equivalente a:</target>
        </trans-unit>
        <trans-unit id="e055e854ed20a46d2f7df7544241f7588b51f8b0" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as automated stringify via overload now drop the leading '+'. The old code would return '+3', the new returns '3'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;../test/more&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="translated">Tanto &lt;code&gt;bstr()&lt;/code&gt; como &lt;code&gt;bsstr()&lt;/code&gt; , as&amp;iacute; como la secuenciaci&amp;oacute;n automatizada a trav&amp;eacute;s de sobrecarga, ahora eliminan el '+' inicial. El c&amp;oacute;digo anterior devolver&amp;iacute;a '+3', el nuevo devuelve '3'. Esto es para ser coherente con Perl y hacer que &lt;code&gt;cmp&lt;/code&gt; (especialmente con sobrecarga) funcione como espera. Tambi&amp;eacute;n resuelve problemas con &lt;code&gt;Test.pm&lt;/code&gt; y &lt;a href=&quot;../test/more&quot;&gt;Test :: More&lt;/a&gt; , que encadenan los argumentos antes de compararlos.</target>
        </trans-unit>
        <trans-unit id="a620ebe99c93fe5ad5f0770d99e27217bee38fe8" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;bsstr()&lt;/code&gt; as well as stringify via overload drop the leading '+'. This is to be consistent with Perl and to make &lt;code&gt;cmp&lt;/code&gt; (especially with overloading) to work as you expect. It also solves problems with &lt;code&gt;Test.pm&lt;/code&gt; and &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt;, which stringify arguments before comparing them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eaeb9ffa94e14cf78c87073a072611e3232fa148" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="translated">Tanto &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; ACCENT}&quot;) y checkNFC (&quot;B \ N {COMBINING AGUTE ACCENT}&quot;) devolver&amp;aacute;n &lt;code&gt;MAYBE&lt;/code&gt; . &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; no est&amp;aacute; en NFC (su NFC es &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt; ), mientras que &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; est&amp;aacute; en NFC.</target>
        </trans-unit>
        <trans-unit id="4a5a39017b338373b526416f145175959e75a080" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;checkNFC(&quot;A\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; and &lt;code&gt;checkNFC(&quot;B\N{COMBINING ACUTE ACCENT}&quot;)&lt;/code&gt; will return &lt;code&gt;MAYBE&lt;/code&gt;. &lt;code&gt;&quot;A\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is not in NFC (its NFC is &lt;code&gt;&quot;\N{LATIN CAPITAL LETTER A WITH ACUTE}&quot;&lt;/code&gt;), while &lt;code&gt;&quot;B\N{COMBINING ACUTE ACCENT}&quot;&lt;/code&gt; is in NFC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0dc99557ca052a1f52b6aa9fe01653c0b56cfaf" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;cmp&lt;/code&gt; and &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; operators perform the same comparison between terms (upgrading to a version object automatically). Perl automatically generates all of the other comparison operators based on those two. In addition to the obvious equalities listed below, appending a single trailing 0 term does not change the value of a version for comparison purposes. In other words &quot;v1.2&quot; and &quot;1.2.0&quot; will compare as identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24cf9e2240da639243f4502d5aa3bda3947c5953" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; croak if given dates outside the supported range.</source>
          <target state="translated">Tanto &lt;code&gt;timelocal()&lt;/code&gt; como &lt;code&gt;timegm()&lt;/code&gt; si se dan fechas fuera del rango admitido.</target>
        </trans-unit>
        <trans-unit id="9b6b1830495cedccd8298426103e7c2b6bedc5b6" translate="yes" xml:space="preserve">
          <source>Both &lt;code&gt;wrap()&lt;/code&gt; and &lt;code&gt;fill()&lt;/code&gt; return a single string.</source>
          <target state="translated">Tanto &lt;code&gt;wrap()&lt;/code&gt; como &lt;code&gt;fill()&lt;/code&gt; devuelven una sola cadena.</target>
        </trans-unit>
        <trans-unit id="a3b45c366057bea34b5a8bb7824f2e8dd99b7496" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt; , and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="translated">Ambas funciones de Perl esperar&amp;aacute;n un objeto como primer par&amp;aacute;metro. En el c&amp;oacute;digo C ++ generado, el objeto se llama &lt;code&gt;THIS&lt;/code&gt; , y la llamada al m&amp;eacute;todo se realizar&amp;aacute; en este objeto. Entonces, en el c&amp;oacute;digo C ++, los m&amp;eacute;todos blue () y set_blue () se llamar&amp;aacute;n as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="7be927e1ed4202312ce2dde8192f9556312f51fd" translate="yes" xml:space="preserve">
          <source>Both Perl functions will expect an object as the first parameter. In the generated C++ code the object is called &lt;code&gt;THIS&lt;/code&gt;, and the method call will be performed on this object. So in the C++ code the blue() and set_blue() methods will be called as this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="642b008f0bb09ab02b4608dfe561ba3f906e665d" translate="yes" xml:space="preserve">
          <source>Both YAML.pm and YAML::Syck are capable of deserialising code. As this requires a string eval, which might be a security risk, you can use this option to enable or disable the deserialisation of code via CPAN::DeferredCode. (Note: This does not work under perl 5.6)</source>
          <target state="translated">Tanto YAML.pm como YAML::Syck son capaces de deserializar el código.Como esto requiere una evaluación de la cadena,lo que podría ser un riesgo de seguridad,puedes usar esta opción para habilitar o deshabilitar la deserialización del código a través de CPAN::DeferredCode.(Nota:Esto no funciona bajo el perl 5.6)</target>
        </trans-unit>
        <trans-unit id="1092e6af8de8fc50cc6d06fd73a32b5d8423a7e9" translate="yes" xml:space="preserve">
          <source>Both are bad, and broken, and unportable. Use the PTR2IV() macro that does it right. (Likewise, there are PTR2UV(), PTR2NV(), INT2PTR(), and NUM2PTR().)</source>
          <target state="translated">Ambas son malas,y están rotas,y no son portátiles.Usa la macro PTR2IV()que lo hace bien.(De la misma manera,hay PTR2UV(),PTR2NV(),INT2PTR(),y NUM2PTR().)</target>
        </trans-unit>
        <trans-unit id="e8f3fbafa937e38c34348185c6cef931d0a050c2" translate="yes" xml:space="preserve">
          <source>Both colored() and many uses of the color constants will add the reset escape sequence after a newline. If a program mixes colored output to standard output with output to standard error, this can result in the standard error text having the wrong color because the reset escape sequence hasn't yet been flushed to the display (since standard output to a terminal is line-buffered by default). To avoid this, either set autoflush() on STDOUT or set $Term::ANSIColor::EACHLINE to &lt;code&gt;&quot;\n&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3767903b8fab9710d5f5dbf8d10a9f6252cdd29" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; or &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org/dist/CPAN-Reporter/&lt;/a&gt;.</source>
          <target state="translated">Ambos esfuerzos dan la bienvenida a voluntarios. Para participar en las pruebas de humo del perl mismo, visite &lt;a href=&quot;http://search.cpan.org/dist/Test-Smoke/&quot;&gt;http://search.cpan.org/dist/Test-Smoke/&lt;/a&gt; . Para comenzar a probar los m&amp;oacute;dulos CPAN de humo, visite &lt;a href=&quot;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&quot;&gt;http://search.cpan.org/dist/CPANPLUS-YACSmoke/&lt;/a&gt; o &lt;a href=&quot;http://search.cpan.org/dist/minismokebox/&quot;&gt;http://search.cpan.org/dist/minismokebox/&lt;/a&gt; o &lt;a href=&quot;http://search.cpan.org/dist/CPAN-Reporter/&quot;&gt;http://search.cpan.org / dist / CPAN-Reporter /&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ae562d3087c6e461927df57072977056d07bc9d8" translate="yes" xml:space="preserve">
          <source>Both efforts welcome volunteers. In order to get involved in smoke testing of the perl itself visit &lt;a href=&quot;https://metacpan.org/release/Test-Smoke&quot;&gt;https://metacpan.org/release/Test-Smoke&lt;/a&gt;. In order to start smoke testing CPAN modules visit &lt;a href=&quot;https://metacpan.org/release/CPANPLUS-YACSmoke&quot;&gt;https://metacpan.org/release/CPANPLUS-YACSmoke&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/minismokebox&quot;&gt;https://metacpan.org/release/minismokebox&lt;/a&gt; or &lt;a href=&quot;https://metacpan.org/release/CPAN-Reporter&quot;&gt;https://metacpan.org/release/CPAN-Reporter&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55d4c4d23a88d207ea9fa065963f476f871b153f" translate="yes" xml:space="preserve">
          <source>Both encode and decode methods propagate &lt;a href=&quot;encode#Handling-Malformed-Data&quot;&gt;CHECK flags&lt;/a&gt; when encoding and decoding the MIME charset.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a1c59ffc42033f2c98187249f767826197ba8a8" translate="yes" xml:space="preserve">
          <source>Both forms are equivalent.</source>
          <target state="translated">Ambas formas son equivalentes.</target>
        </trans-unit>
        <trans-unit id="143f2cf2fc37f6046de22ba46473032b532447b9" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt; ) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="translated">Ambas funciones devuelven informaci&amp;oacute;n equivalente (como &lt;code&gt;gettimeofday&lt;/code&gt; ) pero con diferentes representaciones. Los nombres &lt;code&gt;NVtime&lt;/code&gt; y &lt;code&gt;U2time&lt;/code&gt; se seleccionaron principalmente porque son independientes del sistema operativo. ( &lt;code&gt;gettimeofday&lt;/code&gt; est&amp;aacute; centrado en Unix, aunque algunas plataformas como Win32 y VMS tienen emulaciones para ello).</target>
        </trans-unit>
        <trans-unit id="5c4e6f175302e55e83c34f1bf1849d831a9de257" translate="yes" xml:space="preserve">
          <source>Both functions return equivalent information (like &lt;code&gt;gettimeofday&lt;/code&gt;) but with different representations. The names &lt;code&gt;NVtime&lt;/code&gt; and &lt;code&gt;U2time&lt;/code&gt; were selected mainly because they are operating system independent. (&lt;code&gt;gettimeofday&lt;/code&gt; is Unix-centric, though some platforms like Win32 and VMS have emulations for it.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b934a70ce89ebfca7d59daaef7b8bcbcd00a0ef" translate="yes" xml:space="preserve">
          <source>Both install() and uninstall() are specific to the way ExtUtils::MakeMaker handles the installation and deinstallation of perl modules. They are not designed as general purpose tools.</source>
          <target state="translated">Tanto instalar()como desinstalar()son específicos de la forma en que ExtUtils::MakeMaker maneja la instalación y desinstalación de los módulos de perl.No están diseñados como herramientas de propósito general.</target>
        </trans-unit>
        <trans-unit id="5627699dd1ad2924464995985beca5c6cf35ef97" translate="yes" xml:space="preserve">
          <source>Both methods will prevent the import() method from firing and exporting the &lt;code&gt;qv()&lt;/code&gt; sub.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9733ec84f2ee4e84fe6e0d43084959736e1c222c" translate="yes" xml:space="preserve">
          <source>Both numeric and string values are accepted, but note that string values are case sensitive. The default for this setting is &quot;RANDOM&quot; or 1.</source>
          <target state="translated">Se aceptan tanto los valores numéricos como los de las cadenas,pero tenga en cuenta que los valores de las cadenas son sensibles a las mayúsculas y minúsculas.El valor predeterminado para este ajuste es &quot;ALEATORIO&quot; o 1.</target>
        </trans-unit>
        <trans-unit id="4cf5f58736e6000e5a6bd77d8280326d1b82a931" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt; ) for it.</source>
          <target state="translated">Ambos de los anteriores coinciden con los caracteres &lt;code&gt;\N{U+00}&lt;/code&gt; &lt;code&gt;\N{U+01}&lt;/code&gt; , ... &lt;code&gt;\N{U+08}&lt;/code&gt; , &lt;code&gt;\N{U+09}&lt;/code&gt; , pero &lt;code&gt;\x09&lt;/code&gt; parece que podr&amp;iacute;a ser un error, por lo que se genera la advertencia (bajo &lt;code&gt;re 'strict'&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="6cba8f2c40b0b7e7464484e646fc77656ccf2181" translate="yes" xml:space="preserve">
          <source>Both of the above match the characters &lt;code&gt;\N{U+00}&lt;/code&gt;&lt;code&gt;\N{U+01}&lt;/code&gt;, ... &lt;code&gt;\N{U+08}&lt;/code&gt;, &lt;code&gt;\N{U+09}&lt;/code&gt;, but the &lt;code&gt;\x09&lt;/code&gt; looks like it could be a mistake so the warning is raised (under &lt;code&gt;re 'strict'&lt;/code&gt;) for it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19034866ba0e5cf040b7023a16a969fddf08ed53" translate="yes" xml:space="preserve">
          <source>Both of the provided scalars are already compiled as regular expressions and do not contain either anchors or implicit groupings, so they can be included in your own regular expressions freely. For example, consider the following code:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6fc8a94496c661c5e9f86f3352074c1b6a4eef2" translate="yes" xml:space="preserve">
          <source>Both of these methods will produce similar version objects, in that the default stringification will yield the version &lt;a href=&quot;#Normal-Form&quot;&gt;&quot;Normal Form&quot;&lt;/a&gt; only if required:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a103cc718ae6b6f4898e4597463858c0b08dfa7" translate="yes" xml:space="preserve">
          <source>Both or neither range ends should be Unicode in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d4874cd0d5b99351b1bf775f190f16f304b87eaf" translate="yes" xml:space="preserve">
          <source>Both read and write access.</source>
          <target state="translated">Tanto el acceso a la lectura como a la escritura.</target>
        </trans-unit>
        <trans-unit id="e56fad1d57355bf08ff94859ec86b0170dc6755c" translate="yes" xml:space="preserve">
          <source>Both routines return a reference to the hash operated on.</source>
          <target state="translated">Ambas rutinas devuelven una referencia al hachís operado.</target>
        </trans-unit>
        <trans-unit id="7a1480fdf3f98f2170cd256ce3b56c618e9acd2d" translate="yes" xml:space="preserve">
          <source>Both signify the monospace (c[ode] style) text consisting of &quot;$x&quot;, one space, &quot;?&quot;, one space, &quot;:&quot;, one space, &quot;$z&quot;. The difference is that in the latter, with the S code, those spaces are not &quot;normal&quot; spaces, but instead are non-breaking spaces.</source>
          <target state="translated">Ambos significan el texto monoespacio (estilo c[ode])que consiste en &quot;$x&quot;,un espacio,&quot;?&quot;,un espacio,&quot;:&quot;,un espacio,&quot;$z&quot;.La diferencia es que en este último,con el código S,esos espacios no son espacios &quot;normales&quot;,sino que son espacios que no se rompen.</target>
        </trans-unit>
        <trans-unit id="ed699d8c766ffac9fc7609020189bb30a788c2d9" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;Math::BigInt&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9280ff05f374fc2e82bcdbf91ea7cf106541bf" translate="yes" xml:space="preserve">
          <source>Both stringify and bstr() now drop the leading '+'. The old code would return '+1.23', the new returns '1.23'. See the documentation in &lt;a href=&quot;bigint&quot;&gt;Math::BigInt&lt;/a&gt; for reasoning and details.</source>
          <target state="translated">Tanto stringify como bstr () ahora eliminan el '+' inicial. El c&amp;oacute;digo anterior devolver&amp;iacute;a '+1.23', el nuevo devuelve '1.23'. Consulte la documentaci&amp;oacute;n en &lt;a href=&quot;bigint&quot;&gt;Math :: BigInt&lt;/a&gt; para conocer el razonamiento y los detalles.</target>
        </trans-unit>
        <trans-unit id="6e26a4aa31b6884fed4ace8e2ed5cfef52233768" translate="yes" xml:space="preserve">
          <source>Both styles work with either objects or typeglobs of real filehandles. (They might also work with strings under some circumstances, but this is risky.)</source>
          <target state="translated">Ambos estilos funcionan con objetos o con glóbulos de mangos de archivos reales.(También podrían funcionar con cuerdas en algunas circunstancias,pero esto es arriesgado).</target>
        </trans-unit>
        <trans-unit id="40008ef1178df5187f4e9e86678b099b5c9935cc" translate="yes" xml:space="preserve">
          <source>Both subroutines here are called in a scalar context, while in:</source>
          <target state="translated">Ambas subrutinas aquí se llaman en un contexto escalar,mientras que en:</target>
        </trans-unit>
        <trans-unit id="88a5a602af253e21581322ee44c47e54f2ad5148" translate="yes" xml:space="preserve">
          <source>Both sysread() and recv() currently use only the &lt;code&gt;:utf8&lt;/code&gt; flag for the stream, ignoring the actual layers. Since sysread() and recv() do no UTF-8 validation they can end up creating invalidly encoded scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b8819b78d506b9303c55ca1c6cd1ccf91f01b90" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;$key&lt;/code&gt; and &lt;code&gt;$value&lt;/code&gt; parameters will be set to the key/value pair read from the database.</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;$key&lt;/code&gt; y &lt;code&gt;$value&lt;/code&gt; se establecer&amp;aacute;n en el par clave / valor le&amp;iacute;do de la base de datos.</target>
        </trans-unit>
        <trans-unit id="65ffa77ee21f2f134768654239d413a7ca561444" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt; ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt; ; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt; ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt; ing function should return the intended value if the key is valid.</source>
          <target state="translated">Tanto el &lt;code&gt;FETCH&lt;/code&gt; funci&amp;oacute;n de ING y la &lt;code&gt;EXISTS&lt;/code&gt; funciones tienen la misma firma: los argumentos son &lt;code&gt;$key, $data&lt;/code&gt; ; $ data tiene el mismo valor que el dado como argumento durante el empate (). Ambas funciones deben devolver una lista vac&amp;iacute;a si el valor no existe. Si la funci&amp;oacute;n &lt;code&gt;EXISTS&lt;/code&gt; es diferente de la funci&amp;oacute;n de &lt;code&gt;FETCH&lt;/code&gt; , deber&amp;iacute;a devolver un valor VERDADERO en caso de &amp;eacute;xito. La funci&amp;oacute;n de &lt;code&gt;FETCH&lt;/code&gt; deber&amp;iacute;a devolver el valor deseado si la clave es v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="26d9da8f5ad7069914e20430c62d4e761633b2e9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;FETCH&lt;/code&gt;ing function and the &lt;code&gt;EXISTS&lt;/code&gt; functions have the same signature: the arguments are &lt;code&gt;$key, $data&lt;/code&gt;; $data is the same value as given as argument during tie()ing. Both functions should return an empty list if the value does not exist. If &lt;code&gt;EXISTS&lt;/code&gt; function is different from the &lt;code&gt;FETCH&lt;/code&gt;ing function, it should return a TRUE value on success. The &lt;code&gt;FETCH&lt;/code&gt;ing function should return the intended value if the key is valid.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ed4eca63dc77f9c5ab93bb8224d63244af078a" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;\p&lt;/code&gt; counterparts always assume Unicode rules are in effect. On ASCII platforms, this means they assume that the code points from 128 to 255 are Latin-1, and that means that using them under locale rules is unwise unless the locale is guaranteed to be Latin-1 or UTF-8. In contrast, the POSIX character classes are useful under locale rules. They are affected by the actual rules in effect, as follows:</source>
          <target state="translated">Ambas contrapartes de &lt;code&gt;\p&lt;/code&gt; siempre asumen que las reglas Unicode est&amp;aacute;n en vigor. En las plataformas ASCII, esto significa que asumen que los puntos de c&amp;oacute;digo de 128 a 255 son Latin-1, y eso significa que usarlos bajo las reglas de configuraci&amp;oacute;n regional no es prudente a menos que se garantice que la configuraci&amp;oacute;n regional es Latin-1 o UTF-8. Por el contrario, las clases de caracteres POSIX son &amp;uacute;tiles en las reglas de configuraci&amp;oacute;n regional. Se ven afectados por las reglas reales en vigor, de la siguiente manera:</target>
        </trans-unit>
        <trans-unit id="ce95f2fe752d4b23fc80e241799a0c7676e9a5d9" translate="yes" xml:space="preserve">
          <source>Both the &lt;code&gt;filter&lt;/code&gt; method used with a</source>
          <target state="translated">Tanto el m&amp;eacute;todo de &lt;code&gt;filter&lt;/code&gt; utilizado con un</target>
        </trans-unit>
        <trans-unit id="16bb52db9f75f89e8e102ba17368f296bd30bb0a" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt; .</source>
          <target state="translated">Tanto los filtros Store como Fetch manipulan &lt;code&gt;$_&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4fb703f0b0c3a852ad76e2cb00f9c501f48f8ec4" translate="yes" xml:space="preserve">
          <source>Both the Store and Fetch filters manipulate &lt;code&gt;$_&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76973f944d78d30e634a5b0ebc6b4adb75da6f43" translate="yes" xml:space="preserve">
          <source>Both the functions can import the functions that are specified.</source>
          <target state="translated">Ambas funciones pueden importar las funciones que se especifiquen.</target>
        </trans-unit>
        <trans-unit id="2ad856a815b0ce3afb8156093d09ab25a9afd217" translate="yes" xml:space="preserve">
          <source>Both the main process and any child processes it forks share the same STDIN, STDOUT, and STDERR filehandles. If both processes try to access them at once, strange things can happen. You may also want to close or reopen the filehandles for the child. You can get around this by opening your pipe with open(), but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">Tanto el proceso principal como cualquier proceso infantil que se bifurca comparten los mismos mangos de archivo STDIN,STDOUT y STDERR.Si ambos procesos intentan acceder a ellos a la vez,pueden ocurrir cosas extrañas.También puede querer cerrar o reabrir los manejos de archivos para el niño.Puedes evitarlo abriendo el tubo con open(),pero en algunos sistemas esto significa que el proceso hijo no puede sobrevivir al padre.</target>
        </trans-unit>
        <trans-unit id="449435c9cac23bf8a94ca4fcd8681004ec825181" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;ing a pipe (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="translated">Tanto el proceso principal como el en segundo plano (el proceso &quot;secundario&quot;) comparten los mismos identificadores de archivo STDIN, STDOUT y STDERR. Si ambos intentan acceder a ellos a la vez, pueden suceder cosas extra&amp;ntilde;as. Es posible que desee cerrarlos o volver a abrirlos para el ni&amp;ntilde;o. Puede evitar esto &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; una tuber&amp;iacute;a (ver &lt;a href=&quot;functions/open&quot;&gt;abierto&lt;/a&gt; ), pero en algunos sistemas esto significa que el proceso hijo no puede sobrevivir al padre.</target>
        </trans-unit>
        <trans-unit id="f7d92bf0fef8c6d376360d3e96b538b59d69f577" translate="yes" xml:space="preserve">
          <source>Both the main process and the backgrounded one (the &quot;child&quot; process) share the same STDIN, STDOUT and STDERR filehandles. If both try to access them at once, strange things can happen. You may want to close or reopen these for the child. You can get around this with &lt;code&gt;open&lt;/code&gt;ing a pipe (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;) but on some systems this means that the child process cannot outlive the parent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d89a0af2055da02fc83d8afed6e917b5cc66d525" translate="yes" xml:space="preserve">
          <source>Both the native cc and gcc seem to consume lots of memory when building Perl. toke.c is a known trouble spot when optimizing: 256 megabytes of data section seems to be enough. Another known trouble spot is the mktables script which builds the Unicode support tables. The default setting of the process data section in Tru64 should be one gigabyte, but some sites/setups might have lowered that. The configuration process of Perl checks for too low process limits, and lowers the optimization for the toke.c if necessary, and also gives advice on how to raise the process limits (for example: &lt;code&gt;ulimit -d 262144&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12969a7fe698e5db30d6dfa2ac116b77818d15ac" translate="yes" xml:space="preserve">
          <source>Both the special and normal mappings are stored in</source>
          <target state="translated">Tanto los mapas especiales como los normales se almacenan en</target>
        </trans-unit>
        <trans-unit id="e87bc450de2089bfd62a5bd96629fc5b32ff6be9" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a5aa8697bdd1c4c4522254cc3fbbee82434df88" translate="yes" xml:space="preserve">
          <source>Both these XS declarations correspond to the &lt;code&gt;char*&lt;/code&gt; C type, but they have different semantics, see &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt;.</source>
          <target state="translated">Ambas declaraciones XS corresponden al tipo &lt;code&gt;char*&lt;/code&gt; C, pero tienen una sem&amp;aacute;ntica diferente, consulte &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;El operador &amp;amp; Unary&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="457d0ea6cab97df36f6f6888a3f8a1c477cbe9c0" translate="yes" xml:space="preserve">
          <source>Both these methods insert &lt;code&gt;&quot;:full&quot;&lt;/code&gt; automatically as the first argument (if no other argument is given), and you can give the &lt;code&gt;&quot;:full&quot;&lt;/code&gt; explicitly as well, like</source>
          <target state="translated">Ambos m&amp;eacute;todos insertan &lt;code&gt;&quot;:full&quot;&lt;/code&gt; autom&amp;aacute;ticamente como primer argumento (si no se proporciona ning&amp;uacute;n otro argumento), y tambi&amp;eacute;n puede dar &lt;code&gt;&quot;:full&quot;&lt;/code&gt; expl&amp;iacute;citamente, como</target>
        </trans-unit>
        <trans-unit id="a673297be17d984a1ebfc2f484aa63db04fb7bb3" translate="yes" xml:space="preserve">
          <source>Both these problems can be cured. Say, if we want to overload hash dereference on a reference to an object which is</source>
          <target state="translated">Ambos problemas pueden ser curados.Digamos que si queremos sobrecargar la referencia a un objeto que es</target>
        </trans-unit>
        <trans-unit id="c67dbd5c074e12563a96469c299bb554a98bb89b" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales.</source>
          <target state="translated">Tanto el nombre de la semana (día)como el nombre del mes (mes)permiten pasar una lista para usarla como índice del nombre de los días en contra.Esto puede ser útil si se necesita implementar alguna forma de localización sin instalar o usar locales.</target>
        </trans-unit>
        <trans-unit id="7251257be5507cef24fe3fb21a50fe67755c29b8" translate="yes" xml:space="preserve">
          <source>Both wdayname (day) and monname (month) allow passing in a list to use to index the name of the days against. This can be useful if you need to implement some form of localisation without actually installing or using locales. Note that this is a global override and will affect all Time::Piece instances.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f50d687ceecfadfb877f247a6453725043a7ffb" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="translated">Rutina de decodificaci&amp;oacute;n UTF-8 de nivel inferior. Devuelve el valor del punto de c&amp;oacute;digo nativo del primer car&amp;aacute;cter de la cadena &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , que se supone que est&amp;aacute; en codificaci&amp;oacute;n UTF-8 (o UTF-EBCDIC) y no m&amp;aacute;s de bytes &lt;code&gt;curlen&lt;/code&gt; ; &lt;code&gt;*retlen&lt;/code&gt; (si &lt;code&gt;retlen&lt;/code&gt; no es NULL) se establecer&amp;aacute; en la longitud, en bytes, de ese car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="dfa04ba4cca5e78047dc43990129bc3ae3f19bff" translate="yes" xml:space="preserve">
          <source>Bottom level UTF-8 decode routine. Returns the native code point value of the first character in the string &lt;code&gt;s&lt;/code&gt;, which is assumed to be in UTF-8 (or UTF-EBCDIC) encoding, and no longer than &lt;code&gt;curlen&lt;/code&gt; bytes; &lt;code&gt;*retlen&lt;/code&gt; (if &lt;code&gt;retlen&lt;/code&gt; isn't NULL) will be set to the length, in bytes, of that character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ffac88340ff426b9b20077ea20bd37ed9bc04e3" translate="yes" xml:space="preserve">
          <source>Boundaries of Hangul syllables are determined according to conjoining Jamo behavior in</source>
          <target state="translated">Los límites de las sílabas de Hangul se determinan de acuerdo con el comportamiento conjunto de Jamo en</target>
        </trans-unit>
        <trans-unit id="fa3c7716ef77e2c3385fc102b1a731781237c324" translate="yes" xml:space="preserve">
          <source>Boykin, Joseph, David Kirschen, Alan Langerman, and Susan LoVerso. Programming under Mach. Addison-Wesley, 1994, ISBN 0-201-52739-1.</source>
          <target state="translated">Boykin,Joseph,David Kirschen,Alan Langerman y Susan LoVerso.Programación bajo Mach.Addison-Wesley,1994,ISBN 0-201-52739-1.</target>
        </trans-unit>
        <trans-unit id="cbed39e2d9457a27b38ac123d4072c095875ce37" translate="yes" xml:space="preserve">
          <source>Brace yourself for thanks, bug reports, hate mail and spam coming as result of the previous step. No good deed should remain unpunished!</source>
          <target state="translated">Prepárate para las gracias,los informes de errores,los correos de odio y el spam que llegan como resultado del paso anterior.¡Ninguna buena acción debe quedar sin castigo!</target>
        </trans-unit>
        <trans-unit id="5fde9354c8205697f6414265780ed0c53484415c" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">Se requieren llaves para hacer referencia a grupos de captura con nombre, pero son opcionales para los que tienen n&amp;uacute;meros absolutos o relativos. Las llaves son m&amp;aacute;s seguras al crear una expresi&amp;oacute;n regular al concatenar cadenas m&amp;aacute;s peque&amp;ntilde;as. Por ejemplo, si tiene &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; , y &lt;code&gt;$a&lt;/code&gt; contiene &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; y &lt;code&gt;$b&lt;/code&gt; contiene &lt;code&gt;&quot;37&quot;&lt;/code&gt; , obtendr&amp;aacute; &lt;code&gt;/\g137/&lt;/code&gt; que probablemente no sea lo que pretend&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="18fd4ec0e937de91c70828b19eb3454f88d75941" translate="yes" xml:space="preserve">
          <source>Braces are required in referring to named capture groups, but are optional for absolute or relative numbered ones. Braces are safer when creating a regex by concatenating smaller strings. For example if you have &lt;code&gt;qr/$a$b/&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;, and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt;, you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2fa9a0b57b5dc549e8decf6cc394f53167efa53b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a crucial feature of Locale::Maketext. I mean Bracket Notation to provide a replacement for the use of sprintf formatting. Everything you do with Bracket Notation could be done with a sub block, but bracket notation is meant to be much more concise.</source>
          <target state="translated">La notación de corchetes es una característica crucial de Locale::Maketext.Me refiero a la notación de corchetes para reemplazar el uso del formato sprintf.Todo lo que haces con la Notación de Paréntesis podría hacerse con un sub-bloque,pero la notación de paréntesis está pensada para ser mucho más concisa.</target>
        </trans-unit>
        <trans-unit id="bb9b16ff2deefe21cce7105f1030ffe04c9ef94b" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7d31b6dcf28abb8afbf24fa97f7391fe87364415" translate="yes" xml:space="preserve">
          <source>Bracket Notation is a like a miniature &quot;template&quot; system (in the sense of &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Text::Template&lt;/a&gt;, not in the sense of C++ templates), where normal text is passed thru basically as is, but text in special regions is specially interpreted. In Bracket Notation, you use square brackets (&quot;[...]&quot;), not curly braces (&quot;{...}&quot;) to note sections that are specially interpreted.</source>
          <target state="translated">La notaci&amp;oacute;n entre corchetes es como un sistema de &quot;plantilla&quot; en miniatura (en el sentido de &lt;a href=&quot;http://search.cpan.org/perldoc/Text::Template&quot;&gt;Texto :: Plantilla&lt;/a&gt; , no en el sentido de las plantillas de C ++), donde el texto normal se pasa b&amp;aacute;sicamente como est&amp;aacute;, pero el texto en regiones especiales se interpreta especialmente. En la notaci&amp;oacute;n de corchetes, utiliza corchetes (&quot;[...]&quot;), no llaves (&quot;{...}&quot;) para anotar las secciones que se interpretan especialmente.</target>
        </trans-unit>
        <trans-unit id="c69ae72aa90270486c045c7a6541cf13d55632e9" translate="yes" xml:space="preserve">
          <source>Bracket Notation is discussed in a later section. Note that trying to compile a string into Bracket Notation can throw an exception if the string is not syntactically valid (say, by not balancing brackets right.)</source>
          <target state="translated">La notación de corchetes se examina en una sección posterior.Tenga en cuenta que tratar de compilar una cadena en la Notación de corchetes puede lanzar una excepción si la cadena no es sintácticamente válida (por ejemplo,no equilibrando los corchetes a la derecha.)</target>
        </trans-unit>
        <trans-unit id="046d4b6cd34c3e66bcd55c31ba3d01db5f8bac76" translate="yes" xml:space="preserve">
          <source>Bracket groups that are empty, or which consist only of whitespace, are ignored. (Examples: &quot;[]&quot;, &quot;[ ]&quot;, or a [ and a ] with returns and/or tabs and/or spaces between them.</source>
          <target state="translated">Los grupos de corchetes que están vacíos,o que consisten sólo en espacios en blanco,son ignorados.(Ejemplos:&quot;[]&quot;,&quot;[]&quot;,o un[y un]con retornos y/o pestañas y/o espacios entre ellos.</target>
        </trans-unit>
        <trans-unit id="d96a703ba2e31ec739345b11c90028f276d06d37" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes</source>
          <target state="translated">Clases de personaje entre corchetes</target>
        </trans-unit>
        <trans-unit id="1d6defc184cd831ef1a40a992a7bc00f4a08d7aa" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the /xx pattern modifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56159ead51e4e16a6e6e36a9eba26b713462d135" translate="yes" xml:space="preserve">
          <source>Bracketed Character Classes and the &lt;code&gt;/xx&lt;/code&gt; pattern modifier</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fd31d2f7c96c6ebd02a583681a9f9dd8128bde2" translate="yes" xml:space="preserve">
          <source>Bracketed character classes are represented by &lt;code&gt;regnode_charclass&lt;/code&gt; structures, which have a four-byte argument and then a 32-byte (256-bit) bitmap indicating which characters in the Latin1 range are included in the class.</source>
          <target state="translated">Las clases de caracteres entre corchetes est&amp;aacute;n representadas por estructuras &lt;code&gt;regnode_charclass&lt;/code&gt; , que tienen un argumento de cuatro bytes y luego un mapa de bits de 32 bytes (256 bits) que indica qu&amp;eacute; caracteres del rango Latin1 est&amp;aacute;n incluidos en la clase.</target>
        </trans-unit>
        <trans-unit id="4f10c5c48b8ce584bf50338e9ce1774e2c591ba3" translate="yes" xml:space="preserve">
          <source>Brackets around a symbolic reference can simply serve to isolate an identifier or variable name from the rest of an expression, just as they always have within a string. For example,</source>
          <target state="translated">Los corchetes alrededor de una referencia simbólica pueden servir simplemente para aislar un identificador o nombre de variable del resto de una expresión,como siempre lo han hecho dentro de una cadena.Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="ee4272402a91677e15417810bffa7f99811d776d" translate="yes" xml:space="preserve">
          <source>Brackets must be balanced -- every openbracket must have one matching closebracket, and vice versa. So these are all &lt;b&gt;invalid&lt;/b&gt;:</source>
          <target state="translated">Los soportes deben estar equilibrados: cada soporte abierto debe tener un soporte cerrado coincidente y viceversa. Entonces estos son todos &lt;b&gt;inv&amp;aacute;lidos&lt;/b&gt; :</target>
        </trans-unit>
        <trans-unit id="078f4a9c2a661144675f9e2bfab86b75d63064df" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;</source>
          <target state="translated">Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="976a94f14824f930d58b9616017f2abefc3253d5" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (versi&amp;oacute;n inicial), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6593228df02466d50b8cc0c36e813c08ba422fcb" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt; (initial version), Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;, Marc Green &amp;lt;marcgreen@cpan.org&amp;gt; (port to Pod::Simple) Ricardo Signes &amp;lt;rjbs@cpan.org&amp;gt; (more porting to Pod::Simple) Karl Williamson &amp;lt;khw@cpan.org&amp;gt; (more porting to Pod::Simple)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd85e7290aa8473e575a87a5fd8b95386788c86e" translate="yes" xml:space="preserve">
          <source>Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;, Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</source>
          <target state="translated">Brad Appleton &amp;lt;bradapp@enteract.com&amp;gt;, Marek Rouchal &amp;lt;marekr@cpan.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="ace391da91b3b622751d8ebf145fd4091f241ba4" translate="yes" xml:space="preserve">
          <source>Brad Gilbert &amp;lt;bgills@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ae43dcfe840a5e3a18a13f5b3acd9cb0f221ef8" translate="yes" xml:space="preserve">
          <source>Brandon Browning,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7ea19e07547da7e5f6a43b6c0892e4265aeebb1" translate="yes" xml:space="preserve">
          <source>Brandon L. Black, &amp;lt;blblack@gmail.com&amp;gt;</source>
          <target state="translated">Brandon L. Black, &amp;lt;blblack@gmail.com&amp;gt;</target>
        </trans-unit>
        <trans-unit id="6fb6fe57c36bfedd5ff6f16a948fc45d01c7d083" translate="yes" xml:space="preserve">
          <source>Branislav Zahradnik &amp;lt;barney@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37497aa5a2272c49714aee1b07e8edf973a95f59" translate="yes" xml:space="preserve">
          <source>Brazil</source>
          <target state="translated">Brazil</target>
        </trans-unit>
        <trans-unit id="eca2fc6f92666147ac6a607129bb8a0811237538" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given()&lt;/code&gt; block.</source>
          <target state="translated">Salir de un bloque &lt;code&gt;given()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="70e84e284b7238bd647c1d2ad9dae3dcf040b2c5" translate="yes" xml:space="preserve">
          <source>Break out of a &lt;code&gt;given&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03d93607f829e7fe2aafd920d3e1c2e3753bb301" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt; d has some initialization which it expects to be done early.</source>
          <target state="translated">Interrumpa la ejecuci&amp;oacute;n de su programa si el m&amp;oacute;dulo que &lt;code&gt;autouse&lt;/code&gt; d tiene alguna inicializaci&amp;oacute;n que espera que se realice antes.</target>
        </trans-unit>
        <trans-unit id="848f64a4802a4e63379bfcaf66c37f0f07a8afee" translate="yes" xml:space="preserve">
          <source>Break the execution of your program if the module you &lt;code&gt;autouse&lt;/code&gt;d has some initialization which it expects to be done early.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="75e308eb5b16f38422b4dd55b2c10339c108233c" translate="yes" xml:space="preserve">
          <source>Break up text into lines according to Unicode rules.</source>
          <target state="translated">Dividir el texto en líneas según las reglas de Unicode.</target>
        </trans-unit>
        <trans-unit id="5ad0b6bff702cd07f8dbaf1cb4107d1095e60662" translate="yes" xml:space="preserve">
          <source>Break-out the reusable code into one or more separate module files.</source>
          <target state="translated">Descomponer el código reutilizable en uno o más archivos de módulos separados.</target>
        </trans-unit>
        <trans-unit id="f19f6b051659b65527c1cf48996b006f5fcd4db1" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt; . Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt; . The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="translated">L&amp;iacute;neas rompibles est&amp;aacute;n marcados con &lt;code&gt;:&lt;/code&gt; . Las l&amp;iacute;neas con puntos de interrupci&amp;oacute;n se marcan con &lt;code&gt;b&lt;/code&gt; y las que tienen acciones con &lt;code&gt;a&lt;/code&gt; . La l&amp;iacute;nea que est&amp;aacute; a punto de ejecutarse est&amp;aacute; marcada con &lt;code&gt;==&amp;gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4cca55190538278526fdb090660eae35486629fc" translate="yes" xml:space="preserve">
          <source>Breakable lines are marked with &lt;code&gt;:&lt;/code&gt;. Lines with breakpoints are marked by &lt;code&gt;b&lt;/code&gt; and those with actions by &lt;code&gt;a&lt;/code&gt;. The line that's about to be executed is marked by &lt;code&gt;==&amp;gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73cb8429b43020f4d84d456449c4c5b228dde417" translate="yes" xml:space="preserve">
          <source>Breaking gettext</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02352bb0ba7c8d9b86acca1b53f9d1e7553bf956" translate="yes" xml:space="preserve">
          <source>Breaking out</source>
          <target state="translated">Rompiendo...</target>
        </trans-unit>
        <trans-unit id="b58f4abd812365aa3e9bf665a84c1fa3c88cdbc5" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a DBM file and a hash.</source>
          <target state="translated">Rompe la unión entre un archivo DBM y un hash.</target>
        </trans-unit>
        <trans-unit id="fece5a66de93443d7bff991c12beae4eb8074f61" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2CCLASSNAME%2CLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4964084eb3d73be96dd1eeb1af8495c4dc61d5f9" translate="yes" xml:space="preserve">
          <source>Breaks the binding between a variable and a package. (See &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;tie&lt;/a&gt;.) Has no effect if the variable is not tied.</source>
          <target state="translated">Rompe el enlace entre una variable y un paquete. (Ver &lt;a href=&quot;#tie-VARIABLE%2cCLASSNAME%2cLIST&quot;&gt;empate&lt;/a&gt; ). No tiene efecto si la variable no est&amp;aacute; empatada.</target>
        </trans-unit>
        <trans-unit id="ebcffdb904889257c266769aa18189925f0f7c13" translate="yes" xml:space="preserve">
          <source>Brent Powers has a &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; module that was designed to work with Memoize and provides expiration of least-recently-used data. The cache is held at a fixed number of entries, and when new data comes in, the least-recently used data is expired. See &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt;.</source>
          <target state="translated">Brent Powers tiene un m&amp;oacute;dulo &lt;code&gt;Memoize::ExpireLRU&lt;/code&gt; que fue dise&amp;ntilde;ado para funcionar con Memoize y proporciona la caducidad de los datos utilizados menos recientemente. La cach&amp;eacute; se mantiene en un n&amp;uacute;mero fijo de entradas, y cuando ingresan nuevos datos, los datos utilizados menos recientemente caducan. Consulte &lt;a href=&quot;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&quot;&gt;http://search.cpan.org/search?mode=module&amp;amp;query=ExpireLRU&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c27cf707cf417ff0a776233c5044d0c0f1f7ca1a" translate="yes" xml:space="preserve">
          <source>Brian Fraser &amp;lt;fraserbn@gmail.com&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f48c0d1bc27a1a6d3322c34a40dc48ed4836827" translate="yes" xml:space="preserve">
          <source>Brian Mowrey &amp;lt;brian@drlabs.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d67acd53896f7915d6e2dc925e202a5731fc6800" translate="yes" xml:space="preserve">
          <source>Briefly, &lt;code&gt;/l&lt;/code&gt; sets the character set to that of whatever &lt;b&gt;L&lt;/b&gt;ocale is in effect at the time of the execution of the pattern match.</source>
          <target state="translated">Brevemente, &lt;code&gt;/l&lt;/code&gt; establece el juego de caracteres en el de cualquier &lt;b&gt;L&lt;/b&gt; ocale que est&amp;eacute; en vigor en el momento de la ejecuci&amp;oacute;n de la coincidencia de patrones.</target>
        </trans-unit>
        <trans-unit id="617a3fbf545ee5333943d4e71b255277bef3b51a" translate="yes" xml:space="preserve">
          <source>Broadcast =&amp;gt; BOOL</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4f1d6e87ca75e40a64b990a2d32b737b491cbea9" translate="yes" xml:space="preserve">
          <source>Broadly speaking, performing a match of a string against a pattern involves the following steps:</source>
          <target state="translated">En términos generales,la realización de una coincidencia de una cuerda contra un patrón implica los siguientes pasos:</target>
        </trans-unit>
        <trans-unit id="b0f84539efd4151eb704c02dcc4f761c1702c86d" translate="yes" xml:space="preserve">
          <source>Broken systems</source>
          <target state="translated">Sistemas rotos</target>
        </trans-unit>
        <trans-unit id="1def5ba77699f04961452989de376f438210ae2b" translate="yes" xml:space="preserve">
          <source>Bucket Order Perturbance</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d93b6657484eea5e944049ac0b3ddce1a19d87f5" translate="yes" xml:space="preserve">
          <source>Buffer overflow in prime_env_iter: %s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe6990bb386cb0f2d9d5ad6fab5909ce4fbcb2fd" translate="yes" xml:space="preserve">
          <source>Buffer scalar containing the chunk currently under consideration of the text currently being lexed. This is always a plain string scalar (for which &lt;code&gt;SvPOK&lt;/code&gt; is true). It is not intended to be used as a scalar by normal scalar means; instead refer to the buffer directly by the pointer variables described below.</source>
          <target state="translated">Buffer escalar que contiene el fragmento que se est&amp;aacute; considerando actualmente del texto que se est&amp;aacute; lexizando. Este es siempre un escalar de cadena simple (para el que &lt;code&gt;SvPOK&lt;/code&gt; es verdadero). No est&amp;aacute; destinado a ser utilizado como escalar por medios escalares normales; en su lugar, consulte el b&amp;uacute;fer directamente mediante las variables de puntero que se describen a continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="aaf695eeaf0754918bfdf3c63ed153867d69dfcf" translate="yes" xml:space="preserve">
          <source>Bug reports and other feedback are most welcome.</source>
          <target state="translated">Los informes de errores y otros comentarios son muy bienvenidos.</target>
        </trans-unit>
        <trans-unit id="4a6ed58e35768beb4922face36916e3eb34ceb32" translate="yes" xml:space="preserve">
          <source>Bug reports should be submitted to the GitHub issue tracker at &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;. The &lt;b&gt;perlbug@perl.org&lt;/b&gt; address no longer automatically opens tickets. You can use this tool to compose your report and save it to a file which you can then submit to the issue tracker.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3dfa0b6c5b9a870507e0243e43fe93803edb544" translate="yes" xml:space="preserve">
          <source>Bug reports, patches, and nagging provided by lots of folks-- thanks everybody! Special thanks to Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt; for assuring me that a &amp;amp;nested_quotewords() would be useful, and to Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; for telling me not to worry about error-checking (sort of-- you had to be there).</source>
          <target state="translated">Informes de errores, parches y molestias proporcionados por muchas personas, &amp;iexcl;gracias a todos! Un agradecimiento especial a Michael Schwern &amp;lt;schwern@envirolink.org&amp;gt; por asegurarme que un &amp;amp; nested_quotewords () ser&amp;iacute;a &amp;uacute;til, y a Jeff Friedl &amp;lt;jfriedl@yahoo-inc.com&amp;gt; por decirme que no me preocupe por la verificaci&amp;oacute;n de errores (una especie de -- Hab&amp;iacute;a que estar all&amp;iacute;).</target>
        </trans-unit>
        <trans-unit id="829fe5647d6ef5dc40cbf31334f7d303909516a7" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</source>
          <target state="translated">Correcci&amp;oacute;n de errores por Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2011.</target>
        </trans-unit>
        <trans-unit id="238715da3b418db89372b9015297a37b9b381344" translate="yes" xml:space="preserve">
          <source>Bug-fixing by Peter John Acklam &amp;lt;pjacklam@online.no&amp;gt; 2010-2016.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c8eea1b80ba437eb2c7d9d8e4a7a1c0c36ddce4e" translate="yes" xml:space="preserve">
          <source>Bugs</source>
          <target state="translated">Bugs</target>
        </trans-unit>
        <trans-unit id="60757698bb42548c3dda76e0d4ec377b0dd06d65" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though GitHub: &lt;a href=&quot;https://github.com/Test-More/test-more/issues&quot;&gt;https://github.com/Test-More/test-more/issues&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f308ba7fc80d9c9a972b67a64671b669a27d16c" translate="yes" xml:space="preserve">
          <source>Bugs (and requests for new features) can be reported to the author though the CPAN RT system: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</source>
          <target state="translated">Los errores (y las solicitudes de nuevas funciones) se pueden informar al autor a trav&amp;eacute;s del sistema CPAN RT: &lt;a href=&quot;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&quot;&gt;http://rt.cpan.org/NoAuth/ReportBug.html?Queue=Test-Builder-Tester&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="888b6006f2872d22aaa1cd6bce9e12ccb31d9655" translate="yes" xml:space="preserve">
          <source>Bugs / Feature Requests</source>
          <target state="translated">Bugs/Solicitudes de características</target>
        </trans-unit>
        <trans-unit id="58d170e283eb8eb2d13abdce7bd1aa5026377f10" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted at &lt;a href=&quot;https://github.com/houseabsolute/Time-Local/issues&quot;&gt;https://github.com/houseabsolute/Time-Local/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a450dc1be8865ad9e376ea507387ccd3c0e65886" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=File-Temp&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-File-Temp@rt.cpan.org&quot;&gt;bug-File-Temp@rt.cpan.org&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="147820deb7b5b2f1e33d540237db5f728a826fed" translate="yes" xml:space="preserve">
          <source>Bugs may be submitted through &lt;a href=&quot;https://rt.cpan.org/Public/Dist/Display.html?Name=Module-Metadata&quot;&gt;the RT bug tracker&lt;/a&gt; (or &lt;a href=&quot;mailto:bug-Module-Metadata@rt.cpan.org&quot;&gt;bug-Module-Metadata@rt.cpan.org&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="798e9f12ff638512bcd89953d3735c6b7ab1cee3" translate="yes" xml:space="preserve">
          <source>Bugs you don't plan to fix. :-)</source>
          <target state="translated">Bugs que no planeas arreglar.:-)</target>
        </trans-unit>
        <trans-unit id="bbd80cf7e2ded5efed8f4ee9151ab57a8ab66392" translate="yes" xml:space="preserve">
          <source>Build</source>
          <target state="translated">Build</target>
        </trans-unit>
        <trans-unit id="a3c79824d95086093512b52d7ab25ad53dd0d923" translate="yes" xml:space="preserve">
          <source>Build Anomalies with Perl on OS/390</source>
          <target state="translated">Construir anomalías con Perl en OS/390</target>
        </trans-unit>
        <trans-unit id="8197039c73f48aefe4687141c68ac9ca58ef8d5e" translate="yes" xml:space="preserve">
          <source>Build FAQ</source>
          <target state="translated">Construir FAQ</target>
        </trans-unit>
        <trans-unit id="4f1a5b2e8fc6f3c96b77575a0eaa73b7619bef70" translate="yes" xml:space="preserve">
          <source>Build Prerequisites for Perl on AmigaOS</source>
          <target state="translated">Construir los requisitos previos para Perl en AmigaOS</target>
        </trans-unit>
        <trans-unit id="431713be1df25e40d76ce4972f5897bc2ac46f53" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; are pruned.</source>
          <target state="translated">Construya un iterador que encuentre archivos distroprefs en el &amp;aacute;rbol debajo del directorio dado. Dentro del &amp;aacute;rbol, los directorios que coinciden con &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m/^[._]/&lt;/a&gt;&lt;/code&gt; se eliminan .</target>
        </trans-unit>
        <trans-unit id="1f5e8d7b401e7067eefc5a283830fcc846d1ee9e" translate="yes" xml:space="preserve">
          <source>Build an iterator which finds distroprefs files in the tree below the given directory. Within the tree directories matching &lt;code&gt;m/^[._]/&lt;/code&gt; are pruned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39f0d013521af98c935739685e85fd389eb57d10" translate="yes" xml:space="preserve">
          <source>Build hash based classes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="025fef91894be2ceb7f450be64f484f9a3dfd148" translate="yes" xml:space="preserve">
          <source>Build instructions for OS/2, &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;</source>
          <target state="translated">Instrucciones de compilaci&amp;oacute;n para OS / 2, &lt;a href=&quot;perlos2&quot;&gt;perlos2&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6a0c26b6e73b4a14e003052fbfb474ae81ddeb3d" translate="yes" xml:space="preserve">
          <source>Build instructions for Win32 in &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt;, or under the Cygnus environment in &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt;.</source>
          <target state="translated">Construya instrucciones para Win32 en &lt;a href=&quot;perlwin32&quot;&gt;perlwin32&lt;/a&gt; , o bajo el entorno Cygnus en &lt;a href=&quot;perlcygwin&quot;&gt;perlcygwin&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ec272960803bf0c1141ddb2cc450b8e7bb399d9c" translate="yes" xml:space="preserve">
          <source>Build man pages, too</source>
          <target state="translated">Construir páginas de hombre,también</target>
        </trans-unit>
        <trans-unit id="6e79e48e57f84dbe7fa157bde2a3fead704bb75d" translate="yes" xml:space="preserve">
          <source>Build system</source>
          <target state="translated">Sistema de construcción</target>
        </trans-unit>
        <trans-unit id="857fee8f38d36d4d66b3ca310ad74ff4223ccbe4" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the UTF-8 encoded string &lt;code&gt;spv&lt;/code&gt;, length &lt;code&gt;len&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &lt;code&gt;&quot;...&quot;&lt;/code&gt; will be appended).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f324587551677d6f64a6a55d81e5c02c33aaa350" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">Construya en el escalar &lt;code&gt;dsv&lt;/code&gt; una versi&amp;oacute;n visualizable del escalar &lt;code&gt;sv&lt;/code&gt; , la versi&amp;oacute;n visualizable &lt;code&gt;pvlim&lt;/code&gt; longitud m&amp;aacute;xima de pvlim bytes (si es m&amp;aacute;s larga, el resto se trunca y se a&amp;ntilde;adir&amp;aacute; &quot;...&quot;).</target>
        </trans-unit>
        <trans-unit id="46af0313d23f0c460bfa1f3a9e5387975e8b2b74" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the scalar &lt;code&gt;sv&lt;/code&gt;, the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc42dbdb87c5e71f504c4dbe80214e6754c41fcb" translate="yes" xml:space="preserve">
          <source>Build to the scalar &lt;code&gt;dsv&lt;/code&gt; a displayable version of the string &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; , the displayable version being at most &lt;code&gt;pvlim&lt;/code&gt; bytes long (if longer, the rest is truncated and &quot;...&quot; will be appended).</source>
          <target state="translated">Construya en el escalar &lt;code&gt;dsv&lt;/code&gt; una versi&amp;oacute;n visualizable de la cadena &lt;code&gt;spv&lt;/code&gt; , length &lt;code&gt;len&lt;/code&gt; , siendo la versi&amp;oacute;n visualizable &lt;code&gt;pvlim&lt;/code&gt; bytes de longitud como m&amp;aacute;ximo (si es m&amp;aacute;s larga, el resto se trunca y se agregar&amp;aacute; &quot;...&quot;).</target>
        </trans-unit>
        <trans-unit id="c6bd3f51881e4d26f104fbcd7a9347aa8d6d5282" translate="yes" xml:space="preserve">
          <source>Build, Configure, Make, Install</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c215cd495fbe90044cc607bb79e970dde2b9028" translate="yes" xml:space="preserve">
          <source>Build, Test, Install Perl on OS/390</source>
          <target state="translated">Construir,probar,instalar Perl en OS/390</target>
        </trans-unit>
        <trans-unit id="249199540ceee6ec6b4a1f1daa24666f4aa042eb" translate="yes" xml:space="preserve">
          <source>Build.PL</source>
          <target state="translated">Build.PL</target>
        </trans-unit>
        <trans-unit id="4759bf14d7a511508e86c343c934894b6e8db533" translate="yes" xml:space="preserve">
          <source>Builder</source>
          <target state="translated">Builder</target>
        </trans-unit>
        <trans-unit id="52b5e661f9ecf45eed9a8b41756d5844802fbce9" translate="yes" xml:space="preserve">
          <source>Builder class for Windows platforms</source>
          <target state="translated">Clase de constructor para plataformas Windows</target>
        </trans-unit>
        <trans-unit id="9d914bfcf1c5bc9e6b83d3232349cae23d392f30" translate="yes" xml:space="preserve">
          <source>Building</source>
          <target state="translated">Building</target>
        </trans-unit>
        <trans-unit id="2ed0dadcc70796d33055d55283657d04fb0c039a" translate="yes" xml:space="preserve">
          <source>Building 32-bit Perl in Irix</source>
          <target state="translated">Construyendo Perl de 32 bits en Irix</target>
        </trans-unit>
        <trans-unit id="977f968c44ef127f7e68a4bbd06a3bc09d574a03" translate="yes" xml:space="preserve">
          <source>Building 64-bit Perl in Irix</source>
          <target state="translated">Construyendo Perl de 64 bits en Irix</target>
        </trans-unit>
        <trans-unit id="a68801656d21c1742976b2a26b0d97ca179190db" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX</source>
          <target state="translated">Construyendo Extensiones Dinámicas en AIX</target>
        </trans-unit>
        <trans-unit id="cdc5004f31232806335a1cd820513add0b5ef95f" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on AIX &amp;lt; 5L</source>
          <target state="translated">Creaci&amp;oacute;n de extensiones din&amp;aacute;micas en AIX &amp;lt;5L</target>
        </trans-unit>
        <trans-unit id="60eeab40d6adc2fe265d128c48b6aa4e93a2fcb8" translate="yes" xml:space="preserve">
          <source>Building Dynamic Extensions on HP-UX</source>
          <target state="translated">Construyendo extensiones dinámicas en HP-UX</target>
        </trans-unit>
        <trans-unit id="e3d2578989b066f6d4e0e3d492f28b294aef6801" translate="yes" xml:space="preserve">
          <source>Building Extensions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cca0ab4039ae032282d3c4fa53d7e82995e8594" translate="yes" xml:space="preserve">
          <source>Building Non-XS Modules on DOS</source>
          <target state="translated">Construir módulos no XS en DOS</target>
        </trans-unit>
        <trans-unit id="e58f39330e280e7de8b3b247f8f97aeb868e7743" translate="yes" xml:space="preserve">
          <source>Building Perl for WinCE</source>
          <target state="translated">Construyendo Perl para WinCE</target>
        </trans-unit>
        <trans-unit id="9e84e0a9f11037f0b7fccbdd30b3def3e1270535" translate="yes" xml:space="preserve">
          <source>Building Perl on DOS</source>
          <target state="translated">Construyendo Perl en DOS</target>
        </trans-unit>
        <trans-unit id="107439a62a7c6f42562b678d76f2e80c36c5eb66" translate="yes" xml:space="preserve">
          <source>Building Prerequisites for Perl on DOS</source>
          <target state="translated">Creación de los requisitos previos para el Perl en el DOS</target>
        </trans-unit>
        <trans-unit id="b5ced49870fdf0851779593a86211e669aed437d" translate="yes" xml:space="preserve">
          <source>Building XS Modules on DOS</source>
          <target state="translated">Construyendo módulos XS en DOS</target>
        </trans-unit>
        <trans-unit id="16ea3711da90cdc1ad8b70bb59bd87c31033d7af" translate="yes" xml:space="preserve">
          <source>Building a 64-bit capable gcc on PA-RISC from source is possible only when you have the HP C-ANSI C compiler or an already working 64-bit binary of gcc available. Best performance for perl is achieved with HP's native compiler.</source>
          <target state="translated">Construir un gcc de 64 bits en PA-RISC desde la fuente sólo es posible cuando se dispone del compilador HP C-ANSI C o de un binario de 64 bits de gcc que ya funciona.El mejor rendimiento para perl se logra con el compilador nativo de HP.</target>
        </trans-unit>
        <trans-unit id="b06d77f19e3d0e1947de8d417eb97b9240aba5fe" translate="yes" xml:space="preserve">
          <source>Building a binary distribution</source>
          <target state="translated">Construir una distribución binaria</target>
        </trans-unit>
        <trans-unit id="5eaf641b2cc432d339298d2d7667c55e1df71877" translate="yes" xml:space="preserve">
          <source>Building a regexp</source>
          <target state="translated">Construir un regexp</target>
        </trans-unit>
        <trans-unit id="4f3097c147e745c265a4f8606c6e810a7ad5d9f4" translate="yes" xml:space="preserve">
          <source>Building an LP64 perl</source>
          <target state="translated">Construyendo un perl LP64</target>
        </trans-unit>
        <trans-unit id="d601de14ddca518b95c2c6d816b3b797646fe162" translate="yes" xml:space="preserve">
          <source>Building custom</source>
          <target state="translated">La costumbre de construir</target>
        </trans-unit>
        <trans-unit id="38b3b94607428da1a192459760b9b24f29336537" translate="yes" xml:space="preserve">
          <source>Building custom .EXE files</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94d1d0131bb7b5bab11d8fd5a13a49d41b119105" translate="yes" xml:space="preserve">
          <source>Building custom _.EXE_ files</source>
          <target state="translated">Construir archivos personalizados _.EXE</target>
        </trans-unit>
        <trans-unit id="e10bbd8c13474666bee2a919ca9d0cf777bfbdb2" translate="yes" xml:space="preserve">
          <source>Building debugging-enabled binaries (with -g or -g3) will increase the chance of getting these errors. Prevent -g if possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60333d2c51f8933ea40f3711d31effe77527e1a4" translate="yes" xml:space="preserve">
          <source>Building perl at older commits</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58685fabffe8d566dcf90fc429e9988b44fb72cb" translate="yes" xml:space="preserve">
          <source>Building should proceed differently depending on whether the version of perl you install is already present and used on your system, or is a new version not yet used. The description below assumes that the version is new, so installing its DLLs and</source>
          <target state="translated">La construcción debe proceder de manera diferente dependiendo de si la versión de perl que se instala ya está presente y se utiliza en su sistema,o es una nueva versión que aún no se utiliza.La descripción que sigue asume que la versión es nueva,por lo que la instalación de sus DLLs y</target>
        </trans-unit>
        <trans-unit id="25399d44a6d52942b965d7741dfbe5b98c44e3b6" translate="yes" xml:space="preserve">
          <source>Building with threads in Irix</source>
          <target state="translated">Construir con hilos en Irix</target>
        </trans-unit>
        <trans-unit id="c882cff5cf66c8bc0ee9d0ac391aee6b3e4faba4" translate="yes" xml:space="preserve">
          <source>Buildtype.bat</source>
          <target state="translated">Buildtype.bat</target>
        </trans-unit>
        <trans-unit id="167534462e1810e98824021557fb475fd2cb9f52" translate="yes" xml:space="preserve">
          <source>Built-in Attributes</source>
          <target state="translated">Atributos incorporados</target>
        </trans-unit>
        <trans-unit id="03c641eb4ff3905fcf16d5ff9fd329806e0d8127" translate="yes" xml:space="preserve">
          <source>Built-in Encodings</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a254cda26c62367280124a0a97ba97ac0047a0c1" translate="yes" xml:space="preserve">
          <source>Builtin operators and functions</source>
          <target state="translated">Operadores y funciones incorporadas</target>
        </trans-unit>
        <trans-unit id="82bac8de7c475e9a140fc89ca8b2ed3375482576" translate="yes" xml:space="preserve">
          <source>Builtin types include:</source>
          <target state="translated">Los tipos construidos incluyen:</target>
        </trans-unit>
        <trans-unit id="5c77726358c5daf98ad9cdccd0882bca0f718b88" translate="yes" xml:space="preserve">
          <source>Bulgaria</source>
          <target state="translated">Bulgaria</target>
        </trans-unit>
        <trans-unit id="572f7127eed71e662d147110ecd2618b7d80c972" translate="yes" xml:space="preserve">
          <source>Bultibuffer count</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56c511a735d99d5e1aad2b7d21a4ed9e5dff3aca" translate="yes" xml:space="preserve">
          <source>Bumped version.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbadec79c760a0615a7745522920ce54712b347a" translate="yes" xml:space="preserve">
          <source>Bundle/Snapshot_2012_05_21_00.pm</source>
          <target state="translated">Bundle/Snapshot_2012_05_21_00.pm</target>
        </trans-unit>
        <trans-unit id="c1d562515d11cd030821deea9c673716499b48ca" translate="yes" xml:space="preserve">
          <source>Bundled Encode::Locale</source>
          <target state="translated">Código de paquete::Local</target>
        </trans-unit>
        <trans-unit id="9a033a116a34993104733ddb8e62da3f808f4b18" translate="yes" xml:space="preserve">
          <source>Bundles</source>
          <target state="translated">Bundles</target>
        </trans-unit>
        <trans-unit id="57402f7215532c14b5a4891e2bc99d5f27572992" translate="yes" xml:space="preserve">
          <source>Bundles are treated specially in the CPAN package. If you say 'install Bundle::Tkkit' (assuming such a bundle exists), CPAN will install all the modules in the CONTENTS section of the pod. You can install your own Bundles locally by placing a conformant Bundle file somewhere into your @INC path. The autobundle() command which is available in the shell interface does that for you by including all currently installed modules in a snapshot bundle file.</source>
          <target state="translated">Los paquetes son tratados especialmente en el paquete CPAN.Si dices 'instalar Paquete::Tkkit' (asumiendo que tal paquete existe),el CPAN instalará todos los módulos en la sección de CONTENIDO del pod.Puede instalar sus propios paquetes localmente colocando un archivo Bundle conforme en algún lugar de su ruta @INC.El comando autobundle()que está disponible en la interfaz de la shell lo hace por usted incluyendo todos los módulos actualmente instalados en un archivo bundle de instantánea.</target>
        </trans-unit>
        <trans-unit id="654a81f2d3a7234ab3c1e3ba078dd1e95b9d8acf" translate="yes" xml:space="preserve">
          <source>Bundling</source>
          <target state="translated">Bundling</target>
        </trans-unit>
        <trans-unit id="d01b7bc2d8bcb3e8147c5617d5cc44c01b525846" translate="yes" xml:space="preserve">
          <source>But</source>
          <target state="translated">But</target>
        </trans-unit>
        <trans-unit id="4409f482ed69df6dea8ad78ddaf1fc21ee472c98" translate="yes" xml:space="preserve">
          <source>But (for the foreseeable future), Pod does not provide any way for Pod authors to distinguish which grouping is meant by the above &quot;=item&quot;-cluster structure. So formatters should format it like so:</source>
          <target state="translated">Pero (para el futuro previsible),Pod no proporciona ninguna manera de que los autores de Pod distingan qué agrupación se entiende por la estructura de grupo &quot;=ítem&quot; anterior.Por lo tanto,los formateadores deberían darle un formato como este:</target>
        </trans-unit>
        <trans-unit id="90e0c4e431de8ceb3ea88d2476b9cdf6b06e1777" translate="yes" xml:space="preserve">
          <source>But I consider that somewhat of a distraction from the work of getting the main code working -- to say nothing of the fact that I often have to play with the program a few times before I can decide exactly what wording I want in the messages (which in this case would require me to go changing three lines of code: the call to maketext with that key, and then the two lines in ThisProject/I18N/en.pm).</source>
          <target state="translated">Pero considero que eso es algo que me distrae del trabajo de hacer funcionar el código principal,sin mencionar el hecho de que a menudo tengo que jugar con el programa unas cuantas veces antes de poder decidir exactamente qué texto quiero en los mensajes (lo que en este caso requeriría que fuera cambiando tres líneas de código:la llamada a maketext con esa tecla,y luego las dos líneas en ThisProject/I18N/es.pm).</target>
        </trans-unit>
        <trans-unit id="68ec332e5b845e28e04fd0941baf17f046ea1744" translate="yes" xml:space="preserve">
          <source>But Perl treats &lt;code&gt;\n&lt;/code&gt; as the start- and end-line delimiter, whereas Unicode specifies more characters that should be so-interpreted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab00dd7d452b56d9f0d69d34971f4ee775260627" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E
WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</source>
          <target state="translated">Pero la intenci&amp;oacute;n de Unicode es unificar los est&amp;aacute;ndares y pr&amp;aacute;cticas de conjuntos de caracteres existentes, y varios est&amp;aacute;ndares preexistentes tienen caracteres &amp;uacute;nicos que significan lo mismo que algunas de estas combinaciones, como ISO-8859-1, que tiene bastantes de ellos. Por ejemplo, &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; ya estaba en este est&amp;aacute;ndar cuando apareci&amp;oacute; Unicode. Por lo tanto, Unicode lo agreg&amp;oacute; a su repertorio como ese &amp;uacute;nico car&amp;aacute;cter. Pero Unicode considera que este car&amp;aacute;cter es equivalente a la secuencia que consta del car&amp;aacute;cter &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; seguido del car&amp;aacute;cter &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc372f6b713e0d837f8396fac1cbf07d86470ffa" translate="yes" xml:space="preserve">
          <source>But Unicode's intent is to unify the existing character set standards and practices, and several pre-existing standards have single characters that mean the same thing as some of these combinations, like ISO-8859-1, which has quite a few of them. For example, &lt;code&gt;&quot;LATIN CAPITAL LETTER E WITH ACUTE&quot;&lt;/code&gt; was already in this standard when Unicode came along. Unicode therefore added it to its repertoire as that single character. But this character is considered by Unicode to be equivalent to the sequence consisting of the character &lt;code&gt;&quot;LATIN CAPITAL LETTER E&quot;&lt;/code&gt; followed by the character &lt;code&gt;&quot;COMBINING ACUTE ACCENT&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e01ae5e7eb5b2bd27e52f97c45f989f3f7c27c0" translate="yes" xml:space="preserve">
          <source>But a warning is in order. When using the following to make a copy of a number, only a shallow copy will be made.</source>
          <target state="translated">Pero es necesario hacer una advertencia.Cuando se utiliza lo siguiente para hacer una copia de un número,sólo se hará una copia superficial.</target>
        </trans-unit>
        <trans-unit id="402f2e961d9afb45626c390dcfdcf325381214c3" translate="yes" xml:space="preserve">
          <source>But any modifiers will still apply to all the components:</source>
          <target state="translated">Pero cualquier modificador se seguirá aplicando a todos los componentes:</target>
        </trans-unit>
        <trans-unit id="066f97bc3c6fb6f4f0d1613419193dc5c411fa60" translate="yes" xml:space="preserve">
          <source>But as you might well imagine, this can get pretty rough on the reader.</source>
          <target state="translated">Pero como se puede imaginar,esto puede ser muy duro para el lector.</target>
        </trans-unit>
        <trans-unit id="52f632f5c831c8135e210771e0889bbe7f7800a2" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; has no special meaning.</source>
          <target state="translated">Pero la asignaci&amp;oacute;n de peso para los ideogramas unificados de CJK en la &lt;code&gt;table&lt;/code&gt; o &lt;code&gt;entry&lt;/code&gt; sigue siendo v&amp;aacute;lida. Si &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; se pasa expl&amp;iacute;citamente como el valor de esta clave, los pesos de los ideogramas unificados de CJK se tratan como indefinidos. Sin embargo, cuando &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; &lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;)&lt;/code&gt; no tiene un significado especial.</target>
        </trans-unit>
        <trans-unit id="3d36eb62a097e882438bf9a3637e15c6d9e493e5" translate="yes" xml:space="preserve">
          <source>But assignment of weight for CJK unified ideographs in &lt;code&gt;table&lt;/code&gt; or &lt;code&gt;entry&lt;/code&gt; is still valid. If &lt;code&gt;undef&lt;/code&gt; is passed explicitly as the value for this key, weights for CJK unified ideographs are treated as undefined. However when &lt;code&gt;UCA_Version&lt;/code&gt; &amp;gt; 8, &lt;code&gt;(overrideCJK =&amp;gt; undef)&lt;/code&gt; has no special meaning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1e716943619b45aa9ba23cbbf0f24483f934af2" translate="yes" xml:space="preserve">
          <source>But be quite sure that &lt;code&gt;ok&lt;/code&gt; is called exactly as many times in the first block as &lt;code&gt;skip&lt;/code&gt; is called in the second block.</source>
          <target state="translated">Pero aseg&amp;uacute;rese de que se llame a &lt;code&gt;ok&lt;/code&gt; exactamente tantas veces en el primer bloque como a &lt;code&gt;skip&lt;/code&gt; en el segundo bloque.</target>
        </trans-unit>
        <trans-unit id="6a9db2da200feea27e3e89ec89ca9f8bf249bcbc" translate="yes" xml:space="preserve">
          <source>But both are slower than assigning the empty list or undefining %HASH or @ARRAY, which is the customary way to empty out an aggregate:</source>
          <target state="translated">Pero ambos son más lentos que asignar la lista vacía o indefinir %HASH o @ARRAY,que es la forma habitual de vaciar un agregado:</target>
        </trans-unit>
        <trans-unit id="527a74597b28c7ec00ae7d09430ff9201f3f5a87" translate="yes" xml:space="preserve">
          <source>But don't bother him, he's retired.</source>
          <target state="translated">Pero no lo molestes,está retirado.</target>
        </trans-unit>
        <trans-unit id="04440d595d2cdff8c05a9e9393436d8792f429f8" translate="yes" xml:space="preserve">
          <source>But don't put</source>
          <target state="translated">Pero no pongas</target>
        </trans-unit>
        <trans-unit id="9491e2071e60f65ae593369952ca1ddd75bbfad0" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; , and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt; ). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="translated">Pero debido a un error que no se puede arreglar (arreglarlo romper&amp;iacute;a muchos m&amp;oacute;dulos CPAN existentes) en el archivo de mapa de tipos, el recuento de referencias del &lt;code&gt;AV *&lt;/code&gt; no se reduce correctamente. Por lo tanto, el XSUB anterior perder&amp;aacute; memoria cada vez que se llame. El mismo problema existe para &lt;code&gt;HV *&lt;/code&gt; , &lt;code&gt;CV *&lt;/code&gt; y &lt;code&gt;SVREF&lt;/code&gt; (que indica una referencia escalar, no un &lt;code&gt;SV *&lt;/code&gt; general ). En el c&amp;oacute;digo XS en perls que comienzan con perl 5.16, puede anular los mapas de tipos para cualquiera de estos tipos con una versi&amp;oacute;n que maneje correctamente los recuentos de referencias. En tu secci&amp;oacute;n &lt;code&gt;TYPEMAP&lt;/code&gt; , haz</target>
        </trans-unit>
        <trans-unit id="3bda93cc7a8a89f24895e1ee457675fc5ec79f7f" translate="yes" xml:space="preserve">
          <source>But due to an unfixable bug (fixing it would break lots of existing CPAN modules) in the typemap file, the reference count of the &lt;code&gt;AV *&lt;/code&gt; is not properly decremented. Thus, the above XSUB would leak memory whenever it is being called. The same problem exists for &lt;code&gt;HV *&lt;/code&gt;, &lt;code&gt;CV *&lt;/code&gt;, and &lt;code&gt;SVREF&lt;/code&gt; (which indicates a scalar reference, not a general &lt;code&gt;SV *&lt;/code&gt;). In XS code on perls starting with perl 5.16, you can override the typemaps for any of these types with a version that has proper handling of refcounts. In your &lt;code&gt;TYPEMAP&lt;/code&gt; section, do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9ca11f359e927d9da9a4e640717e37037c1c98" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt; , to use that; if not so specificable, you can use use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt; . &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt; , hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="translated">Pero lo m&amp;aacute;s f&amp;aacute;cil es usarlo si el car&amp;aacute;cter se puede especificar como literal, como &lt;code&gt;&quot;A&quot;&lt;/code&gt; o &lt;code&gt;&quot;%&quot;&lt;/code&gt; ; si no es tan espec&amp;iacute;fico, puede usar use &lt;code&gt;\N{}&lt;/code&gt; , si los efectos secundarios no son molestos. Simplemente especifique todos sus caracteres en hexadecimal, usando &lt;code&gt;\N{U+ZZ}&lt;/code&gt; lugar de &lt;code&gt;\xZZ&lt;/code&gt; . &lt;code&gt;\N{}&lt;/code&gt; es el nombre Unicode, por lo que siempre le da el car&amp;aacute;cter Unicode. &lt;code&gt;\N{U+41}&lt;/code&gt; es el car&amp;aacute;cter cuyo punto de c&amp;oacute;digo Unicode es &lt;code&gt;0x41&lt;/code&gt; , por lo que es &lt;code&gt;'A'&lt;/code&gt; en todas las plataformas. Los efectos secundarios son:</target>
        </trans-unit>
        <trans-unit id="2d7d9f0491fdf8f26d2ae8e336ebfac29d297c05" translate="yes" xml:space="preserve">
          <source>But easiest is, if the character is specifiable as a literal, like &lt;code&gt;&quot;A&quot;&lt;/code&gt; or &lt;code&gt;&quot;%&quot;&lt;/code&gt;, to use that; if not so specificable, you can use &lt;code&gt;\N{}&lt;/code&gt; , if the side effects aren't troublesome. Simply specify all your characters in hex, using &lt;code&gt;\N{U+ZZ}&lt;/code&gt; instead of &lt;code&gt;\xZZ&lt;/code&gt;. &lt;code&gt;\N{}&lt;/code&gt; is the Unicode name, and so it always gives you the Unicode character. &lt;code&gt;\N{U+41}&lt;/code&gt; is the character whose Unicode code point is &lt;code&gt;0x41&lt;/code&gt;, hence is &lt;code&gt;'A'&lt;/code&gt; on all platforms. The side effects are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e336391004e93bf9adbf972f876990718b27f63" translate="yes" xml:space="preserve">
          <source>But failure_handler_auto, instead of dying or anything, compiles $key, caching it in</source>
          <target state="translated">Pero el &quot;Failure_handler_auto&quot;,en lugar de morir o cualquier otra cosa,compila $key,guardándolo en caché</target>
        </trans-unit>
        <trans-unit id="d44c97279f7f106146fa21778196b89c19981fbb" translate="yes" xml:space="preserve">
          <source>But fear not, there's a simple solution. The module &lt;code&gt;Sub::Name&lt;/code&gt; will reach into the perl internals and assign a name to an anonymous subroutine for you. Simply do this:</source>
          <target state="translated">Pero no temas, hay una soluci&amp;oacute;n sencilla. El m&amp;oacute;dulo &lt;code&gt;Sub::Name&lt;/code&gt; llegar&amp;aacute; al interior de perl y le asignar&amp;aacute; un nombre a una subrutina an&amp;oacute;nima. Simplemente haz esto:</target>
        </trans-unit>
        <trans-unit id="6c88ebcfc6d7c83b843d2d6f3e737b05e79bf378" translate="yes" xml:space="preserve">
          <source>But for &quot;directory&quot;, you'd want &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; so that our elementary &lt;code&gt;quant&lt;/code&gt; method doesn't think that the plural of &quot;directory&quot; is &quot;directorys&quot;. And you might find that the output may sound better if you specify a negative form, as in:</source>
          <target state="translated">Pero para &quot;directorio&quot;, querr&amp;iacute;a &lt;code&gt;&quot;[quant,_1,directory,directories]&quot;&lt;/code&gt; para que nuestro m&amp;eacute;todo &lt;code&gt;quant&lt;/code&gt; elemental no crea que el plural de &quot;directorio&quot; es &quot;directorys&quot;. Y puede encontrar que la salida puede sonar mejor si especifica una forma negativa, como en:</target>
        </trans-unit>
        <trans-unit id="490b6f6af7c2374cd5fd42c108629dc25f1e6fdb" translate="yes" xml:space="preserve">
          <source>But for now, let's look at general issues common to all these types of data structures.</source>
          <target state="translated">Pero por ahora,veamos las cuestiones generales comunes a todos estos tipos de estructuras de datos.</target>
        </trans-unit>
        <trans-unit id="44e2925861f8472f51f5341cbaaf661343ddc11e" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;Locale::Maketext::TPJ13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt;/&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fcb950a418ab15715107f772519ba0899f4c7c" translate="yes" xml:space="preserve">
          <source>But for other languages (as is discussed at length in &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale::Maketext::TPJ13&lt;/a&gt;), simple &lt;code&gt;quant&lt;/code&gt; /&lt;code&gt;numf&lt;/code&gt; is not enough. For the particularly problematic Slavic languages, what you may need is a method which you provide with the number, the citation form of the noun to quantify, and the case and gender that the sentence's syntax projects onto that noun slot. The method would then be responsible for determining what grammatical number that numeral projects onto its noun phrase, and what case and gender it may override the normal case and gender with; and then it would look up the noun in a lexicon providing all needed inflected forms.</source>
          <target state="translated">Pero para otros lenguajes (como se discute extensamente en &lt;a href=&quot;maketext/tpj13&quot;&gt;Locale :: Maketext :: TPJ13&lt;/a&gt; ), el simple &lt;code&gt;quant&lt;/code&gt; / &lt;code&gt;numf&lt;/code&gt; no es suficiente. Para los lenguajes eslavos particularmente problem&amp;aacute;ticos, lo que puede necesitar es un m&amp;eacute;todo que proporcione con el n&amp;uacute;mero, la forma de cita del sustantivo a cuantificar y el caso y el g&amp;eacute;nero que la sintaxis de la oraci&amp;oacute;n proyecta en ese espacio nominal. El m&amp;eacute;todo ser&amp;iacute;a entonces responsable de determinar qu&amp;eacute; n&amp;uacute;mero gramatical proyecta ese numeral en su sintagma nominal, y en qu&amp;eacute; caso y g&amp;eacute;nero puede anular el caso y el g&amp;eacute;nero normales; y luego buscar&amp;iacute;a el sustantivo en un l&amp;eacute;xico que proporciona todas las formas flexionadas necesarias.</target>
        </trans-unit>
        <trans-unit id="ef8dab0f4d9389f9bb5dc21779fdfd4e9a160e11" translate="yes" xml:space="preserve">
          <source>But for some processors/formats this cannot be easily controlled; as with the HTML example, the behavior of multiple ambiguous &amp;lt;a name=&quot;</source>
          <target state="translated">Pero para algunos procesadores / formatos, esto no se puede controlar f&amp;aacute;cilmente; como en el ejemplo HTML, el comportamiento de varios &amp;lt;a name = &quot;ambiguos</target>
        </trans-unit>
        <trans-unit id="8b46bf6bc073f2a792b2de8dc4b3f11e31f9c12f" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK.</source>
          <target state="translated">Pero generalmente,un bloque está delimitado por corchetes rizados,también conocidos como tirantes.Llamaremos a esta construcción sintáctica un BLOQUE.</target>
        </trans-unit>
        <trans-unit id="12fcc42a7dd22316cac44e40d51daa68deca033b" translate="yes" xml:space="preserve">
          <source>But generally, a block is delimited by curly brackets, also known as braces. We will call this syntactic construct a BLOCK. Because enclosing braces are also the syntax for hash reference constructor expressions (see &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;), you may occasionally need to disambiguate by placing a &lt;code&gt;;&lt;/code&gt; immediately after an opening brace so that Perl realises the brace is the start of a block. You will more frequently need to disambiguate the other way, by placing a &lt;code&gt;+&lt;/code&gt; immediately before an opening brace to force it to be interpreted as a hash reference constructor expression. It is considered good style to use these disambiguating mechanisms liberally, not only when Perl would otherwise guess incorrectly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ccefce54f83b7f4c3b397919dd3e84e700ff50bd" translate="yes" xml:space="preserve">
          <source>But if the client asks for &quot;i-Mingo&quot; or &quot;x-mingo&quot;, or &quot;Fr&quot;, then the lookup in %greetings fails. That's the Wrong Thing.</source>
          <target state="translated">Pero si el cliente pide &quot;i-Mingo&quot; o &quot;x-mingo&quot;,o &quot;Fr&quot;,entonces la búsqueda en % saludos falla.Eso es lo malo.</target>
        </trans-unit>
        <trans-unit id="ec6083b91636d75d0495261998b67a37e19945dc" translate="yes" xml:space="preserve">
          <source>But if the document starts out:</source>
          <target state="translated">Pero si el documento comienza:</target>
        </trans-unit>
        <trans-unit id="018410255214e3cce3a8b05ae3d7d99e0330f4d0" translate="yes" xml:space="preserve">
          <source>But if you subclass Pod::Simple::Methody, it will instead do this when it sees a &quot;=head1 Hi there&quot;:</source>
          <target state="translated">Pero si subclasifica Pod::Simple::Metodología,lo hará cuando vea un &quot;=cabeza1 Hola&quot;:</target>
        </trans-unit>
        <trans-unit id="0cf73c47906927595e3043b178988fd87c4d5b4a" translate="yes" xml:space="preserve">
          <source>But if you try this:</source>
          <target state="translated">Pero si intentas esto:</target>
        </trans-unit>
        <trans-unit id="90ee606d0538a1d21fc1f464d165e33c56162b66" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt; , you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="translated">Pero si desea apariciones anidadas de &lt;code&gt;START&lt;/code&gt; a &lt;code&gt;END&lt;/code&gt; , se encontrar&amp;aacute; con el problema descrito en la pregunta de esta secci&amp;oacute;n sobre la coincidencia de texto equilibrado.</target>
        </trans-unit>
        <trans-unit id="3edd5ad7f10118d3c50f146510574f8277f3c749" translate="yes" xml:space="preserve">
          <source>But if you want nested occurrences of &lt;code&gt;START&lt;/code&gt; through &lt;code&gt;END&lt;/code&gt;, you'll run up against the problem described in the question in this section on matching balanced text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95d91fb2e9c31e4e480c3aa19de7d332e4a9c236" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be in writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt; , so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt; , then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; , and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN
SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but require familiarity with Unicode.</source>
          <target state="translated">Pero si escribe un c&amp;oacute;digo que usa &lt;code&gt;\005&lt;/code&gt; para significar una TAB o &lt;code&gt;\xC1&lt;/code&gt; para significar una &quot;A&quot;, o &lt;code&gt;\xDF&lt;/code&gt; para significar una &quot;&amp;yuml;&quot; ( &lt;code&gt;&quot;y&quot;&lt;/code&gt; peque&amp;ntilde;a con una di&amp;eacute;resis), entonces su c&amp;oacute;digo puede funcionar en su Plataforma EBCDIC, pero no en ASCII. Est&amp;aacute; bien hacerlo si nadie querr&amp;aacute; ejecutar su c&amp;oacute;digo en una plataforma ASCII; pero el sesgo en este documento estar&amp;aacute; en la escritura de c&amp;oacute;digo port&amp;aacute;til entre sistemas EBCDIC y ASCII. Nuevamente, si todos los caracteres que le interesan se pueden ingresar f&amp;aacute;cilmente desde su teclado, no tiene que saber nada sobre ASCII, pero muchos teclados no le permiten ingresar directamente, digamos, el car&amp;aacute;cter &lt;code&gt;\xDF&lt;/code&gt; , por lo que debe hacerlo especificarlo indirectamente, como mediante el uso de &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; secuencia de escape. En esos casos, es m&amp;aacute;s f&amp;aacute;cil saber algo sobre los conjuntos de caracteres ASCII / Unicode. Si sabe que la &quot;&amp;yuml;&quot; peque&amp;ntilde;a es &lt;code&gt;U+00FF&lt;/code&gt; , puede especificarla como &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt; y hacer que la computadora la traduzca autom&amp;aacute;ticamente a &lt;code&gt;\xDF&lt;/code&gt; en su plataforma, y ​​dejarla como &lt;code&gt;\xFF&lt;/code&gt; en ASCII. O puede especificarlo por su nombre, &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; y no tener que conocer los n&amp;uacute;meros. De cualquier manera funciona, pero requiere familiaridad con Unicode.</target>
        </trans-unit>
        <trans-unit id="8c5b9a3f892143e75b663a18f94ea6753bbb8def" translate="yes" xml:space="preserve">
          <source>But if you write code that uses &lt;code&gt;\005&lt;/code&gt; to mean a TAB or &lt;code&gt;\xC1&lt;/code&gt; to mean an &quot;A&quot;, or &lt;code&gt;\xDF&lt;/code&gt; to mean a &quot;&amp;yuml;&quot; (small &lt;code&gt;&quot;y&quot;&lt;/code&gt; with a diaeresis), then your code may well work on your EBCDIC platform, but not on an ASCII one. That's fine to do if no one will ever want to run your code on an ASCII platform; but the bias in this document will be towards writing code portable between EBCDIC and ASCII systems. Again, if every character you care about is easily enterable from your keyboard, you don't have to know anything about ASCII, but many keyboards don't easily allow you to directly enter, say, the character &lt;code&gt;\xDF&lt;/code&gt;, so you have to specify it indirectly, such as by using the &lt;code&gt;&quot;\xDF&quot;&lt;/code&gt; escape sequence. In those cases it's easiest to know something about the ASCII/Unicode character sets. If you know that the small &quot;&amp;yuml;&quot; is &lt;code&gt;U+00FF&lt;/code&gt;, then you can instead specify it as &lt;code&gt;&quot;\N{U+FF}&quot;&lt;/code&gt;, and have the computer automatically translate it to &lt;code&gt;\xDF&lt;/code&gt; on your platform, and leave it as &lt;code&gt;\xFF&lt;/code&gt; on ASCII ones. Or you could specify it by name, &lt;code&gt;\N{LATIN SMALL LETTER Y WITH DIAERESIS&lt;/code&gt; and not have to know the numbers. Either way works, but both require familiarity with Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cb0a7929d9be6d467d0702a4ca1482bdad00292" translate="yes" xml:space="preserve">
          <source>But if you're a perl programmer, then for you I have something much more wondrous than just a structure offset printer.</source>
          <target state="translated">Pero si eres un programador de perl,entonces para ti tengo algo mucho más maravilloso que una impresora offset de estructuras.</target>
        </trans-unit>
        <trans-unit id="b5d1347e7974f3a5c8f6ee662fc96a7143711f4b" translate="yes" xml:space="preserve">
          <source>But if you're using &lt;code&gt;PerlIO_printf()&lt;/code&gt;, it's less typing and visual clutter to use the &lt;code&gt;%z&lt;/code&gt; length modifier (for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c71d4b40a76244fed8568f06f2e4623c952ed6" translate="yes" xml:space="preserve">
          <source>But in any case, try to keep the features and operating systems separate.</source>
          <target state="translated">Pero en cualquier caso,trate de mantener las características y los sistemas operativos separados.</target>
        </trans-unit>
        <trans-unit id="f86252e7b4ed24cc14ced10c8828354685807171" translate="yes" xml:space="preserve">
          <source>But in case you find the need to...</source>
          <target state="translated">Pero en caso de que encuentre la necesidad de...</target>
        </trans-unit>
        <trans-unit id="3425ba57841c54a0c594ad2ebd352f7a60dfde42" translate="yes" xml:space="preserve">
          <source>But in general, such surprises are rare when entire sentences are being translated, especially when the functional context is restricted to that of a computer interacting with a user either to convey a fact or to prompt for a piece of information. So, for purposes of localization, translation by phrase (generally by sentence) is both the simplest and the least problematic.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8e2d7167267546a3345c93288a69c7eaaae59c46" translate="yes" xml:space="preserve">
          <source>But in many cases, especially multi-byte CJK encodings, you have to tweak a little more. Your network connection may not accept any data with the Most Significant Bit set, and your computer may not be able to tell if a given byte is a whole character or just half of it. So you have to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56073db003479cbcc5aa02dbdcbc3839993740e4" translate="yes" xml:space="preserve">
          <source>But in other cases, it just is that no one has implemented support yet. Patches welcome! Some elements are ported backward for some releases, but not all the way to 5.003_07.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca1b980e76b99df2ec3833fb22b3d48a26eb466f" translate="yes" xml:space="preserve">
          <source>But in this particular example, you probably really want</source>
          <target state="translated">Pero en este ejemplo en particular,probablemente quieras realmente</target>
        </trans-unit>
        <trans-unit id="3cee8270da886ebc5c44d683d110f389adb2e169" translate="yes" xml:space="preserve">
          <source>But it actually compiles as this:</source>
          <target state="translated">Pero en realidad se compila así:</target>
        </trans-unit>
        <trans-unit id="823e1d2128bc470581c23a9dfa7a058a23c8a7f1" translate="yes" xml:space="preserve">
          <source>But it also puts the same information in certain fields of the XSUB itself:</source>
          <target state="translated">Pero también pone la misma información en ciertos campos del propio XSUB:</target>
        </trans-unit>
        <trans-unit id="f5f796fef481b4bfaedc4fb27aaba8e13316d437" translate="yes" xml:space="preserve">
          <source>But it also works on lexically declared aggregates.</source>
          <target state="translated">Pero también funciona con agregados declarados léxicamente.</target>
        </trans-unit>
        <trans-unit id="bce306df93e9efe810cd4909bfa7982e26681041" translate="yes" xml:space="preserve">
          <source>But it could equally well be a discussion of three (related or equivalent) items, &quot;Neque&quot;, &quot;Porro&quot;, and &quot;Quisquam Est&quot;, followed by a paragraph explaining them all, and then a new item &quot;Ut Enim&quot;. In that case, you'd probably want to format it like so:</source>
          <target state="translated">Pero también podría ser una discusión de tres artículos (relacionados o equivalentes),&quot;Neque&quot;,&quot;Porro&quot; y &quot;Quisquam Est&quot;,seguido de un párrafo que los explicara todos,y luego un nuevo artículo &quot;Ut Enim&quot;.En ese caso,probablemente querrás darle un formato así:</target>
        </trans-unit>
        <trans-unit id="ad75a36ebc7396598ae4020570b59b4dddb1d077" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Perl 6. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="translated">Pero no funciona en absoluto en Perl 6. En su lugar, debe usar el operador &lt;code&gt;any&lt;/code&gt; (paralelizable) :</target>
        </trans-unit>
        <trans-unit id="5bdbc1f908497576f552335e7ff9cc35570484f5" translate="yes" xml:space="preserve">
          <source>But it doesn't work at all in Raku. Instead, you should use the (parallelizable) &lt;code&gt;any&lt;/code&gt; operator:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf7fd3170743bf29faac8bcfc9396e4e0b2afa0e" translate="yes" xml:space="preserve">
          <source>But it will croak if:</source>
          <target state="translated">Pero si se muere..:</target>
        </trans-unit>
        <trans-unit id="934319e95a665a2a7425edac031de11ea5229dad" translate="yes" xml:space="preserve">
          <source>But most importantly, it works on systems that don't have &lt;code&gt;nl_langinfo&lt;/code&gt;, such as Windows, hence makes your code more portable. Of the fifty-some possible items specified by the POSIX 2008 standard, &lt;a href=&quot;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&quot;&gt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&lt;/a&gt;, only one is completely unimplemented, though on non-Windows platforms, another significant one is also not implemented). It uses various techniques to recover the other items, including calling &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/strftime&quot;&gt;strftime(3)&lt;/a&gt;&lt;/code&gt;, both of which are specified in C89, so should be always be available. Later &lt;code&gt;strftime()&lt;/code&gt; versions have additional capabilities; &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned for those not available on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49401717215b8f0f347edc31ef79b337c80caafe" translate="yes" xml:space="preserve">
          <source>But most importantly, it works on systems that don't have &lt;code&gt;nl_langinfo&lt;/code&gt;, such as Windows, hence makes your code more portable. Of the fifty-some possible items specified by the POSIX 2008 standard, &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&quot;&gt;http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/langinfo.h.html&lt;/a&gt;, only one is completely unimplemented, though on non-Windows platforms, another significant one is also not implemented). It uses various techniques to recover the other items, including calling &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/strftime&quot;&gt;strftime(3)&lt;/a&gt;&lt;/code&gt;, both of which are specified in C89, so should be always be available. Later &lt;code&gt;strftime()&lt;/code&gt; versions have additional capabilities; &lt;code&gt;&quot;&quot;&lt;/code&gt; is returned for those not available on your system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac22b7287d2aed5e7462242749c989d65753c887" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; , and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="translated">Pero nunca utilice el &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; sin antes haber configurado una codificaci&amp;oacute;n predeterminada. De lo contrario, Perl no puede saber cu&amp;aacute;l de los muchos, muchos, muchos tipos posibles de archivos de texto tiene, y Perl no tendr&amp;aacute; idea de c&amp;oacute;mo mapear correctamente los datos en su archivo en caracteres reales con los que pueda trabajar. Otros formatos de codificaci&amp;oacute;n comunes, incluidos &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt; , &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt; , &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt; , &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt; e incluso &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt; . Consulte &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n sobre codificaciones.</target>
        </trans-unit>
        <trans-unit id="a0747e69fd78e083ffa59b04def2af91b0c7abf3" translate="yes" xml:space="preserve">
          <source>But never use the bare &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; without having set up a default encoding first. Otherwise, Perl cannot know which of the many, many, many possible flavors of text file you have, and Perl will have no idea how to correctly map the data in your file into actual characters it can work with. Other common encoding formats including &lt;code&gt;&quot;ASCII&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-1&quot;&lt;/code&gt;, &lt;code&gt;&quot;ISO-8859-15&quot;&lt;/code&gt;, &lt;code&gt;&quot;Windows-1252&quot;&lt;/code&gt;, &lt;code&gt;&quot;MacRoman&quot;&lt;/code&gt;, and even &lt;code&gt;&quot;UTF-16LE&quot;&lt;/code&gt;. See &lt;a href=&quot;perlunitut&quot;&gt;perlunitut&lt;/a&gt; for more about encodings.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eca085acb0ddeeb52a224b25677bc101217dcb2a" translate="yes" xml:space="preserve">
          <source>But note that these last three macros are valid only if &lt;code&gt;SvPOK()&lt;/code&gt; is true.</source>
          <target state="translated">Pero tenga en cuenta que estas &amp;uacute;ltimas tres macros son v&amp;aacute;lidas solo si &lt;code&gt;SvPOK()&lt;/code&gt; es verdadero.</target>
        </trans-unit>
        <trans-unit id="5960a3f75e9619ab812c7dea1d6e781ac954880e" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt; . If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="translated">Pero tenga en cuenta que esto no significa que cualquiera de los caracteres de la cadena sea necesario codificado en UTF-8, o que alguno de los caracteres tenga puntos de c&amp;oacute;digo mayores que 0xFF (255) o incluso 0x80 (128), o que la cadena tenga cualquier personaje en absoluto. Todo lo que hace &lt;code&gt;is_utf8()&lt;/code&gt; es devolver el valor de la bandera interna &quot;utf8ness&quot; adjunta a la &lt;code&gt;$string&lt;/code&gt; . Si el indicador est&amp;aacute; desactivado, los bytes del escalar se interpretan como una codificaci&amp;oacute;n de un solo byte. Si la bandera est&amp;aacute; activada, los bytes del escalar se interpretan como los puntos de c&amp;oacute;digo codificados en UTF-8 (de longitud variable, potencialmente multibyte) de los caracteres. Los bytes agregados a una cadena codificada en UTF-8 se actualizan autom&amp;aacute;ticamente a UTF-8. Si se combinan escalares mixtos que no son UTF-8 y UTF-8 (interpolaci&amp;oacute;n entre comillas dobles, concatenaci&amp;oacute;n expl&amp;iacute;cita o sustituci&amp;oacute;n de par&amp;aacute;metros printf / sprintf), el resultado ser&amp;aacute; codificado en UTF-8 como si las copias de las cadenas de bytes se actualizaran a UTF -8: por ejemplo,</target>
        </trans-unit>
        <trans-unit id="f3b88a9932e49bdc61514a0893c4a2b1cc99c884" translate="yes" xml:space="preserve">
          <source>But note that this doesn't mean that any of the characters in the string are necessary UTF-8 encoded, or that any of the characters have code points greater than 0xFF (255) or even 0x80 (128), or that the string has any characters at all. All the &lt;code&gt;is_utf8()&lt;/code&gt; does is to return the value of the internal &quot;utf8ness&quot; flag attached to the &lt;code&gt;$string&lt;/code&gt;. If the flag is off, the bytes in the scalar are interpreted as a single byte encoding. If the flag is on, the bytes in the scalar are interpreted as the (variable-length, potentially multi-byte) UTF-8 encoded code points of the characters. Bytes added to a UTF-8 encoded string are automatically upgraded to UTF-8. If mixed non-UTF-8 and UTF-8 scalars are merged (double-quoted interpolation, explicit concatenation, or printf/sprintf parameter substitution), the result will be UTF-8 encoded as if copies of the byte strings were upgraded to UTF-8: for example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3ed10f08c2a7b806d29712ea53fb65371e6dda25" translate="yes" xml:space="preserve">
          <source>But prior to v5.16, you must be explicit about which set of charnames you want. The &lt;code&gt;:full&lt;/code&gt; names are the official Unicode character name, alias, or sequence, which all share a namespace.</source>
          <target state="translated">Pero antes de v5.16, debe ser expl&amp;iacute;cito sobre qu&amp;eacute; conjunto de nombres de caracteres desea. Los &lt;code&gt;:full&lt;/code&gt; nombres completos son el nombre, alias o secuencia oficial de caracteres Unicode, que comparten un espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="6ea0e56fa9cef58c93ebf2b8ef0ed82782b2271a" translate="yes" xml:space="preserve">
          <source>But recall that not all operating systems support forking or capturing of the output of commands, so this complex statement may not be portable.</source>
          <target state="translated">Pero recuerde que no todos los sistemas operativos soportan el bifurcado o la captura de la salida de los comandos,por lo que esta compleja afirmación puede no ser portátil.</target>
        </trans-unit>
        <trans-unit id="80db3d6002a0ea4be473c7d7a0631f6d66de4e4e" translate="yes" xml:space="preserve">
          <source>But second off, it's not isomorphic -- the &quot;solution&quot; (i.e., the phrasebook entries) for Chinese maps from these four English phrases to the one Chinese phrase that fits for all of them. In other words, the informal solution would be &quot;The way to say what you want in Chinese is with the one phrase 'For your question, in Y directories you would find X files'&quot; -- and so the implemented solution should be, isomorphically, just a straightforward way to spit out that one phrase, with numerals properly interpolated. It shouldn't have to map from the complexity of other languages to the simplicity of this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f098d4fba29dcb8c3c77666f8cde3d29b4074e10" translate="yes" xml:space="preserve">
          <source>But some modules cannot be built with this mantra. They try to get some extra data from the user via the environment, extra arguments, or interactively--thus disturbing the installation of large bundles like Phalanx100 or modules with many dependencies like Plagger.</source>
          <target state="translated">Pero algunos módulos no pueden ser construidos con este mantra.Intentan obtener algunos datos extra del usuario a través del entorno,argumentos extra,o interactivamente-lo que perturba la instalación de grandes paquetes como Phalanx100 o módulos con muchas dependencias como Plagger.</target>
        </trans-unit>
        <trans-unit id="b9343448796744b38fdcc31c04963c50f230e565" translate="yes" xml:space="preserve">
          <source>But stringify it and you get just the text content:</source>
          <target state="translated">Pero si lo encadenas,obtienes sólo el contenido del texto:</target>
        </trans-unit>
        <trans-unit id="420149069302ad928f47370a01dc8262cabda22d" translate="yes" xml:space="preserve">
          <source>But take care not to pass it as, for example</source>
          <target state="translated">Pero ten cuidado de no pasarla como,por ejemplo</target>
        </trans-unit>
        <trans-unit id="f5ed605cf911baa94f53b7f6af1d782e89ccd2f6" translate="yes" xml:space="preserve">
          <source>But testing for taintedness gets you only so far. Sometimes you have just to clear your data's taintedness. Values may be untainted by using them as keys in a hash; otherwise the only way to bypass the tainting mechanism is by referencing subpatterns from a regular expression match. Perl presumes that if you reference a substring using $1, $2, etc. in a non-tainting pattern, that you knew what you were doing when you wrote that pattern. That means using a bit of thought--don't just blindly untaint anything, or you defeat the entire mechanism. It's better to verify that the variable has only good characters (for certain values of &quot;good&quot;) rather than checking whether it has any bad characters. That's because it's far too easy to miss bad characters that you never thought of.</source>
          <target state="translated">Pero la prueba de la contaminación sólo te lleva hasta cierto punto.A veces sólo tienes que limpiar la corrupción de tus datos.Los valores pueden ser inmaculados usándolos como claves en un hash;de lo contrario,la única manera de evitar el mecanismo de contaminación es haciendo referencia a subpatrones de una coincidencia de expresión regular.Perl presume que si se hace referencia a una subcadena usando $1,$2,etc.en un patrón no contaminado,que se sabía lo que se hacía cuando se escribió ese patrón.Eso significa que usando un poco de pensamiento...no sólo destierras ciegamente nada,o derrotas todo el mecanismo.Es mejor verificar que la variable sólo tiene caracteres buenos (para ciertos valores de &quot;bueno&quot;)que comprobar si tiene caracteres malos.Eso es porque es demasiado fácil perder los caracteres malos que nunca se te ocurrieron.</target>
        </trans-unit>
        <trans-unit id="07ab01a33d4e7c1814e10d3a1451c86fcb0fab16" translate="yes" xml:space="preserve">
          <source>But that can produce ambiguous syntax in certain cases, so it's often better to use the direct method invocation approach:</source>
          <target state="translated">Pero eso puede producir una sintaxis ambigua en ciertos casos,por lo que a menudo es mejor utilizar el método directo de invocación:</target>
        </trans-unit>
        <trans-unit id="4081f5e36560816f0b341323008a11e961519754" translate="yes" xml:space="preserve">
          <source>But that isn't going to match; at least, not the way you're hoping. It claims that there is no 123 in the string. Here's a clearer picture of why that pattern matches, contrary to popular expectations:</source>
          <target state="translated">Pero eso no va a coincidir;al menos,no de la manera que esperas.Afirma que no hay 123 en la cadena.Aquí hay una imagen más clara de por qué ese patrón coincide,en contra de las expectativas populares:</target>
        </trans-unit>
        <trans-unit id="07b885fe74e23c15de33bcf3d35cb8fafefcc846" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="translated">Pero ese segundo &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; est&amp;aacute; adelantando. No est&amp;aacute; usando una cadena literal simple para la plantilla. Entonces, tal vez deber&amp;iacute;amos presentar ...</target>
        </trans-unit>
        <trans-unit id="ebd21a1f53afcb90bb2e6fa1c3ee1beda8c1e31a" translate="yes" xml:space="preserve">
          <source>But that second &lt;code&gt;unpack&lt;/code&gt; is rushing ahead. It isn't using a simple literal string for the template. So maybe we should introduce...</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="861b5be1d3b22e874a1fd22ed51f10196d9c89e5" translate="yes" xml:space="preserve">
          <source>But that's not terribly pretty. You may find it simpler or clearer in the long run to just do things like this:</source>
          <target state="translated">Pero eso no es terriblemente bonito.Puede que a la larga te resulte más sencillo o más claro hacer cosas como esta:</target>
        </trans-unit>
        <trans-unit id="5d68c723e2845ae1a2c75f9213f2beec623c2f67" translate="yes" xml:space="preserve">
          <source>But that's rather inefficient. A better way to do it is to start your program with:</source>
          <target state="translated">Pero eso es bastante ineficiente.Una mejor manera de hacerlo es comenzar su programa con:</target>
        </trans-unit>
        <trans-unit id="3c5623d3d8f73ddcc75bce9ec5d80243561beb13" translate="yes" xml:space="preserve">
          <source>But the Arabic translator is the next to write back. First off, your code for &quot;I scanned %g directory.&quot; or &quot;I scanned %g directories.&quot; assumes there's only singular or plural. But, to use linguistic jargon again, Arabic has grammatical number, like English (but unlike Chinese), but it's a three-term category: singular, dual, and plural. In other words, the way you say &quot;directory&quot; depends on whether there's one directory, or</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0666cc872d80abdc9e23386d6ece439d18c0915" translate="yes" xml:space="preserve">
          <source>But the HERE_TARGET must still be flush against the margin. If you want that indented also, you'll have to quote in the indentation.</source>
          <target state="translated">Pero el HERE_TARGET todavía debe estar al ras del margen.Si quieres que también se indentifique,tendrás que citar en la indentación.</target>
        </trans-unit>
        <trans-unit id="3261d19f3d27e578566dcbff378ffaa4781a7162" translate="yes" xml:space="preserve">
          <source>But the following code is quite bad:</source>
          <target state="translated">Pero el siguiente código es bastante malo:</target>
        </trans-unit>
        <trans-unit id="903f25d05dc48316bba755ecdc1e7944baec6c3c" translate="yes" xml:space="preserve">
          <source>But the marked code isn't syntactically correct to be such an interpolated class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9ae2e6c3f8a198a1ff872d901ef6ec6abf0329" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</source>
          <target state="translated">Pero hay algunos casos en los que solo funciona esta soluci&amp;oacute;n (como &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;maybe::next::method&lt;/code&gt; );</target>
        </trans-unit>
        <trans-unit id="f444a7ccc18a957e30bdbe83f2e4500327151823" translate="yes" xml:space="preserve">
          <source>But there are some cases where only this solution works (like &lt;code&gt;goto &amp;amp;maybe::next::method&lt;/code&gt;);</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbd2ecd4d2700eece4600f310be07e3be1c2ebf" translate="yes" xml:space="preserve">
          <source>But there are some cases where you may want to know which character set you are running under. One possible example is doing &lt;a href=&quot;#SORTING&quot;&gt;sorting&lt;/a&gt; in inner loops where performance is critical.</source>
          <target state="translated">Pero hay algunos casos en los que es posible que desee saber con qu&amp;eacute; juego de caracteres se est&amp;aacute; ejecutando. Un posible ejemplo es &lt;a href=&quot;#SORTING&quot;&gt;ordenar&lt;/a&gt; en bucles internos donde el rendimiento es fundamental.</target>
        </trans-unit>
        <trans-unit id="79f382a399e7acdac77923f9261c190aa9a11824" translate="yes" xml:space="preserve">
          <source>But there's no real need for &lt;b&gt;both&lt;/b&gt; to be tempfiles... the following should work just as well, without deadlocking:</source>
          <target state="translated">Pero no hay una necesidad real de que &lt;b&gt;ambos&lt;/b&gt; sean archivos temporales ... lo siguiente deber&amp;iacute;a funcionar igual de bien, sin interbloqueo:</target>
        </trans-unit>
        <trans-unit id="5a55d83408434c70f23ed8c60b8e212b2bfead28" translate="yes" xml:space="preserve">
          <source>But they may be arbitrarily long:</source>
          <target state="translated">Pero pueden ser arbitrariamente largos:</target>
        </trans-unit>
        <trans-unit id="47bd7edd758647409df600b782dfd569cb2795d8" translate="yes" xml:space="preserve">
          <source>But they may span several (non-blank) lines:</source>
          <target state="translated">Pero pueden abarcar varias líneas (no en blanco):</target>
        </trans-unit>
        <trans-unit id="af1031e39fec41022cade090893d6211ac853b17" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt; , excluding the Laotian. Pitfalls like this can be avoided by parenthesizing the component pieces:</source>
          <target state="translated">Pero esto no tiene el efecto que probablemente esperar&amp;iacute;a alguien que lea el c&amp;oacute;digo, ya que la intersecci&amp;oacute;n se aplica solo a &lt;code&gt;\p{Thai}&lt;/code&gt; , excluyendo el laosiano. Errores como este se pueden evitar poniendo entre par&amp;eacute;ntesis los componentes:</target>
        </trans-unit>
        <trans-unit id="3e961579d9e8252ea504999636a1d461e186d84b" translate="yes" xml:space="preserve">
          <source>But this does not have the effect that someone reading the source code would likely expect, as the intersection applies just to &lt;code&gt;\p{Thai}&lt;/code&gt;, excluding the Laotian. Its best to compile the subcomponents, but you could also parenthesize the component pieces:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e39b52a31dfee971d175ae42a65864bfa50aedc" translate="yes" xml:space="preserve">
          <source>But this doesn't match, at least not the way one might expect. Only after inserting the interpolated &lt;code&gt;$a99a&lt;/code&gt; and looking at the resulting full text of the regexp is it obvious that the backreferences have backfired. The subexpression &lt;code&gt;(\w+)&lt;/code&gt; has snatched number 1 and demoted the groups in &lt;code&gt;$a99a&lt;/code&gt; by one rank. This can be avoided by using relative backreferences:</source>
          <target state="translated">Pero esto no coincide, al menos no de la forma que cabr&amp;iacute;a esperar. Solo despu&amp;eacute;s de insertar el &lt;code&gt;$a99a&lt;/code&gt; interpolado y mirar el texto completo resultante de la expresi&amp;oacute;n regular, es obvio que las referencias inversas han fracasado. La subexpresi&amp;oacute;n &lt;code&gt;(\w+)&lt;/code&gt; arrebat&amp;oacute; el n&amp;uacute;mero 1 y degrad&amp;oacute; a los grupos en &lt;code&gt;$a99a&lt;/code&gt; en un rango. Esto se puede evitar utilizando referencias inversas relativas:</target>
        </trans-unit>
        <trans-unit id="6783211af3a27626c9e0e73fe10e75f068ecbc7b" translate="yes" xml:space="preserve">
          <source>But this is not guaranteed to work.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d71f7e1b353d405d0ac11988a391e51c106c8d8" translate="yes" xml:space="preserve">
          <source>But this is not:</source>
          <target state="translated">Pero esto no lo es:</target>
        </trans-unit>
        <trans-unit id="b33d301cbe486111cdb963daebee73c9ce3e8834" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;), you may prefer:</source>
          <target state="translated">Pero para evitar las advertencias de portabilidad (ver &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; ), es posible que prefiera:</target>
        </trans-unit>
        <trans-unit id="f9f8099c8d1ed2b0fc4c9abd170ecd56ff0e63b5" translate="yes" xml:space="preserve">
          <source>But to avoid portability warnings (see &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;), you may prefer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="020939326fc990dde03b1b00ce335dbc09c9fc3e" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Pero espera: &amp;iquest;el &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; no devuelve simplemente una secuencia de bytes? &amp;iquest;C&amp;oacute;mo podemos pasar esta cadena de bytes a alg&amp;uacute;n c&amp;oacute;digo C esperando un puntero que, despu&amp;eacute;s de todo, no es m&amp;aacute;s que un n&amp;uacute;mero? La respuesta es simple: tenemos que obtener la direcci&amp;oacute;n num&amp;eacute;rica de los bytes devueltos por &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9d8b172e82350b535193e00efe170bf43ca91d34" translate="yes" xml:space="preserve">
          <source>But wait: doesn't &lt;code&gt;pack&lt;/code&gt; just return a sequence of bytes? How can we pass this string of bytes to some C code expecting a pointer which is, after all, nothing but a number? The answer is simple: We have to obtain the numeric address from the bytes returned by &lt;code&gt;pack&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="681fa12b5aa88395e6be12e5639cef0794d6ebaa" translate="yes" xml:space="preserve">
          <source>But what about user-defined subroutines from modules? If you use &lt;code&gt;autodie&lt;/code&gt; on a user-defined subroutine then it assumes the following behaviour to demonstrate failure:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1178148d2666470319bf944b3a6373f8bd5ec43c" translate="yes" xml:space="preserve">
          <source>But what happens if your test program dies halfway through?! Since we didn't say how many tests we're going to run, how can we know it failed? No problem, &lt;a href=&quot;Test::More&quot;&gt;Test::More&lt;/a&gt; employs some magic to catch that death and turn the test into a failure, even if every test passed up to that point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97c582aeb02e8310ccc2268a23e2a13586d2230f" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;//g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt; :</source>
          <target state="translated">Pero, &amp;iquest;y si tuvi&amp;eacute;ramos un n&amp;uacute;mero indeterminado de palabras? Este es el tipo de tarea para la que se cre&amp;oacute; &lt;code&gt;//g&lt;/code&gt; . Para extraer todas las palabras, forme la expresi&amp;oacute;n regular simple &lt;code&gt;(\w+)&lt;/code&gt; y recorra todas las coincidencias con &lt;code&gt;/(\w+)/g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="90358bd78c20e742086dbdc6ea3490a9deb3bfcc" translate="yes" xml:space="preserve">
          <source>But what if we had an indeterminate number of words? This is the sort of task &lt;code&gt;/g&lt;/code&gt; was made for. To extract all words, form the simple regexp &lt;code&gt;(\w+)&lt;/code&gt; and loop over all matches with &lt;code&gt;/(\w+)/g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae7271808fc8fe6737543912e6a4f4345f08e046" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</source>
          <target state="translated">Pero cuando &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; se utiliza en lugar de &lt;code&gt;&quot;autotie&quot;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="818681641ebe6c47ebb66c7080c5a8f6b3070c54" translate="yes" xml:space="preserve">
          <source>But when &lt;code&gt;&quot;autotieref&quot;&lt;/code&gt; is used instead of &lt;code&gt;&quot;autotie&quot;&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a237c274e15fc51e976c2366d2b1cd3f9bba3c7c" translate="yes" xml:space="preserve">
          <source>But when the following lines are added at the end:</source>
          <target state="translated">Pero cuando se añaden las siguientes líneas al final:</target>
        </trans-unit>
        <trans-unit id="b3a7682b246bb8254bfcb416501b69b76a746fd6" translate="yes" xml:space="preserve">
          <source>But with the actual compile tree for &lt;code&gt;$a = $b + $c&lt;/code&gt; it is different: some nodes</source>
          <target state="translated">Pero con el &amp;aacute;rbol de compilaci&amp;oacute;n real para &lt;code&gt;$a = $b + $c&lt;/code&gt; es diferente: algunos nodos</target>
        </trans-unit>
        <trans-unit id="4db6b75d323cb14de03fc556f71c215fa0254459" translate="yes" xml:space="preserve">
          <source>But won't work when called as:</source>
          <target state="translated">Pero no funcionará cuando se le llame como:</target>
        </trans-unit>
        <trans-unit id="41f61e687d338fbf08bd8ac1adb4bd20048487aa" translate="yes" xml:space="preserve">
          <source>But you don't actually have to make two pipe calls. If you have the socketpair() system call, it will do this all for you.</source>
          <target state="translated">Pero en realidad no tienes que hacer dos llamadas a la tubería.Si tienes la llamada de sistema de socketspair(),hará todo esto por ti.</target>
        </trans-unit>
        <trans-unit id="eb429c70b04342714cf4d23c433974bea348e678" translate="yes" xml:space="preserve">
          <source>But you put it aside for the moment, and optimistically hope that the other translators won't have this problem, and that their languages will be better behaved -- i.e., that they will be just like English.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bc61709d9d36e283fe251c9894f7f9c70eff276" translate="yes" xml:space="preserve">
          <source>But you still cannot make assumptions about whether this is correct, unless your policy says it is. You really are best off asking the user.</source>
          <target state="translated">Pero aún así no puede hacer suposiciones sobre si esto es correcto,a menos que su política diga que lo es.Realmente es mejor preguntarle al usuario.</target>
        </trans-unit>
        <trans-unit id="4b9905ad0aeb95ca50441bf7c28631173d039f82" translate="yes" xml:space="preserve">
          <source>But you still have those funny select()s. So just use the FileHandle module. Now, you can access these special variables using lowercase method names instead:</source>
          <target state="translated">Pero todavía tienes esas divertidas selecciones.Así que usa el módulo FileHandle.Ahora,puedes acceder a estas variables especiales usando nombres de métodos en minúsculas:</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
