<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="604c79e231e51591da6ce53e73549980b6c066b2" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result - Individual test suite results.</source>
          <target state="translated">App::Probar::Estado::Resultado-Resultados del conjunto de pruebas individuales.</target>
        </trans-unit>
        <trans-unit id="83a53d94c22845a17e42b81ff706d21b9d9578b9" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test</source>
          <target state="translated">App::Prove::State::Result::Test</target>
        </trans-unit>
        <trans-unit id="dcd1440850fc9e2913d7cf105103afc698a85230" translate="yes" xml:space="preserve">
          <source>App::Prove::State::Result::Test - Individual test results.</source>
          <target state="translated">App::Probar::Estado::Resultado::Prueba-Resultados de la prueba individual.</target>
        </trans-unit>
        <trans-unit id="a04f6596455dd68a60a8ad9f2a7176ca7fb0ee44" translate="yes" xml:space="preserve">
          <source>Apparently, IBM used a compiler (for some period of time around '95?) which changes FP mask right and left. This is not</source>
          <target state="translated">Aparentemente,IBM usó un compilador (por algún período de tiempo alrededor del 95?)que cambia la máscara FP a derecha e izquierda.Esto no es</target>
        </trans-unit>
        <trans-unit id="3c4496c4495e5c99d047e29d461a211122789431" translate="yes" xml:space="preserve">
          <source>Appeal to their self interest! If Perl is new (and thus scary) to them, find something that Perl can do to solve one of their problems. That might mean that Perl either saves them something (time, headaches, money) or gives them something (flexibility, power, testability).</source>
          <target state="translated">¡Apelar a su propio interés! Si Perl es nuevo (y por lo tanto aterrador)para ellos,encuentre algo que Perl pueda hacer para resolver uno de sus problemas.Eso podría significar que Perl les ahorra algo (tiempo,dolores de cabeza,dinero)o les da algo (flexibilidad,poder,comprobabilidad).</target>
        </trans-unit>
        <trans-unit id="7820ab67805cf1ba0f215418474bf3c391c0a394" translate="yes" xml:space="preserve">
          <source>Appearances can be deceptive, especially when it comes to emptiness. If you are scratching your head trying to work out why Test::Tester is saying that your diagnostics are wrong when they look perfectly right then the answer is probably whitespace. From version 0.10 on, Test::Tester surrounds the expected and got diag values with single quotes to make it easier to spot trailing whitespace. So in this example</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b71dbc9f1f2c8f41b80953098f3e95dfa1012f02" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list.</source>
          <target state="translated">Añada un elemento a la lista de operaciones contenida directamente en una lista de operaciones,devolviendo la lista ampliada.</target>
        </trans-unit>
        <trans-unit id="555e00ca2c34efb8f2b3198b481016b18bb0499c" translate="yes" xml:space="preserve">
          <source>Append an item to the list of ops contained directly within a list-type op, returning the lengthened list. &lt;code&gt;first&lt;/code&gt; is the list-type op, and &lt;code&gt;last&lt;/code&gt; is the op to append to the list. &lt;code&gt;optype&lt;/code&gt; specifies the intended opcode for the list. If &lt;code&gt;first&lt;/code&gt; is not already a list of the right type, it will be upgraded into one. If either &lt;code&gt;first&lt;/code&gt; or &lt;code&gt;last&lt;/code&gt; is null, the other is returned unchanged.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becdeb6adee05d280a8a50e1526a1a849bef0624" translate="yes" xml:space="preserve">
          <source>Append elements of</source>
          <target state="translated">Agregar elementos de</target>
        </trans-unit>
        <trans-unit id="7b02fe45aa574073ed825bd38be9577b88d0ca63" translate="yes" xml:space="preserve">
          <source>Append elements of LIST to the array.</source>
          <target state="translated">Añada elementos de LIST a la matriz.</target>
        </trans-unit>
        <trans-unit id="89394607a467e98868ad0332e6c7061404a979e4" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">Agregue el tiempo de ejecuci&amp;oacute;n de cada prueba a la salida. Utiliza &lt;a href=&quot;../../time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; si est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="f3320c1303317ee828f35f641012da0ef7ad78b8" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;../time/hires&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="translated">Agregue el tiempo de ejecuci&amp;oacute;n de cada prueba a la salida. Utiliza &lt;a href=&quot;../time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; si est&amp;aacute; disponible.</target>
        </trans-unit>
        <trans-unit id="c0d38ef820bcef303880baae14bb62295e88bb8d" translate="yes" xml:space="preserve">
          <source>Append run time for each test to output. Uses &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="115b06d7e965b2c8ec031641d6914969c4847565" translate="yes" xml:space="preserve">
          <source>Appending the G_KEEPERR flag, so that the</source>
          <target state="translated">Añadiendo la bandera de G_KEEPERR,para que el</target>
        </trans-unit>
        <trans-unit id="112a3bb05c1aa885c550b6193e7eaea408add2b6" translate="yes" xml:space="preserve">
          <source>Appends the given string or parse-tree or sequence object to the parse-tree of this interior sequence.</source>
          <target state="translated">Añade la cadena o el árbol de análisis o el objeto de la secuencia al árbol de análisis de esta secuencia interior.</target>
        </trans-unit>
        <trans-unit id="bc939bc86e4ec12055b78bc1367433c6c3dc048c" translate="yes" xml:space="preserve">
          <source>Apple Mac OS 8/9</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6dd82bd12d46344a2006677b750f75da928a5f51" translate="yes" xml:space="preserve">
          <source>Application of the patches</source>
          <target state="translated">Aplicación de los parches</target>
        </trans-unit>
        <trans-unit id="e91f35534bce18d06e39334fde833d8a1d0115a1" translate="yes" xml:space="preserve">
          <source>Application release September 2001, HP-UX 11.00 is the first to ship with Perl. By the time it was perl-5.6.1 in /opt/perl. The first occurrence is on CD 5012-7954 and can be installed using</source>
          <target state="translated">El HP-UX 11.00,lanzado en septiembre de 2001,es el primero que se envía con el Perl.En el momento en que fue perl-5.6.1 en /opt/perl.La primera ocurrencia está en el CD 5012-7954 y puede ser instalada usando</target>
        </trans-unit>
        <trans-unit id="70dcb259ecf9216f358dc0f66966f145bfe54f70" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression.</source>
          <target state="translated">Aplica un contexto sintáctico a un árbol de operaciones que representa una expresión.</target>
        </trans-unit>
        <trans-unit id="4e768fecef5f9dd672611658c8743f59705b1284" translate="yes" xml:space="preserve">
          <source>Applies a syntactic context to an op tree representing an expression. &lt;code&gt;o&lt;/code&gt; is the op tree, and &lt;code&gt;context&lt;/code&gt; must be &lt;code&gt;G_SCALAR&lt;/code&gt;, &lt;code&gt;G_ARRAY&lt;/code&gt;, or &lt;code&gt;G_VOID&lt;/code&gt; to specify the context to apply. The modified op tree is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5ed3f5653497e355ed136e0b7c54a5982ace7b4" translate="yes" xml:space="preserve">
          <source>Applies dl_find_symbol() to the members of @dl_librefs and returns the first match found.</source>
          <target state="translated">Aplica dl_find_symbol()a los miembros de @dl_librefs y devuelve la primera coincidencia encontrada.</target>
        </trans-unit>
        <trans-unit id="8f16d6f27d971ff843245cdc989aa538f3326e5f" translate="yes" xml:space="preserve">
          <source>Apply &lt;a href=&quot;#int-EXPR&quot;&gt;&lt;code&gt;int&lt;/code&gt;&lt;/a&gt; to the value returned by &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="197e68ad33f090de266ab7a82716d4dcf0c6223c" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">Aplique &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; al valor devuelto por &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; si desea n&amp;uacute;meros enteros aleatorios en lugar de n&amp;uacute;meros fraccionarios aleatorios. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="a60da6ae1477278e788b56dd12901cf6a9b5b818" translate="yes" xml:space="preserve">
          <source>Apply &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; to the value returned by &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; if you want random integers instead of random fractional numbers. For example,</source>
          <target state="translated">Aplique &lt;code&gt;&lt;a href=&quot;int&quot;&gt;int()&lt;/a&gt;&lt;/code&gt; al valor devuelto por &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand()&lt;/a&gt;&lt;/code&gt; si desea n&amp;uacute;meros enteros aleatorios en lugar de n&amp;uacute;meros fraccionarios aleatorios. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="974cf6b03d0010e4742b565eeb776443fe41243e" translate="yes" xml:space="preserve">
          <source>Apply Perl-specific heuristics to find the correct PODs. This includes stripping Perl-like extensions, omitting subdirectories that are numeric but do</source>
          <target state="translated">Aplica la heurística específica de Perl para encontrar los PODs correctos.Esto incluye la eliminación de las extensiones similares a Perl,omitiendo los subdirectorios que son numéricos pero que</target>
        </trans-unit>
        <trans-unit id="baaa234761c2eef7e15c7c661df9bd832e32f420" translate="yes" xml:space="preserve">
          <source>Apply a list of switch options to the state, updating the internal object state as a result. Nothing is returned.</source>
          <target state="translated">Aplicar una lista de opciones de conmutación al estado,actualizando el estado del objeto interno como resultado.No se devuelve nada.</target>
        </trans-unit>
        <trans-unit id="7b0453d0169f10e0dd546ac420ad360f4311387a" translate="yes" xml:space="preserve">
          <source>Applying %s to %s will act on scalar(%s)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c72c1cee8e4b08228a22dc9c5e025abf27a61b14" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; causes the exotic forms &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="translated">Aplicar &lt;code&gt;autodie&lt;/code&gt; a &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; hace que el &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; { $cmd } @args &lt;/code&gt; formas ex&amp;oacute;ticas {$ cmd} @args o &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt; { $cmd } @args&lt;/code&gt; se considere un error de sintaxis hasta el final del &amp;aacute;mbito l&amp;eacute;xico. Si realmente necesita usar la forma ex&amp;oacute;tica, puede llamar a &lt;code&gt;CORE::system&lt;/code&gt; o &lt;code&gt;CORE::exec&lt;/code&gt; lugar, o usar &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(system exec)&lt;/code&gt; antes de llamar a la forma ex&amp;oacute;tica.</target>
        </trans-unit>
        <trans-unit id="73c33410e3cd1ef38b870e6e841b6a111c44ea15" translate="yes" xml:space="preserve">
          <source>Applying &lt;code&gt;autodie&lt;/code&gt; to &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt; causes the exotic forms &lt;code&gt;system { $cmd } @args &lt;/code&gt; or &lt;code&gt;exec { $cmd } @args&lt;/code&gt; to be considered a syntax error until the end of the lexical scope. If you really need to use the exotic form, you can call &lt;code&gt;CORE::system&lt;/code&gt; or &lt;code&gt;CORE::exec&lt;/code&gt; instead, or use &lt;code&gt;no autodie qw(system exec)&lt;/code&gt; before calling the exotic form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b6bbaf0846e0f6542bb5b50d36df38212d67922" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</source>
          <target state="translated">Equivalente aproximado de Perl: &lt;code&gt;$myarray[$key] = $val;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="255706027acb3bbb6c23a2beab5baa7da2561792" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</source>
          <target state="translated">Equivalente aproximado de Perl: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f08b9c9f0996e8f22c8e80713baa3b2c5d6b61a" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;&amp;amp;{&quot;$sub_name&quot;}(@$argv)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="171752021f257ea835e63866304a10e0627a5496" translate="yes" xml:space="preserve">
          <source>Approximate Perl equivalent: &lt;code&gt;splice(@myarray, $key, 1, $val)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b7d5efdfeaa09de6b4d853375871c9207032b5a" translate="yes" xml:space="preserve">
          <source>April 04-07th, 1997: by Jarkko Hietaniemi, added the run-for-some-time functionality.</source>
          <target state="translated">Abril 04-07,1997:por Jarkko Hietaniemi,añadió la funcionalidad de correr por un tiempo.</target>
        </trans-unit>
        <trans-unit id="538beea89400340066f03de9b8531baacd233ee4" translate="yes" xml:space="preserve">
          <source>April 2010</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af4f4762f9bd3f0f4a10caf5b6e63dc4ce543724" translate="yes" xml:space="preserve">
          <source>Arabic</source>
          <target state="translated">Arabic</target>
        </trans-unit>
        <trans-unit id="5383ba59b7a51b492dcc518df7e4190d4cdf46a1" translate="yes" xml:space="preserve">
          <source>Arbitrary big rational numbers</source>
          <target state="translated">Grandes números racionales arbitrarios</target>
        </trans-unit>
        <trans-unit id="d355876ea51e167fe43014294b56e66adbafd342" translate="yes" xml:space="preserve">
          <source>Arbitrary size floating point math package</source>
          <target state="translated">Paquete matemático de punto flotante de tamaño arbitrario</target>
        </trans-unit>
        <trans-unit id="94977ff2a6f2fcf0486458c46c172275ed7d1a6e" translate="yes" xml:space="preserve">
          <source>Arbitrary size integer/float math package</source>
          <target state="translated">Paquete matemático de tamaño arbitrario de entero/flotación</target>
        </trans-unit>
        <trans-unit id="f96ddf323d8050458b6f5da00e7d15254e6e51f7" translate="yes" xml:space="preserve">
          <source>Arch</source>
          <target state="translated">Arch</target>
        </trans-unit>
        <trans-unit id="fa197ea9d1ebf357ab1895c0454edae5ed010094" translate="yes" xml:space="preserve">
          <source>Archive and test</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba6c5bbd1305838d356b1a16f613e5175253fc77" translate="yes" xml:space="preserve">
          <source>Archive::Tar</source>
          <target state="translated">Archive::Tar</target>
        </trans-unit>
        <trans-unit id="57cc32f42ad2d2bee580d99c3d374961c6559947" translate="yes" xml:space="preserve">
          <source>Archive::Tar - module for manipulations of tar archives</source>
          <target state="translated">Archivo::Alquitrán-módulo para manipular archivos de alquitrán</target>
        </trans-unit>
        <trans-unit id="987b760cdf9eb8e8f22f82c621b2dbe3ee552aeb" translate="yes" xml:space="preserve">
          <source>Archive::Tar provides an object oriented mechanism for handling tar files. It provides class methods for quick and easy files handling while also allowing for the creation of tar file objects for custom manipulation. If you have the IO::Zlib module installed, Archive::Tar will also support compressed or gzipped tar files.</source>
          <target state="translated">Archive::Tar proporciona un mecanismo orientado a objetos para manejar archivos de tar.Proporciona métodos de clase para el manejo rápido y fácil de los archivos,mientras que también permite la creación de objetos de archivos tar para la manipulación personalizada.Si tiene instalado el módulo IO::Zlib,Archive::Tar también soportará archivos tar comprimidos o comprimidos en gzip.</target>
        </trans-unit>
        <trans-unit id="2de9e103622352aeb9a5f8214ffe2d70dee8d73d" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 / xz compressed file and the IO::Uncompress::Bunzip2 / IO::Uncompress::UnXz are not available and simply return.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c0d8b6a96eeaeee2b14e15f99110273c20f8435" translate="yes" xml:space="preserve">
          <source>Archive::Tar will warn if you try to pass a bzip2 compressed file and the IO::Zlib / IO::Uncompress::Bunzip2 modules are not available and simply return.</source>
          <target state="translated">Archive::Tar avisará si intentas pasar un archivo comprimido en bzip2 y los módulos IO::Zlib/IO::Uncompress::Bunzip2 no están disponibles y simplemente vuelve.</target>
        </trans-unit>
        <trans-unit id="ccbf19882dacfbec62ca802f4c207f93b26aac20" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;can_handle_compressed_files</source>
          <target state="translated">Archive::Tar-&amp;gt;can_handle_compressed_files</target>
        </trans-unit>
        <trans-unit id="3b7da738f6421ea5f244ab2a75337cb19a765083" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;create_archive($file, $compressed, @filelist)</source>
          <target state="translated">Archivo :: Tar-&amp;gt; create_archive ($ archivo, $ comprimido, @filelist)</target>
        </trans-unit>
        <trans-unit id="1dcbd289acf336b4bc9986937face374b8265d16" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;extract_archive($file, $compressed)</source>
          <target state="translated">Archivo :: Tar-&amp;gt; extract_archive ($ archivo, $ comprimido)</target>
        </trans-unit>
        <trans-unit id="8336b53d325ea70cb860e4292e999b5eb8ccc20b" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;iter( $filename, [ $compressed, {opt =&amp;gt; $val} ] )</source>
          <target state="translated">Archivo :: Tar-&amp;gt; iter ($ nombre de archivo, [$ comprimido, {opt =&amp;gt; $ val}])</target>
        </trans-unit>
        <trans-unit id="7b5db2965e54185ceb8a82cfef6b3bcf83d67256" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;list_archive($file, $compressed, [\@properties])</source>
          <target state="translated">Archivo :: Tar-&amp;gt; list_archive ($ archivo, $ comprimido, [\ @properties])</target>
        </trans-unit>
        <trans-unit id="2b89433003c5207f03c7ec11ee01b11e8497bdb8" translate="yes" xml:space="preserve">
          <source>Archive::Tar-&amp;gt;new( [$file, $compressed] )</source>
          <target state="translated">Archivo :: Tar-&amp;gt; nuevo ([$ archivo, $ comprimido])</target>
        </trans-unit>
        <trans-unit id="3fdd79ccbef7cb27b73af9645a51c4748537632a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File</source>
          <target state="translated">Archive::Tar::File</target>
        </trans-unit>
        <trans-unit id="e4450126317363219e2891fd96c92d67bb8fdb14" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File - a subclass for in-memory extracted file from Archive::Tar</source>
          <target state="translated">Archivo::Tar::Archivo-una subclase para el archivo extraído en memoria del Archivo::Tar</target>
        </trans-unit>
        <trans-unit id="9bb643189669555fb8fc9a5ad660a12af02d7c6a" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( chunk =&amp;gt; $chunk )</source>
          <target state="translated">Archivo :: Tar :: Archivo-&amp;gt; nuevo (fragmento =&amp;gt; $ fragmento)</target>
        </trans-unit>
        <trans-unit id="ba9618dfc7889be15218e3ccacc09c8bf242756f" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( data =&amp;gt; $path, $data, $opt )</source>
          <target state="translated">Archivo :: Tar :: Archivo-&amp;gt; nuevo (datos =&amp;gt; $ ruta, $ datos, $ opt)</target>
        </trans-unit>
        <trans-unit id="a50e4ac8ad32b339e1eb6dee5ec96a58d21300c3" translate="yes" xml:space="preserve">
          <source>Archive::Tar::File-&amp;gt;new( file =&amp;gt; $path )</source>
          <target state="translated">Archivo :: Tar :: Archivo-&amp;gt; nuevo (archivo =&amp;gt; $ ruta)</target>
        </trans-unit>
        <trans-unit id="752ab891c175e9890243ad0568d1b63da7b75555" translate="yes" xml:space="preserve">
          <source>Archive::Tar::Files provides a neat little object layer for in-memory extracted files. It's mostly used internally in Archive::Tar to tidy up the code, but there's no reason users shouldn't use this API as well.</source>
          <target state="translated">Archivo::Tar::Archivos proporciona una pequeña capa de objetos para los archivos extraídos en la memoria.Se usa principalmente internamente en Archive::Tar para ordenar el código,pero no hay razón para que los usuarios no usen también esta API.</target>
        </trans-unit>
        <trans-unit id="2fa2e509f071fa28e01ed08cd42d1e6a982c1c93" translate="yes" xml:space="preserve">
          <source>Archiving and Compression</source>
          <target state="translated">Archivo y compresión</target>
        </trans-unit>
        <trans-unit id="470ed7908583fc807812b6f6f1c733d168001e41" translate="yes" xml:space="preserve">
          <source>Are Perl regexes DFAs or NFAs? Are they POSIX compliant?</source>
          <target state="translated">¿Son los regexes de Perl DFAs o NFAs? ¿Son compatibles con POSIX?</target>
        </trans-unit>
        <trans-unit id="eb00fa046e6f0e29e318d2fe47833f95b6115931" translate="yes" xml:space="preserve">
          <source>Are These Threads The Same?</source>
          <target state="translated">¿Son estos hilos lo mismo?</target>
        </trans-unit>
        <trans-unit id="4b1b74d280a485e3d6be58ac5945ac8cbddc5958" translate="yes" xml:space="preserve">
          <source>Are not yet implemented.</source>
          <target state="translated">Aún no se han implementado.</target>
        </trans-unit>
        <trans-unit id="37ca7d873908345ae9a97f86f6ad04967916d66e" translate="yes" xml:space="preserve">
          <source>Are we at end of file?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c7b6fd019a3db8f66c106580e36cbc2e27fdf91" translate="yes" xml:space="preserve">
          <source>Are you running Windows, and did you write</source>
          <target state="translated">¿Estás usando Windows,y escribiste</target>
        </trans-unit>
        <trans-unit id="d10b1e8f0d25e8ced1066c8aec43c1966f5ae507" translate="yes" xml:space="preserve">
          <source>Are you running the latest released version of perl?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c3fcfe8bf10e9354f16b7f74dc1d506d9b370761" translate="yes" xml:space="preserve">
          <source>Are you sure what you have is a bug?</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9835fff08898bf6d47cdf47b75c3d5a32e54abb7" translate="yes" xml:space="preserve">
          <source>Are you using a really old version of Perl?</source>
          <target state="translated">¿Estás usando una versión muy antigua de Perl?</target>
        </trans-unit>
        <trans-unit id="1f76843fe2bb213b3ad1c4d889f7769d9611e0fa" translate="yes" xml:space="preserve">
          <source>Arg too short for msgsnd</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="354bf98925838ca68611b950e2a37ebd11c21640" translate="yes" xml:space="preserve">
          <source>Argentina</source>
          <target state="translated">Argentina</target>
        </trans-unit>
        <trans-unit id="6fa0e4cab9d0443ef8c9e6c56e4240cbc1230cdb" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;, &lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;, and &lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; to include external Perl files.</source>
          <target state="translated">Podr&amp;iacute;a decirse que estas son las &amp;uacute;nicas rutinas que necesitar&amp;aacute; para ejecutar fragmentos de c&amp;oacute;digo Perl desde su programa C. Su c&amp;oacute;digo puede ser tan largo como desee; puede contener m&amp;uacute;ltiples declaraciones; puede emplear &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; , &lt;a href=&quot;functions/require&quot;&gt;requiera&lt;/a&gt; y &lt;a href=&quot;functions/do&quot;&gt;haga&lt;/a&gt; para incluir archivos Perl externos.</target>
        </trans-unit>
        <trans-unit id="1bfedcdfdca0d5a6460d0d9a3f351f6cd3b4ab7e" translate="yes" xml:space="preserve">
          <source>Arguably, these are the only routines you'll ever need to execute snippets of Perl code from within your C program. Your code can be as long as you wish; it can contain multiple statements; it can employ &lt;a href=&quot;perlfunc#use&quot;&gt;&quot;use&quot; in perlfunc&lt;/a&gt;, &lt;a href=&quot;perlfunc#require&quot;&gt;&quot;require&quot; in perlfunc&lt;/a&gt;, and &lt;a href=&quot;perlfunc#do&quot;&gt;&quot;do&quot; in perlfunc&lt;/a&gt; to include external Perl files.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce5e5792e97fe5c7861d6ae9b29cf5a25cc0e70a" translate="yes" xml:space="preserve">
          <source>Argument</source>
          <target state="translated">Argument</target>
        </trans-unit>
        <trans-unit id="a16749b15d046173fc9fcdf8d075749c151dba6a" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; isn't numeric%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c043537672dbd0f8f35895f8245f3c4e263a6c8f" translate="yes" xml:space="preserve">
          <source>Argument &quot;%s&quot; treated as 0 in increment (++)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="068c4f93ca844add9151394d87be6f0eff5098cb" translate="yes" xml:space="preserve">
          <source>Argument callback</source>
          <target state="translated">Argumento de devolución de llamada</target>
        </trans-unit>
        <trans-unit id="f421070543c0b96709c29a61e7bc0e29c9a6f773" translate="yes" xml:space="preserve">
          <source>Argument list not closed for PerlIO layer &quot;%s&quot;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="becc16f3f9567f706b791b0867003075aa38f700" translate="yes" xml:space="preserve">
          <source>Argument stack</source>
          <target state="translated">La pila de argumentos</target>
        </trans-unit>
        <trans-unit id="9acc1ee24f849a6b6943c3856e23bafeb8ea115e" translate="yes" xml:space="preserve">
          <source>Argument stack manipulation in the core is exactly the same as it is in XSUBs - see &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt;, &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; and &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; for a longer description of the macros used in stack manipulation.</source>
          <target state="translated">La manipulaci&amp;oacute;n de la pila de argumentos en el n&amp;uacute;cleo es exactamente la misma que en los XSUB; consulte &lt;a href=&quot;perlxstut&quot;&gt;perlxstut&lt;/a&gt; , &lt;a href=&quot;perlxs&quot;&gt;perlxs&lt;/a&gt; y &lt;a href=&quot;perlguts&quot;&gt;perlguts&lt;/a&gt; para obtener una descripci&amp;oacute;n m&amp;aacute;s detallada de las macros utilizadas en la manipulaci&amp;oacute;n de la pila.</target>
        </trans-unit>
        <trans-unit id="cbb9fa252e60809efa55a7ad83aea5438ef56753" translate="yes" xml:space="preserve">
          <source>Arguments</source>
          <target state="translated">Arguments</target>
        </trans-unit>
        <trans-unit id="1e682d21a155016274d4c0edada169602cf2db63" translate="yes" xml:space="preserve">
          <source>Arguments are case insensitive.</source>
          <target state="translated">Los argumentos son insensibles a las mayúsculas y minúsculas.</target>
        </trans-unit>
        <trans-unit id="f350823ca978137e84ceb658074c062e77adbc5a" translate="yes" xml:space="preserve">
          <source>Arguments are forced into the integer format if not strings.</source>
          <target state="translated">Los argumentos son forzados en el formato de números enteros,si no en el de cuerdas.</target>
        </trans-unit>
        <trans-unit id="e574a112087c49e835619f8e2053ef81199f3165" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt; . The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="translated">Los argumentos se pasan al c&amp;oacute;digo PP y se devuelven desde el c&amp;oacute;digo PP utilizando la pila de argumentos, &lt;code&gt;ST&lt;/code&gt; . La forma t&amp;iacute;pica de manejar los argumentos es sacarlos de la pila, tratarlos como desee y luego devolver el resultado a la pila. As&amp;iacute; es como funciona, por ejemplo, el operador coseno:</target>
        </trans-unit>
        <trans-unit id="ad4cbcd9603c1cc923fb5986131d15966c20d956" translate="yes" xml:space="preserve">
          <source>Arguments are passed to PP code and returned from PP code using the argument stack, &lt;code&gt;ST&lt;/code&gt;. The typical way to handle arguments is to pop them off the stack, deal with them how you wish, and then push the result back onto the stack. This is how, for instance, the cosine operator works:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fccb02bffe9af13a6b48fc881c2035657ec7bff" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt; ) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="translated">Los argumentos generalmente se formatean para que sean tan anchos como sea necesario para mostrar el valor dado. Puede anular el ancho poniendo un n&amp;uacute;mero aqu&amp;iacute;, u obtener el ancho del siguiente argumento (con &lt;code&gt;*&lt;/code&gt; ) o de un argumento especificado (por ejemplo, con &lt;code&gt;*2$&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="79b342195140d9018897c02d4477a0cd2a68bcbe" translate="yes" xml:space="preserve">
          <source>Arguments are usually formatted to be only as wide as required to display the given value. You can override the width by putting a number here, or get the width from the next argument (with &lt;code&gt;*&lt;/code&gt;) or from a specified argument (e.g., with &lt;code&gt;*2$&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb3861e253aa9c040fd66d90deafd1a6d71292f" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Overloadable Operations&lt;/a&gt; below.</source>
          <target state="translated">Los argumentos de la directiva de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; son pares (clave, valor). Para obtener el conjunto completo de claves legales, consulte &lt;a href=&quot;#Overloadable-Operations&quot;&gt;Operaciones para sobrecargar a&lt;/a&gt; continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cb61e5648eb703f1cc9dab71a052768830d8cd36" translate="yes" xml:space="preserve">
          <source>Arguments of the &lt;code&gt;use overload&lt;/code&gt; directive are (key, value) pairs. For the full set of legal keys, see &lt;a href=&quot;#Overloadable-Operations&quot;&gt;&quot;Overloadable Operations&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5141dae339b17f35a7a4380f8f719ce252ef43f8" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; , or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="translated">Los argumentos que no comienzan con un gui&amp;oacute;n se toman como nombres de subrutinas o formatos a representar; si no se especifican tales funciones, se representa el cuerpo principal del programa (fuera de las subrutinas, y sin incluir los archivos usados ​​o requeridos). Pasar &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; o &lt;code&gt;END&lt;/code&gt; har&amp;aacute; que se impriman todos los bloques especiales correspondientes. Los argumentos deben seguir las opciones.</target>
        </trans-unit>
        <trans-unit id="c05d8fdf0d667d5e67ac75211debe610ccbb3189" translate="yes" xml:space="preserve">
          <source>Arguments that don't start with a hyphen are taken to be the names of subroutines or formats to render; if no such functions are specified, the main body of the program (outside any subroutines, and not including use'd or require'd files) is rendered. Passing &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt;, or &lt;code&gt;END&lt;/code&gt; will cause all of the corresponding special blocks to be printed. Arguments must follow options.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce73d1bc99ee20ea72fd21908b3617e55e0813cc" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="translated">Los argumentos para &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; &lt;b&gt; no se&lt;/b&gt; comprueban para ver si est&amp;aacute;n contaminados.</target>
        </trans-unit>
        <trans-unit id="4006b3311082c7bd892aab6f8d46c918fb22f118" translate="yes" xml:space="preserve">
          <source>Arguments to &lt;code&gt;print&lt;/code&gt; and &lt;code&gt;syswrite&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; checked for taintedness.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b24aafc030974a768212046c7dad5ef0c74d247" translate="yes" xml:space="preserve">
          <source>Arguments to Tests</source>
          <target state="translated">Argumentos para las pruebas</target>
        </trans-unit>
        <trans-unit id="253657f116857073367b6474bc4203deb4236cb2" translate="yes" xml:space="preserve">
          <source>Arguments to be added to the command line</source>
          <target state="translated">Los argumentos que se añadirán a la línea de mando</target>
        </trans-unit>
        <trans-unit id="ef74aa3554ce37f3e92c7ca867fc499504f0b195" translate="yes" xml:space="preserve">
          <source>Arguments to these commands are either strings exactly matching the identification string of an object, or regular expressions matched case-insensitively against various attributes of the objects. The parser only recognizes a regular expression when you enclose it with slashes.</source>
          <target state="translated">Los argumentos de estos comandos son o bien cadenas que coinciden exactamente con la cadena de identificación de un objeto,o bien expresiones regulares que coinciden de manera insensible a los casos contra varios atributos de los objetos.El analizador sólo reconoce una expresión regular cuando la encierra con barras.</target>
        </trans-unit>
        <trans-unit id="a0478ca5f4c068ca3ac12f9474f6a15865ce9053" translate="yes" xml:space="preserve">
          <source>Arguments:</source>
          <target state="translated">Arguments:</target>
        </trans-unit>
        <trans-unit id="2007b9d426cd74d2705e9cb985a4b287291d5413" translate="yes" xml:space="preserve">
          <source>Arguments: COUNT is the number of times to run the loop, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">Argumentos:COUNT es el número de veces que se ejecuta el bucle,y CODE es el código a ejecutar.CODIGO puede ser un código de referencia o una cadena a evaluar;de cualquier manera se ejecutará en el paquete del llamante.</target>
        </trans-unit>
        <trans-unit id="504073c25d9741031e514c8e9e91bef33965e548" translate="yes" xml:space="preserve">
          <source>Arguments: TIME is the minimum length of time to run CODE for, and CODE is the code to run. CODE may be either a code reference or a string to be eval'd; either way it will be run in the caller's package.</source>
          <target state="translated">Argumentos:El TIEMPO es el tiempo mínimo para ejecutar el CÓDIGO,y el CÓDIGO es el código a ejecutar.CODIGO puede ser un código de referencia o una cadena a evaluar;de cualquier manera se ejecutará en el paquete del llamante.</target>
        </trans-unit>
        <trans-unit id="38bfcf708d6931f7d42f920765aaabb5369a9058" translate="yes" xml:space="preserve">
          <source>Aristotle</source>
          <target state="translated">Aristotle</target>
        </trans-unit>
        <trans-unit id="45f053dc732762c8c17889da40821807b746247b" translate="yes" xml:space="preserve">
          <source>Arithmetic</source>
          <target state="translated">Arithmetic</target>
        </trans-unit>
        <trans-unit id="aa4a9120c32b4442874b4d46d816ed7dd9bbe6c6" translate="yes" xml:space="preserve">
          <source>Arithmetic methods</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d077356b7b5076ff62409f2fbd19527762e29c71" translate="yes" xml:space="preserve">
          <source>Arithmetic operators</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6532be8ff2d954f60f4660f2c54f2ea6702b27e" translate="yes" xml:space="preserve">
          <source>Arithmetic operators during &lt;code&gt;use integer&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104fd3fd5302e037fb8d66ee6c616a71d0739a71" translate="yes" xml:space="preserve">
          <source>Arizona</source>
          <target state="translated">Arizona</target>
        </trans-unit>
        <trans-unit id="2dd1feda95af0eae16b44852b3e991a7320b9877" translate="yes" xml:space="preserve">
          <source>Arnold, Ken and James Gosling. The Java Programming Language, 2nd ed. Addison-Wesley, 1998, ISBN 0-201-31006-6.</source>
          <target state="translated">Arnold,Ken y James Gosling.El lenguaje de programación Java,2ª edición.Addison-Wesley,1998,ISBN 0-201-31006-6.</target>
        </trans-unit>
        <trans-unit id="f59bbf13db8733c389e26cc50790aefa49bd87eb" translate="yes" xml:space="preserve">
          <source>Around line 755:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c85b5fb626816d8525d58d40352050c4cc00a98a" translate="yes" xml:space="preserve">
          <source>Around line 804:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ab366efdd1504cdfaa681a633d790c9ce967f2c" translate="yes" xml:space="preserve">
          <source>Arranges for &lt;code&gt;sv&lt;/code&gt; to be shared between threads if a suitable module has been loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f2eecdf1f299504d5505f21d414522aaf018f39c" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; and sets &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; (errno).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b85d47773b3148f4f3a1e9d404f9d2d3175fa5" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">Hace los arreglos para que FILEHANDLE se lea o escriba en modo &quot;binario&quot; o &quot;texto&quot; en sistemas donde las bibliotecas de tiempo de ejecuci&amp;oacute;n distinguen entre archivos binarios y de texto. Si FILEHANDLE es una expresi&amp;oacute;n, el valor se toma como el nombre del identificador de archivo. Devuelve verdadero en caso de &amp;eacute;xito, de lo contrario, devuelve &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; y establece &lt;code&gt;$!&lt;/code&gt; (errno).</target>
        </trans-unit>
        <trans-unit id="1ffbadba9c3dce1044ad3f375a7830b9eb0ed44f" translate="yes" xml:space="preserve">
          <source>Arranges for FILEHANDLE to be read or written in &quot;binary&quot; or &quot;text&quot; mode on systems where the run-time libraries distinguish between binary and text files. If FILEHANDLE is an expression, the value is taken as the name of the filehandle. Returns true on success, otherwise it returns &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and sets &lt;code&gt;$!&lt;/code&gt; (errno).</source>
          <target state="translated">Hace los arreglos para que FILEHANDLE se lea o escriba en modo &quot;binario&quot; o &quot;texto&quot; en sistemas donde las bibliotecas de tiempo de ejecuci&amp;oacute;n distinguen entre archivos binarios y de texto. Si FILEHANDLE es una expresi&amp;oacute;n, el valor se toma como el nombre del identificador de archivo. Devuelve verdadero en caso de &amp;eacute;xito, de lo contrario, devuelve &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; y establece &lt;code&gt;$!&lt;/code&gt; (errno).</target>
        </trans-unit>
        <trans-unit id="9aa41e54fbd34ab084dcbe15fa8b4cafcc06eac6" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on &lt;code&gt;sv&lt;/code&gt; if a suitable module has been loaded.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="343c9f92b2508f5809b499c36c6237ee53dad8e9" translate="yes" xml:space="preserve">
          <source>Arranges for a mutual exclusion lock to be obtained on sv if a suitable module has been loaded.</source>
          <target state="translated">Dispone que se obtenga un bloqueo de exclusión mutua en el sv si se ha cargado un módulo adecuado.</target>
        </trans-unit>
        <trans-unit id="a5173bbe458c53871d9b1f27fa09a96bfb62b86e" translate="yes" xml:space="preserve">
          <source>Arranges for sv to be shared between threads if a suitable module has been loaded.</source>
          <target state="translated">Hace que el sv se comparta entre los hilos si se ha cargado un módulo adecuado.</target>
        </trans-unit>
        <trans-unit id="77504b93a8457067677bb3cc3aa5311d924675f5" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e55b4fcd8dbc2fd2ba6c045d961bacb9e292142" translate="yes" xml:space="preserve">
          <source>Arranges to have a SIGALRM delivered to this process after the specified number of wallclock seconds has elapsed. If SECONDS is not specified, the value stored in &lt;code&gt;$_&lt;/code&gt; is used. (On some machines, unfortunately, the elapsed time may be up to one second less or more than you specified because of how seconds are counted, and process scheduling may delay the delivery of the signal even further.)</source>
          <target state="translated">Organiza que se env&amp;iacute;e un SIGALRM a este proceso despu&amp;eacute;s de que haya transcurrido el n&amp;uacute;mero especificado de segundos del reloj de pared. Si no se especifica SECONDS, se utiliza el valor almacenado en &lt;code&gt;$_&lt;/code&gt; . (En algunas m&amp;aacute;quinas, desafortunadamente, el tiempo transcurrido puede ser hasta un segundo menos o m&amp;aacute;s de lo que especific&amp;oacute; debido a c&amp;oacute;mo se cuentan los segundos, y la programaci&amp;oacute;n del proceso puede retrasar a&amp;uacute;n m&amp;aacute;s la entrega de la se&amp;ntilde;al).</target>
        </trans-unit>
        <trans-unit id="8d25b4a3297455b9e035c6b89f1c17b7c2bce696" translate="yes" xml:space="preserve">
          <source>Array (&lt;code&gt;'@'&lt;/code&gt; or &lt;code&gt;'*@'&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc39e6a09e8f437b433c2957e8745936c343df43" translate="yes" xml:space="preserve">
          <source>Array Interpolation</source>
          <target state="translated">Interpolación de matrices</target>
        </trans-unit>
        <trans-unit id="946f892404632d1e1ef312d460522dbcef0e5ca6" translate="yes" xml:space="preserve">
          <source>Array Manipulation Functions</source>
          <target state="translated">Funciones de manipulación de arreglos</target>
        </trans-unit>
        <trans-unit id="380a0ee1c3f2add958e20ae4dd8479917cbbbae8" translate="yes" xml:space="preserve">
          <source>Array holding list of directories to be searched for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e55ce1c88c52594e868f7dcd4b7c1bf4e8ab55e6" translate="yes" xml:space="preserve">
          <source>Array of extension names to be included when doing a static build. MakeMaker will normally build with all of the installed extensions when doing a static build, and that is usually the desired behavior. If INCLUDE_EXT is present then MakeMaker will build only with those extensions which are explicitly mentioned. (e.g. [ qw( Socket POSIX ) ])</source>
          <target state="translated">Conjunto de nombres de extensiones que se incluirán cuando se haga una construcción estática.MakeMaker normalmente construirá con todas las extensiones instaladas cuando haga una construcción estática,y ese es normalmente el comportamiento deseado.Si INCLUDE_EXT está presente,MakeMaker sólo construirá con las extensiones que se mencionan explícitamente.(por ejemplo[qw(Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="1a8fc45517962d9406be17b19c25fe3aa87b4fd8" translate="yes" xml:space="preserve">
          <source>Array of extension names to exclude when doing a static build. This is ignored if INCLUDE_EXT is present. Consult INCLUDE_EXT for more details. (e.g. [ qw( Socket POSIX ) ] )</source>
          <target state="translated">Matriz de nombres de extensiones para excluir cuando se hace una construcción estática.Esto es ignorado si INCLUDE_EXT está presente.Consulte INCLUDE_EXT para más detalles.(por ejemplo[qw(Socket POSIX)])</target>
        </trans-unit>
        <trans-unit id="ab0eedcb736c58c9e1bf3d9da5ea7d522b690f73" translate="yes" xml:space="preserve">
          <source>Array of strings containing name (and email address) of package author(s). Is used in CPAN Meta files (META.yml or META.json) and PPD (Perl Package Description) files for PPM (Perl Package Manager).</source>
          <target state="translated">Conjunto de cadenas que contienen el nombre (y la dirección de correo electrónico)del autor o autores del paquete.Se utiliza en los archivos CPAN Meta (META.yml o META.json)y en los archivos PPD (Perl Package Description)para PPM (Perl Package Manager).</target>
        </trans-unit>
        <trans-unit id="c57f3a7023d5d1d3793f2eb3d27a157609936e28" translate="yes" xml:space="preserve">
          <source>Array of symbol names for variables to be made available as universal symbols. Used only under AIX, OS/2, VMS and Win32 at present. Defaults to []. (e.g. [ qw(Foo_version Foo_numstreams Foo_tree ) ])</source>
          <target state="translated">Matriz de nombres de símbolos para las variables que se pondrán a disposición como símbolos universales.Actualmente se utiliza sólo en AIX,OS/2,VMS y Win32.Por defecto es [].(e.g.[qw(Foo_version Foo_numstreams Foo_tree)])</target>
        </trans-unit>
        <trans-unit id="9ab44c94b1ea31feff632108e9870b5e1654c616" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Las operaciones de matriz, que cambian los escalares, los reorganizan o suman o restan algunos escalares, solo funcionan en matrices. Estos no pueden funcionar en una lista, que est&amp;aacute; arreglada. Las operaciones de la matriz incluyen &lt;code&gt;&lt;a href=&quot;functions/shift&quot;&gt;shift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/unshift&quot;&gt;unshift&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/push&quot;&gt;push&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/pop&quot;&gt;pop&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/splice&quot;&gt;splice&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4a460c81ea3de2b351104bc9016134c2ac95be02" translate="yes" xml:space="preserve">
          <source>Array operations, which change the scalars, rearrange them, or add or subtract some scalars, only work on arrays. These can't work on a list, which is fixed. Array operations include &lt;code&gt;shift&lt;/code&gt;, &lt;code&gt;unshift&lt;/code&gt;, &lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, and &lt;code&gt;splice&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78674941505b9a2d4a3ebcad653295e98eb9dd4f" translate="yes" xml:space="preserve">
          <source>Array passed to stat will be coerced to a scalar%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9dd682c69e6440164f6188906ac10fd3b501a3b" translate="yes" xml:space="preserve">
          <source>Array reference of files to examine. May not be specified with &lt;code&gt;dir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4a46ecccd0814a0e990fda1f36238fc6513b396" translate="yes" xml:space="preserve">
          <source>Array refs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70c97244599437a3af8dc620ee670c18edb6906b" translate="yes" xml:space="preserve">
          <source>Array size can be obtained by doing:</source>
          <target state="translated">El tamaño de la matriz se puede obtener haciendo:</target>
        </trans-unit>
        <trans-unit id="4958f544bd9596999a8c5e79c668a1a1962b374e" translate="yes" xml:space="preserve">
          <source>Array, indexed by opcode, of functions that will be called for the &quot;check&quot; phase of optree building during compilation of Perl code. For most (but not all) types of op, once the op has been initially built and populated with child ops it will be filtered through the check function referenced by the appropriate element of this array. The new op is passed in as the sole argument to the check function, and the check function returns the completed op. The check function may (as the name suggests) check the op for validity and signal errors. It may also initialise or modify parts of the ops, or perform more radical surgery such as adding or removing child ops, or even throw the op away and return a different op in its place.</source>
          <target state="translated">Conjunto,indexado por opcode,de funciones que se llamarán para la fase de &quot;comprobación&quot; de la construcción de optree durante la compilación del código Perl.En el caso de la mayoría de los tipos de operaciones (pero no todos),una vez que la operación se ha construido inicialmente y se ha poblado con operaciones infantiles,se filtrará a través de la función de verificación referida por el elemento apropiado de esta matriz.La nueva operación se pasa como único argumento a la función de comprobación,y la función de comprobación devuelve la operación completada.La función de comprobación puede (como su nombre indica)comprobar la validez de la operación y señalar errores.También puede inicializar o modificar partes de las operaciones,o realizar una cirugía más radical como añadir o eliminar operaciones infantiles,o incluso tirar la operación y devolver una operación diferente en su lugar.</target>
        </trans-unit>
        <trans-unit id="cbf55f45c7afc72d6bf912afc7befb393f385b76" translate="yes" xml:space="preserve">
          <source>Arrayref containing the facet-data hashes of events nested under this one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7622ad2f459420f8cf1278b446072cfedac9e366" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(archname manext)] defines ARCHNAME &amp;amp; MANEXT from config.sh. MakeMaker will add to CONFIG the following values anyway: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</source>
          <target state="translated">Arrayref. Por ejemplo, [qw (archname manext)] define ARCHNAME &amp;amp; MANEXT desde config.sh. MakeMaker agregar&amp;aacute; a CONFIG los siguientes valores de todos modos: ar cc cccdlflags ccdlflags dlext dlsrc ld lddlflags ldflags libc lib_ext obj_ext ranlib sitelibexp sitearchexp so</target>
        </trans-unit>
        <trans-unit id="ac3c8cf1aba574321bc1f66afd6baee7d74ccdb5" translate="yes" xml:space="preserve">
          <source>Arrayref. E.g. [qw(name1 name2)] skip (do not write) sections of the Makefile. Caution! Do not use the SKIP attribute for the negligible speedup. It may seriously damage the resulting Makefile. Only use it if you really need it.</source>
          <target state="translated">Arrayref.Por ejemplo,[qw(nombre1 nombre2)]salta (no escribe)secciones del Makefile.Atención! No use el atributo SKIP para la aceleración insignificante.Puede dañar seriamente el Makefile resultante.Sólo úsenlo si realmente lo necesitan.</target>
        </trans-unit>
        <trans-unit id="b90cc9bfd23567a2ff5ba1f00e7c63ca6da8755e" translate="yes" xml:space="preserve">
          <source>Arrays</source>
          <target state="translated">Arrays</target>
        </trans-unit>
        <trans-unit id="065b62648ae15e66467cb649a0f78784ebc20d69" translate="yes" xml:space="preserve">
          <source>Arrays and slices are interpolated into double-quoted strings by joining the elements with the delimiter specified in the &lt;code&gt;$&quot;&lt;/code&gt; variable (&lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; if &quot;use English;&quot; is specified), space by default. The following are equivalent:</source>
          <target state="translated">Las matrices y los segmentos se interpolan en cadenas entre comillas dobles uniendo los elementos con el delimitador especificado en la variable &lt;code&gt;$&quot;&lt;/code&gt; (se &lt;code&gt;$LIST_SEPARATOR&lt;/code&gt; si se especifica&quot; use English; &quot;), espacio por defecto. Los siguientes son equivalentes:</target>
        </trans-unit>
        <trans-unit id="015aea03d19c4f5404b14d2e291f0bb807a559b3" translate="yes" xml:space="preserve">
          <source>Arrays are zero-indexed. Here's how you get at elements in an array:</source>
          <target state="translated">Los arreglos están indexados a cero.Así es como se llega a los elementos de un arreglo:</target>
        </trans-unit>
        <trans-unit id="62a56f74931523c8c6be523e0f4189cd13f83348" translate="yes" xml:space="preserve">
          <source>Arrays index from 0. Likewise string positions in substr() and index().</source>
          <target state="translated">Matriz de índice desde 0.Así como las posiciones de las cadenas en substr()e índice().</target>
        </trans-unit>
        <trans-unit id="c6d4028b66a4b9402be627f34603725a671721e9" translate="yes" xml:space="preserve">
          <source>Arrays:</source>
          <target state="translated">Arrays:</target>
        </trans-unit>
        <trans-unit id="758bdbae166b00a3d8e1212d185299f382e9e26b" translate="yes" xml:space="preserve">
          <source>Arrow Notation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d88829ea9618170c7e2c7635ccc9b881ef3d9e85" translate="yes" xml:space="preserve">
          <source>Arrow Rule</source>
          <target state="translated">Regla de la flecha</target>
        </trans-unit>
        <trans-unit id="59f3e01c7f1fff089e4fc72d78498e369ebc8aba" translate="yes" xml:space="preserve">
          <source>Article about software localization</source>
          <target state="translated">Artículo sobre localización de software</target>
        </trans-unit>
        <trans-unit id="7c422841b7e3951946583038790545c4ed38481b" translate="yes" xml:space="preserve">
          <source>Articles</source>
          <target state="translated">Articles</target>
        </trans-unit>
        <trans-unit id="c2be5dffac8f664ad6e121cb0e6596d1cc2f8c20" translate="yes" xml:space="preserve">
          <source>Articles that are either about &lt;b&gt;DB_File&lt;/b&gt; or make use of it.</source>
          <target state="translated">Art&amp;iacute;culos que tratan sobre &lt;b&gt;DB_File&lt;/b&gt; o hacen uso de &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="a75b4962c21a671a678a35a002d5a9cabe9f37df" translate="yes" xml:space="preserve">
          <source>Artistic License</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ec201db4d2d3c7be7bb34f8e626f24de679e0d7" translate="yes" xml:space="preserve">
          <source>Artur Bergman &amp;lt;sky AT crucially DOT net&amp;gt;</source>
          <target state="translated">Artur Bergman &amp;lt;cielo AT crucialmente red DOT&amp;gt;</target>
        </trans-unit>
        <trans-unit id="8abf83e588a6f8dbd23df54124d573a8d6e50b02" translate="yes" xml:space="preserve">
          <source>Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, June 11, 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</source>
          <target state="translated">Artur Bergman, &quot;Where Wizards Fear To Tread&quot;, 11 de junio de 2002, &lt;a href=&quot;http://www.perl.com/pub/a/2002/06/11/threads.html&quot;&gt;http://www.perl.com/pub/a/2002/06/11/threads.html&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="9d31985fda87b26d6554bcfbfe7dbc398b51917e" translate="yes" xml:space="preserve">
          <source>As</source>
          <target state="translated">As</target>
        </trans-unit>
        <trans-unit id="47c29ec0c3f7f05bae80de5283a0b030f441a291" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; or &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="translated">Como &lt;a href=&quot;../functions/stat&quot;&gt;stat&lt;/a&gt; o &lt;a href=&quot;../functions/lstat&quot;&gt;lstat&lt;/a&gt; pero con las marcas de tiempo de acceso / modificaci&amp;oacute;n / cambio de archivos en una resoluci&amp;oacute;n de subsegundos, si el sistema operativo y el sistema de archivos admiten dichas marcas de tiempo. Para anular la estad&amp;iacute;stica est&amp;aacute;ndar ():</target>
        </trans-unit>
        <trans-unit id="cad0de4aeb2435c3e6250aa64da21872a52c4d61" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#stat&quot;&gt;&quot;stat&quot; in perlfunc&lt;/a&gt; or &lt;a href=&quot;perlfunc#lstat&quot;&gt;&quot;lstat&quot; in perlfunc&lt;/a&gt; but with the access/modify/change file timestamps in subsecond resolution, if the operating system and the filesystem both support such timestamps. To override the standard stat():</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674c2b9678e49fe5c48ffe3cac937cee6706d2ff" translate="yes" xml:space="preserve">
          <source>As &lt;a href=&quot;perlfunc#utime&quot;&gt;&quot;utime&quot; in perlfunc&lt;/a&gt; but with the ability to set the access/modify file timestamps in subsecond resolution, if the operating system and the filesystem, and the mount options of the filesystem, all support such timestamps.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02b2b57eecbbd649395f996ef53060747f75fc9c" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-nok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">Como &lt;b&gt;-nok&lt;/b&gt; excepto que informar&amp;aacute; sobre sistemas m&amp;aacute;s antiguos.</target>
        </trans-unit>
        <trans-unit id="4859922e8f70272693e823f3867ed24a92199eaa" translate="yes" xml:space="preserve">
          <source>As &lt;b&gt;-ok&lt;/b&gt; except it will report on older systems.</source>
          <target state="translated">Como &lt;b&gt;-ok&lt;/b&gt; excepto que informar&amp;aacute; sobre sistemas m&amp;aacute;s antiguos.</target>
        </trans-unit>
        <trans-unit id="11468a3ea9b3583c1d2e6860cce82a44a9b04f63" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt; , one of the following names must be given.</source>
          <target state="translated">Como &lt;code&gt;$form_name&lt;/code&gt; , se debe dar uno de los siguientes nombres.</target>
        </trans-unit>
        <trans-unit id="bdbf26fc42681222abf14a2b96b2aee6d500b3fc" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;$form_name&lt;/code&gt;, one of the following names must be given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2779b0caf565b7a913bad43d8e6bc994f2a3b086" translate="yes" xml:space="preserve">
          <source>As &lt;code&gt;-Dm&lt;/code&gt; is using the PerlIO layer for output, it will by itself allocate quite a bunch of SVs, which are hidden to avoid recursion. You can bypass the PerlIO layer if you use the SV logging provided by &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; instead.</source>
          <target state="translated">Como &lt;code&gt;-Dm&lt;/code&gt; est&amp;aacute; usando la capa PerlIO para la salida, por s&amp;iacute; mismo asignar&amp;aacute; un mont&amp;oacute;n de SV, que est&amp;aacute;n ocultos para evitar la recursividad. Puede omitir la capa PerlIO si usa el registro SV proporcionado por &lt;code&gt;-DPERL_MEM_LOG&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="2a4f04aeb40af858ae530be27c732d3a12776244" translate="yes" xml:space="preserve">
          <source>As DSM is a trimmed-down Linux system, it lacks many of the tools and libraries commonly found on Linux. The basic tools like sh, cp, rm, etc. are implemented using &lt;a href=&quot;https://en.wikipedia.org/wiki/BusyBox&quot;&gt;BusyBox&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37a9797fcef19ae902b7dc1fdcbae68c956c3e1b" translate="yes" xml:space="preserve">
          <source>As I work on a particular part of my module it's most likely that the tests that cover that code will fail. I'd like to run the whole test suite but have it prioritize these 'hot' tests. I can tell prove to do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f4dc14381957936768414e0ffe59b0595e92060" translate="yes" xml:space="preserve">
          <source>As JSON cannot directly represent Perl objects, you have to choose between a pure JSON representation (without the ability to deserialise the object automatically again), and a nonstandard extension to the JSON syntax, tagged values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67afac02f586f9bebcefbfe5f3e2ccc5758a2739" translate="yes" xml:space="preserve">
          <source>As Perl is developed by a global team of volunteers, our documentation often contains spellings which look funny to</source>
          <target state="translated">Como Perl es desarrollado por un equipo global de voluntarios,nuestra documentación a menudo contiene ortografías que parecen divertidas para</target>
        </trans-unit>
        <trans-unit id="56f06af6196a2958b2b24cc234e03f482b95a8e2" translate="yes" xml:space="preserve">
          <source>As Storable neither knows nor cares about character sets (although it does know that characters may be more than eight bits wide), any difference in the interpretation of character codes between a host and a target system is your problem. In particular, if host and target use different code points to represent the characters used in the text representation of floating-point numbers, you will not be able be able to exchange floating-point data, even with nstore().</source>
          <target state="translated">Como Storable no conoce ni se preocupa por los conjuntos de caracteres (aunque sí sabe que los caracteres pueden tener más de ocho bits de ancho),cualquier diferencia en la interpretación de los códigos de caracteres entre un sistema anfitrión y uno de destino es su problema.En particular,si el anfitrión y el objetivo utilizan puntos de código diferentes para representar los caracteres utilizados en la representación de texto de los números de punto flotante,no podrá intercambiar datos de punto flotante,ni siquiera con nstore().</target>
        </trans-unit>
        <trans-unit id="4eb26264176ff313034cbea4b1e32ac9ca4ff4be" translate="yes" xml:space="preserve">
          <source>As a beginning Perl programmer, your most common use of OO Perl will be in using third-party modules, which are documented below.</source>
          <target state="translated">Como programador principiante de Perl,su uso más común de OO Perl será en el uso de módulos de terceros,que se documentan a continuación.</target>
        </trans-unit>
        <trans-unit id="053c80fe967b67f5a7cb2ee310e9489c54536633" translate="yes" xml:space="preserve">
          <source>As a code reference, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c668c33e20c8d7992e509e03d3adf2ab76f6474b" translate="yes" xml:space="preserve">
          <source>As a consequence of the fact that &lt;code&gt;:raw&lt;/code&gt; normally pops layers, it usually only makes sense to have it as the only or first element in a layer specification. When used as the first element it provides a known base on which to build e.g.</source>
          <target state="translated">Como consecuencia del hecho de que &lt;code&gt;:raw&lt;/code&gt; normalmente hace aparecer capas, generalmente solo tiene sentido tenerlo como el &amp;uacute;nico o el primer elemento en una especificaci&amp;oacute;n de capa. Cuando se utiliza como primer elemento, proporciona una base conocida sobre la que construir, por ejemplo</target>
        </trans-unit>
        <trans-unit id="85a48b10d40e66cd4a8aedc3b80bf9f3898c7f18" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt; .</source>
          <target state="translated">Como consecuencia, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; pasa por alto cualquier n&amp;uacute;mero o &lt;code&gt;*&lt;/code&gt; despu&amp;eacute;s de &lt;code&gt;P&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="794de411ca7a9fef9a487a0fcead83c094be14c9" translate="yes" xml:space="preserve">
          <source>As a consequence, &lt;code&gt;pack&lt;/code&gt; ignores any number or &lt;code&gt;*&lt;/code&gt; after &lt;code&gt;P&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af58dfe35e68f1702e8805a513e543501b556b2f" translate="yes" xml:space="preserve">
          <source>As a consequence, the behavior of the operator % agrees with the behavior of Perl's built-in % operator (as documented in the perlop manpage), and the equation</source>
          <target state="translated">Como consecuencia,el comportamiento del operador % está de acuerdo con el comportamiento del operador % incorporado de Perl (como se documenta en la página web de perlop),y la ecuación</target>
        </trans-unit>
        <trans-unit id="b71d9a336a26729c423fab79edbbfcd18fbf6683" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ed20c41e94e838dcaa1f2e890809ac53aaadc11" translate="yes" xml:space="preserve">
          <source>As a convenience, &lt;a href=&quot;io/socket&quot;&gt;IO::Socket&lt;/a&gt;'s setsockopt() method will convert a number into a packed byte buffer, and getsockopt() will unpack a byte buffer of the correct size back into a number.</source>
          <target state="translated">Para su comodidad, el m&amp;eacute;todo setsockopt () de &lt;a href=&quot;io/socket&quot;&gt;IO :: Socket&lt;/a&gt; convertir&amp;aacute; un n&amp;uacute;mero en un b&amp;uacute;fer de bytes empaquetado, y getsockopt () descomprimir&amp;aacute; un b&amp;uacute;fer de bytes del tama&amp;ntilde;o correcto en un n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="39dd3ca26236e47c7f0b84b7220b02b39c4ce6f1" translate="yes" xml:space="preserve">
          <source>As a convenience, if only one argument is passed then this argument is assumed to be the name of the test (as in the above examples.)</source>
          <target state="translated">Por comodidad,si sólo se pasa un argumento,se supone que este argumento es el nombre de la prueba (como en los ejemplos anteriores).</target>
        </trans-unit>
        <trans-unit id="1cb03824a7a51fc71299760a7d72ef70c9f7d1d1" translate="yes" xml:space="preserve">
          <source>As a debugging aid, you can force Carp to treat a croak as a confess and a carp as a cluck across</source>
          <target state="translated">Como ayuda a la depuración,puedes obligar a Carpa a tratar un graznido como una confesión y a una carpa como un cloqueo a través de</target>
        </trans-unit>
        <trans-unit id="5de9c4f1738c3fbc65c8014410d9308c0bceec73" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Parser, Pod::PlainText supports the same methods and interfaces. See &lt;a href=&quot;parser&quot;&gt;Pod::Parser&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; and then calls either parse_from_filehandle() or parse_from_file().</source>
          <target state="translated">Como clase derivada de Pod :: Parser, Pod :: PlainText admite los mismos m&amp;eacute;todos e interfaces. Consulte &lt;a href=&quot;parser&quot;&gt;Pod :: Parser&lt;/a&gt; para obtener todos los detalles; brevemente, uno crea un nuevo analizador con &lt;code&gt;Pod::PlainText-&amp;gt;new()&lt;/code&gt; y luego llama a parse_from_filehandle () o parse_from_file ().</target>
        </trans-unit>
        <trans-unit id="64d726339f8e6e60df57582ad6893533391488ae" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6ec952fc34afc28085390c8d52daf19e0a80643" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Man supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details.</source>
          <target state="translated">Como clase derivada de Pod :: Simple, Pod :: Man admite los mismos m&amp;eacute;todos e interfaces. Consulte &lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt; para obtener todos los detalles.</target>
        </trans-unit>
        <trans-unit id="7614b2907ce626d34be33e5f930e92fbced576b9" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;Pod::Simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4fc5bdbe388e6ddf3cda0d8bc20220f607ea7d" translate="yes" xml:space="preserve">
          <source>As a derived class from Pod::Simple, Pod::Text supports the same methods and interfaces. See &lt;a href=&quot;simple&quot;&gt;Pod::Simple&lt;/a&gt; for all the details; briefly, one creates a new parser with &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; and then normally calls parse_file().</source>
          <target state="translated">Como clase derivada de Pod :: Simple, Pod :: Text admite los mismos m&amp;eacute;todos e interfaces. Vea &lt;a href=&quot;simple&quot;&gt;Pod :: Simple&lt;/a&gt; para todos los detalles; brevemente, uno crea un nuevo analizador con &lt;code&gt;Pod::Text-&amp;gt;new()&lt;/code&gt; y luego normalmente llama a parse_file ().</target>
        </trans-unit>
        <trans-unit id="b23f74daa8f57475a4ba46fd4485f5b745823a7e" translate="yes" xml:space="preserve">
          <source>As a final remark, note that one can fill %subr by</source>
          <target state="translated">Como comentario final,note que uno puede llenar el %subr por</target>
        </trans-unit>
        <trans-unit id="4cc64b626e2a5166499114ddf2d5328e019929e3" translate="yes" xml:space="preserve">
          <source>As a final thought, remember that it's not (at the time of writing) possible to produce a useful program which will run in zero or negative time and this basic principle can be written as:</source>
          <target state="translated">Como reflexión final,recuerde que no es posible (en el momento de escribir esto)producir un programa útil que se ejecute en tiempo cero o negativo y este principio básico puede escribirse como:</target>
        </trans-unit>
        <trans-unit id="b93fce445dda74a4e62d212ddcfc5d79912e276b" translate="yes" xml:space="preserve">
          <source>As a final word of warning, if you're using adb, &lt;code&gt;make test&lt;/code&gt; may appear to hang; this is because it doesn't output anything until it finishes running all tests. You can check its progress by logging into the device, moving to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c76d7d0ab08773eceae9495e1336acd5bdc1e071" translate="yes" xml:space="preserve">
          <source>As a further example, this means that if you wanted to put these bits of code in &lt;code&gt;C&lt;/code&gt; (code) style:</source>
          <target state="translated">Como ejemplo adicional, esto significa que si quisiera poner estos bits de c&amp;oacute;digo en estilo &lt;code&gt;C&lt;/code&gt; (c&amp;oacute;digo):</target>
        </trans-unit>
        <trans-unit id="a5d5c5dbed3ae73f59f4d512802a9cfe627521f0" translate="yes" xml:space="preserve">
          <source>As a further example: At time of writing, no &quot;biblio&quot; identifier is supported, but suppose some processor were written to recognize it as a way of (say) denoting a bibliographic reference (necessarily containing formatting codes in ordinary paragraphs). The fact that &quot;biblio&quot; paragraphs were meant for ordinary processing would be indicated by prefacing each &quot;biblio&quot; identifier with a colon:</source>
          <target state="translated">Como otro ejemplo:En el momento de redactar el presente documento no se admite ningún identificador &quot;biblio&quot;,pero supongamos que algún procesador se escribió para reconocerlo como una forma de (digamos)denotar una referencia bibliográfica (que contiene necesariamente códigos de formato en párrafos ordinarios).El hecho de que los párrafos &quot;biblio&quot; estuvieran destinados a un procesamiento ordinario se indicaría precediendo cada identificador &quot;biblio&quot; con dos puntos:</target>
        </trans-unit>
        <trans-unit id="32e712936b7f11c5ab2eb3ed80fcfadcc776b710" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt; , execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="translated">Como optimizaci&amp;oacute;n adicional, al salir del bloque eval en el &lt;code&gt;FETCH&lt;/code&gt; , la ejecuci&amp;oacute;n del c&amp;oacute;digo que sigue al bloque a&amp;uacute;n se lleva a cabo en el bucle interno. Cuando se &lt;code&gt;docatch&lt;/code&gt; una excepci&amp;oacute;n, docatch compara el nivel &lt;code&gt;JMPENV&lt;/code&gt; de &lt;code&gt;CxEVAL&lt;/code&gt; con &lt;code&gt;PL_top_env&lt;/code&gt; y, si difieren, simplemente vuelve a lanzar la excepci&amp;oacute;n. De esta manera se abren los bucles internos.</target>
        </trans-unit>
        <trans-unit id="52bd4fd38df2dbb2fd4340b3f74e473ef3bdf3bc" translate="yes" xml:space="preserve">
          <source>As a further optimisation, on exit from the eval block in the &lt;code&gt;FETCH&lt;/code&gt;, execution of the code following the block is still carried on in the inner loop. When an exception is raised, &lt;code&gt;docatch&lt;/code&gt; compares the &lt;code&gt;JMPENV&lt;/code&gt; level of the &lt;code&gt;CxEVAL&lt;/code&gt; with &lt;code&gt;PL_top_env&lt;/code&gt; and if they differ, just re-throws the exception. In this way any inner loops get popped.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a1271bc4a381b470fd6a076ccacce4ffa6ad068" translate="yes" xml:space="preserve">
          <source>As a further performance optimisation, the various &lt;code&gt;PUSH&lt;/code&gt; macros all operate using a local variable &lt;code&gt;SP&lt;/code&gt;, rather than the interpreter-global variable &lt;code&gt;PL_stack_sp&lt;/code&gt;. This variable is declared by the &lt;code&gt;dSP&lt;/code&gt; macro - though it is normally implied by XSUBs and similar so it is rare you have to consider it directly. Once declared, the &lt;code&gt;PUSH&lt;/code&gt; macros will operate only on this local variable, so before invoking any other perl core functions you must use the &lt;code&gt;PUTBACK&lt;/code&gt; macro to return the value from the local &lt;code&gt;SP&lt;/code&gt; variable back to the interpreter variable. Similarly, after calling a perl core function which may have had reason to move the stack or push/pop values to it, you must use the &lt;code&gt;SPAGAIN&lt;/code&gt; macro which refreshes the local &lt;code&gt;SP&lt;/code&gt; value back from the interpreter one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23702715810537d7f01f041b430e67e396dff672" translate="yes" xml:space="preserve">
          <source>As a general rule of thumb, your commit message should help a programmer who knows the Perl core quickly understand what you were trying to do, how you were trying to do it, and why the change matters to Perl.</source>
          <target state="translated">Como regla general,su mensaje de confirmación debería ayudar a un programador que conoce el núcleo de Perl a comprender rápidamente lo que intentaba hacer,cómo lo intentaba y por qué el cambio es importante para Perl.</target>
        </trans-unit>
        <trans-unit id="4e47a1601663426f056fd202a23442a94b37a934" translate="yes" xml:space="preserve">
          <source>As a general rule you should</source>
          <target state="translated">Como regla general debería</target>
        </trans-unit>
        <trans-unit id="f1a7ae8ef2fbb4b6cb7127db887caa429f079e93" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then &lt;code&gt;@EXPORT_OK&lt;/code&gt; anything but use &lt;code&gt;@EXPORT&lt;/code&gt; with caution. For function and method names use barewords in preference to names prefixed with ampersands for the export lists.</source>
          <target state="translated">Como regla general, si el m&amp;oacute;dulo intenta estar orientado a objetos, no exporte nada. Si es solo una colecci&amp;oacute;n de funciones, &lt;code&gt;@EXPORT_OK&lt;/code&gt; cualquier cosa menos use &lt;code&gt;@EXPORT&lt;/code&gt; con precauci&amp;oacute;n. Para los nombres de funciones y m&amp;eacute;todos, utilice palabras simples en lugar de los nombres con el prefijo y el s&amp;iacute;mbolo para las listas de exportaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e17549d186f2cd9b2973080585cd98536cba2f89" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object oriented then export nothing. If it's just a collection of functions then @EXPORT_OK anything but use @EXPORT with caution.</source>
          <target state="translated">Como regla general,si el módulo trata de ser orientado a objetos,entonces no exportar nada.Si es sólo una colección de funciones entonces @EXPORT_OK cualquier cosa menos usar @EXPORT con precaución.</target>
        </trans-unit>
        <trans-unit id="433c99eba76250876af9c971ad06d88a2549474f" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt; . This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="translated">Como regla general, si el m&amp;oacute;dulo intenta estar orientado a objetos, no exporte nada. Si es solo una colecci&amp;oacute;n de funciones y variables, entonces puede exportarlas a trav&amp;eacute;s de otra matriz, llamada &lt;code&gt;@EXPORT_OK&lt;/code&gt; . Esta matriz no coloca autom&amp;aacute;ticamente sus nombres de subrutina y variable en el espacio de nombres a menos que el usuario solicite espec&amp;iacute;ficamente que se haga esto.</target>
        </trans-unit>
        <trans-unit id="d1e3854176f62c2a9d9d5efd5fe3ab87123d6cec" translate="yes" xml:space="preserve">
          <source>As a general rule, if the module is trying to be object-oriented then don't export anything. If it's just a collection of functions and variables, then you can export them via another array, called &lt;code&gt;@EXPORT_OK&lt;/code&gt;. This array does not automatically place its subroutine and variable names into the namespace unless the user specifically requests that this be done.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7b6a2f89138fc36d28abf12c8042d8936138512" translate="yes" xml:space="preserve">
          <source>As a historical predecessor, Microsoft's variant probably has more rights for the name, though it may be objected that Microsoft shouldn't have used JIS as part of the name in the first place.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a207991a7d026174ee51a8481f0b776cbc48b6ea" translate="yes" xml:space="preserve">
          <source>As a last resort, however:</source>
          <target state="translated">Como último recurso,sin embargo:</target>
        </trans-unit>
        <trans-unit id="3ab2161dda92a73d5893b103484d832131038b70" translate="yes" xml:space="preserve">
          <source>As a last resort, you can use the perl one-liner:</source>
          <target state="translated">Como último recurso,puedes usar el perl de una línea:</target>
        </trans-unit>
        <trans-unit id="9a117b27b5618d5856aaaf26d908e957a310a377" translate="yes" xml:space="preserve">
          <source>As a last resort, you could also use &lt;code&gt;PERL5DB&lt;/code&gt; to customize the debugger by directly setting internal variables or calling debugger functions.</source>
          <target state="translated">Como &amp;uacute;ltimo recurso, tambi&amp;eacute;n puede usar &lt;code&gt;PERL5DB&lt;/code&gt; para personalizar el depurador configurando directamente las variables internas o llamando a las funciones del depurador.</target>
        </trans-unit>
        <trans-unit id="3641087c3ef51813afe729b7c79e589f770bbb23" translate="yes" xml:space="preserve">
          <source>As a matter of policy we do &lt;b&gt;not&lt;/b&gt; edit the history of the blead and maint-* branches. If a typo (or worse) sneaks into a commit to blead or maint-*, we'll fix it in another commit. The only types of updates allowed on these branches are &quot;fast-forwards&quot;, where all history is preserved.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04cbbe97dbf5020460c7615ae57692f7d59ba371" translate="yes" xml:space="preserve">
          <source>As a nonstandard extension to the JSON syntax that is enabled by the &lt;code&gt;relaxed&lt;/code&gt; setting, shell-style comments are allowed. They can start anywhere outside strings and go till the end of the line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46efdbcc9fcabaefc1ffd7ba61888d42081d0818" translate="yes" xml:space="preserve">
          <source>As a noun, a piece of syntax made up of smaller pieces. As a transitive verb, to create an &lt;b&gt;object&lt;/b&gt; using a &lt;b&gt;constructor&lt;/b&gt;.</source>
          <target state="translated">Como sustantivo, una pieza de sintaxis compuesta de piezas m&amp;aacute;s peque&amp;ntilde;as. Como verbo transitivo, crear un &lt;b&gt;objeto&lt;/b&gt; usando un &lt;b&gt;constructor&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d308f1d2a7a4e49c9b329da294e48e6b1847ac8e" translate="yes" xml:space="preserve">
          <source>As a qr// compiled regular expression, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f0cb7718076aa901719a5347944ab158c02cce2" translate="yes" xml:space="preserve">
          <source>As a result of these problems, starting in v5.20, what Perl does is to treat non-Unicode code points as just typical unassigned Unicode characters, and matches accordingly. (Note: Unicode has atypical unassigned code points. For example, it has noncharacter code points, and ones that, when they do get assigned, are destined to be written Right-to-left, as Arabic and Hebrew are. Perl assumes that no non-Unicode code point has any atypical properties.)</source>
          <target state="translated">Como resultado de estos problemas,a partir de la v5.20,lo que hace Perl es tratar los puntos de código no Unicode como los típicos caracteres Unicode no asignados,y los empareja en consecuencia.(Nota:Unicode tiene puntos de código no asignados atípicos.Por ejemplo,tiene puntos de código sin caracteres,y los que,cuando se asignan,están destinados a ser escritos de derecha a izquierda,como el árabe y el hebreo.Perl asume que ningún punto de código no Unicode tiene propiedades atípicas).</target>
        </trans-unit>
        <trans-unit id="dd723ff09f0dfd75022fcfe75451c37784da18b7" translate="yes" xml:space="preserve">
          <source>As a result, &lt;code&gt;$?&lt;/code&gt; will always be zero if the subprocess's exit status indicated successful completion, and non-zero if a warning or error occurred or a program compliant with encoding _POSIX_EXIT values was run and set a status.</source>
          <target state="translated">Como resultado, &lt;code&gt;$?&lt;/code&gt; siempre ser&amp;aacute; cero si el estado de salida del subproceso indic&amp;oacute; una finalizaci&amp;oacute;n exitosa, y distinto de cero si ocurri&amp;oacute; una advertencia o error o si se ejecut&amp;oacute; un programa compatible con la codificaci&amp;oacute;n de valores _POSIX_EXIT y se estableci&amp;oacute; un estado.</target>
        </trans-unit>
        <trans-unit id="c26b5ebaa65b4ac15b7d233c58e1a9bb61162748" translate="yes" xml:space="preserve">
          <source>As a scalar operator:</source>
          <target state="translated">Como un operador escalar:</target>
        </trans-unit>
        <trans-unit id="752c53cfef8630f9f583dd0b9dbea60f05156327" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt; can be written &lt;code&gt;(*:&lt;i&gt;NAME&lt;/i&gt;)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8274ec69a734737beb00f3f5313b731efea1dc76" translate="yes" xml:space="preserve">
          <source>As a shortcut &lt;code&gt;(*MARK:NAME)&lt;/code&gt; can be written &lt;code&gt;(*:NAME)&lt;/code&gt;.</source>
          <target state="translated">Como atajo &lt;code&gt;(*MARK:NAME)&lt;/code&gt; se puede escribir &lt;code&gt;(*:NAME)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2b9a135b5dd5e3840c9d7b2126bd8f1513618105" translate="yes" xml:space="preserve">
          <source>As a shortcut a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="translated">Como un atajo,una llamada de un solo argumento toma el nombre del archivo de la variable escalar global del mismo nombre que el filehandle:</target>
        </trans-unit>
        <trans-unit id="039d51ec286cc421077f33a0f875e9f7cff415a2" translate="yes" xml:space="preserve">
          <source>As a shortcut, a one-argument call takes the filename from the global scalar variable of the same name as the filehandle:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9baecd622ad6ae8ccb368a1f47c6a9f4ae3fac55" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="translated">Como atajo, puede utilizar el m&amp;oacute;dulo &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="36ff34b524a3157846677e62919073347584851b" translate="yes" xml:space="preserve">
          <source>As a shortcut, you can use the module &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b3e1134bf3b8109ecb5762080e2eff8e1996cc6" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt; ) won't work either.</source>
          <target state="translated">Como efecto secundario, como &lt;code&gt;_&lt;/code&gt; no funciona, los operadores de prueba de archivos apilados ( &lt;code&gt;-f -w $file&lt;/code&gt; ) tampoco funcionar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="62159e969c4500e73917688c4b98b60605e2b166" translate="yes" xml:space="preserve">
          <source>As a side effect, as &lt;code&gt;_&lt;/code&gt; doesn't work, stacked filetest operators (&lt;code&gt;-f -w $file&lt;/code&gt;) won't work either.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46d4d9254656022c6da49a40120c1e05ea2c02db" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the keys. In particular, calling &lt;a href=&quot;#keys-HASH&quot;&gt;&lt;code&gt;keys&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e28725785d22d9074c048ed573cb348e22b3201" translate="yes" xml:space="preserve">
          <source>As a side effect, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; resets the HASH or ARRAY's internal iterator (see &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt;) before yielding the values. In particular, calling &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt; in void context resets the iterator with no other overhead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e67c2575fdaa4cadca39640f540c5c1c25ff2b7b" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">Como efecto secundario, llamar a keys () restablece el iterador interno de HASH o ARRAY (ver &lt;a href=&quot;#each&quot;&gt;cada uno&lt;/a&gt; ). En particular, llamar a keys () en un contexto vac&amp;iacute;o restablece el iterador sin otra sobrecarga.</target>
        </trans-unit>
        <trans-unit id="c7b3fa9f58a42d510ccd961956edd3b53e1d0c57" translate="yes" xml:space="preserve">
          <source>As a side effect, calling keys() resets the internal iterator of the HASH or ARRAY (see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;). In particular, calling keys() in void context resets the iterator with no other overhead.</source>
          <target state="translated">Como efecto secundario, llamar a keys () restablece el iterador interno de HASH o ARRAY (ver &lt;a href=&quot;each&quot;&gt;cada uno&lt;/a&gt; ). En particular, llamar a keys () en un contexto vac&amp;iacute;o restablece el iterador sin otra sobrecarga.</target>
        </trans-unit>
        <trans-unit id="aa184b78eeef36fa29a1577f9bf8458234354229" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;#each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">Como efecto secundario, llamar a values ​​() restablece el iterador interno HASH o ARRAY, vea &lt;a href=&quot;#each&quot;&gt;cada uno&lt;/a&gt; . (En particular, llamar a values ​​() en contexto void restablece el iterador sin otra sobrecarga. Aparte de restablecer el iterador, los &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; en el contexto de lista son los mismos que &lt;code&gt;@array&lt;/code&gt; simple . (Recomendamos que use &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; contexto void @array para esto, pero razon&amp;oacute; que eliminar los &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; requerir&amp;iacute;a m&amp;aacute;s documentaci&amp;oacute;n que dejarlos adentro).</target>
        </trans-unit>
        <trans-unit id="a91a0923e5abea890fdc2bd22bb84126ade104fe" translate="yes" xml:space="preserve">
          <source>As a side effect, calling values() resets the HASH or ARRAY's internal iterator, see &lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;. (In particular, calling values() in void context resets the iterator with no other overhead. Apart from resetting the iterator, &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; in list context is the same as plain &lt;code&gt;@array&lt;/code&gt; . (We recommend that you use void context &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; for this, but reasoned that taking &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; out would require more documentation than leaving it in.)</source>
          <target state="translated">Como efecto secundario, llamar a values ​​() restablece el iterador interno HASH o ARRAY, vea &lt;a href=&quot;each&quot;&gt;cada uno&lt;/a&gt; . (En particular, llamar a values ​​() en contexto void restablece el iterador sin otra sobrecarga. Aparte de restablecer el iterador, los &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; en el contexto de lista son los mismos que &lt;code&gt;@array&lt;/code&gt; simple . (Recomendamos que use &lt;code&gt;&lt;a href=&quot;keys&quot;&gt;keys&lt;/a&gt; @array&lt;/code&gt; contexto void @array para esto, pero razon&amp;oacute; que eliminar los &lt;code&gt;&lt;a href=&quot;values&quot;&gt;values&lt;/a&gt; @array&lt;/code&gt; requerir&amp;iacute;a m&amp;aacute;s documentaci&amp;oacute;n que dejarlos adentro).</target>
        </trans-unit>
        <trans-unit id="af3e12604d06f443cb762354f1d6409bffc768b2" translate="yes" xml:space="preserve">
          <source>As a side effect, the timestamps of the written specfiles reflect the linear order of all dependencies.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb674c50cbe5a1c37b1e7edbe788950bfe9342b0" translate="yes" xml:space="preserve">
          <source>As a simple string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e57a1c04bdc517b9206bb149b8d52cd1b60750" translate="yes" xml:space="preserve">
          <source>As a special case</source>
          <target state="translated">Como un caso especial</target>
        </trans-unit>
        <trans-unit id="0643313e18655a38535055ff2dedcaffb5a9d742" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2FPATTERN%2Fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt;) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17ea6c6f4727b11c2b48648599d60dd30f72b5e8" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">Como caso especial de &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , el patr&amp;oacute;n vac&amp;iacute;o dado en la sintaxis del &lt;a href=&quot;perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;operador de coincidencia&lt;/a&gt; ( &lt;code&gt;//&lt;/code&gt; ) coincide espec&amp;iacute;ficamente con la cadena vac&amp;iacute;a, lo que es contrario a su interpretaci&amp;oacute;n habitual como &amp;uacute;ltima coincidencia exitosa.</target>
        </trans-unit>
        <trans-unit id="59db895ceb1feffbf61c972fbfef8ae7b61e3fff" translate="yes" xml:space="preserve">
          <source>As a special case for &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt;, the empty pattern given in &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;match operator&lt;/a&gt; syntax (&lt;code&gt;//&lt;/code&gt; ) specifically matches the empty string, which is contrary to its usual interpretation as the last successful match.</source>
          <target state="translated">Como caso especial de &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; , el patr&amp;oacute;n vac&amp;iacute;o dado en la sintaxis del &lt;a href=&quot;../perlop#m%2fPATTERN%2fmsixpodualngc&quot;&gt;operador de coincidencia&lt;/a&gt; ( &lt;code&gt;//&lt;/code&gt; ) coincide espec&amp;iacute;ficamente con la cadena vac&amp;iacute;a, lo que es contrario a su interpretaci&amp;oacute;n habitual como &amp;uacute;ltima coincidencia exitosa.</target>
        </trans-unit>
        <trans-unit id="527a25823c5b741d3ca1303c6cacef3dfa61f467" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</source>
          <target state="translated">Como caso especial, si la sobrecarga devuelve el objeto en s&amp;iacute;, se utilizar&amp;aacute; directamente. Una conversi&amp;oacute;n sobrecargada que devuelve el objeto probablemente sea un error, porque es probable que obtenga algo similar a &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a27c6716a696c868b2b90bc0841f6de8cd23a521" translate="yes" xml:space="preserve">
          <source>As a special case if the overload returns the object itself then it will be used directly. An overloaded conversion returning the object is probably a bug, because you're likely to get something that looks like &lt;code&gt;YourPackage=HASH(0x8172b34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b483703a04a580981cff65069d8ecd06f49d995" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="898fa8e40ea8bbaf82f7657e12c724a39a6b933a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Como caso especial, la forma de tres argumentos con un modo de lectura / escritura y el tercer argumento es &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="bfe8944e96951a5268014155bb5ff3707aad862a" translate="yes" xml:space="preserve">
          <source>As a special case the three-argument form with a read/write mode and the third argument being &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;:</source>
          <target state="translated">Como caso especial, la forma de tres argumentos con un modo de lectura / escritura y el tercer argumento es &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="39d0f95cc62f9b7d251ca80f498d915dd0b1187f" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt; , not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt; , except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="translated">Como caso especial, &lt;code&gt;\(@foo)&lt;/code&gt; devuelve una lista de referencias al contenido de &lt;code&gt;@foo&lt;/code&gt; , no una referencia a &lt;code&gt;@foo&lt;/code&gt; en s&amp;iacute;. Lo mismo &lt;code&gt;%foo&lt;/code&gt; , excepto que las referencias clave son a copias (dado que las claves son solo cadenas en lugar de escalares completos).</target>
        </trans-unit>
        <trans-unit id="783b2ec5714a2b5973ee8fd00ae088eee54cd571" translate="yes" xml:space="preserve">
          <source>As a special case, &lt;code&gt;\(@foo)&lt;/code&gt; returns a list of references to the contents of &lt;code&gt;@foo&lt;/code&gt;, not a reference to &lt;code&gt;@foo&lt;/code&gt; itself. Likewise for &lt;code&gt;%foo&lt;/code&gt;, except that the key references are to copies (since the keys are just strings rather than full-fledged scalars).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e559b691f686abba65a2b1bdefbe0a3fb92d6845" translate="yes" xml:space="preserve">
          <source>As a special case, if the constructor is passed a single argument (as opposed to an even-sized list of key/value pairs), it is taken to be the value of the &lt;code&gt;PeerAddr&lt;/code&gt; parameter. This is parsed in the same way, according to the behaviour given in the &lt;code&gt;PeerHost&lt;/code&gt; AND &lt;code&gt;LocalHost&lt;/code&gt; PARSING section below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d3b4ecbd7d509c41643f820908fd45c356bb919" translate="yes" xml:space="preserve">
          <source>As a special case, if the test in the &lt;code&gt;for&lt;/code&gt; loop (or the corresponding &lt;code&gt;while&lt;/code&gt; loop) is empty, it is treated as true. That is, both</source>
          <target state="translated">Como caso especial, si la prueba en el ciclo &lt;code&gt;for&lt;/code&gt; (o el ciclo &lt;code&gt;while&lt;/code&gt; correspondiente ) est&amp;aacute; vac&amp;iacute;a, se trata como verdadera. Es decir, ambos</target>
        </trans-unit>
        <trans-unit id="07d1fa15ef1af04fe7ac16e1712ceb861430b28a" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt; . The head should be as described above, say</source>
          <target state="translated">Como caso especial, si el valor de esta variable est&amp;aacute; separado por espacios, la cola puede usarse para desactivar los adornos estableciendo la cola en &lt;code&gt;o=0&lt;/code&gt; o &lt;code&gt;ornaments=0&lt;/code&gt; . La cabeza debe ser como se describe arriba, digamos</target>
        </trans-unit>
        <trans-unit id="ea8552b1560e05c9733562fefc877a4a04a62b1f" translate="yes" xml:space="preserve">
          <source>As a special case, if the value of this variable is space-separated, the tail might be used to disable the ornaments by setting the tail to be &lt;code&gt;o=0&lt;/code&gt; or &lt;code&gt;ornaments=0&lt;/code&gt;. The head should be as described above, say</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fde23ad411d5b9ebf1966fbf214f46640cb22f9" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt; , you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="translated">Como caso especial, si especifica el nombre del m&amp;oacute;dulo &lt;code&gt;Unicode&lt;/code&gt; , obtendr&amp;aacute; el n&amp;uacute;mero de versi&amp;oacute;n de la base de datos de caracteres Unicode incluida con las versiones de Perl solicitadas.</target>
        </trans-unit>
        <trans-unit id="ed0f26789d5db7e7c0ccec99b141a92d811bb2de" translate="yes" xml:space="preserve">
          <source>As a special case, if you specify the module name &lt;code&gt;Unicode&lt;/code&gt;, you'll get the version number of the Unicode Character Database bundled with the requested perl versions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03f58faea796a1077f97500a4e213c983487f04c" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with a hash reference as the sole argument, this causes an assignment of the whole hash element. The object reference is returned.</source>
          <target state="translated">Como caso especial,cuando se llama al accesorio con una referencia de hachís como único argumento,esto provoca una asignación de todo el elemento de hachís.La referencia del objeto es devuelta.</target>
        </trans-unit>
        <trans-unit id="d80964d39654d27c73a60223b4ebc15d6e6b2f91" translate="yes" xml:space="preserve">
          <source>As a special case, when the accessor is called with an array reference as the sole argument, this causes an assignment of the whole array element. The object reference is returned.</source>
          <target state="translated">Como caso especial,cuando se llama al accesorio con una referencia de matriz como único argumento,esto provoca una asignación de todo el elemento de la matriz.La referencia del objeto es devuelta.</target>
        </trans-unit>
        <trans-unit id="261536d85ff532107bd0e6c855c28c78277c6b3c" translate="yes" xml:space="preserve">
          <source>As a special exception, when you slice a list (but not an array or a hash), if the list evaluates to empty, then taking a slice of that empty list will always yield the empty list in turn. Thus:</source>
          <target state="translated">Como excepción especial,cuando se corta una lista (pero no una matriz o un hash),si la lista evalúa que está vacía,entonces tomar un trozo de esa lista vacía siempre dará como resultado la lista vacía a su vez.Por lo tanto:</target>
        </trans-unit>
        <trans-unit id="267a52b216bf364239047183b439e3e80275f9ef" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. Contact us at &amp;lt;perl5-security-report@perl.org&amp;gt; to begin that process.</source>
          <target state="translated">Como proveedor, es posible que tenga el requisito de respaldar las correcciones de seguridad m&amp;aacute;s all&amp;aacute; de nuestro compromiso de soporte de 3 a&amp;ntilde;os. Podemos brindarle asistencia y asesoramiento limitados mientras lo hace y, cuando sea posible, intentaremos aplicar esos parches a las ramas -maint relevantes en git, aunque podemos o no optar por hacer disponibles versiones numeradas o parches &quot;oficiales&quot;. Cont&amp;aacute;ctenos en &amp;lt;perl5-security-report@perl.org&amp;gt; para comenzar ese proceso.</target>
        </trans-unit>
        <trans-unit id="f4351851a4bb7c858433022e707056375232e54d" translate="yes" xml:space="preserve">
          <source>As a vendor, you may have a requirement to backport security fixes beyond our 3 year support commitment. We can provide limited support and advice to you as you do so and, where possible will try to apply those patches to the relevant -maint branches in git, though we may or may not choose to make numbered releases or &quot;official&quot; patches available. See &lt;a href=&quot;perlsec#SECURITY-VULNERABILITY-CONTACT-INFORMATION&quot;&gt;&quot;SECURITY VULNERABILITY CONTACT INFORMATION&quot; in perlsec&lt;/a&gt; for details on how to begin that process.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b767e1ab5bdc22f58c69583808a39ce8aa5393a" translate="yes" xml:space="preserve">
          <source>As a volunteer organization, the commitments we make are heavily dependent on the goodwill and hard work of individuals who have no obligation to contribute to Perl.</source>
          <target state="translated">Como organización de voluntarios,los compromisos que asumimos dependen en gran medida de la buena voluntad y el trabajo duro de las personas que no tienen la obligación de contribuir a Perl.</target>
        </trans-unit>
        <trans-unit id="b55a4625fdc844badd446c13482f0c20c8caa1b5" translate="yes" xml:space="preserve">
          <source>As above, but the destination node text of the link.</source>
          <target state="translated">Como arriba,pero el texto del nodo de destino del enlace.</target>
        </trans-unit>
        <trans-unit id="07731660b460e18f03465884e08d802967534966" translate="yes" xml:space="preserve">
          <source>As all values evaluate to true, a simple &lt;code&gt;if&lt;/code&gt; test is good enough to determine whether an extension is present.</source>
          <target state="translated">Como todos los valores se eval&amp;uacute;an como verdaderos, una simple prueba &lt;code&gt;if&lt;/code&gt; es suficientemente buena para determinar si una extensi&amp;oacute;n est&amp;aacute; presente.</target>
        </trans-unit>
        <trans-unit id="049e8d249c3ad3a2a8b180055568baa12252b047" translate="yes" xml:space="preserve">
          <source>As alluded to earlier you can also declare inlined subs dynamically at BEGIN time if their body consists of a lexically-scoped scalar which has no other references. Only the first example here will be inlined:</source>
          <target state="translated">Como se mencionó anteriormente,también se pueden declarar dinámicamente los subconjuntos alineados en el momento del inicio si su cuerpo consiste en un escalar léxico que no tiene otras referencias.Sólo el primer ejemplo aquí estará alineado:</target>
        </trans-unit>
        <trans-unit id="40622c1595c0e7b33c82f810ddadd26599013393" translate="yes" xml:space="preserve">
          <source>As alternatives to &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; when used for control flow, Perl provides the &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt; operators (see below). The short-circuit behavior is identical. The precedence of &lt;code&gt;&quot;and&quot;&lt;/code&gt; and &lt;code&gt;&quot;or&quot;&lt;/code&gt; is much lower, however, so that you can safely use them after a list operator without the need for parentheses:</source>
          <target state="translated">Como alternativas a &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; y &lt;code&gt;||&lt;/code&gt; cuando se usa para el flujo de control, Perl proporciona la &lt;code&gt;and&lt;/code&gt; y &lt;code&gt;or&lt;/code&gt; operadores (ver abajo). El comportamiento de cortocircuito es id&amp;eacute;ntico. Sin embargo, la precedencia de &lt;code&gt;&quot;and&quot;&lt;/code&gt; y &lt;code&gt;&quot;or&quot;&lt;/code&gt; es mucho menor, por lo que puede usarlos de manera segura despu&amp;eacute;s de un operador de lista sin necesidad de par&amp;eacute;ntesis:</target>
        </trans-unit>
        <trans-unit id="c44b3a4add0c470afd83290fbaea5d47d3bf3bcb" translate="yes" xml:space="preserve">
          <source>As always with Perl there is more than one way to do it. Below are a few examples of approaches to making common conversions between number representations. This is intended to be representational rather than exhaustive.</source>
          <target state="translated">Como siempre con Perl hay más de una manera de hacerlo.A continuación se presentan algunos ejemplos de enfoques para hacer conversiones comunes entre representaciones numéricas.Esto pretende ser representativo más que exhaustivo.</target>
        </trans-unit>
        <trans-unit id="a27e8bc51d6a9b14b4e2235fdc7ebedf28d134bc" translate="yes" xml:space="preserve">
          <source>As always, if any of these are ever officially declared as bugs, they'll be fixed and removed.</source>
          <target state="translated">Como siempre,si alguna vez se declaran oficialmente como bichos,serán arreglados y eliminados.</target>
        </trans-unit>
        <trans-unit id="43d8cae7f79fc634e42b4fbb6869d40983003e1e" translate="yes" xml:space="preserve">
          <source>As always, setting up a server is little bit more involved than running a client. The model is that the server creates a special kind of socket that does nothing but listen on a particular port for incoming connections. It does this by calling the &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; method with slightly different arguments than the client did.</source>
          <target state="translated">Como siempre, configurar un servidor es un poco m&amp;aacute;s complicado que ejecutar un cliente. El modelo es que el servidor crea un tipo especial de socket que no hace m&amp;aacute;s que escuchar en un puerto particular las conexiones entrantes. Lo hace llamando al m&amp;eacute;todo &lt;code&gt;IO::Socket::INET-&amp;gt;new()&lt;/code&gt; con argumentos ligeramente diferentes a los del cliente.</target>
        </trans-unit>
        <trans-unit id="b052d1d2bb45ec362535f92deef9adc1abd8b3f0" translate="yes" xml:space="preserve">
          <source>As an (ahem) accidental feature, &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines were looked up as methods (using the &lt;code&gt;@ISA&lt;/code&gt; hierarchy) even when the subroutines to be autoloaded were called as plain functions (e.g. &lt;code&gt;Foo::bar()&lt;/code&gt;), not as methods (e.g. &lt;code&gt;Foo-&amp;gt;bar()&lt;/code&gt; or &lt;code&gt;$obj-&amp;gt;bar()&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90ed318055b1f6119d9ba187aa6944aea5c29dbe" translate="yes" xml:space="preserve">
          <source>As an added convenience, the Digest::SHA module offers routines to calculate keyed hashes using the HMAC-SHA-1/224/256/384/512 algorithms. These services exist in functional form only, and mimic the style and behavior of the</source>
          <target state="translated">Como una conveniencia adicional,el módulo Digest::SHA ofrece rutinas para calcular hashes clave usando los algoritmos HMAC-SHA-1/224/256/384/512.Estos servicios existen sólo en forma funcional,e imitan el estilo y el comportamiento del</target>
        </trans-unit>
        <trans-unit id="d0e4684ebfef4659c7147a264548f0d1e61303df" translate="yes" xml:space="preserve">
          <source>As an aid in resetting colors, colored() takes a scalar as the first argument and any number of attribute strings as the second argument and returns the scalar wrapped in escape codes so that the attributes will be set as requested before the string and reset to normal after the string. Alternately, you can pass a reference to an array as the first argument, and then the contents of that array will be taken as attributes and color codes and the remainder of the arguments as text to colorize.</source>
          <target state="translated">Como ayuda para restablecer los colores,colored()toma un escalar como primer argumento y cualquier número de cadenas de atributos como segundo argumento y devuelve el escalar envuelto en códigos de escape para que los atributos se establezcan como se solicitó antes de la cadena y se restablezcan a la normalidad después de la cadena.Alternativamente,puedes pasar una referencia a una matriz como primer argumento,y entonces el contenido de esa matriz se tomará como atributos y códigos de color y el resto de los argumentos como texto a colorear.</target>
        </trans-unit>
        <trans-unit id="0317f97de63b01d4c67910fb17a2e6ee0d204ecf" translate="yes" xml:space="preserve">
          <source>As an alternative to subclassing the components I need to change I can attach callbacks to the default classes. TAP::Harness exposes these callbacks:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c1670ab0bb7042a354367f8f6979cab460d9b35" translate="yes" xml:space="preserve">
          <source>As an alternative to the above, you may prefer to throw exceptions using the Error module.</source>
          <target state="translated">Como alternativa a lo anterior,puede que prefiera lanzar excepciones usando el módulo de error.</target>
        </trans-unit>
        <trans-unit id="8f3dc04daa3638b5aaf1c862a68465a157788d9e" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::InputMap&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f943c4f68c18459667f13d0990dfceca7c5ca2a9" translate="yes" xml:space="preserve">
          <source>As an alternative to the named parameters usage, you may pass in an &lt;code&gt;ExtUtils::Typemaps::Type&lt;/code&gt; object as first argument, a copy of which will be added to the typemap. In that case, only the &lt;code&gt;replace&lt;/code&gt; or &lt;code&gt;skip&lt;/code&gt; named parameters may be used after the object. Example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="782eb5f652231f0fff9e780cbf2fef47e3527def" translate="yes" xml:space="preserve">
          <source>As an alternative, overloaded constants (see &lt;a href=&quot;overload&quot;&gt;overload&lt;/a&gt;) provide a simple way to extend the functionality of the RE engine, by substituting one pattern for another.</source>
          <target state="translated">Como alternativa, las constantes sobrecargadas (ver &lt;a href=&quot;overload&quot;&gt;sobrecarga&lt;/a&gt; ) proporcionan una forma sencilla de ampliar la funcionalidad del motor RE, sustituyendo un patr&amp;oacute;n por otro.</target>
        </trans-unit>
        <trans-unit id="18772395363d0e88e55df307a43fbfe2be745eba" translate="yes" xml:space="preserve">
          <source>As an alternative, specify a number instead of list of letters (e.g., &lt;b&gt;-D14&lt;/b&gt; is equivalent to &lt;b&gt;-Dtls&lt;/b&gt;):</source>
          <target state="translated">Como alternativa, especifique un n&amp;uacute;mero en lugar de una lista de letras (por ejemplo, &lt;b&gt;-D14&lt;/b&gt; es equivalente a &lt;b&gt;-Dtls&lt;/b&gt; ):</target>
        </trans-unit>
        <trans-unit id="8f4ba5d9ceee180216d44c33a248904b28bf93a4" translate="yes" xml:space="preserve">
          <source>As an alternative, to keep the case of the replacement word if it is longer than the original, you can use this code, by Jeff Pinyan:</source>
          <target state="translated">Como alternativa,para mantener el caso de la palabra de reemplazo si es más larga que la original,puedes usar este código,de Jeff Pinyan:</target>
        </trans-unit>
        <trans-unit id="b70856a89ed6672d06c69a35074c3c6f2093e9dd" translate="yes" xml:space="preserve">
          <source>As an example consider the structure of a zip file. This is a well-defined file format that mixes both compressed and uncompressed sections of data in a single file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="edc86b424441622df9f0c07df7eb59f80cab5da3" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt; , but not otherwise, is the pattern</source>
          <target state="translated">Como ejemplo de algo que est&amp;aacute; atrapado bajo &lt;code&gt;&quot;strict'&lt;/code&gt; , pero no de otra manera, es el patr&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="ec5fbaf06c5491bc9e0146955b6b1bccb85f04a8" translate="yes" xml:space="preserve">
          <source>As an example of something that is caught under &lt;code&gt;&quot;strict'&lt;/code&gt;, but not otherwise, is the pattern</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b1b17f0c5a778dad149ae64ff9d232a5d6120e" translate="yes" xml:space="preserve">
          <source>As an example of this case, this code prints the message &quot;Perl exited with active threads: 2 running and unjoined&quot;:</source>
          <target state="translated">Como ejemplo de este caso,este código imprime el mensaje &quot;Perl salió con hilos activos&quot;:2 corriendo y sin unir&quot;:</target>
        </trans-unit>
        <trans-unit id="fd8cd6983452bdbcd828fbbb431f9c0eaf4c793d" translate="yes" xml:space="preserve">
          <source>As an example where a possessive quantifier is suitable we consider matching a quoted string, as it appears in several programming languages. The backslash is used as an escape character that indicates that the next character is to be taken literally, as another character for the string. Therefore, after the opening quote, we expect a (possibly empty) sequence of alternatives: either some character except an unescaped quote or backslash or an escaped character.</source>
          <target state="translated">Como ejemplo de que un cuantificador posesivo es adecuado,consideramos la posibilidad de hacer coincidir una cadena citada,tal como aparece en varios lenguajes de programación.La barra invertida se utiliza como un carácter de escape que indica que el siguiente carácter debe ser tomado literalmente,como otro carácter para la cadena.Por lo tanto,después de la cita inicial,esperamos una secuencia (posiblemente vacía)de alternativas:algún carácter excepto una cita no escapada o una barra invertida o un carácter escapado.</target>
        </trans-unit>
        <trans-unit id="5cd508967ae1e206046e267640fdf9448ece0fe7" translate="yes" xml:space="preserve">
          <source>As an example, let's implement a &lt;code&gt;THAW&lt;/code&gt; function that regenerates the &lt;code&gt;My::Object&lt;/code&gt; from the &lt;code&gt;FREEZE&lt;/code&gt; example earlier:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82731324b346859b9bccf9603560116021199d53" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , it encodes the character in UTF-8 and stores it in $x. Then it is marked as character data, so, for instance, &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt; . However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, $x is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt; :</source>
          <target state="translated">Por ejemplo, cuando Perl ve &lt;code&gt;$x = &lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;(400)&lt;/code&gt; , codifica el car&amp;aacute;cter en UTF-8 y lo almacena en $ x. Luego se marca como datos de caracteres, por lo que, por ejemplo, la &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; devuelve &lt;code&gt;1&lt;/code&gt; . Sin embargo, en el &amp;aacute;mbito del pragma de &lt;code&gt;bytes&lt;/code&gt; , $ x se trata como una serie de bytes, los bytes que componen la codificaci&amp;oacute;n UTF8, y la &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt; $x&lt;/code&gt; devuelve &lt;code&gt;2&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="4cc20e99e2c8e44ee448eca66f36aaad208e30f4" translate="yes" xml:space="preserve">
          <source>As an example, when Perl sees &lt;code&gt;$x = chr(400)&lt;/code&gt;, it encodes the character in UTF-8 and stores it in &lt;code&gt;$x&lt;/code&gt;. Then it is marked as character data, so, for instance, &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;1&lt;/code&gt;. However, in the scope of the &lt;code&gt;bytes&lt;/code&gt; pragma, &lt;code&gt;$x&lt;/code&gt; is treated as a series of bytes - the bytes that make up the UTF8 encoding - and &lt;code&gt;length $x&lt;/code&gt; returns &lt;code&gt;2&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c313609d4ce2bde8a8cf3d1a920bc018f88eebaa" translate="yes" xml:space="preserve">
          <source>As an interim measure, you may either change the #! line of your scripts to specifically refer to the old perl version, e.g. on Solaris 9 use #!/usr/perl5/5.00503/bin/perl to use the perl version that was the default for Solaris 8, or if you have a large number of scripts it may be more convenient to make the old version of perl the default on your system. You can do this by changing the appropriate symlinks under /usr/perl5 as follows (example for Solaris 9):</source>
          <target state="translated">Como medida provisional,puede cambiar la línea #! de sus scripts para referirse específicamente a la antigua versión de perl,por ejemplo,en Solaris 9 use #!/usr/perl5/5.00503/bin/perl para usar la versión de perl que era la predeterminada para Solaris 8,o si tiene un gran número de scripts puede ser más conveniente hacer que la antigua versión de perl sea la predeterminada en su sistema.Puede hacerlo cambiando los enlaces simbólicos apropiados en /usr/perl5 de la siguiente manera (ejemplo para Solaris 9):</target>
        </trans-unit>
        <trans-unit id="373576f861e30b7c81e25bff74bee6e23c15298c" translate="yes" xml:space="preserve">
          <source>As an optimization, may not call the command shell specified in &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; spawns an external process and immediately returns its process designator, without waiting for it to terminate. Return value may be used subsequently in &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt;. Failure to &lt;code&gt;spawn()&lt;/code&gt; a subprocess is indicated by setting &lt;code&gt;$?&lt;/code&gt; to &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; is set in a way compatible with Unix (i.e. the exitstatus of the subprocess is obtained by &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot;&amp;gt;&amp;gt;, as described in the documentation). (Win32)</source>
          <target state="translated">Como optimizaci&amp;oacute;n, no se puede llamar al shell de comandos especificado en &lt;code&gt;$ENV{PERL5SHELL}&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;(1, @args)&lt;/code&gt; genera un proceso externo e inmediatamente devuelve su designador de proceso, sin esperar a que termine. El valor de retorno se puede utilizar posteriormente en &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/waitpid&quot;&gt;waitpid&lt;/a&gt;&lt;/code&gt; . La falla al &lt;code&gt;spawn()&lt;/code&gt; un subproceso se indica configurando &lt;code&gt;$?&lt;/code&gt; a &lt;code&gt;&quot;255 &amp;lt;&amp;lt; 8&quot;&lt;/code&gt; . &lt;code&gt;$?&lt;/code&gt; est&amp;aacute; configurado de una manera compatible con Unix (es decir, el estado de salida del subproceso se obtiene mediante &lt;code&gt;&quot;$?&lt;/code&gt; 8&quot; &amp;gt;&amp;gt;, como se describe en la documentaci&amp;oacute;n). (Win32)</target>
        </trans-unit>
        <trans-unit id="137d06b82a3cf943b3082535121ce9ca48c386c5" translate="yes" xml:space="preserve">
          <source>As another example, this Pod source:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24dac5f3b0ae02bfc967e018bd163c71db2de949" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;a href=&quot;#split-%2FPATTERN%2F%2CEXPR%2CLIMIT&quot;&gt;&lt;code&gt;split&lt;/code&gt;&lt;/a&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a string composed of a single space character (such as &lt;code&gt;' '&lt;/code&gt; or &lt;code&gt;&quot;\x20&quot;&lt;/code&gt;, but not e.g. &lt;code&gt;/ /&lt;/code&gt;). In this case, any leading whitespace in EXPR is removed before splitting occurs, and the PATTERN is instead treated as if it were &lt;code&gt;/\s+/&lt;/code&gt;; in particular, this means that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38474bdd192558dcfa688dfaf6e45817a6f595ea" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">Como otro caso especial, &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emula el comportamiento predeterminado de la herramienta de l&amp;iacute;nea de comando &lt;b&gt;awk&lt;/b&gt; cuando el PATR&amp;Oacute;N se omite o</target>
        </trans-unit>
        <trans-unit id="aab9f2eadc04a37e669ffc31217a1ec91df2a94d" translate="yes" xml:space="preserve">
          <source>As another special case, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emulates the default behavior of the command line tool &lt;b&gt;awk&lt;/b&gt; when the PATTERN is either omitted or a</source>
          <target state="translated">Como otro caso especial, &lt;code&gt;&lt;a href=&quot;split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; emula el comportamiento predeterminado de la herramienta de l&amp;iacute;nea de comando &lt;b&gt;awk&lt;/b&gt; cuando el PATR&amp;Oacute;N se omite o</target>
        </trans-unit>
        <trans-unit id="46ab5c6135652ee2c4d494e00004b3edd1c35481" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , which are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation char equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt; , and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="translated">Como otra soluci&amp;oacute;n para este problema, Perl 5.10.0 introdujo &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; y &lt;code&gt;${^POSTMATCH}&lt;/code&gt; , que son equivalentes a &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; y &lt;code&gt;$'&lt;/code&gt; , &lt;b&gt;excepto&lt;/b&gt; que solo se garantiza que definirse despu&amp;eacute;s de una coincidencia exitosa que se ejecut&amp;oacute; con el modificador &lt;code&gt;/p&lt;/code&gt; (preserve). El uso de estas variables no incurre en una penalizaci&amp;oacute;n de rendimiento global, a diferencia de sus equivalentes de caracteres de puntuaci&amp;oacute;n, sin embargo, hay que decirle a Perl cu&amp;aacute;ndo desea usarlas. A partir de Perl 5.20, estas tres variables son equivalentes a &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$&amp;amp;&lt;/code&gt; y &lt;code&gt;$'&lt;/code&gt; , y &lt;code&gt;/p&lt;/code&gt; se ignora.</target>
        </trans-unit>
        <trans-unit id="5306125a9b9482228b73d9001504cb8ff0235e3b" translate="yes" xml:space="preserve">
          <source>As another workaround for this problem, Perl 5.10.0 introduced &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt;, which are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, &lt;b&gt;except&lt;/b&gt; that they are only guaranteed to be defined after a successful match that was executed with the &lt;code&gt;/p&lt;/code&gt; (preserve) modifier. The use of these variables incurs no global performance penalty, unlike their punctuation character equivalents, however at the trade-off that you have to tell perl when you want to use them. As of Perl 5.20, these three variables are equivalent to &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$&amp;amp;&lt;/code&gt; and &lt;code&gt;$'&lt;/code&gt;, and &lt;code&gt;/p&lt;/code&gt; is ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="faf1880e6e4e5e1670571e23b070295ae744c1fc" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; , and &lt;code&gt;&amp;amp;=&lt;/code&gt; . While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="translated">Como se describi&amp;oacute; &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;anteriormente&lt;/a&gt; , Perl puede llamar a m&amp;eacute;todos para operadores como &lt;code&gt;+&lt;/code&gt; y &lt;code&gt;&amp;amp;&lt;/code&gt; en el curso de la implementaci&amp;oacute;n de operaciones faltantes como &lt;code&gt;++&lt;/code&gt; , &lt;code&gt;+=&lt;/code&gt; y &lt;code&gt;&amp;amp;=&lt;/code&gt; . Si bien estos m&amp;eacute;todos pueden detectar este uso probando la definici&amp;oacute;n del tercer argumento, en todos los casos deben evitar cambiar sus operandos. Esto se debe a que Perl no llama al constructor de copia antes de invocar estos m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="20dd96aab8100e801c2698dbb8e487016840bd2c" translate="yes" xml:space="preserve">
          <source>As described &lt;a href=&quot;#Calling-Conventions-and-Magic-Autogeneration&quot;&gt;above&lt;/a&gt;, Perl may call methods for operators like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;&amp;amp;&lt;/code&gt; in the course of implementing missing operations like &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, and &lt;code&gt;&amp;amp;=&lt;/code&gt;. While these methods may detect this usage by testing the definedness of the third argument, they should in all cases avoid changing their operands. This is because Perl does not call the copy constructor before invoking these methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9c1d88156738ffdc72a22d4eb2c079c412ad705" translate="yes" xml:space="preserve">
          <source>As described earlier, if there are many changes on your smoke-me branch then you should prepare a merge commit in which to give an overview of those changes by using the following command instead of the last command above:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff132deadaac51720c9e117548f044618ad0a39" translate="yes" xml:space="preserve">
          <source>As discussed elsewhere, Perl has one foot (two hooves?) planted in each of two worlds: the old world of ASCII and single-byte locales, and the new world of Unicode, upgrading when necessary. If your legacy code does not explicitly use Unicode, no automatic switch-over to Unicode should happen.</source>
          <target state="translated">Como ya se ha dicho,Perl tiene un pie (¿dos pezuñas?)plantado en cada uno de los dos mundos:el viejo mundo del ASCII y los locales de un solo byte,y el nuevo mundo del Unicode,que se actualiza cuando es necesario.Si su código heredado no utiliza explícitamente Unicode,no debería producirse un cambio automático a Unicode.</target>
        </trans-unit>
        <trans-unit id="3a28f6e945d7b1d8cd9440551fcd17f03dc59837" translate="yes" xml:space="preserve">
          <source>As explained above, an anonymous function with access to the lexical variables visible when that function was compiled, creates a closure. It retains access to those variables even though it doesn't get run until later, such as in a signal handler or a Tk callback.</source>
          <target state="translated">Como se ha explicado anteriormente,una función anónima con acceso a las variables léxicas visibles cuando se compiló esa función,crea un cierre.Mantiene el acceso a esas variables aunque no se ejecute hasta más tarde,como en un manejador de señales o una llamada Tk.</target>
        </trans-unit>
        <trans-unit id="03fe8a37ea6c568501bcfeecc21187a67095c9a8" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;&quot;ASCII Rules versus Unicode Rules&quot;&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de6278f8e877d258b1f62760a70228a073ba24fd" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;ASCII Rules versus Unicode Rules&lt;/a&gt;, under ASCII rules, they are considered to be unassigned characters.</source>
          <target state="translated">Como se explica en &lt;a href=&quot;#ASCII-Rules-versus-Unicode-Rules&quot;&gt;Reglas ASCII frente a Reglas Unicode&lt;/a&gt; , seg&amp;uacute;n las reglas ASCII, se consideran caracteres no asignados.</target>
        </trans-unit>
        <trans-unit id="48e236093008993b6e4def956b958d0cb620db14" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist%28%29&quot;&gt;&quot;prop_invlist()&quot;&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap%28%29&quot;&gt;&quot;prop_invmap()&quot;&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ffaa22d40c8f644f2c59a68a07b28bdf08a1f8a" translate="yes" xml:space="preserve">
          <source>As explained in &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist()&lt;/a&gt;, whether a code point is in the list or not depends on if the index is even (in) or odd (not in). And as explained in &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap()&lt;/a&gt;, the index is used with the returned parallel array to find the mapping.</source>
          <target state="translated">Como se explica en &lt;a href=&quot;#prop_invlist()&quot;&gt;prop_invlist ()&lt;/a&gt; , si un punto de c&amp;oacute;digo est&amp;aacute; en la lista o no depende de si el &amp;iacute;ndice es par (en) o impar (no en). Y como se explica en &lt;a href=&quot;#prop_invmap()&quot;&gt;prop_invmap ()&lt;/a&gt; , el &amp;iacute;ndice se usa con la matriz paralela devuelta para encontrar el mapeo.</target>
        </trans-unit>
        <trans-unit id="bf0e7abd7a09ee9c2ba9a8344c5b618840f66e79" translate="yes" xml:space="preserve">
          <source>As far as creating the &lt;code&gt;$pOverlapped&lt;/code&gt; structure, you are currently on your own.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101540b4758da815d4da97e60284cb84f98af97f" translate="yes" xml:space="preserve">
          <source>As for new features and requests to change common behaviors, please ask the author of JSON::XS (Marc Lehmann, &amp;lt;schmorp[at]schmorp.de&amp;gt;) first, by email (important!), to keep compatibility among JSON.pm backends.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c53e475afb32fdd8296f1c9a917ef2e75b376078" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt; .</source>
          <target state="translated">En cuanto a otras operaciones, a la subrutina que implementa '=' se le pasan tres argumentos, aunque los dos &amp;uacute;ltimos son siempre &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;''&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bf65c0259648a27866b59740e85994dce5ffc5e7" translate="yes" xml:space="preserve">
          <source>As for other operations, the subroutine implementing '=' is passed three arguments, though the last two are always &lt;code&gt;undef&lt;/code&gt; and &lt;code&gt;''&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf2ef2540039c1386257379903eff22c20c0bad" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:&lt;i&gt;name&lt;/i&gt;:]&lt;/code&gt;, with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f54bd3297d1b4b8911e3de6ffd9e1ee35795e3c" translate="yes" xml:space="preserve">
          <source>As if all those classes weren't enough, Perl also defines POSIX-style character classes. These have the form &lt;code&gt;[:name:]&lt;/code&gt;, with &lt;code&gt;name&lt;/code&gt; the name of the POSIX class. The POSIX classes are &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; , and &lt;code&gt;xdigit&lt;/code&gt; , and two extensions, &lt;code&gt;word&lt;/code&gt; (a Perl extension to match &lt;code&gt;\w&lt;/code&gt; ), and &lt;code&gt;blank&lt;/code&gt; (a GNU extension). The &lt;code&gt;//a&lt;/code&gt; modifier restricts these to matching just in the ASCII range; otherwise they can match the same as their corresponding Perl Unicode classes: &lt;code&gt;[:upper:]&lt;/code&gt; is the same as &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (There are some exceptions and gotchas with this; see &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; for a full discussion.) The &lt;code&gt;[:digit:]&lt;/code&gt;, &lt;code&gt;[:word:]&lt;/code&gt;, and &lt;code&gt;[:space:]&lt;/code&gt; correspond to the familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; , and &lt;code&gt;\s&lt;/code&gt; character classes. To negate a POSIX class, put a &lt;code&gt;^&lt;/code&gt; in front of the name, so that, e.g., &lt;code&gt;[:^digit:]&lt;/code&gt; corresponds to &lt;code&gt;\D&lt;/code&gt; and, under Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . The Unicode and POSIX character classes can be used just like &lt;code&gt;\d&lt;/code&gt; , with the exception that POSIX character classes can only be used inside of a character class:</source>
          <target state="translated">Como si todas esas clases no fueran suficientes, Perl tambi&amp;eacute;n define clases de caracteres al estilo POSIX. Estos tienen la forma &lt;code&gt;[:name:]&lt;/code&gt; , con &lt;code&gt;name&lt;/code&gt; el nombre de la clase POSIX. Las clases POSIX son &lt;code&gt;alpha&lt;/code&gt; , &lt;code&gt;alnum&lt;/code&gt; , &lt;code&gt;ascii&lt;/code&gt; , &lt;code&gt;cntrl&lt;/code&gt; , &lt;code&gt;digit&lt;/code&gt; , &lt;code&gt;graph&lt;/code&gt; , &lt;code&gt;lower&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;punct&lt;/code&gt; , &lt;code&gt;space&lt;/code&gt; , &lt;code&gt;upper&lt;/code&gt; y &lt;code&gt;xdigit&lt;/code&gt; , y dos extensiones, &lt;code&gt;word&lt;/code&gt; (una extensi&amp;oacute;n Perl para coincidir con &lt;code&gt;\w&lt;/code&gt; ) y en &lt;code&gt;blank&lt;/code&gt; (una extensi&amp;oacute;n GNU ). El &lt;code&gt;//a&lt;/code&gt; El modificador los restringe para que coincidan solo en el rango ASCII; de lo contrario se pueden igualar los mismos que sus correspondientes clases Perl Unicode: &lt;code&gt;[:upper:]&lt;/code&gt; es lo mismo que &lt;code&gt;\p{IsUpper}&lt;/code&gt; , etc. (Hay algunas excepciones y trampas con este; ver &lt;a href=&quot;perlrecharclass&quot;&gt;perlrecharclass&lt;/a&gt; para una discusi&amp;oacute;n completa.) El &lt;code&gt;[:digit:]&lt;/code&gt; , &lt;code&gt;[:word:]&lt;/code&gt; y &lt;code&gt;[:space:]&lt;/code&gt; corresponden a lo familiar &lt;code&gt;\d&lt;/code&gt; , &lt;code&gt;\w&lt;/code&gt; y &lt;code&gt;\s&lt;/code&gt; clases de personajes. Para negar una clase POSIX, coloque &lt;code&gt;^&lt;/code&gt; delante del nombre, de modo que, por ejemplo, &lt;code&gt;[:^digit:]&lt;/code&gt; corresponda a &lt;code&gt;\D&lt;/code&gt; y, en Unicode, &lt;code&gt;\P{IsDigit}&lt;/code&gt; . Las clases de caracteres Unicode y POSIX se pueden usar como &lt;code&gt;\d&lt;/code&gt; , con la excepci&amp;oacute;n de que las clases de caracteres POSIX solo se pueden usar dentro de una clase de caracteres:</target>
        </trans-unit>
        <trans-unit id="c16f46255f2c5b016b34cc67482e93dd7025a2f9" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;a href=&quot;perlvar#%25ENV&quot;&gt;&lt;code&gt;%ENV&lt;/code&gt;&lt;/a&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt;. Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="460ff6781c9a7b0d42e2f096c304dc01b5296e55" translate="yes" xml:space="preserve">
          <source>As implied above, the environment accessed through &lt;code&gt;%ENV&lt;/code&gt; is global, and the convention is that program specific environment variables are of the form &lt;code&gt;Program$Name&lt;/code&gt; . Each filesystem maintains a current directory, and the current filesystem's current directory is the &lt;b&gt;global&lt;/b&gt; current directory. Consequently, sociable programs don't change the current directory but rely on full pathnames, and programs (and Makefiles) cannot assume that they can spawn a child process which can change the current directory without affecting its parent (and everyone else for that matter).</source>
          <target state="translated">Como se indic&amp;oacute; anteriormente, el entorno al que se accede a trav&amp;eacute;s de &lt;code&gt;%ENV&lt;/code&gt; es global, y la convenci&amp;oacute;n es que las variables de entorno espec&amp;iacute;ficas del programa tienen el formato &lt;code&gt;Program$Name&lt;/code&gt; . Cada sistema de archivos mantiene un directorio actual, y el directorio actual del sistema de archivos actual es el directorio actual &lt;b&gt;global&lt;/b&gt; . En consecuencia, los programas sociables no cambian el directorio actual, sino que se basan en nombres de ruta completos, y los programas (y Makefiles) no pueden asumir que pueden generar un proceso hijo que puede cambiar el directorio actual sin afectar a su padre (y a todos los dem&amp;aacute;s) .</target>
        </trans-unit>
        <trans-unit id="9cfe8ec9bce67c19def3a159ea6c0eb1d6dbe31c" translate="yes" xml:space="preserve">
          <source>As in some shells, you can enclose the variable name in braces to disambiguate it from following alphanumerics (and underscores). You must also do this when interpolating a variable into a string to separate the variable name from a following double-colon or an apostrophe, since these would be otherwise treated as a package separator:</source>
          <target state="translated">Como en algunas conchas,puedes encerrar el nombre de la variable entre corchetes para desambiguarla de seguir los alfanuméricos (y los subrayados).También se debe hacer esto cuando se interpola una variable en una cadena para separar el nombre de la variable de un doble punto o un apóstrofe que le sigue,ya que de otro modo se trataría como un separador de paquetes:</target>
        </trans-unit>
        <trans-unit id="f260d12b5b1b7a497f5733dde8f966ff0dea7a60" translate="yes" xml:space="preserve">
          <source>As it stands it predates version.pm but has the same goal: make version strings visible and comparable.</source>
          <target state="translated">En su estado actual es anterior a version.pm pero tiene el mismo objetivo:hacer visibles y comparables las cadenas de la versión.</target>
        </trans-unit>
        <trans-unit id="e22bdaf7af0b55a0257fbf249cc6b2acfdfc9220" translate="yes" xml:space="preserve">
          <source>As its name suggests, if your code tripped a mandatory warning, you would get a warning whether you wanted it or not. For example, the code below would always produce an &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; warning about the &quot;2:&quot;.</source>
          <target state="translated">Como sugiere su nombre, si su c&amp;oacute;digo activ&amp;oacute; una advertencia obligatoria, recibir&amp;iacute;a una advertencia tanto si la deseaba como si no. Por ejemplo, el c&amp;oacute;digo siguiente siempre producir&amp;iacute;a una advertencia &lt;code&gt;&quot;isn't numeric&quot;&lt;/code&gt; sobre el &quot;2:&quot;.</target>
        </trans-unit>
        <trans-unit id="299f8da88c7d33c41fa9b9da7b25493959ed6b3c" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="translated">Como se acaba de mencionar, todas las variables son, por defecto, locales de hilo. Para usar variables compartidas, tambi&amp;eacute;n debe cargar &lt;a href=&quot;threads/shared&quot;&gt;hilos :: shared&lt;/a&gt; :</target>
        </trans-unit>
        <trans-unit id="7273a25ae51ae519b823516d45a11747d27d1f68" translate="yes" xml:space="preserve">
          <source>As just mentioned, all variables are, by default, thread local. To use shared variables, you need to also load &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b2545d2ff62a227583262bedb22954e6e8e3fc3" translate="yes" xml:space="preserve">
          <source>As locks are advisory, they do not prevent data access or modification by another thread that does not itself attempt to obtain a lock on the variable.</source>
          <target state="translated">Como los bloqueos son de carácter consultivo,no impiden el acceso a los datos o la modificación por parte de otro hilo que no intente por sí mismo obtener un bloqueo de la variable.</target>
        </trans-unit>
        <trans-unit id="3b3a54f56722c72f0cfe48a91b285385f9f3fe3e" translate="yes" xml:space="preserve">
          <source>As long as a context exists for a given hub, all tools that try to get a context will get the existing instance. If you try to store the context you will pollute other tools with incorrect context information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ff74ffe73c98f024294d6b4b3ccdb104adb917" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">Siempre que todos los documentos procesados &lt;code&gt;--errors=pod&lt;/code&gt; como resultado alg&amp;uacute;n resultado, incluso si ese resultado incluye erratas (una secci&amp;oacute;n &lt;code&gt;POD ERRORS&lt;/code&gt; ERRORS generada con --errors = pod ), &lt;b&gt;pod2man&lt;/b&gt; saldr&amp;aacute; con el estado 0. Si alguno de los documentos que se est&amp;aacute;n procesando no da como resultado un documento de salida, &lt;b&gt;pod2man&lt;/b&gt; saldr&amp;aacute; con el estado 1. Si hay errores de sintaxis en un documento POD que se est&amp;aacute; procesando y el estilo de manejo de errores se establece en el valor predeterminado de &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;b&gt;pod2man abortar&amp;aacute;&lt;/b&gt; inmediatamente con el estado de salida 255.</target>
        </trans-unit>
        <trans-unit id="00a3a680bcee6a61521d2a5ef5058ff99a76856b" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt; ), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="translated">Siempre que todos los documentos procesados &lt;code&gt;--errors=pod&lt;/code&gt; como resultado alg&amp;uacute;n resultado, incluso si ese resultado incluye erratas (una secci&amp;oacute;n de &lt;code&gt;POD ERRORS&lt;/code&gt; generada con --errors = pod ), &lt;b&gt;pod2text&lt;/b&gt; saldr&amp;aacute; con el estado 0. Si alguno de los documentos que se est&amp;aacute;n procesando no da como resultado un documento de salida, &lt;b&gt;pod2text&lt;/b&gt; saldr&amp;aacute; con el estado 1. Si hay errores de sintaxis en un documento POD que se est&amp;aacute; procesando y el estilo de manejo de errores se establece en el valor predeterminado de &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , &lt;b&gt;pod2text&lt;/b&gt; se cancelar&amp;aacute; inmediatamente con el estado de salida 255.</target>
        </trans-unit>
        <trans-unit id="0269a38b4ec57ba243ba2782b49b270dd9c32426" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2man&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2man&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2man&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03b9b379a8f2df5ad39a7bc04538ebad9bc6c049" translate="yes" xml:space="preserve">
          <source>As long as all documents processed result in some output, even if that output includes errata (a &lt;code&gt;POD ERRORS&lt;/code&gt; section generated with &lt;code&gt;--errors=pod&lt;/code&gt;), &lt;b&gt;pod2text&lt;/b&gt; will exit with status 0. If any of the documents being processed do not result in an output document, &lt;b&gt;pod2text&lt;/b&gt; will exit with status 1. If there are syntax errors in a POD document being processed and the error handling style is set to the default of &lt;code&gt;die&lt;/code&gt;, &lt;b&gt;pod2text&lt;/b&gt; will abort immediately with exit status 255.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89c56046221181f7e1bfa30bafe704cdc7899788" translate="yes" xml:space="preserve">
          <source>As long as the code inside the SKIP block at least compiles. Please don't ask how. No, it's not a filter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95c1aea5304f4de3806c6769617146a8ffc159e5" translate="yes" xml:space="preserve">
          <source>As long as the reference is never returned by any function within the module, no outside module can see the subroutine, because its name is not in any package's symbol table. Remember that it's not</source>
          <target state="translated">Mientras la referencia nunca sea devuelta por ninguna función dentro del módulo,ningún módulo externo puede ver la subrutina,porque su nombre no está en la tabla de símbolos de ningún paquete.Recuerde que no es</target>
        </trans-unit>
        <trans-unit id="9a46642b51b5bbcfbb8a5a0fab6a1a748c3835a7" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2C-Mutators%2C-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt;, and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt;, then the code</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="958bb5f65d2f4962aaa4f5dd2b31857927db841a" translate="yes" xml:space="preserve">
          <source>As mentioned &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;above&lt;/a&gt;, this operation is called when a mutator is applied to a reference that shares its object with some other reference. For example, if &lt;code&gt;$b&lt;/code&gt; is mathemagical, and &lt;code&gt;'++'&lt;/code&gt; is overloaded with &lt;code&gt;'incr'&lt;/code&gt; , and &lt;code&gt;'='&lt;/code&gt; is overloaded with &lt;code&gt;'clone'&lt;/code&gt; , then the code</source>
          <target state="translated">Como se mencion&amp;oacute; &lt;a href=&quot;#Mathemagic%2c-Mutators%2c-and-Copy-Constructors&quot;&gt;anteriormente&lt;/a&gt; , esta operaci&amp;oacute;n se llama cuando se aplica un mutador a una referencia que comparte su objeto con alguna otra referencia. Por ejemplo, si &lt;code&gt;$b&lt;/code&gt; es matem&amp;aacute;tico, y &lt;code&gt;'++'&lt;/code&gt; est&amp;aacute; sobrecargado con &lt;code&gt;'incr'&lt;/code&gt; , y &lt;code&gt;'='&lt;/code&gt; est&amp;aacute; sobrecargado con &lt;code&gt;'clone'&lt;/code&gt; , entonces el c&amp;oacute;digo</target>
        </trans-unit>
        <trans-unit id="4a4d04edd6d111dfba357a91be03d0f8c653a2d2" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;&quot;ALIASES&quot;&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6db309618dd0587d20027a36c5759130977518d4" translate="yes" xml:space="preserve">
          <source>As mentioned above under &lt;a href=&quot;#ALIASES&quot;&gt;ALIASES&lt;/a&gt;, Unicode 6.1 defines extra names (synonyms or aliases) for some code points, most of which were already available as Perl extensions. All these are accepted by &lt;code&gt;\N{...}&lt;/code&gt; and the other functions in this module, but &lt;code&gt;viacode&lt;/code&gt; has to choose which one name to return for a given input code point, so it returns the &quot;best&quot; name. To understand how this works, it is helpful to know more about the Unicode name properties. All code points actually have only a single name, which (starting in Unicode 2.0) can never change once a character has been assigned to the code point. But mistakes have been made in assigning names, for example sometimes a clerical error was made during the publishing of the Standard which caused words to be misspelled, and there was no way to correct those. The Name_Alias property was eventually created to handle these situations. If a name was wrong, a corrected synonym would be published for it, using Name_Alias. &lt;code&gt;viacode&lt;/code&gt; will return that corrected synonym as the &quot;best&quot; name for a code point. (It is even possible, though it hasn't happened yet, that the correction itself will need to be corrected, and so another Name_Alias can be created for that code point; &lt;code&gt;viacode&lt;/code&gt; will return the most recent correction.)</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente en &lt;a href=&quot;#ALIASES&quot;&gt;ALIAS&lt;/a&gt; , Unicode 6.1 define nombres adicionales (sin&amp;oacute;nimos o alias) para algunos puntos de c&amp;oacute;digo, la mayor&amp;iacute;a de los cuales ya estaban disponibles como extensiones Perl. Todos estos son aceptados por &lt;code&gt;\N{...}&lt;/code&gt; y las otras funciones en este m&amp;oacute;dulo, pero &lt;code&gt;viacode&lt;/code&gt; tiene que elegir qu&amp;eacute; nombre devolver para un punto de c&amp;oacute;digo de entrada dado, por lo que devuelve el &quot;mejor&quot; nombre. Para comprender c&amp;oacute;mo funciona esto, es &amp;uacute;til saber m&amp;aacute;s sobre las propiedades de los nombres Unicode. Todos los puntos de c&amp;oacute;digo en realidad tienen un solo nombre, que (a partir de Unicode 2.0) nunca puede cambiar una vez que se ha asignado un car&amp;aacute;cter al punto de c&amp;oacute;digo. Pero se han cometido errores al asignar nombres, por ejemplo, a veces se cometi&amp;oacute; un error administrativo durante la publicaci&amp;oacute;n de la Norma que provoc&amp;oacute; que las palabras se escribieran mal, y no hab&amp;iacute;a forma de corregirlas. La propiedad Name_Alias ​​finalmente se cre&amp;oacute; para manejar estas situaciones. Si un nombre era incorrecto, se publicar&amp;iacute;a un sin&amp;oacute;nimo corregido para &amp;eacute;l, utilizando Name_Alias. &lt;code&gt;viacode&lt;/code&gt; devolver&amp;aacute; ese sin&amp;oacute;nimo corregido como el &quot;mejor&quot; nombre para un punto de c&amp;oacute;digo. (Incluso es posible, aunque a&amp;uacute;n no ha sucedido, que la correcci&amp;oacute;n en s&amp;iacute; deba corregirse y, por lo tanto, se puede crear otro Name_Alias ​​para ese punto de c&amp;oacute;digo; &lt;code&gt;viacode&lt;/code&gt; devolver&amp;aacute; la correcci&amp;oacute;n m&amp;aacute;s reciente).</target>
        </trans-unit>
        <trans-unit id="aa5ef151af9bb6073935edbcfff85b0147b33678" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt; ; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt; . Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt; ) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt; . And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Unicode Encodings in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, UTF-8 usa un n&amp;uacute;mero variable de bytes para almacenar un car&amp;aacute;cter. Los caracteres con valores 0 ... 127 se almacenan en un byte, como el buen ASCII. El car&amp;aacute;cter 128 se almacena como &lt;code&gt;v194.128&lt;/code&gt; ; esto contin&amp;uacute;a hasta el car&amp;aacute;cter 191, que es &lt;code&gt;v194.191&lt;/code&gt; . Ahora nos hemos quedado sin bits (191 es el binario &lt;code&gt;10111111&lt;/code&gt; ), as&amp;iacute; que seguimos adelante; el car&amp;aacute;cter 192 es &lt;code&gt;v195.128&lt;/code&gt; . Y as&amp;iacute; contin&amp;uacute;a, movi&amp;eacute;ndose a tres bytes en el car&amp;aacute;cter 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;Codificaciones Unicode en perlunicode&lt;/a&gt; tiene im&amp;aacute;genes de c&amp;oacute;mo funciona esto.</target>
        </trans-unit>
        <trans-unit id="6394bb5241172d16852f3bd3688b62b5907e9510" translate="yes" xml:space="preserve">
          <source>As mentioned above, UTF-8 uses a variable number of bytes to store a character. Characters with values 0...127 are stored in one byte, just like good ol' ASCII. Character 128 is stored as &lt;code&gt;v194.128&lt;/code&gt;; this continues up to character 191, which is &lt;code&gt;v194.191&lt;/code&gt;. Now we've run out of bits (191 is binary &lt;code&gt;10111111&lt;/code&gt;) so we move on; character 192 is &lt;code&gt;v195.128&lt;/code&gt;. And so it goes on, moving to three bytes at character 2048. &lt;a href=&quot;perlunicode#Unicode-Encodings&quot;&gt;&quot;Unicode Encodings&quot; in perlunicode&lt;/a&gt; has pictures of how this works.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b80f86706a5e778489f2084a741a86389a8e67cd" translate="yes" xml:space="preserve">
          <source>As mentioned above, you can determine the context of the currently executing subroutine in Perl with</source>
          <target state="translated">Como se ha mencionado anteriormente,se puede determinar el contexto de la subrutina que se está ejecutando actualmente en Perl con</target>
        </trans-unit>
        <trans-unit id="00501a67a82ec0513abc29055abfbad02a55f669" translate="yes" xml:space="preserve">
          <source>As mentioned at the top of this document, if you are having problems with these example extensions, you might see if any of these help you.</source>
          <target state="translated">Como se mencionó en la parte superior de este documento,si tienes problemas con estas extensiones de ejemplo,puedes ver si alguna de ellas te ayuda.</target>
        </trans-unit>
        <trans-unit id="2746f2e141da00d82feca97a110b834cca59fd6d" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, Perl can store a number in any one of three formats, but most operators typically understand only one of those formats. When a numeric value is passed as an argument to such an operator, it will be converted to the format understood by the operator.</source>
          <target state="translated">Como se mencionó anteriormente,Perl puede almacenar un número en cualquiera de los tres formatos,pero la mayoría de los operadores normalmente sólo entienden uno de esos formatos.Cuando se pasa un valor numérico como argumento a un operador de ese tipo,se convertirá al formato que entiende el operador.</target>
        </trans-unit>
        <trans-unit id="77154bb24a38474664192f3ea13c3d83da99f57f" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, a &quot;callback&quot; key may be added to the &lt;code&gt;TAP::Parser&lt;/code&gt; constructor. If present, each callback corresponding to a given result type will be called with the result as the argument if the &lt;code&gt;run&lt;/code&gt; method is used. The callback is expected to be a subroutine reference (or anonymous subroutine) which is invoked with the parser result as its argument.</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, se puede agregar una clave de &quot;devoluci&amp;oacute;n de llamada&quot; al constructor &lt;code&gt;TAP::Parser&lt;/code&gt; . Si est&amp;aacute; presente, cada devoluci&amp;oacute;n de llamada correspondiente a un tipo de resultado dado se llamar&amp;aacute; con el resultado como argumento si se utiliza el m&amp;eacute;todo de &lt;code&gt;run&lt;/code&gt; . Se espera que la devoluci&amp;oacute;n de llamada sea una referencia de subrutina (o subrutina an&amp;oacute;nima) que se invoca con el resultado del analizador como argumento.</target>
        </trans-unit>
        <trans-unit id="4ebe40c302b03d332e451ead97b5b34c4f2894b9" translate="yes" xml:space="preserve">
          <source>As mentioned earlier, in the case of the default engines, the &lt;code&gt;pprivate&lt;/code&gt; will be a pointer to a regexp_internal structure which holds the compiled program and any additional data that is private to the regex engine implementation.</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, en el caso de los motores predeterminados, &lt;code&gt;pprivate&lt;/code&gt; ser&amp;aacute; un puntero a una estructura regexp_internal que contiene el programa compilado y cualquier dato adicional que sea privado para la implementaci&amp;oacute;n del motor regex.</target>
        </trans-unit>
        <trans-unit id="05bef95fb25bb75da2eac006c647172d0c563725" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="translated">Como se menciona en &lt;a href=&quot;../encode&quot;&gt;Encode&lt;/a&gt; , las codificaciones se definen (al menos en la implementaci&amp;oacute;n actual) como objetos. La asignaci&amp;oacute;n del nombre de codificaci&amp;oacute;n al objeto se realiza mediante el hash &lt;code&gt;%Encode::Encoding&lt;/code&gt; . Aunque puede manipular directamente este hash, se recomienda encarecidamente utilizar este m&amp;oacute;dulo de clase base y agregar los m&amp;eacute;todos encode () y decode ().</target>
        </trans-unit>
        <trans-unit id="4b732b611600d48e618ee4980714b28a0f9ad12e" translate="yes" xml:space="preserve">
          <source>As mentioned in &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt;, encodings are (in the current implementation at least) defined as objects. The mapping of encoding name to object is via the &lt;code&gt;%Encode::Encoding&lt;/code&gt; hash. Though you can directly manipulate this hash, it is strongly encouraged to use this base class module and add encode() and decode() methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83fbfdaddc2272e65e0714e5d0f69ab35b42f974" translate="yes" xml:space="preserve">
          <source>As mentioned in the previous item, this still doesn't work when using socket I/O between Unix and Macintosh. You'll need to hard code your line terminators, in that case.</source>
          <target state="translated">Como se mencionó en el punto anterior,esto todavía no funciona cuando se usa el socket I/O entre Unix y Macintosh.Necesitarás codificar tus terminadores de línea,en ese caso.</target>
        </trans-unit>
        <trans-unit id="ed52abb82f45ac71a451aad1bb7530a654fe2ad3" translate="yes" xml:space="preserve">
          <source>As mentioned previously, dynamic loading isn't currently available nor is MakeMaker. Both are high-priority items.</source>
          <target state="translated">Como se mencionó anteriormente,la carga dinámica no está disponible actualmente ni tampoco MakeMaker.Ambos son elementos de alta prioridad.</target>
        </trans-unit>
        <trans-unit id="9fbc47f4ab04b1b192086c459c88acf77887350f" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; plus a warning.)</source>
          <target state="translated">Como se mencion&amp;oacute;, la funci&amp;oacute;n devuelve &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si no se conoce ning&amp;uacute;n nombre para el punto de c&amp;oacute;digo. En Unicode, el nombre correcto para estos es la cadena vac&amp;iacute;a, que &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; cadena a. (Si solicita un punto de c&amp;oacute;digo m&amp;aacute;s all&amp;aacute; del m&amp;aacute;ximo legal de Unicode de U + 10FFFF al que no ha asignado un alias, obtendr&amp;aacute; &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; m&amp;aacute;s una advertencia).</target>
        </trans-unit>
        <trans-unit id="3d4ae46619b16556205991103a3ee51a24d3e1e6" translate="yes" xml:space="preserve">
          <source>As mentioned, the function returns &lt;code&gt;undef&lt;/code&gt; if no name is known for the code point. In Unicode the proper name for these is the empty string, which &lt;code&gt;undef&lt;/code&gt; stringifies to. (If you ask for a code point past the legal Unicode maximum of U+10FFFF that you haven't assigned an alias to, you get &lt;code&gt;undef&lt;/code&gt; plus a warning.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651eca43c6e2d73bc740fcae1016d17e36d82316" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;../builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt; .</source>
          <target state="translated">Como la mayor parte del resto de la producci&amp;oacute;n se espera que el flujo de error ser&amp;aacute; creado por &lt;a href=&quot;../builder&quot;&gt;Test :: Constructor&lt;/a&gt; 's &lt;code&gt;diag&lt;/code&gt; funci&amp;oacute;n, &lt;a href=&quot;tester&quot;&gt;Test :: :: Constructor Tester&lt;/a&gt; proporciona una funci&amp;oacute;n de conveniencia &lt;code&gt;test_diag&lt;/code&gt; que se puede utilizar en lugar de &lt;code&gt;test_err&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="77c366c0e7fb4976a90caf137a45b2b3674180a3" translate="yes" xml:space="preserve">
          <source>As most of the remaining expected output to the error stream will be created by &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt;'s &lt;code&gt;diag&lt;/code&gt; function, &lt;a href=&quot;Test::Builder::Tester&quot;&gt;Test::Builder::Tester&lt;/a&gt; provides a convenience function &lt;code&gt;test_diag&lt;/code&gt; that you can use instead of &lt;code&gt;test_err&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e01de119b6c27502755389f5ecb232b0f5fe3f3" translate="yes" xml:space="preserve">
          <source>As much as possible, the version.pm module remains compatible with all current code. However, if your module is using a module that has defined &lt;code&gt;$VERSION&lt;/code&gt; using the version class, there are a couple of things to be aware of. For purposes of discussion, we will assume that we have the following module installed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3938aef953ff6d9fa864efd013ef275f9aaeca4" translate="yes" xml:space="preserve">
          <source>As noted above, if the file does not already exist, then the append-mode open will create it for you. But if the file does already exist, its contents are safe from harm because you will be adding your new text past the end of the old text.</source>
          <target state="translated">Como se ha señalado anteriormente,si el archivo no existe ya,entonces el modo de apéndice abierto lo creará para usted.Pero si el archivo ya existe,su contenido está a salvo de cualquier daño,ya que añadirá su nuevo texto más allá del final del texto antiguo.</target>
        </trans-unit>
        <trans-unit id="a7e52b3ee94a5bcfcbfa100ffa60b7bfdd3a2e7b" translate="yes" xml:space="preserve">
          <source>As noted above, the &lt;code&gt;mark&lt;/code&gt; variable itself will point at the most recently pushed value on the value stack before the list begins, and so the list itself starts at &lt;code&gt;mark + 1&lt;/code&gt;. The values of the list may be iterated by code such as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9988c3a40e007efc46894bc022da2f7d4a303e25" translate="yes" xml:space="preserve">
          <source>As noted above, xV references on the main value stack do not contribute to the reference count of an xV, and so another mechanism is used to track when temporary values which live on the stack must be released. This is the job of the temporaries stack.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa50c7a75f631655fc7d60c7b218e502c8aba3fb" translate="yes" xml:space="preserve">
          <source>As noted earlier in this document, the scalar sense of list assignment is the number of elements on the right-hand side of the assignment. The null list contains no elements, so when the password file is exhausted, the result is 0, not 2.</source>
          <target state="translated">Como se ha señalado anteriormente en el presente documento,el sentido escalar de la asignación de listas es el número de elementos que se encuentran a la derecha de la asignación.La lista nula no contiene ningún elemento,por lo que cuando se agota el archivo de contraseñas,el resultado es 0,no 2.</target>
        </trans-unit>
        <trans-unit id="3e5e8b8f30fce2b639027bd3be7728c79d978675" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;&quot;USING LOCALES&quot;&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;use locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c32dd8a34a2658e1d2e1869aeb4cec0307b6493f" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;#USING-LOCALES&quot;&gt;USING LOCALES&lt;/a&gt;, &lt;code&gt;cmp&lt;/code&gt; compares according to the current collation locale when &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect, but falls back to a char-by-char comparison for strings that the locale says are equal. You can use &lt;code&gt;POSIX::strcoll()&lt;/code&gt; if you don't want this fall-back:</source>
          <target state="translated">Como se indica en &lt;a href=&quot;#USING-LOCALES&quot;&gt;UTILIZAR LOCALES&lt;/a&gt; , &lt;code&gt;cmp&lt;/code&gt; se compara de acuerdo con la configuraci&amp;oacute;n regional de clasificaci&amp;oacute;n actual cuando &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; est&amp;aacute; en vigor, pero recurre a una comparaci&amp;oacute;n de caracteres por caracteres para las cadenas que la configuraci&amp;oacute;n regional dice que son iguales. Puede usar &lt;code&gt;POSIX::strcoll()&lt;/code&gt; si no desea esta alternativa :</target>
        </trans-unit>
        <trans-unit id="39a23dc03cf7dc5e3d6e19189da7b65ab7a30cf2" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;&quot;TESTING&quot; in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eda06429df1073940e96ea523060e042021aeec8" translate="yes" xml:space="preserve">
          <source>As noted in &lt;a href=&quot;perlhack#TESTING&quot;&gt;TESTING in perlhack&lt;/a&gt;, when writing test scripts, the file</source>
          <target state="translated">Como se indica en &lt;a href=&quot;perlhack#TESTING&quot;&gt;PRUEBAS en perlhack&lt;/a&gt; , al escribir scripts de prueba, el archivo</target>
        </trans-unit>
        <trans-unit id="1655e6b218596b71d5606712f426706cfda24e83" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;ExtUtils::Manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="716cc3d3aff35fc6629ccc256677b64774af14df" translate="yes" xml:space="preserve">
          <source>As of 1.37_02 install() supports the use of a list of patterns to filter out files that shouldn't be installed. If $skip is omitted or undefined then install will try to read the list from INSTALL.SKIP in the CWD. This file is a list of regular expressions and is just like the MANIFEST.SKIP file used by &lt;a href=&quot;manifest&quot;&gt;ExtUtils::Manifest&lt;/a&gt;.</source>
          <target state="translated">A partir de 1.37_02 install () admite el uso de una lista de patrones para filtrar los archivos que no deber&amp;iacute;an instalarse. Si $ skip se omite o no est&amp;aacute; definido, install intentar&amp;aacute; leer la lista de INSTALL.SKIP en el CWD. Este archivo es una lista de expresiones regulares y es como el archivo MANIFEST.SKIP utilizado por &lt;a href=&quot;manifest&quot;&gt;ExtUtils :: Manifest&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0f828a6d861469c7d75db52b836c69689c1760b7" translate="yes" xml:space="preserve">
          <source>As of 3.10, the internal data for all types of codes can be modified.</source>
          <target state="translated">A partir del 3.10,los datos internos de todos los tipos de códigos pueden ser modificados.</target>
        </trans-unit>
        <trans-unit id="4f51af2e950bc010c45298268ec1c3013383b233" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;a href=&quot;warnings&quot;&gt;&lt;code&gt;printf&lt;/code&gt;&lt;/a&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d399ef50aa4f86fbc538d8e5d435b672ada57b9" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">A partir de la versi&amp;oacute;n 5.14, ninguno de estos genera una excepci&amp;oacute;n si no son compatibles con su plataforma. Sin embargo, si las advertencias est&amp;aacute;n habilitadas, se emite una advertencia de la clase de advertencia &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; en un indicador de conversi&amp;oacute;n no admitido. Si en cambio prefiere una excepci&amp;oacute;n, haga esto:</target>
        </trans-unit>
        <trans-unit id="fd9213ca43980debccb984d13f9caaa2e79748be" translate="yes" xml:space="preserve">
          <source>As of 5.14, none of these raises an exception if they are not supported on your platform. However, if warnings are enabled, a warning of the &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; warning class is issued on an unsupported conversion flag. Should you instead prefer an exception, do this:</source>
          <target state="translated">A partir de la versi&amp;oacute;n 5.14, ninguno de estos genera una excepci&amp;oacute;n si no son compatibles con su plataforma. Sin embargo, si las advertencias est&amp;aacute;n habilitadas, se emite una advertencia de la clase de advertencia &lt;code&gt;&lt;a href=&quot;printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; en un indicador de conversi&amp;oacute;n no admitido. Si en cambio prefiere una excepci&amp;oacute;n, haga esto:</target>
        </trans-unit>
        <trans-unit id="6791199e3f80fe4bbb43c0eaff9608d527ada74b" translate="yes" xml:space="preserve">
          <source>As of 5.14, that can also be written this way:</source>
          <target state="translated">A partir del 5.14,eso también puede ser escrito de esta manera:</target>
        </trans-unit>
        <trans-unit id="b37d45aa3fafa285df8c8611054589c583244ea5" translate="yes" xml:space="preserve">
          <source>As of 5.19.9 setting &lt;code&gt;$/&lt;/code&gt; to any other form of reference will throw a fatal exception. This is in preparation for supporting new ways to set &lt;code&gt;$/&lt;/code&gt; in the future.</source>
          <target state="translated">A partir de 5.19.9, configurar &lt;code&gt;$/&lt;/code&gt; en cualquier otra forma de referencia arrojar&amp;aacute; una excepci&amp;oacute;n fatal. Esto es una preparaci&amp;oacute;n para admitir nuevas formas de establecer &lt;code&gt;$/&lt;/code&gt; en el futuro.</target>
        </trans-unit>
        <trans-unit id="5090edb4c78c4b281b3a889d093a1c4d0aac43d2" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, long doubles are working if you use the Sun compilers (needed for additional math routines not included in libm).</source>
          <target state="translated">A partir de 5.8.1,los dobles largos funcionan si se utilizan los compiladores Sun (necesarios para rutinas matemáticas adicionales no incluidas en la libm).</target>
        </trans-unit>
        <trans-unit id="f508ee41697726e1567be3f0dd308006b0a11bbd" translate="yes" xml:space="preserve">
          <source>As of 5.8.1, the &lt;b&gt;-C&lt;/b&gt; can be followed either by a number or a list of option letters. The letters, their numeric values, and effects are as follows; listing the letters is equal to summing the numbers.</source>
          <target state="translated">A partir de 5.8.1, la &lt;b&gt;-C&lt;/b&gt; puede ir seguida de un n&amp;uacute;mero o una lista de letras de opci&amp;oacute;n. Las letras, sus valores num&amp;eacute;ricos y efectos son los siguientes; enumerar las letras es igual a sumar los n&amp;uacute;meros.</target>
        </trans-unit>
        <trans-unit id="45cfda1b1b7f6423e5dd7ec6647effcbf0d30173" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="translated">A partir de 5.9.5, la directiva &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; y sus equivalentes tienen un alcance l&amp;eacute;xico, al igual que las otras directivas. Sin embargo, tienen efectos tanto en tiempo de compilaci&amp;oacute;n como en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="d51f5d10f6eede269e073b2d28e8411b4b049f81" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="translated">A partir de 5.9.5, la directiva &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; re 'debug'&lt;/code&gt; y sus equivalentes tienen un alcance l&amp;eacute;xico, al igual que las otras directivas. Sin embargo, tienen efectos tanto en tiempo de compilaci&amp;oacute;n como en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="88f554d7cda5067d9baf3d30fcba8c29b1dbb104" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as are the other directives. However they have both compile-time and run-time effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6609b05c1701ded1ef1eec29d7bb5f4a5b93b02d" translate="yes" xml:space="preserve">
          <source>As of 5.9.5 the directive &lt;code&gt;use re 'debug'&lt;/code&gt; and its equivalents are lexically scoped, as the other directives are. However they have both compile-time and run-time effects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b5a3958e4abf52ef71b991a4f025f997262e7e8" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; can also be a code reference which takes the ordinal value of the unmapped character as an argument and returns octets that represent the fallback character. For instance:</source>
          <target state="translated">A partir de &lt;code&gt;Encode&lt;/code&gt; 2.12, &lt;code&gt;CHECK&lt;/code&gt; tambi&amp;eacute;n puede ser una referencia de c&amp;oacute;digo que toma el valor ordinal del car&amp;aacute;cter no mapeado como argumento y devuelve octetos que representan el car&amp;aacute;cter de reserva. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b411b3efc2bae2399e243c4103628c18af471dad" translate="yes" xml:space="preserve">
          <source>As of &lt;code&gt;Encode&lt;/code&gt; version 2.21, a new method &lt;code&gt;mime_name()&lt;/code&gt; is therefore added.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 2.21 de &lt;code&gt;Encode&lt;/code&gt; , se &lt;code&gt;mime_name()&lt;/code&gt; un nuevo m&amp;eacute;todo mime_name () .</target>
        </trans-unit>
        <trans-unit id="703e152d6b7fb820f5c3dbc21f352bf9bc7a9e95" translate="yes" xml:space="preserve">
          <source>As of CPAN 1.9463, if you do not have permission to write the default perl library directories, CPAN's configuration process will ask you whether you want to bootstrap &amp;lt;local::lib&amp;gt;, which makes keeping a personal perl library directory easy.</source>
          <target state="translated">A partir de CPAN 1.9463, si no tiene permiso para escribir los directorios predeterminados de la biblioteca de Perl, el proceso de configuraci&amp;oacute;n de CPAN le preguntar&amp;aacute; si desea iniciar &amp;lt;local :: lib&amp;gt;, lo que facilita el mantenimiento de un directorio personal de la biblioteca de Perl.</target>
        </trans-unit>
        <trans-unit id="07aaeb2f2c75fecbde3c90f6c2e907a83c502842" translate="yes" xml:space="preserve">
          <source>As of Encode 1.87, the older form</source>
          <target state="translated">A partir del código 1.87,la forma más antigua</target>
        </trans-unit>
        <trans-unit id="b09ae12c2db054fb655cbb26f548a82db4c390c0" translate="yes" xml:space="preserve">
          <source>As of July 2002 (the Perl release 5.8.0), the following platforms were able to build Perl from the standard source code distribution available at &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</source>
          <target state="translated">En julio de 2002 (la versi&amp;oacute;n 5.8.0 de Perl), las siguientes plataformas pudieron compilar Perl a partir de la distribuci&amp;oacute;n de c&amp;oacute;digo fuente est&amp;aacute;ndar disponible en &lt;a href=&quot;http://www.cpan.org/src/&quot;&gt;http://www.cpan.org/src/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="fcab0673d5c88e7554da234165f977684b228be3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="translated">A partir de Perl 5.10, se pueden usar las variables &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; y &lt;code&gt;${^POSTMATCH}&lt;/code&gt; . Estos solo se establecen si el modificador &lt;code&gt;/p&lt;/code&gt; est&amp;aacute; presente. En consecuencia, no penalizan el resto del programa. En Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt; , &lt;code&gt;${^MATCH}&lt;/code&gt; y &lt;code&gt;${^POSTMATCH}&lt;/code&gt; est&amp;aacute;n disponibles tanto si se ha utilizado &lt;code&gt;/p&lt;/code&gt; como si no (el modificador se ignora), y &lt;code&gt;$`&lt;/code&gt; , &lt;code&gt;$'&lt;/code&gt; y &lt;code&gt;$&amp;amp;&lt;/code&gt; no causar cualquier diferencia de velocidad.</target>
        </trans-unit>
        <trans-unit id="e79e99fb499b4f259d0eaa53033cd09b0a52555d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, the &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; variables may be used. These are only set if the &lt;code&gt;/p&lt;/code&gt; modifier is present. Consequently they do not penalize the rest of the program. In Perl 5.20, &lt;code&gt;${^PREMATCH}&lt;/code&gt;, &lt;code&gt;${^MATCH}&lt;/code&gt; and &lt;code&gt;${^POSTMATCH}&lt;/code&gt; are available whether the &lt;code&gt;/p&lt;/code&gt; has been used or not (the modifier is ignored), and &lt;code&gt;$`&lt;/code&gt;, &lt;code&gt;$'&lt;/code&gt; and &lt;code&gt;$&amp;amp;&lt;/code&gt; do not cause any speed difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eafa84154e8f8c3596803a7b5e3904a497adc460" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; to change the behaviour:</source>
          <target state="translated">A partir de Perl 5.10, este pragma tiene un &amp;aacute;mbito l&amp;eacute;xico y entra en vigor en tiempo de compilaci&amp;oacute;n. En versiones anteriores, su efecto era global y ten&amp;iacute;a efecto en tiempo de ejecuci&amp;oacute;n; la documentaci&amp;oacute;n sugiri&amp;oacute; usar &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval()&lt;/a&gt;&lt;/code&gt; para cambiar el comportamiento:</target>
        </trans-unit>
        <trans-unit id="331b4594e4263cc88f44953b4d0b8305968e3f99" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, this pragma is lexically scoped and takes effect at compile time. In earlier versions its effect was global and took effect at run-time; the documentation suggested using &lt;code&gt;eval()&lt;/code&gt; to change the behaviour:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="86d4d0145ccce27050aa6a59ab5275c8b3a0cdb0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10, you can match balanced text with regular expressions using recursive patterns. Before Perl 5.10, you had to resort to various tricks such as using Perl code in &lt;code&gt;(??{})&lt;/code&gt; sequences.</source>
          <target state="translated">A partir de Perl 5.10, puede hacer coincidir texto equilibrado con expresiones regulares utilizando patrones recursivos. Antes de Perl 5.10, ten&amp;iacute;a que recurrir a varios trucos, como usar c&amp;oacute;digo Perl en secuencias &lt;code&gt;(??{})&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eea5149372feb11e1db38e07d50576f276a6c743" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, Perl supports several Python/PCRE-specific extensions to the regex syntax. While Perl programmers are encouraged to use the Perl-specific syntax, the following are also accepted:</source>
          <target state="translated">A partir de Perl 5.10.0,Perl soporta varias extensiones específicas de Python/PCRE para la sintaxis regex.Aunque se anima a los programadores de Perl a utilizar la sintaxis específica de Perl,también se aceptan las siguientes:</target>
        </trans-unit>
        <trans-unit id="793e424fe5bef6967b0c0b6751f2a3b12bcf501f" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="translated">A partir de Perl 5.10.0, como una forma de az&amp;uacute;car puramente sint&amp;aacute;ctica, puede apilar operadores de prueba de archivos, de manera que &lt;code&gt;-f -w -x $file&lt;/code&gt; sea ​​equivalente a &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt; . (Esta es solo una sintaxis elegante: si usa el valor de retorno de &lt;code&gt;-f $file&lt;/code&gt; como argumento para otro operador de prueba de archivos, no ocurrir&amp;aacute; ninguna magia especial).</target>
        </trans-unit>
        <trans-unit id="03db908cbb1531eee3e0f01a16bb3f1d5ad12f15" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, as a form of purely syntactic sugar, you can stack file test operators, in a way that &lt;code&gt;-f -w -x $file&lt;/code&gt; is equivalent to &lt;code&gt;-x $file &amp;amp;&amp;amp; -w _ &amp;amp;&amp;amp; -f _&lt;/code&gt;. (This is only fancy syntax: if you use the return value of &lt;code&gt;-f $file&lt;/code&gt; as an argument to another filetest operator, no special magic will happen.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4eb7e07d934fae953d19f8161458d55420e41446" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, one can create custom regular expression engines. This is not for the faint of heart, as they have to plug in at the C level. See &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; for more details.</source>
          <target state="translated">A partir de Perl 5.10.0, se pueden crear motores de expresiones regulares personalizados. Esto no es para los d&amp;eacute;biles de coraz&amp;oacute;n, ya que tienen que conectarse al nivel C. Consulte &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="0c7a09399a8f27b12757a6f71f279fa17b42fdfd" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.0, you can also use the &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers to force big- or little-endian byte-order. This is useful if you want to store signed integers or 64-bit integers, for example.</source>
          <target state="translated">A partir de Perl 5.10.0, tambi&amp;eacute;n puede usar los modificadores &lt;code&gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;lt;&lt;/code&gt; para forzar el orden de bytes de endian grande o peque&amp;ntilde;o. Esto es &amp;uacute;til si desea almacenar enteros con signo o enteros de 64 bits, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="835734cf27f076a5a1e9340fb76782ceeb1a149b" translate="yes" xml:space="preserve">
          <source>As of Perl 5.10.1 there is a new interface for plugging and using method resolution orders other than the default (linear depth first search). The C3 method resolution order added in 5.10.0 has been re-implemented as a plugin, without changing its Perl-space interface.</source>
          <target state="translated">A partir de Perl 5.10.1 hay una nueva interfaz para conectar y utilizar órdenes de resolución de métodos distintos a los predeterminados (búsqueda de profundidad lineal primero).El orden de resolución de métodos C3 añadido en 5.10.0 ha sido reimplementado como un plugin,sin cambiar su interfaz de Perl-espacio.</target>
        </trans-unit>
        <trans-unit id="ec3d8a5f4531571b478743636520cd49e4ac13cb" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;a href=&quot;#readdir-DIRHANDLE&quot;&gt;&lt;code&gt;readdir&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either a &lt;code&gt;readdir&lt;/code&gt; expression or an explicit assignment of a &lt;code&gt;readdir&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ca2607d4b8da91c9aab14d61ac0b65b288bfff7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">A partir de Perl 5.12 se puede utilizar un desnudo &lt;code&gt;&lt;a href=&quot;functions/readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; en un &lt;code&gt;while&lt;/code&gt; de bucle, que establecer&amp;aacute; &lt;code&gt;$_&lt;/code&gt; en cada iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7ef4b7baf6bbb1a8636644643a30ec84c9a4f514" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12 you can use a bare &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">A partir de Perl 5.12 se puede utilizar un desnudo &lt;code&gt;&lt;a href=&quot;readdir&quot;&gt;readdir&lt;/a&gt;&lt;/code&gt; en un &lt;code&gt;while&lt;/code&gt; de bucle, que establecer&amp;aacute; &lt;code&gt;$_&lt;/code&gt; en cada iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9aad368f35112b0ebb60af7e4b6035d03ee10832" translate="yes" xml:space="preserve">
          <source>As of Perl 5.12, deprecated features and modules warn the user as they're used. When a module is deprecated, it will also be made available on CPAN. Installing it from CPAN will silence deprecation warnings for that module.</source>
          <target state="translated">A partir de Perl 5.12,las características y módulos obsoletos advierten al usuario cuando se utilizan.Cuando un módulo está desaprobado,también estará disponible en el CPAN.Al instalarlo desde el CPAN se silenciarán las advertencias de depreciación de ese módulo.</target>
        </trans-unit>
        <trans-unit id="7bc75da6cf8214f9a49a145ca7f1ff6dd1976a38" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 every hash has its own hash traversal order, and this order changes every time a new element is inserted into the hash. This functionality is provided by maintaining an unsigned integer mask (U32) which is xor'ed with the actual bucket id during a traversal of the hash buckets using keys(), values() or each().</source>
          <target state="translated">A partir de Perl 5.18 cada hachís tiene su propio orden transversal de hachís,y este orden cambia cada vez que se inserta un nuevo elemento en el hachís.Esta funcionalidad se proporciona manteniendo una máscara de entero sin signo (U32)que se xorifica con la identificación real del cubo durante una travesía de los cubos de hash usando keys(),values()o each().</target>
        </trans-unit>
        <trans-unit id="52e65492e2356da13376652cd3b63537c008c53e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;a href=&quot;#each-HASH&quot;&gt;&lt;code&gt;each&lt;/code&gt;&lt;/a&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;a href=&quot;perlvar#%24_&quot;&gt;&lt;code&gt;$_&lt;/code&gt;&lt;/a&gt; on every iteration. If either an &lt;code&gt;each&lt;/code&gt; expression or an explicit assignment of an &lt;code&gt;each&lt;/code&gt; expression to a scalar is used as a &lt;code&gt;while&lt;/code&gt;/&lt;code&gt;for&lt;/code&gt; condition, then the condition actually tests for definedness of the expression's value, not for its regular truth value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8b875400d906734f1b4f9f29eb27503d8a35f16" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">A partir de Perl 5.18 se puede utilizar una dio a luz &lt;code&gt;&lt;a href=&quot;each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; en un &lt;code&gt;while&lt;/code&gt; de bucle, que establecer&amp;aacute; &lt;code&gt;$_&lt;/code&gt; en cada iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="211e0f721f82a57a3e303b9bd4a37e7c878adb86" translate="yes" xml:space="preserve">
          <source>As of Perl 5.18 you can use a bare &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; in a &lt;code&gt;while&lt;/code&gt; loop, which will set &lt;code&gt;$_&lt;/code&gt; on every iteration.</source>
          <target state="translated">A partir de Perl 5.18 se puede utilizar una dio a luz &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; en un &lt;code&gt;while&lt;/code&gt; de bucle, que establecer&amp;aacute; &lt;code&gt;$_&lt;/code&gt; en cada iteraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c33c32e4c4b133822c39af8f8540bc2360a9b3e1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="translated">A partir de Perl 5.20, en lugar de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings FATAL =&amp;gt; 'all';&lt;/code&gt; puedes usar:</target>
        </trans-unit>
        <trans-unit id="9ee11b59ca6b84291fdd57fa90c4a5348d5dae02" translate="yes" xml:space="preserve">
          <source>As of Perl 5.20, instead of &lt;code&gt;use warnings FATAL =&amp;gt; 'all';&lt;/code&gt; you can use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35a63f8082ff3fbb7b2bded313d23f6fdc3cfd9" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; . (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Assigning to References in perlref&lt;/a&gt;.)</source>
          <target state="translated">A partir de Perl 5.22, existe una variante experimental de este bucle que acepta una variable precedida por una barra invertida para VAR, en cuyo caso los elementos de LIST deben ser referencias. La variable con barra invertida se convertir&amp;aacute; en un alias para cada elemento referenciado en la LISTA, que debe ser del tipo correcto. La variable no necesita ser un escalar en este caso, y la barra invertida puede ir seguida de &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; . Para utilizar este formulario, debe habilitar la funci&amp;oacute;n de &lt;code&gt;refaliasing&lt;/code&gt; mediante la &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; . (Ver &lt;a href=&quot;feature&quot;&gt;caracter&amp;iacute;stica&lt;/a&gt; . Ver tambi&amp;eacute;n &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;Asignaci&amp;oacute;n a referencias en perlref&lt;/a&gt; .)</target>
        </trans-unit>
        <trans-unit id="4cc3a1608477d241ae1d9f45daf77429c175f625" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, there is an experimental variant of this loop that accepts a variable preceded by a backslash for VAR, in which case the items in the LIST must be references. The backslashed variable will become an alias to each referenced item in the LIST, which must be of the correct type. The variable needn't be a scalar in this case, and the backslash may be followed by &lt;code&gt;my&lt;/code&gt;. To use this form, you must enable the &lt;code&gt;refaliasing&lt;/code&gt; feature via &lt;code&gt;use feature&lt;/code&gt;. (See &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;. See also &lt;a href=&quot;perlref#Assigning-to-References&quot;&gt;&quot;Assigning to References&quot; in perlref&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df42579e1cb5e3f110d0c1cf4c3bbc08eda67128" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, this buggy behavior, while preserved for backward compatibility, is detected and emits a deprecation warning. If you want the subroutine to be inlined (with no warning), make sure the variable is not used in a context where it could be modified aside from where it is declared.</source>
          <target state="translated">A partir de Perl 5.22,este comportamiento de los bichos,aunque preservado para la compatibilidad con el pasado,se detecta y emite una advertencia de depreciación.Si quiere que la subrutina esté en línea (sin advertencia),asegúrese de que la variable no se utilice en un contexto en el que pueda ser modificada aparte de donde se declara.</target>
        </trans-unit>
        <trans-unit id="b18e8f64ae6fd8a43ee4372bec94f73e67d74058" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; instead of &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (You can also do &lt;code&gt;($x) x 2&lt;/code&gt; , which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="translated">A partir de Perl 5.22, tambi&amp;eacute;n puede usar &lt;code&gt;(&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;)x2&lt;/code&gt; en lugar de &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;, &lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . (Tambi&amp;eacute;n puede hacer &lt;code&gt;($x) x 2&lt;/code&gt; , que es menos &amp;uacute;til, porque asigna a la misma variable dos veces, superando el primer valor asignado).</target>
        </trans-unit>
        <trans-unit id="adc72631156437f156fe787062790a9076462201" translate="yes" xml:space="preserve">
          <source>As of Perl 5.22, you can also use &lt;code&gt;(undef)x2&lt;/code&gt; instead of &lt;code&gt;undef, undef&lt;/code&gt;. (You can also do &lt;code&gt;($x) x 2&lt;/code&gt;, which is less useful, because it assigns to the same variable twice, clobbering the first value assigned.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="485dbe5ed6cb5d47f12b9abb8eb25ef72fc078a7" translate="yes" xml:space="preserve">
          <source>As of Perl 5.24, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::postderef&lt;/code&gt; warning category still exists (for compatibility with code that disables it).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="795c67df489058534540e8b295b838da24c8850d" translate="yes" xml:space="preserve">
          <source>As of Perl 5.25 the return was changed to be the count of keys in the hash. If you need access to the old behavior you can use &lt;code&gt;Hash::Util::bucket_ratio()&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a4dc26e9cc8e6190d88b95c93b52fd5320659be" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, the list-context range operator on strings works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: its behavior depends on the internal encoding of the range endpoint.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8155f16a3b816f25d3b7bda9eaf9e783e3bae93" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26, use of this feature no longer triggers a warning, though the &lt;code&gt;experimental::lexical_subs&lt;/code&gt; warning category still exists (for compatibility with code that disables it). In addition, this syntax is not only no longer experimental, but it is enabled for all Perl code, regardless of what feature declarations are in scope.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="644c2bcdf8b193d872fddb3b64677c202b8cacc1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.26.0, this module has no effect. The internal Perl feature that was used to implement this module has been removed. In recent years, much work has been done on the Perl core to eliminate discrepancies in the treatment of upgraded versus downgraded strings. In addition, the &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; pragma, which caused many of the problems, is no longer supported. Thus, the warnings this module produced are no longer necessary.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c1154c7dc017ae8cf6bc262f38694d16778c8f10" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, setting &lt;code&gt;$/&lt;/code&gt; to a reference of a non-positive integer throws a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="097112fced1ea44933320d3c2e627da3a57d8e96" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, these attributes are syntax errors. Since the attributes do not do anything, removing them from your code fixes the syntax error; and removing them will not influence the behaviour of your code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4698cfe65801c463a3e671c9cf65833d68ff49ae" translate="yes" xml:space="preserve">
          <source>As of Perl 5.28, this special-cased whitespace splitting works as expected in the scope of &lt;a href=&quot;feature#The-%27unicode_strings%27-feature&quot;&gt;&lt;code&gt;&quot;use feature 'unicode_strings&quot;&lt;/code&gt;&lt;/a&gt;. In previous versions, and outside the scope of that feature, it exhibits &lt;a href=&quot;perlunicode#The-%22Unicode-Bug%22&quot;&gt;&quot;The &quot;Unicode Bug&quot;&quot; in perlunicode&lt;/a&gt;: characters that are whitespace according to Unicode rules but not according to ASCII rules can be treated as part of fields rather than as field separators, depending on the string's internal encoding.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df44a28f7cb4ce868d57f8dd07bcda2680ebf3e0" translate="yes" xml:space="preserve">
          <source>As of Perl 5.30, use of delimiters which are non-standalone graphemes is fatal, in order to move the language to be able to accept multi-character graphemes as delimiters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3dcb750cd92914748543d04c418a1857ae25be47" translate="yes" xml:space="preserve">
          <source>As of Perl 5.32, this message is no longer generated. Instead, see &lt;a href=&quot;#Non-octal-character-%27%25c%27-terminates-%5Co-early.-Resolved-as-%22%25s%22&quot;&gt;&quot;Non-octal character '%c' terminates \o early. Resolved as &quot;%s&quot;&quot;&lt;/a&gt;. (W misc, regexp) You wrote something like &lt;code&gt;\08&lt;/code&gt;, or &lt;code&gt;\179&lt;/code&gt; in a double-quotish string. All but the last digit is treated as a single character, specified in octal. The last digit is the next character in the string. To tell Perl that this is indeed what you want, you can use the &lt;code&gt;\o{ }&lt;/code&gt; syntax, or use exactly three digits to specify the octal for the character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f3aa7e1697ed4bbe63edb4cde5bc634c7d4943e" translate="yes" xml:space="preserve">
          <source>As of Perl 5.6, you can represent filehandles with scalar variables which you treat as any other scalar.</source>
          <target state="translated">A partir de Perl 5.6,puedes representar mangos de archivos con variables escalares que tratas como cualquier otro escalar.</target>
        </trans-unit>
        <trans-unit id="90e7536680dcd18ada661ef157609a74a6cebee3" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0 after using this module you cannot use the implicit &lt;code&gt;$_&lt;/code&gt; or the special filehandle &lt;code&gt;_&lt;/code&gt; with stat() or lstat(), trying to do so leads into strange errors. The workaround is for &lt;code&gt;$_&lt;/code&gt; to be explicit</source>
          <target state="translated">A partir de Perl 5.8.0, despu&amp;eacute;s de usar este m&amp;oacute;dulo, no puede usar el &lt;code&gt;$_&lt;/code&gt; impl&amp;iacute;cito o el identificador de archivo especial &lt;code&gt;_&lt;/code&gt; con stat () o lstat (), intentar hacerlo conduce a errores extra&amp;ntilde;os. La soluci&amp;oacute;n alternativa es que &lt;code&gt;$_&lt;/code&gt; sea ​​expl&amp;iacute;cito</target>
        </trans-unit>
        <trans-unit id="115a406a7271cc4332af7b8bb93f168d625583f1" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, at least the following encodings are recognized. Note that unless otherwise specified, they are all case insensitive (via alias) and all occurrence of spaces are replaced with '-'. In other words, &quot;ISO 8859 1&quot; and &quot;iso-8859-1&quot; are identical.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fd0a9a99a09c2a713ff60adbdf886450b68308c" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, the &quot;Full&quot; case-folding of</source>
          <target state="translated">A partir de Perl 5.8.0,el caso &quot;completo&quot; de</target>
        </trans-unit>
        <trans-unit id="444326d8d5a5982dc22e2a52147d982ac07eb8e8" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt;, no shell escapes happen.</source>
          <target state="translated">A partir de Perl 5.8.0, puede usar &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; con m&amp;uacute;ltiples argumentos. Al igual que las formas de lista de &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; , no se producen escapes de shell.</target>
        </trans-unit>
        <trans-unit id="df8794a0813798e6a0cf5a13a0dc7223a79a0992" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.0, you can use &lt;code&gt;open()&lt;/code&gt; with multiple arguments. Just like the list forms of &lt;code&gt;system()&lt;/code&gt; and &lt;code&gt;exec()&lt;/code&gt;, no shell escapes happen.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a68a3c591a49e26bfd6e1872f3f7a653d522ef71" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1 the dynamic loading of libraries (DynaLoader, XSLoader) also seems to have become broken in in SunOS 4.x. Therefore the default is to build Perl statically.</source>
          <target state="translated">A partir de Perl 5.8.1 la carga dinámica de las librerías (DynaLoader,XSLoader)también parece haberse roto en SunOS 4.x.Por lo tanto,el valor por defecto es construir Perl estáticamente.</target>
        </trans-unit>
        <trans-unit id="ef5cb6c37e267f59227533f0250c84c8718b7076" translate="yes" xml:space="preserve">
          <source>As of Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; also has the &lt;code&gt;utf8::is_utf8&lt;/code&gt; function.</source>
          <target state="translated">A partir de Perl 5.8.1, &lt;a href=&quot;utf8&quot;&gt;utf8&lt;/a&gt; tambi&amp;eacute;n tiene la funci&amp;oacute;n &lt;code&gt;utf8::is_utf8&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ab205322181f94cdf41d5eaaf572850bb63def33" translate="yes" xml:space="preserve">
          <source>As of Perl 5.9.5 there is a new interface for plugging and using regular expression engines other than the default one.</source>
          <target state="translated">A partir de Perl 5.9.5 hay una nueva interfaz para enchufar y usar motores de expresión regular distintos del predeterminado.</target>
        </trans-unit>
        <trans-unit id="02c3c3ae5c3a1698c2091dbb44ff1c48ff7a71dd" translate="yes" xml:space="preserve">
          <source>As of Perl Symbian port version 0.4.1 any part of Perl's standard regression test suite has not been run on a real Symbian device using the ported Perl, so innumerable bugs may lie in wait. Therefore there is absolutely no warranty.</source>
          <target state="translated">A partir de la versión 0.4.1 del puerto Perl Symbian,cualquier parte del conjunto de pruebas de regresión estándar de Perl no se ha ejecutado en un dispositivo Symbian real utilizando el Perl portado,por lo que pueden existir innumerables errores.Por lo tanto,no hay ninguna garantía.</target>
        </trans-unit>
        <trans-unit id="470b823d90414a4ffaec0c54908966f5bb0b6779" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a7301a461e47b0be61be125749323ecdfc5a92a" translate="yes" xml:space="preserve">
          <source>As of Perl v5.16.0, it is implemented by the &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; module. See &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; for more details on its behaviour.</source>
          <target state="translated">A partir de Perl v5.16.0, est&amp;aacute; implementado por el m&amp;oacute;dulo &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; . Consulte &lt;a href=&quot;arybase&quot;&gt;arybase&lt;/a&gt; para obtener m&amp;aacute;s detalles sobre su comportamiento.</target>
        </trans-unit>
        <trans-unit id="0cf84017310ef88efe853e952dd2c6c52ce61386" translate="yes" xml:space="preserve">
          <source>As of Perl v5.30.0, or under &lt;code&gt;use v5.16&lt;/code&gt;, or &lt;code&gt;no feature &quot;array_base&quot;&lt;/code&gt;, &lt;code&gt;$[&lt;/code&gt; no longer has any effect, and always contains 0. Assigning 0 to it is permitted, but any other value will produce an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f7c19e511eae81348e03d06d3194e0d82d15184" translate="yes" xml:space="preserve">
          <source>As of R2.5 of USS for OS/390 and Version 2.3 of VM/ESA these Unix sub-systems do not support the &lt;code&gt;#!&lt;/code&gt; shebang trick for script invocation. Hence, on OS/390 and VM/ESA Perl scripts can be executed with a header similar to the following simple script:</source>
          <target state="translated">A partir de R2.5 de USS para OS / 390 y la versi&amp;oacute;n 2.3 de VM / ESA, estos subsistemas Unix no admiten el c&amp;oacute;digo &lt;code&gt;#!&lt;/code&gt; truco shebang para invocaci&amp;oacute;n de script. Por lo tanto, en OS / 390 y VM / ESA, los scripts Perl se pueden ejecutar con un encabezado similar al siguiente script simple:</target>
        </trans-unit>
        <trans-unit id="4e29546f04e5cfe2122e46676161bb58e8a9f171" translate="yes" xml:space="preserve">
          <source>As of Unicode 6.0, this is always empty.</source>
          <target state="translated">A partir de Unicode 6.0,esto siempre está vacío.</target>
        </trans-unit>
        <trans-unit id="6be62dadd6bbd6b8a9fe9bd5f460bd2ea3dfc014" translate="yes" xml:space="preserve">
          <source>As of VERSION 1.18 all IO::Socket objects have autoflush turned on by default. This was not the case with earlier releases.</source>
          <target state="translated">A partir de la versión 1.18 todos los objetos IO::Socket tienen activado el autoflush por defecto.Este no era el caso con las versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="9b18b6d1424b74e3d0360d9f0334585a766708d3" translate="yes" xml:space="preserve">
          <source>As of db-4.2.x it is no longer needed to do this by hand. Sleepycat has changed the configuration process to add +z on HP-UX automatically.</source>
          <target state="translated">A partir de db-4.2.x ya no es necesario hacerlo a mano.Sleepycat ha cambiado el proceso de configuración para añadir +z en el HP-UX automáticamente.</target>
        </trans-unit>
        <trans-unit id="d75d887c21a8a54a73e586867619f60f35cac751" translate="yes" xml:space="preserve">
          <source>As of libcrypt 1.3 (March 2016), you will need to install the libcrypt-devel package for Configure to detect crypt().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddb5b154eee158ecabd0abbac4ff1eab5e92e45f" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . This is used like this:</source>
          <target state="translated">A partir de perl 5.14 es posible conectarse al mecanismo de alcance l&amp;eacute;xico en tiempo de compilaci&amp;oacute;n usando &lt;code&gt;Perl_blockhook_register&lt;/code&gt; . Esto se usa as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="ad95286c36cd410295b8a2ce1cb7201a227c4aba" translate="yes" xml:space="preserve">
          <source>As of perl 5.14 it is possible to hook into the compile-time lexical scope mechanism using &lt;code&gt;Perl_blockhook_register&lt;/code&gt;. This is used like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="11e27b1acb1512cd132ffd47cefd52584149d78c" translate="yes" xml:space="preserve">
          <source>As of perl 5.25 this function is used only for debugging purposes, and the number of used hash buckets is not in any way cached, thus this function can be costly to execute as it must iterate over all the buckets in the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="283446be77b5c5650a7aade52dfb5d3e56c4e299" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5 're' debug contains a number of utility functions that may be optionally exported into the caller's namespace. They are listed below.</source>
          <target state="translated">A partir de perl 5.9.5 're' debug contiene una serie de funciones de utilidad que pueden exportarse opcionalmente al espacio de nombres del llamante.Se enumeran a continuación.</target>
        </trans-unit>
        <trans-unit id="e452fc188847c39d477f7724ca763c55646692fe" translate="yes" xml:space="preserve">
          <source>As of perl 5.9.5/Win32 0.27, these functions have been moved into the Win32 module. Win32CORE provides stubs for each of the former CORE Win32:: functions that internally just load the Win32 module and call it's version, and Win32CORE is statically linked to perl for both cygwin and regular win32 builds. This will permit these functions to be updated in the CPAN Win32 module independently of updating perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5916c6705e19aa4737c1eaecb1fdda26e7395e63" translate="yes" xml:space="preserve">
          <source>As of perl5.6, open() autovivifies file and directory handles as references if you pass it an uninitialized scalar variable. You can then pass these references just like any other scalar, and use them in the place of named handles.</source>
          <target state="translated">A partir de perl5.6,open()autovivenifica los archivos y manejos de directorios como referencias si le pasas una variable escalar no inicializada.Puedes entonces pasar estas referencias como cualquier otro escalar,y usarlas en lugar de los &quot;handles&quot; nombrados.</target>
        </trans-unit>
        <trans-unit id="0d06e02fdc69f862d76b045e6be72fc487c78e0b" translate="yes" xml:space="preserve">
          <source>As of perl5.7.2 all tests pass under:</source>
          <target state="translated">A partir del perl5.7.2 todas las pruebas pasan por debajo:</target>
        </trans-unit>
        <trans-unit id="e7ebc726132cf88aa72c90598602d1b0ee48a664" translate="yes" xml:space="preserve">
          <source>As of perl5.8.1 there is at least one test still failing.</source>
          <target state="translated">A partir del perl5.8.1 hay al menos una prueba que sigue fallando.</target>
        </trans-unit>
        <trans-unit id="1b82fd373dbd0883f99d276e806ca9d5f0a6e144" translate="yes" xml:space="preserve">
          <source>As of release 5 of Perl, assignment to &lt;code&gt;$[&lt;/code&gt; is treated as a compiler directive, and cannot influence the behavior of any other file. (That's why you can only assign compile-time constants to it.) Its use is highly discouraged.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 5 de Perl, la asignaci&amp;oacute;n a &lt;code&gt;$[&lt;/code&gt; se trata como una directiva del compilador y no puede influir en el comportamiento de ning&amp;uacute;n otro archivo. (Es por eso que solo puede asignarle constantes en tiempo de compilaci&amp;oacute;n). Se desaconseja su uso.</target>
        </trans-unit>
        <trans-unit id="1e2bbc98f0506e501d121cbf3463e0bb77e718b4" translate="yes" xml:space="preserve">
          <source>As of release 5.003_01 perl is linked to multithreaded C RTL DLL. If perl itself is not compiled multithread-enabled, so will not be perl's malloc(). However, extensions may use multiple thread on their own risk.</source>
          <target state="translated">A partir de la versión 5.003_01 el perl está vinculado a la DLL RTL multihilo C.Si el propio perl no está compilado con multihilo,no será el malloc()de perl.Sin embargo,las extensiones pueden usar múltiples hilos por su cuenta y riesgo.</target>
        </trans-unit>
        <trans-unit id="5dbdb753a9581b45c8e16e8caa7ad1fc9cd73184" translate="yes" xml:space="preserve">
          <source>As of right now, this returns 2 if the path is absolute with a volume, 1 if it's absolute with no volume, 0 otherwise.</source>
          <target state="translated">A partir de ahora,esto devuelve 2 si el camino es absoluto con un volumen,1 si es absoluto sin volumen,0 en caso contrario.</target>
        </trans-unit>
        <trans-unit id="cedde28f0889c00006609cd1f4e0ab992b6b315c" translate="yes" xml:space="preserve">
          <source>As of the date of this document's last update, the following systems contain PA-RISC 2.0 chips:</source>
          <target state="translated">A la fecha de la última actualización de este documento,los siguientes sistemas contienen chips PA-RISC 2.0:</target>
        </trans-unit>
        <trans-unit id="361f300829fa013b44d60226e2c65866392ff21f" translate="yes" xml:space="preserve">
          <source>As of the date of this document, Perl is fully 64-bit compliant on HP-UX 11.00 and up for both cc- and gcc builds. If you are about to build a 64-bit perl with GNU gcc, please read the gcc section carefully.</source>
          <target state="translated">A partir de la fecha de este documento,Perl es totalmente compatible con los 64 bits en HP-UX 11.00 y más para las versiones cc y gcc.Si está a punto de construir un perl de 64 bits con GNU gcc,por favor lea la sección de gcc cuidadosamente.</target>
        </trans-unit>
        <trans-unit id="6087654ae9665e2974920201f81ba084c4838564" translate="yes" xml:space="preserve">
          <source>As of the time this document was last revised, the following Perl functions were implemented in the VMS port of Perl (functions marked with * are discussed in more detail below):</source>
          <target state="translated">En el momento en que se revisó este documento por última vez,se implementaron las siguientes funciones Perl en el puerto VMS de Perl (las funciones marcadas con*se examinan con más detalle a continuación):</target>
        </trans-unit>
        <trans-unit id="4d788164927e274de517225973608d97db84fe9f" translate="yes" xml:space="preserve">
          <source>As of this writing, any encoding whose class belongs to Encode::XS and Encode::Unicode works. The Encode module has a &lt;code&gt;perlio_ok&lt;/code&gt; method which you can use before applying PerlIO encoding to the filehandle. Here is an example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f434753b82171852395258695f5260796bd3e54" translate="yes" xml:space="preserve">
          <source>As of v5.14, Perl distinguishes three subclasses of UTF‑8 warnings.</source>
          <target state="translated">A partir del v5.14,Perl distingue tres subclases de advertencias UTF-8.</target>
        </trans-unit>
        <trans-unit id="3687eac7ed0d3e9a3819b6d8b59ffbbce6f96ce7" translate="yes" xml:space="preserve">
          <source>As of v5.18.0, both keys and values stored in &lt;code&gt;%ENV&lt;/code&gt; are stringified.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 5.18.0, tanto las claves como los valores almacenados en &lt;code&gt;%ENV&lt;/code&gt; est&amp;aacute;n clasificados.</target>
        </trans-unit>
        <trans-unit id="068ae70c04574cc37cc34db842b7ac8d0c145fb6" translate="yes" xml:space="preserve">
          <source>As of version 1.01 of the AutoSplit module it is possible to have multiple packages within a single file. Both of the following cases are supported:</source>
          <target state="translated">A partir de la versión 1.01 del módulo AutoSplit es posible tener varios paquetes en un solo archivo.Se admiten los dos casos siguientes:</target>
        </trans-unit>
        <trans-unit id="4d09237d697a620472d98ca9564ba252e7440a3a" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="translated">A partir de la versi&amp;oacute;n 1.02 (proporcionada con perl 5.12), el objeto proporciona una sobrecarga &lt;code&gt;&quot;-X&quot;&lt;/code&gt; , por lo que puede llamar a los operadores de prueba de archivos ( &lt;code&gt;-f&lt;/code&gt; , &lt;code&gt;-x&lt;/code&gt; , etc.) en &amp;eacute;l. Tambi&amp;eacute;n proporciona un m&amp;eacute;todo &lt;code&gt;-&amp;gt;cando&lt;/code&gt; , llamado like</target>
        </trans-unit>
        <trans-unit id="3f4a112eabf93bbafc4bcc9a1025d0ef06b216ad" translate="yes" xml:space="preserve">
          <source>As of version 1.02 (provided with perl 5.12) the object provides &lt;code&gt;&quot;-X&quot;&lt;/code&gt; overloading, so you can call filetest operators (&lt;code&gt;-f&lt;/code&gt;, &lt;code&gt;-x&lt;/code&gt;, and so on) on it. It also provides a &lt;code&gt;-&amp;gt;cando&lt;/code&gt; method, called like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39c91a8aec6b3b91e09f6a8bd53c1515a32cc61b" translate="yes" xml:space="preserve">
          <source>As of version 1.04 (Perl 5.10), strict verifies that it is used as &quot;strict&quot; to avoid the dreaded Strict trap on case insensitive file systems.</source>
          <target state="translated">A partir de la versión 1.04 (Perl 5.10),Strict verifica que se utiliza como &quot;strict&quot; para evitar la temida trampa de Strict en sistemas de archivos que no distinguen entre mayúsculas y minúsculas.</target>
        </trans-unit>
        <trans-unit id="5750d09d680a68ca093b8cb502caecf523fc46de" translate="yes" xml:space="preserve">
          <source>As of version 1.32 of this module, constants can be defined in packages other than the caller, by including the package name in the name of the constant:</source>
          <target state="translated">A partir de la versión 1.32 de este módulo,las constantes pueden definirse en paquetes distintos del llamador,incluyendo el nombre del paquete en el nombre de la constante:</target>
        </trans-unit>
        <trans-unit id="a9966baeb16dc71d9782450ad1960be303770497" translate="yes" xml:space="preserve">
          <source>As of version 1.47 the following additions were made to the install interface. Note that the new argument style and use of the %result hash is recommended.</source>
          <target state="translated">A partir de la versión 1.47 se hicieron las siguientes adiciones a la interfaz de instalación.Nótese que se recomienda el nuevo estilo de argumento y el uso del hash %resultado.</target>
        </trans-unit>
        <trans-unit id="e47319fd89f8639b4c6dc3d1dee645f4e3217716" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt; ; see below.</source>
          <target state="translated">A partir de la versi&amp;oacute;n 2.12, &lt;code&gt;Encode&lt;/code&gt; admite valores de referencia de c&amp;oacute;digo para &lt;code&gt;CHECK&lt;/code&gt; ; vea abajo.</target>
        </trans-unit>
        <trans-unit id="ffc6a36f7c22fafbcd2974930b9d682b59ed0fd0" translate="yes" xml:space="preserve">
          <source>As of version 2.12, &lt;code&gt;Encode&lt;/code&gt; supports coderef values for &lt;code&gt;CHECK&lt;/code&gt;; see below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="feaefe7da5a3f173789e3bc38d1cc052b48f0697" translate="yes" xml:space="preserve">
          <source>As of version 2.32 Getopt::Long provides auto-help, a quick and easy way to add the options --help and -? to your program, and handle them.</source>
          <target state="translated">A partir de la versión 2.32 Getopt::Long proporciona auto-ayuda,una forma rápida y fácil de añadir las opciones -ayuda y -? a su programa,y manejarlas.</target>
        </trans-unit>
        <trans-unit id="4961ac95a03fe72cd95305ebd10cd56767e6cd2e" translate="yes" xml:space="preserve">
          <source>As of version 5.00305, OS/2 perl binary distribution comes split into 11 components. Unfortunately, to enable configurable binary installation, the file paths in the zip files are not absolute, but relative to some directory.</source>
          <target state="translated">A partir de la versión 5.00305,la distribución binaria de OS/2 perl viene dividida en 11 componentes.Desafortunadamente,para permitir una instalación binaria configurable,las rutas de los archivos zip no son absolutas,sino relativas a algún directorio.</target>
        </trans-unit>
        <trans-unit id="0a03b6b4ddea7ad90c28bf2de5b6b3532c441bd5" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the time implementation of the operating system it's running on. Instead, it has its own implementation of those routines with a safe range of at least +/- 2**52 (about 142 million years)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5ef8d96f6d787f0f3cc3fb69a33144b75f432e6" translate="yes" xml:space="preserve">
          <source>As of version 5.12.0, perl has stopped using the underlying time library of the operating system it's running on and has its own implementation of those routines with a safe range of at least +/ 2**52 (about 142 million years).</source>
          <target state="translated">A partir de la versión 5.12.0,perl ha dejado de utilizar la biblioteca de tiempo subyacente del sistema operativo en el que se ejecuta y tiene su propia implementación de esas rutinas con un rango seguro de al menos +/2**52 (unos 142 millones de años).</target>
        </trans-unit>
        <trans-unit id="ede48005eab24777f4cf1c1c51404cc14a546bbe" translate="yes" xml:space="preserve">
          <source>As of writing (2010-09) only the</source>
          <target state="translated">Hasta la fecha (2010-09)sólo el</target>
        </trans-unit>
        <trans-unit id="9bba94e9dfeb863cebb5f1b8b07f6bae30ef1d7d" translate="yes" xml:space="preserve">
          <source>As opposed to &lt;a href=&quot;http://man.he.net/man3/atoi&quot;&gt;atoi(3)&lt;/a&gt; or &lt;a href=&quot;http://man.he.net/man3/strtol&quot;&gt;strtol(3)&lt;/a&gt;, &lt;code&gt;grok_atoUV&lt;/code&gt; does NOT allow optional leading whitespace, nor negative inputs. If such features are required, the calling code needs to explicitly implement those.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="53d68ae04ea90208ac09617d93481673c81dae0c" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="translated">Seg&amp;uacute;n &lt;a href=&quot;functions/readline&quot;&gt;readline&lt;/a&gt; , en contexto escalar deber&amp;iacute;a devolver la siguiente l&amp;iacute;nea, o &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; para no tener m&amp;aacute;s datos. En el contexto de la lista, deber&amp;iacute;a devolver todas las l&amp;iacute;neas restantes o una lista vac&amp;iacute;a para no tener m&amp;aacute;s datos. Las cadenas devueltas deben incluir el separador de registros de entrada &lt;code&gt;$/&lt;/code&gt; (ver &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; ), a menos que sea &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; (que significa modo &quot;slurp&quot;).</target>
        </trans-unit>
        <trans-unit id="008a0000ee5b61a83c14df2cf7cee7f4e080298a" translate="yes" xml:space="preserve">
          <source>As per &lt;a href=&quot;perlfunc#readline&quot;&gt;&lt;code&gt;readline&lt;/code&gt;&lt;/a&gt;, in scalar context it should return the next line, or &lt;code&gt;undef&lt;/code&gt; for no more data. In list context it should return all remaining lines, or an empty list for no more data. The strings returned should include the input record separator &lt;code&gt;$/&lt;/code&gt; (see &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;), unless it is &lt;code&gt;undef&lt;/code&gt; (which means &quot;slurp&quot; mode).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="35db6e6083bf8853a0d7a773700bfc53f4f3833e" translate="yes" xml:space="preserve">
          <source>As per get(), but returns a tied filehandle. Reading from this filehandle returns the requested message. The filehandle will return EOF at the end of the message and should not be reused.</source>
          <target state="translated">Como get(),pero devuelve un filehandle atado.La lectura de este filehandle devuelve el mensaje solicitado.El filehandle devolverá EOF al final del mensaje y no debe ser reutilizado.</target>
        </trans-unit>
        <trans-unit id="f8d3cabb86865ec30b2f81b742c043bb4dfa0006" translate="yes" xml:space="preserve">
          <source>As perl does not use it, it is not well tested.</source>
          <target state="translated">Como Perl no lo usa,no está bien probado.</target>
        </trans-unit>
        <trans-unit id="04f2eace94f5ec9fb309f7ef275b1f53f5b18652" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; becomes</source>
          <target state="translated">Como pragmata se implementa como m&amp;oacute;dulos, como cualquier otro m&amp;oacute;dulo, &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; myint;&lt;/code&gt; se convierte en</target>
        </trans-unit>
        <trans-unit id="95ffc5a9c7d9d21832644aa0005e8ab6e5d3fda8" translate="yes" xml:space="preserve">
          <source>As pragmata are implemented as modules, like any other module, &lt;code&gt;use myint;&lt;/code&gt; becomes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ff69505257da499d009f94993a8c36d403bc517" translate="yes" xml:space="preserve">
          <source>As previously mentioned, the &quot;switch&quot; feature is considered highly experimental; it is subject to change with little notice. In particular, &lt;code&gt;when&lt;/code&gt; has tricky behaviours that are expected to change to become less tricky in the future. Do not rely upon its current (mis)implementation. Before Perl 5.18, &lt;code&gt;given&lt;/code&gt; also had tricky behaviours that you should still beware of if your code must run on older versions of Perl.</source>
          <target state="translated">Como se mencion&amp;oacute; anteriormente, la funci&amp;oacute;n &quot;cambiar&quot; se considera altamente experimental; est&amp;aacute; sujeto a cambios sin previo aviso. En particular, &lt;code&gt;when&lt;/code&gt; tiene comportamientos complicados que se espera que cambien para ser menos complicados en el futuro. No conf&amp;iacute;e en su (mala) implementaci&amp;oacute;n actual. Antes de Perl 5.18, &lt;code&gt;given&lt;/code&gt; tambi&amp;eacute;n ten&amp;iacute;a comportamientos complicados de los que a&amp;uacute;n debe tener cuidado si su c&amp;oacute;digo debe ejecutarse en versiones anteriores de Perl.</target>
        </trans-unit>
        <trans-unit id="d4ddd43c6028587c10020a05414bb6d70c1790ee" translate="yes" xml:space="preserve">
          <source>As previously noted, individual entries (as opposed to the whole hash) are settable. Perl only cares about Boolean true here, although the values used by</source>
          <target state="translated">Como se ha señalado anteriormente,las entradas individuales (en contraposición a todo el hachís)se pueden establecer.Perl sólo se preocupa por el verdadero Booleano aquí,aunque los valores utilizados por</target>
        </trans-unit>
        <trans-unit id="40863db850a5e2446412cc32d982d2e85c0c2a70" translate="yes" xml:space="preserve">
          <source>As setup, consider this (admittedly rather contrived) example of a tie; all it does is use a file to keep a log of the values assigned to a scalar.</source>
          <target state="translated">Como configuración,consideremos este ejemplo (ciertamente bastante artificioso)de corbata;todo lo que hace es utilizar un archivo para llevar un registro de los valores asignados a un escalar.</target>
        </trans-unit>
        <trans-unit id="d5e7901b05cd99e70f1eb4d22405e5ec5c43c73a" translate="yes" xml:space="preserve">
          <source>As shipped, the only command-line history supplied is a simplistic one that checks for leading exclamation points. However, if you install the Term::ReadKey and Term::ReadLine modules from CPAN (such as Term::ReadLine::Gnu, Term::ReadLine::Perl, ...) you will have full editing capabilities much like those GNU</source>
          <target state="translated">Tal y como se envió,el único historial de la línea de mando suministrado es uno simplista que comprueba los principales signos de exclamación.Sin embargo,si instalas los módulos Term::ReadKey y Term::ReadLine de CPAN (como Term::ReadLine::Gnu,Term::ReadLine::Perl,...)tendrás capacidades completas de edición como las de GNU</target>
        </trans-unit>
        <trans-unit id="3c7b29c9acaba84b5dfa9d94a08362e636c880e4" translate="yes" xml:space="preserve">
          <source>As shown above, Perl creates the backup file whether or not any output is actually changed. So this is just a fancy way to copy files:</source>
          <target state="translated">Como se muestra arriba,Perl crea el archivo de respaldo,ya sea que se cambie o no cualquier salida.Así que esta es sólo una forma elegante de copiar archivos:</target>
        </trans-unit>
        <trans-unit id="cf827d39576175b49dc1a1c39fee2ddfa72908f4" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">Como se muestra en este ejemplo, &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; est&amp;aacute; exento de la regla &quot;parece una funci&amp;oacute;n&quot;. Un par de par&amp;eacute;ntesis a continuaci&amp;oacute;n no delimita (necesariamente) su argumento. &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; es equivalente a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Adem&amp;aacute;s, a diferencia de la mayor&amp;iacute;a de los operadores con nombre, tiene la misma prioridad que la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a246c967f8c44d960de455229b31b368ecdb7f4c" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; is equivalent to &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="translated">Como se muestra en este ejemplo, &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; est&amp;aacute; exento de la regla &quot;parece una funci&amp;oacute;n&quot;. Un par de par&amp;eacute;ntesis a continuaci&amp;oacute;n no delimita (necesariamente) su argumento. &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/a&gt;&lt;/code&gt; es equivalente a &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; NEXT&lt;/code&gt; . Adem&amp;aacute;s, a diferencia de la mayor&amp;iacute;a de los operadores con nombre, tiene la misma prioridad que la asignaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="69217332278a487735b9f765568e5e6b60cb13f1" translate="yes" xml:space="preserve">
          <source>As shown in this example, &lt;code&gt;goto EXPR&lt;/code&gt; is exempt from the &quot;looks like a function&quot; rule. A pair of parentheses following it does not (necessarily) delimit its argument. &lt;code&gt;goto(&quot;NE&quot;).&quot;XT&quot;&lt;/code&gt; is equivalent to &lt;code&gt;goto NEXT&lt;/code&gt;. Also, unlike most named operators, this has the same precedence as assignment.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc78a790919531fd0718a68912f96b73236dccd" translate="yes" xml:space="preserve">
          <source>As some variables are reported by a different name in the output of &lt;code&gt;perl -V&lt;/code&gt; than their actual name in &lt;code&gt;%Config&lt;/code&gt;, I decided to leave the &lt;code&gt;config&lt;/code&gt; entry as close to reality as possible, and put in the entries that might have been guessed by the printed output in a separate block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48a035147de7a604eb6e8f9633c18d50b5e19c9b" translate="yes" xml:space="preserve">
          <source>As soon as one of my failing tests passes it will be removed from the list of failed tests. Eventually I fix them all and prove can find no failing tests to run:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81930da4a8c9e7cfd6af4afe44478552245004db" translate="yes" xml:space="preserve">
          <source>As such, consumers may use this data for informational analysis, but presenting it to the user as canonical or relying on it as such is invariably the height of folly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d2e840402d6fc0f9fee1fa99ab3b3ed1f5042e9" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; command (e.g., &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="translated">Como tal, las se&amp;ntilde;ales que normalmente no ser&amp;iacute;an apropiadas para usar en el comando &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill()&lt;/a&gt;&lt;/code&gt; (por ejemplo, &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;('KILL', $$)&lt;/code&gt; ) se pueden usar con el m&amp;eacute;todo &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; (nuevamente, como se ilustra arriba) .</target>
        </trans-unit>
        <trans-unit id="2afd2bab6cbdd50c9685439c6b9fc8e46337a3ed" translate="yes" xml:space="preserve">
          <source>As such, signals that would normally not be appropriate to use in the &lt;code&gt;kill()&lt;/code&gt; command (e.g., &lt;code&gt;kill('KILL', $$)&lt;/code&gt;) are okay to use with the &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; method (again, as illustrated above).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24bd5acc92d8894261d7ef9b04b6f856fb374ce1" translate="yes" xml:space="preserve">
          <source>As such, you open a pipe using the same &lt;code&gt;open&lt;/code&gt; call that you use for opening files, setting the second (&lt;code&gt;MODE&lt;/code&gt;) argument to special characters that indicate either an input or an output pipe. Use &lt;code&gt;&quot;-|&quot;&lt;/code&gt; for a filehandle that will let your Perl program read data from an external program, and &lt;code&gt;&quot;|-&quot;&lt;/code&gt; for a filehandle that will send data to that program instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a44ff5fd296684850a7eea8453ca8654e5ea2769" translate="yes" xml:space="preserve">
          <source>As system libraries (most notably glibc) are also triggering errors, valgrind allows to suppress such errors using suppression files. The default suppression file that comes with valgrind already catches a lot of them. Some additional suppressions are defined in</source>
          <target state="translated">Como las bibliotecas de sistema (sobre todo glibc)también están provocando errores,valgrind permite suprimir esos errores utilizando archivos de supresión.El archivo de supresión por defecto que viene con valgrind ya captura muchos de ellos.Algunas supresiones adicionales están definidas en</target>
        </trans-unit>
        <trans-unit id="e1a99808d733ec0659b941748add22eaba940233" translate="yes" xml:space="preserve">
          <source>As that is multiple C statements it is quite common so see this idiom instead:</source>
          <target state="translated">Como se trata de múltiples declaraciones de la C,es bastante común,así que vea este modismo en su lugar:</target>
        </trans-unit>
        <trans-unit id="ac882702a8c758004edc0489caa0c38829169f81" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt; , you can disable warnings using the empty subroutine:</source>
          <target state="translated">Como el gancho &lt;code&gt;'IGNORE'&lt;/code&gt; no es compatible con &lt;code&gt;__WARN__&lt;/code&gt; , puede desactivar las advertencias usando la subrutina vac&amp;iacute;a:</target>
        </trans-unit>
        <trans-unit id="d759f2151ab12005046fd0fb7fc374d93cc7fcaa" translate="yes" xml:space="preserve">
          <source>As the &lt;code&gt;'IGNORE'&lt;/code&gt; hook is not supported by &lt;code&gt;__WARN__&lt;/code&gt;, its effect is the same as using &lt;code&gt;'DEFAULT'&lt;/code&gt;. You can disable warnings using the empty subroutine:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="481d1ba67f45c383e883a88846da2edc2a1775aa" translate="yes" xml:space="preserve">
          <source>As the Perl interpreter looks at signal flags only when it is about to execute a new opcode, a signal that arrives during a long-running opcode (e.g. a regular expression operation on a very large string) will not be seen until the current opcode completes.</source>
          <target state="translated">Como el intérprete de Perl mira las banderas de señales sólo cuando está a punto de ejecutar un nuevo opcode,una señal que llega durante un opcode de larga duración (por ejemplo,una operación de expresión regular en una cadena muy grande)no se verá hasta que el opcode actual se complete.</target>
        </trans-unit>
        <trans-unit id="f849d9355eec2f51b5cef2814ee106c18c309122" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO (bytes) internally, all this totally ignores things like the type of your filesystem (ASCII or EBCDIC).</source>
          <target state="translated">Como la capa de PerlIO utiliza internamente IO (bytes)sin procesar,todo esto ignora totalmente cosas como el tipo de su sistema de archivos (ASCII o EBCDIC).</target>
        </trans-unit>
        <trans-unit id="ef5f3ccf5711fff6ab130d18e6106225adf61f56" translate="yes" xml:space="preserve">
          <source>As the PerlIO layer uses raw IO internally, all this totally ignores the type of your filesystem (ASCII or EBCDIC) and the IO_CONVERSION environment variable. If you want to get the old behavior, that the BS2000 IO functions determine conversion depending on the filesystem PerlIO still is your friend. You use IO_CONVERSION as usual and tell Perl, that it should use the native IO layer:</source>
          <target state="translated">Como la capa PerlIO usa IO en bruto internamente,todo esto ignora totalmente el tipo de su sistema de archivos (ASCII o EBCDIC)y la variable de entorno IO_CONVERSION.Si quieres conseguir el viejo comportamiento,que las funciones IO de BS2000 determinen la conversión dependiendo del sistema de archivos PerlIO sigue siendo tu amigo.Utiliza IO_CONVERSION como de costumbre y dile a Perl,que debe utilizar la capa IO nativa:</target>
        </trans-unit>
        <trans-unit id="20b8fc20101f3d438a32270dc2621c0dd14971b3" translate="yes" xml:space="preserve">
          <source>As the comment says, this is not a good way to implement accessors. It's slow and too clever by far. However, you may see this as a way to provide accessors in older Perl code. See &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; for recommendations on OO coding in Perl.</source>
          <target state="translated">Como dice el comentario, esta no es una buena forma de implementar accesos. Es lento y demasiado inteligente de lejos. Sin embargo, puede ver esto como una forma de proporcionar accesos en c&amp;oacute;digo Perl m&amp;aacute;s antiguo. Consulte &lt;a href=&quot;perlootut&quot;&gt;perlootut&lt;/a&gt; para obtener recomendaciones sobre la codificaci&amp;oacute;n OO en Perl.</target>
        </trans-unit>
        <trans-unit id="1139ca2064130f83bd2fbbeaae8eb84583cc89ac" translate="yes" xml:space="preserve">
          <source>As the example in &lt;a href=&quot;#new%28%29&quot;&gt;&quot;new()&quot;&lt;/a&gt; shows, you can always create a copy of an existing version object with the same value by the very compact:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fca5f01eab824b22bb6b1905a8d483f37ad2ed6" translate="yes" xml:space="preserve">
          <source>As the example shows, if the second argument is an empty string, the category's locale is returned to the default specified by the corresponding environment variables. Generally, this results in a return to the default that was in force when Perl started up: changes to the environment made by the application after startup may or may not be noticed, depending on your system's C library.</source>
          <target state="translated">Como muestra el ejemplo,si el segundo argumento es una cadena vacía,la localización de la categoría se devuelve al valor por defecto especificado por las variables de entorno correspondientes.Generalmente,esto da como resultado un retorno al valor por defecto que estaba vigente cuando se inició Perl:los cambios en el entorno realizados por la aplicación después del inicio pueden o no ser notados,dependiendo de la biblioteca C de su sistema.</target>
        </trans-unit>
        <trans-unit id="1edaf8c27fdae81166329d8ebc45bdc56d4e0e72" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portability to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt;, &lt;code&gt;\N{U+28}&lt;/code&gt;, &lt;code&gt;\N{U+29}&lt;/code&gt;, ..., &lt;code&gt;\N{U+3D}&lt;/code&gt;, &lt;code&gt;\N{U+3E}&lt;/code&gt;, and &lt;code&gt;\N{U+3F}&lt;/code&gt;, whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a3da7dd18a3b2da7c7f36441b50e2eab858828a" translate="yes" xml:space="preserve">
          <source>As the final two examples above show, you can achieve portablity to non-ASCII platforms by using the &lt;code&gt;\N{...}&lt;/code&gt; form for the range endpoints. These indicate that the specified range is to be interpreted using Unicode values, so &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; means to match &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; , and &lt;code&gt;\N{U+3F}&lt;/code&gt; , whatever the native code point versions for those are. These are called &quot;Unicode&quot; ranges. If either end is of the &lt;code&gt;\N{...}&lt;/code&gt; form, the range is considered Unicode. A &lt;code&gt;regexp&lt;/code&gt; warning is raised under &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; if the other endpoint is specified non-portably:</source>
          <target state="translated">Como muestran los dos ejemplos finales anteriores, puede lograr la portabilidad a plataformas que no sean ASCII utilizando el formulario &lt;code&gt;\N{...}&lt;/code&gt; para los puntos finales del rango. Estos indican que el rango especificado se interpretar&amp;aacute; utilizando valores Unicode, por lo que &lt;code&gt;[\N{U+27}-\N{U+3F}]&lt;/code&gt; significa coincidir con &lt;code&gt;\N{U+27}&lt;/code&gt; , &lt;code&gt;\N{U+28}&lt;/code&gt; , &lt;code&gt;\N{U+29}&lt;/code&gt; , ..., &lt;code&gt;\N{U+3D}&lt;/code&gt; , &lt;code&gt;\N{U+3E}&lt;/code&gt; y &lt;code&gt;\N{U+3F}&lt;/code&gt; , cualesquiera que sean las versiones nativas del punto de c&amp;oacute;digo. Estos se denominan rangos &quot;Unicode&quot;. Si cualquiera de los extremos tiene el formato &lt;code&gt;\N{...}&lt;/code&gt; , el rango se considera Unicode. Se &lt;code&gt;regexp&lt;/code&gt; advertencia de expresi&amp;oacute;n regular en &lt;code&gt;&quot;use re 'strict'&quot;&lt;/code&gt; si el otro punto final se especifica de forma no port&amp;aacute;til:</target>
        </trans-unit>
        <trans-unit id="17c70cf277254845a8ce88c971a047564a105d87" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt; , you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt; : if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="translated">Como &amp;uacute;ltimo car&amp;aacute;cter de un prototipo, o justo antes de un punto y coma, un &lt;code&gt;@&lt;/code&gt; o un &lt;code&gt;%&lt;/code&gt; , puede usar &lt;code&gt;_&lt;/code&gt; en lugar de &lt;code&gt;$&lt;/code&gt; : si no se proporciona este argumento, se usar&amp;aacute; &lt;code&gt;$_&lt;/code&gt; en su lugar.</target>
        </trans-unit>
        <trans-unit id="9cd30084251e957fbd55793c63ff1e2e0b66c3d5" translate="yes" xml:space="preserve">
          <source>As the last character of a prototype, or just before a semicolon, a &lt;code&gt;@&lt;/code&gt; or a &lt;code&gt;%&lt;/code&gt;, you can use &lt;code&gt;_&lt;/code&gt; in place of &lt;code&gt;$&lt;/code&gt;: if this argument is not provided, &lt;code&gt;$_&lt;/code&gt; will be used instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4b123b1845e08fc58170e4c4c4ab5952b56ae816" translate="yes" xml:space="preserve">
          <source>As the last example indicates, a handler may be set up to be (re)called in two or more phases. The phase name is passed as the handler's final argument.</source>
          <target state="translated">Como se indica en el último ejemplo,un manipulador puede estar configurado para ser (re)llamado en dos o más fases.El nombre de la fase se pasa como argumento final del manejador.</target>
        </trans-unit>
        <trans-unit id="776d16ae4f440b015655f81050641c0ec6c3a0f2" translate="yes" xml:space="preserve">
          <source>As the parser reads the second and subsequent lines from the source stream, it feeds those lines through the &lt;code&gt;cpp&lt;/code&gt; source filter before processing them. The &lt;code&gt;cpp&lt;/code&gt; filter simply passes each line through the real C preprocessor. The output from the C preprocessor is then inserted back into the source stream by the filter.</source>
          <target state="translated">A medida que el analizador lee la segunda l&amp;iacute;nea y las siguientes del flujo de origen, alimenta esas l&amp;iacute;neas a trav&amp;eacute;s del filtro de origen &lt;code&gt;cpp&lt;/code&gt; antes de procesarlas. El filtro &lt;code&gt;cpp&lt;/code&gt; simplemente pasa cada l&amp;iacute;nea a trav&amp;eacute;s del preprocesador C real. A continuaci&amp;oacute;n, el filtro vuelve a insertar la salida del preprocesador de C en el flujo de origen.</target>
        </trans-unit>
        <trans-unit id="de16f72d9bd04b071a155fd420870c413322270a" translate="yes" xml:space="preserve">
          <source>As the parser sees sections like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29477c3662cd388380e5f2f7edde392d4aa47d3" translate="yes" xml:space="preserve">
          <source>As the parser understands a Perl program, it builds up a tree of operations for the interpreter to perform during execution. The routines which construct and link together the various operations are to be found in</source>
          <target state="translated">A medida que el analizador entiende un programa de Perl,construye un árbol de operaciones para que el intérprete las realice durante la ejecución.Las rutinas que construyen y enlazan las distintas operaciones se encuentran en</target>
        </trans-unit>
        <trans-unit id="720247a05069501ddebd25eded634ebdeed59cfd" translate="yes" xml:space="preserve">
          <source>As the sorting is done in the JSON::PP scope, you usually need to prepend &lt;code&gt;JSON::PP::&lt;/code&gt; to the subroutine name, and the special variables &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; used in the subrontine used by &lt;code&gt;sort&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="059620d29d96cd6f5eb8cd327a9137c1f47169b5" translate="yes" xml:space="preserve">
          <source>As there are various Make programs with incompatible syntax, which use operating system shells, again with incompatible syntax, it is important for users of this module to know which flavour of Make a Makefile has been written for so they'll use the correct one and won't have to face the possibly bewildering errors resulting from using the wrong one.</source>
          <target state="translated">Como hay varios programas Make con sintaxis incompatible,que usan shells de sistemas operativos,de nuevo con sintaxis incompatible,es importante que los usuarios de este módulo sepan para qué sabor de Make un Makefile se ha escrito,de modo que usen el correcto y no tengan que enfrentarse a los posibles errores desconcertantes que resultan de usar el equivocado.</target>
        </trans-unit>
        <trans-unit id="036fd1e2507560ce47135587c83032ff17f1287e" translate="yes" xml:space="preserve">
          <source>As there is an overlap between the error numbers used by</source>
          <target state="translated">Como hay una superposición entre los números de error utilizados por</target>
        </trans-unit>
        <trans-unit id="267c472340bc23541eca7afc953c80b9af09e6af" translate="yes" xml:space="preserve">
          <source>As this callback gets called less often then the &lt;code&gt;filter_json_object&lt;/code&gt; one, decoding speed will not usually suffer as much. Therefore, single-key objects make excellent targets to serialise Perl objects into, especially as single-key JSON objects are as close to the type-tagged value concept as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not support this in any way, so you need to make sure your data never looks like a serialised Perl hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ae4c3659f41e6ea72787219e7dd135169795201" translate="yes" xml:space="preserve">
          <source>As to how you'd implement the Russian example from the beginning of the article, well, There's More Than One Way To Do It, but it could be something like this (using English words for Russian, just so you know what's going on):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c1931b1f7f35afcd5d7f66942f927b9ab23c40a" translate="yes" xml:space="preserve">
          <source>As to sharing of auxiliary functions, consider the problem of Russian numbers from the beginning of this article; obviously, you'd want to write only once the hairy code that, given a numeric value, would return some specification of which case and number a given quantified noun should use. But suppose that you discover, while localizing an interface for, say, Ukranian (a Slavic language related to Russian, spoken by several million people, many of whom would be relieved to find that your Web site's or software's interface is available in their language), that the rules in Ukranian are the same as in Russian for quantification, and probably for many other grammatical functions. While there may well be no phrases in common between Russian and Ukranian, you could still choose to have the Ukranian module inherit from the Russian module, just for the sake of inheriting all the various grammatical methods. Or, probably better organizationally, you could move those functions to a module called &lt;code&gt;_E_Slavic&lt;/code&gt; or something, which Russian and Ukrainian could inherit useful functions from, but which would (presumably) provide no lexicon.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2c40011ac031fbcf62ae0096c0f70fe3f04f6d4" translate="yes" xml:space="preserve">
          <source>As told above, Perl 5.6.1 was still good in AmigaOS, as was 5.7.2. After Perl 5.7.2 (change #11423, see the Changes file, and the file pod/perlhack.pod for how to get the individual changes) Perl dropped its internal support for vfork(), and that was very probably the step that broke AmigaOS (since the ixemul library has only vfork). The build finally fails when the ext/DynaLoader is being built, and PERL ends up as &quot;0&quot; in the produced Makefile, trying to run &quot;0&quot; does not quite work. Also, executing miniperl in backticks seems to generate nothing: very probably related to the (v)fork problems. &lt;b&gt;Fixing the breakage requires someone quite familiar with the ixemul library, and how one is supposed to run external commands in AmigaOS without fork().&lt;/b&gt;</source>
          <target state="translated">Como se dijo anteriormente, Perl 5.6.1 todav&amp;iacute;a era bueno en AmigaOS, al igual que 5.7.2. Despu&amp;eacute;s de Perl 5.7.2 (cambio # 11423, vea el archivo de Cambios y el archivo pod / perlhack.pod para saber c&amp;oacute;mo obtener los cambios individuales), Perl elimin&amp;oacute; su soporte interno para vfork (), y ese fue muy probablemente el paso que se rompi&amp;oacute; AmigaOS (ya que la biblioteca ixemul solo tiene vfork). La compilaci&amp;oacute;n finalmente falla cuando se est&amp;aacute; compilando el ext / DynaLoader y PERL termina como &quot;0&quot; en el Makefile producido, intentar ejecutar &quot;0&quot; no funciona del todo. Adem&amp;aacute;s, la ejecuci&amp;oacute;n de miniperl en comillas inversas parece no generar nada: muy probablemente relacionado con los problemas de la bifurcaci&amp;oacute;n (v). &lt;b&gt;Arreglar la rotura requiere alguien bastante familiarizado con la biblioteca ixemul, y c&amp;oacute;mo se supone que uno debe ejecutar comandos externos en AmigaOS sin fork ().&lt;/b&gt;</target>
        </trans-unit>
        <trans-unit id="7df201bc839d821d3a7ec829e521380838b10cef" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt; , and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="translated">Como de costumbre, &lt;code&gt;PL_restartop&lt;/code&gt; se extrae de &lt;code&gt;CxEVAL&lt;/code&gt; y se realiza un &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; , que hace que la pila de C vuelva a aparecer en docatch:</target>
        </trans-unit>
        <trans-unit id="2a573f9f62b976f78c5ac59164a50ae13a402046" translate="yes" xml:space="preserve">
          <source>As usual, &lt;code&gt;PL_restartop&lt;/code&gt; is extracted from the &lt;code&gt;CxEVAL&lt;/code&gt;, and a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; done, which pops the C stack back to the docatch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43f8dfff8ebd277fcb05688b6c5164a9ecb709ab" translate="yes" xml:space="preserve">
          <source>As usual, run</source>
          <target state="translated">Como siempre,corre</target>
        </trans-unit>
        <trans-unit id="6a12281792622fa54248b5b0512161ae986d73ec" translate="yes" xml:space="preserve">
          <source>As we have seen above, Principle 0 overrides the others. The regexp will be matched as early as possible, with the other principles determining how the regexp matches at that earliest character position.</source>
          <target state="translated">Como hemos visto arriba,el Principio 0 anula los otros.El regexp se emparejará lo antes posible,y los otros principios determinarán cómo se empareja el regexp en esa posición de caracteres más temprana.</target>
        </trans-unit>
        <trans-unit id="f24d0557480129d0bec98f1d07b3bc35225e11b2" translate="yes" xml:space="preserve">
          <source>As we mentioned before, Perl's built-in OO system is very minimal, but also quite flexible. Over the years, many people have developed systems which build on top of Perl's built-in system to provide more features and convenience.</source>
          <target state="translated">Como mencionamos antes,el sistema de OO incorporado de Perl es muy mínimo,pero también bastante flexible.A lo largo de los años,mucha gente ha desarrollado sistemas que se construyen sobre el sistema incorporado de Perl para proporcionar más características y conveniencia.</target>
        </trans-unit>
        <trans-unit id="4f2e51cb7fb14eb8f1de406668bded94aec1752e" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f78df2a986a05b74a05b4840bd77f0745f303d" translate="yes" xml:space="preserve">
          <source>As we mentioned before, roles provide an alternative to inheritance, but Perl does not have any built-in role support. If you choose to use Moose, it comes with a full-fledged role implementation. However, if you use one of our other recommended OO modules, you can still use roles with &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role::Tiny&lt;/a&gt;</source>
          <target state="translated">Como mencionamos antes, los roles proporcionan una alternativa a la herencia, pero Perl no tiene ning&amp;uacute;n soporte de rol incorporado. Si elige usar Moose, viene con una implementaci&amp;oacute;n de rol completa. Sin embargo, si usa uno de nuestros otros m&amp;oacute;dulos OO recomendados, a&amp;uacute;n puede usar roles con &lt;a href=&quot;http://search.cpan.org/perldoc/Role::Tiny&quot;&gt;Role :: Tiny&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="6f8a13dd0293aebd2b1466f31d349be90b2e062e" translate="yes" xml:space="preserve">
          <source>As we mentioned earlier, Perl provides no special constructor syntax. This means that a class must implement its own constructor. A constructor is simply a class method that returns a reference to a new object.</source>
          <target state="translated">Como mencionamos antes,Perl no tiene una sintaxis constructiva especial.Esto significa que una clase debe implementar su propio constructor.Un constructor es simplemente un método de clase que devuelve una referencia a un nuevo objeto.</target>
        </trans-unit>
        <trans-unit id="34cb600e9a3f6e5e075e857de4110b1ef2b3324a" translate="yes" xml:space="preserve">
          <source>As we return an empty list, everything is fine.</source>
          <target state="translated">Al devolver una lista vacía,todo está bien.</target>
        </trans-unit>
        <trans-unit id="1bc0081962e83c9753eb5550755ad42af088433e" translate="yes" xml:space="preserve">
          <source>As we said before, Perl's minimal OO system has led to a profusion of OO systems on CPAN. While you can still drop down to the bare metal and write your classes by hand, there's really no reason to do that with modern Perl.</source>
          <target state="translated">Como dijimos antes,el mínimo sistema de OO de Perl ha llevado a una profusión de sistemas de OO en el CPAN.Mientras que todavía puedes bajar al metal desnudo y escribir tus clases a mano,no hay realmente ninguna razón para hacer eso con el Perl moderno.</target>
        </trans-unit>
        <trans-unit id="7867c988c2c06b2c05fdddd86e23a3f47b3a2862" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function.</source>
          <target state="translated">Como dijimos anteriormente, la mayor&amp;iacute;a de los objetos Perl son hashes, pero un objeto puede ser una instancia de cualquier tipo de datos Perl (escalar, matriz, etc.). La conversi&amp;oacute;n de una estructura de datos simple en un objeto se realiza mediante la &lt;b&gt;bendici&amp;oacute;n de&lt;/b&gt; esa estructura de datos mediante la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; de Perl .</target>
        </trans-unit>
        <trans-unit id="4b99a5371cd1d193aeb40f1c8ec4bf090e8b2c97" translate="yes" xml:space="preserve">
          <source>As we said earlier, most Perl objects are hashes, but an object can be an instance of any Perl data type (scalar, array, etc.). Turning a plain data structure into an object is done by &lt;b&gt;blessing&lt;/b&gt; that data structure using Perl's &lt;code&gt;bless&lt;/code&gt; function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="504d4df94aa612d7624624e4944523fc3497d648" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function. The &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="translated">Como vimos anteriormente, un objeto es simplemente una estructura de datos que ha sido bendecida en una clase a trav&amp;eacute;s de la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; . La funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/bless&quot;&gt;bless&lt;/a&gt;&lt;/code&gt; puede tomar uno o dos argumentos:</target>
        </trans-unit>
        <trans-unit id="86afd7b293cb09c0f55f2b3f4442d25492c71a40" translate="yes" xml:space="preserve">
          <source>As we saw earlier, an object is simply a data structure that has been blessed into a class via the &lt;code&gt;bless&lt;/code&gt; function. The &lt;code&gt;bless&lt;/code&gt; function can take either one or two arguments:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1d3a4a5afeb3f9e63b11e0b6c656dbcfa8f18b8" translate="yes" xml:space="preserve">
          <source>As we've already shown, &lt;code&gt;call_sv&lt;/code&gt; can be used to invoke an anonymous subroutine. However, our example showed a Perl script invoking an XSUB to perform this operation. Let's see how it can be done inside our C code:</source>
          <target state="translated">Como ya hemos mostrado, &lt;code&gt;call_sv&lt;/code&gt; se puede utilizar para invocar una subrutina an&amp;oacute;nima. Sin embargo, nuestro ejemplo mostr&amp;oacute; un script de Perl que invoca un XSUB para realizar esta operaci&amp;oacute;n. Veamos c&amp;oacute;mo se puede hacer dentro de nuestro c&amp;oacute;digo C:</target>
        </trans-unit>
        <trans-unit id="96d58f32e93788e5dbef34c03d0df80dbd089dab" translate="yes" xml:space="preserve">
          <source>As well as accessing Berkeley DB using a tied hash or array, it is also possible to make direct use of most of the API functions defined in the Berkeley DB documentation.</source>
          <target state="translated">Además de acceder a la Berkeley DB usando un hash atado o un array,también es posible hacer uso directo de la mayoría de las funciones de la API definidas en la documentación de la Berkeley DB.</target>
        </trans-unit>
        <trans-unit id="0237593efedf8b6eff88bac44019384e6b74f34f" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the array (like &lt;code&gt;av_clear()&lt;/code&gt;), this also frees the memory used by the av to store its list of scalars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a89b3b004de95ce93de721c0f8e3cdeec13f545" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like &lt;code&gt;hv_clear()&lt;/code&gt;), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="749b97b56149a492eb18a4cb65f04d306a596132" translate="yes" xml:space="preserve">
          <source>As well as freeing all the elements of the hash (like hv_clear()), this also frees any auxiliary data and storage associated with the hash.</source>
          <target state="translated">Además de liberar todos los elementos del hash (como hv_clear()),también libera cualquier dato y almacenamiento auxiliar asociado al hash.</target>
        </trans-unit>
        <trans-unit id="2e0710bbe12c8de0ee3e47fce586245cf49652f2" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="translated">Adem&amp;aacute;s de la agrupaci&amp;oacute;n, los par&amp;eacute;ntesis tienen un segundo prop&amp;oacute;sito. Se pueden utilizar para capturar los resultados de partes de la coincidencia de expresiones regulares para su uso posterior. Los resultados terminan en &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; y as&amp;iacute; sucesivamente.</target>
        </trans-unit>
        <trans-unit id="3a1788b97e5572fb886ee20a2620cc1ef5c829d9" translate="yes" xml:space="preserve">
          <source>As well as grouping, parentheses serve a second purpose. They can be used to capture the results of parts of the regexp match for later use. The results end up in &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; and so on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="998a4f37f47dfa1a21fcb95591647fa7596884ba" translate="yes" xml:space="preserve">
          <source>As well as the following methods, this class inherits all the methods in &lt;a href=&quot;IO::Socket&quot;&gt;IO::Socket&lt;/a&gt; and &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7365f5053276b5ccb78d102d8d65d8a7cbb5a47c" translate="yes" xml:space="preserve">
          <source>As well as these two, there is another converter:</source>
          <target state="translated">Además de estos dos,hay otro convertidor:</target>
        </trans-unit>
        <trans-unit id="79309f713ddbfafe2f6334a91eabf7f9425eca6b" translate="yes" xml:space="preserve">
          <source>As with &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt; is set prior to unwinding the call stack; any &lt;code&gt;DESTROY&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; handlers can then alter this value, and thus Perl's exit code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f09c013a494b22fb2c5704b9b33f8690cdb78ae" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">Al igual que con &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; a los elementos de la lista, &lt;code&gt;pairfirst&lt;/code&gt; alias &lt;code&gt;$a&lt;/code&gt; y &lt;code&gt;$b&lt;/code&gt; de los elementos de la lista dada. Cualquier modificaci&amp;oacute;n del mismo por el bloque de c&amp;oacute;digo ser&amp;aacute; visible para la persona que llama.</target>
        </trans-unit>
        <trans-unit id="6ccb264713980d688f5b35e3f78e5d8bcc1b34f2" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">Al igual que con &lt;code&gt;&lt;a href=&quot;../functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; a los elementos de la lista, &lt;code&gt;pairgrep&lt;/code&gt; alias &lt;code&gt;$a&lt;/code&gt; y &lt;code&gt;$b&lt;/code&gt; de los elementos de la lista dada. Cualquier modificaci&amp;oacute;n del mismo por el bloque de c&amp;oacute;digo ser&amp;aacute; visible para la persona que llama.</target>
        </trans-unit>
        <trans-unit id="0e0ea04c8e6030abec75f8b13970784d2a0b7c8f" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="translated">Al igual que con &lt;code&gt;&lt;a href=&quot;../functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; a aliasing &lt;code&gt;$_&lt;/code&gt; a los elementos de la lista, &lt;code&gt;pairmap&lt;/code&gt; alias &lt;code&gt;$a&lt;/code&gt; y &lt;code&gt;$b&lt;/code&gt; de los elementos de la lista dada. Cualquier modificaci&amp;oacute;n del mismo por el bloque de c&amp;oacute;digo ser&amp;aacute; visible para la persona que llama.</target>
        </trans-unit>
        <trans-unit id="fec85543ad9986bf912be9475be1ac989c167db7" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;PERL5OPT&lt;/code&gt;, a string of additional &lt;code&gt;cpan(1)&lt;/code&gt; options to add to those you specify on the command line.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc99e7ad503065bd82f24f799275058edae300da" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairfirst&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d482c5453c9dc11a8d1e3e4a1d4df1955e90671" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;grep&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairgrep&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="852273f60001fb5cfcfc3f59c366b8a418d217ac" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;gzerror()&lt;/code&gt; it returns an error number in numeric context and an error message in string context. Unlike &lt;code&gt;gzerror()&lt;/code&gt; though, the error message will correspond to the</source>
          <target state="translated">Al igual que con &lt;code&gt;gzerror()&lt;/code&gt; , devuelve un n&amp;uacute;mero de error en contexto num&amp;eacute;rico y un mensaje de error en contexto de cadena. &lt;code&gt;gzerror()&lt;/code&gt; embargo, a diferencia de gzerror () , el mensaje de error corresponder&amp;aacute; al</target>
        </trans-unit>
        <trans-unit id="ad8ddc963c1faca12f5a1122723298a5bb8081cc" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;map&lt;/code&gt; aliasing &lt;code&gt;$_&lt;/code&gt; to list elements, &lt;code&gt;pairmap&lt;/code&gt; aliases &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt; to elements of the given list. Any modifications of it by the code block will be visible to the caller.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89fce7a719c0828fb9010451c52ebed3b12f2d8d" translate="yes" xml:space="preserve">
          <source>As with &lt;code&gt;mro::get_linear_isa&lt;/code&gt; above, &lt;code&gt;UNIVERSAL&lt;/code&gt; is special. &lt;code&gt;UNIVERSAL&lt;/code&gt; (and parents') isarev lists do not include every class in existence, even though all classes are effectively descendants for method inheritance purposes.</source>
          <target state="translated">Al igual que con &lt;code&gt;mro::get_linear_isa&lt;/code&gt; anterior, &lt;code&gt;UNIVERSAL&lt;/code&gt; es especial. Las listas isarev &lt;code&gt;UNIVERSAL&lt;/code&gt; (y las de los padres) no incluyen todas las clases existentes, aunque todas las clases son efectivamente descendientes para prop&amp;oacute;sitos de herencia de m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="32eae94f86fad4a1553a0eb1f5e32221b0ef149f" translate="yes" xml:space="preserve">
          <source>As with CORE::utime(), passing undef as both the atime and mtime will call the syscall with a NULL argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bfc8628cde1b50356023884cf039103db9706d2" translate="yes" xml:space="preserve">
          <source>As with G_SCALAR, this flag has 2 effects:</source>
          <target state="translated">Al igual que con G_SCALAR,esta bandera tiene 2 efectos:</target>
        </trans-unit>
        <trans-unit id="56fcac1f27b0d72bf38ecab8e2bf923c1135ad6d" translate="yes" xml:space="preserve">
          <source>As with GetOptionsFromArray, a first argument hash reference now becomes the second argument.</source>
          <target state="translated">Como en GetOptionsFromArray,una referencia de hash del primer argumento se convierte ahora en el segundo argumento.</target>
        </trans-unit>
        <trans-unit id="f5b2adb567968a40150b99a2b38e37687da34625" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo)
{ &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</source>
          <target state="translated">Como ocurre con todas las directivas de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;&lt;/code&gt; , la definici&amp;oacute;n de una constante ocurre en tiempo de compilaci&amp;oacute;n. Por lo tanto, probablemente no sea correcto poner una declaraci&amp;oacute;n constante dentro de una declaraci&amp;oacute;n condicional (como &lt;code&gt;if ($foo) { &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; constant ... }&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="5354f6304cc90aca1a4c69a0041cb7b6c7daa540" translate="yes" xml:space="preserve">
          <source>As with all &lt;code&gt;use&lt;/code&gt; directives, defining a constant happens at compile time. Thus, it's probably not correct to put a constant declaration inside of a conditional statement (like &lt;code&gt;if ($foo) { use constant ... }&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9e166bc9c2d17d86e12b7d5456a5dc29e6460a0" translate="yes" xml:space="preserve">
          <source>As with all compiler backend options, these must follow directly after the '-MO=Deparse', separated by a comma but not any white space.</source>
          <target state="translated">Como con todas las opciones de fondo del compilador,éstas deben seguir directamente después del &quot;-MO=Deparse&quot;,separadas por una coma pero sin ningún espacio en blanco.</target>
        </trans-unit>
        <trans-unit id="dec6818f5ac3b2a14f0cdaa20965c7cdeed80414" translate="yes" xml:space="preserve">
          <source>As with all standard commands, a single-character switch may be clustered with the following switch, if any.</source>
          <target state="translated">Como con todos los comandos estándar,un interruptor de un solo carácter puede agruparse con el siguiente interruptor,si lo hay.</target>
        </trans-unit>
        <trans-unit id="3f95467f687ea8e2cde45cd2aae56d762c10d52a" translate="yes" xml:space="preserve">
          <source>As with all things in Perl,</source>
          <target state="translated">Como todas las cosas en Perl,</target>
        </trans-unit>
        <trans-unit id="d4bf4ba0005710853f921b26431dc8a4fd4165e9" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt; . If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt; , you will get no protection at all.</source>
          <target state="translated">Al igual que con cualquier esquema de bloqueo de advertencia, la protecci&amp;oacute;n solo funciona si usa sistem&amp;aacute;ticamente &lt;code&gt;lock_store&lt;/code&gt; y &lt;code&gt;lock_retrieve&lt;/code&gt; . Si un lado de su aplicaci&amp;oacute;n usa &lt;code&gt;store&lt;/code&gt; mientras que el otro usa &lt;code&gt;lock_retrieve&lt;/code&gt; , no obtendr&amp;aacute; ninguna protecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="cbbf76ef92d8f729f36aea391937508d71d89ba4" translate="yes" xml:space="preserve">
          <source>As with any advisory locking scheme, the protection only works if you systematically use &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_retrieve&lt;/code&gt;. If one side of your application uses &lt;code&gt;store&lt;/code&gt; whilst the other uses &lt;code&gt;lock_retrieve&lt;/code&gt;, you will get no protection at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dfdecc72a46325c982361e944a60a5cc48397fb3" translate="yes" xml:space="preserve">
          <source>As with constructors, Perl provides no special accessor declaration syntax, so classes must provide explicitly written accessor methods. There are two common types of accessors, read-only and read-write.</source>
          <target state="translated">Como en el caso de los constructores,Perl no proporciona una sintaxis especial de declaración de accesorios,por lo que las clases deben proporcionar métodos de acceso explícitamente escritos.Hay dos tipos comunes de accesos,de sólo lectura y de lectura-escritura.</target>
        </trans-unit>
        <trans-unit id="5d06ccd4ce0505718d0adf18033c22a5ca1bc63e" translate="yes" xml:space="preserve">
          <source>As with many unix ports, this one depends on a few &quot;standard&quot; unix utilities which are not necessarily standard for QNX4.</source>
          <target state="translated">Como con muchos puertos unix,éste depende de unas pocas utilidades unix &quot;estándar&quot; que no son necesariamente estándar para QNX4.</target>
        </trans-unit>
        <trans-unit id="522d69b5bf4a752ac2eed134a3a3d90b973940bc" translate="yes" xml:space="preserve">
          <source>As with normal Perl arrays, a RECNO array can be accessed using negative indexes. The index -1 refers to the last element of the array, -2 the second last, and so on. Attempting to access an element before the start of the array will raise a fatal run-time error.</source>
          <target state="translated">Como con los arreglos de Perl normales,se puede acceder a un arreglo de RECNO usando índices negativos.El índice -1 se refiere al último elemento de la matriz,-2 al último segundo,y así sucesivamente.Intentar acceder a un elemento antes del comienzo del array provocará un error fatal en el tiempo de ejecución.</target>
        </trans-unit>
        <trans-unit id="4f5b532a80f5e05a1cc6284ddbfce49edaec9bba" translate="yes" xml:space="preserve">
          <source>As with postfix array, postfix value slice dereferencing</source>
          <target state="translated">Al igual que con la matriz de postfix,el valor de postfix rebanada dereferenciando</target>
        </trans-unit>
        <trans-unit id="5f2a0ee0b6d450a60b564dbded3394cc767489a2" translate="yes" xml:space="preserve">
          <source>As with subroutines, the type of value returned from a thread's entry point function may be determined by the thread's</source>
          <target state="translated">Al igual que en las subrutinas,el tipo de valor devuelto por la función del punto de entrada de un hilo puede estar determinado por la</target>
        </trans-unit>
        <trans-unit id="b1cab3e1a5ac11251ae5d77c854023eac88d9ffb" translate="yes" xml:space="preserve">
          <source>As with the</source>
          <target state="translated">Como en el caso de la</target>
        </trans-unit>
        <trans-unit id="cd7300c50635cef829928b369e4af967b57015fd" translate="yes" xml:space="preserve">
          <source>As with the DB_HASH format, it is possible to provide a user defined Perl routine to perform the comparison of keys. By default, though, the keys are stored in lexical order.</source>
          <target state="translated">Al igual que con el formato DB_HASH,es posible proporcionar una rutina Perl definida por el usuario para realizar la comparación de claves.Sin embargo,por defecto,las claves se almacenan en orden léxico.</target>
        </trans-unit>
        <trans-unit id="69ca9bf5a86e0011eab25710aa599ffe7224ff94" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Al igual que con el modo de adici&amp;oacute;n, cuando abre un archivo en modo de solo escritura, ahora puede escribir en ese identificador de archivo usando cualquiera de los siguientes &lt;code&gt;&lt;a href=&quot;functions/syswrite&quot;&gt;syswrite&lt;/a&gt;&lt;/code&gt; &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/say&quot;&gt;say&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; o syswrite .</target>
        </trans-unit>
        <trans-unit id="d97479933fa1462fae02a9e50ede26b28a53d5f2" translate="yes" xml:space="preserve">
          <source>As with the append mode, when you open a file in write-only mode, you can now write to that filehandle using any of &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;printf&lt;/code&gt;, &lt;code&gt;say&lt;/code&gt;, &lt;code&gt;write&lt;/code&gt;, or &lt;code&gt;syswrite&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="166455d62d96ee30d0f7c0e9ebb9b193aa0e9037" translate="yes" xml:space="preserve">
          <source>As with the built-in &lt;code&gt;chmod()&lt;/code&gt;, &lt;code&gt;$file&lt;/code&gt; may be a filename or a file handle.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1061a3cd33d1bd9d36627a353371c49a4d11968d" translate="yes" xml:space="preserve">
          <source>As with the mark stack to the value stack, the scope stack forms a pair with the save stack. The scope stack stores the height of the save stack at which nested scopes begin, and allows the save stack to be unwound back to that point when the scope is left.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a73b99d56aa400ec87ca02454010bfda953deea" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; operator, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; can use other delimiters, such as &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt;, and even &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt;. If single quotes are used &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; in list context returns the same thing as in scalar context, i.e., the number of matches.</source>
          <target state="translated">Al igual que con el operador match &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; puede usar otros delimitadores, como &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s!!!&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}{}&lt;/a&gt;&lt;/code&gt; , e incluso &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s{}//&lt;/a&gt;&lt;/code&gt; . Si se usan comillas simples &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; , entonces la expresi&amp;oacute;n regular y el reemplazo se tratan como cadenas entre comillas simples y no hay sustituciones de variables. &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; en el contexto de lista devuelve lo mismo que en el contexto escalar, es decir, el n&amp;uacute;mero de coincidencias.</target>
        </trans-unit>
        <trans-unit id="8a7f1aef7986985cb8cfbcb39be9e92c12b6802e" translate="yes" xml:space="preserve">
          <source>As with the match &lt;code&gt;m//&lt;/code&gt; operator, &lt;code&gt;s///&lt;/code&gt; can use other delimiters, such as &lt;code&gt;s!!!&lt;/code&gt; and &lt;code&gt;s{}{}&lt;/code&gt;, and even &lt;code&gt;s{}//&lt;/code&gt;. If single quotes are used &lt;code&gt;s'''&lt;/code&gt;, then the regexp and replacement are treated as single-quoted strings and there are no variable substitutions. &lt;code&gt;s///&lt;/code&gt; in list context returns the same thing as in scalar context,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5751273786ef031d84398bd287378b577d2ec97d" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cd8fd98a0003315162b3999969a156676702a25" translate="yes" xml:space="preserve">
          <source>As with the matching operator, the regexp quote can use different delimiters, e.g., &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt;. Apostrophes as delimiters (&lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt;) inhibit any interpolation.</source>
          <target state="translated">Al igual que con el operador de coincidencia, la cita de expresiones regulares puede usar diferentes delimitadores, por ejemplo, &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr!!&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr{}&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr~~&lt;/a&gt;&lt;/code&gt; . Los ap&amp;oacute;strofos como delimitadores ( &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr''&lt;/a&gt;&lt;/code&gt; ) inhiben cualquier interpolaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e11bb01f2bd8c076a80300f6980985d85bb41c1a" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The untie Gotcha&lt;/a&gt; below.</source>
          <target state="translated">Al igual que con los otros tipos de ataduras, este m&amp;eacute;todo se llamar&amp;aacute; cuando se &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; . Puede ser apropiado &quot;CERRAR autom&amp;aacute;ticamente&quot; cuando esto ocurra. Vea &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;The Untie Gotcha a&lt;/a&gt; continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="afcbb54437173c8bdb1b71e9fdd8c918462556a8" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when &lt;code&gt;untie&lt;/code&gt; happens. It may be appropriate to &quot;auto CLOSE&quot; when this occurs. See &lt;a href=&quot;#The-untie-Gotcha&quot;&gt;&quot;The &lt;code&gt;untie&lt;/code&gt; Gotcha&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d1c8cd71dac7105bd6440effb2807ea501bbea1" translate="yes" xml:space="preserve">
          <source>As with the other types of ties, this method will be called when the tied handle is about to be destroyed. This is useful for debugging and possibly cleaning up.</source>
          <target state="translated">Al igual que con los otros tipos de ataduras,este método se llamará cuando el asa atada esté a punto de ser destruida.Esto es útil para depurar y posiblemente limpiar.</target>
        </trans-unit>
        <trans-unit id="c8628e08c07475c8f2b1e6b9f5f0e7ba611079bf" translate="yes" xml:space="preserve">
          <source>As with the return stack, it would be possible (and a small performance win) to pre-extend the return array before pushing data into it, since we know how many elements we will return:</source>
          <target state="translated">Al igual que con la pila de retorno,sería posible (y una pequeña ganancia de rendimiento)pre-extender la matriz de retorno antes de introducir los datos en ella,ya que sabemos cuántos elementos devolveremos:</target>
        </trans-unit>
        <trans-unit id="3d4c99ea11e7c5fcd5dc736377914de3be4bac49" translate="yes" xml:space="preserve">
          <source>As with the shell, in Perl the &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; is used to open the file in read-only mode. If it succeeds, Perl allocates a brand new filehandle for you and fills in your previously undefined &lt;code&gt;$handle&lt;/code&gt; argument with a reference to that handle.</source>
          <target state="translated">Al igual que con el shell, en Perl se usa &lt;code&gt;&quot;&amp;lt;&quot;&lt;/code&gt; para abrir el archivo en modo de s&amp;oacute;lo lectura. Si tiene &amp;eacute;xito, Perl le asigna un nuevo identificador de archivo y completa su argumento &lt;code&gt;$handle&lt;/code&gt; previamente indefinido con una referencia a ese identificador.</target>
        </trans-unit>
        <trans-unit id="7fd1e1a58893cf268ad48b11d78449c12dc31c5c" translate="yes" xml:space="preserve">
          <source>As you can see 3 records have been successfully created with key &lt;code&gt;Wall&lt;/code&gt; - the only thing is, when they are retrieved from the database they</source>
          <target state="translated">Como puede ver, se han creado 3 registros con &amp;eacute;xito con key &lt;code&gt;Wall&lt;/code&gt; ; lo &amp;uacute;nico es que cuando se recuperan de la base de datos,</target>
        </trans-unit>
        <trans-unit id="07a24c035647250238dd385e01e0859319d79ee5" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method. The difference between them is that the</source>
          <target state="translated">Como puede ver, ambos m&amp;oacute;dulos tienen una estructura muy similar. Ambos hacen uso del m&amp;oacute;dulo &lt;code&gt;Filter::Util::Call&lt;/code&gt; y ambos tienen un m&amp;eacute;todo de &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n . La diferencia entre ellos es que el</target>
        </trans-unit>
        <trans-unit id="6c90ba06fa5e1fe7496f3d2e8756e36b17de7ff3" translate="yes" xml:space="preserve">
          <source>As you can see both modules have a broadly similar structure. They both make use of the &lt;code&gt;Filter::Util::Call&lt;/code&gt; module and both have an &lt;code&gt;import&lt;/code&gt; method. The difference between them is that the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f994dc63d7341f367ad1cc1ffc63c6ff1af1973" translate="yes" xml:space="preserve">
          <source>As you can see in the synopsis, based on your template, the arguments provided will be validated.</source>
          <target state="translated">Como puede ver en la sinopsis,basado en su plantilla,los argumentos proporcionados serán validados.</target>
        </trans-unit>
        <trans-unit id="fc43df7357cab99ebecef48bb020a483deb5469e" translate="yes" xml:space="preserve">
          <source>As you can see,</source>
          <target state="translated">Como puede ver,</target>
        </trans-unit>
        <trans-unit id="ba5fcb84fa73471a91e0f59090740d9676a886a8" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt; . This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt; .</source>
          <target state="translated">Como se puede ver, una nueva corriente ha sido creado para la lectura de la fuente de la &lt;code&gt;Fred.pm&lt;/code&gt; . Esta transmisi&amp;oacute;n permanecer&amp;aacute; activa hasta que se haya analizado todo &lt;code&gt;Fred.pm&lt;/code&gt; . El flujo de origen de &lt;code&gt;cpp_test&lt;/code&gt; seguir&amp;aacute; existiendo, pero estar&amp;aacute; inactivo. Una vez que el analizador ha terminado de leer Fred.pm, se destruir&amp;aacute; el flujo de origen asociado a &amp;eacute;l. El flujo de origen para &lt;code&gt;cpp_test&lt;/code&gt; vuelve a activarse y el analizador lee la l&amp;iacute;nea 4 y las l&amp;iacute;neas siguientes de &lt;code&gt;cpp_test&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d30857f7aa9b41378f7136a05fa07d62994d4300" translate="yes" xml:space="preserve">
          <source>As you can see, a new stream has been created for reading the source from &lt;code&gt;Fred.pm&lt;/code&gt;. This stream will remain active until all of &lt;code&gt;Fred.pm&lt;/code&gt; has been parsed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; will still exist, but is inactive. Once the parser has finished reading Fred.pm, the source stream associated with it will be destroyed. The source stream for &lt;code&gt;cpp_test&lt;/code&gt; then becomes active again and the parser reads line 4 and subsequent lines from &lt;code&gt;cpp_test&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25de0c5886c2da663b8272fdb54e70c4ca6e8f92" translate="yes" xml:space="preserve">
          <source>As you can see, either a bare number or a quoted string can usually be used interchangeably, except in the case of a trailing zero, which must be quoted to be converted properly. For this reason, it is strongly recommended that all initializers to qv() be quoted strings instead of bare numbers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413492c2aba459a109ff8cf8bd650d35b867bf30" translate="yes" xml:space="preserve">
          <source>As you can see, even though we parsed out a branch and a piece, it was ultimately only an atom. The final program shows us how things work. We have an &lt;code&gt;EXACT&lt;/code&gt; regop, followed by an &lt;code&gt;END&lt;/code&gt; regop. The number in parens indicates where the &lt;code&gt;regnext&lt;/code&gt; of the node goes. The &lt;code&gt;regnext&lt;/code&gt; of an &lt;code&gt;END&lt;/code&gt; regop is unused, as &lt;code&gt;END&lt;/code&gt; regops mean we have successfully matched. The number on the left indicates the position of the regop in the regnode array.</source>
          <target state="translated">Como puede ver, a pesar de que analizamos una rama y una pieza, en &amp;uacute;ltima instancia era solo un &amp;aacute;tomo. El programa final nos muestra c&amp;oacute;mo funcionan las cosas. Tenemos un regop &lt;code&gt;EXACT&lt;/code&gt; O , seguido de un regop &lt;code&gt;END&lt;/code&gt; . El n&amp;uacute;mero entre parens indica d&amp;oacute;nde va el &lt;code&gt;regnext&lt;/code&gt; del nodo. El &lt;code&gt;regnext&lt;/code&gt; de una repetici&amp;oacute;n &lt;code&gt;END&lt;/code&gt; no se utiliza, ya que las repeticiones &lt;code&gt;END&lt;/code&gt; significan que hemos coincidido con &amp;eacute;xito. El n&amp;uacute;mero de la izquierda indica la posici&amp;oacute;n de la regop en la matriz regnode.</target>
        </trans-unit>
        <trans-unit id="a413e2eb7d932038f9ab1ac09695763b902b4d80" translate="yes" xml:space="preserve">
          <source>As you can see, it's getting a bit complicated. That's why sometimes is easier to take a temporary on your way through:</source>
          <target state="translated">Como puedes ver,se está complicando un poco.Por eso,a veces es más fácil tomar una decisión temporal en tu camino:</target>
        </trans-unit>
        <trans-unit id="3fa1293b0c00ad3a76c1e01bf182a9e2122f9fdc" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt; , where the &quot;little end&quot; touches the code.</source>
          <target state="translated">Como puede ver, el &quot;extremo grande&quot; de la flecha toca la &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s&lt;/a&gt;&lt;/code&gt; , lo cual es una buena forma de recordar que &lt;code&gt;&amp;gt;&lt;/code&gt; es el modificador big-endian. Obviamente, lo mismo funciona para &lt;code&gt;&amp;lt;&lt;/code&gt; , donde el &quot;peque&amp;ntilde;o final&quot; toca el c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="e38e7377d2adf9700c078e4fa63c0bfa66881f41" translate="yes" xml:space="preserve">
          <source>As you can see, the &quot;big end&quot; of the arrow touches the &lt;code&gt;s&lt;/code&gt;, which is a nice way to remember that &lt;code&gt;&amp;gt;&lt;/code&gt; is the big-endian modifier. The same obviously works for &lt;code&gt;&amp;lt;&lt;/code&gt;, where the &quot;little end&quot; touches the code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66163e2bfe72429a8264b60a772dffb530266b37" translate="yes" xml:space="preserve">
          <source>As you can see, the &lt;code&gt;&quot;|&quot;&lt;/code&gt; binds less tightly than a sequence of ordinary characters. We can override this by using the grouping metacharacters, the parentheses &lt;code&gt;&quot;(&quot;&lt;/code&gt; and &lt;code&gt;&quot;)&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d3da9040412695027bfa4b6fb728646046f3571" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt; , and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="translated">Como puede ver, todos los bytes de continuaci&amp;oacute;n comienzan con &lt;code&gt;&quot;10&quot;&lt;/code&gt; , y los bits iniciales del byte de inicio indican cu&amp;aacute;ntos bytes hay en el car&amp;aacute;cter codificado.</target>
        </trans-unit>
        <trans-unit id="d1ec4366039f138acb113c4753f7ee644d2c9618" translate="yes" xml:space="preserve">
          <source>As you can see, the continuation bytes all begin with &lt;code&gt;&quot;10&quot;&lt;/code&gt;, and the leading bits of the start byte tell how many bytes there are in the encoded character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3abefb49e57cec4dd056d885964fc7e8cddbabc0" translate="yes" xml:space="preserve">
          <source>As you can see, we've stored the path and file data in the object itself. Remember, under the hood, this object is still just a hash. Later, we'll write accessors to manipulate this data.</source>
          <target state="translated">Como pueden ver,hemos almacenado la ruta y los datos de los archivos en el propio objeto.Recuerden,bajo el capó,este objeto sigue siendo sólo un hachís.Más tarde,escribiremos accesos para manipular estos datos.</target>
        </trans-unit>
        <trans-unit id="5a6344bf7b33dbff5320cfc2c10a629a29808655" translate="yes" xml:space="preserve">
          <source>As you can tell from a glance at &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt;, the L&amp;lt;...&amp;gt; code is the most complex of the Pod formatting codes. The points below will hopefully clarify what it means and how processors should deal with it.</source>
          <target state="translated">Como puede ver de un vistazo a &lt;a href=&quot;perlpod&quot;&gt;perlpod&lt;/a&gt; , el c&amp;oacute;digo L &amp;lt;...&amp;gt; es el m&amp;aacute;s complejo de los c&amp;oacute;digos de formato de Pod. Es de esperar que los puntos a continuaci&amp;oacute;n aclaren lo que significa y c&amp;oacute;mo los procesadores deben manejarlo.</target>
        </trans-unit>
        <trans-unit id="9261097e2916c2cc0f66dd44d4a942cdcbac0f6d" translate="yes" xml:space="preserve">
          <source>As you craft each patch you intend to submit to the Perl core, it's important to write a good commit message. This is especially important if your submission will consist of a series of commits.</source>
          <target state="translated">Mientras elaboras cada parche que pretendes enviar al núcleo de Perl,es importante escribir un buen mensaje de compromiso.Esto es especialmente importante si su envío consistirá en una serie de compromisos.</target>
        </trans-unit>
        <trans-unit id="585d50527e778d78ffa867804e8d6039ce87d004" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt; 's prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt; 's is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="translated">Como puede haber inferido de la documentaci&amp;oacute;n y los ejemplos anteriores, el prototipo de &lt;code&gt;ok&lt;/code&gt; es &lt;code&gt;($;$$)&lt;/code&gt; (y, dicho sea de paso, el de &lt;code&gt;skip&lt;/code&gt; es &lt;code&gt;($;$$$)&lt;/code&gt; ). Esto significa, por ejemplo, que puede hacer &lt;code&gt;ok @foo, @bar&lt;/code&gt; para comparar el</target>
        </trans-unit>
        <trans-unit id="60f0e85b8faee0b99818f50244dd5f18552cf61a" translate="yes" xml:space="preserve">
          <source>As you may have inferred from the above documentation and examples, &lt;code&gt;ok&lt;/code&gt;'s prototype is &lt;code&gt;($;$$)&lt;/code&gt; (and, incidentally, &lt;code&gt;skip&lt;/code&gt;'s is &lt;code&gt;($;$$$)&lt;/code&gt;). This means, for example, that you can do &lt;code&gt;ok @foo, @bar&lt;/code&gt; to compare the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3a79c79e4e5a9fafc42ddaaf88736c1e2cc7621" translate="yes" xml:space="preserve">
          <source>As you may have noticed, the name of the FETCH method (et al.) is the same for all accesses, even though the constructors differ in names (TIESCALAR vs TIEARRAY). While in theory you could have the same class servicing several tied types, in practice this becomes cumbersome, and it's easiest to keep them at simply one tie type per class.</source>
          <target state="translated">Como habrán notado,el nombre del método FETCH (et al.)es el mismo para todos los accesos,aunque los constructores difieren en los nombres (TIESCALAR vs TIEARRAY).Mientras que en teoría se podría tener la misma clase atendiendo a varios tipos de ataduras,en la práctica esto se vuelve engorroso,y es más fácil mantenerlos simplemente en un tipo de atadura por clase.</target>
        </trans-unit>
        <trans-unit id="e80271d1fdc3feb0460f1e3a1704fc272e31f101" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="translated">Como sabr&amp;aacute;, esto llama a la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n de &lt;code&gt;attributes&lt;/code&gt; en tiempo de compilaci&amp;oacute;n con estos par&amp;aacute;metros: 'atributos', el nombre del paquete de la persona que llama, la referencia al c&amp;oacute;digo y el 'm&amp;eacute;todo'.</target>
        </trans-unit>
        <trans-unit id="62f1e6ecdd027dd1eaef3a110461833a51c5767e" translate="yes" xml:space="preserve">
          <source>As you might know this calls the &lt;code&gt;import&lt;/code&gt; function of &lt;code&gt;attributes&lt;/code&gt; at compile time with these parameters: 'attributes', the caller's package name, the reference to the code and 'method'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f14d6a62a3d5dfc412b082b83700a2aa2b31479" translate="yes" xml:space="preserve">
          <source>As you see from those examples, &lt;code&gt;STDOUT&lt;/code&gt; and &lt;code&gt;STDERR&lt;/code&gt; are output handles, and &lt;code&gt;STDIN&lt;/code&gt; and &lt;code&gt;ARGV&lt;/code&gt; are input handles. They are in all capital letters because they are reserved to Perl, much like the &lt;code&gt;@ARGV&lt;/code&gt; array and the &lt;code&gt;%ENV&lt;/code&gt; hash are. Their external associations were set up by your shell.</source>
          <target state="translated">Como puede ver en esos ejemplos, &lt;code&gt;STDOUT&lt;/code&gt; y &lt;code&gt;STDERR&lt;/code&gt; son identificadores de salida, y &lt;code&gt;STDIN&lt;/code&gt; y &lt;code&gt;ARGV&lt;/code&gt; son identificadores de entrada. Est&amp;aacute;n en may&amp;uacute;sculas porque est&amp;aacute;n reservados para Perl, al igual que la matriz &lt;code&gt;@ARGV&lt;/code&gt; y el hash &lt;code&gt;%ENV&lt;/code&gt; . Sus asociaciones externas fueron establecidas por su caparaz&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e27f616d9e27793d35d5e898cb0fead7ca633114" translate="yes" xml:space="preserve">
          <source>As you see, it's quite easy to become confused. While some small portion of the blame for this can be attributed to the reference-based implementation, it's really more due to a lack of existing documentation with examples designed for the beginner.</source>
          <target state="translated">Como ves,es bastante fácil confundirse.Si bien una pequeña parte de la culpa de esto se puede atribuir a la aplicación basada en referencias,en realidad se debe más a la falta de documentación existente con ejemplos diseñados para el principiante.</target>
        </trans-unit>
        <trans-unit id="512c5953fca52adf9fe503c69215e4eb2353e34b" translate="yes" xml:space="preserve">
          <source>As you see, it's remarkably similar to the Internet domain TCP server, so much so, in fact, that we've omitted several duplicate functions--spawn(), logmsg(), ctime(), and REAPER()--which are the same as in the other server.</source>
          <target state="translated">Como ves,es notablemente similar al servidor TCP del dominio de Internet,tanto que,de hecho,hemos omitido varias funciones duplicadas-spawn(),logmsg(),ctime(),y REAPER()-que son las mismas que en el otro servidor.</target>
        </trans-unit>
        <trans-unit id="ea8178cd8e63a3e66a311fade3362af15d43aa5f" translate="yes" xml:space="preserve">
          <source>As you see, the name of the package is the name of the structure. Regular fields are just their own names. Plus the following accessor functions are provided for your convenience:</source>
          <target state="translated">Como ves,el nombre del paquete es el nombre de la estructura.Los campos regulares son sólo sus propios nombres.Además,se proporcionan las siguientes funciones accesorias para su conveniencia:</target>
        </trans-unit>
        <trans-unit id="1963330f0948df59dbdb1893ed34078a319f8af0" translate="yes" xml:space="preserve">
          <source>As you see, the next buffer begins with \x43. But \x43 is 'C' in ASCII, which is wrong in this case because we are now in JISX 0208 area so it has to convert \x43\x46, not \x43. Unlike utf8 and EUC, in escape-based encodings you can't tell if a given octet is a whole character or just part of it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b457b60332a38dcdc3bc2fb765fda15f087f9402" translate="yes" xml:space="preserve">
          <source>As you see, there is one exception: in ASCII. That way you can assume Goal #1. And with &lt;code&gt;Encode&lt;/code&gt; , Goal #2 is assumed but you still have to be careful in the cases mentioned in the &lt;b&gt;CAVEAT&lt;/b&gt; paragraphs above.</source>
          <target state="translated">Como ve, hay una excepci&amp;oacute;n: en ASCII. De esa manera, puede asumir el Objetivo # 1. Y con &lt;code&gt;Encode&lt;/code&gt; , se asume el Objetivo # 2, pero a&amp;uacute;n debe tener cuidado en los casos mencionados en los p&amp;aacute;rrafos &lt;b&gt;CAVEAT&lt;/b&gt; anteriores.</target>
        </trans-unit>
        <trans-unit id="7cc089f777993943781491fc9a72f85a9a2f245b" translate="yes" xml:space="preserve">
          <source>As you see, this can be a bit tricky. It's important to realize that a regular expression is merely a set of assertions that gives a definition of success. There may be 0, 1, or several different ways that the definition might succeed against a particular string. And if there are multiple ways it might succeed, you need to understand backtracking to know which variety of success you will achieve.</source>
          <target state="translated">Como ves,esto puede ser un poco difícil.Es importante darse cuenta de que una expresión regular es simplemente un conjunto de afirmaciones que da una definición de éxito.Puede haber 0,1,o varias formas diferentes en que la definición puede tener éxito contra una cadena en particular.Y si hay múltiples maneras en que podría tener éxito,necesitas entender el retroceso para saber qué variedad de éxito lograrás.</target>
        </trans-unit>
        <trans-unit id="f1ce088efa2db68e2d881f71961d1904be5d37ad" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt; ; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , and &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt; , using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt; ).</source>
          <target state="translated">Como era de esperar, este modificador hace que, por ejemplo, &lt;code&gt;\D&lt;/code&gt; signifique lo mismo que &lt;code&gt;[^0-9]&lt;/code&gt; ; de hecho, todos los caracteres no ASCII coinciden &lt;code&gt;\D&lt;/code&gt; , &lt;code&gt;\S&lt;/code&gt; , y &lt;code&gt;\W&lt;/code&gt; . &lt;code&gt;\b&lt;/code&gt; todav&amp;iacute;a significa coincidir en el l&amp;iacute;mite entre &lt;code&gt;\w&lt;/code&gt; y &lt;code&gt;\W&lt;/code&gt; , usando las definiciones &lt;code&gt;/a&lt;/code&gt; de ellos (de manera similar para &lt;code&gt;\B&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="326d016c49ef7a973850d57e2bcbf3c0189253be" translate="yes" xml:space="preserve">
          <source>As you would expect, this modifier causes, for example, &lt;code&gt;\D&lt;/code&gt; to mean the same thing as &lt;code&gt;[^0-9]&lt;/code&gt;; in fact, all non-ASCII characters match &lt;code&gt;\D&lt;/code&gt;, &lt;code&gt;\S&lt;/code&gt;, and &lt;code&gt;\W&lt;/code&gt;. &lt;code&gt;\b&lt;/code&gt; still means to match at the boundary between &lt;code&gt;\w&lt;/code&gt; and &lt;code&gt;\W&lt;/code&gt;, using the &lt;code&gt;/a&lt;/code&gt; definitions of them (similarly for &lt;code&gt;\B&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="26154301b1350500c1d0c8c752bea63ea6529192" translate="yes" xml:space="preserve">
          <source>As you're writing an application, you decide as you go what messages you need to emit. Normally you'd go to write this:</source>
          <target state="translated">Mientras escribes una solicitud,decides sobre la marcha qué mensajes debes emitir.Normalmente irías a escribir esto:</target>
        </trans-unit>
        <trans-unit id="94a73ad4a31e87483d1616b8954f4b6c0ff428df" translate="yes" xml:space="preserve">
          <source>As you've seen, you can force &lt;code&gt;catdir()&lt;/code&gt; to create an absolute path by passing either an empty string or a path that begins with a volume name as the first argument. However, you are strongly encouraged not to do so, since this is done only for backward compatibility. Newer versions of File::Spec come with a method called &lt;code&gt;catpath()&lt;/code&gt; (see below), that is designed to offer a portable solution for the creation of absolute paths. It takes volume, directory and file portions and returns an entire path. While &lt;code&gt;catdir()&lt;/code&gt; is still suitable for the concatenation of</source>
          <target state="translated">Como ha visto, puede obligar a &lt;code&gt;catdir()&lt;/code&gt; a crear una ruta absoluta pasando una cadena vac&amp;iacute;a o una ruta que comience con un nombre de volumen como primer argumento. Sin embargo, se le recomienda encarecidamente que no lo haga, ya que esto se hace solo por compatibilidad con versiones anteriores. Las versiones m&amp;aacute;s nuevas de File :: Spec vienen con un m&amp;eacute;todo llamado &lt;code&gt;catpath()&lt;/code&gt; (ver m&amp;aacute;s abajo), que est&amp;aacute; dise&amp;ntilde;ado para ofrecer una soluci&amp;oacute;n port&amp;aacute;til para la creaci&amp;oacute;n de rutas absolutas. Toma porciones de volumen, directorio y archivo y devuelve una ruta completa. Si bien &lt;code&gt;catdir()&lt;/code&gt; sigue siendo adecuado para la concatenaci&amp;oacute;n de</target>
        </trans-unit>
        <trans-unit id="b050afe32e842917948687f3937c11147c83dc8c" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_bin()&lt;/code&gt;, but with a &quot;0b&quot; prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88a7400facc4c4fbcaa07e7c2bb5aa1602866660" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_hex()&lt;/code&gt;, but with a &quot;0x&quot; prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="743f14ce73f3cd35ea5c0dbbced7d93ed35d470e" translate="yes" xml:space="preserve">
          <source>As, &lt;code&gt;to_oct()&lt;/code&gt;, but with a &quot;0&quot; prefix.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a173e725607d0f98c78ebac0b31138d8d136aa84" translate="yes" xml:space="preserve">
          <source>Asia</source>
          <target state="translated">Asia</target>
        </trans-unit>
        <trans-unit id="ef98034aa566e13ada7b3540ed05db8863763db2" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;&quot;Signatures&quot;&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;my()&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my%28%29&quot;&gt;&quot;Private Variables via my()&quot;&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local%28%29&quot;&gt;&quot;Temporary Values via local()&quot;&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;&quot;Packages&quot; in perlmod&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f22fac8ac4e191689a82159394064af8e931487a" translate="yes" xml:space="preserve">
          <source>Aside from an experimental facility (see &lt;a href=&quot;#Signatures&quot;&gt;Signatures&lt;/a&gt; below), Perl does not have named formal parameters. In practice all you do is assign to a &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; list of these. Variables that aren't declared to be private are global variables. For gory details on creating private variables, see &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Private Variables via my()&lt;/a&gt; and &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Temporary Values via local()&lt;/a&gt;. To create protected environments for a set of functions in a separate package (and probably a separate file), see &lt;a href=&quot;perlmod#Packages&quot;&gt;Packages in perlmod&lt;/a&gt;.</source>
          <target state="translated">Aparte de una instalaci&amp;oacute;n experimental (ver &lt;a href=&quot;#Signatures&quot;&gt;Firmas a&lt;/a&gt; continuaci&amp;oacute;n), Perl no tiene par&amp;aacute;metros formales con nombre. En la pr&amp;aacute;ctica, todo lo que hace es asignar a una lista &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my()&lt;/a&gt;&lt;/code&gt; de estos. Las variables que no se declaran privadas son variables globales. Para obtener detalles sangrientos sobre la creaci&amp;oacute;n de variables privadas, consulte &lt;a href=&quot;#Private-Variables-via-my()&quot;&gt;Variables privadas a trav&amp;eacute;s de my ()&lt;/a&gt; y &lt;a href=&quot;#Temporary-Values-via-local()&quot;&gt;Valores temporales a trav&amp;eacute;s de local ()&lt;/a&gt; . Para crear entornos protegidos para un conjunto de funciones en un paquete separado (y probablemente un archivo separado), consulte &lt;a href=&quot;perlmod#Packages&quot;&gt;Paquetes en perlmod&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="0befd0a8afa8c19a870d175a4fdb840002143042" translate="yes" xml:space="preserve">
          <source>Ask it to create new Perl executable:</source>
          <target state="translated">Pídele que cree un nuevo ejecutable de Perl:</target>
        </trans-unit>
        <trans-unit id="06d5ff26b7db3df6b27e4da48afc0d8940af7b07" translate="yes" xml:space="preserve">
          <source>Ask the current maintainer to make you a co-maintainer or transfer the module to you.</source>
          <target state="translated">Pídele al actual mantenedor que te haga co-mantenedor o que te transfiera el módulo.</target>
        </trans-unit>
        <trans-unit id="640918b79c5c24d060028d2fd27fecdba24558af" translate="yes" xml:space="preserve">
          <source>Ask the server for &quot;helpful information&quot; (that's what the RFC says) on the commands it accepts.</source>
          <target state="translated">Pide al servidor &quot;información útil&quot; (eso es lo que dice el RFC)sobre los comandos que acepta.</target>
        </trans-unit>
        <trans-unit id="29957267ee0cac223134add5f2b52ea620705c23" translate="yes" xml:space="preserve">
          <source>Ask them for it. There are so many email providers available that it's unlikely the local system has any idea how to determine a user's email address.</source>
          <target state="translated">Pídeselo.Hay tantos proveedores de correo electrónico disponibles que es poco probable que el sistema local tenga alguna idea de cómo determinar la dirección de correo electrónico de un usuario.</target>
        </trans-unit>
        <trans-unit id="8175f0d205c5d75254bfd57646dfed8cae5e64df" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are not the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105ecea82b3155461bbe416d044a05c528e58f67" translate="yes" xml:space="preserve">
          <source>Assert that 2 strings are the same.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cd83e9891bd9f5bea1baf962bedc44d308569ef" translate="yes" xml:space="preserve">
          <source>Assertion %s failed: file &quot;%s&quot;, line %d</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49bf55dc112eb3597726ba8ecf785a4fae4cbce0" translate="yes" xml:space="preserve">
          <source>Assertions</source>
          <target state="translated">Assertions</target>
        </trans-unit>
        <trans-unit id="00331b7ae6edef1dff40c7175d1e39fd7f33aa69" translate="yes" xml:space="preserve">
          <source>Assertions are conditions that have to be true; they don't actually match parts of the substring. There are six assertions that are written as backslash sequences.</source>
          <target state="translated">Las afirmaciones son condiciones que tienen que ser verdaderas;en realidad no coinciden con partes de la subcadena.Hay seis afirmaciones que están escritas como secuencias de barra invertida.</target>
        </trans-unit>
        <trans-unit id="ec473104d4054125a1271db8c3a3c454c061191a" translate="yes" xml:space="preserve">
          <source>Assigned Charset Names by IANA</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a86826951e8fe2168fef92e79a3e63e6f4fad1f" translate="yes" xml:space="preserve">
          <source>Assigned value is not %s reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6fd2dd7df68753c5a7360c0d8b35ab5d159443" translate="yes" xml:space="preserve">
          <source>Assigned value is not a reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc266cdcbb6ece4821fb3ad4912b26e12d68bda4" translate="yes" xml:space="preserve">
          <source>Assigning Magic</source>
          <target state="translated">Asignar la magia</target>
        </trans-unit>
        <trans-unit id="50bb715253aae843187816dcb0ecbb87efcdec5e" translate="yes" xml:space="preserve">
          <source>Assigning a filehandle to a bareword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5758c53717d47b26aecb2f1e95a4e608692a5e69" translate="yes" xml:space="preserve">
          <source>Assigning and Dereferencing Variables.</source>
          <target state="translated">Asignación y derivación de variables.</target>
        </trans-unit>
        <trans-unit id="9b18b9bc51526dfb449c1c7223109c18c9530a59" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is fatal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a93015f6058ffbf0e4e5d995a578a534b1b45233" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to $[ is no longer possible</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39852930a7cbed0e34d5b478d338273371ea5664" translate="yes" xml:space="preserve">
          <source>Assigning non-zero to &lt;code&gt;$[&lt;/code&gt; is fatal</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d524a6069dcf850237db76c5b77de165e1b358ee" translate="yes" xml:space="preserve">
          <source>Assigning to References</source>
          <target state="translated">Asignación a las referencias</target>
        </trans-unit>
        <trans-unit id="c279a061dbc31dc7bee97d46022b90f62667a4ac" translate="yes" xml:space="preserve">
          <source>Assigning to a list of private variables to name your arguments:</source>
          <target state="translated">Asignando a una lista de variables privadas para nombrar sus argumentos:</target>
        </trans-unit>
        <trans-unit id="5095fe9fb68e9a62edc8c9686322a7856091bd87" translate="yes" xml:space="preserve">
          <source>Assigning to an entry in the hash will cause the time stamps of the file to be modified. If the file does not exist then it will be created. Assigning a single integer to a hash element will cause both the access and modification times to be changed to that value. Alternatively a reference to an array of two values can be passed. The first array element will be used to set the access time and the second element will be used to set the modification time.</source>
          <target state="translated">Asignar a una entrada en el hash hará que se modifiquen las marcas de tiempo del archivo.Si el archivo no existe,entonces será creado.Asignar un solo entero a un elemento del hash hará que tanto las horas de acceso como las de modificación se cambien a ese valor.Alternativamente,se puede pasar una referencia a una matriz de dos valores.El primer elemento de la matriz se utilizará para establecer el tiempo de acceso y el segundo elemento se utilizará para establecer el tiempo de modificación.</target>
        </trans-unit>
        <trans-unit id="7ca1018fbacf1aa9c5974935df5ed892f5691b8b" translate="yes" xml:space="preserve">
          <source>Assigning to the special variable $[</source>
          <target state="translated">Asignando a la variable especial $[</target>
        </trans-unit>
        <trans-unit id="7bec00ae67953bf63f8b1b3f8ddf8f9255f79d82" translate="yes" xml:space="preserve">
          <source>Assignment Operators</source>
          <target state="translated">Operadores de asignación</target>
        </trans-unit>
        <trans-unit id="91becff514df4bb52422a8c72ad2fa7e138a09c4" translate="yes" xml:space="preserve">
          <source>Assignment is a little bit special in that it uses its left argument to determine the context for the right argument. Assignment to a scalar evaluates the right-hand side in scalar context, while assignment to an array or hash evaluates the righthand side in list context. Assignment to a list (or slice, which is just a list anyway) also evaluates the right-hand side in list context.</source>
          <target state="translated">La asignación es un poco especial en el sentido de que utiliza su argumento izquierdo para determinar el contexto del argumento derecho.La asignación a un escalar evalúa el lado derecho en el contexto del escalar,mientras que la asignación a una matriz o hash evalúa el lado derecho en el contexto de la lista.La asignación a una lista (o trozo,que de todos modos es sólo una lista)también evalúa el lado derecho en el contexto de la lista.</target>
        </trans-unit>
        <trans-unit id="eeb7b7ef33aeb4c3b9e41b0d3c8c37efe141de32" translate="yes" xml:space="preserve">
          <source>Assignment operators work as in C. That is,</source>
          <target state="translated">Los operadores de asignación trabajan como en C.Es decir,</target>
        </trans-unit>
        <trans-unit id="e44ee3c1149f2c21100b91bdf4ef60fbcf7575f3" translate="yes" xml:space="preserve">
          <source>Assignment to a typeglob performs an aliasing operation, i.e.,</source>
          <target state="translated">La asignación a una tipografía realiza una operación de alias,es decir,</target>
        </trans-unit>
        <trans-unit id="efdb1ec14f21e9ed5ad15f6e0bef5c8c9ed1a0b1" translate="yes" xml:space="preserve">
          <source>Assignment to both a list and a scalar</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="101d3fe15227197bfb043f8902c240196099b710" translate="yes" xml:space="preserve">
          <source>Assignment to references and non-references may be combined in lists and conditional ternary expressions, as long as the values on the right-hand side are the right type for each element on the left, though this may make for obfuscated code:</source>
          <target state="translated">La asignación de referencias y no referencias puede combinarse en listas y expresiones ternarias condicionales,siempre y cuando los valores de la parte derecha sean del tipo correcto para cada elemento de la izquierda,aunque esto puede suponer un código ofuscado:</target>
        </trans-unit>
        <trans-unit id="057d58c74d80136578cabbeee1b89206c3250bd4" translate="yes" xml:space="preserve">
          <source>Assignments</source>
          <target state="translated">Assignments</target>
        </trans-unit>
        <trans-unit id="38be444e6e51033245feebeecd19c780a4190e4e" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Backreferences are matching variables that can be used</source>
          <target state="translated">Asociadas con las variables coincidentes &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ... est&amp;aacute;n las &lt;b&gt;referencias inversas &lt;/b&gt; &lt;code&gt;\g1&lt;/code&gt; , &lt;code&gt;\g2&lt;/code&gt; , ... Las referencias inversas son variables coincidentes que se pueden utilizar</target>
        </trans-unit>
        <trans-unit id="de3f3ea1d0b7efcc3a2ee5d6b60bcc68b1043b48" translate="yes" xml:space="preserve">
          <source>Associated with the matching variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, ... are the &lt;b&gt;backreferences&lt;/b&gt;&lt;code&gt;\g1&lt;/code&gt;, &lt;code&gt;\g2&lt;/code&gt;, ... Backreferences are matching variables that can be used</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="68987493bca5f5e7abadf4c61d3d6f22214b34fc" translate="yes" xml:space="preserve">
          <source>Associates an internal FILEHANDLE with the external file specified by EXPR. That filehandle will subsequently allow you to perform I/O operations on that file, such as reading from it or writing to it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6addecb62c84d829e48e459ba05882e03a175023" translate="yes" xml:space="preserve">
          <source>Assume &lt;b&gt;anything&lt;/b&gt; about structs (especially the ones you don't control, like the ones coming from the system headers)</source>
          <target state="translated">Asuma &lt;b&gt;cualquier cosa&lt;/b&gt; sobre estructuras (especialmente las que no controla, como las que provienen de los encabezados del sistema)</target>
        </trans-unit>
        <trans-unit id="9e766ffb9a2f9804774162774bb465b7a888d65a" translate="yes" xml:space="preserve">
          <source>Assume each sentence ends with two spaces and try to preserve that spacing. Without this option, all consecutive whitespace in non-verbatim paragraphs is compressed into a single space.</source>
          <target state="translated">Supongamos que cada frase termina con dos espacios e intentemos preservar ese espacio.Sin esta opción,todos los espacios en blanco consecutivos en los párrafos no verbales se comprimen en un solo espacio.</target>
        </trans-unit>
        <trans-unit id="eb29cb4a3a64a3e55d8f8b66fc5429f33cc90a54" translate="yes" xml:space="preserve">
          <source>Assume four classes, A,B,C &amp;amp; D.</source>
          <target state="translated">Suponga cuatro clases, A, B, C y D.</target>
        </trans-unit>
        <trans-unit id="52c1183f42274e0344acc650141fdfaebc8ac557" translate="yes" xml:space="preserve">
          <source>Assume no one is paying attention and skips prompts for distributions that do that correctly. &lt;code&gt;cpan(1)&lt;/code&gt; sets this to &lt;code&gt;1&lt;/code&gt; unless it already has a value (even if that value is false).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2226e484e68600c3306101e70d0302d670391b19" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;a href=&quot;perlfunc#ord-EXPR&quot;&gt;&lt;code&gt;ord&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;perlfunc#chr-NUMBER&quot;&gt;&lt;code&gt;chr&lt;/code&gt;&lt;/a&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt;. However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/code&gt; are portable, and starting in Perl v5.24, the same ranges are portable in &lt;a href=&quot;perlop#tr%2FSEARCHLIST%2FREPLACEMENTLIST%2Fcdsr&quot;&gt;&lt;code&gt;tr///&lt;/code&gt;&lt;/a&gt;. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="900f642b83bb773e589683695c3e83ec1e64d87c" translate="yes" xml:space="preserve">
          <source>Assume nothing about numerical values (&lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt;) of characters. Do not use explicit code point ranges (like &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . However, starting in Perl v5.22, regular expression pattern bracketed character class ranges specified like &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; are portable. You can portably use symbolic character classes like &lt;code&gt;[:print:]&lt;/code&gt;.</source>
          <target state="translated">No asuma nada sobre los valores num&amp;eacute;ricos ( &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; ) de los caracteres. No utilice rangos de puntos de c&amp;oacute;digo expl&amp;iacute;citos (como &lt;code&gt;\xHH-\xHH)&lt;/code&gt; . Sin embargo, a partir de Perl v5.22, los rangos de clases de caracteres entre corchetes de patrones de expresi&amp;oacute;n regular especificados como &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/[\N{U+HH}-\N{U+HH}]/&lt;/a&gt;&lt;/code&gt; son port&amp;aacute;tiles. Puede utilizar de forma port&amp;aacute;til clases de caracteres simb&amp;oacute;licos como &lt;code&gt;[:print:]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d225542d9c39b42f29197a0ce47f62fa7382a5c0" translate="yes" xml:space="preserve">
          <source>Assume that an integer cannot take less than 20 bytes of memory, a float cannot take less than 24 bytes, a string cannot take less than 32 bytes (all these examples assume 32-bit architectures, the result are quite a bit worse on 64-bit architectures). If a variable is accessed in two of three different ways (which require an integer, a float, or a string), the memory footprint may increase yet another 20 bytes. A sloppy malloc(3) implementation can inflate these numbers dramatically.</source>
          <target state="translated">Supongamos que un entero no puede tomar menos de 20 bytes de memoria,un flotador no puede tomar menos de 24 bytes,una cadena no puede tomar menos de 32 bytes (todos estos ejemplos asumen arquitecturas de 32 bits,el resultado es bastante peor en arquitecturas de 64 bits).Si se accede a una variable de dos o tres maneras diferentes (que requieren un número entero,un flotador o una cadena),la huella de la memoria puede aumentar otros 20 bytes.Una implementación descuidada de malloc(3)puede inflar estos números dramáticamente.</target>
        </trans-unit>
        <trans-unit id="5cf62705d74f3464ae65764bb487f8249da94d46" translate="yes" xml:space="preserve">
          <source>Assume that the old DLL is named</source>
          <target state="translated">Supongamos que el viejo DLL se llama</target>
        </trans-unit>
        <trans-unit id="2605c8584b04c7bf0a2b7cc3badf48edb3bf06d0" translate="yes" xml:space="preserve">
          <source>Assume that you are a seasoned porter, so are sure that all the necessary tools are already present on your system, and you know how to get the Perl source distribution. Untar it, change to the extract directory, and</source>
          <target state="translated">Suponga que es un porteador experimentado,así que esté seguro de que todas las herramientas necesarias ya están presentes en su sistema,y que sabe cómo obtener la distribución de la fuente de Perl.Desátalo,cambia al directorio de extracción,y</target>
        </trans-unit>
        <trans-unit id="111d847871723c094fda67b2b5bccd84d523f158" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1c680a74a55225e27707c2ac5fffa720c70f93" translate="yes" xml:space="preserve">
          <source>Assume this TAP version for &lt;a href=&quot;parser&quot;&gt;TAP::Parser&lt;/a&gt; instead of default TAP version 12.</source>
          <target state="translated">Asuma esta versi&amp;oacute;n de &lt;a href=&quot;parser&quot;&gt;TAP&lt;/a&gt; para TAP :: Parser en lugar de la versi&amp;oacute;n 12 de TAP predeterminada.</target>
        </trans-unit>
        <trans-unit id="7fc8664d84c1446907ca24dadecd0bd664e1d82d" translate="yes" xml:space="preserve">
          <source>Assume very little about character sets.</source>
          <target state="translated">Asumir muy poco sobre los conjuntos de personajes.</target>
        </trans-unit>
        <trans-unit id="14aa653264a55e7f75e0cffdf8147628d06e0a12" translate="yes" xml:space="preserve">
          <source>Assumes that &lt;code&gt;PL_op&lt;/code&gt; is the OP that originally triggered the error, and that &lt;code&gt;PL_comppad&lt;/code&gt;/&lt;code&gt;PL_curpad&lt;/code&gt; points to the currently executing pad.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b3c42e666c3f46061cf3e08ae5f736db9c6b58e" translate="yes" xml:space="preserve">
          <source>Assumes that PL_op is the op that originally triggered the error, and that PL_comppad/PL_curpad points to the currently executing pad.</source>
          <target state="translated">Asume que PL_op es la operación que originalmente disparó el error,y que PL_comppad/PL_curpad apunta a la plataforma de ejecución actual.</target>
        </trans-unit>
        <trans-unit id="40680f85edea3366c2b9e8f14183ac57a5e6081e" translate="yes" xml:space="preserve">
          <source>Assuming NOT a POSIX class since %s in regex; marked by &amp;lt;-- HERE in m/%s/</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85a92465c7801a7593ae125acb124d7a78d00d62" translate="yes" xml:space="preserve">
          <source>Assuming one can dereference any type of pointer for any type of data</source>
          <target state="translated">Asumiendo que se puede derivar cualquier tipo de puntero para cualquier tipo de datos</target>
        </trans-unit>
        <trans-unit id="3eba801518ac20c3e71b66588e69e8412d142226" translate="yes" xml:space="preserve">
          <source>Assuming sizeof(int) == sizeof(long)</source>
          <target state="translated">Asumiendo tamaño(int)==tamaño(largo)</target>
        </trans-unit>
        <trans-unit id="3b4336515b2aaf87ea7abdf5569d5fbbc17ae08d" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt; -files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="translated">Suponiendo que los archivos &lt;code&gt;man&lt;/code&gt; se colocaron en una ubicaci&amp;oacute;n adecuada, esto completa la instalaci&amp;oacute;n del sistema Perl m&amp;iacute;nimo. (La distribuci&amp;oacute;n binaria tambi&amp;eacute;n contiene muchos m&amp;oacute;dulos adicionales y la documentaci&amp;oacute;n en formato INF).</target>
        </trans-unit>
        <trans-unit id="d729092ca24191c5dd2dddf6e45eb913d7433329" translate="yes" xml:space="preserve">
          <source>Assuming that the &lt;code&gt;man&lt;/code&gt;-files were put on an appropriate location, this completes the installation of minimal Perl system. (The binary distribution contains also a lot of additional modules, and the documentation in INF format.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b3d48dcc2393b6165f22e974c8fe37cb11cfa92" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use 'd', 'm' and 'y' respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="translated">Suponiendo que tenemos que hacer coincidir las fechas del calendario que pueden darse en uno de los tres formatos yyyy-mm-dd,mm/dd/yyyy o dd.mm.yyyy,podemos escribir tres patrones adecuados en los que usamos &quot;d&quot;,&quot;m&quot; e &quot;y&quot; respectivamente como los nombres de los grupos que capturan los componentes correspondientes de una fecha.La operación de emparejamiento combina los tres patrones como alternativas:</target>
        </trans-unit>
        <trans-unit id="391cee4ecd3812f9caf92f329d5fa158ab37c5f3" translate="yes" xml:space="preserve">
          <source>Assuming that we have to match calendar dates which may be given in one of the three formats yyyy-mm-dd, mm/dd/yyyy or dd.mm.yyyy, we can write three suitable patterns where we use &lt;code&gt;'d'&lt;/code&gt;, &lt;code&gt;'m'&lt;/code&gt; and &lt;code&gt;'y'&lt;/code&gt; respectively as the names of the groups capturing the pertaining components of a date. The matching operation combines the three patterns as alternatives:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31fc34e986ee3355963fe79a5b72db07365ea4e2" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression (see also &lt;a href=&quot;perlretut&quot;&gt;perlretut&lt;/a&gt; and &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0518d034f096809ab863fb80241126fe45a3c2bb" translate="yes" xml:space="preserve">
          <source>Assuming that you don't care about IEEE notations like &quot;NaN&quot; or &quot;Infinity&quot;, you probably just want to use a regular expression:</source>
          <target state="translated">Asumiendo que no te importan las notaciones del IEEE como &quot;NaN&quot; o &quot;Infinito&quot;,probablemente sólo quieras usar una expresión regular:</target>
        </trans-unit>
        <trans-unit id="c5c2ab31ddb2d4e68552f61633bf186e98613579" translate="yes" xml:space="preserve">
          <source>Assuming the character set is ASCIIish</source>
          <target state="translated">Asumiendo que el conjunto de caracteres es ASCIIish</target>
        </trans-unit>
        <trans-unit id="657e33b27d387873c824a6e9282e0d4e22ed782e" translate="yes" xml:space="preserve">
          <source>Assuming the character set is just ASCII</source>
          <target state="translated">Asumiendo que el conjunto de caracteres es sólo ASCII</target>
        </trans-unit>
        <trans-unit id="f18b4264a48b77c77d31682d53d915137b1c2a2b" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;&quot;savepv&quot; in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e0c2159a115b592c79f24b1d84f43c005948de3" translate="yes" xml:space="preserve">
          <source>Assuming the contents of static memory pointed to by the return values of Perl wrappers for C library functions doesn't change. Many C library functions return pointers to static storage that can be overwritten by subsequent calls to the same or related functions. Perl has light-weight wrappers for some of these functions, and which don't make copies of the static memory. A good example is the interface to the environment variables that are in effect for the program. Perl has &lt;code&gt;PerlEnv_getenv&lt;/code&gt; to get values from the environment. But the return is a pointer to static memory in the C library. If you are using the value to immediately test for something, that's fine, but if you save the value and expect it to be unchanged by later processing, you would be wrong, but perhaps you wouldn't know it because different C library implementations behave differently, and the one on the platform you're testing on might work for your situation. But on some platforms, a subsequent call to &lt;code&gt;PerlEnv_getenv&lt;/code&gt; or related function WILL overwrite the memory that your first call points to. This has led to some hard-to-debug problems. Do a &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv in perlapi&lt;/a&gt; to make a copy, thus avoiding these problems. You will have to free the copy when you're done to avoid memory leaks. If you don't have control over when it gets freed, you'll need to make the copy in a mortal scalar, like so:</source>
          <target state="translated">Suponiendo que el contenido de la memoria est&amp;aacute;tica apuntado por los valores de retorno de los contenedores de Perl para las funciones de la biblioteca C no cambia. Muchas funciones de la biblioteca de C devuelven punteros al almacenamiento est&amp;aacute;tico que pueden sobrescribirse mediante llamadas posteriores a la misma funci&amp;oacute;n o funciones relacionadas. Perl tiene envoltorios livianos para algunas de estas funciones y no hacen copias de la memoria est&amp;aacute;tica. Un buen ejemplo es la interfaz de las variables de entorno que est&amp;aacute;n vigentes para el programa. Perl tiene &lt;code&gt;PerlEnv_getenv&lt;/code&gt; para obtener valores del medio ambiente. Pero el retorno es un puntero a la memoria est&amp;aacute;tica en la biblioteca C. Si est&amp;aacute; utilizando el valor para probar inmediatamente algo, est&amp;aacute; bien, pero si guarda el valor y espera que no se modifique en el procesamiento posterior, estar&amp;iacute;a equivocado, pero quiz&amp;aacute;s no lo sepa porque se comportan diferentes implementaciones de la biblioteca C de manera diferente, y el de la plataforma en la que est&amp;aacute; probando podr&amp;iacute;a funcionar para su situaci&amp;oacute;n. Pero en algunas plataformas, una llamada posterior a &lt;code&gt;PerlEnv_getenv&lt;/code&gt; o una funci&amp;oacute;n relacionada sobrescribir&amp;aacute; la memoria a la que apunta su primera llamada. Esto ha provocado algunos problemas dif&amp;iacute;ciles de depurar. Haz un &lt;a href=&quot;perlapi#savepv&quot;&gt;savepv en perlapi&lt;/a&gt;hacer una copia, evitando as&amp;iacute; estos problemas. Tendr&amp;aacute; que liberar la copia cuando haya terminado para evitar p&amp;eacute;rdidas de memoria. Si no tiene control sobre cu&amp;aacute;ndo se libera, deber&amp;aacute; hacer la copia en un escalar mortal, as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="3368b5431ec704ea21f8185fe92770b3b042af71" translate="yes" xml:space="preserve">
          <source>Assuming the database from the previous example:</source>
          <target state="translated">Suponiendo la base de datos del ejemplo anterior:</target>
        </trans-unit>
        <trans-unit id="37f2465394b9cbdd91947c6e4e077a7d4b7dde8a" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; , overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="translated">Suponiendo que se comporten de forma an&amp;aacute;loga a &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; Perl, se requieren implementaciones sobrecargadas de estos operadores para mutar sus operandos.</target>
        </trans-unit>
        <trans-unit id="3db726b30f88089aabcbf03ff0837b3e46de1fc1" translate="yes" xml:space="preserve">
          <source>Assuming they are to behave analogously to Perl's &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;, overloaded implementations of these operators are required to mutate their operands.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c0a71c399dfe91f864d3abd9d93805888be04d4" translate="yes" xml:space="preserve">
          <source>Assuming we are on the branch &lt;code&gt;blead&lt;/code&gt; immediately after a pull, this command would be more or less equivalent to:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23383c34471c75b25927cfad7162ad1979bea49b" translate="yes" xml:space="preserve">
          <source>Assuming you call your class Projname::L10N, create a class consisting minimally of:</source>
          <target state="translated">Suponiendo que llames a tu clase Projname::L10N,crea una clase que consista mínimamente en:</target>
        </trans-unit>
        <trans-unit id="a8c3ccec4be1ea177d36a955790696ae747518f7" translate="yes" xml:space="preserve">
          <source>Assuming you have good test coverage, your tests should fail with missing dependencies informing the user more strongly that something is wrong. You can write a</source>
          <target state="translated">Asumiendo que tiene una buena cobertura de pruebas,sus pruebas deberían fallar con las dependencias faltantes informando al usuario con más fuerza que algo está mal.Puedes escribir un</target>
        </trans-unit>
        <trans-unit id="562091b17215c5d2dabd5a6d27106f5a063623cd" translate="yes" xml:space="preserve">
          <source>Assuming you know you're dealing with a UTF-8 string, you can find out how long the first character in it is with the &lt;code&gt;UTF8SKIP&lt;/code&gt; macro:</source>
          <target state="translated">Suponiendo que sabe que est&amp;aacute; tratando con una cadena UTF-8, puede averiguar cu&amp;aacute;nto tiempo tiene el primer car&amp;aacute;cter con la macro &lt;code&gt;UTF8SKIP&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="9da798a9d5da7f2f9d9ef9e1b52ebf21c8c17dc7" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; .</source>
          <target state="translated">Suponiendo que est&amp;aacute; ejecutando con permisos suficientes, deber&amp;iacute;a poder establecer la fecha y la hora en todo el sistema ejecutando el programa &lt;code&gt;date(1)&lt;/code&gt; . (No hay forma de establecer la hora y la fecha por proceso). Este mecanismo funcionar&amp;aacute; para Unix, MS-DOS, Windows y NT; el equivalente de VMS es el &lt;code&gt;set &lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; establecido .</target>
        </trans-unit>
        <trans-unit id="02ec0a4ff8284bf3708641e3963c674ad5d28a0e" translate="yes" xml:space="preserve">
          <source>Assuming you're running under sufficient permissions, you should be able to set the system-wide date and time by running the &lt;code&gt;date(1)&lt;/code&gt; program. (There is no way to set the time and date on a per-process basis.) This mechanism will work for Unix, MS-DOS, Windows, and NT; the VMS equivalent is &lt;code&gt;set time&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a50f834fa5c7b73ada293aca740d6156afc09752" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="translated">Suponiendo que su sistema admita tales cosas, simplemente env&amp;iacute;e una se&amp;ntilde;al apropiada al proceso (vea &lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt; ). Es com&amp;uacute;n enviar primero una se&amp;ntilde;al TERM, esperar un poco y luego enviar una se&amp;ntilde;al KILL para terminar.</target>
        </trans-unit>
        <trans-unit id="a095cda27752254d76d70e270420e5ff5d39b90c" translate="yes" xml:space="preserve">
          <source>Assuming your system supports such things, just send an appropriate signal to the process (see &lt;a href=&quot;perlfunc#kill&quot;&gt;&quot;kill&quot; in perlfunc&lt;/a&gt;). It's common to first send a TERM signal, wait a little bit, and then send a KILL signal to finish it off.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="489e70109e67cf9da0e282567e7dfa75ecfec0d5" translate="yes" xml:space="preserve">
          <source>Asynchronous I/O.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34c6deba477e26d8810a3f5cd4114d33aa1e300" translate="yes" xml:space="preserve">
          <source>At 10:23, this function generates the 10th line of a data file; at 3:45 PM it generates the 15th line instead. By default, &lt;code&gt;Memoize&lt;/code&gt; will only see the $problem_type argument. To fix this, include the current hour in the normalizer:</source>
          <target state="translated">A las 10:23, esta funci&amp;oacute;n genera la d&amp;eacute;cima l&amp;iacute;nea de un archivo de datos; a las 3:45 pm genera la l&amp;iacute;nea 15 en su lugar. De forma predeterminada, &lt;code&gt;Memoize&lt;/code&gt; solo ver&amp;aacute; el argumento $ problem_type. Para solucionar este problema, incluya la hora actual en el normalizador:</target>
        </trans-unit>
        <trans-unit id="0d3035d43f34a8f68a2af535ff4afe837cc1bf23" translate="yes" xml:space="preserve">
          <source>At a given character position, the first alternative that allows the regex match to succeed will be the one that matches. Here, all the alternatives match at the first string position, so the first matches.</source>
          <target state="translated">En la posición de un personaje determinado,la primera alternativa que permite que la coincidencia de regex tenga éxito será la que coincida.Aquí,todas las alternativas coinciden en la posición de la primera cuerda,por lo que las primeras coincidencias.</target>
        </trans-unit>
        <trans-unit id="35d56b3c766a2a7d81a6ef179791e69c5926ffe4" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and don't affect the other parts.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa1efd2d4349c6ea79b9b9fc2089c111f8b1ca40" translate="yes" xml:space="preserve">
          <source>At any given time, exactly one of these modifiers is in effect. Their existence allows Perl to keep the originally compiled behavior of a regular expression, regardless of what rules are in effect when it is actually executed. And if it is interpolated into a larger regex, the original's rules continue to apply to it, and only it.</source>
          <target state="translated">En cualquier momento,exactamente uno de estos modificadores está en efecto.Su existencia permite a Perl mantener el comportamiento originalmente compilado de una expresión regular,independientemente de las reglas que están en efecto cuando se ejecuta realmente.Y si se interpola en un regex más grande,las reglas del original continúan aplicándose a él,y sólo a él.</target>
        </trans-unit>
        <trans-unit id="7593f9fb00e51f006212d276b2834d5cb1e7bd4c" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="translated">En cualquier caso, el uso del &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;&lt;/code&gt; o es cuestionable cuando se trata de caracteres Unicode, ya que hay que considerar aspectos como el ancho de los caracteres (es decir, el doble de ancho para ideogramas) y las direcciones (es decir, BIDI para &amp;aacute;rabe y hebreo).</target>
        </trans-unit>
        <trans-unit id="b3d5fa45c550ce1b12a041713732b9ad3afd79b2" translate="yes" xml:space="preserve">
          <source>At any rate, the very use of &lt;code&gt;format&lt;/code&gt; is questionable when it comes to unicode characters since you have to consider such things as character width (i.e. double-width for ideographs) and directions (i.e. BIDI for Arabic and Hebrew).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40530b4cf9ab5b3f6391788f6f588ae031f72498" translate="yes" xml:space="preserve">
          <source>At deserialization time, you will be given back the same LIST, but all the extra references will be pointing into the deserialized structure.</source>
          <target state="translated">En el momento de la deserialización,se le devolverá la misma LISTA,pero todas las referencias extra estarán apuntando a la estructura deserializada.</target>
        </trans-unit>
        <trans-unit id="2359fa76d13a340de35eda7f896e38293fc5d5aa" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</source>
          <target state="translated">En cada nivel de pila, se muestra el nombre de la subrutina junto con sus par&amp;aacute;metros. Para escalares simples, esto es suficiente. Para tipos de datos complejos, como objetos y otras referencias, esto simplemente puede mostrar &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d3499c5b318f8c7ae1f2cab230c6e5e96c7a777c" translate="yes" xml:space="preserve">
          <source>At each stack level, the subroutine's name is displayed along with its parameters. For simple scalars, this is sufficient. For complex data types, such as objects and other references, this can simply display &lt;code&gt;'HASH(0x1ab36d8)'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="396433f01b9bc30bd1dc987a608f2db8a7b54ded" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">En los puntos de entrada a perl, como &lt;code&gt;perl_parse()&lt;/code&gt; , &lt;code&gt;perl_run()&lt;/code&gt; y &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; cada uno hace un &lt;code&gt;JMPENV_PUSH&lt;/code&gt; , luego ingresa un bucle de runops o lo que sea, y maneja posibles devoluciones de excepci&amp;oacute;n. Para un retorno 2, se realiza una limpieza final, como hacer estallar las pilas y llamar a los bloques &lt;code&gt;CHECK&lt;/code&gt; o &lt;code&gt;END&lt;/code&gt; . Entre otras cosas, as&amp;iacute; es como se sigue realizando la limpieza del alcance durante una &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2c5843723152f1754465e406a2b90b574561ffc4" translate="yes" xml:space="preserve">
          <source>At entry points to perl, such as &lt;code&gt;perl_parse()&lt;/code&gt;, &lt;code&gt;perl_run()&lt;/code&gt; and &lt;code&gt;call_sv(cv, G_EVAL)&lt;/code&gt; each does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt;, then enter a runops loop or whatever, and handle possible exception returns. For a 2 return, final cleanup is performed, such as popping stacks and calling &lt;code&gt;CHECK&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt; blocks. Amongst other things, this is how scope cleanup still occurs during an &lt;code&gt;exit&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3b52a6611c3d532a492a587178e19cf7d8fea481" translate="yes" xml:space="preserve">
          <source>At first glance, you'd think that it shouldn't print, because obviously the &lt;code&gt;ddd&lt;/code&gt; isn't going to match the target string. But look at this example:</source>
          <target state="translated">A primera vista, pensar&amp;iacute;a que no deber&amp;iacute;a imprimirse, porque obviamente el &lt;code&gt;ddd&lt;/code&gt; no va a coincidir con la cadena de destino. Pero mira este ejemplo:</target>
        </trans-unit>
        <trans-unit id="a20d2e5d0ab73a1c97b3463749bc6385228a9028" translate="yes" xml:space="preserve">
          <source>At least for consistency with WinNT, you should keep the recommended value.</source>
          <target state="translated">Al menos para la consistencia con el WinNT,deberías mantener el valor recomendado.</target>
        </trans-unit>
        <trans-unit id="27bd45d9389cf551091228f338420922ea6613d9" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt; , respectively.</source>
          <target state="translated">Al menos en Unix puede superar esto aumentando los l&amp;iacute;mites de tama&amp;ntilde;o de datos de su proceso: en csh / tcsh use &lt;code&gt;limit&lt;/code&gt; y &lt;code&gt;limit datasize n&lt;/code&gt; (donde &lt;code&gt;n&lt;/code&gt; es el n&amp;uacute;mero de kilobytes) para verificar los l&amp;iacute;mites actuales y cambiarlos, y en ksh / bash / zsh usa &lt;code&gt;ulimit -a&lt;/code&gt; y &lt;code&gt;ulimit -d n&lt;/code&gt; , respectivamente.</target>
        </trans-unit>
        <trans-unit id="66f7b8a4f3dad67cd26cb07eaab73c32a3b79d31" translate="yes" xml:space="preserve">
          <source>At least in Unix you may be able to get past this by increasing your process datasize limits: in csh/tcsh use &lt;code&gt;limit&lt;/code&gt; and &lt;code&gt;limit datasize n&lt;/code&gt; (where &lt;code&gt;n&lt;/code&gt; is the number of kilobytes) to check the current limits and change them, and in ksh/bash/zsh use &lt;code&gt;ulimit -a&lt;/code&gt; and &lt;code&gt;ulimit -d n&lt;/code&gt;, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be275e2a07874324b642ea6224748e1cc7c92b91" translate="yes" xml:space="preserve">
          <source>At least it's backwards compatible in not doing much.</source>
          <target state="translated">Al menos es compatible al revés en no hacer mucho.</target>
        </trans-unit>
        <trans-unit id="9e14e0bb06602e8d806ecd5603df3d1331d55d06" translate="yes" xml:space="preserve">
          <source>At least one of &lt;code&gt;s1&lt;/code&gt; and &lt;code&gt;s2&lt;/code&gt; must have a goal (at least one of &lt;code&gt;l1&lt;/code&gt; and &lt;code&gt;l2&lt;/code&gt; must be non-zero), and if both do, both have to be reached for a successful match. Also, if the fold of a character is multiple characters, all of them must be matched (see tr21 reference below for 'folding').</source>
          <target state="translated">Al menos uno de &lt;code&gt;s1&lt;/code&gt; y &lt;code&gt;s2&lt;/code&gt; debe tener un objetivo (al menos uno de &lt;code&gt;l1&lt;/code&gt; y &lt;code&gt;l2&lt;/code&gt; debe ser distinto de cero), y si ambos lo tienen, ambos deben alcanzarse para una coincidencia exitosa. Adem&amp;aacute;s, si el pliegue de un personaje es de varios caracteres, todos deben coincidir (consulte la referencia de tr21 a continuaci&amp;oacute;n para ver &quot;plegado&quot;).</target>
        </trans-unit>
        <trans-unit id="9972c1cfc00f54bc3d4bf6854c0d9453527f2493" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="translated">Al menos las tres funciones integradas &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined(...)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists(...)&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof(...)&lt;/a&gt;&lt;/code&gt; . Alg&amp;uacute;n d&amp;iacute;a podr&amp;iacute;amos agregar m&amp;aacute;s de estos m&amp;aacute;s adelante si pensamos en ellos.</target>
        </trans-unit>
        <trans-unit id="36309277752b244d6584b5ffd8f2594deef16e94" translate="yes" xml:space="preserve">
          <source>At least the three builtin functions &lt;code&gt;defined(...)&lt;/code&gt;, &lt;code&gt;exists(...)&lt;/code&gt;, and &lt;code&gt;eof(...)&lt;/code&gt;. We might someday add more of these later if we think of them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc8bf4c3c86adf3ceb8a466491ba399fbc2b4c86" translate="yes" xml:space="preserve">
          <source>At line number 4 is a helpful pointer, that tells you where you are now. To see more code, type 'v' again:</source>
          <target state="translated">En la línea 4 hay un útil puntero,que te dice dónde estás ahora.Para ver más código,teclea 'v' de nuevo:</target>
        </trans-unit>
        <trans-unit id="0f8b916c14aa42230cca14b7fbe9aee5db398694" translate="yes" xml:space="preserve">
          <source>At one time, it was legal in some standards to have code points up to 0x7FFF_FFFF, but not higher, and this code point is higher.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3706bce960e08579e2a93b26085ef7458b3bba0d" translate="yes" xml:space="preserve">
          <source>At present that list is: weaken, isweak, dualvar, isvstring, set_prototype</source>
          <target state="translated">Actualmente esa lista es:weak,isweak,dualvar,isvstring,set_prototype</target>
        </trans-unit>
        <trans-unit id="945b483b1ccbe65e925900ec39e83bbc97a9ab8a" translate="yes" xml:space="preserve">
          <source>At present the following compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a9a7ccc891020b1abe97ef7e238b5077a99ae99b" translate="yes" xml:space="preserve">
          <source>At present three compression methods are supported by IO::Compress::Zip, namely Store (no compression at all), Deflate, Bzip2 and LZMA.</source>
          <target state="translated">Actualmente hay tres métodos de compresión soportados por IO::Compress::Zip,a saber:Store (sin compresión),Deflate,Bzip2 y LZMA.</target>
        </trans-unit>
        <trans-unit id="c6f3b56326d807044d12f7fa90b19c7ea2469f7b" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="translated">En la actualidad, la primera vez que itera sobre% ENV utilizando &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; , incurrir&amp;aacute; en una penalizaci&amp;oacute;n de tiempo ya que se leen todos los nombres l&amp;oacute;gicos, para completar% ENV. Las iteraciones posteriores no volver&amp;aacute;n a leer los nombres l&amp;oacute;gicos, por lo que no ser&amp;aacute;n tan lentos, pero tampoco reflejar&amp;aacute;n ning&amp;uacute;n cambio en las tablas de nombres l&amp;oacute;gicos causado por otros programas.</target>
        </trans-unit>
        <trans-unit id="214ce8ba80d0a179d1db87f227b4915a835aed62" translate="yes" xml:space="preserve">
          <source>At present, the first time you iterate over %ENV using &lt;code&gt;keys&lt;/code&gt;, or &lt;code&gt;values&lt;/code&gt;, you will incur a time penalty as all logical names are read, in order to fully populate %ENV. Subsequent iterations will not reread logical names, so they won't be as slow, but they also won't reflect any changes to logical name tables caused by other programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25d8707372413087d65e69b61d9a6dc703b71cf2" translate="yes" xml:space="preserve">
          <source>At run time, each listed plugin is instantiated as a singleton object by running the equivalent of this pseudo code:</source>
          <target state="translated">En tiempo de ejecución,cada plugin listado es instanciado como un objeto de un solo botón ejecutando el equivalente de este pseudo código:</target>
        </trans-unit>
        <trans-unit id="0346a8b0d676351a6882db32e2f71fe2cd6612af" translate="yes" xml:space="preserve">
          <source>At run-time you can use:</source>
          <target state="translated">En tiempo de ejecución puedes usar:</target>
        </trans-unit>
        <trans-unit id="14c311a97bb302da658b5d5c146d94913481c6a7" translate="yes" xml:space="preserve">
          <source>At some moment the built may die, reporting a</source>
          <target state="translated">En algún momento el construido puede morir,reportando un</target>
        </trans-unit>
        <trans-unit id="fdde3eae592d85a1bbf81dc1dcb5f03f478df9d3" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agreed to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8f94eca0c2d56d19683ad85c3b3f54fed0ab0893" translate="yes" xml:space="preserve">
          <source>At the 2008 QA Hackathon in Oslo, Perl module toolchain maintainers agrees to use the CPAN Meta format to communicate post-configuration requirements between toolchain components. These files,</source>
          <target state="translated">En el QA Hackathon de 2008 en Oslo,los mantenedores de la cadena de herramientas del módulo Perl acuerdan utilizar el formato CPAN Meta para comunicar los requisitos de postconfiguración entre los componentes de la cadena de herramientas.Estos archivos,</target>
        </trans-unit>
        <trans-unit id="86950d72bad1114392fd499fea36a75e7faf16d6" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt; . Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="translated">A costa de una ligera sobrecarga de encabezado, puede almacenar en un descriptor de archivo ya abierto utilizando la rutina &lt;code&gt;store_fd&lt;/code&gt; y recuperar de un archivo a trav&amp;eacute;s de &lt;code&gt;fd_retrieve&lt;/code&gt; . Esos nombres no se importan de forma predeterminada, por lo que tendr&amp;aacute; que hacerlo expl&amp;iacute;citamente si necesita esas rutinas. El descriptor de archivo que proporcione debe estar ya abierto, para leerlo si lo va a recuperar y para escribir si desea almacenarlo.</target>
        </trans-unit>
        <trans-unit id="e5ffbd456858663ac301bf7789eac1b059f62c98" translate="yes" xml:space="preserve">
          <source>At the cost of a slight header overhead, you may store to an already opened file descriptor using the &lt;code&gt;store_fd&lt;/code&gt; routine, and retrieve from a file via &lt;code&gt;fd_retrieve&lt;/code&gt;. Those names aren't imported by default, so you will have to do that explicitly if you need those routines. The file descriptor you supply must be already opened, for read if you're going to retrieve and for write if you wish to store.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5655f269f9dae667811a30ef2f8f926fc9530ad6" translate="yes" xml:space="preserve">
          <source>At the end of</source>
          <target state="translated">Al final de</target>
        </trans-unit>
        <trans-unit id="9572ac86c1b1da5c7ab83dd35ce00912ee7e613d" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;. You can override that with an explicit &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="translated">Al final de todos los bloques &lt;code&gt;when&lt;/code&gt; , hay un &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; impl&amp;iacute;cito . Puede anular eso con un &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; expl&amp;iacute;cito si est&amp;aacute; interesado solo en la primera coincidencia.</target>
        </trans-unit>
        <trans-unit id="1e41ae8e63f613457fbc688a05901eda0e76d2fb" translate="yes" xml:space="preserve">
          <source>At the end of all &lt;code&gt;when&lt;/code&gt; blocks, there is an implicit &lt;code&gt;next&lt;/code&gt;. You can override that with an explicit &lt;code&gt;last&lt;/code&gt; if you're interested in only the first match alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca6a702d6cdcdadecdbaeb43444eca515cc146c7" translate="yes" xml:space="preserve">
          <source>At the end of the parse, call &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; to get the tree's top node.</source>
          <target state="translated">Al final del an&amp;aacute;lisis, llame a &lt;code&gt;$parser-&amp;gt;root&lt;/code&gt; para obtener el nodo superior del &amp;aacute;rbol.</target>
        </trans-unit>
        <trans-unit id="7dfefef1d68ca5b408b29dae9e3fff68c7b274a2" translate="yes" xml:space="preserve">
          <source>At the end of the subtest, the final &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event is sent to the formatter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07a9cc69765068861817ec41e4a7228bd113195b" translate="yes" xml:space="preserve">
          <source>At the lowest level, the macros new_SV() and del_SV() grab and free an SV head. (If debugging with -DD, del_SV() calls the function S_del_sv() to return the SV to the free list with error checking.) new_SV() calls more_sv() / sv_add_arena() to add an extra arena if the free list is empty. SVs in the free list have their SvTYPE field set to all ones.</source>
          <target state="translated">En el nivel más bajo,las macros new_SV()y del_SV()agarran y liberan una cabeza SV.(Si se depura con -DD,del_SV()llama a la función S_del_sv()para devolver el SV a la lista libre con comprobación de errores).new_SV()llama a more_sv()/sv_add_arena()para añadir un campo extra si la lista libre está vacía.Los SV de la lista libre tienen su campo SvTYPE establecido en todos.</target>
        </trans-unit>
        <trans-unit id="6089cbc08fb43732445842a261366b161cee7872" translate="yes" xml:space="preserve">
          <source>At the moment of writing, AIX supports two different native C compilers, for which you have to pay: &lt;b&gt;xlC&lt;/b&gt; and &lt;b&gt;vac&lt;/b&gt;. If you decide to use either of these two (which is quite a lot easier than using gcc), be sure to upgrade to the latest available patch level. Currently:</source>
          <target state="translated">En el momento de escribir este art&amp;iacute;culo, AIX admite dos compiladores nativos de C diferentes, por los que debe pagar: &lt;b&gt;xlC&lt;/b&gt; y &lt;b&gt;vac&lt;/b&gt; . Si decide usar cualquiera de estos dos (que es mucho m&amp;aacute;s f&amp;aacute;cil que usar gcc), aseg&amp;uacute;rese de actualizar al &amp;uacute;ltimo nivel de parche disponible. Actualmente:</target>
        </trans-unit>
        <trans-unit id="af7b9b33fafaf83f9420acb89bb16618e9123d52" translate="yes" xml:space="preserve">
          <source>At the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.</source>
          <target state="translated">A riesgo de afirmar lo obvio,los módulos están pensados para ser modulares.Un desarrollador de Perl debe ser capaz de utilizar los módulos para armar los bloques de construcción de su aplicación.Sin embargo,es importante que los bloques tengan la forma correcta,y que el desarrollador no tenga que usar un bloque grande cuando todo lo que necesita es uno pequeño.</target>
        </trans-unit>
        <trans-unit id="1014d039b0716d418675db8cd3420cc810aff463" translate="yes" xml:space="preserve">
          <source>At the same time, this pragma cannot detect when such a module has installed from CPAN to the core library, and so it would endlessly and uselessly exhort the user to upgrade.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2c548d72452435d78a5e713661472ad87fa3347" translate="yes" xml:space="preserve">
          <source>At the time of this writing (2009-03) there are three YAML implementations working: YAML, YAML::Syck, and YAML::XS. The latter two are faster but need a C compiler installed on your system. There may be more alternative YAML conforming modules. When I tried two other players, YAML::Tiny and YAML::Perl, they seemed not powerful enough to work with CPAN.pm. This may have changed in the meantime.</source>
          <target state="translated">En el momento de escribir este informe (2009-03)hay tres implementaciones de YAML funcionando:YAML,YAML::Syck,y YAML::XS.Las dos últimas son más rápidas pero necesitan un compilador C instalado en su sistema.Puede haber más módulos alternativos conformes a YAML.Cuando probé otros dos reproductores,YAML::Tiny y YAML::Perl,no parecían ser lo suficientemente potentes para trabajar con CPAN.pm.Esto puede haber cambiado mientras tanto.</target>
        </trans-unit>
        <trans-unit id="7ea634c02baa48b31e81ed3a00831f7dcbb2e678" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt;
&quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="translated">En el momento de escribir este art&amp;iacute;culo (junio de 2002), existe un error conocido en la impresi&amp;oacute;n de la libc Tru64 de dobles largos cuando no se usa la notaci&amp;oacute;n &quot;e&quot;. Los valores son correctos y utilizables, pero solo se muestra un n&amp;uacute;mero limitado de d&amp;iacute;gitos a menos que fuerce el problema usando &lt;code&gt;&lt;a href=&quot;functions/printf&quot;&gt;printf&lt;/a&gt; &quot;%.33e&quot;,$num&lt;/code&gt; o similar. Para las versiones de Tru64 V5.0A a V5.1A, se espera un parche en alg&amp;uacute;n momento despu&amp;eacute;s del lanzamiento de perl 5.8.0. Si su libc a&amp;uacute;n no ha sido parcheada, recibir&amp;aacute; una advertencia de Configurar cuando seleccione dobles largos.</target>
        </trans-unit>
        <trans-unit id="cff077ec447ff4f924a23e0da4a7a4062c468c7a" translate="yes" xml:space="preserve">
          <source>At the time of this writing (June 2002), there is a known bug in the Tru64 libc printing of long doubles when not using &quot;e&quot; notation. The values are correct and usable, but you only get a limited number of digits displayed unless you force the issue by using &lt;code&gt;printf &quot;%.33e&quot;,$num&lt;/code&gt; or the like. For Tru64 versions V5.0A through V5.1A, a patch is expected sometime after perl 5.8.0 is released. If your libc has not yet been patched, you'll get a warning from Configure when selecting long doubles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1867a801fe6f9af5a7aceadb824f2be69014eb61" translate="yes" xml:space="preserve">
          <source>At the time of this writing, Perl 5.18.0 is considered to be well-hardened against algorithmic complexity attacks on its hash implementation. This is largely owed to the following measures mitigate attacks:</source>
          <target state="translated">En el momento de redactar el presente documento,se considera que Perl 5.18.0 está bien endurecido contra los ataques de complejidad algorítmica en su implementación de hachís.Esto se debe en gran medida a las siguientes medidas para mitigar los ataques:</target>
        </trans-unit>
        <trans-unit id="8a33c676d1f79e763827316ea86000a157f0da7a" translate="yes" xml:space="preserve">
          <source>At the time of very final cleanup, sv_free_arenas() is called from perl_destruct() to physically free all the arenas allocated since the start of the interpreter.</source>
          <target state="translated">En el momento de la limpieza final,se llama a sv_free_arenas()desde perl_destruct()para liberar físicamente todas las arenas asignadas desde el inicio del intérprete.</target>
        </trans-unit>
        <trans-unit id="4ad7685293e30733157e0b0115df9c2bbc818321" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current &quot;a&quot; sub, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">En el momento en que se crea f,no puede capturar la actual subrutina &quot;a&quot;,ya que la subrutina anónima aún no ha sido creada.Por el contrario,lo siguiente no dará una advertencia ya que la subrutina anónima ya ha sido creada y está en vivo:</target>
        </trans-unit>
        <trans-unit id="c7f753fb79bacf696f44e6edc3ce403746b9d93b" translate="yes" xml:space="preserve">
          <source>At the time that f is created, it can't capture the current value of $a, since the anonymous subroutine hasn't been created yet. Conversely, the following won't give a warning since the anonymous subroutine has by now been created and is live:</source>
          <target state="translated">En el momento en que se crea f,no puede capturar el valor actual de $a,ya que la subrutina anónima aún no ha sido creada.Por el contrario,lo siguiente no dará una advertencia ya que la subrutina anónima ya ha sido creada y está activa:</target>
        </trans-unit>
        <trans-unit id="9d72f28fef349b76a0adf7f5f7156e5e3f38d89f" translate="yes" xml:space="preserve">
          <source>At the time this document was last updated, Cygwin 1.7.16 was current.</source>
          <target state="translated">En el momento de la última actualización de este documento,Cygwin 1.7.16 estaba vigente.</target>
        </trans-unit>
        <trans-unit id="568132008f8ee29811084c20ba8f801b1aedb463" translate="yes" xml:space="preserve">
          <source>At the very least, this is useful to see what the SelfLoader thinks are stubs - in order to ensure future versions of the SelfStubber remain in step with the SelfLoader, the SelfStubber actually uses the SelfLoader to determine which stubs are needed.</source>
          <target state="translated">Al menos,esto es útil para ver lo que el autocargador piensa que son los talones-para asegurar que las futuras versiones del autocargador se mantengan en sintonía con el autocargador,el autocargador utiliza realmente el autocargador para determinar qué talones se necesitan.</target>
        </trans-unit>
        <trans-unit id="9d086f75055dc823d417d876f240b4ce1aa5f40a" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass needs to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c88d3fd177dc36a169a0f390f88ed358e376c27" translate="yes" xml:space="preserve">
          <source>At the very minimum, any subclass will need to provide its own &lt;code&gt;new()&lt;/code&gt; and can store additional hash keys in the object. There are also some package globals that must be defined, e.g.:</source>
          <target state="translated">Como m&amp;iacute;nimo, cualquier subclase deber&amp;aacute; proporcionar su propio &lt;code&gt;new()&lt;/code&gt; y puede almacenar claves hash adicionales en el objeto. Tambi&amp;eacute;n hay algunos paquetes globales que deben definirse, por ejemplo:</target>
        </trans-unit>
        <trans-unit id="edcf8fa241edee8ba6be389a9320a43680a858f9" translate="yes" xml:space="preserve">
          <source>At this point, if you're using the</source>
          <target state="translated">En este punto,si estás usando el</target>
        </trans-unit>
        <trans-unit id="5a6511c6f50957ea6c619917499bccc60b76c492" translate="yes" xml:space="preserve">
          <source>At this point, we have all the basic regexp concepts covered, so let's give a more involved example of a regular expression. We will build a regexp that matches numbers.</source>
          <target state="translated">En este punto,tenemos todos los conceptos básicos de regexp cubiertos,por lo que vamos a dar un ejemplo más involucrado de una expresión regular.Construiremos un regexp que coincida con los números.</target>
        </trans-unit>
        <trans-unit id="370a5cf660692a42903691231af5dc8e0071bc25" translate="yes" xml:space="preserve">
          <source>At this point, xsubpp is doing very little work - the differences between Mytest.xs and Mytest.c are minimal.</source>
          <target state="translated">En este momento,xsubpp está haciendo muy poco trabajo-las diferencias entre Mytest.xs y Mytest.c son mínimas.</target>
        </trans-unit>
        <trans-unit id="4cb351d8164d812dc7e335f6aa1c330c2f5b0d24" translate="yes" xml:space="preserve">
          <source>At this time, &lt;code&gt;study&lt;/code&gt; does nothing. This may change in the future.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e93ae94dda2105286d8d2c3c0189888d8aa45b7" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; in ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="translated">En el momento de escribir este art&amp;iacute;culo, los valores de &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; son de dos tipos: el nombre de una p&amp;aacute;gina Pod como &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (que puede ser un m&amp;oacute;dulo o programa Perl real en un directorio @INC / PATH, o un archivo .pod en esos lugares); o el nombre de una p&amp;aacute;gina de manual de Unix, como &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt; . En teor&amp;iacute;a, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; ambiguo entre una p&amp;aacute;gina Pod llamada &quot;chmod&quot; o la p&amp;aacute;gina man de Unix &quot;chmod&quot; (en cualquier secci&amp;oacute;n man). Sin embargo, la presencia de una cadena en parens, como en &quot;crontab (5)&quot;, es suficiente para se&amp;ntilde;alar que lo que se est&amp;aacute; discutiendo no es una p&amp;aacute;gina Pod, y por tanto, presumiblemente es una p&amp;aacute;gina man de Unix. La distinci&amp;oacute;n no tiene importancia para muchos procesadores Pod,pero algunos procesadores que renderizan en formatos de hipertexto pueden necesitar distinguirlos para saber c&amp;oacute;mo renderizar un determinado &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; C&amp;oacute;digo L &amp;lt;foo&amp;gt; .</target>
        </trans-unit>
        <trans-unit id="1402e155751b829c93df5128b5d19d797691621a" translate="yes" xml:space="preserve">
          <source>At time of writing, &lt;code&gt;L&amp;lt;name&amp;gt;&lt;/code&gt; values are of two types: either the name of a Pod page like &lt;code&gt;L&amp;lt;Foo::Bar&amp;gt;&lt;/code&gt; (which might be a real Perl module or program in an @INC / PATH directory, or a .pod file in those places); or the name of a Unix man page, like &lt;code&gt;L&amp;lt;crontab(5)&amp;gt;&lt;/code&gt;. In theory, &lt;code&gt;L&amp;lt;chmod&amp;gt;&lt;/code&gt; is ambiguous between a Pod page called &quot;chmod&quot;, or the Unix man page &quot;chmod&quot; (in whatever man-section). However, the presence of a string in parens, as in &quot;crontab(5)&quot;, is sufficient to signal that what is being discussed is not a Pod page, and so is presumably a Unix man page. The distinction is of no importance to many Pod processors, but some processors that render to hypertext formats may need to distinguish them in order to know how to render a given &lt;code&gt;L&amp;lt;foo&amp;gt;&lt;/code&gt; code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="24f8d626a483cf6ebf2f3cd6cefe211ee98242ab" translate="yes" xml:space="preserve">
          <source>At time of writing, I don't think you'll need to use this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b127225208f5ac9bbb6a72b48b20b7d3616ff18" translate="yes" xml:space="preserve">
          <source>Atari MiNT</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f3342f30bf4c3977d537b68719b3f6636e25cb1" translate="yes" xml:space="preserve">
          <source>Athena</source>
          <target state="translated">Athena</target>
        </trans-unit>
        <trans-unit id="fb5b8f9948a5df2cd992c1e84448561317bc6a25" translate="yes" xml:space="preserve">
          <source>Atrributes such as package, file, and caller are determined automatically, and cannot be specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3493cb8763751f88e1926ab01085068e369734c9" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://man.he.net/man2/shmat&quot;&gt;shmat(2)&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d759da54d18d185bb5ccfc037b889a6ccc296532" translate="yes" xml:space="preserve">
          <source>Attach the shared memory segment identified by ID to the address space of the calling process. See &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt;.</source>
          <target state="translated">Adjunte el segmento de memoria compartida identificado por ID al espacio de direcciones del proceso de llamada. Ver &lt;a href=&quot;http://search.cpan.org/perldoc/shmat&quot;&gt;shmat&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="225d31a7a030cd02427cb0b7456aa1f815b2914d" translate="yes" xml:space="preserve">
          <source>Attaching &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; to arrays is permissible but has no effect.</source>
          <target state="translated">Se &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; adjuntar PERL_MAGIC_uvar a matrices, pero no tiene ning&amp;uacute;n efecto.</target>
        </trans-unit>
        <trans-unit id="d423c0cfec188bd6ee98e700b49e9beb58a1ac55" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication.</source>
          <target state="translated">Intenta la autentificación del SASL.</target>
        </trans-unit>
        <trans-unit id="a57d83a2b0e335a567209ea75d9a6f7c18c72eb5" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module.</source>
          <target state="translated">Intenta la autentificación del SASL.Requiere Authen::Módulo SASL.</target>
        </trans-unit>
        <trans-unit id="ccd854e11a4d11e3e9e58ceb95944b13ef3a518a" translate="yes" xml:space="preserve">
          <source>Attempt SASL authentication. Requires Authen::SASL module. The first form constructs a new Authen::SASL object using the given username and password; the second form uses the given Authen::SASL object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="883f5c19fa9ca67ce62c443fd2ce7bac60b6089d" translate="yes" xml:space="preserve">
          <source>Attempt to access disallowed key '%s' in a restricted hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cf0ab65502bfcdd00cde497405332ccea4e648b" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a freed package</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8614ea5fd745bc313cc5245a331edbc4dddec890" translate="yes" xml:space="preserve">
          <source>Attempt to bless into a reference</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfa31d2d4671313bd0af54f4bb1d33e8b3d1352" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt; . If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt; , the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="translated">Intente cambiar el directorio al directorio dado en &lt;code&gt;$dir&lt;/code&gt; . Si &lt;code&gt;$dir&lt;/code&gt; es &lt;code&gt;&quot;..&quot;&lt;/code&gt; , el comando FTP &lt;code&gt;CDUP&lt;/code&gt; se utiliza para intentar subir un directorio. Si no se proporciona ning&amp;uacute;n directorio, se intentar&amp;aacute; cambiar el directorio al directorio ra&amp;iacute;z.</target>
        </trans-unit>
        <trans-unit id="6f0b75ab4748fe5742f8fdfbfa72a1464729d3b5" translate="yes" xml:space="preserve">
          <source>Attempt to change directory to the directory given in &lt;code&gt;$dir&lt;/code&gt;. If &lt;code&gt;$dir&lt;/code&gt; is &lt;code&gt;&quot;..&quot;&lt;/code&gt;, the FTP &lt;code&gt;CDUP&lt;/code&gt; command is used to attempt to move up one directory. If no directory is given then an attempt is made to change the directory to the root directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6aef18d28c95173a99a1a9cd9b174366e83e56c" translate="yes" xml:space="preserve">
          <source>Attempt to clear deleted array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f1a553fb01152c680db2f1ac04b66addb3e1a32b" translate="yes" xml:space="preserve">
          <source>Attempt to convert an absolute file specification to a relative specification.</source>
          <target state="translated">Intenta convertir una especificación de archivo absoluta en una especificación relativa.</target>
        </trans-unit>
        <trans-unit id="2c4880c9fdd4f4d9c5b79e2c012fb0e250d383e7" translate="yes" xml:space="preserve">
          <source>Attempt to delete disallowed key '%s' from a restricted hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0798ebadbab9bffb1e99c85507d3edee83caa008" translate="yes" xml:space="preserve">
          <source>Attempt to delete readonly key '%s' from a restricted hash</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6a6104d31483a82798cc43a56c3040f5b0e5915" translate="yes" xml:space="preserve">
          <source>Attempt to destroy all objects not yet freed.</source>
          <target state="translated">Intenta destruir todos los objetos que aún no han sido liberados.</target>
        </trans-unit>
        <trans-unit id="fe99a6ee8775c38ae61fdc7b8491eb15dc3ce181" translate="yes" xml:space="preserve">
          <source>Attempt to evaluate the current host's internet name and domain</source>
          <target state="translated">Intentar evaluar el nombre y el dominio de Internet del actual anfitrión</target>
        </trans-unit>
        <trans-unit id="80fda9c03868b272773d0d41887e0dbe18413719" translate="yes" xml:space="preserve">
          <source>Attempt to free non-arena SV: 0x%x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54d38b115a5aa938320799c6531228c69b9fa275" translate="yes" xml:space="preserve">
          <source>Attempt to free nonexistent shared string '%s'%s</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b479273a362ea2e8c34f077e9e3c6360ab77808" translate="yes" xml:space="preserve">
          <source>Attempt to free temp prematurely: SV 0x%x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a34a51b6be5af9431919f62ebe158c42fa203ea7" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced glob pointers</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40f310189c328c36df3675b24385fea4a52ffa6b" translate="yes" xml:space="preserve">
          <source>Attempt to free unreferenced scalar: SV 0x%x</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51aff28048c322c0b88140e9c1dcb9278d5b60c1" translate="yes" xml:space="preserve">
          <source>Attempt to pack pointer to temporary value</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="078cb982d4d92298b47355c08e74e2f224c181c7" translate="yes" xml:space="preserve">
          <source>Attempt to print summary information if run is interrupted by SIGINT (Ctrl-C).</source>
          <target state="translated">Intente imprimir información resumida si la ejecución es interrumpida por el SIGINT (Ctrl-C).</target>
        </trans-unit>
        <trans-unit id="b914600bb82ac0ae87b3e9ab97d2d1c2f3efb3a8" translate="yes" xml:space="preserve">
          <source>Attempt to produce color output.</source>
          <target state="translated">Intenta producir una salida de color.</target>
        </trans-unit>
        <trans-unit id="efb3613b13587fe1f93cf60bf899f24390374124" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt; .</source>
          <target state="translated">Intente leer bytes de &lt;code&gt;$length&lt;/code&gt; de datos sin comprimir en &lt;code&gt;$buffer&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="09a9c5fb7a8cb670c472dd87151c6343a5662154" translate="yes" xml:space="preserve">
          <source>Attempt to read &lt;code&gt;$length&lt;/code&gt; bytes of uncompressed data into &lt;code&gt;$buffer&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e9d551547de808708f971d391e53086cf3f44fc" translate="yes" xml:space="preserve">
          <source>Attempt to reload %s aborted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87c4ceba341469a694caa6a8c164987d97a35645" translate="yes" xml:space="preserve">
          <source>Attempt to set length of freed array</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cee621066cdf5eff50fe796c90fc14083ab2dd15" translate="yes" xml:space="preserve">
          <source>Attempt to use reference as lvalue in substr</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b92f951c7fd86ee7f7ec9db2ae7b702bd512a11" translate="yes" xml:space="preserve">
          <source>Attempting to inherit from yourself generates a warning.</source>
          <target state="translated">Intentar heredar de ti mismo genera una advertencia.</target>
        </trans-unit>
        <trans-unit id="940068c4484917346e58cd849ab63ab658a04374" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="translated">Intentar empaquetar los valores especiales de coma flotante &lt;code&gt;Inf&lt;/code&gt; y &lt;code&gt;NaN&lt;/code&gt; (infinito, tambi&amp;eacute;n en negativo, y no un n&amp;uacute;mero) en valores enteros empaquetados (como &lt;code&gt;&quot;L&quot;&lt;/code&gt; ) es un error fatal. La raz&amp;oacute;n de esto es que simplemente no hay ning&amp;uacute;n mapeo sensato para estos valores especiales en enteros.</target>
        </trans-unit>
        <trans-unit id="d1f53d7ce9f579730ddb96734ab811ab0bbc0590" translate="yes" xml:space="preserve">
          <source>Attempting to pack the special floating point values &lt;code&gt;Inf&lt;/code&gt; and &lt;code&gt;NaN&lt;/code&gt; (infinity, also in negative, and not-a-number) into packed integer values (like &lt;code&gt;&quot;L&quot;&lt;/code&gt;) is a fatal error. The reason for this is that there simply isn't any sensible mapping for these special values into integers.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6015d4f519177c33ba06ab08404701540b4f2048" translate="yes" xml:space="preserve">
          <source>Attempting to reopen a database without closing it.</source>
          <target state="translated">Intentando reabrir una base de datos sin cerrarla.</target>
        </trans-unit>
        <trans-unit id="0bedf74043c203b86c1b5363d305f57a4b0c5fcb" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname(2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , and the file</source>
          <target state="translated">Intenta varios m&amp;eacute;todos para obtener el nombre de host del sistema y luego almacena en cach&amp;eacute; el resultado. Prueba el primero disponible de la biblioteca C gethostname (), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt; , uname (2), &lt;code&gt;&lt;a href=&quot;../functions/syscall&quot;&gt;syscall(SYS_gethostname)&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;`hostname`&lt;/code&gt; , &lt;code&gt;`uname -n`&lt;/code&gt; , y el archivo</target>
        </trans-unit>
        <trans-unit id="82ba9728173d7f6ba4ffa539ae706dc3eec02b8f" translate="yes" xml:space="preserve">
          <source>Attempts several methods of getting the system hostname and then caches the result. It tries the first available of the C library's gethostname(), &lt;code&gt;`$Config{aphostname}`&lt;/code&gt;, uname(2), &lt;code&gt;syscall(SYS_gethostname)&lt;/code&gt;, &lt;code&gt;`hostname`&lt;/code&gt;, &lt;code&gt;`uname -n`&lt;/code&gt;, and the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ba76ae4290c1441342a9f4f7bc1b58233fe69fb" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like &lt;a href=&quot;http://man.he.net/man2/connect&quot;&gt;connect(2)&lt;/a&gt;. Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3A-Client%2FServer-Communication&quot;&gt;&quot;Sockets: Client/Server Communication&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f998d3cd38777ee213006cd15fb0e0f6d2ddc7f7" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Intenta conectarse a un enchufe remoto, como connect (2). Devuelve verdadero si tuvo &amp;eacute;xito, falso en caso contrario. NAME debe ser una direcci&amp;oacute;n empaquetada del tipo apropiado para el socket. Consulte los ejemplos en &lt;a href=&quot;../perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: comunicaci&amp;oacute;n cliente / servidor en perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="64769a075153327a39fd4f2723d3853f980fe471" translate="yes" xml:space="preserve">
          <source>Attempts to connect to a remote socket, just like connect(2). Returns true if it succeeded, false otherwise. NAME should be a packed address of the appropriate type for the socket. See the examples in &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: Client/Server Communication in perlipc&lt;/a&gt;.</source>
          <target state="translated">Intenta conectarse a un enchufe remoto, como connect (2). Devuelve verdadero si tuvo &amp;eacute;xito, falso en caso contrario. NAME debe ser una direcci&amp;oacute;n empaquetada del tipo apropiado para el socket. Consulte los ejemplos en &lt;a href=&quot;perlipc#Sockets%3a-Client%2fServer-Communication&quot;&gt;Sockets: comunicaci&amp;oacute;n cliente / servidor en perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4a0ddb935c0376b494edd76deb21d2e9aa4a1612" translate="yes" xml:space="preserve">
          <source>Attempts to convert in-place the octet sequence encoded as</source>
          <target state="translated">Intenta convertir en el lugar la secuencia de octetos codificada como</target>
        </trans-unit>
        <trans-unit id="bd9b4f39078d108026008c73a3d153cb14bae4bd" translate="yes" xml:space="preserve">
          <source>Attempts to convert the PV of an SV from characters to bytes. If the PV contains a character that cannot fit in a byte, this conversion will fail; in this case, either returns false or, if &lt;code&gt;fail_ok&lt;/code&gt; is not true, croaks.</source>
          <target state="translated">Intenta convertir el PV de un SV de caracteres a bytes. Si el PV contiene un car&amp;aacute;cter que no cabe en un byte, esta conversi&amp;oacute;n fallar&amp;aacute;; en este caso, devuelve falso o, si &lt;code&gt;fail_ok&lt;/code&gt; no es verdadero, croa.</target>
        </trans-unit>
        <trans-unit id="64d7ec66819a9007136707554fdc8dbbef9567aa" translate="yes" xml:space="preserve">
          <source>Attempts to determine if a given host is outside your firewall. Possible return values are.</source>
          <target state="translated">Intenta determinar si un determinado anfitrión está fuera de su cortafuegos.Los posibles valores de retorno son.</target>
        </trans-unit>
        <trans-unit id="015e99d4e0b5f5661a89b0c851595de01de6cc85" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH</source>
          <target state="translated">Intenta leer LONGITUD</target>
        </trans-unit>
        <trans-unit id="c8be1bb9a549008dc0e0461ce94dfbc02a8ed8c1" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/read&quot;&gt;read(2)&lt;/a&gt;. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with other kinds of reads, &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; can cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; or &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="623d8fbf82dc2fdc9694f6bbe91f1257bb25f69a" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">Intenta leer LENGTH bytes de datos en la variable SCALAR del FILEHANDLE especificado, utilizando read (2). Que no pasa por tamponada IO, por lo que esta mezcla con otros tipos de lecturas, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , o &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; puede causar confusi&amp;oacute;n porque el perlio o capas stdio generalmente b&amp;uacute;fer de datos. Devuelve el n&amp;uacute;mero de bytes realmente le&amp;iacute;dos, &lt;code&gt;0&lt;/code&gt; al final del archivo o indef si hubo un error (en el &amp;uacute;ltimo caso, &lt;code&gt;$!&lt;/code&gt; Tambi&amp;eacute;n est&amp;aacute; configurado). SCALAR aumentar&amp;aacute; o reducir&amp;aacute; de modo que el &amp;uacute;ltimo byte realmente le&amp;iacute;do sea el &amp;uacute;ltimo byte del escalar despu&amp;eacute;s de la lectura.</target>
        </trans-unit>
        <trans-unit id="321c64867646f812228d15e7d459f8fc1a5c1183" translate="yes" xml:space="preserve">
          <source>Attempts to read LENGTH bytes of data into variable SCALAR from the specified FILEHANDLE, using the read(2). It bypasses buffered IO, so mixing this with other kinds of reads, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; can cause confusion because the perlio or stdio layers usually buffers data. Returns the number of bytes actually read, &lt;code&gt;0&lt;/code&gt; at end of file, or undef if there was an error (in the latter case &lt;code&gt;$!&lt;/code&gt; is also set). SCALAR will be grown or shrunk so that the last byte actually read is the last byte of the scalar after the read.</source>
          <target state="translated">Intenta leer LENGTH bytes de datos en la variable SCALAR del FILEHANDLE especificado, utilizando read (2). Que no pasa por tamponada IO, por lo que esta mezcla con otros tipos de lecturas, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; , o &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; puede causar confusi&amp;oacute;n porque el perlio o capas stdio generalmente b&amp;uacute;fer de datos. Devuelve el n&amp;uacute;mero de bytes realmente le&amp;iacute;dos, &lt;code&gt;0&lt;/code&gt; al final del archivo o indef si hubo un error (en el &amp;uacute;ltimo caso, &lt;code&gt;$!&lt;/code&gt; Tambi&amp;eacute;n est&amp;aacute; configurado). SCALAR aumentar&amp;aacute; o reducir&amp;aacute; de modo que el &amp;uacute;ltimo byte realmente le&amp;iacute;do sea el &amp;uacute;ltimo byte del escalar despu&amp;eacute;s de la lectura.</target>
        </trans-unit>
        <trans-unit id="1a8348f0c0ac76ec0ef2040ebe72ee4d10ad1e13" translate="yes" xml:space="preserve">
          <source>Attempts to set_hints_for unidentifiable subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e09b188ae4a3fab1a81562daadb429ed4fd7f6d" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using &lt;a href=&quot;http://man.he.net/man2/write&quot;&gt;write(2)&lt;/a&gt;. If LENGTH is not specified, writes whole SCALAR. It bypasses any &lt;a href=&quot;perlio&quot;&gt;PerlIO&lt;/a&gt; layers including buffered IO (but is affected by the presence of the &lt;code&gt;:utf8&lt;/code&gt; layer as described later), so mixing this with reads (other than &lt;code&gt;sysread)&lt;/code&gt;), &lt;a href=&quot;#print-FILEHANDLE-LIST&quot;&gt;&lt;code&gt;print&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#write-FILEHANDLE&quot;&gt;&lt;code&gt;write&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;&lt;code&gt;seek&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt;, or &lt;a href=&quot;#eof-FILEHANDLE&quot;&gt;&lt;code&gt;eof&lt;/code&gt;&lt;/a&gt; may cause confusion because the &lt;code&gt;:perlio&lt;/code&gt; and &lt;code&gt;:crlf&lt;/code&gt; layers usually buffer data. Returns the number of bytes actually written, or &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt; if there was an error (in this case the errno variable &lt;a href=&quot;perlvar#%24%21&quot;&gt;&lt;code&gt;$!&lt;/code&gt;&lt;/a&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="056c7c4b49d09bfb10b608aa560ae7f329c94639" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">Intenta escribir LENGTH bytes de datos de la variable ESCALAR al FILEHANDLE especificado, utilizando write (2). Si no se especifica LENGTH, escribe SCALAR completo. Omite IO almacenado en b&amp;uacute;fer, por lo que mezclar esto con lecturas (que no sean &lt;code&gt;&lt;a href=&quot;functions/sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; puede causar confusi&amp;oacute;n porque las capas perlio y stdio generalmente almacenan datos en b&amp;uacute;fer. Devuelve el n&amp;uacute;mero de bytes realmente escritos, o &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si hubo un error (en este caso, tambi&amp;eacute;n se establece la variable errno &lt;code&gt;$!&lt;/code&gt; ). Si LENGTH es mayor que los datos disponibles en el ESCALAR despu&amp;eacute;s del OFFSET, solo se escribir&amp;aacute;n los datos disponibles.</target>
        </trans-unit>
        <trans-unit id="bf935c85345c3169ffc0b395c956f17c45a9fe82" translate="yes" xml:space="preserve">
          <source>Attempts to write LENGTH bytes of data from variable SCALAR to the specified FILEHANDLE, using write(2). If LENGTH is not specified, writes whole SCALAR. It bypasses buffered IO, so mixing this with reads (other than &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; may cause confusion because the perlio and stdio layers usually buffer data. Returns the number of bytes actually written, or &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if there was an error (in this case the errno variable &lt;code&gt;$!&lt;/code&gt; is also set). If the LENGTH is greater than the data available in the SCALAR after the OFFSET, only as much data as is available will be written.</source>
          <target state="translated">Intenta escribir LENGTH bytes de datos de la variable ESCALAR al FILEHANDLE especificado, utilizando write (2). Si no se especifica LENGTH, escribe SCALAR completo. Omite IO almacenado en b&amp;uacute;fer, por lo que mezclar esto con lecturas (que no sean &lt;code&gt;&lt;a href=&quot;sysread&quot;&gt;sysread())&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;print&quot;&gt;print&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;write&quot;&gt;write&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;seek&quot;&gt;seek&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;tell&quot;&gt;tell&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;eof&quot;&gt;eof&lt;/a&gt;&lt;/code&gt; puede causar confusi&amp;oacute;n porque las capas perlio y stdio generalmente almacenan datos en b&amp;uacute;fer. Devuelve el n&amp;uacute;mero de bytes realmente escritos, o &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si hubo un error (en este caso, tambi&amp;eacute;n se establece la variable errno &lt;code&gt;$!&lt;/code&gt; ). Si LENGTH es mayor que los datos disponibles en el ESCALAR despu&amp;eacute;s del OFFSET, solo se escribir&amp;aacute;n los datos disponibles.</target>
        </trans-unit>
        <trans-unit id="cf2ad2263d9deded93137fc6e93270ce22633fb0" translate="yes" xml:space="preserve">
          <source>Attempts word completion. Cannot be changed.</source>
          <target state="translated">Intenta completar la palabra.No se puede cambiar.</target>
        </trans-unit>
        <trans-unit id="223e46f6b77744459f61cc252aea39f3bcaac056" translate="yes" xml:space="preserve">
          <source>Attribs</source>
          <target state="translated">Attribs</target>
        </trans-unit>
        <trans-unit id="295826f440604d6a675c4c66d0a324dc4eaca56b" translate="yes" xml:space="preserve">
          <source>Attribute prototype(%s) discards earlier prototype attribute in same sub</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="402319da749127eab7373ce69945d35452ea82aa" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers</source>
          <target state="translated">Attribute::Handlers</target>
        </trans-unit>
        <trans-unit id="ab429cb97f17abf9bda7af427a4ab75a270a8eee" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers - Simpler definition of attribute handlers</source>
          <target state="translated">Atributo::Manejadores-Definición más simple de los manejadores de atributos</target>
        </trans-unit>
        <trans-unit id="1c8c525e5ee86dfc71e9832b4cad7c5124dad809" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt; ) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Non-interpretive attribute handlers&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="translated">Attribute :: Handlers realiza grandes esfuerzos para convertir el argumento de datos ( &lt;code&gt;$_[4]&lt;/code&gt; ) a una forma utilizable antes de pasarlo al controlador (pero consulte &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;Controladores de atributos no interpretativos&lt;/a&gt; ). Si esos esfuerzos tienen &amp;eacute;xito, los datos interpretados se pasan en una referencia de matriz; si fallan, los datos brutos se pasan como una cadena. Por ejemplo, todos estos:</target>
        </trans-unit>
        <trans-unit id="04790e00da71beac2f86333318faed6cfab890a0" translate="yes" xml:space="preserve">
          <source>Attribute::Handlers makes strenuous efforts to convert the data argument (&lt;code&gt;$_[4]&lt;/code&gt;) to a usable form before passing it to the handler (but see &lt;a href=&quot;#Non-interpretive-attribute-handlers&quot;&gt;&quot;Non-interpretive attribute handlers&quot;&lt;/a&gt;). If those efforts succeed, the interpreted data is passed in an array reference; if they fail, the raw data is passed as a string. For example, all of these:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6652617f2c799eb11ee727b16c5646c48af6905" translate="yes" xml:space="preserve">
          <source>Attributes</source>
          <target state="translated">Attributes</target>
        </trans-unit>
        <trans-unit id="4ce085fab8976266bb7771327c95a06a2d92883d" translate="yes" xml:space="preserve">
          <source>Attributes :locked and :unique</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57744968c9ece6a6fd393a9a1f9a16852d8d26e2" translate="yes" xml:space="preserve">
          <source>Attributes &lt;code&gt;:locked&lt;/code&gt; and &lt;code&gt;:unique&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f65ce706012d5cc8515dbfba3f0c94b3cae90800" translate="yes" xml:space="preserve">
          <source>Attributes =&amp;gt; $sAttributes</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7096373d5156eb6bd0032a6f3f3f6f2306181c31" translate="yes" xml:space="preserve">
          <source>Attributes are often stored in the object itself. For example, if the object is an anonymous hash, we can store the attribute values in the hash using the attribute name as the key.</source>
          <target state="translated">Los atributos se almacenan a menudo en el propio objeto.Por ejemplo,si el objeto es un hash anónimo,podemos almacenar los valores de los atributos en el hash utilizando el nombre del atributo como clave.</target>
        </trans-unit>
        <trans-unit id="1ec0e5f9458a3d0b7666b49e580f1e144a9409de" translate="yes" xml:space="preserve">
          <source>Attributes are typically defined as read-only or read-write. Read-only attributes can only be set when the object is first created, while read-write attributes can be altered at any time.</source>
          <target state="translated">Los atributos se definen típicamente como de sólo lectura o de lectura-escritura.Los atributos de sólo lectura sólo pueden establecerse cuando se crea el objeto por primera vez,mientras que los atributos de lectura-escritura pueden ser alterados en cualquier momento.</target>
        </trans-unit>
        <trans-unit id="e7c79e72c9cbf686713260fcf1aae8a2f9a1a49e" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; interfaces</source>
          <target state="translated">Atributos como interfaces de &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="dd541d956cc1115542e113d51d19e51923523667" translate="yes" xml:space="preserve">
          <source>Attributes as &lt;code&gt;tie&lt;/code&gt; interfaces</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e1c2a2200f4dc51bc987e61b1d0f256256aa8d5" translate="yes" xml:space="preserve">
          <source>Attributes as tie interfaces</source>
          <target state="translated">Atributos como interfaces de enlace</target>
        </trans-unit>
        <trans-unit id="5d582f3d2d463609c927f60d4eb884597e89efea" translate="yes" xml:space="preserve">
          <source>Attributes make an excellent and intuitive interface through which to tie variables. For example:</source>
          <target state="translated">Los atributos constituyen una excelente e intuitiva interfaz a través de la cual se vinculan las variables.Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="508a5aa4d3d540c30ef29d403ada44bf44ff7142" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="translated">Los atributos, una vez establecidos, duran hasta que se desarman (imprimiendo el atributo &lt;code&gt;clear&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../functions/reset&quot;&gt;reset&lt;/a&gt;&lt;/code&gt; ). Tenga cuidado al hacer esto, o de lo contrario su atributo perdurar&amp;aacute; despu&amp;eacute;s de que su script termine de ejecutarse, y la gente se molesta mucho al ver que su mensaje y escritura cambian a colores extra&amp;ntilde;os.</target>
        </trans-unit>
        <trans-unit id="8aad82b8fbc6c4c52822cc8ecd0cf935a1127780" translate="yes" xml:space="preserve">
          <source>Attributes, once set, last until they are unset (by printing the attribute &lt;code&gt;clear&lt;/code&gt; or &lt;code&gt;reset&lt;/code&gt;). Be careful to do this, or otherwise your attribute will last after your script is done running, and people get very annoyed at having their prompt and typing changed to weird colors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d51da1fd65173253fff2051ffdb2fb4742bcd89d" translate="yes" xml:space="preserve">
          <source>Audrey Tang</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1874e0336adde0a00ba3a60dae1dc775409600bd" translate="yes" xml:space="preserve">
          <source>Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</source>
          <target state="translated">Audrey Tang &amp;lt;cpan@audreyt.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="f2cb213ffe5688a539a9e042d127473bf2e3ad45" translate="yes" xml:space="preserve">
          <source>August 2005</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b22c9a35903363899da803d503fe897e1743fa7" translate="yes" xml:space="preserve">
          <source>August 23, 2005</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ceafb51e2b0783d53dd620019dff3aa66708a26f" translate="yes" xml:space="preserve">
          <source>Australia</source>
          <target state="translated">Australia</target>
        </trans-unit>
        <trans-unit id="593905b31972f6ffe58325abf98595caf4ebf458" translate="yes" xml:space="preserve">
          <source>Austria</source>
          <target state="translated">Austria</target>
        </trans-unit>
        <trans-unit id="95786e021d4a315fb9439c8c152d524cf9f59cc3" translate="yes" xml:space="preserve">
          <source>Authen::SASL is required for AUTH support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="21c24cd01488e77938199d2e43d1c1e07248317d" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt; . Similar to &lt;a href=&quot;#login&quot;&gt;login&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="translated">Autenticarse con el servidor identific&amp;aacute;ndose como &lt;code&gt;USER&lt;/code&gt; con contrase&amp;ntilde;a &lt;code&gt;PASS&lt;/code&gt; . Similar al &lt;a href=&quot;#login&quot;&gt;inicio&lt;/a&gt; de sesi&amp;oacute;n , pero la contrase&amp;ntilde;a no se env&amp;iacute;a en texto sin cifrar.</target>
        </trans-unit>
        <trans-unit id="2d308c897b8201e557fb3734cdc42302c1f694dd" translate="yes" xml:space="preserve">
          <source>Authenticate with the server identifying as &lt;code&gt;USER&lt;/code&gt; with password &lt;code&gt;PASS&lt;/code&gt;. Similar to &lt;a href=&quot;#login&quot;&gt;&quot;login&quot;&lt;/a&gt;, but the password is not sent in clear text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="507f24ee32e393058ec2717e7ff642ddf8b1dd65" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the original AUTHINFO USER / AUTHINFO PASS form, defined in RFC2980) using the supplied username and password. Please note that the password is sent in clear text to the server. This command should not be used with valuable passwords unless the connection to the server is somehow protected.</source>
          <target state="translated">Se autentica en el servidor (usando el formulario original AUTHINFO USER/AUTHINFO PASS,definido en RFC2980)usando el nombre de usuario y la contraseña suministrados.Tenga en cuenta que la contraseña se envía en texto claro al servidor.Este comando no debe ser usado con contraseñas valiosas a menos que la conexión con el servidor esté protegida de alguna manera.</target>
        </trans-unit>
        <trans-unit id="4be2c3e4a055e66e61888715b3835a0acb5d7f3e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;&quot;authinfo&quot;&lt;/a&gt; the password is sent in clear text.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f9130bcae1a2dee757ab825f2972f22149b8d0e" translate="yes" xml:space="preserve">
          <source>Authenticates to the server (using the proposed NNTP V2 AUTHINFO SIMPLE form, defined and deprecated in RFC2980) using the supplied username and password. As with &lt;a href=&quot;#authinfo&quot;&gt;authinfo&lt;/a&gt; the password is sent in clear text.</source>
          <target state="translated">Se autentica en el servidor (utilizando el formulario NNTP V2 AUTHINFO SIMPLE propuesto, definido y obsoleto en RFC2980) utilizando el nombre de usuario y la contrase&amp;ntilde;a proporcionados. Al igual que con &lt;a href=&quot;#authinfo&quot;&gt;authinfo,&lt;/a&gt; la contrase&amp;ntilde;a se env&amp;iacute;a en texto sin cifrar .</target>
        </trans-unit>
        <trans-unit id="561e59b47284192d792d6315e83a8df1bb4623e9" translate="yes" xml:space="preserve">
          <source>Authentication, Security, and Encryption</source>
          <target state="translated">Autenticación,Seguridad y Cifrado</target>
        </trans-unit>
        <trans-unit id="5fda23d62015b99fb2a9f86b38bcdf2bdf7609c8" translate="yes" xml:space="preserve">
          <source>Author</source>
          <target state="translated">Author</target>
        </trans-unit>
        <trans-unit id="a250719f5509f4b060ed02cea92bc61a08d442f3" translate="yes" xml:space="preserve">
          <source>Author and Copyright Information</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd140dad60fa77aa1adfbcd64d1e9ea4bc89ff62" translate="yes" xml:space="preserve">
          <source>Author and Maintainer: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</source>
          <target state="translated">Autor y encargado: The Perl5-Porters &amp;lt;perl5-porters@perl.org&amp;gt;</target>
        </trans-unit>
        <trans-unit id="e41e820954a6b297983a7b6986adfdc7c083ed60" translate="yes" xml:space="preserve">
          <source>Author and Modification History</source>
          <target state="translated">Autor e historial de modificaciones</target>
        </trans-unit>
        <trans-unit id="dc4e711f40af1fee4327bcbd34d91d11e1b38a81" translate="yes" xml:space="preserve">
          <source>Author of this software makes no claim whatsoever about suitability, reliability, edability, editability or usability of this product, and should not be kept liable for any damage resulting from the use of it. If you can use it, you are in luck, if not, I should not be kept responsible. Keep a handy copy of your backup tape at hand.</source>
          <target state="translated">El autor de este software no hace ninguna reclamación sobre la idoneidad,fiabilidad,capacidad de edición o uso de este producto,y no debe ser considerado responsable de ningún daño resultante del uso del mismo.Si puede usarlo,está de suerte,si no,no debería ser responsable.Tenga a mano una copia de su cinta de seguridad.</target>
        </trans-unit>
        <trans-unit id="75a1f723a2c00ab3f9e540ebe5e3b630e531e2c3" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</source>
          <target state="translated">Autor: Mark Jason Dominus, Plover Systems ( &lt;code&gt;mjd-perl-&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;+@plover.com&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="b0d417f355d7d062d5dedda5f6e9d6e446d1132a" translate="yes" xml:space="preserve">
          <source>Author: Mark Jason Dominus, Plover Systems (&lt;code&gt;mjd-perl-ref+@plover.com&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2a52548bd0852b99153ddd79a1f550f70674c7d" translate="yes" xml:space="preserve">
          <source>Authors</source>
          <target state="translated">Authors</target>
        </trans-unit>
        <trans-unit id="4e4bc3d81e572248f45b55f87eb6a695cc5d7e17" translate="yes" xml:space="preserve">
          <source>Authors must not nest L&amp;lt;...&amp;gt; codes. For example, &quot;L&amp;lt;The L&amp;lt;Foo::Bar&amp;gt; man page&amp;gt;&quot; should be treated as an error.</source>
          <target state="translated">Los autores no deben anidar c&amp;oacute;digos L &amp;lt;...&amp;gt;. Por ejemplo, &quot;L &amp;lt;The L &amp;lt;Foo :: Bar&amp;gt; p&amp;aacute;gina man&amp;gt;&quot; debe tratarse como un error.</target>
        </trans-unit>
        <trans-unit id="9a1f2888146e0b82120ccf28bf4584779813130b" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters are reminded that &quot;=over&quot; ... &quot;=back&quot; may map to several different constructs in your output format. For example, in converting Pod to (X)HTML, it can map to any of &amp;lt;ul&amp;gt;...&amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt;...&amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt;...&amp;lt;/dl&amp;gt;, or &amp;lt;blockquote&amp;gt;...&amp;lt;/blockquote&amp;gt;. Similarly, &quot;=item&quot; can map to &amp;lt;li&amp;gt; or &amp;lt;dt&amp;gt;.</source>
          <target state="translated">Se recuerda a los autores de formateadores de pods que &quot;= over&quot; ... &quot;= back&quot; se puede asignar a varias construcciones diferentes en su formato de salida. Por ejemplo, al convertir Pod a (X) HTML, se puede asignar a cualquiera de &amp;lt;ul&amp;gt; ... &amp;lt;/ul&amp;gt;, &amp;lt;ol&amp;gt; ... &amp;lt;/ol&amp;gt;, &amp;lt;dl&amp;gt; ... &amp;lt;/dl&amp;gt; , o &amp;lt;blockquote&amp;gt; ... &amp;lt;/blockquote&amp;gt;. De manera similar, &quot;= item&quot; se puede asignar a &amp;lt;li&amp;gt; o &amp;lt;dt&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="80bad0a974c0d7ed8e69ae0a2451cf949509d806" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters should note that this construct:</source>
          <target state="translated">Los autores de los formateadores de Pod deben tener en cuenta que esta construcción:</target>
        </trans-unit>
        <trans-unit id="0772af8ca884a475bc6c000e8a2e7ecd3771d821" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Parser, comes with modern versions of Perl.</source>
          <target state="translated">Los autores de los formateadores/procesadores de Pod deben hacer todo lo posible para evitar escribir su propio analizador de Pod.Ya hay varios en el CPAN,con una amplia gama de estilos de interfaz --y uno de ellos,Pod::Parser,viene con versiones modernas de Perl.</target>
        </trans-unit>
        <trans-unit id="ee6ba2eca154c452d912ba72284ef9425f5cac4c" translate="yes" xml:space="preserve">
          <source>Authors of Pod formatters/processors should make every effort to avoid writing their own Pod parser. There are already several in CPAN, with a wide range of interface styles -- and one of them, Pod::Simple, comes with modern versions of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f5a6b2c86d1c842fb78879cb9847a9b86de0e1d" translate="yes" xml:space="preserve">
          <source>Authors of formatter subclasses might find these methods useful to call on a parser object that you haven't started pulling tokens from yet:</source>
          <target state="translated">Los autores de subclases de formateo podrían encontrar estos métodos útiles para llamar a un objeto analizador del que aún no se han empezado a sacar fichas:</target>
        </trans-unit>
        <trans-unit id="ba749f31a8ceaa34419e1f1f52af7da1b1065181" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">Auto-decrecimiento del valor en el SV,haciendo conversión de cadena a numérica si es necesario.Maneja la magia y la sobrecarga del operador.</target>
        </trans-unit>
        <trans-unit id="cabef034701dc195b619657e11c47b3b4c7ed2cb" translate="yes" xml:space="preserve">
          <source>Auto-decrement of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">Auto-decrecimiento del valor en el SV,haciendo conversión de cadena a numérica si es necesario.Maneja la sobrecarga del operador.Se salta el manejo de la magia 'get'.</target>
        </trans-unit>
        <trans-unit id="f8df54de50b8630f73dd7c3210d2ed53c7051734" translate="yes" xml:space="preserve">
          <source>Auto-increment and Auto-decrement</source>
          <target state="translated">Auto-incremento y auto-decrecimiento</target>
        </trans-unit>
        <trans-unit id="9c2549c4f8e7b5156ddcd16c47fe624753b70037" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles 'get' magic and operator overloading.</source>
          <target state="translated">Autoincremento del valor en el SV,haciendo conversión de cadena a numérica si es necesario.Maneja la magia y la sobrecarga del operador.</target>
        </trans-unit>
        <trans-unit id="11123412c221a7c2bf77f34ba93ea1498be1bd77" translate="yes" xml:space="preserve">
          <source>Auto-increment of the value in the SV, doing string to numeric conversion if necessary. Handles operator overloading. Skips handling 'get' magic.</source>
          <target state="translated">Autoincremento del valor en el SV,haciendo conversión de cadena a numérica si es necesario.Maneja la sobrecarga del operador.Se salta el manejo de la magia de 'get'.</target>
        </trans-unit>
        <trans-unit id="95b64723d9f40505396f5971cbc44d69372e59a7" translate="yes" xml:space="preserve">
          <source>Auto-upgrade</source>
          <target state="translated">Auto-upgrade</target>
        </trans-unit>
        <trans-unit id="57a4f42cae4d12771bda9f458a5b76498da8ce37" translate="yes" xml:space="preserve">
          <source>AutoLoader</source>
          <target state="translated">AutoLoader</target>
        </trans-unit>
        <trans-unit id="4bbd7ae289ef059e5890696f9cb149721a7b8e69" translate="yes" xml:space="preserve">
          <source>AutoLoader - load subroutines only on demand</source>
          <target state="translated">Autocargador-carga las subrutinas sólo a petición</target>
        </trans-unit>
        <trans-unit id="6851ab5ce9e022d9cc5797875048cf4a3f08af3e" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autocargador puede fallar al encontrar los archivos de divisi&amp;oacute;n autom&amp;aacute;tica (o incluso encontrar los incorrectos) en los casos en que &lt;code&gt;@INC&lt;/code&gt; contiene rutas relativas &lt;b&gt;y&lt;/b&gt; el programa hace &lt;code&gt;&lt;a href=&quot;functions/chdir&quot;&gt;chdir&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4651f865ebaf11dee249fb89b162cf3da62c9078" translate="yes" xml:space="preserve">
          <source>AutoLoader may fail to find the autosplit files (or even find the wrong ones) in cases where &lt;code&gt;@INC&lt;/code&gt; contains relative paths, &lt;b&gt;and&lt;/b&gt; the program does &lt;code&gt;chdir&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5080d78f65857a5bb4650061f6068b73782d0765" translate="yes" xml:space="preserve">
          <source>AutoLoader vs. SelfLoader</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a635037412af6ace383fa21d0d50db8f0393e57" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt; .</source>
          <target state="translated">Los Autocargadores anteriores a Perl 5.002 ten&amp;iacute;an una interfaz ligeramente diferente. Cualquier m&amp;oacute;dulo antiguo que use &lt;b&gt;Autocargador&lt;/b&gt; debe cambiarse al nuevo estilo de llamada. Por lo general, esto solo significa cambiar un requisito por un uso, agregar la importaci&amp;oacute;n expl&amp;iacute;cita &lt;code&gt;'AUTOLOAD'&lt;/code&gt; si es necesario y eliminar el &lt;b&gt;Autocargador&lt;/b&gt; de &lt;code&gt;@ISA&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7e1e103fc57cef534d77a1863a7beda04c276011" translate="yes" xml:space="preserve">
          <source>AutoLoaders prior to Perl 5.002 had a slightly different interface. Any old modules which use &lt;b&gt;AutoLoader&lt;/b&gt; should be changed to the new calling style. Typically this just means changing a require to a use, adding the explicit &lt;code&gt;'AUTOLOAD'&lt;/code&gt; import if needed, and removing &lt;b&gt;AutoLoader&lt;/b&gt; from &lt;code&gt;@ISA&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56be52307d7f516628d0435d04dbf15ef2be8e1c" translate="yes" xml:space="preserve">
          <source>AutoSplit</source>
          <target state="translated">AutoSplit</target>
        </trans-unit>
        <trans-unit id="141ac9ea73e406af3a95ffd453d7845aea91bee3" translate="yes" xml:space="preserve">
          <source>AutoSplit - split a package for autoloading</source>
          <target state="translated">AutoSplit-dividir un paquete para autocargarlo</target>
        </trans-unit>
        <trans-unit id="68a652cb711d8eb8f8b2dadb0dc16bdffbba498d" translate="yes" xml:space="preserve">
          <source>Autocreating constants</source>
          <target state="translated">Constantes de autocreación</target>
        </trans-unit>
        <trans-unit id="52fe0335e51acfb62f3dfd3073b3227b5b8c4846" translate="yes" xml:space="preserve">
          <source>Autodeferring</source>
          <target state="translated">Autodeferring</target>
        </trans-unit>
        <trans-unit id="f3589c4e74b1463fb3c579cd588ce9598fdbe87e" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">Autodie utiliza un conjunto simple de categor&amp;iacute;as para agrupar elementos integrados similares. Solicitar un tipo de categor&amp;iacute;a (comenzando con dos puntos) habilitar&amp;aacute; el autodie para todos los elementos integrados debajo de esa categor&amp;iacute;a. Por ejemplo, al solicitar &lt;code&gt;:file&lt;/code&gt; habilitar&amp;aacute; autodie para &lt;code&gt;&lt;a href=&quot;functions/close&quot;&gt;close&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d86d0ceb4ab6dfa49a2928ed69a6b234345c4271" translate="yes" xml:space="preserve">
          <source>Autodie uses a simple set of categories to group together similar built-ins. Requesting a category type (starting with a colon) will enable autodie for all built-ins beneath that category. For example, requesting &lt;code&gt;:file&lt;/code&gt; will enable autodie for &lt;code&gt;close&lt;/code&gt;, &lt;code&gt;fcntl&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt; and &lt;code&gt;sysopen&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f410fe9b046b8c8a478048e83efc2672d42d3c9c" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; will generate an exception if &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; returns false with any other error.</source>
          <target state="translated">Autodying &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; generar&amp;aacute; una excepci&amp;oacute;n si &lt;code&gt;&lt;a href=&quot;functions/flock&quot;&gt;flock&lt;/a&gt;&lt;/code&gt; devuelve falso con cualquier otro error.</target>
        </trans-unit>
        <trans-unit id="dfa0c806bb2bafe199faa77554873951783b04df" translate="yes" xml:space="preserve">
          <source>Autodying &lt;code&gt;flock&lt;/code&gt; will generate an exception if &lt;code&gt;flock&lt;/code&gt; returns false with any other error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fa81ba949fafdad4688aed6d9380f82976ca9d7" translate="yes" xml:space="preserve">
          <source>Autoloading</source>
          <target state="translated">Autoloading</target>
        </trans-unit>
        <trans-unit id="a71f8461a563c747e56f2cb5fb124e64328506d5" translate="yes" xml:space="preserve">
          <source>Autoloading and package lexicals</source>
          <target state="translated">Autocargamento y léxicos de paquetes</target>
        </trans-unit>
        <trans-unit id="24023d5e4bccdad4a40c403d058e7c856f75ea71" translate="yes" xml:space="preserve">
          <source>Autoloading with XSUBs</source>
          <target state="translated">Autocargado con XSUBs</target>
        </trans-unit>
        <trans-unit id="ea5735f59ad896a38c6b806f8d8b02abba9762e7" translate="yes" xml:space="preserve">
          <source>Automatic binary installation</source>
          <target state="translated">Instalación binaria automática</target>
        </trans-unit>
        <trans-unit id="e7b3540721074f2b16f8319edcdb7f16ebcac6ca" translate="yes" xml:space="preserve">
          <source>Automatic filehandle closure</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4347ed90164094c8291f74a6e4466cefbf468214" translate="yes" xml:space="preserve">
          <source>Automatic pipe flushing</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b890d9b67b4f885e928a5dbcadc3dec7cd34f3ad" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt; . In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="translated">Genere autom&amp;aacute;ticamente XSUB bas&amp;aacute;ndose en declaraciones de funciones en el archivo de encabezado. Se debe instalar el paquete &lt;code&gt;C::Scan&lt;/code&gt; . Si se especifica esta opci&amp;oacute;n, el nombre del archivo de encabezado puede verse como &lt;code&gt;NAME1,NAME2&lt;/code&gt; . En este caso, se usa NAME1 en lugar de la cadena especificada, pero los XSUB se emiten solo para las declaraciones incluidas en el archivo NAME2.</target>
        </trans-unit>
        <trans-unit id="5d64745dc0e8fe8b3b6097336c3b9ed3a673cecd" translate="yes" xml:space="preserve">
          <source>Automatically generate XSUBs basing on function declarations in the header file. The package &lt;code&gt;C::Scan&lt;/code&gt; should be installed. If this option is specified, the name of the header file may look like &lt;code&gt;NAME1,NAME2&lt;/code&gt;. In this case NAME1 is used instead of the specified string, but XSUBs are emitted only for the declarations included from file NAME2.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="974a6c8e46a4b4db1ad3a13139d3950f13a09a91" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--help&lt;/b&gt; and &lt;b&gt;-?&lt;/b&gt; options if the application did not specify a handler for this option itself.</source>
          <target state="translated">Proporcionar soporte autom&amp;aacute;ticamente para &lt;b&gt;--help&lt;/b&gt; y &lt;b&gt;-? &lt;/b&gt;opciones si la aplicaci&amp;oacute;n no especific&amp;oacute; un controlador para esta opci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="909a15529b11dbad33480554d0c112bc56821029" translate="yes" xml:space="preserve">
          <source>Automatically provide support for the &lt;b&gt;--version&lt;/b&gt; option if the application did not specify a handler for this option itself.</source>
          <target state="translated">Proporcione autom&amp;aacute;ticamente soporte para la opci&amp;oacute;n &lt;b&gt;--version&lt;/b&gt; si la aplicaci&amp;oacute;n no especific&amp;oacute; un controlador para esta opci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="859ddcc1d54c8f56f6fc79d681322ff6800ab918" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt; , which may be specified as the qualifier of an attribute:</source>
          <target state="translated">Los autoties se utilizan con mayor frecuencia en el m&amp;oacute;dulo al que realmente se vinculan y necesitan exportar sus atributos a cualquier m&amp;oacute;dulo que los llame. Para facilitar esto, Attribute :: Handlers reconoce una &quot; &lt;code&gt;__CALLER__&lt;/code&gt; &quot; especial - __CALLER__ , que puede especificarse como el calificador de un atributo:</target>
        </trans-unit>
        <trans-unit id="caebe3a78fcebc80600d1c2befdf4f9537e79eaa" translate="yes" xml:space="preserve">
          <source>Autoties are most commonly used in the module to which they actually tie, and need to export their attributes to any module that calls them. To facilitate this, Attribute::Handlers recognizes a special &quot;pseudo-class&quot; -- &lt;code&gt;__CALLER__&lt;/code&gt;, which may be specified as the qualifier of an attribute:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b404ad26695e85bc7cc28bdc0dded7208f879f3b" translate="yes" xml:space="preserve">
          <source>Autovivification</source>
          <target state="translated">Autovivification</target>
        </trans-unit>
        <trans-unit id="bf3b722c40bbbb50ad0fb62696f5d22f07dbb403" translate="yes" xml:space="preserve">
          <source>AvFILL</source>
          <target state="translated">AvFILL</target>
        </trans-unit>
        <trans-unit id="90bf7946c287adae3d715c64ee31d396014df2f6" translate="yes" xml:space="preserve">
          <source>AvFILLp</source>
          <target state="translated">AvFILLp</target>
        </trans-unit>
        <trans-unit id="c275699a9fcc5b1df221a4afe6ee0192241a51b8" translate="yes" xml:space="preserve">
          <source>Available Plugins</source>
          <target state="translated">Plugins disponibles</target>
        </trans-unit>
        <trans-unit id="3f5fe2a468e50383b2ee86c82b0cbc98dd7d8c3d" translate="yes" xml:space="preserve">
          <source>Available Since 0.05.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a1689bbab8d96444cb240ecc94b27e3bd6e1fa9d" translate="yes" xml:space="preserve">
          <source>Available Subroutines</source>
          <target state="translated">Subrutinas disponibles</target>
        </trans-unit>
        <trans-unit id="f8f5117038c185bf68b0bd33b349f9405e133955" translate="yes" xml:space="preserve">
          <source>Available exports</source>
          <target state="translated">Exportaciones disponibles</target>
        </trans-unit>
        <trans-unit id="00239624abff2fe9a2fd406296f776638259fff8" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt; , then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Deferred Signals (Safe Signals) in perlipc&lt;/a&gt;.</source>
          <target state="translated">Disponible en Perls 5.8.1 y posteriores. Si se establece en &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt; , se restaura el comportamiento de la se&amp;ntilde;al anterior a Perl-5.8.0 (que es inmediato pero inseguro). Si se establece en &lt;code&gt;safe&lt;/code&gt; , se utilizan se&amp;ntilde;ales seguras (pero diferidas). Consulte &lt;a href=&quot;perlipc#Deferred-Signals-(Safe-Signals)&quot;&gt;Se&amp;ntilde;ales diferidas (se&amp;ntilde;ales seguras) en perlipc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="86ef598431b2f464d3fea7c4a79b483722ad9f02" translate="yes" xml:space="preserve">
          <source>Available in Perls 5.8.1 and later. If set to &lt;code&gt;&quot;unsafe&quot;&lt;/code&gt;, the pre-Perl-5.8.0 signal behaviour (which is immediate but unsafe) is restored. If set to &lt;code&gt;safe&lt;/code&gt;, then safe (but deferred) signals are used. See &lt;a href=&quot;perlipc#Deferred-Signals-%28Safe-Signals%29&quot;&gt;&quot;Deferred Signals (Safe Signals)&quot; in perlipc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06d7ad8e1c503f30109967f01a5055e60c428ad2" translate="yes" xml:space="preserve">
          <source>Available in version 2.22 and above.</source>
          <target state="translated">Disponible en la versión 2.22 y superior.</target>
        </trans-unit>
        <trans-unit id="ca47c0994a656fab74100d8043c17430984bfc08" translate="yes" xml:space="preserve">
          <source>Available in version 2.32 and above</source>
          <target state="translated">Disponible en la versión 2.32 y superior</target>
        </trans-unit>
        <trans-unit id="6a2ef8d70aa0a54d8ffae1859cac80b4b3ca0c60" translate="yes" xml:space="preserve">
          <source>Available in version 2.66 and above.</source>
          <target state="translated">Disponible en la versión 2.66 y superior.</target>
        </trans-unit>
        <trans-unit id="46f1e6d4a99c839646d86f37c67e8ce5c790c2f7" translate="yes" xml:space="preserve">
          <source>Available in version 2.77 and above.</source>
          <target state="translated">Disponible en la versión 2.77 y superior.</target>
        </trans-unit>
        <trans-unit id="1ee0ed3a84dce710c7a16f8db82978050c4d2850" translate="yes" xml:space="preserve">
          <source>Available in version 2.99 and above.</source>
          <target state="translated">Disponible en la versión 2.99 y superior.</target>
        </trans-unit>
        <trans-unit id="d74a27e4b35b5f01b8ce5c3169c1b5a135f15fe4" translate="yes" xml:space="preserve">
          <source>Available in version 3.00 and above.</source>
          <target state="translated">Disponible en la versión 3.00 y superior.</target>
        </trans-unit>
        <trans-unit id="a51b57f95b46e8e4e842d85639326f6206ff272d" translate="yes" xml:space="preserve">
          <source>Available in version 6.18 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c501834b7b0b901f2df0d6603e7d6136330ca271" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_01 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe2902c53bc06bcbcd50a3060b02d4d1a785d162" translate="yes" xml:space="preserve">
          <source>Available in version 6.30_02 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb07b303f6d617426c6371968300dfb4f3ae0614" translate="yes" xml:space="preserve">
          <source>Available in version 6.31 and above.</source>
          <target state="translated">Disponible en la versión 6.31 y superior.</target>
        </trans-unit>
        <trans-unit id="e2eb2ee2a8a2421e0f16491afdee27929c55a640" translate="yes" xml:space="preserve">
          <source>Available in version 6.46 and above.</source>
          <target state="translated">Disponible en la versión 6.46 y superior.</target>
        </trans-unit>
        <trans-unit id="7b80e477803719c627e591ee3d93e9c48ad902d2" translate="yes" xml:space="preserve">
          <source>Available in version 6.48 and above.</source>
          <target state="translated">Disponible en la versión 6.48 y superior.</target>
        </trans-unit>
        <trans-unit id="6813343f2b8479035fb49fea7be4fff847bf5d84" translate="yes" xml:space="preserve">
          <source>Available in version 6.51_01 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aec275cec443caa644465799fc156b88fcadd8ce" translate="yes" xml:space="preserve">
          <source>Available in version 6.52 and above.</source>
          <target state="translated">Disponible en la versión 6.52 y superior.</target>
        </trans-unit>
        <trans-unit id="4c5736820a885b4b84bf41953dc520dbc9201d97" translate="yes" xml:space="preserve">
          <source>Available in version 6.5503 and above.</source>
          <target state="translated">Disponible en la versión 6.5503 y superior.</target>
        </trans-unit>
        <trans-unit id="50ef4d62519ad32b490887468033714841e5c394" translate="yes" xml:space="preserve">
          <source>Available in version 6.55_03 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b94a4ea271ebeb34f1da9b94033460c66ab594da" translate="yes" xml:space="preserve">
          <source>Available in version 6.57_02 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="608b36cf2b4b343801fc146cfc4244281c6223d0" translate="yes" xml:space="preserve">
          <source>Available in version 6.64 and above.</source>
          <target state="translated">Disponible en la versión 6.64 y superior.</target>
        </trans-unit>
        <trans-unit id="35008f0927cc370d80fa1feb2cb101b493da804e" translate="yes" xml:space="preserve">
          <source>Available in version 6.7501 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a0f8c774f58768a8219ed32fc69bb6c645c818c" translate="yes" xml:space="preserve">
          <source>Available in version 6.8305 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1a55162e32a4d313034aeda2facf36c09febf1e" translate="yes" xml:space="preserve">
          <source>Available in version 6.8502 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3781d883fbe89e1fc4d95fc3c8a343771b42879b" translate="yes" xml:space="preserve">
          <source>Available in version 7.12 and above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d6ce3bbbc75b8e9071a24da666baed09d9b758d" translate="yes" xml:space="preserve">
          <source>Available on 64 bit OpenVMS 8.2 and later. (VMS)</source>
          <target state="translated">Disponible en el OpenVMS 8.2 de 64 bits y posterior.(VMS)</target>
        </trans-unit>
        <trans-unit id="61cd670e85d7eb394067cdccaf9865a921e8dfe4" translate="yes" xml:space="preserve">
          <source>Available only for socket handles, and it does what the &lt;code&gt;ioctlsocket()&lt;/code&gt; call in the Winsock API does. (Win32)</source>
          <target state="translated">Disponible solo para identificadores de socket, y hace lo que hace la llamada &lt;code&gt;ioctlsocket()&lt;/code&gt; en la API de Winsock. (Win32)</target>
        </trans-unit>
        <trans-unit id="7ff7a29d7d279f81c65111e3969b0de8be5b1d10" translate="yes" xml:space="preserve">
          <source>Available only for socket handles. (RISC OS)</source>
          <target state="translated">Disponible sólo para las manijas de los enchufes.(RISC OS)</target>
        </trans-unit>
        <trans-unit id="9f1e3ff1138fe80a24c7ddf73407362168941db0" translate="yes" xml:space="preserve">
          <source>Available only under threaded builds, this function allocates an entry in &lt;code&gt;PL_stashpad&lt;/code&gt; for the stash passed to it.</source>
          <target state="translated">Disponible solo en compilaciones con subprocesos, esta funci&amp;oacute;n asigna una entrada en &lt;code&gt;PL_stashpad&lt;/code&gt; para el alijo que se le pasa.</target>
        </trans-unit>
        <trans-unit id="24db3617e94fd8213371a29596a3d186b94b903d" translate="yes" xml:space="preserve">
          <source>Available since 0.05.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8904628a4cafc1997d22ed36de689160cc550e45" translate="yes" xml:space="preserve">
          <source>Available since 0.14.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="47b9977311f14febdb908b3d7c8768e488ba1bdf" translate="yes" xml:space="preserve">
          <source>Available since 0.15.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="484973f71a15c235b16dffbc3bc34be0d16c15f0" translate="yes" xml:space="preserve">
          <source>Available since 0.19.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf20cba49d40f80adc31be98bf7c874514e9c65b" translate="yes" xml:space="preserve">
          <source>Available since version 1.000020.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b4ebee27a76026f487f2506be21a330fd5bb55de" translate="yes" xml:space="preserve">
          <source>Available since version 2.141170.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04c0a2e766dbfbf8f4dc8178b6428ab302e4b061" translate="yes" xml:space="preserve">
          <source>Avar Arnfjord Bjarmason &amp;lt;avar@cpan.org&amp;gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e829311778d72727fd390df6d086e72d016b6e9b" translate="yes" xml:space="preserve">
          <source>Avoid /usr/ucb/cc.</source>
          <target state="translated">Evitar /usr/ucb/cc.</target>
        </trans-unit>
        <trans-unit id="20382d66f57ab5b9e0eec4292fa20991e9ee50cf" translate="yes" xml:space="preserve">
          <source>Avoid &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; where using &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; and &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; would work.</source>
          <target state="translated">Evite &lt;code&gt;$r-&amp;gt;Class::func()&lt;/code&gt; donde usar &lt;code&gt;@ISA=qw(... Class ...)&lt;/code&gt; y &lt;code&gt;$r-&amp;gt;func()&lt;/code&gt; funcionar&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="653557f5998e677614fe1c110b44a8530b1a3295" translate="yes" xml:space="preserve">
          <source>Avoid assignments in conditionals, but if they're unavoidable, use extra paren, e.g. &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</source>
          <target state="translated">Evite las asignaciones en condicionales, pero si son inevitables, use par&amp;eacute;n adicionales, por ejemplo, &quot;if (a &amp;amp;&amp;amp; (b = c)) ...&quot;</target>
        </trans-unit>
        <trans-unit id="12cd7881c58cc2ba233002bb3f616c6a3c8332a8" translate="yes" xml:space="preserve">
          <source>Avoid barewords if you can, especially all lowercase ones. You can't tell by just looking at it whether a bareword is a function or a string. By using quotes on strings and parentheses on function calls, you won't ever get them confused.</source>
          <target state="translated">Evite las palabras de barras si puede,especialmente todas las minúsculas.No se puede saber con sólo mirarlo si una palabra clave es una función o una cadena.Usando comillas en las cadenas y paréntesis en las llamadas a funciones,nunca se confundirán.</target>
        </trans-unit>
        <trans-unit id="a2c60caa765bc1191575d1eafdff1bfe2d3195d5" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="translated">Evite las pruebas de nombres de clases como: &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt; &quot;Invalid&quot; unless &lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; $ref eq 'FOO'&lt;/code&gt; . Generalmente puede eliminar la parte &lt;code&gt;eq 'FOO'&lt;/code&gt; sin ning&amp;uacute;n da&amp;ntilde;o. &amp;iexcl;Deje que los objetos se cuiden solos! En general, evite los nombres de clases cableados en la medida de lo posible.</target>
        </trans-unit>
        <trans-unit id="6c6177d46cc76c5db51cee88fceed0a2c4936349" translate="yes" xml:space="preserve">
          <source>Avoid class name tests like: &lt;code&gt;die &quot;Invalid&quot; unless ref $ref eq 'FOO'&lt;/code&gt;. Generally you can delete the &lt;code&gt;eq 'FOO'&lt;/code&gt; part with no harm at all. Let the objects look after themselves! Generally, avoid hard-wired class names as far as possible.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98206b093bcf40d6e074eb698543fd4b6a25d539" translate="yes" xml:space="preserve">
          <source>Avoid keeping any state information in your packages. It makes it difficult for multiple other packages to use yours. Keep state information in objects.</source>
          <target state="translated">Evita guardar cualquier información de estado en tus paquetes.Esto dificulta el uso de los otros paquetes.Mantenga la información de estado en los objetos.</target>
        </trans-unit>
        <trans-unit id="b40cce256d04ce45459ded87307f5f3e8ae2760b" translate="yes" xml:space="preserve">
          <source>Avoid libucb.</source>
          <target state="translated">Evita la libucación.</target>
        </trans-unit>
        <trans-unit id="b3ba9403766f60fa8e210155287efa18e1a9e739" translate="yes" xml:space="preserve">
          <source>Avoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.</source>
          <target state="translated">Evite iniciar una nueva jerarquía de alto nivel,especialmente si ya existe una jerarquía adecuada bajo la cual pueda colocar su módulo.</target>
        </trans-unit>
        <trans-unit id="e368cb46427a0a7114b3f3aa59a320144f3a18b6" translate="yes" xml:space="preserve">
          <source>Avoid unnecessary quotes and stringification</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd4b693367a701b3345901dbd6d82b5f0d6ce929" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (or &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; function instead.</source>
          <target state="translated">Evite el uso de &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep()&lt;/a&gt;&lt;/code&gt; (o &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map()&lt;/a&gt;&lt;/code&gt; ) o `backticks` en un contexto vac&amp;iacute;o, es decir, cuando simplemente desecha sus valores de retorno. Todas esas funciones tienen valores de retorno, as&amp;iacute; que &amp;uacute;selas. De lo contrario, utilice un bucle &lt;code&gt;foreach()&lt;/code&gt; o la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system()&lt;/a&gt;&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="4d1b147c04752308a754e45a088f0a5ced1e3189" translate="yes" xml:space="preserve">
          <source>Avoid using &lt;code&gt;grep()&lt;/code&gt; (or &lt;code&gt;map()&lt;/code&gt;) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a &lt;code&gt;foreach()&lt;/code&gt; loop or the &lt;code&gt;system()&lt;/code&gt; function instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="342c7154cb2c0ee3ba1afbccab12770600c98259" translate="yes" xml:space="preserve">
          <source>Avoid using hardcoded test numbers whenever possible (the EXPECTED/GOT found in t/op/tie.t is much more maintainable, and gives better failure reports).</source>
          <target state="translated">Evitar el uso de números de prueba codificados siempre que sea posible (el EXPECTED/GOT que se encuentra en t/op/tie.t es mucho más mantenible,y da mejores informes de fallos).</target>
        </trans-unit>
        <trans-unit id="67de3787b457172bffd90b9f3faae7435e0dae2f" translate="yes" xml:space="preserve">
          <source>Avoid using qx// and system() unless you are testing for them. If you do use them, make sure that you cover _all_ perl platforms.</source>
          <target state="translated">Evite usar qx//y system()a menos que esté haciendo pruebas para ellos.Si los usa,asegúrese de cubrir todas las plataformas de Perl.</target>
        </trans-unit>
        <trans-unit id="0e92b74d5a979c26e7eb18be8603b8359a1d07fd" translate="yes" xml:space="preserve">
          <source>Avoiding Pipe Deadlocks</source>
          <target state="translated">Evitar los callejones sin salida de las tuberías</target>
        </trans-unit>
        <trans-unit id="6e3313e507db79bbbaea78fb241509ccc328aba1" translate="yes" xml:space="preserve">
          <source>Avoiding repetitions</source>
          <target state="translated">Evitar las repeticiones</target>
        </trans-unit>
        <trans-unit id="3721e8be2f4b8bf2c63f63312cdfa53888d8430d" translate="yes" xml:space="preserve">
          <source>Awk Traps</source>
          <target state="translated">Trampas Awk</target>
        </trans-unit>
        <trans-unit id="ae4f281df5a5d0ff3cad6371f76d5c29b6d953ec" translate="yes" xml:space="preserve">
          <source>B</source>
          <target state="translated">B</target>
        </trans-unit>
        <trans-unit id="960ee8c49bfa63dfbcee503c121c56c7a1e4101b" translate="yes" xml:space="preserve">
          <source>B *</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd2b125cd8de6e0701cdac6ee17fd331ce4a27c2" translate="yes" xml:space="preserve">
          <source>B - The Perl Compiler Backend</source>
          <target state="translated">B-La base de datos del compilador de Perl</target>
        </trans-unit>
        <trans-unit id="66cbfa5966aea2edc7cf64e032e34c46ba4f5e91" translate="yes" xml:space="preserve">
          <source>B line</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b918b0aa2af36ef03dc69f56d877870ae5fd0aee" translate="yes" xml:space="preserve">
          <source>B-regex</source>
          <target state="translated">B-regex</target>
        </trans-unit>
        <trans-unit id="19869e35c46a3e66430c519067a6d3e7137c0ed7" translate="yes" xml:space="preserve">
          <source>B. Execution</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f96bf8801b12adefc37c1e7fc962c4790aa5f3c1" translate="yes" xml:space="preserve">
          <source>B. K. Oxley (binkley),</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4995b54293f85c5bb7976c9e655accd8fbd573ea" translate="yes" xml:space="preserve">
          <source>B. UNPACK</source>
          <target state="translated">B.UNPACK</target>
        </trans-unit>
        <trans-unit id="52b9020e3a04e67bbf5d1e8e1b850a5ce003849b" translate="yes" xml:space="preserve">
          <source>B::AV Methods</source>
          <target state="translated">B::AV Métodos</target>
        </trans-unit>
        <trans-unit id="dc2dfb25dd4ed2146470cd57ee95edac91f0306b" translate="yes" xml:space="preserve">
          <source>B::BINOP Method</source>
          <target state="translated">B::Método BINOP</target>
        </trans-unit>
        <trans-unit id="d151bd0866d55b4bfc156b14f486f63bf8d29ea8" translate="yes" xml:space="preserve">
          <source>B::BM Methods</source>
          <target state="translated">B::BM Métodos</target>
        </trans-unit>
        <trans-unit id="9055e894e201b212c293a29798f1091ff6d20491" translate="yes" xml:space="preserve">
          <source>B::COP Methods</source>
          <target state="translated">B::Métodos COP</target>
        </trans-unit>
        <trans-unit id="ad1f22ba3c95252a59969a1a218e1111bb139542" translate="yes" xml:space="preserve">
          <source>B::CV Methods</source>
          <target state="translated">B::CV Métodos</target>
        </trans-unit>
        <trans-unit id="c5987daa2aa6d7fac584555a51956a3b445f0843" translate="yes" xml:space="preserve">
          <source>B::Concise</source>
          <target state="translated">B::Concise</target>
        </trans-unit>
        <trans-unit id="0e99aa1c3be052d8105291584d6f4ee6b16f397c" translate="yes" xml:space="preserve">
          <source>B::Concise - Walk Perl syntax tree, printing concise info about ops</source>
          <target state="translated">B::Conciso-Caminar el árbol de sintaxis de Perl,imprimiendo información concisa sobre las operaciones</target>
        </trans-unit>
        <trans-unit id="d98d2c8e235d9494074cb2fd60569e8b9c12b5d6" translate="yes" xml:space="preserve">
          <source>B::Concise::reset_sequence()</source>
          <target state="translated">B::Concise::reset_sequence()</target>
        </trans-unit>
        <trans-unit id="553185e97d716b58f74fa982526081cbc642ddf4" translate="yes" xml:space="preserve">
          <source>B::Debug</source>
          <target state="translated">B::Debug</target>
        </trans-unit>
        <trans-unit id="7b2b543f6bc70176bf812e6ac813955a4e8d32ab" translate="yes" xml:space="preserve">
          <source>B::Debug - Walk Perl syntax tree, printing debug info about ops</source>
          <target state="translated">B::Debug-Caminar el árbol de sintaxis de Perl,imprimir la información de depuración de operaciones</target>
        </trans-unit>
        <trans-unit id="b2fba5e2c554e2a4492f4d6c8ba33e2e0b6a2475" translate="yes" xml:space="preserve">
          <source>B::Deparse</source>
          <target state="translated">B::Deparse</target>
        </trans-unit>
        <trans-unit id="45e0d250a6312bd5838511c6a45d0f47e7a90193" translate="yes" xml:space="preserve">
          <source>B::Deparse - Perl compiler backend to produce perl code</source>
          <target state="translated">B::Deparse-Backend del compilador de Perl para producir el código perl</target>
        </trans-unit>
        <trans-unit id="ef79da6fd85d8fa02ee778f0544d6ba33e8b3b18" translate="yes" xml:space="preserve">
          <source>B::Deparse can also be used on a sub-by-sub basis from other perl programs.</source>
          <target state="translated">B::Deparse también puede ser utilizado en una base de sub-sub de otros programas de perl.</target>
        </trans-unit>
        <trans-unit id="187ec0fb4a4a04196e808c398a93708ba9275615" translate="yes" xml:space="preserve">
          <source>B::Deparse is a backend module for the Perl compiler that generates perl source code, based on the internal compiled structure that perl itself creates after parsing a program. The output of B::Deparse won't be exactly the same as the original source, since perl doesn't keep track of comments or whitespace, and there isn't a one-to-one correspondence between perl's syntactical constructions and their compiled form, but it will often be close. When you use the &lt;b&gt;-p&lt;/b&gt; option, the output also includes parentheses even when they are not required by precedence, which can make it easy to see if perl is parsing your expressions the way you intended.</source>
          <target state="translated">B :: Deparse es un m&amp;oacute;dulo de backend para el compilador de Perl que genera c&amp;oacute;digo fuente de Perl, basado en la estructura compilada interna que el propio Perl crea despu&amp;eacute;s de analizar un programa. La salida de B :: Deparse no ser&amp;aacute; exactamente la misma que la fuente original, ya que perl no realiza un seguimiento de los comentarios o los espacios en blanco, y no existe una correspondencia uno a uno entre las construcciones sint&amp;aacute;cticas de perl y sus compilaciones. forma, pero a menudo estar&amp;aacute; cerca. Cuando usa la opci&amp;oacute;n &lt;b&gt;-p&lt;/b&gt; , la salida tambi&amp;eacute;n incluye par&amp;eacute;ntesis incluso cuando no son requeridos por la precedencia, lo que puede hacer que sea f&amp;aacute;cil ver si perl est&amp;aacute; analizando sus expresiones de la manera deseada.</target>
        </trans-unit>
        <trans-unit id="fc31dbbc2ee8c07aa355011d5f82b2d63c5b6c00" translate="yes" xml:space="preserve">
          <source>B::GV Methods</source>
          <target state="translated">B::GV Métodos</target>
        </trans-unit>
        <trans-unit id="f507161ede02e20a9575d2189eb0e0194566355a" translate="yes" xml:space="preserve">
          <source>B::HV Methods</source>
          <target state="translated">B::HV Métodos</target>
        </trans-unit>
        <trans-unit id="e300bd8b4c95a3624e2aa219bf974f0118cef860" translate="yes" xml:space="preserve">
          <source>B::IO Methods</source>
          <target state="translated">B::IO Métodos</target>
        </trans-unit>
        <trans-unit id="35a3e95640c426b65cf8d850194a4f17b3215f07" translate="yes" xml:space="preserve">
          <source>B::IO objects derive from IO objects and you will get more information from the IO object itself.</source>
          <target state="translated">B::Los objetos IO derivan de los objetos IO y obtendrás más información del propio objeto IO.</target>
        </trans-unit>
        <trans-unit id="9329448ffaface57d41ef2b007c24eb18197a68b" translate="yes" xml:space="preserve">
          <source>B::IV Methods</source>
          <target state="translated">B::IV Métodos</target>
        </trans-unit>
        <trans-unit id="f3d775a1d64c4d9d033d742b01a011ef21c3139b" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41ae1a755811beebf8ac2f49c8c1656753f2209c" translate="yes" xml:space="preserve">
          <source>B::IV, B::NV, B::RV, B::PV, B::PVIV, B::PVNV, B::PVMG, B::BM (5.9.5 and earlier), B::PVLV, B::AV, B::HV, B::CV, B::GV, B::FM, B::IO. These classes correspond in the obvious way to the underlying C structures of similar names. The inheritance hierarchy mimics the underlying C &quot;inheritance&quot;. For the 5.10.x branch, (</source>
          <target state="translated">B::IV,B::NV,B::RV,B::PV,B::PVIV,B::PVNV,B::PVMG,B::BM (5.9.5 y anterior),B::PVLV,B::AV,B::HV,B::CV,B::GV,B::FM,B::IO.Estas clases corresponden de manera obvia a las estructuras C subyacentes de nombres similares.La jerarquía de herencia imita la &quot;herencia&quot; C subyacente.Para la rama 5.10.x,(</target>
        </trans-unit>
        <trans-unit id="47e3586b1ed7a7d56d8afab1073b55905757ce29" translate="yes" xml:space="preserve">
          <source>B::LISTOP Method</source>
          <target state="translated">B::Método LISTOP</target>
        </trans-unit>
        <trans-unit id="04688acb0cbf70d25c11e0314b06463ce4bde512" translate="yes" xml:space="preserve">
          <source>B::LOGOP Method</source>
          <target state="translated">B::Método LOGOP</target>
        </trans-unit>
        <trans-unit id="7263ed2af022568be1b85d473eacf000486dd697" translate="yes" xml:space="preserve">
          <source>B::LOOP Methods</source>
          <target state="translated">B::Métodos LOOP</target>
        </trans-unit>
        <trans-unit id="83ceb8c6feb2e3fc2f3bf822a42dbcd07ff89ff2" translate="yes" xml:space="preserve">
          <source>B::MAGIC Methods</source>
          <target state="translated">B::Métodos MÁGICOS</target>
        </trans-unit>
        <trans-unit id="69a559c9b6f1bb1dde02c8b48310f4be42a91370" translate="yes" xml:space="preserve">
          <source>B::METHOP Methods (Since Perl 5.22)</source>
          <target state="translated">B::Métodos METHOP (Desde Perl 5.22)</target>
        </trans-unit>
        <trans-unit id="ce0314b7717adf8f5e71d17e31bd593c95324507" translate="yes" xml:space="preserve">
          <source>B::NV Methods</source>
          <target state="translated">B::NV Métodos</target>
        </trans-unit>
        <trans-unit id="c0b4baaa7ca50074884462d7620fd16447077eec" translate="yes" xml:space="preserve">
          <source>B::OP Methods</source>
          <target state="translated">B::OP Métodos</target>
        </trans-unit>
        <trans-unit id="9f43dd0af65c2a7397a364fed7e94a6388954481" translate="yes" xml:space="preserve">
          <source>B::OP::terse</source>
          <target state="translated">B::OP::terse</target>
        </trans-unit>
        <trans-unit id="b8644ca464436a14d88fc7211463f2c65ed97695" translate="yes" xml:space="preserve">
          <source>B::Op_private</source>
          <target state="translated">B::Op_private</target>
        </trans-unit>
        <trans-unit id="67239ea053c2700f5ce63cb3454a4558b2cbf5e7" translate="yes" xml:space="preserve">
          <source>B::Op_private - OP op_private flag definitions</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5409024a3cb7db3e3ab0625fc65de3e420057bb4" translate="yes" xml:space="preserve">
          <source>B::PADLIST Methods</source>
          <target state="translated">B::Métodos de PADLIST</target>
        </trans-unit>
        <trans-unit id="7aa1d371fde2d45d24f6903c528b83b6becc77cd" translate="yes" xml:space="preserve">
          <source>B::PADNAME Methods</source>
          <target state="translated">B::Métodos de PADNAME</target>
        </trans-unit>
        <trans-unit id="f042ef0bca656a3a3db2a47dca50963fab567b10" translate="yes" xml:space="preserve">
          <source>B::PADNAMELIST Methods</source>
          <target state="translated">B::PADNAMELISTA Métodos</target>
        </trans-unit>
        <trans-unit id="7fc794e6266342d3b9c5605f5dd3acf7f99c4eaf" translate="yes" xml:space="preserve">
          <source>B::PADOP Method</source>
          <target state="translated">B::Método PADOP</target>
        </trans-unit>
        <trans-unit id="3cfe6d3792643bf75e3768c357ceb15d1fcc2896" translate="yes" xml:space="preserve">
          <source>B::PMOP Methods</source>
          <target state="translated">B::Métodos PMOP</target>
        </trans-unit>
        <trans-unit id="935c8ee8b93bca030ffae3839fe2dd9b63ef8ee4" translate="yes" xml:space="preserve">
          <source>B::PV Methods</source>
          <target state="translated">B::PV Métodos</target>
        </trans-unit>
        <trans-unit id="2ae17602fe4096f70c3f88f15eb8e459f9c75ea9" translate="yes" xml:space="preserve">
          <source>B::PVLV Methods</source>
          <target state="translated">B::Métodos PVLV</target>
        </trans-unit>
        <trans-unit id="974a328507349d20edd58996d04366d5388a2f7c" translate="yes" xml:space="preserve">
          <source>B::PVMG Methods</source>
          <target state="translated">B::Métodos PVMG</target>
        </trans-unit>
        <trans-unit id="7210fef12d9bb7c60c3dee3ae3350db4f7b9f9ab" translate="yes" xml:space="preserve">
          <source>B::PVOP Method</source>
          <target state="translated">B::Método PVOP</target>
        </trans-unit>
        <trans-unit id="6455c3fb933990f5652e2d49c591cb379eb4bf8a" translate="yes" xml:space="preserve">
          <source>B::REGEXP Methods</source>
          <target state="translated">B::Métodos REGEXP</target>
        </trans-unit>
        <trans-unit id="5fb9902660751871b51829ac2f4124c1e0f71d1f" translate="yes" xml:space="preserve">
          <source>B::RV Methods</source>
          <target state="translated">B::Métodos RV</target>
        </trans-unit>
        <trans-unit id="1bc231286052c317542f678d841b72c83eca59c7" translate="yes" xml:space="preserve">
          <source>B::SV Methods</source>
          <target state="translated">B::SV Métodos</target>
        </trans-unit>
        <trans-unit id="ba72f1a9a3b75ef02445cdb3be5e5dfd9e626d0a" translate="yes" xml:space="preserve">
          <source>B::SVOP Methods</source>
          <target state="translated">B::Métodos SVOP</target>
        </trans-unit>
        <trans-unit id="6d49788efca655ce69693e7fc4afeb14e70c0677" translate="yes" xml:space="preserve">
          <source>B::Showlex</source>
          <target state="translated">B::Showlex</target>
        </trans-unit>
        <trans-unit id="950f98354a0be3d4d89c912c00828150ec365f96" translate="yes" xml:space="preserve">
          <source>B::Showlex - Show lexical variables used in functions or files</source>
          <target state="translated">B::Showlex-Muestra las variables léxicas utilizadas en funciones o archivos</target>
        </trans-unit>
        <trans-unit id="fdd28b59d6f44b83715e2f882acc2a2a5588e605" translate="yes" xml:space="preserve">
          <source>B::Terse</source>
          <target state="translated">B::Terse</target>
        </trans-unit>
        <trans-unit id="c493225f0157e4f61a98bb3974699f2af44cb46f" translate="yes" xml:space="preserve">
          <source>B::Terse - Walk Perl syntax tree, printing terse info about ops</source>
          <target state="translated">B::Terse-Caminar el árbol de sintaxis de Perl,imprimiendo información concisa sobre operaciones</target>
        </trans-unit>
        <trans-unit id="9f6685ca28bcfea09300907f0826a8f9a2c91850" translate="yes" xml:space="preserve">
          <source>B::UNOP Method</source>
          <target state="translated">B::Método UNOP</target>
        </trans-unit>
        <trans-unit id="69effd3b7e8802f540cc9b9e50328608e6736463" translate="yes" xml:space="preserve">
          <source>B::UNOP_AUX Methods (since 5.22)</source>
          <target state="translated">B::Métodos UNOP_AUX (desde 5.22)</target>
        </trans-unit>
        <trans-unit id="c85e7a03e5bbe49c04256621164986ed11cb37ba" translate="yes" xml:space="preserve">
          <source>B::Xref</source>
          <target state="translated">B::Xref</target>
        </trans-unit>
        <trans-unit id="651c8208adb3fd49f31423f94f8ac43c0733aa36" translate="yes" xml:space="preserve">
          <source>B::Xref - Generates cross reference reports for Perl programs</source>
          <target state="translated">B::Xref-Genera informes de referencia cruzada para los programas Perl</target>
        </trans-unit>
        <trans-unit id="a61d2719382da67e2a1a2dbd76dd400accca9187" translate="yes" xml:space="preserve">
          <source>BACKWARD COMPATIBILITY AND DEPRECATION</source>
          <target state="translated">COMPATIBILIDAD RETROACTIVA Y DEPRECIACIÓN</target>
        </trans-unit>
        <trans-unit id="e5b45b4fc983ac2702f9e777eee2ac1b1e5f0f20" translate="yes" xml:space="preserve">
          <source>BACKWARDS COMPATIBILITY</source>
          <target state="translated">COMPATIBILIDAD CON EL PASADO</target>
        </trans-unit>
        <trans-unit id="bef6eec96c16ae54f978beec72807557ca3a9eaf" translate="yes" xml:space="preserve">
          <source>BASIC METHODS</source>
          <target state="translated">MÉTODOS BÁSICOS</target>
        </trans-unit>
        <trans-unit id="aa6878b1c31a9420245df1daffb7b223338737a3" translate="yes" xml:space="preserve">
          <source>BBB</source>
          <target state="translated">BBB</target>
        </trans-unit>
        <trans-unit id="a76d28d6a4e36d4447b9f4c252abca9f3cac325b" translate="yes" xml:space="preserve">
          <source>BBEdit and TextWrangler</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cf5cb57c99d3bbd6c48033a11d198c341ee5329" translate="yes" xml:space="preserve">
          <source>BEFORE YOU START WRITING A MODULE</source>
          <target state="translated">ANTES DE EMPEZAR A ESCRIBIR UN MÓDULO</target>
        </trans-unit>
        <trans-unit id="3598517c826f1480a241800ce73f781ae2b1cd6a" translate="yes" xml:space="preserve">
          <source>BEGIN</source>
          <target state="translated">BEGIN</target>
        </trans-unit>
        <trans-unit id="d94255a33af2a233413bdca7bd8b5cd50ff62d1b" translate="yes" xml:space="preserve">
          <source>BEGIN blocks</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38cb5ebde363f32ca7879125654df658667bbf73" translate="yes" xml:space="preserve">
          <source>BEGIN failed--compilation aborted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70821eae507ac85cc9e07ce2b4ef46d0ec3667a3" translate="yes" xml:space="preserve">
          <source>BEGIN not safe after errors--compilation aborted</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed0ab3055b45605d8d3bfeee9675e3115e25dd63" translate="yes" xml:space="preserve">
          <source>BEGIN, UNITCHECK, CHECK, INIT and END</source>
          <target state="translated">COMIENZO,CHEQUEO,COMPROBACIÓN,INICIO y FINAL</target>
        </trans-unit>
        <trans-unit id="ee1ec7cf5d1203d7be37071bc2244af5ad59b465" translate="yes" xml:space="preserve">
          <source>BEHAVIOR HOOKS</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82587c5990d27962027bcd8f44009a394aa03c6d" translate="yes" xml:space="preserve">
          <source>BENCHMARKS</source>
          <target state="translated">BENCHMARKS</target>
        </trans-unit>
        <trans-unit id="3eb8dc2707d319cff39e903c8f9e907ffde6faaa" translate="yes" xml:space="preserve">
          <source>BEST PRACTICE</source>
          <target state="translated">MEJORES PRÁCTICAS</target>
        </trans-unit>
        <trans-unit id="9971e7204a8b08d861ca7fadb789c6c4fe6817b8" translate="yes" xml:space="preserve">
          <source>BINARY_LOCATION</source>
          <target state="translated">BINARY_LOCATION</target>
        </trans-unit>
        <trans-unit id="d6b920160b07e6d8ef62aeb966afe0559c1c4da6" translate="yes" xml:space="preserve">
          <source>BINMODE</source>
          <target state="translated">BINMODE</target>
        </trans-unit>
        <trans-unit id="5d021fda0b6b8ed6bd452bf1168689693b7edba7" translate="yes" xml:space="preserve">
          <source>BINMODE this</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf55ddd9725aa1a87e415a1396e069c8d47b25d1" translate="yes" xml:space="preserve">
          <source>BLOCK</source>
          <target state="translated">BLOCK</target>
        </trans-unit>
        <trans-unit id="457d9dafbbea9f5d194f2f920ae5f010432f75b2" translate="yes" xml:space="preserve">
          <source>BLOCKDEV</source>
          <target state="translated">BLOCKDEV</target>
        </trans-unit>
        <trans-unit id="b09c96efee066cc539728b4e2b0f68b4e32a0350" translate="yes" xml:space="preserve">
          <source>BOM as integer when fetched in network byte order</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73fcc9dd1e6686a3a9e94d9fb16092a9ef3f9ef8" translate="yes" xml:space="preserve">
          <source>BOM_UTF8</source>
          <target state="translated">BOM_UTF8</target>
        </trans-unit>
        <trans-unit id="9afa89ba4b3340d7bc1c3e18c656cfc5abf6d9a7" translate="yes" xml:space="preserve">
          <source>BOOLEAN = less-&amp;gt;of( FEATURE )</source>
          <target state="translated">BOOLEAN = menos-&amp;gt; de (FUNCI&amp;Oacute;N)</target>
        </trans-unit>
        <trans-unit id="3e4c26e4f6f8343f03e02567a3c22dbf6978ed5f" translate="yes" xml:space="preserve">
          <source>BOTTOM_GV</source>
          <target state="translated">BOTTOM_GV</target>
        </trans-unit>
        <trans-unit id="5538bef04345694943fc69521fc1c479110399bf" translate="yes" xml:space="preserve">
          <source>BOTTOM_NAME</source>
          <target state="translated">BOTTOM_NAME</target>
        </trans-unit>
        <trans-unit id="247befebedd2ed6823933439f49eb30a07d09dca" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION</source>
          <target state="translated">NOTACIÓN DE PARÉNTESIS</target>
        </trans-unit>
        <trans-unit id="17d26d9e28cc4c16fe9b307dc7f0b75e8a9d3b1b" translate="yes" xml:space="preserve">
          <source>BRACKET NOTATION SECURITY</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c25e7baf0562de8891b5c53dde5e9d802f4a0b6e" translate="yes" xml:space="preserve">
          <source>BREAKOUT_AT</source>
          <target state="translated">BREAKOUT_AT</target>
        </trans-unit>
        <trans-unit id="e7772b5b926c191f6bd98767963948f3ffc93baa" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), so you have to use the following lines instead:</source>
          <target state="translated">BS2000 POSIX no admite la notaci&amp;oacute;n shebang ( &lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt; ), por lo que debe usar las siguientes l&amp;iacute;neas:</target>
        </trans-unit>
        <trans-unit id="900c916101719763ca728f26535d16592b2fec22" translate="yes" xml:space="preserve">
          <source>BS2000 POSIX doesn't support the shebang notation (&lt;code&gt;#!/usr/local/bin/perl&lt;/code&gt;), so you have to use the following lines instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f442b9234477d8def500a9840cec8cff9ed97e5a" translate="yes" xml:space="preserve">
          <source>BSD</source>
          <target state="translated">BSD</target>
        </trans-unit>
        <trans-unit id="664c8d2ddb2e4dc2ea085ed16d6df4504ec03ee2" translate="yes" xml:space="preserve">
          <source>BSD::Resource on Solaris</source>
          <target state="translated">BSD::Recurso en Solaris</target>
        </trans-unit>
        <trans-unit id="df51adc50ecdca424b6145ec6164f8c39197a14c" translate="yes" xml:space="preserve">
          <source>BSD::Resource versions earlier than 1.09 do not compile on Solaris with perl 5.6.0 and higher, for the same reasons as Proc::ProcessTable. BSD::Resource versions starting from 1.09 have a workaround for the problem.</source>
          <target state="translated">BSD::Las versiones de recursos anteriores a la 1.09 no compilan en Solaris con perl 5.6.0 y superior,por las mismas razones que Proc::ProcessTable.BSD::Las versiones de recursos a partir de la 1.09 tienen una solución para el problema.</target>
        </trans-unit>
        <trans-unit id="d7fe8d7ec43bafda1404b3733deb73b25528fcbd" translate="yes" xml:space="preserve">
          <source>BSLOADLIBS</source>
          <target state="translated">BSLOADLIBS</target>
        </trans-unit>
        <trans-unit id="502dbddd3b35610af6911c0fbc9ca3be4bfe6d63" translate="yes" xml:space="preserve">
          <source>BTW. Beware too of pressure from managers who see you speed a program up by 50% of the runtime once, only to get a request one month later to do the same again (true story) - you'll just have to point out you're only human, even if you are a Perl programmer, and you'll see what you can do...</source>
          <target state="translated">POR CIERTO.Ten cuidado con la presión de los gerentes que te ven acelerar un programa en un 50% del tiempo de ejecución una vez,sólo para obtener una solicitud un mes después para hacer lo mismo de nuevo (historia real)-sólo tendrás que señalar que eres sólo un humano,incluso si eres un programador de Perl,y verás lo que puedes hacer...</target>
        </trans-unit>
        <trans-unit id="78253234498ab9f80f071ee0cf6c83a489538d17" translate="yes" xml:space="preserve">
          <source>BUFFERED VS UNBUFFERED (OR STREAMED)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f95da7d5f97af571f044d5a433d68877d16ba4a5" translate="yes" xml:space="preserve">
          <source>BUFFERS</source>
          <target state="translated">BUFFERS</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
