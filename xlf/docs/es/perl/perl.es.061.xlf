<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="abdb50fe44b0e7ab1495a77ca76309d394c16e26" translate="yes" xml:space="preserve">
          <source>The next example show how to use the &lt;code&gt;LimitOutput&lt;/code&gt; option. Notice the use of two nested loops in this case. The outer loop reads the data from the input source - STDIN and the inner loop repeatedly calls &lt;code&gt;inflate&lt;/code&gt; until &lt;code&gt;$input&lt;/code&gt; is exhausted, we get an error, or the end of the stream is reached. One point worth remembering is by using the &lt;code&gt;LimitOutput&lt;/code&gt; option you also get &lt;code&gt;ConsumeInput&lt;/code&gt; set as well - this makes the code below much simpler.</source>
          <target state="translated">El siguiente ejemplo muestra c&amp;oacute;mo utilizar la opci&amp;oacute;n &lt;code&gt;LimitOutput&lt;/code&gt; . Observe el uso de dos bucles anidados en este caso. El bucle externo lee los datos de la fuente de entrada - STDIN y el bucle interno llama repetidamente a &lt;code&gt;inflate&lt;/code&gt; hasta que se agota &lt;code&gt;$input&lt;/code&gt; , obtenemos un error o se alcanza el final de la secuencia. Un punto que vale la pena recordar es que al usar la opci&amp;oacute;n &lt;code&gt;LimitOutput&lt;/code&gt; tambi&amp;eacute;n obtiene el conjunto &lt;code&gt;ConsumeInput&lt;/code&gt; ; esto hace que el c&amp;oacute;digo a continuaci&amp;oacute;n sea mucho m&amp;aacute;s simple.</target>
        </trans-unit>
        <trans-unit id="a73f1f7691d7497b711d0f4bac2e881b3c885873" translate="yes" xml:space="preserve">
          <source>The next example shows each input parameter evaluated late.</source>
          <target state="translated">El siguiente ejemplo muestra cada parámetro de entrada evaluado tardíamente.</target>
        </trans-unit>
        <trans-unit id="def9f1245a38d3c5116ce761f9376e6f2078f597" translate="yes" xml:space="preserve">
          <source>The next examples will use the following C++ class.</source>
          <target state="translated">Los próximos ejemplos utilizarán la siguiente clase de C++.</target>
        </trans-unit>
        <trans-unit id="6c82e2eba4791c1303c10eb37d70a72bf59badcd" translate="yes" xml:space="preserve">
          <source>The next option deals with the charset (a.k.a. character set) your terminal supports. In general, CPAN is English speaking territory, so the charset does not matter much but some CPAN have names that are outside the ASCII range. If your terminal supports UTF-8, you should say no to the next question. If it expects ISO-8859-1 (also known as LATIN1) then you should say yes. If it supports neither, your answer does not matter because you will not be able to read the names of some authors anyway. If you answer no, names will be output in UTF-8.</source>
          <target state="translated">La siguiente opción se refiere al juego de caracteres (también conocido como juego de caracteres)que su terminal soporta.En general,el CPAN es territorio de habla inglesa,por lo que el juego de caracteres no importa mucho,pero algunos CPAN tienen nombres que están fuera del rango ASCII.Si tu terminal soporta UTF-8,deberías decir que no a la siguiente pregunta.Si espera ISO-8859-1 (también conocido como LATIN1)entonces debería decir que sí.Si no soporta ninguno de los dos,tu respuesta no importa porque de todas formas no podrás leer los nombres de algunos autores.Si contestas que no,los nombres serán publicados en UTF-8.</target>
        </trans-unit>
        <trans-unit id="128477608ba084f3baead065e12f71790ccb5def" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt; es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="translated">El siguiente puntero para &lt;code&gt;BRANCH&lt;/code&gt; es interesante porque apunta a d&amp;oacute;nde debe ir la ejecuci&amp;oacute;n si falla la rama. Al ejecutar, si el motor intenta pasar de una rama a un &lt;code&gt;regnext&lt;/code&gt; que no es una rama, entonces el motor sabr&amp;aacute; que todo el conjunto de ramas ha fallado.</target>
        </trans-unit>
        <trans-unit id="49d098f677fc7d28016366882913ea295f0ea710" translate="yes" xml:space="preserve">
          <source>The next pointer for &lt;code&gt;BRANCH&lt;/code&gt;es is interesting in that it points at where execution should go if the branch fails. When executing, if the engine tries to traverse from a branch to a &lt;code&gt;regnext&lt;/code&gt; that isn't a branch then the engine will know that the entire set of branches has failed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b56244f1caeaf0b5b4e0b479de80d44c501b35d" translate="yes" xml:space="preserve">
          <source>The next step is interpolation in the text obtained, which is now delimiter-independent. There are multiple cases.</source>
          <target state="translated">El siguiente paso es la interpolación en el texto obtenido,que ahora es independiente del delimitador.Hay múltiples casos.</target>
        </trans-unit>
        <trans-unit id="2e9d420a49c5570abf7ae9f3e075e9465afea859" translate="yes" xml:space="preserve">
          <source>The next step is the type-specific context processing; in this case &lt;code&gt;cx_popsub&lt;/code&gt;. In part, this looks like:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b245543afec9985d508833acde280bdb2e09df89" translate="yes" xml:space="preserve">
          <source>The next step is to add some symlinks to system libraries. For example, the development software expect a library &lt;code&gt;libm.so&lt;/code&gt; that normally is a symlink to &lt;code&gt;libm.so.6&lt;/code&gt;. Synology only provides the latter and not the symlink.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0e87f516f02471787ab2f018e28d7851e0ac5f9" translate="yes" xml:space="preserve">
          <source>The next step is to pop savestack entries: &lt;code&gt;CX_LEAVE_SCOPE(cx)&lt;/code&gt; is just defined as &lt;code&gt;LEAVE_SCOPE(cx-&amp;gt;blk_oldsaveix)&lt;/code&gt;. Note that during the popping, it's possible for perl to call destructors, call &lt;code&gt;STORE&lt;/code&gt; to undo localisations of tied vars, and so on. Any of these can die or call &lt;code&gt;exit()&lt;/code&gt;. In this case, &lt;code&gt;dounwind()&lt;/code&gt; will be called, and the current context stack frame will be re-processed. Thus it is vital that all steps in popping a context are done in such a way to support reentrancy. The other alternative, of decrementing &lt;code&gt;cxstack_ix&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99d612978700e6928f957643eba3d0d61622b6ed" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system via email.</source>
          <target state="translated">El siguiente paso es enviar su parche al sistema de entradas del núcleo de Perl por correo electrónico.</target>
        </trans-unit>
        <trans-unit id="c53212a853da747bb753ac0eb206bd02a60002ca" translate="yes" xml:space="preserve">
          <source>The next step is to submit your patch to the Perl core ticket system.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82a6f456a2c90d50e2abfb7f37ee6f9a4299445f" translate="yes" xml:space="preserve">
          <source>The next task is to break the problem down into smaller problems that are easily converted into a regexp.</source>
          <target state="translated">La siguiente tarea es descomponer el problema en problemas más pequeños que se convierten fácilmente en un regexp.</target>
        </trans-unit>
        <trans-unit id="c9e21bae9fb5eef63978dcfa71c7a0d3cb21ec24" translate="yes" xml:space="preserve">
          <source>The next time you wish to make a patch, you need to start from the latest perl in a pristine state. Check you don't have any local changes or added files in your perl check-out which you wish to keep, then run these commands:</source>
          <target state="translated">La próxima vez que desee hacer un parche,debe comenzar con el último perl en un estado prístino.Comprueba que no tienes ningún cambio local o archivos añadidos en tu revisión de perl que desees conservar,entonces ejecuta estos comandos:</target>
        </trans-unit>
        <trans-unit id="79f58ceb3f799f52310d0fb9160eed5d3d3eaba7" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is it's like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="translated">Lo bueno de las pruebas de todo,en vez de simplemente comentar un bloque de pruebas,es que es como tener una lista programática de todo.Sabes cuánto trabajo queda por hacer,eres consciente de los errores que hay,y sabrás inmediatamente cuando se arreglen.</target>
        </trans-unit>
        <trans-unit id="93f6c477375802df02f9578f889b424f60ac9928" translate="yes" xml:space="preserve">
          <source>The nice part about todo tests, as opposed to simply commenting out a block of tests, is that it is like having a programmatic todo list. You know how much work is left to be done, you're aware of what bugs there are, and you'll know immediately when they're fixed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="92737be37077b1e4ee6685cd7da7d12b0a775c27" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C requires that certain things be set up in the console before Visual C will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run the &lt;code&gt;vcvars32.bat&lt;/code&gt; file to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; or &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . On a typical install of a Microsoft C compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files\Microsoft Visual Studio\VC98\Bin. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="translated">El nmake que viene con Visual C ++ ser&amp;aacute; suficiente para construir. Visual C requiere que se configuren ciertas cosas en la consola antes de que Visual C se ejecute correctamente. Para que una caja de consola pueda ejecutar el compilador de C, deber&amp;aacute; ejecutar previamente el archivo &lt;code&gt;vcvars32.bat&lt;/code&gt; para compilar para x86-32 y para x86-64 &lt;code&gt;vcvarsall.bat x64&lt;/code&gt; o &lt;code&gt;vcvarsamd64.bat&lt;/code&gt; . En una instalaci&amp;oacute;n t&amp;iacute;pica de un producto compilador de Microsoft C, estos archivos por lotes ya estar&amp;aacute;n en su &lt;code&gt;PATH&lt;/code&gt; variable de entorno para que pueda escribirlos sin una ruta absoluta en su consola. Si necesita encontrar la ruta absoluta al archivo por lotes, generalmente se encuentra en alg&amp;uacute;n lugar como C: \ Archivos de programa \ Microsoft Visual Studio \ VC98 \ Bin. Con algunos productos Micrsoft C m&amp;aacute;s nuevos (lanzados despu&amp;eacute;s de ~ 2004), el instalador colocar&amp;aacute; un acceso directo en el men&amp;uacute; de inicio para iniciar una nueva ventana de consola con la consola ya configurada para su arquitectura de destino (x86-32 o x86-64 o IA64) . Con los compiladores m&amp;aacute;s nuevos, tambi&amp;eacute;n puede usar los archivos por lotes m&amp;aacute;s antiguos si as&amp;iacute; lo desea.</target>
        </trans-unit>
        <trans-unit id="74b0871cc8ecf5b8ec07f0886c93ea7f99f29900" translate="yes" xml:space="preserve">
          <source>The nmake that comes with Visual C++ will suffice for building. Visual C++ requires that certain things be set up in the console before Visual C++ will sucessfully run. To make a console box be able to run the C compiler, you will need to beforehand, run &lt;code&gt;vcvarsall.bat x86&lt;/code&gt; to compile for x86-32 and for x86-64 &lt;code&gt;vcvarsall.bat amd64&lt;/code&gt;. On a typical install of a Microsoft C++ compiler product, these batch files will already be in your &lt;code&gt;PATH&lt;/code&gt; environment variable so you may just type them without an absolute path into your console. If you need to find the absolute path to the batch file, it is usually found somewhere like C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC. With some newer Micrsoft C products (released after ~2004), the installer will put a shortcut in the start menu to launch a new console window with the console already set up for your target architecture (x86-32 or x86-64 or IA64). With the newer compilers, you may also use the older batch files if you choose so.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d92d9609b16a9236c6b0750e878097cebaf141fa" translate="yes" xml:space="preserve">
          <source>The nmake that comes with the Platform SDK will suffice for building Perl. Make sure you are building within one of the &quot;Build Environment&quot; shells available after you install the Platform SDK from the Start Menu.</source>
          <target state="translated">La nmake que viene con el SDK de la plataforma será suficiente para construir Perl.Asegúrate de que estás construyendo dentro de uno de los shells de &quot;Entorno de Construcción&quot; disponibles después de instalar el SDK de la Plataforma desde el Menú de Inicio.</target>
        </trans-unit>
        <trans-unit id="4cf437af831d898cd280f5f9fa16e3b19f38db9a" translate="yes" xml:space="preserve">
          <source>The node type, either &lt;code&gt;section&lt;/code&gt; or &lt;code&gt;item&lt;/code&gt; . As an unofficial type, there is also &lt;code&gt;hyperlink&lt;/code&gt; , derived from e.g. &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</source>
          <target state="translated">El tipo de nodo, ya sea &lt;code&gt;section&lt;/code&gt; o &lt;code&gt;item&lt;/code&gt; . Como tipo no oficial, tambi&amp;eacute;n hay un &lt;code&gt;hyperlink&lt;/code&gt; , derivado de, por ejemplo, &lt;code&gt;L&amp;lt;&lt;a href=&quot;http://perl.com&quot;&gt;http://perl.com&lt;/a&gt;&amp;gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9d0e0bd31f6a31a67e6263a3a5396fe920511c99" translate="yes" xml:space="preserve">
          <source>The non-ASCII characters below 256 can have various meanings, depending on various things. (See, most notably, &lt;a href=&quot;perllocale&quot;&gt;perllocale&lt;/a&gt;.) But usually the whole range can be referred to as ISO-8859-1. Often, the term &quot;Latin-1&quot; (or &quot;Latin1&quot;) is used as an equivalent for ISO-8859-1. But some people treat &quot;Latin1&quot; as referring just to the characters in the range 128 through 255, or somethimes from 160 through 255. This documentation uses &quot;Latin1&quot; and &quot;Latin-1&quot; to refer to all 256 characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6361a2e3097d12a5b1db2175b6f9b22e2b4e005e" translate="yes" xml:space="preserve">
          <source>The non-blocking behaviour is an extension of the &lt;code&gt;IO::Socket::INET&lt;/code&gt; API, unique to &lt;code&gt;IO::Socket::IP&lt;/code&gt;, because the former does not support multi-homed non-blocking connect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8827c5b69a11959983a358ee79f064e14c978f0c" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt; ):</source>
          <target state="translated">El modificador no destructivo &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///r&lt;/a&gt;&lt;/code&gt; hace que se devuelva el resultado de la sustituci&amp;oacute;n en lugar de modificar &lt;code&gt;$_&lt;/code&gt; (o cualquier variable a la que est&amp;eacute; vinculado el sustituto con &lt;code&gt;=~&lt;/code&gt; ):</target>
        </trans-unit>
        <trans-unit id="33ea7bc6a1364954efde1784eb70e926a46ab789" translate="yes" xml:space="preserve">
          <source>The non-destructive modifier &lt;code&gt;s///r&lt;/code&gt; causes the result of the substitution to be returned instead of modifying &lt;code&gt;$_&lt;/code&gt; (or whatever variable the substitute was bound to with &lt;code&gt;=~&lt;/code&gt;):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3e24c19053882dd3539c4f0f017c48b302d8630" translate="yes" xml:space="preserve">
          <source>The non-zero numeric</source>
          <target state="translated">El número no cero</target>
        </trans-unit>
        <trans-unit id="ed0d308e2d36922ca367c5db784707665a50eda8" translate="yes" xml:space="preserve">
          <source>The normal Makefile.PL that h2xs generates doesn't know about the mylib directory. We need to tell it that there is a subdirectory and that we will be generating a library in it. Let's add the argument MYEXTLIB to the WriteMakefile call so that it looks like this:</source>
          <target state="translated">El Makefile.PL normal que genera h2xs no conoce el directorio mylib.Tenemos que decirle que hay un subdirectorio y que generaremos una biblioteca en él.Añadamos el argumento MYEXTLIB a la llamada de WriteMakefile para que se vea así:</target>
        </trans-unit>
        <trans-unit id="b1469f4963ec233a67445e77b1dc5adf4ccf9ab7" translate="yes" xml:space="preserve">
          <source>The normal course of action is to call:</source>
          <target state="translated">El curso normal de acción es llamar:</target>
        </trans-unit>
        <trans-unit id="32723b8237682738b9e39db42e26b25a535a8b05" translate="yes" xml:space="preserve">
          <source>The normal return provided by &lt;code&gt;scalar(%hash)&lt;/code&gt; is not available. What this means is that using %tied_hash in boolean context doesn't work right (currently this always tests false, regardless of whether the hash is empty or hash elements). [ This paragraph needs review in light of changes in 5.25 ]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ecf683f52c0f42f564cf7e0ed381f4bb97cc8438" translate="yes" xml:space="preserve">
          <source>The normal use of this class is like so:</source>
          <target state="translated">El uso normal de esta clase es así:</target>
        </trans-unit>
        <trans-unit id="1ac2010e9cf7828bd4211d3176636428b6a9a255" translate="yes" xml:space="preserve">
          <source>The normal way to run a Perl program is by making it directly executable, or else by passing the name of the source file as an argument on the command line. (An interactive Perl environment is also possible--see &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; for details on how to do that.) Upon startup, Perl looks for your program in one of the following places:</source>
          <target state="translated">La forma normal de ejecutar un programa Perl es haci&amp;eacute;ndolo directamente ejecutable, o pasando el nombre del archivo fuente como argumento en la l&amp;iacute;nea de comandos. (Tambi&amp;eacute;n es posible un entorno interactivo de Perl; consulte &lt;a href=&quot;perldebug&quot;&gt;perldebug&lt;/a&gt; para obtener detalles sobre c&amp;oacute;mo hacerlo). Al iniciarse, Perl busca su programa en uno de los siguientes lugares:</target>
        </trans-unit>
        <trans-unit id="42b613b12f582e26d7e800d066ea1eb52e714a90" translate="yes" xml:space="preserve">
          <source>The not-a-number as a constant:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46672cb58512b6dfcf1bfa852b6fb1012267b6a3" translate="yes" xml:space="preserve">
          <source>The notation still looks a little cumbersome, so there's one more abbreviation:</source>
          <target state="translated">La notación todavía parece un poco engorrosa,así que hay una abreviatura más:</target>
        </trans-unit>
        <trans-unit id="faf2109c5b26dde1813deee78331f15408acfe4a" translate="yes" xml:space="preserve">
          <source>The notion that an empty &lt;b&gt;derived class&lt;/b&gt; should behave exactly like its &lt;b&gt;base class&lt;/b&gt;.</source>
          <target state="translated">La noci&amp;oacute;n de que una &lt;b&gt;clase derivada&lt;/b&gt; vac&amp;iacute;a deber&amp;iacute;a comportarse exactamente como su &lt;b&gt;clase base&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="d26e84b13c8c8748080fe4085da63e6e9ef520f9" translate="yes" xml:space="preserve">
          <source>The notion that you can tell an &lt;b&gt;object&lt;/b&gt; to do something generic, and the object will interpret the command in different ways depending on its type. [&amp;lt; Greek &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, many forms.]</source>
          <target state="translated">La noci&amp;oacute;n de que puede decirle a un &lt;b&gt;objeto&lt;/b&gt; que haga algo gen&amp;eacute;rico, y el objeto interpretar&amp;aacute; el comando de diferentes maneras seg&amp;uacute;n su tipo. [&amp;lt;Griego &amp;pi;&amp;omicron;&amp;lambda;&amp;upsilon;- + &amp;mu;&amp;omicron;&amp;rho;ϕή, muchas formas.]</target>
        </trans-unit>
        <trans-unit id="ad272f88bed19c2e6cec366907b96e0baf112d7c" translate="yes" xml:space="preserve">
          <source>The notion that, with a complete set of simple tools that work well together, you can build almost anything you want. Which is fine if you&amp;rsquo;re assembling a tricycle, but if you&amp;rsquo;re building a defranishizing comboflux regurgalator, you really want your own machine shop in which to build special tools. Perl is sort of a machine shop.</source>
          <target state="translated">La noci&amp;oacute;n de que, con un conjunto completo de herramientas simples que funcionan bien juntas, puede construir casi cualquier cosa que desee. Lo cual est&amp;aacute; bien si est&amp;aacute; ensamblando un triciclo, pero si est&amp;aacute; construyendo un regulador comboflux que desgrana, realmente quiere su propio taller de m&amp;aacute;quinas en el que construir herramientas especiales. Perl es una especie de taller de m&amp;aacute;quinas.</target>
        </trans-unit>
        <trans-unit id="d8cd6888cbc4c56537079a3ca6af05881fde2aca" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt; , which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="translated">El identificador de archivo nulo &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; es especial: se puede usar para emular el comportamiento de &lt;b&gt;sed&lt;/b&gt; y &lt;b&gt;awk&lt;/b&gt; , y cualquier otro programa de filtro Unix que tome una lista de nombres de archivos, haciendo lo mismo con cada l&amp;iacute;nea de entrada de todos ellos. La entrada de &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; proviene de la entrada est&amp;aacute;ndar o de cada archivo enumerado en la l&amp;iacute;nea de comando. As&amp;iacute; es como funciona: la primera vez que se eval&amp;uacute;a &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; , se &lt;code&gt;@ARGV&lt;/code&gt; matriz @ARGV y, si est&amp;aacute; vac&amp;iacute;a, &lt;code&gt;$ARGV[0]&lt;/code&gt; se establece en &lt;code&gt;&quot;-&quot;&lt;/code&gt; , que cuando se abre le proporciona una entrada est&amp;aacute;ndar. El &lt;code&gt;@ARGV&lt;/code&gt; array se procesa como una lista de nombres de archivos. El lazo</target>
        </trans-unit>
        <trans-unit id="2eb5648c665e9498b1d4e1c662b451796e069c6c" translate="yes" xml:space="preserve">
          <source>The null filehandle &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is special: it can be used to emulate the behavior of &lt;b&gt;sed&lt;/b&gt; and &lt;b&gt;awk&lt;/b&gt;, and any other Unix filter program that takes a list of filenames, doing the same to each line of input from all of them. Input from &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; comes either from standard input, or from each file listed on the command line. Here's how it works: the first time &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; is evaluated, the &lt;code&gt;@ARGV&lt;/code&gt; array is checked, and if it is empty, &lt;code&gt;$ARGV[0]&lt;/code&gt; is set to &lt;code&gt;&quot;-&quot;&lt;/code&gt;, which when opened gives you standard input. The &lt;code&gt;@ARGV&lt;/code&gt; array is then processed as a list of filenames. The loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d22af8d2b7cf7cf2c570f3f335ab2a750c99b68" translate="yes" xml:space="preserve">
          <source>The null list is represented by (). Interpolating it in a list has no effect. Thus ((),(),()) is equivalent to (). Similarly, interpolating an array with no elements is the same as if no array had been interpolated at that point.</source>
          <target state="translated">La lista nula está representada por ().Interpolarla en una lista no tiene ningún efecto.Por lo tanto,((),(),())es equivalente a ().De forma similar,interpolar una matriz sin elementos es lo mismo que si no se hubiera interpolado ninguna matriz en ese punto.</target>
        </trans-unit>
        <trans-unit id="1797c45a73a5a87e1dcbfe3ceafa93cc5c4f9d01" translate="yes" xml:space="preserve">
          <source>The null loop times can be cached, the key being the number of rounds. The caching can be controlled using calls like these:</source>
          <target state="translated">Los tiempos del bucle nulo pueden ser almacenados en la memoria caché,la clave es el número de rondas.El caching puede ser controlado usando llamadas como estas:</target>
        </trans-unit>
        <trans-unit id="c43d1fda274f03a112b4082e8056292b9c40d862" translate="yes" xml:space="preserve">
          <source>The number 0, the strings &lt;code&gt;'0'&lt;/code&gt; and &lt;code&gt;&quot;&quot;&lt;/code&gt; , the empty list &lt;code&gt;()&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; are all false in a boolean context. All other values are true. Negation of a true value by &lt;code&gt;!&lt;/code&gt; or &lt;code&gt;not&lt;/code&gt; returns a special false value. When evaluated as a string it is treated as &lt;code&gt;&quot;&quot;&lt;/code&gt; , but as a number, it is treated as 0. Most Perl operators that return true or false behave this way.</source>
          <target state="translated">El n&amp;uacute;mero 0, las cadenas &lt;code&gt;'0'&lt;/code&gt; y &lt;code&gt;&quot;&quot;&lt;/code&gt; , la lista vac&amp;iacute;a &lt;code&gt;()&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; son todos falsos en un contexto booleano. Todos los dem&amp;aacute;s valores son verdaderos. &amp;iexcl;Negaci&amp;oacute;n de un valor verdadero por &lt;code&gt;!&lt;/code&gt; o &lt;code&gt;not&lt;/code&gt; devuelve un valor falso especial. Cuando se eval&amp;uacute;a como una cadena, se trata como &lt;code&gt;&quot;&quot;&lt;/code&gt; , pero como un n&amp;uacute;mero, se trata como 0. La mayor&amp;iacute;a de los operadores de Perl que devuelven verdadero o falso se comportan de esta manera.</target>
        </trans-unit>
        <trans-unit id="692f2a5740e6be2f2f4c50b1195b7318b218c93b" translate="yes" xml:space="preserve">
          <source>The number after Perl (i.e. the 5 after Perl 5) is the major release of the perl interpreter as well as the version of the language. Each major version has significant differences that earlier versions cannot support.</source>
          <target state="translated">El número después del Perl (es decir,el 5 después del 5 de Perl)es la principal novedad del intérprete de perl,así como la versión del idioma.Cada versión principal tiene diferencias significativas que las versiones anteriores no pueden soportar.</target>
        </trans-unit>
        <trans-unit id="3191b134cb3717b47b8c71b05a1d940752bad987" translate="yes" xml:space="preserve">
          <source>The number for the &quot;generation&quot; of the test run. The first generation is 1 (one) and subsequent generations are 2, 3, etc.</source>
          <target state="translated">El número de la &quot;generación&quot; de la prueba.La primera generación es 1 (uno)y las siguientes son 2,3,etc.</target>
        </trans-unit>
        <trans-unit id="2535d279c5200f7be07d31d15ce44068cdb20ffd" translate="yes" xml:space="preserve">
          <source>The number of &quot;hidden&quot; sectors for this partition. Actually this is the number of sectors found prior to this partition, that is, the starting offset [as found in &lt;code&gt;$uStartLow&lt;/code&gt; and &lt;code&gt;$ivStartHigh&lt;/code&gt;] divided by the number of bytes per sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0a9d7413ce0d5ac2d4144491992bf44868224aa" translate="yes" xml:space="preserve">
          <source>The number of bytes in each sector.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fa99ba7fda4b251af40087fa9ad0d33252bbd195" translate="yes" xml:space="preserve">
          <source>The number of concurrent jobs this formatter will handle.</source>
          <target state="translated">El número de trabajos simultáneos que este formateador manejará.</target>
        </trans-unit>
        <trans-unit id="36ffefa76cdb58a51fa74dc31caa513844b361e2" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after &lt;code&gt;av_fill()&lt;/code&gt; returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d2ba45a48d3868e33de1ec7e956df019e81e42a" translate="yes" xml:space="preserve">
          <source>The number of elements in the array will be &lt;code&gt;fill + 1&lt;/code&gt; after av_fill() returns. If the array was previously shorter, then the additional elements appended are set to NULL. If the array was longer, then the excess elements are freed. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; is the same as &lt;code&gt;av_clear(av)&lt;/code&gt; .</source>
          <target state="translated">El n&amp;uacute;mero de elementos en la matriz se &lt;code&gt;fill + 1&lt;/code&gt; despu&amp;eacute;s de que av_fill () regrese. Si la matriz era anteriormente m&amp;aacute;s corta, los elementos adicionales agregados se establecen en NULL. Si la matriz era m&amp;aacute;s larga, se liberan los elementos sobrantes. &lt;code&gt;av_fill(av, -1)&lt;/code&gt; es lo mismo que &lt;code&gt;av_clear(av)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b9161f7d8230483ece3123e0d04957cb7a945f72" translate="yes" xml:space="preserve">
          <source>The number of items in a hash can be obtained by doing:</source>
          <target state="translated">El número de artículos en un hash se puede obtener haciendo:</target>
        </trans-unit>
        <trans-unit id="e4c9a33204f057eb951c01e0df7449caf0e7389f" translate="yes" xml:space="preserve">
          <source>The number of lines left on the page of the currently selected output channel.</source>
          <target state="translated">El número de líneas que quedan en la página del canal de salida actualmente seleccionado.</target>
        </trans-unit>
        <trans-unit id="8b661ef45c3e83256fc7a63d23f91b2343af29ac" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt; . The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Many error messages report both values, if available.</source>
          <target state="translated">El n&amp;uacute;mero de l&amp;iacute;neas le&amp;iacute;das antes de este, m&amp;aacute;s 1. Perl mantiene un n&amp;uacute;mero de l&amp;iacute;nea separado para cada fuente o archivo de entrada que abre. El n&amp;uacute;mero de l&amp;iacute;nea del archivo de origen actual est&amp;aacute; representado por &lt;code&gt;__LINE__&lt;/code&gt; . El n&amp;uacute;mero de l&amp;iacute;nea de entrada actual (para el archivo que se ley&amp;oacute; m&amp;aacute;s recientemente mediante &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt; ) est&amp;aacute; representado por &lt;code&gt;$.&lt;/code&gt; ( &lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt; ) variable. Muchos mensajes de error informan sobre ambos valores, si est&amp;aacute;n disponibles.</target>
        </trans-unit>
        <trans-unit id="2c32dc65a0983301d8b932b2ff7d13fbe8041de2" translate="yes" xml:space="preserve">
          <source>The number of lines read previous to this one, plus 1. Perl keeps a separate line number for each source or input file it opens. The current source file&amp;rsquo;s line number is represented by &lt;code&gt;__LINE__&lt;/code&gt;. The current input line number (for the file that was most recently read via &lt;code&gt;&amp;lt;FH&amp;gt;&lt;/code&gt;) is represented by the &lt;code&gt;$.&lt;/code&gt; (&lt;code&gt;$INPUT_LINE_NUMBER&lt;/code&gt;) variable. Many error messages report both values, if available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c26ea7021e22061094b1160120712623c26587e" translate="yes" xml:space="preserve">
          <source>The number of retrieval pointers that RMS has to maintain (0 to 127255)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7adfc7b3eafb7c58d678ada0cc8dfa22b0798638" translate="yes" xml:space="preserve">
          <source>The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.</source>
          <target state="translated">El número de segundos que el programa funcionó antes de ser terminado,o 0 si no hubo tiempo de espera.</target>
        </trans-unit>
        <trans-unit id="3f0ee453c0514a141454bf624811de74f7121fbc" translate="yes" xml:space="preserve">
          <source>The number of sectors in each track.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="701c3dee8ddb529dd17cdf0b20bfe4db85c06698" translate="yes" xml:space="preserve">
          <source>The number of spaces to indent regular text, and the default indentation for &lt;code&gt;=over&lt;/code&gt; blocks. Defaults to 4.</source>
          <target state="translated">El n&amp;uacute;mero de espacios para aplicar sangr&amp;iacute;a al texto normal y la sangr&amp;iacute;a predeterminada para &lt;code&gt;=over&lt;/code&gt; bloques. Por defecto es 4.</target>
        </trans-unit>
        <trans-unit id="e68baf88a8ecb32bf1315047769f8d0e186bb5f6" translate="yes" xml:space="preserve">
          <source>The number of tests actually seen</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="65eb3487d858db8bd02f6c81679897d6d005441b" translate="yes" xml:space="preserve">
          <source>The number of tests in your script. This means all ok() and skip() calls.</source>
          <target state="translated">El número de pruebas en tu guión.Esto significa todas las llamadas ok()y skip().</target>
        </trans-unit>
        <trans-unit id="7a3c79429902da3d2d3d81b8c529fe97388165ba" translate="yes" xml:space="preserve">
          <source>The number of tests that were planned</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="34e2b7e50e91d743cd4a7b27aa45939dc1c6581f" translate="yes" xml:space="preserve">
          <source>The number of tests which failed</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2e318858e274a3b2d56e4e8546a3453a590b339" translate="yes" xml:space="preserve">
          <source>The number of tests with TODO directives.</source>
          <target state="translated">El número de pruebas con directivas TODO.</target>
        </trans-unit>
        <trans-unit id="134bbf3c12ccdb3b17c2429c883dacdca5457a57" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;&quot;comp&quot;&lt;/a&gt; routine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c43b06bec0238ed7c22fd0d6e38144c2bb8f0d70" translate="yes" xml:space="preserve">
          <source>The number of times the structure is referenced. When this falls to 0, the regexp is automatically freed by a call to pregfree. This should be set to 1 in each engine's &lt;a href=&quot;#comp&quot;&gt;comp&lt;/a&gt; routine.</source>
          <target state="translated">El n&amp;uacute;mero de veces que se hace referencia a la estructura. Cuando esto cae a 0, la expresi&amp;oacute;n regular se libera autom&amp;aacute;ticamente mediante una llamada a pregfree. Esto debe establecerse en 1 en la rutina de &lt;a href=&quot;#comp&quot;&gt;compensaci&amp;oacute;n de&lt;/a&gt; cada motor .</target>
        </trans-unit>
        <trans-unit id="c7aa069edb979af7f298ec7da8f6245a682e62f6" translate="yes" xml:space="preserve">
          <source>The number of times the test has failed.</source>
          <target state="translated">El número de veces que la prueba ha fallado.</target>
        </trans-unit>
        <trans-unit id="f294a946b3a2f3d15985548e48a89b85b334300e" translate="yes" xml:space="preserve">
          <source>The number of times the test has passed.</source>
          <target state="translated">El número de veces que la prueba ha pasado.</target>
        </trans-unit>
        <trans-unit id="1ea0b9d7d53aa08d0e622974bcb543d8e9e34567" translate="yes" xml:space="preserve">
          <source>The number of tracks in each cylinder.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6ecf3312d862847aadfe59c31f3bcfa85cc3016b" translate="yes" xml:space="preserve">
          <source>The numbering within each branch will be as normal, and any groups following this construct will be numbered as though the construct contained only one branch, that being the one with the most capture groups in it.</source>
          <target state="translated">La numeración dentro de cada rama será la normal,y cualquier grupo que siga esta construcción será numerado como si la construcción contuviera una sola rama,que es la que tiene más grupos de captura en ella.</target>
        </trans-unit>
        <trans-unit id="d3f5b7856c836d8ae15bae5d2911f695737356ba" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigFloat. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">Los números se almacenan como objetos,y sus interiores pueden cambiar en cualquier momento,especialmente entre operaciones matemáticas.Los objetos también pueden pertenecer a diferentes clases,como Matemáticas::BigInt,o Matemáticas::BigFloat.Mezclarlos,incluso con escalares normales,no es extraordinario,sino normal y esperado.</target>
        </trans-unit>
        <trans-unit id="0d52076285e4f235f1d8532711b46d3578467720" translate="yes" xml:space="preserve">
          <source>The numbers are stored as objects, and their internals might change at anytime, especially between math operations. The objects also might belong to different classes, like Math::BigInt, or Math::BigInt::Lite. Mixing them together, even with normal scalars is not extraordinary, but normal and expected.</source>
          <target state="translated">Los números se almacenan como objetos,y sus interiores pueden cambiar en cualquier momento,especialmente entre operaciones matemáticas.Los objetos también pueden pertenecer a diferentes clases,como Matemáticas::BigInt,o Matemáticas::BigInt::Lite.Mezclarlos,incluso con escalares normales,no es extraordinario,sino normal y esperado.</target>
        </trans-unit>
        <trans-unit id="d62316f7524c3cde4e634f1fd21e7ac49fd46233" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to 0777), to be modified by the current &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="translated">El modo de permisos num&amp;eacute;ricos que se aplicar&amp;aacute; a cada directorio creado (predeterminado en 0777), que ser&amp;aacute; modificado por la &lt;code&gt;&lt;a href=&quot;../functions/umask&quot;&gt;umask&lt;/a&gt;&lt;/code&gt; actual . Si el directorio ya existe (y por lo tanto no es necesario crearlo), los permisos no se modificar&amp;aacute;n.</target>
        </trans-unit>
        <trans-unit id="5dffd7d41fb958bc0c87e558861a514e1606e35f" translate="yes" xml:space="preserve">
          <source>The numeric permissions mode to apply to each created directory (defaults to &lt;code&gt;0777&lt;/code&gt;), to be modified by the current &lt;code&gt;umask&lt;/code&gt;. If the directory already exists (and thus does not need to be created), the permissions will not be modified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41e019f9571f72909dc6712d8ba72dd87f1a9db6" translate="yes" xml:space="preserve">
          <source>The numeric value of the COP's hint flags, or an empty string if this is not a COP.</source>
          <target state="translated">El valor numérico de los indicadores del COP,o una cadena vacía si no es un COP.</target>
        </trans-unit>
        <trans-unit id="419fea734cd75b36bfd625f906eafadf3594cbdf" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's flags.</source>
          <target state="translated">El valor numérico de las banderas de la OP.</target>
        </trans-unit>
        <trans-unit id="e13f8ed0a121e4b7f2050aa9d7bd9bd36bdb9772" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's private flags.</source>
          <target state="translated">El valor numérico de las banderas privadas de la OP.</target>
        </trans-unit>
        <trans-unit id="afdb5b0bce9be5274063464faba90d66849c8cbe" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's targ.</source>
          <target state="translated">El valor numérico del targ de la OP.</target>
        </trans-unit>
        <trans-unit id="e4bd78ffa7c276231e5c09572ec79b0007d54b06" translate="yes" xml:space="preserve">
          <source>The numeric value of the OP's type, in decimal.</source>
          <target state="translated">El valor numérico del tipo de OP,en decimal.</target>
        </trans-unit>
        <trans-unit id="38a4063b54e70e2579ef41b45391d9edbcb80e9f" translate="yes" xml:space="preserve">
          <source>The object actually used is of the class &lt;a href=&quot;ExtUtils::MY&quot;&gt;MY&lt;/a&gt; which allows you to override bits of MakeMaker inside your Makefile.PL by declaring MY::foo() methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a6a6fda3b81e72660dadfe40e0c6cbbf8b62d9b" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">El objeto se convierte en una subclase de &lt;code&gt;IO::Handle&lt;/code&gt; y se convierte en un identificador en el extremo de lectura de la tuber&amp;iacute;a. Si se dan &lt;code&gt;ARGS&lt;/code&gt; , se llama a la &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; y se pasan &lt;code&gt;ARGS&lt;/code&gt; a exec.</target>
        </trans-unit>
        <trans-unit id="7b25df29627971e66202a04141c07ea01261d426" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt; , and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="translated">El objeto se convierte en una subclase de &lt;code&gt;IO::Handle&lt;/code&gt; y se convierte en un identificador en el extremo de escritura de la tuber&amp;iacute;a. Si se dan &lt;code&gt;ARGS&lt;/code&gt; , se llama a la &lt;code&gt;&lt;a href=&quot;../functions/fork&quot;&gt;fork&lt;/a&gt;&lt;/code&gt; y se pasan &lt;code&gt;ARGS&lt;/code&gt; a exec.</target>
        </trans-unit>
        <trans-unit id="fc8e459a67162585ed649c073732c1f153656661" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the reading end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="960d4697beb3f7754f165a72fa86b9e206ef71bf" translate="yes" xml:space="preserve">
          <source>The object is re-blessed into a sub-class of &lt;code&gt;IO::Handle&lt;/code&gt;, and becomes a handle at the writing end of the pipe. If &lt;code&gt;ARGS&lt;/code&gt; are given then &lt;code&gt;fork&lt;/code&gt; is called and &lt;code&gt;ARGS&lt;/code&gt; are passed to exec.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40e63c161da60788dfbf25012eced379198e6461" translate="yes" xml:space="preserve">
          <source>The object or class on which a method is called is passed as one of the method's arguments, not as a separate &lt;code&gt;this&lt;/code&gt; value.</source>
          <target state="translated">El objeto o clase en la que se llama un m&amp;eacute;todo se pasa como uno de los argumentos del m&amp;eacute;todo, no como un separar &lt;code&gt;this&lt;/code&gt; valor.</target>
        </trans-unit>
        <trans-unit id="ac2428a9234f597f267cadbd7f0f16da4708e348" translate="yes" xml:space="preserve">
          <source>The object oriented interface lets you configure your own encoding or decoding style, within the limits of supported formats.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="15b98c3fd23a1ef70ae8197a79094d62be1e4c5c" translate="yes" xml:space="preserve">
          <source>The object oriented interface to &lt;code&gt;Digest::MD5&lt;/code&gt; is described in this section. After a &lt;code&gt;Digest::MD5&lt;/code&gt; object has been created, you will add data to it and finally ask for the digest in a suitable format. A single object can be used to calculate multiple digests.</source>
          <target state="translated">La interfaz orientada a objetos de &lt;code&gt;Digest::MD5&lt;/code&gt; se describe en esta secci&amp;oacute;n. Despu&amp;eacute;s de que se haya creado un objeto &lt;code&gt;Digest::MD5&lt;/code&gt; , le agregar&amp;aacute; datos y finalmente solicitar&amp;aacute; el resumen en un formato adecuado. Se puede usar un solo objeto para calcular m&amp;uacute;ltiples res&amp;uacute;menes.</target>
        </trans-unit>
        <trans-unit id="e33be9a872157d87d04d9ab372ad71b851a50cce" translate="yes" xml:space="preserve">
          <source>The object registry is also used to repair a field hash after thread cloning. Here, the entire object registry is processed. For every reference found there, the field hashes it has used are visited and the entry is updated.</source>
          <target state="translated">El registro de objetos también se utiliza para reparar un hash de campo después de la clonación de hilos.Aquí se procesa todo el registro de objetos.Por cada referencia que se encuentra allí,se visitan los hashes de campo que ha utilizado y se actualiza la entrada.</target>
        </trans-unit>
        <trans-unit id="90c880f65630ae33e5e929b9f5badc61ea20d016" translate="yes" xml:space="preserve">
          <source>The object registry keeps track of references that have been used as field hash keys. The keys are generated from the reference address like in a field hash (though the registry isn't a field hash). Each value is a weak copy of the original reference, stored in an &lt;code&gt;SV&lt;/code&gt; that is itself magical (&lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; again). The magical structure holds a list (another hash, really) of field hashes that the reference has been used with. When the weakref becomes stale, the magic is activated and uses the list to delete the reference from all field hashes it has been used with. After that, the entry is removed from the object registry itself. Implicitly, that frees the magic structure and the storage it has been using.</source>
          <target state="translated">El registro de objetos realiza un seguimiento de las referencias que se han utilizado como claves hash de campo. Las claves se generan a partir de la direcci&amp;oacute;n de referencia como en un hash de campo (aunque el registro no es un hash de campo). Cada valor es una copia d&amp;eacute;bil de la referencia original, almacenada en un &lt;code&gt;SV&lt;/code&gt; que en s&amp;iacute; mismo es m&amp;aacute;gico ( &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; nuevamente). La estructura m&amp;aacute;gica contiene una lista (otro hash, en realidad) de hashes de campo con los que se ha utilizado la referencia. Cuando la referencia d&amp;eacute;bil se vuelve obsoleta, la magia se activa y usa la lista para eliminar la referencia de todos los hashes de campo con los que se ha usado. Despu&amp;eacute;s de eso, la entrada se elimina del registro de objetos. Impl&amp;iacute;citamente, eso libera la estructura m&amp;aacute;gica y el almacenamiento que ha estado usando.</target>
        </trans-unit>
        <trans-unit id="d72391ab64988da73b0a894ff996ef426650aa27" translate="yes" xml:space="preserve">
          <source>The object returned by &lt;code&gt;builder()&lt;/code&gt; may change at runtime so you should call &lt;code&gt;builder()&lt;/code&gt; inside each function rather than store it in a global.</source>
          <target state="translated">El objeto devuelto por &lt;code&gt;builder()&lt;/code&gt; puede cambiar en tiempo de ejecuci&amp;oacute;n, por lo que debe llamar a &lt;code&gt;builder()&lt;/code&gt; dentro de cada funci&amp;oacute;n en lugar de almacenarlo en un global.</target>
        </trans-unit>
        <trans-unit id="0c2931896c0ae38a7dcf1ceb36dc3228043fb889" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON null value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dce4a435aaab3b8ce3beeeab8876d2f9007b9517" translate="yes" xml:space="preserve">
          <source>The object will be serialised as a JSON number value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afec221431749f399e52c9677871688987dfbb46" translate="yes" xml:space="preserve">
          <source>The oct() function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="translated">La funci&amp;oacute;n oct () se usa com&amp;uacute;nmente cuando una cadena como &lt;code&gt;644&lt;/code&gt; necesita convertirse en un modo de archivo, por ejemplo. Aunque Perl convierte autom&amp;aacute;ticamente cadenas en n&amp;uacute;meros seg&amp;uacute;n sea necesario, esta conversi&amp;oacute;n autom&amp;aacute;tica asume la base 10.</target>
        </trans-unit>
        <trans-unit id="09c9c348da6207c41e75d17f6b539e26d9c4cd1f" translate="yes" xml:space="preserve">
          <source>The official (threaded) builds from HP, as they are shipped on the Application DVD/CD's are available on &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; for both PA-RISC and IPF (Itanium Processor Family). They are built with the HP ANSI-C compiler. Up till 5.8.8 that was done by ActiveState.</source>
          <target state="translated">Las compilaciones oficiales (subprocesadas) de HP, ya que se env&amp;iacute;an en los DVD / CD de la aplicaci&amp;oacute;n, est&amp;aacute;n disponibles en &lt;a href=&quot;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&quot;&gt;http://www.software.hp.com/portal/swdepot/displayProductInfo.do?productNumber=PERL&lt;/a&gt; para ambos PA-RISC e IPF (familia de procesadores Itanium). Est&amp;aacute;n construidos con el compilador HP ANSI-C. Hasta 5.8.8 eso fue hecho por ActiveState.</target>
        </trans-unit>
        <trans-unit id="94afd3df7a7936cd7021df875b7cc881f99b3a21" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at GitHub. Posting to the list and the bugtracker is not a right: all participants in discussion are expected to adhere to a standard of conduct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="122c2a7e4876853c52ff4c6bbc23491cac5b2166" translate="yes" xml:space="preserve">
          <source>The official forum for the development of perl is the perl5-porters mailing list, mentioned above, and its bugtracker at rt.perl.org. All participants in discussion there are expected to adhere to a standard of conduct.</source>
          <target state="translated">El foro oficial para el desarrollo del perl es la lista de correo de perl5-porters,mencionada anteriormente,y su bugtracker en rt.perl.org.Se espera que todos los participantes en los debates de esa lista se adhieran a una norma de conducta.</target>
        </trans-unit>
        <trans-unit id="206093c38ad914ff8435f60fe865bef14dbff945" translate="yes" xml:space="preserve">
          <source>The official home of this project on the web.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="318a2a25e89f6df5d0fee0930895c69196eba39a" translate="yes" xml:space="preserve">
          <source>The official name of VMS as of this writing is OpenVMS.</source>
          <target state="translated">El nombre oficial del VMS a partir de este escrito es OpenVMS.</target>
        </trans-unit>
        <trans-unit id="9e04119b1083995ffa8b809847e51388388f1606" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is</source>
          <target state="translated">La página web oficial de Berkeley DB es</target>
        </trans-unit>
        <trans-unit id="9ae89a7a7356b47202ed85668f00ace437b2ed69" translate="yes" xml:space="preserve">
          <source>The official web site for Berkeley DB is &lt;a href=&quot;http://www.oracle.com/technology/products/berkeley-db/db/index.html&quot;&gt;http://www.oracle.com/technology/products/berkeley-db/db/index.html&lt;/a&gt;. All versions of Berkeley DB are available there.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5b569f6bcadd4a6fd7badb484a162b25dd85b5b2" translate="yes" xml:space="preserve">
          <source>The offset from the start of the file in hex.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ba5881483f263a1268bc8d8cd7d41b8c76ce28" translate="yes" xml:space="preserve">
          <source>The old behavior is currently retained, warts and all, for backwards compatibility, but users are encouraged to change any code that tests &lt;code&gt;$!&lt;/code&gt; against &lt;code&gt;E*&lt;/code&gt; constants for Winsock errors to instead test &lt;code&gt;$^E&lt;/code&gt; against &lt;code&gt;WSAE*&lt;/code&gt; constants. After a suitable deprecation period, which started with Perl 5.24, the old behavior may be removed, leaving &lt;code&gt;$!&lt;/code&gt; unchanged after Winsock function calls, to avoid any possible confusion over which error variable to check.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="065d987b91e5e5831e84ee6eb6792bbd1900fe0e" translate="yes" xml:space="preserve">
          <source>The old behaviour of immediate croaking can be re-instated by setting &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; to some &lt;code&gt;FALSE&lt;/code&gt; value.</source>
          <target state="translated">El antiguo comportamiento de croar inmediato se puede restablecer configurando &lt;code&gt;$Storable::accept_future_minor&lt;/code&gt; en alg&amp;uacute;n valor &lt;code&gt;FALSE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5b386f850ac3d208fd4890f0e6e16aecfa5e9221" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="translated">El estilo de formato de visualizaci&amp;oacute;n antiguo, que puede tener valores &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; o &lt;code&gt;&quot;polar&quot;&lt;/code&gt; , se puede cambiar mediante el par&amp;aacute;metro &lt;code&gt;&quot;style&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e9569a2edc0d7e856dea14bff6ac690edcc52042" translate="yes" xml:space="preserve">
          <source>The old display format style, which can have values &lt;code&gt;&quot;cartesian&quot;&lt;/code&gt; or &lt;code&gt;&quot;polar&quot;&lt;/code&gt;, can be changed using the &lt;code&gt;&quot;style&quot;&lt;/code&gt; parameter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ffd1da07401f04d08ba15b9c723b21da5d25d24" translate="yes" xml:space="preserve">
          <source>The old form of &lt;code&gt;gv_init_pvn()&lt;/code&gt;. It does not work with UTF-8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the &lt;code&gt;GV_ADDMULTI&lt;/code&gt; flag will be passed to &lt;code&gt;gv_init_pvn()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e3404a80aca7096e4f7cc6df65a56468be124f24" translate="yes" xml:space="preserve">
          <source>The old form of gv_init_pvn(). It does not work with UTF8 strings, as it has no flags parameter. If the &lt;code&gt;multi&lt;/code&gt; parameter is set, the GV_ADDMULTI flag will be passed to gv_init_pvn().</source>
          <target state="translated">La forma antigua de gv_init_pvn (). No funciona con cadenas UTF8, ya que no tiene par&amp;aacute;metros de banderas. Si se establece el par&amp;aacute;metro &lt;code&gt;multi&lt;/code&gt; , la bandera GV_ADDMULTI se pasar&amp;aacute; a gv_init_pvn ().</target>
        </trans-unit>
        <trans-unit id="79188e84f37b880e4a772b5ff3206627de3b874e" translate="yes" xml:space="preserve">
          <source>The old home for the module tests, you shouldn't put anything new in here. There are still some bits and pieces hanging around in here that need to be moved. Perhaps you could move them? Thanks!</source>
          <target state="translated">La vieja casa para las pruebas de módulos,no deberías poner nada nuevo aquí.Todavía hay algunas partes y piezas colgando por aquí que necesitan ser movidas.¿Quizás podrías moverlos? Gracias.</target>
        </trans-unit>
        <trans-unit id="37d530fbe2e5d190496e0bd800701dfa6c514e1c" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt; ; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt; , which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</source>
          <target state="translated">El delimitador de paquete antiguo era una comilla simple, pero ahora el delimitador preferido es el de dos puntos dobles, en parte porque es m&amp;aacute;s legible para humanos y en parte porque es m&amp;aacute;s legible para macros &lt;b&gt;emacs&lt;/b&gt; . Tambi&amp;eacute;n hace que los programadores de C ++ sientan que saben lo que est&amp;aacute; pasando, en lugar de usar la comilla simple como separador, que estaba ah&amp;iacute; para hacer que los programadores de Ada sintieran que sab&amp;iacute;an lo que estaba pasando. Debido a que la sintaxis pasada de moda todav&amp;iacute;a es compatible por compatibilidad con versiones anteriores, si intenta usar una cadena como &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt; , acceder&amp;aacute; a &lt;code&gt;$owner::s&lt;/code&gt; ; es decir, la variable $ s en el &lt;code&gt;owner&lt;/code&gt; paquete , que probablemente no sea lo que quiso decir. Use llaves para eliminar la ambig&amp;uuml;edad, como en &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="511ae26f8725e1c7736ec75894aed8905e42064b" translate="yes" xml:space="preserve">
          <source>The old package delimiter was a single quote, but double colon is now the preferred delimiter, in part because it's more readable to humans, and in part because it's more readable to &lt;b&gt;emacs&lt;/b&gt; macros. It also makes C++ programmers feel like they know what's going on--as opposed to using the single quote as separator, which was there to make Ada programmers feel like they knew what was going on. Because the old-fashioned syntax is still supported for backwards compatibility, if you try to use a string like &lt;code&gt;&quot;This is $owner's house&quot;&lt;/code&gt;, you'll be accessing &lt;code&gt;$owner::s&lt;/code&gt;; that is, the $s variable in package &lt;code&gt;owner&lt;/code&gt;, which is probably not what you meant. Use braces to disambiguate, as in &lt;code&gt;&quot;This is ${owner}'s house&quot;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9379928fc066063abf44caaff061ee5071ad9c7" translate="yes" xml:space="preserve">
          <source>The old style indented the note:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d9dec9262d361c18938bccf6c6a18acfa10894f" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c9fb581904d8c9128af585c935239bf8557de2" translate="yes" xml:space="preserve">
          <source>The older (and possibly obsolete) libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;</source>
          <target state="translated">Las bibliotecas m&amp;aacute;s antiguas (y posiblemente obsoletas) &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="bf3a69ba409143423723e457fea838a29577af44" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da753c735f79a0349646d5159490ba674b8d624f" translate="yes" xml:space="preserve">
          <source>The older libraries &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod::PXML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod::XML&lt;/a&gt;, &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod::SAX&lt;/a&gt;</source>
          <target state="translated">Las bibliotecas m&amp;aacute;s antiguas &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::PXML&quot;&gt;Pod :: PXML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::XML&quot;&gt;Pod :: XML&lt;/a&gt; , &lt;a href=&quot;http://search.cpan.org/perldoc/Pod::SAX&quot;&gt;Pod :: SAX&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="995ae7aa276ffe30824f52880be0efab53f1e92d" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;,
$bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</source>
          <target state="translated">La forma de un argumento de add_bits () toma una cadena de $ bits de caracteres &quot;1&quot; y &quot;0&quot; como argumento. Es una abreviatura de &lt;code&gt;$ctx-&amp;gt;add_bits(&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;(&quot;B*&quot;, $bitstring), &lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;($bitstring))&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1b86570e54f795ca97d5fe14e7650da16943e0a5" translate="yes" xml:space="preserve">
          <source>The one argument form of add_bits() takes a $bitstring of &quot;1&quot; and &quot;0&quot; chars as argument. It's a shorthand for &lt;code&gt;$ctx-&amp;gt;add_bits(pack(&quot;B*&quot;, $bitstring), length($bitstring))&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fb0ed6067910ab4f7c54b4b88cf43df00178824" translate="yes" xml:space="preserve">
          <source>The one parameter calling convention also still works.</source>
          <target state="translated">El único parámetro que llama a la convención también sigue funcionando.</target>
        </trans-unit>
        <trans-unit id="80912f94b4001d6702c4a5ac8c13128730d9bdf7" translate="yes" xml:space="preserve">
          <source>The one user (apart from the superuser) who has absolute control over a &lt;b&gt;file&lt;/b&gt;. A file may also have a &lt;b&gt;group&lt;/b&gt; of users who may exercise joint ownership if the real owner permits it. See &lt;b&gt;permission bits&lt;/b&gt;.</source>
          <target state="translated">El &amp;uacute;nico usuario (aparte del superusuario) que tiene control absoluto sobre un &lt;b&gt;archivo&lt;/b&gt; . Un archivo tambi&amp;eacute;n puede tener un &lt;b&gt;grupo&lt;/b&gt; de usuarios que pueden ejercer la propiedad conjunta si el propietario real lo permite. Ver &lt;b&gt;bits de permiso&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="ecb6da0a473e0cefde4e91abce89bab9a6e1b78a" translate="yes" xml:space="preserve">
          <source>The one-shot interface allows you to force the creation of a zip64 zip file by including the &lt;code&gt;Zip64&lt;/code&gt; option.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf794f433c5b5ee5b62cabad4f9e0efe662e76bb" translate="yes" xml:space="preserve">
          <source>The only absolutely mandatory method. Called when the layer is pushed onto the stack. The &lt;code&gt;mode&lt;/code&gt; argument may be NULL if this occurs post-open. The &lt;code&gt;arg&lt;/code&gt; will be non-&lt;code&gt;NULL&lt;/code&gt; if an argument string was passed. In most cases this should call &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; to convert &lt;code&gt;mode&lt;/code&gt; into the appropriate &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; flags in addition to any actions the layer itself takes. If a layer is not expecting an argument it need neither save the one passed to it, nor provide &lt;code&gt;Getarg()&lt;/code&gt; (it could perhaps &lt;code&gt;Perl_warn&lt;/code&gt; that the argument was un-expected).</source>
          <target state="translated">El &amp;uacute;nico m&amp;eacute;todo absolutamente obligatorio. Se llama cuando la capa se inserta en la pila. El argumento de &lt;code&gt;mode&lt;/code&gt; puede ser NULL si esto ocurre despu&amp;eacute;s de la apertura. El &lt;code&gt;arg&lt;/code&gt; ser&amp;aacute; no &lt;code&gt;NULL&lt;/code&gt; si se aprob&amp;oacute; una cadena de argumentos. En la mayor&amp;iacute;a de los casos, esto deber&amp;iacute;a llamar a &lt;code&gt;PerlIOBase_pushed()&lt;/code&gt; para convertir el &lt;code&gt;mode&lt;/code&gt; en los indicadores &lt;code&gt;PERLIO_F_XXXXX&lt;/code&gt; apropiados, adem&amp;aacute;s de cualquier acci&amp;oacute;n que realice la capa. Si una capa no espera un argumento, no necesita guardar el que se le ha pasado ni proporcionar &lt;code&gt;Getarg()&lt;/code&gt; (tal vez podr&amp;iacute;a &lt;code&gt;Perl_warn&lt;/code&gt; que el argumento no fue esperado).</target>
        </trans-unit>
        <trans-unit id="90a79e3c54ca5ed09d00dcfacad6096dece33202" translate="yes" xml:space="preserve">
          <source>The only characters this accepts are the decimal digits '0'..'9'.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8efd8a42e658c0f7e91c83e2d2d53f100f4033a8" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt; , (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="translated">Las &amp;uacute;nicas diferencias se deben al hecho de que &lt;code&gt;string_vianame&lt;/code&gt; es tiempo de ejecuci&amp;oacute;n y &lt;code&gt;\N{}&lt;/code&gt; es tiempo de compilaci&amp;oacute;n. No puede interpolar dentro de una &lt;code&gt;\N{}&lt;/code&gt; , (entonces &lt;code&gt;\N{$variable}&lt;/code&gt; no funciona); y si el nombre de entrada es desconocido, &lt;code&gt;string_vianame&lt;/code&gt; devuelve &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; en lugar de ser un error de sintaxis.</target>
        </trans-unit>
        <trans-unit id="77845b478b84dee4e594bd5bbec241147d4e6e80" translate="yes" xml:space="preserve">
          <source>The only differences are due to the fact that &lt;code&gt;string_vianame&lt;/code&gt; is run-time and &lt;code&gt;\N{}&lt;/code&gt; is compile time. You can't interpolate inside a &lt;code&gt;\N{}&lt;/code&gt;, (so &lt;code&gt;\N{$variable}&lt;/code&gt; doesn't work); and if the input name is unknown, &lt;code&gt;string_vianame&lt;/code&gt; returns &lt;code&gt;undef&lt;/code&gt; instead of it being a syntax error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="341b8df1dab5c18fe08d27199395d7d12fe5908e" translate="yes" xml:space="preserve">
          <source>The only flag specified this time was G_SCALAR. That means that the &lt;code&gt;@_&lt;/code&gt; array will be created and that the value returned by</source>
          <target state="translated">La &amp;uacute;nica bandera especificada esta vez fue G_SCALAR. Eso significa que se &lt;code&gt;@_&lt;/code&gt; matriz @_ y que el valor devuelto por</target>
        </trans-unit>
        <trans-unit id="1be9c07fcdeba873e922d933912b59d6dffd7f9b" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt; . Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">La &amp;uacute;nica interpolaci&amp;oacute;n es la eliminaci&amp;oacute;n de &lt;code&gt;\&lt;/code&gt; de los pares de &lt;code&gt;\\&lt;/code&gt; . Por lo tanto &lt;code&gt;&quot;-&quot;&lt;/code&gt; en &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr'''&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y'''&lt;/a&gt;&lt;/code&gt; se trata, literalmente, como un gui&amp;oacute;n y no hay intervalo de caracteres est&amp;aacute; disponible. &lt;code&gt;\1&lt;/code&gt; en el reemplazo de &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s'''&lt;/a&gt;&lt;/code&gt; no funciona como &lt;code&gt;$1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="02eece87de941c6c62eda48e906abba6c3ece7c9" translate="yes" xml:space="preserve">
          <source>The only interpolation is removal of &lt;code&gt;\&lt;/code&gt; from pairs of &lt;code&gt;\\&lt;/code&gt;. Therefore &lt;code&gt;&quot;-&quot;&lt;/code&gt; in &lt;code&gt;tr'''&lt;/code&gt; and &lt;code&gt;y'''&lt;/code&gt; is treated literally as a hyphen and no character range is available. &lt;code&gt;\1&lt;/code&gt; in the replacement of &lt;code&gt;s'''&lt;/code&gt; does not work as &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="12717cd3a47ff8f730f2ca2276f3a722ee0a85b7" translate="yes" xml:space="preserve">
          <source>The only issue left is to how to bootstrap</source>
          <target state="translated">La única cuestión que queda es cómo arrancar</target>
        </trans-unit>
        <trans-unit id="77cda32153e2808e7ed17b43ef801a42c30a29bd" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; , and &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; that</source>
          <target state="translated">El &amp;uacute;nico tipo de declaraci&amp;oacute;n simple es una expresi&amp;oacute;n evaluada por sus efectos secundarios. Cada declaraci&amp;oacute;n simple debe terminar con un punto y coma, a menos que sea la declaraci&amp;oacute;n final en un bloque, en cuyo caso el punto y coma es opcional. Pero coloque el punto y coma de todos modos si el bloque ocupa m&amp;aacute;s de una l&amp;iacute;nea, porque eventualmente puede agregar otra l&amp;iacute;nea. Tenga en cuenta que hay operadores como &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; {}&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; {}&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; eso</target>
        </trans-unit>
        <trans-unit id="f705477ccbb186a38ab86005af82f68dd900e475" translate="yes" xml:space="preserve">
          <source>The only kind of simple statement is an expression evaluated for its side-effects. Every simple statement must be terminated with a semicolon, unless it is the final statement in a block, in which case the semicolon is optional. But put the semicolon in anyway if the block takes up more than one line, because you may eventually add another line. Note that there are operators like &lt;code&gt;eval {}&lt;/code&gt;, &lt;code&gt;sub {}&lt;/code&gt;, and &lt;code&gt;do {}&lt;/code&gt; that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e309b7f80a25c25de4d7facad82c2d1078752823" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;&quot;Prior to Perl v5.22&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f747c4ca5428591254eb88eeb68548667575b4e" translate="yes" xml:space="preserve">
          <source>The only legitimate use of this pragma is almost certainly just one per file, near the top, with file scope, as the file is likely going to only be written in one encoding. Further restrictions apply in Perls before v5.22 (see &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Prior to Perl v5.22&lt;/a&gt;).</source>
          <target state="translated">El &amp;uacute;nico uso leg&amp;iacute;timo de este pragma es casi con certeza solo uno por archivo, cerca de la parte superior, con alcance de archivo, ya que es probable que el archivo solo se escriba en una codificaci&amp;oacute;n. Se aplican m&amp;aacute;s restricciones en Perls antes de la v5.22 (consulte &lt;a href=&quot;#Prior-to-Perl-v5.22&quot;&gt;Antes de Perl v5.22&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="34c58516de1f8035b02dd5ba10465691170b3177" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt;), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt; . To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt; . Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt; , which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="translated">La &amp;uacute;nica configuraci&amp;oacute;n regional de varios bytes (o caracteres anchos) que probablemente admitir&amp;aacute; Perl es UTF-8. Esto se debe a la dificultad de implementaci&amp;oacute;n, al hecho de que ahora se publican configuraciones regionales UTF-8 de alta calidad para todas las &amp;aacute;reas del mundo ( &lt;a href=&quot;http://unicode.org/Public/cldr/latest/&quot;&gt;http://unicode.org/Public/cldr/latest/&lt;/a&gt; ), y que, en su defecto, puede usar la &lt;a href=&quot;encode&quot;&gt;codificaci&amp;oacute;n&lt;/a&gt;m&amp;oacute;dulo para traducir a / desde su localidad. Por lo tanto, tendr&amp;aacute; que hacer una de esas cosas si est&amp;aacute; utilizando una de estas configuraciones regionales, como Big5 o Shift JIS. Para las configuraciones regionales UTF-8, en Perls (anterior a la v5.20) que no tienen soporte completo para configuraciones regionales UTF-8, pueden funcionar razonablemente bien (dependiendo de la implementaci&amp;oacute;n de su biblioteca C) simplemente porque tanto ellos como Perl almacenan caracteres que toman varios bytes de la misma manera. Sin embargo, es posible que algunas implementaciones de la biblioteca C, si no la mayor&amp;iacute;a, no procesen correctamente los caracteres en la mitad superior del rango Latin-1 (128-255) en &lt;code&gt;LC_CTYPE&lt;/code&gt; . Para ver si un car&amp;aacute;cter es de un tipo particular en una configuraci&amp;oacute;n regional, Perl usa funciones como &lt;code&gt;isalnum()&lt;/code&gt; . Es posible que su biblioteca C no funcione para configuraciones regionales UTF-8 con esas funciones,en su lugar, solo funciona bajo las funciones de biblioteca amplia m&amp;aacute;s nuevas como &lt;code&gt;iswalnum()&lt;/code&gt; , que Perl no usa. Estas configuraciones regionales de varios bytes se tratan como configuraciones regionales de un solo byte y tendr&amp;aacute;n las restricciones que se describen a continuaci&amp;oacute;n. A partir de Perl v5.22, se genera un mensaje de advertencia cuando Perl detecta una configuraci&amp;oacute;n regional de varios bytes que no es totalmente compatible.</target>
        </trans-unit>
        <trans-unit id="18871d07c0f1be22042f9cbee3498004b8a18ce9" translate="yes" xml:space="preserve">
          <source>The only multi-byte (or wide character) locale that Perl is ever likely to support is UTF-8. This is due to the difficulty of implementation, the fact that high quality UTF-8 locales are now published for every area of the world (&lt;a href=&quot;https://unicode.org/Public/cldr/2.0.1/&quot;&gt;https://unicode.org/Public/cldr/2.0.1/&lt;/a&gt; for ones that are already set-up, but from an earlier version; &lt;a href=&quot;https://unicode.org/Public/cldr/latest/&quot;&gt;https://unicode.org/Public/cldr/latest/&lt;/a&gt; for the most up-to-date, but you have to extract the POSIX information yourself), and that failing all that you can use the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module to translate to/from your locale. So, you'll have to do one of those things if you're using one of these locales, such as Big5 or Shift JIS. For UTF-8 locales, in Perls (pre v5.20) that don't have full UTF-8 locale support, they may work reasonably well (depending on your C library implementation) simply because both they and Perl store characters that take up multiple bytes the same way. However, some, if not most, C library implementations may not process the characters in the upper half of the Latin-1 range (128 - 255) properly under &lt;code&gt;LC_CTYPE&lt;/code&gt;. To see if a character is a particular type under a locale, Perl uses the functions like &lt;code&gt;isalnum()&lt;/code&gt;. Your C library may not work for UTF-8 locales with those functions, instead only working under the newer wide library functions like &lt;code&gt;iswalnum()&lt;/code&gt;, which Perl does not use. These multi-byte locales are treated like single-byte locales, and will have the restrictions described below. Starting in Perl v5.22 a warning message is raised when Perl detects a multi-byte locale that it doesn't fully support.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c17b3d145791de4c679a21722f34ee793cec0ff" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3A%3Astring_vianame%28name%29&quot;&gt;&quot;charnames::string_vianame(name)&quot; in charnames&lt;/a&gt;, and &lt;a href=&quot;Unicode::UCD#namedseq%28%29&quot;&gt;&quot;namedseq()&quot; in Unicode::UCD&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81ecbc2496d990405244fb5517f23afeb52e9228" translate="yes" xml:space="preserve">
          <source>The only non-character property that Perl currently supports is Named Sequences, in which a sequence of code points is given a name and generally treated as a single entity. (Perl supports these via the &lt;code&gt;\N{...}&lt;/code&gt; double-quotish construct, &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames::string_vianame(name) in charnames&lt;/a&gt;, and &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq() in Unicode::UCD&lt;/a&gt;.</source>
          <target state="translated">La &amp;uacute;nica propiedad que no es un car&amp;aacute;cter que Perl admite actualmente son las secuencias con nombre, en las que una secuencia de puntos de c&amp;oacute;digo recibe un nombre y generalmente se trata como una entidad &amp;uacute;nica. (Perl los admite mediante la construcci&amp;oacute;n de comillas dobles &lt;code&gt;\N{...}&lt;/code&gt; , &lt;a href=&quot;charnames#charnames%3a%3astring_vianame(name)&quot;&gt;charnames :: string_vianame (name) en charnames&lt;/a&gt; y &lt;a href=&quot;unicode/ucd#namedseq()&quot;&gt;namedseq () en Unicode :: UCD&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="4392ba6f21132243d1d665e363dbf9f2d5cd7f44" translate="yes" xml:space="preserve">
          <source>The only non-single-byte locale Perl supports is (starting in v5.20) UTF-8. This means that code points above 255 are treated as Unicode no matter what locale is in effect (since UTF-8 implies Unicode).</source>
          <target state="translated">El único local de un solo byte que soporta Perl es (a partir de v5.20)UTF-8.Esto significa que los puntos de código por encima de 255 se tratan como Unicode sin importar la locale que esté en vigor (ya que UTF-8 implica Unicode).</target>
        </trans-unit>
        <trans-unit id="9a67bc69297226e55a92fe7a2acd416579cf6146" translate="yes" xml:space="preserve">
          <source>The only objective benefit to using &lt;code&gt;DirHandle&lt;/code&gt; is that it avoids namespace pollution by creating globs to hold directory handles.</source>
          <target state="translated">El &amp;uacute;nico beneficio objetivo de usar &lt;code&gt;DirHandle&lt;/code&gt; es que evita la contaminaci&amp;oacute;n del espacio de nombres al crear globos para contener identificadores de directorio.</target>
        </trans-unit>
        <trans-unit id="29b92533d26d29124ecd17a1f17bcca141dd3115" translate="yes" xml:space="preserve">
          <source>The only other constraint is you must pre-declare how many tests you plan to run. This is in case something goes horribly wrong during the test and your test program aborts, or skips a test or whatever. You do this like so:</source>
          <target state="translated">La única otra limitación es que debes declarar previamente cuántas pruebas planeas realizar.Esto es en caso de que algo salga terriblemente mal durante la prueba y tu programa de pruebas aborte,o se salte una prueba o lo que sea.Lo haces así:</target>
        </trans-unit>
        <trans-unit id="c629e4aca342ff5d679b1354d5badb624d786fd5" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="translated">El &amp;uacute;nico lugar donde no se genera la advertencia cuando deber&amp;iacute;a haber sido as&amp;iacute; es si las optimizaciones hacen que ni siquiera se intente la coincidencia completa del patr&amp;oacute;n. Por ejemplo, Perl puede darse cuenta de que para que una cadena coincida con un determinado patr&amp;oacute;n de expresi&amp;oacute;n regular, la cadena debe contener la subcadena &lt;code&gt;&quot;foobar&quot;&lt;/code&gt; . Antes de intentar la coincidencia, Perl puede buscar esa subcadena y, si no la encuentra, falla inmediatamente la coincidencia sin intentarlo realmente; por lo que no se genera ninguna advertencia incluso si la cadena contiene un punto de c&amp;oacute;digo Unicode anterior.</target>
        </trans-unit>
        <trans-unit id="2a1424cb465056db403b0376b90df7285a39a496" translate="yes" xml:space="preserve">
          <source>The only place where the warning is not raised when it might ought to have been is if optimizations cause the whole pattern match to not even be attempted. For example, Perl may figure out that for a string to match a certain regular expression pattern, the string has to contain the substring &lt;code&gt;&quot;foobar&quot;&lt;/code&gt;. Before attempting the match, Perl may look for that substring, and if not found, immediately fail the match without actually trying it; so no warning gets generated even if the string contains an above-Unicode code point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f03961d151195642787106427ad37fb0df08a21" translate="yes" xml:space="preserve">
          <source>The only pragmas to be completely supported are: &lt;code&gt;use warnings&lt;/code&gt;, &lt;code&gt;use strict&lt;/code&gt;, &lt;code&gt;use bytes&lt;/code&gt;, &lt;code&gt;use integer&lt;/code&gt; and &lt;code&gt;use feature&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7dc3eb2b3b66b20134df38443b06998c7b78e71" translate="yes" xml:space="preserve">
          <source>The only purpose of this step is to create the needed directories, and let you know the names of these directories. From the output you can see that the directory for the extension is</source>
          <target state="translated">El único propósito de este paso es crear los directorios necesarios,y hacerles saber los nombres de estos directorios.De la salida se puede ver que el directorio para la extensión es</target>
        </trans-unit>
        <trans-unit id="e4350c2629055827ad3a8b68cc619a2e785707ba" translate="yes" xml:space="preserve">
          <source>The only required argument is &lt;a href=&quot;IO::Socket#Domain&quot;&gt;&quot;Domain&quot; in IO::Socket&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b743cce5d7490a9e24b6e3b1af9c9095cbf1cfd" translate="yes" xml:space="preserve">
          <source>The only required part is the first field, the name of a module (e.g. Foo::Bar, i.e.</source>
          <target state="translated">La única parte requerida es el primer campo,el nombre de un módulo (por ejemplo,Foo::Bar,es decir.</target>
        </trans-unit>
        <trans-unit id="18bf9d2d31226fde65cb844d15b4e9ac5dd2e6d9" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are &lt;code&gt;GV_SUPER&lt;/code&gt; and &lt;code&gt;SVf_UTF8&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a47d064470efbb85a4c64c4b51a76380fc85cda0" translate="yes" xml:space="preserve">
          <source>The only significant values for &lt;code&gt;flags&lt;/code&gt; are GV_SUPER and SVf_UTF8.</source>
          <target state="translated">Los &amp;uacute;nicos valores significativos para las &lt;code&gt;flags&lt;/code&gt; son GV_SUPER y SVf_UTF8.</target>
        </trans-unit>
        <trans-unit id="27c03514e890f7e1e455be24f92d8de38867990a" translate="yes" xml:space="preserve">
          <source>The only thing to note is that, in both the static and virtual methods, the method name is not passed via the stack--it is used as the first parameter to</source>
          <target state="translated">Lo único que hay que tener en cuenta es que,tanto en el método estático como en el virtual,el nombre del método no se pasa a través de la pila,sino que se utiliza como primer parámetro para</target>
        </trans-unit>
        <trans-unit id="9a6d4c47eb4eb3548f61bca4b08d9e197f6e1287" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; subroutine</source>
          <target state="translated">Lo &amp;uacute;nico que debe recordar es que la subrutina de &lt;code&gt;&lt;a href=&quot;../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="3a8286223f476561d867d00238ced07bc0080bf9" translate="yes" xml:space="preserve">
          <source>The only thing you have to remember is that the &lt;code&gt;import&lt;/code&gt; subroutine</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="befc7f9200d677e41e635df70642f3120f18f3ee" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;. When used as a number, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt; ; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="translated">Lo &amp;uacute;nico que necesita declarar en Perl son los formatos de informe y las subrutinas (ya veces ni siquiera las subrutinas). Una variable escalar contiene el valor indefinido ( &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ) hasta que se le ha asignado un valor definido, que no es &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; . Cuando se usa como un n&amp;uacute;mero, &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; se trata como &lt;code&gt;0&lt;/code&gt; ; cuando se usa como una cadena, se trata como una cadena vac&amp;iacute;a, &lt;code&gt;&quot;&quot;&lt;/code&gt; ; y cuando se usa como una referencia a la que no se est&amp;aacute; asignando, se trata como un error. Si habilita las advertencias, se le notificar&amp;aacute; de un valor no inicializado cada vez que trate a &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; como una cadena o un n&amp;uacute;mero. Bueno, por lo general. Contextos booleanos, como:</target>
        </trans-unit>
        <trans-unit id="8063526283668c78bfe80f0053d75f81f3e00c7f" translate="yes" xml:space="preserve">
          <source>The only things you need to declare in Perl are report formats and subroutines (and sometimes not even subroutines). A scalar variable holds the undefined value (&lt;code&gt;undef&lt;/code&gt;) until it has been assigned a defined value, which is anything other than &lt;code&gt;undef&lt;/code&gt;. When used as a number, &lt;code&gt;undef&lt;/code&gt; is treated as &lt;code&gt;0&lt;/code&gt;; when used as a string, it is treated as the empty string, &lt;code&gt;&quot;&quot;&lt;/code&gt;; and when used as a reference that isn't being assigned to, it is treated as an error. If you enable warnings, you'll be notified of an uninitialized value whenever you treat &lt;code&gt;undef&lt;/code&gt; as a string or a number. Well, usually. Boolean contexts, such as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31db2a79cbb61c12ae686554ebaa8cf24c12eba8" translate="yes" xml:space="preserve">
          <source>The only times that you absolutely</source>
          <target state="translated">Las únicas veces que absolutamente</target>
        </trans-unit>
        <trans-unit id="cdb480d4e9cef712b05b3e3ca053bd2714b2800c" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt; .</source>
          <target state="translated">La &amp;uacute;nica forma de cambiar esto es proporcionar su propia subrutina para &lt;code&gt;'|'&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cc6185c346e8349db594c7e55f3c51f34e33f48b" translate="yes" xml:space="preserve">
          <source>The only way to change this is to provide your own subroutine for &lt;code&gt;'|'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c65da34730ca57e068ebb9d99972660fe1a63a25" translate="yes" xml:space="preserve">
          <source>The only way to override a lexical warnings setting is with the &lt;b&gt;-W&lt;/b&gt; or &lt;b&gt;-X&lt;/b&gt; command line flags.</source>
          <target state="translated">La &amp;uacute;nica forma de anular una configuraci&amp;oacute;n de advertencias l&amp;eacute;xicas es con los indicadores de l&amp;iacute;nea de comando &lt;b&gt;-W&lt;/b&gt; o &lt;b&gt;-X&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7ea2eaf8e5a3a274ae0f1dbb910613954b91ee9b" translate="yes" xml:space="preserve">
          <source>The only way you will ever be allowed to rebase or modify the history of a pushed branch is to delete it and push it as a new branch under the same name. Please think carefully about doing this. It may be better to sequentially rename your branches so that it is easier for others working with you to cherry-pick their local changes onto the new version. (XXX: needs explanation).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbd9c5131dd8145825db3c00e95fdf65545c95f3" translate="yes" xml:space="preserve">
          <source>The op tree is connected in two ways: you can imagine that there are two &quot;routes&quot; through it, two orders in which you can traverse the tree. First, parse order reflects how the parser understood the code, and secondly, execution order tells perl what order to perform the operations in.</source>
          <target state="translated">El árbol de operaciones está conectado de dos maneras:puedes imaginar que hay dos &quot;rutas&quot; a través de él,dos órdenes en los que puedes atravesar el árbol.Primero,la orden de análisis refleja cómo el analizador entendió el código,y segundo,la orden de ejecución le dice a Perl en qué orden realizar las operaciones.</target>
        </trans-unit>
        <trans-unit id="87587f650625db0a4ecb1818a87bdf007aa521f9" translate="yes" xml:space="preserve">
          <source>The op tree representing the code block is returned. This is always a real op, never a null pointer. It will normally be a &lt;code&gt;lineseq&lt;/code&gt; list, including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops. No ops to construct any kind of runtime scope are included by virtue of it being a block.</source>
          <target state="translated">Se devuelve el &amp;aacute;rbol de operaciones que representa el bloque de c&amp;oacute;digo. Esta es siempre una operaci&amp;oacute;n real, nunca un puntero nulo. Normalmente ser&amp;aacute; una lista &lt;code&gt;lineseq&lt;/code&gt; , que incluye operaciones de &lt;code&gt;nextstate&lt;/code&gt; o equivalentes. No se incluyen operaciones para construir ning&amp;uacute;n tipo de &amp;aacute;mbito de ejecuci&amp;oacute;n en virtud de que es un bloque.</target>
        </trans-unit>
        <trans-unit id="0ada1b492ff1e32feecd23ad2e48d8b585f13df5" translate="yes" xml:space="preserve">
          <source>The op tree representing the expression is returned. If an optional expression is absent, a null pointer is returned, otherwise the pointer will be non-null.</source>
          <target state="translated">Se devuelve el árbol de operaciones que representa la expresión.Si una expresión opcional está ausente,se devuelve un puntero nulo,de lo contrario el puntero será no nulo.</target>
        </trans-unit>
        <trans-unit id="e036bcd0d780fe688c97dce4eafd340bcf362abb" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b8ec717bc605b587bc78dee46e74bc74f77b59be" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be ops directly implementing the statement, suitable to pass to &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt;. It will not normally include a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op (except for those embedded in a scope contained entirely within the statement).</source>
          <target state="translated">Se devuelve el &amp;aacute;rbol de operaciones que representa la declaraci&amp;oacute;n. Esto puede ser un puntero nulo si la declaraci&amp;oacute;n es nula, por ejemplo, si en realidad era una definici&amp;oacute;n de subrutina (que tiene efectos secundarios en tiempo de compilaci&amp;oacute;n). Si no es nulo, ser&amp;aacute;n operaciones que implementen directamente la declaraci&amp;oacute;n, aptas para pasar a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; . Normalmente no incluir&amp;aacute; una &lt;code&gt;nextstate&lt;/code&gt; o equivalente (excepto aquellas incluidas en un alcance contenido completamente dentro de la declaraci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="2254139a8dcdd28ca766e4d41d0739d872c7e21b" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;&quot;newSTATEOP&quot;&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55a48ae410aca9d3fe9a16a19fa26233018ca671" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement is returned. This may be a null pointer if the statement is null, for example if it was actually a subroutine definition (which has compile-time side effects). If not null, it will be the result of a &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; call, normally including a &lt;code&gt;nextstate&lt;/code&gt; or equivalent op.</source>
          <target state="translated">Se devuelve el &amp;aacute;rbol de operaciones que representa la declaraci&amp;oacute;n. Esto puede ser un puntero nulo si la declaraci&amp;oacute;n es nula, por ejemplo, si en realidad era una definici&amp;oacute;n de subrutina (que tiene efectos secundarios en tiempo de compilaci&amp;oacute;n). Si no es nulo, ser&amp;aacute; el resultado de una llamada &lt;a href=&quot;#newSTATEOP&quot;&gt;newSTATEOP&lt;/a&gt; , que normalmente incluye una &lt;code&gt;nextstate&lt;/code&gt; o equivalente.</target>
        </trans-unit>
        <trans-unit id="80258368ca90132ffffe94b685646de5d3e0a9ff" translate="yes" xml:space="preserve">
          <source>The op tree representing the statement sequence is returned. This may be a null pointer if the statements were all null, for example if there were no statements or if there were only subroutine definitions (which have compile-time side effects). If not null, it will be a &lt;code&gt;lineseq&lt;/code&gt; list, normally including &lt;code&gt;nextstate&lt;/code&gt; or equivalent ops.</source>
          <target state="translated">Se devuelve el &amp;aacute;rbol de operaciones que representa la secuencia de instrucciones. Puede ser un puntero nulo si todas las declaraciones fueran nulas, por ejemplo, si no hab&amp;iacute;a declaraciones o si solo hab&amp;iacute;a definiciones de subrutinas (que tienen efectos secundarios en tiempo de compilaci&amp;oacute;n). Si no es nulo, ser&amp;aacute; una lista &lt;code&gt;lineseq&lt;/code&gt; , que normalmente incluye &lt;code&gt;nextstate&lt;/code&gt; o equivalentes.</target>
        </trans-unit>
        <trans-unit id="535ccca6a54b74bb28aa7a40bc1a8b66e55f76db" translate="yes" xml:space="preserve">
          <source>The op tree to unpack the arguments from the stack at runtime is returned. This op tree should appear at the beginning of the compiled function. The caller may wish to use &lt;a href=&quot;#op_append_list&quot;&gt;&quot;op_append_list&quot;&lt;/a&gt; to build their function body after it, or splice it together with the body before calling &lt;a href=&quot;#newATTRSUB&quot;&gt;&quot;newATTRSUB&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c35c6433e7899b6be9854e9907788616c4dfa0ff" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;&quot;OP flags abbreviations&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee004e116194c04a5a9d3789b699d566539ba78d" translate="yes" xml:space="preserve">
          <source>The op-flags (ex &lt;b&gt;'sK/2'&lt;/b&gt;) are described in (&lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;OP flags abbreviations&lt;/a&gt;).</source>
          <target state="translated">Los indicadores de &lt;b&gt;operaci&amp;oacute;n&lt;/b&gt; (ex &lt;b&gt;'sK / 2'&lt;/b&gt; ) se describen en ( &lt;a href=&quot;#OP-flags-abbreviations&quot;&gt;Abreviaturas de indicadores de OP&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="8eec999d2cf9d026309d4e24a85ebd9a75290847" translate="yes" xml:space="preserve">
          <source>The open source license that Larry Wall created for Perl, maximizing Perl&amp;rsquo;s usefulness, availability, and modifiability. The current version is 2. (&lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt;).</source>
          <target state="translated">La licencia de c&amp;oacute;digo abierto que Larry Wall cre&amp;oacute; para Perl, maximizando la utilidad, disponibilidad y modificabilidad de Perl. La versi&amp;oacute;n actual es 2. ( &lt;a href=&quot;http://www.opensource.org/licenses/artistic-license.php&quot;&gt;http://www.opensource.org/licenses/artistic-license.php&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="d076872f9624d7a17cf4c11c33523c71a8396f8e" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given $cmd and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="translated">La función open2()ejecuta el $cmd dado y conecta $chld_out para leer y $chld_in para escribir.Es lo que crees que debería funcionar cuando intentas</target>
        </trans-unit>
        <trans-unit id="2904189d67cdca2709e7a78ebf9563187c0c5785" translate="yes" xml:space="preserve">
          <source>The open2() function runs the given command and connects $chld_out for reading and $chld_in for writing. It's what you think should work when you try</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="793bd01a6b2dc5e14b8e95bd14b22d7c8c213b3b" translate="yes" xml:space="preserve">
          <source>The operand of some types of regop is a literal string; for others, it is a regop leading into a sub-program. In particular, the operand of a &lt;code&gt;BRANCH&lt;/code&gt; node is the first regop of the branch.</source>
          <target state="translated">El operando de algunos tipos de regop es una cadena literal; para otros, es una regop que conduce a un subprograma. En particular, el operando de un nodo &lt;code&gt;BRANCH&lt;/code&gt; es el primer regop de la rama.</target>
        </trans-unit>
        <trans-unit id="cf8df21203ce7e715434391039cee96dd7ffc65d" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt; ) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="translated">El sistema operativo, los controladores de dispositivo, las bibliotecas C y el sistema de tiempo de ejecuci&amp;oacute;n de Perl conspiran para permitir que el programador trate un solo car&amp;aacute;cter ( &lt;code&gt;\n&lt;/code&gt; ) como terminador de l&amp;iacute;nea, independientemente de la representaci&amp;oacute;n externa. En muchos sistemas operativos, la representaci&amp;oacute;n del archivo de texto nativo coincide con la representaci&amp;oacute;n interna, pero en algunas plataformas, la representaci&amp;oacute;n externa de &lt;code&gt;\n&lt;/code&gt; se compone de m&amp;aacute;s de un car&amp;aacute;cter.</target>
        </trans-unit>
        <trans-unit id="3f9b4af2476a3677a8d756957b80eb4422b5ccdb" translate="yes" xml:space="preserve">
          <source>The operating system, device drivers, C libraries, and Perl run-time system all conspire to let the programmer treat a single character (&lt;code&gt;\n&lt;/code&gt;) as the line terminator, irrespective of external representation. On many operating systems, the native text file representation matches the internal representation, but on some platforms the external representation of &lt;code&gt;\n&lt;/code&gt; is made up of more than one character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8c6975d92732aba7cc117877a890c8662a217abc" translate="yes" xml:space="preserve">
          <source>The operation of the &lt;code&gt;%ENV&lt;/code&gt; array depends on the translation of the logical name</source>
          <target state="translated">El funcionamiento de la matriz &lt;code&gt;%ENV&lt;/code&gt; depende de la traducci&amp;oacute;n del nombre l&amp;oacute;gico</target>
        </trans-unit>
        <trans-unit id="1fcdc1a8281a2698369d4d0c5ac8331125832af5" translate="yes" xml:space="preserve">
          <source>The operation of the bval option warrants some discussion. Here is the definition of bval from the Berkeley DB 1.85 recno manual page:</source>
          <target state="translated">El funcionamiento de la opción bval merece ser discutido.Aquí está la definición de bval de la página del manual de Berkeley DB 1.85 recno:</target>
        </trans-unit>
        <trans-unit id="f8261c0231b653877a248b54abf80f0b93e9f204" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; , and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">El funcionamiento de este m&amp;eacute;todo tambi&amp;eacute;n se ve afectado por las &lt;code&gt;archlibexp&lt;/code&gt; , &lt;code&gt;cccdlflags&lt;/code&gt; , &lt;code&gt;ccflags&lt;/code&gt; , &lt;code&gt;optimize&lt;/code&gt; y &lt;code&gt;cc&lt;/code&gt; en &lt;code&gt;Config.pm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ebf43357cdf326de3a784f122cc30174e4d696c9" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;archlibexp&lt;/code&gt;, &lt;code&gt;cccdlflags&lt;/code&gt;, &lt;code&gt;ccflags&lt;/code&gt;, &lt;code&gt;optimize&lt;/code&gt;, and &lt;code&gt;cc&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ea94336b097e013eb83f32bbba38514d8eaa887" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; , and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt; .</source>
          <target state="translated">El funcionamiento de este m&amp;eacute;todo tambi&amp;eacute;n se ve afectado por las &lt;code&gt;lddlflags&lt;/code&gt; , &lt;code&gt;shrpenv&lt;/code&gt; y &lt;code&gt;ld&lt;/code&gt; en &lt;code&gt;Config.pm&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9af43d4cfed7d96567a247c3d560f72f4c234173" translate="yes" xml:space="preserve">
          <source>The operation of this method is also affected by the &lt;code&gt;lddlflags&lt;/code&gt;, &lt;code&gt;shrpenv&lt;/code&gt;, and &lt;code&gt;ld&lt;/code&gt; entries in &lt;code&gt;Config.pm&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf8b3d14dd93250118a75dcead35353084d8d3c" translate="yes" xml:space="preserve">
          <source>The operations that are affected by locale are:</source>
          <target state="translated">Las operaciones que se ven afectadas por la localización son:</target>
        </trans-unit>
        <trans-unit id="4ea8be07a0890d457a63bbbdc0361b2f2a0630bf" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="translated">El operador &lt;code&gt;not&lt;/code&gt; es una clave v&amp;aacute;lida para &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; . Sin embargo, si el operador &lt;code&gt;!&lt;/code&gt; est&amp;aacute; sobrecargado, entonces se usar&amp;aacute; la misma implementaci&amp;oacute;n para &lt;code&gt;not&lt;/code&gt; (ya que los dos operadores difieren solo en la precedencia).</target>
        </trans-unit>
        <trans-unit id="e62d966af3836010344e801b17dfde35cf80a445" translate="yes" xml:space="preserve">
          <source>The operator &lt;code&gt;not&lt;/code&gt; is not a valid key for &lt;code&gt;use overload&lt;/code&gt;. However, if the operator &lt;code&gt;!&lt;/code&gt; is overloaded then the same implementation will be used for &lt;code&gt;not&lt;/code&gt; (since the two operators differ only in precedence).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78cd830e88c435efad5c7c64c9421f0a7b44115d" translate="yes" xml:space="preserve">
          <source>The operator may be assigned to if both the 2nd and 3rd arguments are legal lvalues (meaning that you can assign to them):</source>
          <target state="translated">El operador puede ser asignado si tanto el 2º como el 3º argumento son valores legales (lo que significa que puede asignarlos):</target>
        </trans-unit>
        <trans-unit id="5904b513e41f7f0a3948a698bdf838835b48e7f3" translate="yes" xml:space="preserve">
          <source>The opname, as in &lt;b&gt;'add[t1]'&lt;/b&gt;, may be followed by op-specific information in parentheses or brackets (ex &lt;b&gt;'[t1]'&lt;/b&gt;).</source>
          <target state="translated">El nombre de la operaci&amp;oacute;n, como en &lt;b&gt;'agregar [t1]'&lt;/b&gt; , puede ir seguido de informaci&amp;oacute;n espec&amp;iacute;fica de la operaci&amp;oacute;n entre par&amp;eacute;ntesis o corchetes (ex &lt;b&gt;'[t1]'&lt;/b&gt; ).</target>
        </trans-unit>
        <trans-unit id="4a764821c24945c6b9d29fb8f23336e4895936b8" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;&quot;catdir&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="18a01865affffe01d68458832d996fae1c28b752" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt;.</source>
          <target state="translated">Lo contrario de &lt;a href=&quot;#catdir&quot;&gt;catdir&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="da407a5a37cdd431c49815120665c0495df714be" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir%28%29&quot;&gt;&quot;catdir()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8b12f229c6486073ad774a1dc49a9e1e9fe1afd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;#catdir()&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">Lo opuesto a &lt;a href=&quot;#catdir()&quot;&gt;catdir ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="cd5ab607bfc9b28a62d0ee095cfa34da1a0a1edd" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;../spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="translated">Lo opuesto a &lt;a href=&quot;../spec#catdir&quot;&gt;catdir ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="72e60997864c75a6b42c630a5cd3b7d0d96cb145" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;a href=&quot;File::Spec#catdir&quot;&gt;catdir()&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ebefb2669972c85d8b9e00b79503067268d1b9d" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt; .</source>
          <target state="translated">Lo contrario de &lt;code&gt;catdir()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ce2ff0fee10bb0851a17501763837139e03ed67c" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;catdir()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a36830f45796b87c226ab6318291313f5d62c75" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode&lt;/code&gt;: expects a JSON text and tries to parse it, returning the resulting simple scalar or reference. Croaks on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f81bb459c3e1d2a0353a3947d9d6ef14ef3f4c25" translate="yes" xml:space="preserve">
          <source>The opposite of &lt;code&gt;encode_json&lt;/code&gt;: expects an UTF-8 (binary) string and tries to parse that as an UTF-8 encoded JSON text, returning the resulting reference. Croaks on error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9058f904dc63789872dd9542a7b1316b89449f40" translate="yes" xml:space="preserve">
          <source>The opset and opset_to_ops functions can be used to convert from a list of operators to an opset and</source>
          <target state="translated">Las funciones opset y opset_to_ops pueden utilizarse para convertir una lista de operadores en un opset y</target>
        </trans-unit>
        <trans-unit id="e0e7014b5567d7771bd0933f5acd1310aac22e0f" translate="yes" xml:space="preserve">
          <source>The optag name used must not be defined already (define_optag will croak if it is already defined). Optag names are global to the perl process and optag definitions cannot be altered or deleted once defined.</source>
          <target state="translated">El nombre del optag utilizado no debe estar ya definido (define_optag se quebrará si ya está definido).Los nombres optag son globales al proceso perl y las definiciones optag no pueden ser alteradas o borradas una vez definidas.</target>
        </trans-unit>
        <trans-unit id="16ae99f8eb8c5eb6cf77bcb07b90faddacb6b646" translate="yes" xml:space="preserve">
          <source>The optimizer-specific information is used to avoid entering (a slow) regex engine on strings that will not definitely match. If the &lt;code&gt;isall&lt;/code&gt; flag is set, a call to the regex engine may be avoided even when the optimizer found an appropriate place for the match.</source>
          <target state="translated">La informaci&amp;oacute;n espec&amp;iacute;fica del optimizador se usa para evitar ingresar (un motor de expresiones regulares lento) en cadenas que definitivamente no coincidir&amp;aacute;n. Si se establece el indicador &lt;code&gt;isall&lt;/code&gt; , se puede evitar una llamada al motor de expresiones regulares incluso cuando el optimizador encuentra un lugar apropiado para la coincidencia.</target>
        </trans-unit>
        <trans-unit id="c2bcebf69d65f38d819f2ef47d3870130b4b4a34" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="translated">La opci&amp;oacute;n no toma un argumento y puede ser negada prefij&amp;aacute;ndola con &quot;no&quot; o &quot;no-&quot;. Por ejemplo, &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; permitir&amp;aacute; &lt;code&gt;--foo&lt;/code&gt; (se asignar&amp;aacute; un valor de 1) as&amp;iacute; como &lt;code&gt;--nofoo&lt;/code&gt; y &lt;code&gt;--&lt;a href=&quot;../functions/no&quot;&gt;no&lt;/a&gt;-foo&lt;/code&gt; (se asignar&amp;aacute; un valor de 0). Si la opci&amp;oacute;n tiene alias, esto tambi&amp;eacute;n se aplica a los alias.</target>
        </trans-unit>
        <trans-unit id="d9db329442e437205bd55b086c5b9e99baf5686d" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and may be negated by prefixing it with &quot;no&quot; or &quot;no-&quot;. E.g. &lt;code&gt;&quot;foo!&quot;&lt;/code&gt; will allow &lt;code&gt;--foo&lt;/code&gt; (a value of 1 will be assigned) as well as &lt;code&gt;--nofoo&lt;/code&gt; and &lt;code&gt;--no-foo&lt;/code&gt; (a value of 0 will be assigned). If the option has aliases, this applies to the aliases as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05bc04ade0e6f0bfb276419b00c5f9d55f933117" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="translated">La opci&amp;oacute;n no toma un argumento y se incrementar&amp;aacute; en 1 cada vez que aparezca en la l&amp;iacute;nea de comando. Por ejemplo, &lt;code&gt;&quot;more+&quot;&lt;/code&gt; , cuando se usa con &lt;code&gt;--more --more --more&lt;/code&gt; , incrementar&amp;aacute; el valor tres veces, dando como resultado un valor de 3 (siempre que sea 0 o no est&amp;eacute; definido al principio).</target>
        </trans-unit>
        <trans-unit id="d8e253e20697ea76ff418e0292092a5b47f9f4f6" translate="yes" xml:space="preserve">
          <source>The option does not take an argument and will be incremented by 1 every time it appears on the command line. E.g. &lt;code&gt;&quot;more+&quot;&lt;/code&gt;, when used with &lt;code&gt;--more --more --more&lt;/code&gt;, will increment the value three times, resulting in a value of 3 (provided it was 0 or undefined at first).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6c73626524fd7b39cf23cb6ceb0594624a4560f" translate="yes" xml:space="preserve">
          <source>The option name as specified to the GetOptions() function is called the option</source>
          <target state="translated">El nombre de la opción como se especifica en la función GetOptions()se llama la opción</target>
        </trans-unit>
        <trans-unit id="28e883d6a03c91177fe93b06a907181312e7662a" translate="yes" xml:space="preserve">
          <source>The option names defined below are case insensitive and can be optionally prefixed by a '-'. So all of the following are valid</source>
          <target state="translated">Los nombres de las opciones definidas a continuación no distinguen entre mayúsculas y minúsculas y pueden ser opcionalmente precedidas por un &quot;-&quot;.Así que todo lo siguiente es válido</target>
        </trans-unit>
        <trans-unit id="24d6abd722573e6cae42881df7cf4d56ac582b1b" translate="yes" xml:space="preserve">
          <source>The option requires an argument of the given type. Supported types are:</source>
          <target state="translated">La opción requiere un argumento del tipo dado.Los tipos soportados son:</target>
        </trans-unit>
        <trans-unit id="18b9f1ce4c729b2ded7edcf5db48cd7ab36a842d" translate="yes" xml:space="preserve">
          <source>The optional</source>
          <target state="translated">El opcional</target>
        </trans-unit>
        <trans-unit id="3cb07c5a1f900e41d71b7af9007db9793c77a65e" translate="yes" xml:space="preserve">
          <source>The optional &lt;code&gt;rules&lt;/code&gt; attribute provides direction on which tests should be run in parallel and which should be run sequentially. If no rule data structure is provided, a default data structure is used which makes every test eligible to be run in parallel:</source>
          <target state="translated">El atributo de &lt;code&gt;rules&lt;/code&gt; opcional proporciona una direcci&amp;oacute;n sobre qu&amp;eacute; pruebas deben ejecutarse en paralelo y cu&amp;aacute;les deben ejecutarse secuencialmente. Si no se proporciona una estructura de datos de reglas, se utiliza una estructura de datos predeterminada que hace que cada prueba sea elegible para ejecutarse en paralelo:</target>
        </trans-unit>
        <trans-unit id="0a173dcd400a0274b32b98f040a162b1b1782227" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt; , in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="translated">Los argumentos opcionales se consideran cadenas literales a menos que comiencen con &lt;code&gt;~&lt;/code&gt; o &lt;code&gt;!&lt;/code&gt; , en cuyo caso se interpretan como expresiones regulares (posiblemente negadas).</target>
        </trans-unit>
        <trans-unit id="cf1d2e0ff9c2439cc3ca174e85a170cee0c435c9" translate="yes" xml:space="preserve">
          <source>The optional arguments are considered as literal strings unless they start with &lt;code&gt;~&lt;/code&gt; or &lt;code&gt;!&lt;/code&gt;, in which case they are interpreted as regular expressions (possibly negated).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a457723dc3fc51f575186932ad8e9bfa084daea" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="caed88218bf3ae5d8b6dcab0958f36fc2927ec02" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;anyuncompress&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="131098ff902c48e8458d96c59269d22ab860e8b2" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bunzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6198111cc9801f305996de3eeaa06e0db91b4218" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;bzip2&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38c4c457d99260789b76c08eab24f06adc17d2c1" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;deflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aa1a96727af7ce5f83a4cb5ede379486da415347" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gunzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="32a1759e80fa595487da188a1ae20babdbb62651" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;gzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81f90f77041e19f7f96b84e59406c9ba0fcd6ff0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;inflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d34c4bd457be8b3eca1d1b50327dc8555ebf3e0c" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawdeflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da3088b2b3f74fb962460f08bf6c521a6489c8dc" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;rawinflate&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="564a4703e441e1aa249188b7a46aeee40f3cb3e0" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;unzip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1bd6c00e2144ea2637c42a56845ca5419370d66" translate="yes" xml:space="preserve">
          <source>The optional parameters for the one-shot function &lt;code&gt;zip&lt;/code&gt; are (for the most part) identical to those used with the OO interface defined in the &lt;a href=&quot;#Constructor-Options&quot;&gt;&quot;Constructor Options&quot;&lt;/a&gt; section. The exceptions are listed below</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6ca67d9f48cf9586e57f2ed1e1217218181099d" translate="yes" xml:space="preserve">
          <source>The optional second parameter is ignored if it is larger than the actual length of the first parameter string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a213bd4ecadb16ed12c21fa427d78bb53fa09a37" translate="yes" xml:space="preserve">
          <source>The options listed above customize parts of the default header, but setting &lt;code&gt;html_header&lt;/code&gt; or &lt;code&gt;html_footer&lt;/code&gt; completely overrides the built-in header or footer. These may be useful if you want to use template tags instead of literal HTML headers and footers or are integrating converted POD pages in a larger website.</source>
          <target state="translated">Las opciones enumeradas anteriormente personalizan partes del encabezado predeterminado, pero la configuraci&amp;oacute;n de &lt;code&gt;html_header&lt;/code&gt; o &lt;code&gt;html_footer&lt;/code&gt; anula por completo el encabezado o pie de p&amp;aacute;gina incorporado. Estos pueden ser &amp;uacute;tiles si desea utilizar etiquetas de plantilla en lugar de encabezados y pies de p&amp;aacute;gina HTML literales o si est&amp;aacute; integrando p&amp;aacute;ginas POD convertidas en un sitio web m&amp;aacute;s grande.</target>
        </trans-unit>
        <trans-unit id="01a4d13b9aa02b31aa3157b7bf6c6d232ea80269" translate="yes" xml:space="preserve">
          <source>The options listed in this section control how the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73d081dbc5fcc08b3b44f6576034c6838b070bec" translate="yes" xml:space="preserve">
          <source>The options to this argument is a list of either directories that are searched recursively, or files. (Usually you wouldn't specify files, but just dirs.) Or you can just specify an empty-list, as in $name2path; with the &lt;code&gt;inc&lt;/code&gt; option on, as it is by default.</source>
          <target state="translated">Las opciones de este argumento es una lista de directorios que se buscan de forma recursiva o archivos. (Por lo general, no especificar&amp;iacute;a archivos, sino solo directorios). O simplemente puede especificar una lista vac&amp;iacute;a, como en $ name2path; con la opci&amp;oacute;n &lt;code&gt;inc&lt;/code&gt; activada, como est&amp;aacute; por defecto.</target>
        </trans-unit>
        <trans-unit id="f0865be52cedbd9c729cf95a5b09eba31832648b" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; with &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El optree se comparte entre hilos. Esto significa que existe la posibilidad de que el &amp;aacute;rbol de opci&amp;oacute;n sobreviva al hilo en particular (y por lo tanto a la instancia del int&amp;eacute;rprete) que lo cre&amp;oacute;, por lo que los verdaderos escalares de Perl no se pueden almacenar en el &amp;aacute;rbol de opci&amp;oacute;n. En su lugar, se usa una forma compacta, que solo puede almacenar valores que son enteros (con y sin signo), cadenas o &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ; las referencias y los valores de punto flotante est&amp;aacute;n en cadena. Si necesita almacenar varios valores o estructuras complejas, debe serializarlos, por ejemplo, con &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; . Se registra la eliminaci&amp;oacute;n de una clave hash de &lt;code&gt;%^H&lt;/code&gt; y, como siempre, se puede distinguir de la existencia de una clave con valor &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; con &lt;code&gt;&lt;a href=&quot;functions/exists&quot;&gt;exists&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="758267caaf6c4060844acf8b5ceecd9fefe29a51" translate="yes" xml:space="preserve">
          <source>The optree is shared between threads. This means there is a possibility that the optree will outlive the particular thread (and therefore the interpreter instance) that created it, so true Perl scalars cannot be stored in the optree. Instead a compact form is used, which can only store values that are integers (signed and unsigned), strings or &lt;code&gt;undef&lt;/code&gt; - references and floating point values are stringified. If you need to store multiple values or complex structures, you should serialise them, for example with &lt;code&gt;pack&lt;/code&gt;. The deletion of a hash key from &lt;code&gt;%^H&lt;/code&gt; is recorded, and as ever can be distinguished from the existence of a key with value &lt;code&gt;undef&lt;/code&gt; with &lt;code&gt;exists&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="96c80c62d3615e8dcdce9b967100a640447d19ae" translate="yes" xml:space="preserve">
          <source>The order in which objects are destroyed during the global destruction before the program exits is unpredictable. This means that any objects contained by your object may already have been destroyed. You should check that a contained object is defined before calling a method on it:</source>
          <target state="translated">El orden en el que se destruyen los objetos durante la destrucción global antes de la salida del programa es impredecible.Esto significa que cualquier objeto contenido por su objeto puede haber sido ya destruido.Debería comprobar que un objeto contenido está definido antes de llamar a un método sobre él:</target>
        </trans-unit>
        <trans-unit id="1362f44821baf70a0c53e26c223d4e933d506d90" translate="yes" xml:space="preserve">
          <source>The order in which this test was run for the given test suite result.</source>
          <target state="translated">El orden en que se realizó esta prueba para el resultado del conjunto de pruebas.</target>
        </trans-unit>
        <trans-unit id="49bfec1872d74cc3aa3b51bdca30781b5d81ee87" translate="yes" xml:space="preserve">
          <source>The order into which &lt;b&gt;characters&lt;/b&gt; sort. This is used by &lt;b&gt;string&lt;/b&gt; comparison routines to decide, for example, where in this glossary to put &amp;ldquo;collating sequence&amp;rdquo;.</source>
          <target state="translated">El orden en el que se clasifican los &lt;b&gt;caracteres&lt;/b&gt; . Esto lo utilizan &lt;b&gt;las&lt;/b&gt; rutinas de comparaci&amp;oacute;n de &lt;b&gt;cadenas&lt;/b&gt; para decidir, por ejemplo, en qu&amp;eacute; lugar de este glosario colocar la &amp;ldquo;secuencia de clasificaci&amp;oacute;n&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="90461643a4b9bcbbb16f181372c5e7705b398666" translate="yes" xml:space="preserve">
          <source>The order of any groups including scripts is not changed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="717cecbd54045d9533e4eb5b41c7c271d10ce913" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open2().</source>
          <target state="translated">El orden de los argumentos difiere del de open2().</target>
        </trans-unit>
        <trans-unit id="1338c98402171198f17cc3c818e89af7db3bfea3" translate="yes" xml:space="preserve">
          <source>The order of arguments differs from that of open3().</source>
          <target state="translated">El orden de los argumentos difiere del de open3().</target>
        </trans-unit>
        <trans-unit id="c7058991786845d90ace9e46987253e3ce531354" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e57a83be29caa0cba0eac2c66aec01c8ecc059c8" translate="yes" xml:space="preserve">
          <source>The ordering is the same as for the regular expression which is the result of EXPR, or the pattern contained by capture group</source>
          <target state="translated">El orden es el mismo que para la expresión regular que es el resultado de EXPR,o el patrón contenido por el grupo de captura</target>
        </trans-unit>
        <trans-unit id="0f9c7f78b473deec8b2b7b3c5ae964aaebd4ae76" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</source>
          <target state="translated">La interfaz &lt;code&gt;MD5&lt;/code&gt; original fue escrita por Neil Winton ( &lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="a967938ebcc10e8da7bfe2a06eaff58eb4186ec0" translate="yes" xml:space="preserve">
          <source>The original &lt;code&gt;MD5&lt;/code&gt; interface was written by Neil Winton (&lt;code&gt;N.Winton@axion.bt.co.uk&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7eb97de2fdb41a38605a8a09e6520652a52c56e7" translate="yes" xml:space="preserve">
          <source>The original Dylan paper</source>
          <target state="translated">El papel original de Dylan</target>
        </trans-unit>
        <trans-unit id="50fea78ce2537fb78816d81a4d2374f6c7eff868" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;Pod::Text::Termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="af612d63faee2dc3856c86fd5cc671079598e557" translate="yes" xml:space="preserve">
          <source>The original Pod::Text contained code to do formatting via termcap sequences, although it wasn't turned on by default and it was problematic to get it to work at all. This rewrite doesn't even try to do that, but a subclass of it does. Look for &lt;a href=&quot;text/termcap&quot;&gt;Pod::Text::Termcap&lt;/a&gt;.</source>
          <target state="translated">El Pod :: Text original conten&amp;iacute;a c&amp;oacute;digo para formatear a trav&amp;eacute;s de secuencias de termcap, aunque no estaba activado de forma predeterminada y era problem&amp;aacute;tico hacer que funcionara. Esta reescritura ni siquiera intenta hacer eso, pero una subclase lo hace. Busque &lt;a href=&quot;text/termcap&quot;&gt;Pod :: Text :: Termcap&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07dd5b1a0e82d303f2b0b28746eab063467b6ba7" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden.</source>
          <target state="translated">La especificaci&amp;oacute;n UTF-8 original permit&amp;iacute;a hasta 6 bytes, para permitir la codificaci&amp;oacute;n de n&amp;uacute;meros hasta &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; . Perl contin&amp;uacute;a permiti&amp;eacute;ndolos, y los ha extendido hasta 13 bytes para codificar puntos de c&amp;oacute;digo hasta lo que cabe en una palabra de 64 bits. Sin embargo, Perl le advertir&amp;aacute; si env&amp;iacute;a alguno de estos como no port&amp;aacute;til; y bajo estrictos protocolos de entrada UTF-8, est&amp;aacute;n prohibidos.</target>
        </trans-unit>
        <trans-unit id="00b0e9de1cd640deb40f9e9ac2ea76a7fdd363f8" translate="yes" xml:space="preserve">
          <source>The original UTF-8 specification allowed up to 6 bytes, to allow encoding of numbers up to &lt;code&gt;0x7FFF_FFFF&lt;/code&gt;. Perl continues to allow those, and has extended that up to 13 bytes to encode code points up to what can fit in a 64-bit word. However, Perl will warn if you output any of these as being non-portable; and under strict UTF-8 input protocols, they are forbidden. In addition, it is now illegal to use a code point larger than what a signed integer variable on your system can hold. On 32-bit ASCII systems, this means &lt;code&gt;0x7FFF_FFFF&lt;/code&gt; is the legal maximum (much higher on 64-bit systems).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a0e54c9386e1df6efdb32bc51b43d382c1fa2bb3" translate="yes" xml:space="preserve">
          <source>The original culture of the pre-populist Internet and the deeply-held beliefs of Perl's author, Larry Wall, gave rise to the free and open distribution policy of Perl. Perl is supported by its users. The core, the standard Perl library, the optional modules, and the documentation you're reading now were all written by volunteers.</source>
          <target state="translated">La cultura original de la Internet pre-populista y las profundas creencias del autor de Perl,Larry Wall,dieron lugar a la política de distribución libre y abierta de Perl.Perl es apoyado por sus usuarios.El núcleo,la biblioteca estándar de Perl,los módulos opcionales y la documentación que está leyendo ahora fueron escritos por voluntarios.</target>
        </trans-unit>
        <trans-unit id="12a169f5e5252000915162d740c1f7fb51701fdf" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_get_call_checker_flags&quot;&gt;&quot;cv_get_call_checker_flags&quot;&lt;/a&gt;, which does not return checker flags. When using a checker function returned by this function, it is only safe to call it with a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb0e3050b313150315f2790edd37f73f93a916ca" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;&quot;cv_set_call_checker_flags&quot;&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility. The effect of that flag setting is that the check function is guaranteed to get a genuine GV as its &lt;code&gt;namegv&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="124cee86525fe9ae3fd7e1b40184ae6b8c5be548" translate="yes" xml:space="preserve">
          <source>The original form of &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt;, which passes it the &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; flag for backward-compatibility.</source>
          <target state="translated">La forma original de &lt;a href=&quot;#cv_set_call_checker_flags&quot;&gt;cv_set_call_checker_flags&lt;/a&gt; , que le pasa la bandera &lt;code&gt;CALL_CHECKER_REQUIRE_GV&lt;/code&gt; para compatibilidad con versiones anteriores.</target>
        </trans-unit>
        <trans-unit id="03b164c5369f7a3512c3a8ff6e7ba584a97c85cb" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="translated">El formato original de los archivos CPAN Meta era &lt;a href=&quot;http://search.cpan.org/perldoc/YAML&quot;&gt;YAML&lt;/a&gt; y el archivo correspondiente se llamaba</target>
        </trans-unit>
        <trans-unit id="12304d794d559e0c5fe4691017042f08f8d52e43" translate="yes" xml:space="preserve">
          <source>The original format of CPAN Meta files was &lt;a href=&quot;yaml&quot;&gt;YAML&lt;/a&gt; and the corresponding file was called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc0efcec67bc372bca64df41283c31757275dca6" translate="yes" xml:space="preserve">
          <source>The original impetus for &lt;code&gt;Perl_langinfo()&lt;/code&gt; was so that code that needs to find out the current currency symbol, floating point radix character, or digit grouping separator can use, on all systems, the simpler and more thread-friendly &lt;code&gt;nl_langinfo&lt;/code&gt; API instead of &lt;code&gt;&lt;a href=&quot;http://man.he.net/man3/localeconv&quot;&gt;localeconv(3)&lt;/a&gt;&lt;/code&gt; which is a pain to make thread-friendly. For other fields returned by &lt;code&gt;localeconv&lt;/code&gt;, it is better to use the methods given in &lt;a href=&quot;perlcall&quot;&gt;perlcall&lt;/a&gt; to call &lt;a href=&quot;posix#localeconv&quot;&gt;&lt;code&gt;POSIX::localeconv()&lt;/code&gt;&lt;/a&gt;, which is thread-friendly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3411d71283c2f07e45c5a35c0fcbe60c51f6b9bb" translate="yes" xml:space="preserve">
          <source>The original purpose of source filters was to let you encrypt your program source to prevent casual piracy. This isn't all they can do, as you'll soon learn. But first, the basics.</source>
          <target state="translated">El propósito original de los filtros de origen era permitirle encriptar la fuente de su programa para prevenir la piratería casual.Esto no es todo lo que pueden hacer,como pronto aprenderás.Pero primero,lo básico.</target>
        </trans-unit>
        <trans-unit id="af210dcaae99ceb3aa829035af3557a9ff65ef3a" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;&lt;a href=&quot;#dORIGMARK&quot;&gt;&quot;dORIGMARK&quot;&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a310ea971545c067e472063428469fc1fad9aa30" translate="yes" xml:space="preserve">
          <source>The original stack mark for the XSUB. See &lt;code&gt;dORIGMARK&lt;/code&gt; .</source>
          <target state="translated">La marca de pila original del XSUB. Ver &lt;code&gt;dORIGMARK&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9fdbd5653ee6341eabe4730cc34935e3db7a992" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt; ), like so:</source>
          <target state="translated">El estilo original usa espacios en blanco y guiones en los nombres de los bloques (excepto para &lt;code&gt;No_Block&lt;/code&gt; ), as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="5c736b5ceaedaf0c5b862acefcb315ae2bd5b9ab" translate="yes" xml:space="preserve">
          <source>The original style uses blanks and hyphens in the block names (except for &lt;code&gt;No_Block&lt;/code&gt;), like so:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8dcbc33a95cd67473b45a522488fc8cc805a4f47" translate="yes" xml:space="preserve">
          <source>The original title was</source>
          <target state="translated">El título original era</target>
        </trans-unit>
        <trans-unit id="07db5f54ef4c59c897a817d5ccebc37f60d9a5b6" translate="yes" xml:space="preserve">
          <source>The original true/false value of whatever was passed into the event (but reduced down to 1 or 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e60244f8f199981b052b42233461b69e602ecf3" translate="yes" xml:space="preserve">
          <source>The original usage can be accomplished by explicit (rather than this pragma's implicit) encoding using the &lt;a href=&quot;encode&quot;&gt;Encode&lt;/a&gt; module:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea4b9a6cd75e55515170d81fe9ec6a923c1c00a" translate="yes" xml:space="preserve">
          <source>The original version of B::Terse was written by Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. This wrapper was written by Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</source>
          <target state="translated">La versi&amp;oacute;n original de B :: Terse fue escrita por Malcolm Beattie, &amp;lt;mbeattie@sable.ox.ac.uk&amp;gt;. Este contenedor fue escrito por Stephen McCamant, &amp;lt;smcc@MIT.EDU&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="ba66fcf36669927e93622e0a65ee5e2d5c9bffdb" translate="yes" xml:space="preserve">
          <source>The original version of PA-RISC, HP no longer sells any system with this chip.</source>
          <target state="translated">La versión original de PA-RISC,HP ya no vende ningún sistema con este chip.</target>
        </trans-unit>
        <trans-unit id="0705420ac769cdd445f5fb673329007ec7bccb68" translate="yes" xml:space="preserve">
          <source>The original version of this article originally appeared in The Perl Journal #10, and is copyright 1998 The Perl Journal. It appears courtesy of Jon Orwant and The Perl Journal. This document may be distributed under the same terms as Perl itself.</source>
          <target state="translated">La versión original de este artículo apareció originalmente en The Perl Journal #10,y tiene los derechos de autor de 1998 The Perl Journal.Aparece por cortesía de Jon Orwant y The Perl Journal.Este documento puede ser distribuido bajo los mismos términos que el propio Perl.</target>
        </trans-unit>
        <trans-unit id="9009e0d18f1d5f332e2819aa4a5b08efaa84ba15" translate="yes" xml:space="preserve">
          <source>The original was written by Andy Dougherty</source>
          <target state="translated">El original fue escrito por Andy Dougherty</target>
        </trans-unit>
        <trans-unit id="ac8cde9199e82022f2799533159dbf659a64016b" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;OA_*&lt;/code&gt; constants should not be used.</source>
          <target state="translated">Las otras constantes &lt;code&gt;OA_*&lt;/code&gt; no deben usarse.</target>
        </trans-unit>
        <trans-unit id="e99c9d2a05f195a52a6e3dccd804ac6a0edaa601" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value.</source>
          <target state="translated">El otro &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; m&amp;eacute;todos est&amp;aacute;n destinados a ser llamado s&amp;oacute;lo una vez por &lt;code&gt;$parser&lt;/code&gt; objeto; pero &lt;code&gt;parse_lines&lt;/code&gt; se puede llamar tantas veces por objeto &lt;code&gt;$parser&lt;/code&gt; como desee, siempre que la &amp;uacute;ltima llamada (y solo la &amp;uacute;ltima llamada) termine con un valor &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6c95c0f77be936d4feacc6aa823fe8dfa8595f61" translate="yes" xml:space="preserve">
          <source>The other &lt;code&gt;parser_&lt;i&gt;whatever&lt;/i&gt;&lt;/code&gt; methods are meant to be called only once per &lt;code&gt;$parser&lt;/code&gt; object; but &lt;code&gt;parse_lines&lt;/code&gt; can be called as many times per &lt;code&gt;$parser&lt;/code&gt; object as you want, as long as the last call (and only the last call) ends with an &lt;code&gt;undef&lt;/code&gt; value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f0806e4bd09cd5bd6dbaceaf9c0baff74d032490" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</source>
          <target state="translated">Los otros argumentos deber&amp;iacute;an resultarle familiares si conoce &lt;code&gt;STORABLE_freeze&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="6d6b16332403f12890e319d0cef347a3dc9b9bef" translate="yes" xml:space="preserve">
          <source>The other arguments should look familiar if you know &lt;code&gt;STORABLE_freeze&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="407b63c5d1d6303ca3afdf08c491fa75e0221db1" translate="yes" xml:space="preserve">
          <source>The other big problem with &lt;code&gt;$^W&lt;/code&gt; is the way you can inadvertently change the warning setting in unexpected places in your code. For example, when the code below is run (without the &lt;b&gt;-w&lt;/b&gt; flag), the second call to &lt;code&gt;doit&lt;/code&gt; will trip a &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; warning, whereas the first will not.</source>
          <target state="translated">El otro gran problema con &lt;code&gt;$^W&lt;/code&gt; es la forma en que puede cambiar inadvertidamente la configuraci&amp;oacute;n de advertencia en lugares inesperados de su c&amp;oacute;digo. Por ejemplo, cuando se ejecuta el c&amp;oacute;digo siguiente (sin el indicador &lt;b&gt;-w&lt;/b&gt; ), la segunda llamada a &lt;code&gt;doit&lt;/code&gt; activar&amp;aacute; una advertencia de &lt;code&gt;&quot;Use of uninitialized value&quot;&lt;/code&gt; , mientras que la primera no lo har&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="fc649a384c23c44b5ba2efe0b85df4a20e6ec321" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt; , so the executables are named accordingly.</source>
          <target state="translated">Los otros casos requieren procedimientos un poco m&amp;aacute;s complicados. A continuaci&amp;oacute;n, supongo que la versi&amp;oacute;n actual de Perl es &lt;code&gt;5.8.2&lt;/code&gt; , por lo que los ejecutables se nombran en consecuencia.</target>
        </trans-unit>
        <trans-unit id="427a9edc8baf371e22d2821e2812db4f5b95659f" translate="yes" xml:space="preserve">
          <source>The other cases require a little bit more convoluted procedures. Below I suppose that the current version of Perl is &lt;code&gt;5.8.2&lt;/code&gt;, so the executables are named accordingly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97290d4117a272682128f8d28555111afe13c240" translate="yes" xml:space="preserve">
          <source>The other common cause is for the characters</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c457b75f143400140761950573f5b842848c756c" translate="yes" xml:space="preserve">
          <source>The other counterpart, in the column labelled &quot;Full-range Unicode&quot;, matches any appropriate characters in the full Unicode character set. For example, &lt;code&gt;\p{Alpha}&lt;/code&gt; matches not just the ASCII alphabetic characters, but any character in the entire Unicode character set considered alphabetic. An entry in the column labelled &quot;backslash sequence&quot; is a (short) equivalent.</source>
          <target state="translated">La otra contraparte, en la columna etiquetada &quot;Unicode de rango completo&quot;, coincide con cualquier car&amp;aacute;cter apropiado en el conjunto de caracteres Unicode completo. Por ejemplo, &lt;code&gt;\p{Alpha}&lt;/code&gt; no s&amp;oacute;lo coincide con los caracteres alfab&amp;eacute;ticos ASCII, sino con cualquier car&amp;aacute;cter del conjunto de caracteres Unicode completo que se considere alfab&amp;eacute;tico. Una entrada en la columna denominada &quot;secuencia de barra invertida&quot; es un equivalente (breve).</target>
        </trans-unit>
        <trans-unit id="f185e517dca4682b63e353adac3daa559be38725" translate="yes" xml:space="preserve">
          <source>The other form is called &quot;block eval&quot;. It is less general than string eval, but the code within the BLOCK is parsed only once (at the same time the code surrounding the &lt;code&gt;eval&lt;/code&gt; itself was parsed) and executed within the context of the current Perl program. This form is typically used to trap exceptions more efficiently than the first, while also providing the benefit of checking the code within BLOCK at compile time. BLOCK is parsed and compiled just once. Since errors are trapped, it often is used to check if a given feature is available.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece66aa413156fc84b73d204d2d9bbbf0fe1c18a" translate="yes" xml:space="preserve">
          <source>The other hack is to restore FP flags after a call to dlopen(). This helps against similar damage done by DLLs _DLLInitTerm() at runtime. Currently no way to switch these hacks off is provided.</source>
          <target state="translated">El otro hack es para restaurar las banderas FP después de una llamada a dlopen().Esto ayuda contra el daño similar hecho por los DLLs _DLLInitTerm()en tiempo de ejecución.Actualmente no hay forma de desactivar estos hackers.</target>
        </trans-unit>
        <trans-unit id="9303fbfd8a21fb685b416cbb44c3a447eed84853" translate="yes" xml:space="preserve">
          <source>The other is to install the module in a temporary location.</source>
          <target state="translated">La otra es instalar el módulo en un lugar temporal.</target>
        </trans-unit>
        <trans-unit id="7370aa653e76af4b47e0ca0cfb340c944499961e" translate="yes" xml:space="preserve">
          <source>The other modification made is that</source>
          <target state="translated">La otra modificación realizada es que</target>
        </trans-unit>
        <trans-unit id="5eaa26235f36f66db1f5d49d6f66d3b1d7e346a6" translate="yes" xml:space="preserve">
          <source>The other one is &quot;Common&quot;. This consists of mostly punctuation, emoji, and characters used in mathematics and music, the ASCII digits &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt;, and full-width forms of these digits. These characters can appear intermixed in text in many of the world's scripts. These also don't cause a script run to not match. But like other scripts, all digits in a run must come from the same set of 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52e0e078ed7f59ceb7388f298d1ea1da0c3bdb08" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt; ) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="translated">La otra raz&amp;oacute;n por la que usar una variable para contener el nombre de otra variable es una mala idea es que la pregunta a menudo surge de una falta de comprensi&amp;oacute;n de las estructuras de datos de Perl, particularmente los hash. Al usar referencias simb&amp;oacute;licas, solo est&amp;aacute; usando el hash de la tabla de s&amp;iacute;mbolos del paquete (como &lt;code&gt;%main::&lt;/code&gt; lugar de un hash definido por el usuario. La soluci&amp;oacute;n es usar su propio hash o una referencia real en su lugar.</target>
        </trans-unit>
        <trans-unit id="14e65562914f1eda6c3850757c3e36b8e4c292d5" translate="yes" xml:space="preserve">
          <source>The other reason why using a variable to hold the name of another variable is a bad idea is that the question often stems from a lack of understanding of Perl data structures, particularly hashes. By using symbolic references, you are just using the package's symbol-table hash (like &lt;code&gt;%main::&lt;/code&gt;) instead of a user-defined hash. The solution is to use your own hash or a real reference instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d23447e512ad32c2037041f02596c75ecf1a5899" translate="yes" xml:space="preserve">
          <source>The other scalar-returning list reduction functions are all specialisations of this generic idea.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5743b7f731fc10e9d1778f5bba7c58560baf6a5c" translate="yes" xml:space="preserve">
          <source>The other structure is pointed to by the &lt;code&gt;regexp&lt;/code&gt; struct's &lt;code&gt;pprivate&lt;/code&gt; and is in addition to &lt;code&gt;intflags&lt;/code&gt; in the same struct considered to be the property of the regex engine which compiled the regular expression;</source>
          <target state="translated">La otra estructura es se&amp;ntilde;alada por el &lt;code&gt;pprivate&lt;/code&gt; de la estructura &lt;code&gt;regexp&lt;/code&gt; y adem&amp;aacute;s de &lt;code&gt;intflags&lt;/code&gt; en la misma estructura se considera propiedad del motor de expresiones regulares que compil&amp;oacute; la expresi&amp;oacute;n regular;</target>
        </trans-unit>
        <trans-unit id="5b612d86c256526a7120d0f540436c62b7f8f79b" translate="yes" xml:space="preserve">
          <source>The other synchronization primitives described below can suffer from similar problems.</source>
          <target state="translated">Las otras primitivas de sincronización que se describen a continuación pueden sufrir problemas similares.</target>
        </trans-unit>
        <trans-unit id="375bee995645e81f309660da902b757d6a8e656a" translate="yes" xml:space="preserve">
          <source>The other way works too, especially if you are sure that all your data are under the same encoding, or if compatibility with older versions of Perl is desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="46a4f63ad2418ff7f127884608b4d5e8c00d7b27" translate="yes" xml:space="preserve">
          <source>The others shouldn't be used in a threaded application.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a811a8ea9dab8327d772322e2e441ab82ca0e86f" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El separador de campo de salida para el operador de impresi&amp;oacute;n. Si se define, este valor se imprime entre cada uno de los argumentos de impresi&amp;oacute;n. El valor predeterminado es &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fdf1adf4fd2953bb9b8993988459b89f053c2344" translate="yes" xml:space="preserve">
          <source>The output field separator for the print operator. If defined, this value is printed between each of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4e6a9347f20222b252ad3782a91c8dbdeaeb1ab5" translate="yes" xml:space="preserve">
          <source>The output file to print to. If the special names &quot;-&quot; or &quot;&amp;gt;&amp;amp;1&quot; or &quot;&amp;gt;&amp;amp;STDOUT&quot; are used then standard output is used. If &quot;&amp;gt;&amp;amp;2&quot; or &quot;&amp;gt;&amp;amp;STDERR&quot; is used then standard error is used.</source>
          <target state="translated">El archivo de salida para imprimir. Si se utilizan los nombres especiales &quot;-&quot; o &quot;&amp;gt; &amp;amp; 1&quot; o &quot;&amp;gt; &amp;amp; STDOUT&quot;, se utiliza la salida est&amp;aacute;ndar. Si se utiliza &quot;&amp;gt; &amp;amp; 2&quot; o &quot;&amp;gt; &amp;amp; STDERR&quot;, se utiliza el error est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="cf7f158841e06623182985de04b67d3455d986ee" translate="yes" xml:space="preserve">
          <source>The output files are placed in the hierarchy rooted at Perl's architecture dependent library directory. You can specify a different hierarchy with a &lt;b&gt;-d&lt;/b&gt; switch.</source>
          <target state="translated">Los archivos de salida se colocan en la jerarqu&amp;iacute;a arraigada en el directorio de bibliotecas dependientes de la arquitectura de Perl. Puede especificar una jerarqu&amp;iacute;a diferente con un &lt;b&gt;modificador -d&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="c27fbec04d459297ba3b8649872110c7c0d3d15a" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;&quot;Configurable Options&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d7376e07f79489cad7f31d1cda9c5ba04d798cb" translate="yes" xml:space="preserve">
          <source>The output format is governed by multiple options described under &lt;a href=&quot;#Configurable-Options&quot;&gt;Configurable Options&lt;/a&gt;.</source>
          <target state="translated">El formato de salida se rige por varias opciones descritas en &lt;a href=&quot;#Configurable-Options&quot;&gt;Opciones configurables&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="99376109c851932f74197e279ea101a89b6befe6" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;functions/write&quot;&gt;write&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;functions/format&quot;&gt;format&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; is within the scope of a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; , not whether the &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; is.</source>
          <target state="translated">El formato de salida de una &lt;a href=&quot;functions/write&quot;&gt;escritura&lt;/a&gt; est&amp;aacute; determinado por una declaraci&amp;oacute;n de formato anterior ( &lt;a href=&quot;functions/format&quot;&gt;formato&lt;/a&gt; ), por lo que si la salida se ve afectada o no por la configuraci&amp;oacute;n regional se determina si el &lt;code&gt;&lt;a href=&quot;functions/format&quot;&gt;format()&lt;/a&gt;&lt;/code&gt; est&amp;aacute; dentro del alcance de una &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; , no si la &lt;code&gt;&lt;a href=&quot;functions/write&quot;&gt;write()&lt;/a&gt;&lt;/code&gt; es.</target>
        </trans-unit>
        <trans-unit id="c1530099f7317e5e8334f8069b6bb6b27df102d4" translate="yes" xml:space="preserve">
          <source>The output format of a &lt;a href=&quot;perlfunc#write&quot;&gt;write()&lt;/a&gt; is determined by an earlier format declaration (&lt;a href=&quot;perlfunc#format&quot;&gt;&quot;format&quot; in perlfunc&lt;/a&gt;), so whether or not the output is affected by locale is determined by if the &lt;code&gt;format()&lt;/code&gt; is within the scope of a &lt;code&gt;use locale&lt;/code&gt;, not whether the &lt;code&gt;write()&lt;/code&gt; is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="821335e2d4cef7b064fd271a1052ad49bb811014" translate="yes" xml:space="preserve">
          <source>The output from an XSUB which uses something like the T_PTRREF map, which doesn't bless the object, might look something like this:</source>
          <target state="translated">La salida de un XSUB que usa algo como el mapa T_PTRREF,que no bendice el objeto,podría ser algo así:</target>
        </trans-unit>
        <trans-unit id="0f57dea9a1d29f634f6f112b3d23937584062d88" translate="yes" xml:space="preserve">
          <source>The output from that will be</source>
          <target state="translated">La salida de eso será</target>
        </trans-unit>
        <trans-unit id="489ef92ce8f286ef5d6d82e8d178af124ae1bd61" translate="yes" xml:space="preserve">
          <source>The output is untainted. If you don't know what tainting is, don't worry about it.</source>
          <target state="translated">La salida está intacta.Si no sabes lo que es la contaminación,no te preocupes.</target>
        </trans-unit>
        <trans-unit id="74b4c8cfc7182db2977001aba6ce4cd0c9c3eff4" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call:</source>
          <target state="translated">La l&amp;iacute;nea de salida se puede utilizar como plantilla en un &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; o llamada de &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="ff265796f887227add453069160ce81043ae2ad9" translate="yes" xml:space="preserve">
          <source>The output line can be used as a template in a &lt;code&gt;pack&lt;/code&gt; or &lt;code&gt;unpack&lt;/code&gt; call:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628776c99f7feeea9f3047213f9a74832f55bae9" translate="yes" xml:space="preserve">
          <source>The output of &lt;code&gt;uname -a&lt;/code&gt; if available, otherwise the hostname. The whole thing is then lower-cased and slashes and single quotes are removed.</source>
          <target state="translated">La salida de &lt;code&gt;uname -a&lt;/code&gt; si est&amp;aacute; disponible, de lo contrario, el nombre de host. A continuaci&amp;oacute;n, todo se reduce a min&amp;uacute;sculas y se eliminan las barras diagonales y las comillas simples.</target>
        </trans-unit>
        <trans-unit id="b50cc56cf670c43f6be20602b16c39970c70b1a0" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El separador de registros de salida para el operador de impresi&amp;oacute;n. Si se define, este valor se imprime despu&amp;eacute;s del &amp;uacute;ltimo de los argumentos de print. El valor predeterminado es &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bed1b55192d15d86c0d4204e8c0dbb14dedd4354" translate="yes" xml:space="preserve">
          <source>The output record separator for the print operator. If defined, this value is printed after the last of print's arguments. Default is &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8366e38dbe1255a05a31be8b8ca8cff24bae31ce" translate="yes" xml:space="preserve">
          <source>The output shows all of the groups. The outermost matches show up first and the nested matches show up later:</source>
          <target state="translated">La salida muestra todos los grupos.Las parejas más alejadas aparecen primero y las parejas anidadas aparecen después:</target>
        </trans-unit>
        <trans-unit id="61a2ac718a159127bd64e67ec39c4e8e007d9514" translate="yes" xml:space="preserve">
          <source>The output shows that Perl found the two major groups:</source>
          <target state="translated">El resultado muestra que Perl encontró los dos grupos principales:</target>
        </trans-unit>
        <trans-unit id="eb272330b66e99a860c17d412be21e54b237263f" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt; . Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt; , but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="translated">El resultado muestra que, mientras que en el bloque &lt;code&gt;OUTER&lt;/code&gt; , los valores de &lt;code&gt;$1&lt;/code&gt; y &lt;code&gt;$2&lt;/code&gt; son de la coincidencia con &lt;code&gt;$outer&lt;/code&gt; . Dentro del bloque &lt;code&gt;INNER&lt;/code&gt; , los valores de &lt;code&gt;$1&lt;/code&gt; y &lt;code&gt;$2&lt;/code&gt; son de la coincidencia con &lt;code&gt;$inner&lt;/code&gt; , pero solo hasta el final del bloque (es decir, el alcance din&amp;aacute;mico). Una vez que se completa el bloque &lt;code&gt;INNER&lt;/code&gt; , los valores de &lt;code&gt;$1&lt;/code&gt; y &lt;code&gt;$2&lt;/code&gt; vuelven a los valores de la coincidencia con &lt;code&gt;$outer&lt;/code&gt; aunque no hayamos hecho otra coincidencia:</target>
        </trans-unit>
        <trans-unit id="3aeb115218152011de3493e1c2fea22949664e64" translate="yes" xml:space="preserve">
          <source>The output shows that while in the &lt;code&gt;OUTER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$outer&lt;/code&gt;. Inside the &lt;code&gt;INNER&lt;/code&gt; block, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; are from the match against &lt;code&gt;$inner&lt;/code&gt;, but only until the end of the block (i.e. the dynamic scope). After the &lt;code&gt;INNER&lt;/code&gt; block completes, the values of &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;$2&lt;/code&gt; return to the values for the match against &lt;code&gt;$outer&lt;/code&gt; even though we have not made another match:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43b62e463d3539b36d5bc54872fb60071ea829c7" translate="yes" xml:space="preserve">
          <source>The output shows the constant() subroutine we're testing being replaced with the value of the &lt;code&gt;DEBUG&lt;/code&gt; constant: zero. The line to be tested has been completely optimized away, and you can't get much more efficient than that.</source>
          <target state="translated">La salida muestra que la subrutina de la constante () que estamos probando se reemplaza con el valor de la constante &lt;code&gt;DEBUG&lt;/code&gt; : cero. La l&amp;iacute;nea que se va a probar se ha optimizado por completo y no puede ser mucho m&amp;aacute;s eficiente que eso.</target>
        </trans-unit>
        <trans-unit id="223632d9e65a77def5c7f3d1e26472458213d8c9" translate="yes" xml:space="preserve">
          <source>The output string will be returned.</source>
          <target state="translated">La cadena de salida será devuelta.</target>
        </trans-unit>
        <trans-unit id="5b1aa869d1f21ede1a6455013df56f91d9ec5d9c" translate="yes" xml:space="preserve">
          <source>The output strings for &lt;b&gt;Tputs&lt;/b&gt; are cached for counts of 1 for performance. &lt;b&gt;Tgoto&lt;/b&gt; and &lt;b&gt;Tpad&lt;/b&gt; do not cache. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; is the raw termcap data and &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; is the cached version.</source>
          <target state="translated">Las cadenas de salida para &lt;b&gt;Tputs&lt;/b&gt; se almacenan en cach&amp;eacute; para conteos de 1 para el rendimiento. &lt;b&gt;Tgoto&lt;/b&gt; y &lt;b&gt;Tpad&lt;/b&gt; no almacenan en cach&amp;eacute;. &lt;code&gt;$self-&amp;gt;{_xx}&lt;/code&gt; son los datos sin procesar de termcap y &lt;code&gt;$self-&amp;gt;{xx}&lt;/code&gt; es la versi&amp;oacute;n en cach&amp;eacute;.</target>
        </trans-unit>
        <trans-unit id="5e7202107b643ac3d564aacb4d094eef76b947a2" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="translated">El valor de salida,con su signo,debe ser un valor positivo en el rango 1,2,...,OBJ2-1 o el mismo valor restado OBJ2.Por ejemplo,si los argumentos de entrada son objetos que representan los números 7 y 5,el método debe devolver un objeto que represente el número 3 y un signo &quot;+&quot;,ya que (3*7)% 5=1 % 5,o un objeto que represente el número 2 y un signo &quot;-&quot;,ya que (-2*7)% 5=1 % 5.</target>
        </trans-unit>
        <trans-unit id="3b69a10a3a50934e50dc62235290b18744d8011f" translate="yes" xml:space="preserve">
          <source>The output value, with its sign, must either be a positive value in the range 1,2,...,OBJ2-1 or the same value subtracted OBJ2. For instance, if the input arguments are objects representing the numbers 7 and 5, the method must either return an object representing the number 3 and a &quot;+&quot; sign, since (3*7) % 5 = 1 % 5, or an object representing the number 2 and a &quot;-&quot; sign, since (-2*7) % 5 = 1 % 5.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1eef73c78f4ba8f7baa5a469f4fff0d89cabb26a" translate="yes" xml:space="preserve">
          <source>The output you'll get when the script is executed:</source>
          <target state="translated">La salida que obtendrás cuando se ejecute el guión:</target>
        </trans-unit>
        <trans-unit id="df416751e8a2d229d8b98d6297b404967b69b568" translate="yes" xml:space="preserve">
          <source>The output:</source>
          <target state="translated">La salida:</target>
        </trans-unit>
        <trans-unit id="0dc65b45e14d95f10af2c76613db8f6869035f53" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="translated">El tiempo total, o de reloj de pared, entre el &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; se llam&amp;oacute; y el momento en que finaliza. El tiempo transcurrido incluye los tiempos del usuario y del sistema, y ​​el tiempo dedicado a esperar a otros usuarios y procesos en el sistema. Inevitablemente, esta es la m&amp;aacute;s aproximada de las medidas dadas.</target>
        </trans-unit>
        <trans-unit id="9571b6fa38431ae0c0fee13dd1186fe4dbf0046f" translate="yes" xml:space="preserve">
          <source>The overall, or wallclock, time between when &lt;code&gt;time&lt;/code&gt; was called, and when it terminates. The elapsed time includes both user and system times, and time spent waiting for other users and processes on the system. Inevitably, this is the most approximate of the measurements given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5407cf16873f519751b5a5a5e241e60dd7a6b88b" translate="yes" xml:space="preserve">
          <source>The pTHX_ symbol in the definition is a macro used by Perl under threading to provide an extra argument to the routine holding a pointer back to the interpreter that is executing the regexp. So under threading all routines get an extra argument.</source>
          <target state="translated">El símbolo pTHX_de la definición es una macro utilizada por Perl en el marco de la programación para proporcionar un argumento adicional a la rutina que mantiene un puntero hacia el intérprete que está ejecutando el regexp.Por lo tanto,bajo el hilo de rosca todas las rutinas obtienen un argumento extra.</target>
        </trans-unit>
        <trans-unit id="f3fe23968698971d8ab162ac70a7f7b71df42802" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;A*&lt;/code&gt; gobbles up all remaining bytes, and &lt;code&gt;$prio&lt;/code&gt; remains undefined! Before we let disappointment dampen the morale: Perl's got the trump card to make this trick too, just a little further up the sleeve. Watch this:</source>
          <target state="translated">El c&amp;oacute;digo de paquete &lt;code&gt;A*&lt;/code&gt; se traga todos los bytes restantes, &amp;iexcl;y &lt;code&gt;$prio&lt;/code&gt; permanece indefinido! Antes de que dejemos que la decepci&amp;oacute;n baje la moral: Perl tiene la carta de triunfo para hacer este truco tambi&amp;eacute;n, solo un poco m&amp;aacute;s bajo la manga. Ver este:</target>
        </trans-unit>
        <trans-unit id="7933b3c7848d20de1a22817261c68e6d7c53c8c0" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="translated">El c&amp;oacute;digo de paquete &lt;code&gt;w&lt;/code&gt; se ha agregado para admitir un esquema de codificaci&amp;oacute;n de datos binarios port&amp;aacute;til que va mucho m&amp;aacute;s all&amp;aacute; de simples enteros. (Los detalles se pueden encontrar en &lt;a href=&quot;http://Casbah.org/&quot;&gt;http://Casbah.org/&lt;/a&gt; , el proyecto Scarab.) Un entero sin signo comprimido BER (Representaci&amp;oacute;n codificada binaria) almacena 128 d&amp;iacute;gitos base, el d&amp;iacute;gito m&amp;aacute;s significativo primero, con el menor n&amp;uacute;mero posible de d&amp;iacute;gitos. El bit ocho (el bit alto) se establece en cada byte excepto en el &amp;uacute;ltimo. No hay l&amp;iacute;mite de tama&amp;ntilde;o para la codificaci&amp;oacute;n BER, pero Perl no ir&amp;aacute; a los extremos.</target>
        </trans-unit>
        <trans-unit id="b79ab5606b336d2e61cfa7238de19673ec485cc8" translate="yes" xml:space="preserve">
          <source>The pack code &lt;code&gt;w&lt;/code&gt; has been added to support a portable binary data encoding scheme that goes way beyond simple integers. (Details can be found at &lt;a href=&quot;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&quot;&gt;https://github.com/mworks-project/mw_scarab/blob/master/Scarab-0.1.00d19/doc/binary-serialization.txt&lt;/a&gt;, the Scarab project.) A BER (Binary Encoded Representation) compressed unsigned integer stores base 128 digits, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last. There is no size limit to BER encoding, but Perl won't go to extremes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1cf9569df81623b7e7940e6c5aeacc511770e43a" translate="yes" xml:space="preserve">
          <source>The pack code for big-endian (high order byte at the lowest address) is &lt;code&gt;n&lt;/code&gt; for 16 bit and &lt;code&gt;N&lt;/code&gt; for 32 bit integers. You use these codes if you know that your data comes from a compliant architecture, but, surprisingly enough, you should also use these pack codes if you exchange binary data, across the network, with some system that you know next to nothing about. The simple reason is that this order has been chosen as the</source>
          <target state="translated">El c&amp;oacute;digo de paquete para big-endian (byte de orden superior en la direcci&amp;oacute;n m&amp;aacute;s baja) es &lt;code&gt;n&lt;/code&gt; para enteros de 16 bits y &lt;code&gt;N&lt;/code&gt; para enteros de 32 bits. Utilice estos c&amp;oacute;digos si sabe que sus datos provienen de una arquitectura compatible, pero, sorprendentemente, tambi&amp;eacute;n debe usar estos c&amp;oacute;digos de paquete si intercambia datos binarios, a trav&amp;eacute;s de la red, con alg&amp;uacute;n sistema del que no sabe casi nada. La simple raz&amp;oacute;n es que este orden ha sido elegido como</target>
        </trans-unit>
        <trans-unit id="57fad0d4b36d335f1fb095e9863848e373754e9c" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt; :</source>
          <target state="translated">El c&amp;oacute;digo de paquete que precede &lt;code&gt;/&lt;/code&gt; puede ser cualquier cosa que se ajuste a representar un n&amp;uacute;mero: Todos los c&amp;oacute;digos de paquete binarios num&amp;eacute;ricos, e incluso c&amp;oacute;digos de texto como &lt;code&gt;A4&lt;/code&gt; o &lt;code&gt;Z*&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="65094bdd21f0a1919cd6838b37b6c0d3bbee3405" translate="yes" xml:space="preserve">
          <source>The pack code preceding &lt;code&gt;/&lt;/code&gt; may be anything that's fit to represent a number: All the numeric binary pack codes, and even text codes such as &lt;code&gt;A4&lt;/code&gt; or &lt;code&gt;Z*&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7172e02890f0d23e60cb06f72d229c969bc3f33e" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="translated">El formato de paquete &lt;code&gt;A&lt;/code&gt; significa &quot;cualquier car&amp;aacute;cter&quot;; Si eres &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; ING y se le han acabado las cosas de paquete, &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; va a llenar el resto con espacios.</target>
        </trans-unit>
        <trans-unit id="44495eb674e0583287f2264fa02ffed62c8c4074" translate="yes" xml:space="preserve">
          <source>The pack format &lt;code&gt;A&lt;/code&gt; means &quot;any character&quot;; if you're &lt;code&gt;pack&lt;/code&gt;ing and you've run out of things to pack, &lt;code&gt;pack&lt;/code&gt; will fill the rest up with spaces.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9582d05d51afa98d043db268f238bb511bec0a17" translate="yes" xml:space="preserve">
          <source>The package contains a session manager and a cache manager. The session manager keeps track of what has been fetched, built, and installed in the current session. The cache manager keeps track of the disk space occupied by the make processes and deletes excess space using a simple FIFO mechanism.</source>
          <target state="translated">El paquete contiene un administrador de sesión y un administrador de caché.El administrador de sesiones lleva un registro de lo que se ha buscado,construido e instalado en la sesión actual.El gestor de caché lleva un registro del espacio en disco ocupado por los procesos de make y elimina el exceso de espacio usando un simple mecanismo FIFO.</target>
        </trans-unit>
        <trans-unit id="f2c3c65c0d45b6b1fe4dfd7fdaf1376fd647a40b" translate="yes" xml:space="preserve">
          <source>The package from which the exceptional subroutine was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fdc4d85fb172b2eb58f10fb1bda38f21c477922a" translate="yes" xml:space="preserve">
          <source>The package name argument will typically be the name of the class into which the subroutine was declared, but it may also be the name of a derived class (since handlers are inherited).</source>
          <target state="translated">El argumento del nombre del paquete será típicamente el nombre de la clase en la que se declaró la subrutina,pero también puede ser el nombre de una clase derivada (ya que los manipuladores son hereditarios).</target>
        </trans-unit>
        <trans-unit id="91efffdbf8c7db0b4f5430206e2d6e6cd3563e8f" translate="yes" xml:space="preserve">
          <source>The package name uses the &lt;code&gt;DBM_Filter::&lt;/code&gt; prefix.</source>
          <target state="translated">El nombre del paquete usa el prefijo &lt;code&gt;DBM_Filter::&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="61ad7bd19c49da733338e6250d6950f088f8b981" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt;).</source>
          <target state="translated">El paquete que representa la distribuci&amp;oacute;n. Por ejemplo, &lt;code&gt;Test::More&lt;/code&gt; o &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt; . Se utilizar&amp;aacute; para obtener informaci&amp;oacute;n sobre la distribuci&amp;oacute;n, como &lt;a href=&quot;#DISTNAME&quot;&gt;DISTNAME&lt;/a&gt; , ubicaciones de instalaci&amp;oacute;n dentro de la biblioteca de Perl y d&amp;oacute;nde se buscar&amp;aacute;n los archivos XS de forma predeterminada (consulte &lt;a href=&quot;#XS&quot;&gt;XS&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="cf847620b5ea5a28241ef80f16dce588c1976c67" translate="yes" xml:space="preserve">
          <source>The package representing the distribution. For example, &lt;code&gt;Test::More&lt;/code&gt; or &lt;code&gt;ExtUtils::MakeMaker&lt;/code&gt;. It will be used to derive information about the distribution such as the &lt;a href=&quot;#DISTNAME&quot;&gt;&quot;DISTNAME&quot;&lt;/a&gt;, installation locations within the Perl library and where XS files will be looked for by default (see &lt;a href=&quot;#XS&quot;&gt;&quot;XS&quot;&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4576d414ced67927c5747f7cd9e683dea9105380" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt;
qr//&lt;/code&gt; ). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="translated">El paquete en el que est&amp;aacute; bendecido el objeto m&amp;aacute;gico qr // (como se ve en &lt;code&gt;&lt;a href=&quot;functions/ref&quot;&gt;ref&lt;/a&gt; qr//&lt;/code&gt; ). Se recomienda que los motores cambien esto por el nombre de su paquete para su identificaci&amp;oacute;n, independientemente de si implementan m&amp;eacute;todos en el objeto.</target>
        </trans-unit>
        <trans-unit id="3eb8be4161caf31aed9851aac09981f2dc091cb7" translate="yes" xml:space="preserve">
          <source>The package the qr// magic object is blessed into (as seen by &lt;code&gt;ref qr//&lt;/code&gt;). It is recommended that engines change this to their package name for identification regardless of if they implement methods on the object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="73079d10e9cd577552c5b87cfb22afa1b7851691" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="translated">El paquete que devuelve este m&amp;eacute;todo tambi&amp;eacute;n debe tener el paquete interno &lt;code&gt;Regexp&lt;/code&gt; en su &lt;code&gt;@ISA&lt;/code&gt; . &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/a&gt;&lt;/code&gt; siempre debe ser verdadero independientemente del motor que se est&amp;eacute; utilizando.</target>
        </trans-unit>
        <trans-unit id="890f0468ce1dfbaa3a848480f6a3e9f003f8a19f" translate="yes" xml:space="preserve">
          <source>The package this method returns should also have the internal &lt;code&gt;Regexp&lt;/code&gt; package in its &lt;code&gt;@ISA&lt;/code&gt;. &lt;code&gt;qr//-&amp;gt;isa(&quot;Regexp&quot;)&lt;/code&gt; should always be true regardless of what engine is being used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7b32ac926fcc794f5f7982e502e4686af4c595bf" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="translated">La variable de paquete &lt;code&gt;@EXPORT&lt;/code&gt; determinar&amp;aacute; qu&amp;eacute; s&amp;iacute;mbolos se exportar&amp;aacute;n cuando la persona que llama simplemente diga &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; Net::Acme&lt;/code&gt; ; casi nunca querr&amp;aacute; poner nada all&amp;iacute;. &lt;code&gt;@EXPORT_OK&lt;/code&gt; , por otro lado, especifica qu&amp;eacute; s&amp;iacute;mbolos est&amp;aacute; dispuesto a exportar. Si desea exportar un mont&amp;oacute;n de s&amp;iacute;mbolos, use &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; y defina un conjunto de exportaci&amp;oacute;n est&amp;aacute;ndar; consulte &lt;a href=&quot;exporter&quot;&gt;Exportador&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="9d8ef2409327fe0b3b34e7e40584004dedfbd9fc" translate="yes" xml:space="preserve">
          <source>The package variable &lt;code&gt;@EXPORT&lt;/code&gt; will determine which symbols will get exported when the caller simply says &lt;code&gt;use Net::Acme&lt;/code&gt; - you will hardly ever want to put anything in there. &lt;code&gt;@EXPORT_OK&lt;/code&gt;, on the other hand, specifies which symbols you're willing to export. If you do want to export a bunch of symbols, use the &lt;code&gt;%EXPORT_TAGS&lt;/code&gt; and define a standard export set - look at &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="650111e5202c538679780ce9ea893a905f97b0fc" translate="yes" xml:space="preserve">
          <source>The packages relating to various DBM-related implementations (</source>
          <target state="translated">Los paquetes relativos a diversas implementaciones relacionadas con el DBM (</target>
        </trans-unit>
        <trans-unit id="02ef2277604c9b31476ae26defa7602571798335" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The &lt;code&gt;COP_SEQ_RANGE_LOW&lt;/code&gt; and &lt;code&gt;_HIGH&lt;/code&gt; fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c94813a5310ff08ec4ccbc37cd40783e0084e83e" translate="yes" xml:space="preserve">
          <source>The pad names in the PADNAMELIST have their PV holding the name of the variable. The COP_SEQ_RANGE_LOW and _HIGH fields form a range (low+1..high inclusive) of cop_seq numbers for which the name is valid. During compilation, these fields may hold the special value PERL_PADSEQ_INTRO to indicate various stages:</source>
          <target state="translated">Los nombres de los pads en el PADNAMELISTAS tienen su PV que contiene el nombre de la variable.Los campos COP_SEQ_RANGE_LOW y _HIGH forman un rango (bajo+1..alto inclusive)de números cop_seq para los cuales el nombre es válido.Durante la compilación,estos campos pueden contener el valor especial PERL_PADSEQ_INTRO para indicar varias etapas:</target>
        </trans-unit>
        <trans-unit id="ad69ddb72e9f5b5565c26efc4eeac2130e2ed028" translate="yes" xml:space="preserve">
          <source>The padded $string is returned.</source>
          <target state="translated">La cuerda acolchada es devuelta.</target>
        </trans-unit>
        <trans-unit id="d3a360c727f09061a32c58fb443bedffc200fc64" translate="yes" xml:space="preserve">
          <source>The paper &quot;How to Break MD5 and Other Hash Functions&quot; by Xiaoyun Wang and Hongbo Yu.</source>
          <target state="translated">El documento &quot;Cómo romper el MD5 y otras funciones del hash&quot; de Xiaoyun Wang y Hongbo Yu.</target>
        </trans-unit>
        <trans-unit id="9446a617fdf40553874ee589e7fc235690a0bb87" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;Text::Wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bcc7e86c6ab48d9801f437d7ce277bb0ef436bb" translate="yes" xml:space="preserve">
          <source>The paragraphs you give to &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; should not contain embedded newlines. &lt;a href=&quot;text/wrap&quot;&gt;Text::Wrap&lt;/a&gt; doesn't justify the lines (flush-right).</source>
          <target state="translated">Los p&amp;aacute;rrafos que le da a &lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt; no deben contener nuevas l&amp;iacute;neas incrustadas. &lt;a href=&quot;text/wrap&quot;&gt;Text :: Wrap&lt;/a&gt; no justifica las l&amp;iacute;neas (alineadas a la derecha).</target>
        </trans-unit>
        <trans-unit id="0d3c20158693e8f7ad6ce14151f5e71a493b3128" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the compressed data. This parameter can take one of these forms.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$output_filename_or_reference&lt;/code&gt; se utiliza para controlar el destino de los datos comprimidos. Este par&amp;aacute;metro puede adoptar una de estas formas.</target>
        </trans-unit>
        <trans-unit id="2a2ee58982c19a9868c4499e7bd1b9d1531f2904" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$output_filename_or_reference&lt;/code&gt; is used to control the destination of the uncompressed data. This parameter can take one of these forms.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$output_filename_or_reference&lt;/code&gt; se utiliza para controlar el destino de los datos sin comprimir. Este par&amp;aacute;metro puede adoptar una de estas formas.</target>
        </trans-unit>
        <trans-unit id="4380851c25da81befd83447bad55f6f9f369b966" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;$text&lt;/code&gt; is a string or block of text to be parsed for interior sequences; and the parameter &lt;code&gt;$line_num&lt;/code&gt; is the line number corresponding to the beginning of &lt;code&gt;$text&lt;/code&gt; .</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$text&lt;/code&gt; es una cadena o bloque de texto que se analizar&amp;aacute; para secuencias interiores; y el par&amp;aacute;metro &lt;code&gt;$line_num&lt;/code&gt; es el n&amp;uacute;mero de l&amp;iacute;nea correspondiente al comienzo de &lt;code&gt;$text&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="175733e4967510eadb5d4ab18e962461101eaed6" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;extra_libs&lt;/code&gt; can be used to specify &lt;b&gt;additional&lt;/b&gt; paths to search for installed modules. For instance</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;extra_libs&lt;/code&gt; se puede utilizar para especificar rutas &lt;b&gt;adicionales&lt;/b&gt; para buscar m&amp;oacute;dulos instalados. Por ejemplo</target>
        </trans-unit>
        <trans-unit id="76679b1c7056137b35154fa4603dcc56a2e17eed" translate="yes" xml:space="preserve">
          <source>The parameter &lt;code&gt;type&lt;/code&gt; is an enumeration which specifies which of the 3 interface methods (DB_HASH, DB_BTREE or DB_RECNO) is to be used. Depending on which of these is actually chosen, the final parameter,</source>
          <target state="translated">El &lt;code&gt;type&lt;/code&gt; par&amp;aacute;metro es una enumeraci&amp;oacute;n que especifica cu&amp;aacute;l de los 3 m&amp;eacute;todos de interfaz (DB_HASH, DB_BTREE o DB_RECNO) se utilizar&amp;aacute;. Dependiendo de cu&amp;aacute;l de estos se elija realmente, el par&amp;aacute;metro final,</target>
        </trans-unit>
        <trans-unit id="6df79d8edafef2b8d47fc8b433ceb1dac071556d" translate="yes" xml:space="preserve">
          <source>The parameter list to my() may be assigned to if desired, which allows you to initialize your variables. (If no initializer is given for a particular variable, it is created with the undefined value.) Commonly this is used to name input parameters to a subroutine. Examples:</source>
          <target state="translated">La lista de parámetros de my()puede asignarse si se desea,lo que permite inicializar las variables.(Si no se da un inicializador para una variable en particular,se crea con el valor indefinido).Comúnmente esto se usa para nombrar los parámetros de entrada de una subrutina.Ejemplos:</target>
        </trans-unit>
        <trans-unit id="42306ba107d404a6932eda2f03148007a2382a8a" translate="yes" xml:space="preserve">
          <source>The parameter's default value will still be evaluated if the corresponding argument isn't supplied, even though the value won't be stored anywhere. This is in case evaluating it has important side effects. However, it will be evaluated in void context, so if it doesn't have side effects and is not trivial it will generate a warning if the &quot;void&quot; warning category is enabled. If a nameless optional parameter's default value is not important, it may be omitted just as the parameter's name was:</source>
          <target state="translated">El valor por defecto del parámetro se seguirá evaluando si no se suministra el argumento correspondiente,aunque el valor no se almacene en ninguna parte.Esto es en caso de que la evaluación tenga efectos secundarios importantes.Sin embargo,se evaluará en un contexto de vacío,por lo que si no tiene efectos secundarios y no es trivial,generará una advertencia si la categoría de advertencia de &quot;vacío&quot; está activada.Si el valor por defecto de un parámetro opcional sin nombre no es importante,puede omitirse tal como lo era el nombre del parámetro:</target>
        </trans-unit>
        <trans-unit id="59f23da7798f0b234972a256a92c78bcfb8c2aa3" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the compressed data.</source>
          <target state="translated">El par&amp;aacute;metro, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , se utiliza para definir el origen de los datos comprimidos.</target>
        </trans-unit>
        <trans-unit id="ed835ab2fa9d34eac4fd3a603940891a0a5eef62" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , is used to define the source of the uncompressed data.</source>
          <target state="translated">El par&amp;aacute;metro, &lt;code&gt;$input_filename_or_reference&lt;/code&gt; , se utiliza para definir el origen de los datos sin comprimir.</target>
        </trans-unit>
        <trans-unit id="4cb5c66abe58beef181f4c5d5c5b7b8d0a8b5206" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the compressed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c7a676729b0be9ab28de0e8dc42a59d230912658" translate="yes" xml:space="preserve">
          <source>The parameter, &lt;code&gt;$input_filename_or_reference&lt;/code&gt;, is used to define the source of the uncompressed data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0cab04bcd8cbbda8dd4d2c9ce2cf18535f80ac" translate="yes" xml:space="preserve">
          <source>The parameters it accepts are:</source>
          <target state="translated">Los parámetros que acepta son:</target>
        </trans-unit>
        <trans-unit id="a830abc7b9d4b876164e2805f5f239e46c825485" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="translated">Los par&amp;aacute;metros para &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; lib&lt;/code&gt; se agregan al inicio de la ruta de b&amp;uacute;squeda de Perl. Diciendo</target>
        </trans-unit>
        <trans-unit id="735cc433a3b6580bd3067e26aea227e52cc434e6" translate="yes" xml:space="preserve">
          <source>The parameters to &lt;code&gt;use lib&lt;/code&gt; are added to the start of the perl search path. Saying</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea253e51dc3b40387e985b7980c9898cef5a3467" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="translated">Los par&amp;eacute;ntesis sobre los &lt;code&gt;XSLoader::load()&lt;/code&gt; son necesarios ya que reemplazamos &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; XSLoader&lt;/code&gt; por &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , por lo que el compilador no sabe que hay una funci&amp;oacute;n &lt;code&gt;XSLoader::load()&lt;/code&gt; presente.</target>
        </trans-unit>
        <trans-unit id="0d68003766a6505369e854c0eee6d10a747bd253" translate="yes" xml:space="preserve">
          <source>The parentheses about &lt;code&gt;XSLoader::load()&lt;/code&gt; arguments are needed since we replaced &lt;code&gt;use XSLoader&lt;/code&gt; by &lt;code&gt;require&lt;/code&gt;, so the compiler does not know that a function &lt;code&gt;XSLoader::load()&lt;/code&gt; is present.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f992098d3a5a843dac6b8ae9c7b69d4a2fac46e8" translate="yes" xml:space="preserve">
          <source>The parse proceeds pretty much exactly as it does during the construction phase, except that most routines are short-circuited to change the size field &lt;code&gt;RExC_size&lt;/code&gt; and not do anything else.</source>
          <target state="translated">El an&amp;aacute;lisis se realiza casi exactamente como lo hace durante la fase de construcci&amp;oacute;n, excepto que la mayor&amp;iacute;a de las rutinas se cortocircuitan para cambiar el tama&amp;ntilde;o del campo &lt;code&gt;RExC_size&lt;/code&gt; y no hacer nada m&amp;aacute;s.</target>
        </trans-unit>
        <trans-unit id="ce842c5dcf2b13fb8c9e8394fe72be9c8b2663ca" translate="yes" xml:space="preserve">
          <source>The parser is heavily inspired from the one in &lt;a href=&quot;ExtUtils::ParseXS&quot;&gt;ExtUtils::ParseXS&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93ac900e49339cc6ef6dea21ed4478644c93af89" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt; , and that and its associated routines can be found in</source>
          <target state="translated">El analizador es noblemente asistido por el lexer, que divide su entrada en tokens y decide qu&amp;eacute; tipo de cosa es cada token: un nombre de variable, un operador, una palabra clave, una subrutina, una funci&amp;oacute;n central, etc. El principal punto de entrada al lexer es &lt;code&gt;yylex&lt;/code&gt; , y eso y sus rutinas asociadas se pueden encontrar en</target>
        </trans-unit>
        <trans-unit id="22cd9c89b1bd366e42455f5006c44969bcb5bdee" translate="yes" xml:space="preserve">
          <source>The parser is nobly assisted by the lexer, which chunks up your input into tokens, and decides what type of thing each token is: a variable name, an operator, a bareword, a subroutine, a core function, and so on. The main point of entry to the lexer is &lt;code&gt;yylex&lt;/code&gt;, and that and its associated routines can be found in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c291c44225b529aa63eb30ed6a4d6cbe06294dcd" translate="yes" xml:space="preserve">
          <source>The parser then sees the following code:</source>
          <target state="translated">El analizador ve entonces el siguiente código:</target>
        </trans-unit>
        <trans-unit id="d30f0f58beb42ee5cf5d76db1412cac91e934bb2" translate="yes" xml:space="preserve">
          <source>The part of an Email address which follows the @ is not necessarily a hostname, it is a mail domain. To find the name of a host to connect for a mail domain you need to do a DNS MX lookup</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09f50fcb4a70f717d3ac7b5f391fbd97a01ce899" translate="yes" xml:space="preserve">
          <source>The part of the address of a TCP or UDP socket that directs packets to the correct process after finding the right machine, something like the phone extension you give when you reach the company operator. Also the result of converting code to run on a different platform than originally intended, or the verb denoting this conversion.</source>
          <target state="translated">La parte de la dirección de un socket TCP o UDP que dirige los paquetes al proceso correcto después de encontrar la máquina adecuada,algo así como la extensión telefónica que das cuando te comunicas con el operador de la compañía.También el resultado de convertir el código para que se ejecute en una plataforma diferente a la prevista originalmente,o el verbo que denota esta conversión.</target>
        </trans-unit>
        <trans-unit id="ae986ba9c61f4a263f7b3033ed66b7a9c47ca2ea" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use does not support the specified signal being used in a &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; call.</source>
          <target state="translated">La copia particular de Perl que est&amp;aacute; tratando de usar no admite la se&amp;ntilde;al especificada que se usa en una llamada &lt;code&gt;-&amp;gt;kill()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="24e4beb9cede37117dbc38642ef9d4cdf73ef0f4" translate="yes" xml:space="preserve">
          <source>The particular copy of Perl that you're trying to use was not built using the &lt;code&gt;useithreads&lt;/code&gt; configuration option.</source>
          <target state="translated">La copia particular de Perl que est&amp;aacute; intentando utilizar no se cre&amp;oacute; con la opci&amp;oacute;n de configuraci&amp;oacute;n &lt;code&gt;useithreads&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e133c3129f1a418b83b69fbe9affe042d494a52e" translate="yes" xml:space="preserve">
          <source>The particular macro you must use depends on which &lt;code&gt;sv_set*v&lt;/code&gt; routine you called first. This is because every &lt;code&gt;sv_set*v&lt;/code&gt; routine turns on only the bit for the particular type of data being set, and turns off all the rest.</source>
          <target state="translated">La macro particular que debe usar depende de la rutina &lt;code&gt;sv_set*v&lt;/code&gt; que haya llamado primero. Esto se debe a que cada rutina &lt;code&gt;sv_set*v&lt;/code&gt; activa solo el bit para el tipo particular de datos que se est&amp;aacute; configurando y desactiva el resto.</target>
        </trans-unit>
        <trans-unit id="9a1356c02587b997ee27ddf50eebcf831988fbcb" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases%28%29&quot;&gt;&quot;prop_aliases()&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c24d584fffb94c2e195393379212bd0e772bba9" translate="yes" xml:space="preserve">
          <source>The passed-in property may be specified as any of the synonyms returned by &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases()&lt;/a&gt;.</source>
          <target state="translated">La propiedad pasada puede especificarse como cualquiera de los sin&amp;oacute;nimos devueltos por &lt;a href=&quot;#prop_aliases()&quot;&gt;prop_aliases ()&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="515ad1971581ebeed29e0dfbff2e2ca6f9f34b5c" translate="yes" xml:space="preserve">
          <source>The patchlevel level of this package. The value of patchlevel comes from the</source>
          <target state="translated">El nivel de parcheo de este paquete.El valor de patchlevel viene de la</target>
        </trans-unit>
        <trans-unit id="6c9c1991e5426882e512831205056ad8d0cb53e5" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt; . By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt; . However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt; .</source>
          <target state="translated">El camino que toma Perl a trav&amp;eacute;s de &lt;code&gt;@INC&lt;/code&gt; . Por defecto, esta es una primera b&amp;uacute;squeda de doble profundidad, una vez buscando m&amp;eacute;todos definidos y una vez para &lt;code&gt;AUTOLOAD&lt;/code&gt; . Sin embargo, Perl le permite configurar esto con &lt;code&gt;mro&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bfd87cb3c63ce818c0482394b6803650584202ed" translate="yes" xml:space="preserve">
          <source>The path Perl takes through &lt;code&gt;@INC&lt;/code&gt;. By default, this is a double depth first search, once looking for defined methods and once for &lt;code&gt;AUTOLOAD&lt;/code&gt;. However, Perl lets you configure this with &lt;code&gt;mro&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="97b7ffc6783961615c324915aaa3803b45441d58" translate="yes" xml:space="preserve">
          <source>The path from the uri, will be at least a single '/'.</source>
          <target state="translated">El camino desde el uri,será al menos un simple &quot;/&quot;.</target>
        </trans-unit>
        <trans-unit id="935a26d686af6b04ea7fea8358669d0caebc7249" translate="yes" xml:space="preserve">
          <source>The path of the file from which the history (assuming a usable Term::ReadLine backend) will be read on the debugger's startup, and to which it will be saved on shutdown (for persistence across sessions). Similar in concept to Bash's &lt;code&gt;.bash_history&lt;/code&gt; file.</source>
          <target state="translated">La ruta del archivo desde el cual se leer&amp;aacute; el historial (asumiendo un backend de Term :: ReadLine utilizable) en el inicio del depurador, y en el que se guardar&amp;aacute; cuando se apague (para persistencia entre sesiones). Similar en concepto al archivo &lt;code&gt;.bash_history&lt;/code&gt; de Bash .</target>
        </trans-unit>
        <trans-unit id="b7867a311910479846a23412feb4307a4674c491" translate="yes" xml:space="preserve">
          <source>The path to the &lt;code&gt;git&lt;/code&gt; binary to use for the Git features. The default is &lt;code&gt;/usr/local/bin/git&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3f73d1d0634237caab821e6e9c8fad9914a18a73" translate="yes" xml:space="preserve">
          <source>The path to the file is automatically converted to a Unix like equivalent for use in the archive, and, if on MacOS, the file's modification time is converted from the MacOS epoch to the Unix epoch. So tar archives created on MacOS with &lt;b&gt;Archive::Tar&lt;/b&gt; can be read both with</source>
          <target state="translated">La ruta al archivo se convierte autom&amp;aacute;ticamente a un equivalente similar a Unix para su uso en el archivo y, si est&amp;aacute; en MacOS, la hora de modificaci&amp;oacute;n del archivo se convierte de la &amp;eacute;poca de MacOS a la &amp;eacute;poca de Unix. Por lo tanto, los archivos tar creados en MacOS con &lt;b&gt;Archive :: Tar&lt;/b&gt; se pueden leer con</target>
        </trans-unit>
        <trans-unit id="2ab24d7b050cb5882eec74eec0cbc6ea2a2768dd" translate="yes" xml:space="preserve">
          <source>The pathname of a POD file to syntax-check (defaults to standard input).</source>
          <target state="translated">La ruta de un archivo POD para comprobar la sintaxis (por defecto a la entrada estándar).</target>
        </trans-unit>
        <trans-unit id="3091661abc10e8b933048a63287800c8286b8cec" translate="yes" xml:space="preserve">
          <source>The pathname of a file containing pod documentation to be output in usage message format (defaults to standard input).</source>
          <target state="translated">La ruta de un archivo que contiene la documentación de la vaina que se emitirá en el formato de mensaje de uso (por defecto es la entrada estándar).</target>
        </trans-unit>
        <trans-unit id="5506a685c5fca482706d4108f11645e50bb17fd9" translate="yes" xml:space="preserve">
          <source>The pathname of a file from which to select sections of pod documentation (defaults to standard input).</source>
          <target state="translated">La ruta de un archivo a partir del cual se seleccionan secciones de la documentación de la vaina (por defecto a la entrada estándar).</target>
        </trans-unit>
        <trans-unit id="64067e36292a9c79bf92f0c4d392216daafe926d" translate="yes" xml:space="preserve">
          <source>The pattern begins with a class matching a subset of letters. Whenever this matches, a statement like &lt;code&gt;$count{'a'}++;&lt;/code&gt; is executed, incrementing the letter's counter. Then &lt;code&gt;(*FAIL)&lt;/code&gt; does what it says, and the regexp engine proceeds according to the book: as long as the end of the string hasn't been reached, the position is advanced before looking for another vowel. Thus, match or no match makes no difference, and the regexp engine proceeds until the entire string has been inspected. (It's remarkable that an alternative solution using something like</source>
          <target state="translated">El patr&amp;oacute;n comienza con una clase que coincide con un subconjunto de letras. Siempre que esto coincida, una declaraci&amp;oacute;n como &lt;code&gt;$count{'a'}++;&lt;/code&gt; se ejecuta, incrementando el contador de letras. Luego &lt;code&gt;(*FAIL)&lt;/code&gt; hace lo que dice, y el motor de expresiones regulares procede de acuerdo con el libro: mientras no se haya alcanzado el final de la cadena, la posici&amp;oacute;n avanza antes de buscar otra vocal. Por lo tanto, coincidir o no coincidir no hace ninguna diferencia, y el motor de expresiones regulares contin&amp;uacute;a hasta que se haya inspeccionado toda la cadena. (Es notable que una soluci&amp;oacute;n alternativa que utilice algo como</target>
        </trans-unit>
        <trans-unit id="a027102deb051cbffb2428b7b7a47e74a500b189" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;a href=&quot;#defined-EXPR&quot;&gt;&lt;code&gt;defined&lt;/code&gt;&lt;/a&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="194b10f85ac928e670426276285fc77367b6bf3e" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">La coincidencia de patrones se realiza correctamente y se define &lt;code&gt;$1&lt;/code&gt; , aunque no coincide con &quot;nada&quot;. Realmente no dej&amp;oacute; de coincidir con nada. M&amp;aacute;s bien, coincidi&amp;oacute; con algo que result&amp;oacute; tener cero caracteres. Todo esto es muy franco y honesto. Cuando una funci&amp;oacute;n devuelve un valor indefinido, es una admisi&amp;oacute;n de que no podr&amp;iacute;a darle una respuesta honesta. Por lo tanto, debe usar &lt;code&gt;&lt;a href=&quot;defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; solo cuando cuestione la integridad de lo que est&amp;aacute; tratando de hacer. En otras ocasiones, lo que desea es una simple comparaci&amp;oacute;n con &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6ccde9606e998bb56b83482fdb0ce2d1cd2b87e5" translate="yes" xml:space="preserve">
          <source>The pattern match succeeds and &lt;code&gt;$1&lt;/code&gt; is defined, although it matched &quot;nothing&quot;. It didn't really fail to match anything. Rather, it matched something that happened to be zero characters long. This is all very above-board and honest. When a function returns an undefined value, it's an admission that it couldn't give you an honest answer. So you should use &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; only when questioning the integrity of what you're trying to do. At other times, a simple comparison to &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;&quot;&quot;&lt;/code&gt; is what you want.</source>
          <target state="translated">La coincidencia de patrones se realiza correctamente y se define &lt;code&gt;$1&lt;/code&gt; , aunque no coincide con &quot;nada&quot;. Realmente no dej&amp;oacute; de coincidir con nada. M&amp;aacute;s bien, coincidi&amp;oacute; con algo que result&amp;oacute; tener cero caracteres. Todo esto es muy franco y honesto. Cuando una funci&amp;oacute;n devuelve un valor indefinido, es una admisi&amp;oacute;n de que no podr&amp;iacute;a darle una respuesta honesta. Por lo tanto, debe usar &lt;code&gt;&lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt;&lt;/code&gt; solo cuando cuestione la integridad de lo que est&amp;aacute; tratando de hacer. En otras ocasiones, lo que desea es una simple comparaci&amp;oacute;n con &lt;code&gt;0&lt;/code&gt; o &lt;code&gt;&quot;&quot;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="00e74cbb0f8570bc720cdf9f1dc73c5533c198b5" translate="yes" xml:space="preserve">
          <source>The pattern matching metacharacters &quot;(&quot;, &quot;)&quot;, and &quot;|&quot; do not have backslashes in front.</source>
          <target state="translated">El patrón que coincide con los metacaracteres &quot;(&quot;,&quot;)&quot;,y &quot;|&quot; no tienen barras invertidas en el frente.</target>
        </trans-unit>
        <trans-unit id="8647f015f186197cabe9c1508a8d5b1dddf875e9" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (aka &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="translated">Las operaciones de coincidencia de patrones &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; (tambi&amp;eacute;n conocidas como &lt;code&gt;&lt;a href=&quot;functions/y&quot;&gt;y///&lt;/a&gt;&lt;/code&gt; ) cuando se usan sin un operador &lt;code&gt;=~&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="86784bd21e39089878c5197cae9b26fe435b4866" translate="yes" xml:space="preserve">
          <source>The pattern matching operations &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt; and &lt;code&gt;tr///&lt;/code&gt; (aka &lt;code&gt;y///&lt;/code&gt;) when used without an &lt;code&gt;=~&lt;/code&gt; operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="216352b3a9f025091614aa329a166fdb30a18a8e" translate="yes" xml:space="preserve">
          <source>The pattern modifiers:</source>
          <target state="translated">Los modificadores de patrón:</target>
        </trans-unit>
        <trans-unit id="a2c1a780666383b49402abd005e8fafffcab62b8" translate="yes" xml:space="preserve">
          <source>The pattern of macro calls is like this:</source>
          <target state="translated">El patrón de las llamadas macro es así:</target>
        </trans-unit>
        <trans-unit id="3569af6a782c9884f9c5e89ba969f12fe42cf2da" translate="yes" xml:space="preserve">
          <source>The pattern really,</source>
          <target state="translated">El patrón en realidad,</target>
        </trans-unit>
        <trans-unit id="f373f7a0e4daf869b86fcbb5c4b5b4f2ee465c22" translate="yes" xml:space="preserve">
          <source>The pattern will be used as a Perl regular expression (as opposed to a simple grep regex).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a46001019582eae5c4e5728c4a3fb31cd3dbf38" translate="yes" xml:space="preserve">
          <source>The patterns used in Perl pattern matching evolved from those supplied in the Version 8 regex routines. (The routines are derived (distantly) from Henry Spencer's freely redistributable reimplementation of the V8 routines.) See &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Version 8 Regular Expressions&lt;/a&gt; for details.</source>
          <target state="translated">Los patrones utilizados en la coincidencia de patrones de Perl evolucionaron a partir de los suministrados en las rutinas de expresiones regulares de la Versi&amp;oacute;n 8. (Las rutinas se derivan (distante) de la reimplementaci&amp;oacute;n libremente redistribuible de las rutinas V8 de Henry Spencer.) Consulte &lt;a href=&quot;#Version-8-Regular-Expressions&quot;&gt;Expresiones regulares de la Versi&amp;oacute;n 8&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="e790c64d043de1336b86cfb89ee718b54cb057cd" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;&quot;PL_rpeepp&quot;&lt;/a&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8569c5379da2f4cde343faebf02e081c76fc9c06" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3A-peephole-optimization&quot;&gt;&quot;Compile pass 3: peephole optimization&quot; in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;&quot;PL_peepp&quot;&lt;/a&gt; hook.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dac0ad9b1d3df00129661ed1e95ffc2c13f0c968" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate on ops throughout the subroutine's structure, rather than just at the top level, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; hook.</source>
          <target state="translated">El optimizador de mirilla nunca debe reemplazarse por completo. M&amp;aacute;s bien, agr&amp;eacute;guele c&amp;oacute;digo envolviendo el optimizador existente. La forma b&amp;aacute;sica de hacer esto se puede ver en &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: optimizaci&amp;oacute;n de mirilla en perlguts&lt;/a&gt; . Si el nuevo c&amp;oacute;digo desea operar en operaciones a lo largo de la estructura de la subrutina, en lugar de solo en el nivel superior, es probable que sea m&amp;aacute;s conveniente ajustar el gancho &lt;a href=&quot;#PL_rpeepp&quot;&gt;PL_rpeepp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="db43041726026c591925cfc25e5688f00dc4bbac" translate="yes" xml:space="preserve">
          <source>The peephole optimiser should never be completely replaced. Rather, add code to it by wrapping the existing optimiser. The basic way to do this can be seen in &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: peephole optimization in perlguts&lt;/a&gt;. If the new code wishes to operate only on ops at a subroutine's top level, rather than throughout the structure, it is likely to be more convenient to wrap the &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; hook.</source>
          <target state="translated">El optimizador de mirilla nunca debe reemplazarse por completo. M&amp;aacute;s bien, agr&amp;eacute;guele c&amp;oacute;digo envolviendo el optimizador existente. La forma b&amp;aacute;sica de hacer esto se puede ver en &lt;a href=&quot;perlguts#Compile-pass-3%3a-peephole-optimization&quot;&gt;Compile pass 3: optimizaci&amp;oacute;n de mirilla en perlguts&lt;/a&gt; . Si el nuevo c&amp;oacute;digo desea operar solo en operaciones en el nivel superior de una subrutina, en lugar de en toda la estructura, es probable que sea m&amp;aacute;s conveniente ajustar el gancho &lt;a href=&quot;#PL_peepp&quot;&gt;PL_peepp&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="ace3f1e6483238aa81eb601036e5dcd7d2b38b3a" translate="yes" xml:space="preserve">
          <source>The per-instance data are held in memory beyond the basic PerlIOl struct, by making a PerlIOl the first member of the layer's struct thus:</source>
          <target state="translated">Los datos de cada sustancia se mantienen en la memoria más allá de la estructura básica de PerlIOl,haciendo que un PerlIOl sea el primer miembro de la estructura de la capa así:</target>
        </trans-unit>
        <trans-unit id="467fb902a44226db21d27e75dc641b031d86cd72" translate="yes" xml:space="preserve">
          <source>The per-instance data for a particular handle.</source>
          <target state="translated">Los datos de cada sustancia para un mango en particular.</target>
        </trans-unit>
        <trans-unit id="85e58f1f52dd9a0e84852e44b90f48bbed040fce" translate="yes" xml:space="preserve">
          <source>The per-record overhead will limit the maximum number of records you can access per file. Note that</source>
          <target state="translated">La sobrecarga por registro limitará el número máximo de registros a los que se puede acceder por archivo.Tenga en cuenta que</target>
        </trans-unit>
        <trans-unit id="874d7f7aa12fc5ea3bd61b16d41289fe642a630c" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot;</source>
          <target state="translated">El punto '.' coincide con cualquier personaje menos con &quot;\n&quot;</target>
        </trans-unit>
        <trans-unit id="e038fd297e6c1d463ecc98d5fcaacd0e4180bccd" translate="yes" xml:space="preserve">
          <source>The period '.' matches any character but &quot;\n&quot; (unless the modifier &lt;code&gt;//s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="translated">El per&amp;iacute;odo '.' coincide con cualquier car&amp;aacute;cter excepto &quot;\ n&quot; (a menos que el modificador &lt;code&gt;//s&lt;/code&gt; est&amp;eacute; en efecto, como se explica a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="bc11993ee6fae379fe2dbc40f494f74a38651177" translate="yes" xml:space="preserve">
          <source>The period &lt;code&gt;'.'&lt;/code&gt; matches any character but &lt;code&gt;&quot;\n&quot;&lt;/code&gt; (unless the modifier &lt;code&gt;/s&lt;/code&gt; is in effect, as explained below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="50625043a5bdab5548c251e25233bc0e03a34159" translate="yes" xml:space="preserve">
          <source>The perl code in PerlIO.pm then attempts to locate a layer by doing</source>
          <target state="translated">El código perl en PerlIO.pm entonces intenta localizar una capa haciendo</target>
        </trans-unit>
        <trans-unit id="634e60cc8e248b9b7ce51ac444bfec05dc82ef31" translate="yes" xml:space="preserve">
          <source>The perl command to use is determined by &lt;a href=&quot;#get_perl&quot;&gt;&quot;get_perl&quot;&lt;/a&gt;. The command generated is guaranteed to preserve:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16b7e5af7739f86fd0e9e79d11ca97ac5649e9b1" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . The basic rule of perl exceptions is that &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (in the absence of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , while &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; within &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</source>
          <target state="translated">El n&amp;uacute;cleo de perl envuelve &lt;code&gt;setjmp()&lt;/code&gt; etc. en las macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; y &lt;code&gt;JMPENV_JUMP&lt;/code&gt; . La regla b&amp;aacute;sica de las excepciones de perl es que &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; (en ausencia de &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ) realizan un &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt; , mientras que &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; dentro de &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; hace un &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d6c71858536e734e97d2970ba2f758d971d8a580" translate="yes" xml:space="preserve">
          <source>The perl core wraps &lt;code&gt;setjmp()&lt;/code&gt; etc in the macros &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and &lt;code&gt;JMPENV_JUMP&lt;/code&gt;. The basic rule of perl exceptions is that &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;die&lt;/code&gt; (in the absence of &lt;code&gt;eval&lt;/code&gt;) perform a &lt;code&gt;JMPENV_JUMP(2)&lt;/code&gt;, while &lt;code&gt;die&lt;/code&gt; within &lt;code&gt;eval&lt;/code&gt; does a &lt;code&gt;JMPENV_JUMP(3)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fdbc7e5dc74277662b153d8f95c93e631321b8b" translate="yes" xml:space="preserve">
          <source>The perl equivalent is &lt;code&gt;$sv = undef;&lt;/code&gt;. Note that it doesn't free any string buffer, unlike &lt;code&gt;undef $sv&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c474186075797ee40452934f04a51f573b827bb" translate="yes" xml:space="preserve">
          <source>The perl executable is obtained by linking</source>
          <target state="translated">El ejecutable de perl se obtiene vinculando</target>
        </trans-unit>
        <trans-unit id="1d8ff0cddfb59dc7ae9ad6feb4a5e65da142f6d6" translate="yes" xml:space="preserve">
          <source>The perl history contains one mistake which was not caught in the conversion: a merge was recorded in the history between blead and maint-5.10 where no merge actually occurred. Due to the nature of git, this is now impossible to fix in the public repository. You can remove this mis-merge locally by adding the following line to your &lt;code&gt;.git/info/grafts&lt;/code&gt; file:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06ded168a76972d517d9136275d2690412f2929f" translate="yes" xml:space="preserve">
          <source>The perl message comes out with &quot;Perl&quot; in front. The &lt;code&gt;BEGIN&lt;/code&gt; block works at compile time so all of the compilation errors and warnings get the &quot;Perl:&quot; prefix too.</source>
          <target state="translated">El mensaje de perl aparece con &quot;Perl&quot; al frente. El bloque &lt;code&gt;BEGIN&lt;/code&gt; funciona en tiempo de compilaci&amp;oacute;n, por lo que todos los errores y advertencias de compilaci&amp;oacute;n tambi&amp;eacute;n reciben el prefijo &quot;Perl:&quot;.</target>
        </trans-unit>
        <trans-unit id="b63df2b573a7b7008051f6d3411e1d7de7dd31b6" translate="yes" xml:space="preserve">
          <source>The perl source is in a git repository. You can clone the repository with the following command:</source>
          <target state="translated">La fuente de perl está en un depósito de git.Puedes clonar el repositorio con el siguiente comando:</target>
        </trans-unit>
        <trans-unit id="c5f10541bc3ed7ff03899b584c515233e642fba7" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;&quot;Calling Perl Routines from within C Programs&quot;&lt;/a&gt; for details on how to do this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="327d340c9d37adf78ea3fa44d3b1c6e9e8b77c71" translate="yes" xml:space="preserve">
          <source>The perl tie function associates a variable with an object that implements the various GET, SET, etc methods. To perform the equivalent of the perl tie function from an XSUB, you must mimic this behaviour. The code below carries out the necessary steps -- firstly it creates a new hash, and then creates a second hash which it blesses into the class which will implement the tie methods. Lastly it ties the two hashes together, and returns a reference to the new tied hash. Note that the code below does NOT call the TIEHASH method in the MyTie class - see &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Calling Perl Routines from within C Programs&lt;/a&gt; for details on how to do this.</source>
          <target state="translated">La funci&amp;oacute;n perl tie asocia una variable con un objeto que implementa los diversos m&amp;eacute;todos GET, SET, etc. Para realizar el equivalente de la funci&amp;oacute;n perl tie de un XSUB, debe imitar este comportamiento. El siguiente c&amp;oacute;digo lleva a cabo los pasos necesarios: en primer lugar, crea un nuevo hash y luego crea un segundo hash que bendice en la clase que implementar&amp;aacute; los m&amp;eacute;todos de enlace. Por &amp;uacute;ltimo, une los dos hash y devuelve una referencia al nuevo hash vinculado. Tenga en cuenta que el c&amp;oacute;digo siguiente NO llama al m&amp;eacute;todo TIEHASH en la clase MyTie; consulte &lt;a href=&quot;#Calling-Perl-Routines-from-within-C-Programs&quot;&gt;Llamar rutinas de Perl desde los programas C&lt;/a&gt; para obtener detalles sobre c&amp;oacute;mo hacer esto.</target>
        </trans-unit>
        <trans-unit id="123c31a7a632081aa07f5ab58c14ca27dc4643f2" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt; .</source>
          <target state="translated">El nombre visible de Perl de la subrutina XS generada que devolver&amp;aacute; las constantes. El valor predeterminado es &lt;code&gt;constant&lt;/code&gt; e .</target>
        </trans-unit>
        <trans-unit id="be6633f7068d6499b516b1dff2ff6cfb89ba5f0c" translate="yes" xml:space="preserve">
          <source>The perl visible name of the XS subroutine generated which will return the constants. The default is &lt;code&gt;constant&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="87baa838c319b67b0a259076dbfb27270de34c58" translate="yes" xml:space="preserve">
          <source>The perl-mvs@perl.org list is for discussion of porting issues as well as general usage issues for all EBCDIC Perls. Send a message body of &quot;subscribe perl-mvs&quot; to majordomo@perl.org.</source>
          <target state="translated">La lista perl-mvs@perl.org es para la discusión de cuestiones de portabilidad,así como cuestiones de uso general para todos los Perls del EBCDIC.Envía un cuerpo de mensaje de &quot;subscribe perl-mvs&quot; a majordomo@perl.org.</target>
        </trans-unit>
        <trans-unit id="5ba3dea55a126a532be4f9eaeca0422de96d0827" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="translated">La lista de correo de perl5-changes recibe una copia de cada parche que se env&amp;iacute;a a las ramas de mantenimiento y desarrollo del repositorio de perl. Consulte &lt;a href=&quot;http://lists.perl.org/list/perl5-changes.html&quot;&gt;http://lists.perl.org/list/perl5-changes.html&lt;/a&gt; para obtener informaci&amp;oacute;n sobre suscripciones y archivos.</target>
        </trans-unit>
        <trans-unit id="7ba06e1bf85435dc89a1bc7a3e1228003027ef95" translate="yes" xml:space="preserve">
          <source>The perl5-changes mailing list receives a copy of each patch that gets submitted to the maintenance and development branches of the perl repository. See &lt;a href=&quot;https://lists.perl.org/list/perl5-changes.html&quot;&gt;https://lists.perl.org/list/perl5-changes.html&lt;/a&gt; for subscription and archive information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c029dc7e52d0d0d6369cc3ff0e62686a113c165" translate="yes" xml:space="preserve">
          <source>The perl5-porters (p5p) mailing list is where the Perl standard distribution is maintained and developed. The people who maintain Perl are also referred to as the &quot;Perl 5 Porters&quot;, &quot;p5p&quot; or just the &quot;porters&quot;.</source>
          <target state="translated">La lista de correo de perl5-porters (p5p)es donde se mantiene y desarrolla la distribución estándar de Perl.Las personas que mantienen Perl también se denominan &quot;portadores de Perl 5&quot;,&quot;p5p&quot; o simplemente &quot;portadores&quot;.</target>
        </trans-unit>
        <trans-unit id="3a8b72ced5fe1018b53d36c163e0f112a1621d18" translate="yes" xml:space="preserve">
          <source>The perlXYZ.sis includes only the Perl DLL: to create an additional SIS file which includes some of the standard (pure) Perl libraries, issue the command</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8239507ba48e88fe2cac6b5f08faa6b68602a3e2" translate="yes" xml:space="preserve">
          <source>The perlapp.sis (11 kB -&amp;gt; 16 kB) will be built in the symbian subdirectory, but a copy will also be made to the main directory.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55339a112f571a65cc173aaae9b60118d4926fb7" translate="yes" xml:space="preserve">
          <source>The perlbug program will ask you a few questions about your email address and the patch you're submitting. Once you've answered them it will submit your patch via email.</source>
          <target state="translated">El programa Perlbug te hará algunas preguntas sobre tu dirección de correo electrónico y el parche que estás enviando.Una vez que las hayas contestado,te enviará el parche por correo electrónico.</target>
        </trans-unit>
        <trans-unit id="a319a07f2540ad16252f1fe55565bcf46c56c4bb" translate="yes" xml:space="preserve">
          <source>The perldoc for utime also has an example that has the same effect as touch(1) on files that</source>
          <target state="translated">El perldoc para utime también tiene un ejemplo que tiene el mismo efecto que touch(1)en los archivos que</target>
        </trans-unit>
        <trans-unit id="ed575d398752b423e73c91acec2e13e6122dc7e1" translate="yes" xml:space="preserve">
          <source>The perlfaq comprises several documents that answer the most commonly asked questions about Perl and Perl programming. It's divided by topic into nine major sections outlined in this document.</source>
          <target state="translated">El perlfaq comprende varios documentos que responden a las preguntas más frecuentes sobre el Perl y la programación del Perl.Está dividido por temas en nueve secciones principales que se describen en este documento.</target>
        </trans-unit>
        <trans-unit id="bf571460e6819407bba20acb1eb1771f32d393cd" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="translated">El perlfaq es un documento en evoluci&amp;oacute;n. Lea la &amp;uacute;ltima versi&amp;oacute;n en &lt;a href=&quot;http://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt; . Tambi&amp;eacute;n se incluye en la distribuci&amp;oacute;n est&amp;aacute;ndar de Perl.</target>
        </trans-unit>
        <trans-unit id="f61ce2c3cec8ab2b0fa16fba7a8409cd6e94fd03" translate="yes" xml:space="preserve">
          <source>The perlfaq is an evolving document. Read the latest version at &lt;a href=&quot;https://learn.perl.org/faq/&quot;&gt;http://learn.perl.org/faq/&lt;/a&gt;. It is also included in the standard Perl distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d8ba3c9bbcf37ca492d8ac656f9c49509454f36e" translate="yes" xml:space="preserve">
          <source>The perlpod spec for a Verbatim paragraph is &quot;It should be reproduced exactly...&quot;, which means that the whitespace you've used to indent your verbatim blocks will be preserved in the output. This can be annoying for outputs such as HTML, where that whitespace will remain in front of every line. It's an unfortunate case where syntax is turned into semantics.</source>
          <target state="translated">La especificación del perlpod para un párrafo literal es &quot;Debe ser reproducido exactamente...&quot;,lo que significa que el espacio en blanco que ha utilizado para sangrar sus bloques literales se conservará en la salida.Esto puede ser molesto para salidas como HTML,donde ese espacio en blanco permanecerá delante de cada línea.Es un caso desafortunado en el que la sintaxis se convierte en semántica.</target>
        </trans-unit>
        <trans-unit id="d320cdc510ba6fe180a797e4852d051df0ce9e8c" translate="yes" xml:space="preserve">
          <source>The perlstyle manual supplied with Perl has many helpful points.</source>
          <target state="translated">El manual de Perlstyle suministrado con Perl tiene muchos puntos de ayuda.</target>
        </trans-unit>
        <trans-unit id="f61630dfa6a2b75f5a9ee952e22583e2bdae4aef" translate="yes" xml:space="preserve">
          <source>The person whom the &lt;b&gt;operating system&lt;/b&gt; will let do almost anything. Typically your system administrator or someone pretending to be your system administrator. On Unix systems, the &lt;b&gt;root&lt;/b&gt; user. On Windows systems, usually the Administrator user.</source>
          <target state="translated">La persona a la que el &lt;b&gt;sistema operativo&lt;/b&gt; le permitir&amp;aacute; hacer casi cualquier cosa. Normalmente, el administrador del sistema o alguien que pretende ser el administrador del sistema. En sistemas Unix, el usuario &lt;b&gt;root&lt;/b&gt; . En sistemas Windows, normalmente el usuario administrador.</target>
        </trans-unit>
        <trans-unit id="4a687dacf6873e351f87d30c48226233e28a0761" translate="yes" xml:space="preserve">
          <source>The pinyin ordering includes some characters that are not CJK Unified Ideographs and can't utilize &lt;code&gt;weightPinyin()&lt;/code&gt; for collation. For them, use &lt;code&gt;entry&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="674e8f557a9263711bdd1bff3bb098f69b9e9b84" translate="yes" xml:space="preserve">
          <source>The pipeline model divides up a task into a series of steps, and passes the results of one step on to the thread processing the next. Each thread does one thing to each piece of data and passes the results to the next thread in line.</source>
          <target state="translated">El modelo de tubería divide una tarea en una serie de pasos,y pasa los resultados de un paso al hilo que procesa el siguiente.Cada hilo hace una cosa con cada dato y pasa los resultados al siguiente hilo en línea.</target>
        </trans-unit>
        <trans-unit id="e5963c8e8de82f4449d7ed9e1e51afdf5f459ee1" translate="yes" xml:space="preserve">
          <source>The pl2pm utility will get you started.</source>
          <target state="translated">La utilidad pl2pm te hará empezar.</target>
        </trans-unit>
        <trans-unit id="1d36c8a340c756f47102c1832b54cb16f13c0c7c" translate="yes" xml:space="preserve">
          <source>The plan (for example, '1..5'), must only come at the beginning or end of the TAP output.</source>
          <target state="translated">El plan (por ejemplo,'1..5'),sólo debe venir al principio o al final de la salida del TAP.</target>
        </trans-unit>
        <trans-unit id="b8f929ee511ca422d9eb63d2f4f5d86c27217779" translate="yes" xml:space="preserve">
          <source>The plan event for the subtest</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4326b3bc4ca816f9708e08eacb7250e5b64a4e86" translate="yes" xml:space="preserve">
          <source>The plugin system in the CPAN shell was introduced in version 2.07 and is still considered experimental.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b09a69221209bb270cc3034edeb1fb83d92c2242" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; function so that &lt;a href=&quot;#rand-EXPR&quot;&gt;&lt;code&gt;rand&lt;/code&gt;&lt;/a&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;a href=&quot;#srand-EXPR&quot;&gt;&lt;code&gt;srand&lt;/code&gt;&lt;/a&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fc2d017a3ab4b5deac17556464426823c475059" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">El objetivo de la funci&amp;oacute;n es &quot;sembrar&quot; la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; para que &lt;code&gt;&lt;a href=&quot;functions/rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; pueda producir una secuencia diferente cada vez que ejecute su programa. Cuando se llama con un par&amp;aacute;metro, &lt;code&gt;&lt;a href=&quot;functions/srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; lo usa para la semilla; de lo contrario, elige (semi) aleatoriamente una semilla. En cualquier caso, a partir de Perl 5.14, devuelve la semilla. Para indicar que su c&amp;oacute;digo funcionar&amp;aacute;</target>
        </trans-unit>
        <trans-unit id="2e1f3e31ba6a1b36a8c681657ab8caf017949b14" translate="yes" xml:space="preserve">
          <source>The point of the function is to &quot;seed&quot; the &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; function so that &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; can produce a different sequence each time you run your program. When called with a parameter, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; uses that for the seed; otherwise it (semi-)randomly chooses a seed. In either case, starting with Perl 5.14, it returns the seed. To signal that your code will work</source>
          <target state="translated">El objetivo de la funci&amp;oacute;n es &quot;sembrar&quot; la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; para que &lt;code&gt;&lt;a href=&quot;rand&quot;&gt;rand&lt;/a&gt;&lt;/code&gt; pueda producir una secuencia diferente cada vez que ejecute su programa. Cuando se llama con un par&amp;aacute;metro, &lt;code&gt;&lt;a href=&quot;srand&quot;&gt;srand&lt;/a&gt;&lt;/code&gt; lo usa para la semilla; de lo contrario, elige (semi) aleatoriamente una semilla. En cualquier caso, a partir de Perl 5.14, devuelve la semilla. Para indicar que su c&amp;oacute;digo funcionar&amp;aacute;</target>
        </trans-unit>
        <trans-unit id="d8e49cca1375307d0cbb7648d543980bc0807cf4" translate="yes" xml:space="preserve">
          <source>The pointer is blessed into a class that is derived from the name of type of the pointer but with all '*' in the name replaced with 'Ptr'.</source>
          <target state="translated">El puntero es bendecido en una clase que se deriva del nombre del tipo del puntero pero con todo &quot;*&quot; en el nombre reemplazado por &quot;Ptr&quot;.</target>
        </trans-unit>
        <trans-unit id="549bcd1d7ae81c0474487c42c591f283db8f5fed" translate="yes" xml:space="preserve">
          <source>The pointer to the PV of the &lt;code&gt;dsv&lt;/code&gt; is returned.</source>
          <target state="translated">Se &lt;code&gt;dsv&lt;/code&gt; el puntero al PV del dsv .</target>
        </trans-unit>
        <trans-unit id="7ab31953e34eba90fc36ab51df0189b64f65aae0" translate="yes" xml:space="preserve">
          <source>The points to note are</source>
          <target state="translated">Los puntos a tener en cuenta son</target>
        </trans-unit>
        <trans-unit id="c1fdc510fd28f743532d0f8810f2c036e2bf9b84" translate="yes" xml:space="preserve">
          <source>The polar notation (also known as the trigonometric representation) is much more handy for performing multiplications and divisions of complex numbers, whilst the cartesian notation is better suited for additions and subtractions. Real numbers are on the</source>
          <target state="translated">La notación polar (también conocida como representación trigonométrica)es mucho más práctica para realizar multiplicaciones y divisiones de números complejos,mientras que la notación cartesiana es más adecuada para sumas y restas.Los números reales están en el</target>
        </trans-unit>
        <trans-unit id="b5ec1158a1165100647b29065f9f5443b0e8eb69" translate="yes" xml:space="preserve">
          <source>The polar style attempts to emphasize arguments like</source>
          <target state="translated">El estilo polar intenta enfatizar argumentos como</target>
        </trans-unit>
        <trans-unit id="69fec36a5f0f42b7b7ddc49268b5d8cea58e3639" translate="yes" xml:space="preserve">
          <source>The popular tool &lt;code&gt;sudo&lt;/code&gt; provides a controlled way for users to be able to run programs as other users. It sanitises the execution environment to some extent, and will avoid the &lt;a href=&quot;#Shebang-Race-Condition&quot;&gt;shebang race condition&lt;/a&gt;. If you don't have the safe version of set-id scripts, then &lt;code&gt;sudo&lt;/code&gt; may be a more convenient way of executing a script as another user than writing a C wrapper would be.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c2c870c4a68cedcedbfdb919f7afe57be993942" translate="yes" xml:space="preserve">
          <source>The port for Win32 was used as a reference.</source>
          <target state="translated">El puerto para Win32 fue usado como referencia.</target>
        </trans-unit>
        <trans-unit id="e9a7460e24d0700d3e12dc5c76ead4d814126aa5" translate="yes" xml:space="preserve">
          <source>The port of Perl to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9181a3290f36ca81b3bb6720fe9893dc45df567f" translate="yes" xml:space="preserve">
          <source>The port of Perl to to Mac OS was officially removed as of Perl 5.12, though the last official production release of MacPerl corresponded to Perl 5.6. While Perl 5.10 included the port to Mac OS, ExtUtils::MakeMaker, a core part of Perl's module installation infrastructure officially dropped support for Mac OS in April 2004.</source>
          <target state="translated">El puerto de Perl a Mac OS fue oficialmente eliminado a partir de Perl 5.12,aunque el último lanzamiento oficial de producción de MacPerl correspondió a Perl 5.6.Mientras que Perl 5.10 incluía el puerto a Mac OS,ExtUtils::MakeMaker,una parte esencial de la infraestructura de instalación de módulos de Perl,dejó oficialmente de soportar Mac OS en abril de 2004.</target>
        </trans-unit>
        <trans-unit id="f4180538d74696f5817f3f6feca9a1c65e2c02f2" translate="yes" xml:space="preserve">
          <source>The porters appreciate the time you spent helping to make Perl better. Thank you!</source>
          <target state="translated">Los porteadores aprecian el tiempo que pasaste ayudando a mejorar a Perl.¡Gracias!</target>
        </trans-unit>
        <trans-unit id="54bd391c46a02c41cb9ecadecb266d6444c3a53a" translate="yes" xml:space="preserve">
          <source>The portion of the extension provided by the XS code may be connected to the rest of Perl in either of two ways. In the &lt;b&gt;static&lt;/b&gt; configuration, the object code for the extension is linked directly into</source>
          <target state="translated">La parte de la extensi&amp;oacute;n proporcionada por el c&amp;oacute;digo XS puede conectarse con el resto de Perl de dos formas. En la configuraci&amp;oacute;n &lt;b&gt;est&amp;aacute;tica&lt;/b&gt; , el c&amp;oacute;digo de objeto para la extensi&amp;oacute;n est&amp;aacute; vinculado directamente a</target>
        </trans-unit>
        <trans-unit id="2605e3cd341c048b0037bbd123fa8ea2ca949be7" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2CPOSITION%2CWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c71fa06187e2cb76d45cf6769bdd2d2cbe65fe5" translate="yes" xml:space="preserve">
          <source>The position in the file of FILEHANDLE is left unchanged. You may want to call &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; before writing to the file.</source>
          <target state="translated">La posici&amp;oacute;n en el archivo de FILEHANDLE no se modifica. Es posible que desee llamar a &lt;a href=&quot;#seek-FILEHANDLE%2cPOSITION%2cWHENCE&quot;&gt;seek&lt;/a&gt; antes de escribir en el archivo.</target>
        </trans-unit>
        <trans-unit id="efdfff91986b015ed9943f5eed1ac7ffd6711ca2" translate="yes" xml:space="preserve">
          <source>The possessive forms (new in Perl 5.10) prevent backtracking: what gets matched by a pattern with a possessive quantifier will not be backtracked into, even if that causes the whole match to fail.</source>
          <target state="translated">Las formas posesivas (nuevas en Perl 5.10)impiden el retroceso:lo que se empareja con un patrón con un cuantificador posesivo no será retrocedido,incluso si eso causa que todo el emparejamiento falle.</target>
        </trans-unit>
        <trans-unit id="5eab19b8b748f65afb0049c25c884441fbae1bc8" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="translated">Las posibles categor&amp;iacute;as son: &lt;code&gt;:collate&lt;/code&gt; , &lt;code&gt;:ctype&lt;/code&gt; , &lt;code&gt;:messages&lt;/code&gt; , &lt;code&gt;:monetary&lt;/code&gt; , &lt;code&gt;:numeric&lt;/code&gt; , &lt;code&gt;:&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , y la categor&amp;iacute;a de pseudo &lt;code&gt;:characters&lt;/code&gt; (descritos a continuaci&amp;oacute;n).</target>
        </trans-unit>
        <trans-unit id="b9cec0c735ea3bb0489e4ea0d12dfd9112e5e476" translate="yes" xml:space="preserve">
          <source>The possible categories are: &lt;code&gt;:collate&lt;/code&gt;, &lt;code&gt;:ctype&lt;/code&gt;, &lt;code&gt;:messages&lt;/code&gt;, &lt;code&gt;:monetary&lt;/code&gt;, &lt;code&gt;:numeric&lt;/code&gt;, &lt;code&gt;:time&lt;/code&gt;, and the pseudo category &lt;code&gt;:characters&lt;/code&gt; (described below).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="00fdb180b333447352b78de9f2313423642a41c9" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;a href=&quot;fcntl&quot;&gt;&lt;code&gt;Fcntl&lt;/code&gt;&lt;/a&gt;. See the documentation of your operating system's &lt;a href=&quot;http://man.he.net/man2/open&quot;&gt;open(2)&lt;/a&gt; syscall to see which values and flag bits are available. You may combine several flags using the &lt;code&gt;|&lt;/code&gt;-operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6655e8efe41a46d2438d144ed4d6129c437e80b" translate="yes" xml:space="preserve">
          <source>The possible values and flag bits of the MODE parameter are system-dependent; they are available via the standard module &lt;code&gt;Fcntl&lt;/code&gt; . See the documentation of your operating system's</source>
          <target state="translated">Los valores posibles y los bits de bandera del par&amp;aacute;metro MODE dependen del sistema; est&amp;aacute;n disponibles a trav&amp;eacute;s del m&amp;oacute;dulo est&amp;aacute;ndar &lt;code&gt;Fcntl&lt;/code&gt; . Consulte la documentaci&amp;oacute;n de su sistema operativo</target>
        </trans-unit>
        <trans-unit id="f5b739ecc638266d58487c7c88c27f4bcc3311ca" translate="yes" xml:space="preserve">
          <source>The possibly inferred link-text; i.e., if there was no real link text, then this is the text that we'll infer in its place. (E.g., for &quot;L&amp;lt;Getopt::Std&amp;gt;&quot;, the inferred link text is &quot;Getopt::Std&quot;.)</source>
          <target state="translated">El texto del enlace posiblemente inferido; es decir, si no hab&amp;iacute;a un texto de enlace real, entonces este es el texto que deduciremos en su lugar. (Por ejemplo, para &quot;L &amp;lt;Getopt :: Std&amp;gt;&quot;, el texto del enlace inferido es &quot;Getopt :: Std&quot;).</target>
        </trans-unit>
        <trans-unit id="4e5ec7c69ae0bd18f551874e75cc4c912902b3a0" translate="yes" xml:space="preserve">
          <source>The practice of saying, &amp;ldquo;If I had to do it all over, I&amp;rsquo;d do it differently,&amp;rdquo; and then actually going back and doing it all over differently. Mathematically speaking, it&amp;rsquo;s returning from an unsuccessful recursion on a tree of possibilities. Perl backtracks when it attempts to match patterns with a &lt;b&gt;regular expression&lt;/b&gt;, and its earlier attempts don&amp;rsquo;t pan out. See the section &amp;ldquo;The Little Engine That /Couldn(n&amp;rsquo;t)&amp;rdquo; in Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo;.</source>
          <target state="translated">La pr&amp;aacute;ctica de decir: &quot;Si tuviera que hacerlo todo de nuevo, lo har&amp;iacute;a de manera diferente&quot;, y luego volver atr&amp;aacute;s y hacerlo todo de manera diferente. Matem&amp;aacute;ticamente hablando, est&amp;aacute; regresando de una recursi&amp;oacute;n fallida en un &amp;aacute;rbol de posibilidades. Perl retrocede cuando intenta hacer coincidir patrones con una &lt;b&gt;expresi&amp;oacute;n regular&lt;/b&gt; , y sus intentos anteriores no dan resultado. Consulte la secci&amp;oacute;n &amp;ldquo;La peque&amp;ntilde;a locomotora que / no pudo&amp;rdquo; en el cap&amp;iacute;tulo 5 de Camel, &amp;ldquo;Coincidencia de patrones&amp;rdquo;.</target>
        </trans-unit>
        <trans-unit id="03599d25f97c0e2d0192955c405d8519204aa81e" translate="yes" xml:space="preserve">
          <source>The practice of shifting an alphabet one or more characters for encipherment dates back thousands of years and was explicitly detailed by Gaius Julius Caesar in his &lt;b&gt;Gallic Wars&lt;/b&gt; text. A single alphabet shift is sometimes referred to as a rotation and the shift amount is given as a number $n after the string 'rot' or &quot;rot$n&quot;. Rot0 and rot26 would designate identity maps on the 26-letter English version of the Latin alphabet. Rot13 has the interesting property that alternate subsequent invocations are identity maps (thus rot13 is its own non-trivial inverse in the group of 26 alphabet rotations). Hence the following is a rot13 encoder and decoder that will work on ASCII and EBCDIC platforms:</source>
          <target state="translated">La pr&amp;aacute;ctica de cambiar uno o m&amp;aacute;s caracteres de un alfabeto para su cifrado se remonta a miles de a&amp;ntilde;os y fue expl&amp;iacute;citamente detallada por Gaius Julius Caesar en su texto de las &lt;b&gt;Guerras Galias&lt;/b&gt; . Un solo cambio de alfabeto a veces se denomina rotaci&amp;oacute;n y la cantidad de cambio se da como un n&amp;uacute;mero $ n despu&amp;eacute;s de la cadena 'rot' o &quot;rot $ n&quot;. Rot0 y rot26 designar&amp;iacute;an mapas de identidad en la versi&amp;oacute;n en ingl&amp;eacute;s de 26 letras del alfabeto latino. Rot13 tiene la propiedad interesante de que las invocaciones posteriores alternas son mapas de identidad (por lo tanto, rot13 es su propia inversa no trivial en el grupo de 26 rotaciones alfab&amp;eacute;ticas). Por lo tanto, el siguiente es un codificador y decodificador rot13 que funcionar&amp;aacute; en plataformas ASCII y EBCDIC:</target>
        </trans-unit>
        <trans-unit id="a4931fe0eefec05b185de502969d863746246773" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="translated">El pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; hace &lt;code&gt;$?&lt;/code&gt; reflejan el estado de salida real de VMS en lugar de la emulaci&amp;oacute;n predeterminada del estado POSIX descrita anteriormente. Este pragma tambi&amp;eacute;n deshabilita la conversi&amp;oacute;n de valores distintos de cero a SS $ _ABORT al configurar &lt;code&gt;$?&lt;/code&gt; en un bloque END (pero cero todav&amp;iacute;a se convertir&amp;aacute; a SS $ _NORMAL).</target>
        </trans-unit>
        <trans-unit id="91d3ea3fbae8cd7072d27f773df4ade3db8e3a56" translate="yes" xml:space="preserve">
          <source>The pragma &lt;code&gt;use vmsish 'status'&lt;/code&gt; makes &lt;code&gt;$?&lt;/code&gt; reflect the actual VMS exit status instead of the default emulation of POSIX status described above. This pragma also disables the conversion of non-zero values to SS$_ABORT when setting &lt;code&gt;$?&lt;/code&gt; in an END block (but zero will still be converted to SS$_NORMAL).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36ba59d998f30d35a2800e28be03d01cb711ce6c" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; pragma was supported and &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="translated">El pragma era un l&amp;eacute;xico por script, no por bloque. Solo importaba el &amp;uacute;ltimo &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; , y afect&amp;oacute; a &lt;b&gt;todo el script&lt;/b&gt; . Sin embargo, el pragma &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; encoding&lt;/code&gt; era compatible y la &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; encoding&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; pod&amp;iacute;a aparecer tantas veces como desee en un script determinado (aunque solo el &amp;uacute;ltimo fue efectivo).</target>
        </trans-unit>
        <trans-unit id="9e7b1da1b87c8f47d3de1bab74d0b204e260e393" translate="yes" xml:space="preserve">
          <source>The pragma was a per script, not a per block lexical. Only the last &lt;code&gt;use encoding&lt;/code&gt; or &lt;code&gt;no encoding&lt;/code&gt; mattered, and it affected &lt;b&gt;the whole script&lt;/b&gt;. However, the &lt;code&gt;no encoding&lt;/code&gt; pragma was supported and &lt;code&gt;use encoding&lt;/code&gt; could appear as many times as you want in a given script (though only the last was effective).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f8b4d970b42fbff322fe3d169272f393cc128f89" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="translated">Los pragmas &lt;a href=&quot;../bignum&quot;&gt;bignum&lt;/a&gt; , &lt;a href=&quot;../bigint&quot;&gt;bigint&lt;/a&gt; y &lt;a href=&quot;../bigrat&quot;&gt;bigrat&lt;/a&gt; tambi&amp;eacute;n pueden ser de inter&amp;eacute;s porque resuelven el problema de la actualizaci&amp;oacute;n autom&amp;aacute;tica / degradaci&amp;oacute;n, al menos en parte.</target>
        </trans-unit>
        <trans-unit id="76569ddba56c9f99056592d21ac1b2ff490f26ec" translate="yes" xml:space="preserve">
          <source>The pragmas &lt;a href=&quot;bignum&quot;&gt;bignum&lt;/a&gt;, &lt;a href=&quot;bigint&quot;&gt;bigint&lt;/a&gt; and &lt;a href=&quot;bigrat&quot;&gt;bigrat&lt;/a&gt; also might be of interest because they solve the autoupgrading/downgrading issue, at least partly.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="984c1d7b1bad11977f9a25ba621b51c787c8e6c4" translate="yes" xml:space="preserve">
          <source>The preamble added to each output file is rather verbose, and most of it is only necessary in the presence of non-ASCII characters. It would ideally be nice if all of those definitions were only output if needed, perhaps on the fly as the characters are used.</source>
          <target state="translated">El preámbulo que se añade a cada archivo de salida es bastante verborreico,y la mayor parte de él sólo es necesario en presencia de caracteres no ASCII.Lo ideal sería que todas esas definiciones sólo se dieran a conocer si se necesitan,quizás sobre la marcha,a medida que se utilizan los caracteres.</target>
        </trans-unit>
        <trans-unit id="45357f49e477501b84ee9e2077b2244c8a2bb54d" translate="yes" xml:space="preserve">
          <source>The preamble code for the class is as follows:</source>
          <target state="translated">El código del preámbulo de la clase es el siguiente:</target>
        </trans-unit>
        <trans-unit id="b4c4542a57f99c1f10f3ac073718f1821e067ea0" translate="yes" xml:space="preserve">
          <source>The preference of the &lt;b&gt;regular expression&lt;/b&gt; engine to match the leftmost occurrence of a &lt;b&gt;pattern&lt;/b&gt;, then given a position at which a match will occur, the preference for the longest match (presuming the use of a &lt;b&gt;greedy&lt;/b&gt; quantifier). See Camel chapter 5, &amp;ldquo;Pattern Matching&amp;rdquo; for</source>
          <target state="translated">La preferencia del motor de &lt;b&gt;expresi&amp;oacute;n regular&lt;/b&gt; para coincidir con la ocurrencia m&amp;aacute;s a la izquierda de un &lt;b&gt;patr&amp;oacute;n&lt;/b&gt; , luego dada una posici&amp;oacute;n en la que ocurrir&amp;aacute; una coincidencia, la preferencia por la coincidencia m&amp;aacute;s larga (suponiendo el uso de un cuantificador &lt;b&gt;codicioso&lt;/b&gt; ). Consulte el cap&amp;iacute;tulo 5 de Camel, &quot;Coincidencia de patrones&quot; para</target>
        </trans-unit>
        <trans-unit id="fb28a274f1049ea39bf5f7992f63f38b064b26ab" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</source>
          <target state="translated">La forma preferida de hacer esto es declarar un plan cuando &lt;code&gt;&lt;a href=&quot;../functions/use&quot;&gt;use&lt;/a&gt; Test::More&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5006ab06a26ab8e5eca93c03d0291151f3f3136d" translate="yes" xml:space="preserve">
          <source>The preferred way to do this is to declare a plan when you &lt;code&gt;use Test::More&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a070b02ec3ff7789ebf48e13bc147cc73129be84" translate="yes" xml:space="preserve">
          <source>The prefix specified by &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; will be used with a numeric suffix if the name for a value is undefined.</source>
          <target state="translated">El prefijo especificado por &lt;code&gt;$Data::Dumper::Varname&lt;/code&gt; se usar&amp;aacute; con un sufijo num&amp;eacute;rico si el nombre de un valor no est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="47b994ba12e424b0e632ed96c89a1498fbc470f8" translate="yes" xml:space="preserve">
          <source>The presence of the word &quot;FATAL&quot; in the category list will escalate warnings in those categories into fatal errors in that lexical scope.</source>
          <target state="translated">La presencia de la palabra &quot;FATAL&quot; en la lista de categorías hará que las advertencias en esas categorías se conviertan en errores fatales en ese ámbito léxico.</target>
        </trans-unit>
        <trans-unit id="7069f5b0b1dc1568e108cd084477a400c3f8668e" translate="yes" xml:space="preserve">
          <source>The previous assignments are exactly equivalent to</source>
          <target state="translated">Las asignaciones anteriores son exactamente equivalentes a</target>
        </trans-unit>
        <trans-unit id="131e26e34a6a280e8d155fa06c2fe106438c82bd" translate="yes" xml:space="preserve">
          <source>The previous behavior of putting the errors (converted to POSIX-style &lt;code&gt;E*&lt;/code&gt; error codes since Perl 5.20.0) into &lt;code&gt;$!&lt;/code&gt; was buggy due to the non-equivalence of like-named Winsock and POSIX error constants, a relationship between which has unfortunately been established in one way or another since Perl 5.8.0.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d4bba88bb17e91a3967206974b895243970981e" translate="yes" xml:space="preserve">
          <source>The previous example was not particularly useful. To make it more general purpose we will make use of the context data and allow any arbitrary</source>
          <target state="translated">El ejemplo anterior no fue particularmente útil.Para hacerlo más general haremos uso de los datos de contexto y permitiremos que cualquier</target>
        </trans-unit>
        <trans-unit id="e9b3a0712244fd40d4ef0fb4f6b05e3de06f443f" translate="yes" xml:space="preserve">
          <source>The previous paragraph is applicable verbatim to tied hash access using the &lt;code&gt;hv_store&lt;/code&gt; and &lt;code&gt;hv_store_ent&lt;/code&gt; functions as well.</source>
          <target state="translated">El p&amp;aacute;rrafo anterior se aplica literalmente al acceso hash vinculado mediante las funciones &lt;code&gt;hv_store&lt;/code&gt; y &lt;code&gt;hv_store_ent&lt;/code&gt; tambi&amp;eacute;n.</target>
        </trans-unit>
        <trans-unit id="dd2b650563ddd2d2b6e29ef9f64d0b20b2f5e086" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any text. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="translated">La secci&amp;oacute;n anterior (introducida por un comando &lt;code&gt;=head&lt;/code&gt; ) no contiene ning&amp;uacute;n texto. Esto suele indicar que falta algo. Nota: A &lt;code&gt;=head1&lt;/code&gt; seguido inmediatamente por &lt;code&gt;=head2&lt;/code&gt; no activa esta advertencia.</target>
        </trans-unit>
        <trans-unit id="b2d4d760a41ac2c4684274cd24041bdb5438342a" translate="yes" xml:space="preserve">
          <source>The previous section (introduced by a &lt;code&gt;=head&lt;/code&gt; command) does not contain any valid content. This usually indicates that something is missing. Note: A &lt;code&gt;=head1&lt;/code&gt; followed immediately by &lt;code&gt;=head2&lt;/code&gt; does not trigger this warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="186c5466a670230e882670fbcd9b5aa0c0353eb4" translate="yes" xml:space="preserve">
          <source>The previous step created</source>
          <target state="translated">El paso anterior creó</target>
        </trans-unit>
        <trans-unit id="d900c388659851ed663901ca396af85f982c5cba" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;&quot;LD_LIBRARY_PATH&quot;&lt;/a&gt; above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="340b1d36d10dcf0bc3c98148a5a96864b33866c8" translate="yes" xml:space="preserve">
          <source>The primary cause of the 'dlopen: stub interception failed' message is that the LD_LIBRARY_PATH environment variable includes a directory which is a symlink to /usr/lib (such as /lib). See &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; above.</source>
          <target state="translated">La causa principal del mensaje 'dlopen: error en la intercepci&amp;oacute;n de c&amp;oacute;digo auxiliar' es que la variable de entorno LD_LIBRARY_PATH incluye un directorio que es un enlace simb&amp;oacute;lico a / usr / lib (como / lib). Consulte &lt;a href=&quot;#LD_LIBRARY_PATH&quot;&gt;LD_LIBRARY_PATH&lt;/a&gt; arriba.</target>
        </trans-unit>
        <trans-unit id="6b0f3d276de0b395d904df1ee65d02fbb91e800c" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; .</source>
          <target state="translated">El prop&amp;oacute;sito principal de este m&amp;oacute;dulo es proporcionar acceso de escritura en tiempo real a archivos zip y b&amp;uacute;feres. No es un archivador de archivos de uso general. Si eso es lo que desea, consulte &lt;code&gt;Archive::Zip&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7109b8aae18759607febf6d98f672f7929c0c0ad" translate="yes" xml:space="preserve">
          <source>The primary purpose of this module is to provide streaming write access to zip files and buffers. It is not a general-purpose file archiver. If that is what you want, check out &lt;code&gt;Archive::Zip&lt;/code&gt; or &lt;code&gt;Archive::Zip::SimpleZip&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3562a709266ee6938735493658a732dcdd3f50d6" translate="yes" xml:space="preserve">
          <source>The primary reference for Zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5865d60bf4675397309adf39254a9c20e60ce62" translate="yes" xml:space="preserve">
          <source>The primary reference for Zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;https://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adaddbe76e40b85855bdb3acd3e478586223f423" translate="yes" xml:space="preserve">
          <source>The primary reference for gzip files is RFC 1952 &lt;a href=&quot;http://www.faqs.org/rfcs/rfc1952.html&quot;&gt;http://www.faqs.org/rfcs/rfc1952.html&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc24d550b4fe8851d0897e687949d42067e8b5a9" translate="yes" xml:space="preserve">
          <source>The primary reference for zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="172150eb79f9c57ed50477a5e17aef4d85de5065" translate="yes" xml:space="preserve">
          <source>The primary reference for zip files is the &quot;appnote&quot; document available at &lt;a href=&quot;https://www.pkware.com/documents/casestudies/APPNOTE.TXT&quot;&gt;http://www.pkware.com/documents/casestudies/APPNOTE.TXT&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1bcb3725358ae123bceedddb8d71ef7119024583" translate="yes" xml:space="preserve">
          <source>The primary site for bzip2 is &lt;a href=&quot;http://www.bzip.org&quot;&gt;http://www.bzip.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d840d1ff084fc0827d16e21e7b3094c84c9a7a3" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is</source>
          <target state="translated">El sitio principal para el gzip es</target>
        </trans-unit>
        <trans-unit id="e859dd2ba7bc9bbaa39a1807494221205b0a4770" translate="yes" xml:space="preserve">
          <source>The primary site for gzip is &lt;a href=&quot;http://www.gzip.org&quot;&gt;http://www.gzip.org&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76b9d6c85592a8675b44ceb172e5fcc460f2a10f" translate="yes" xml:space="preserve">
          <source>The primary site for the</source>
          <target state="translated">El sitio principal de la</target>
        </trans-unit>
        <trans-unit id="dff39311adfb064fbb523d321b7e4b3dbea2499f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is</source>
          <target state="translated">El sitio principal del programa bzip2 es</target>
        </trans-unit>
        <trans-unit id="6d5111f3cd60b1576c60bc8b7e186e70a9cf368f" translate="yes" xml:space="preserve">
          <source>The primary site for the bzip2 program is &lt;a href=&quot;https://sourceware.org/bzip2/&quot;&gt;https://sourceware.org/bzip2/&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20a7ebabe8aa28f193ee803e7dabf5b8ae97c28d" translate="yes" xml:space="preserve">
          <source>The principal value of the arc tangent of y/x</source>
          <target state="translated">El valor principal del arco tangente de y/x</target>
        </trans-unit>
        <trans-unit id="c3a6a975854cac68d0d2fce1f652f0011a15276f" translate="yes" xml:space="preserve">
          <source>The principle is that the number of objects found influences how an item is displayed. If the search finds one item, the result is displayed with the rather verbose method &lt;code&gt;as_string&lt;/code&gt; , but if more than one is found, each object is displayed with the terse method &lt;code&gt;as_glimpse&lt;/code&gt; .</source>
          <target state="translated">El principio es que el n&amp;uacute;mero de objetos encontrados influye en c&amp;oacute;mo se muestra un elemento. Si la b&amp;uacute;squeda encuentra un elemento, el resultado se muestra con el m&amp;eacute;todo m&amp;aacute;s bien detallado &lt;code&gt;as_string&lt;/code&gt; , pero si se encuentra m&amp;aacute;s de uno, cada objeto se muestra con el m&amp;eacute;todo conciso &lt;code&gt;as_glimpse&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="febd9a2b7b0ebfb667a62ab220755a864d89456a" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt; . You can set $OFS and $ORS if you're using the English module.</source>
          <target state="translated">La instrucci&amp;oacute;n print () no agrega separadores de campos y registros a menos que establezca &lt;code&gt;$,&lt;/code&gt; y &lt;code&gt;$\&lt;/code&gt; . Puede configurar $ OFS y $ ORS si est&amp;aacute; utilizando el m&amp;oacute;dulo de ingl&amp;eacute;s.</target>
        </trans-unit>
        <trans-unit id="2da7e391c9fd1ea8ee0cde415f9757d6cf29bace" translate="yes" xml:space="preserve">
          <source>The print() statement does not add field and record separators unless you set &lt;code&gt;$,&lt;/code&gt; and &lt;code&gt;$\&lt;/code&gt;. You can set $OFS and $ORS if you're using the English module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e38b92f2492beff5f39d922c93e2a6ed6bba00e9" translate="yes" xml:space="preserve">
          <source>The private &lt;code&gt;_installed_file_for_module&lt;/code&gt; method may be replaced with other methods for locating a module in &lt;code&gt;@INC&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39cbd438adc424d857eb231b91cd98738e10a91c" translate="yes" xml:space="preserve">
          <source>The private data cache will take ownership of a reference to private_sv, much the same way that &lt;code&gt;hv_store()&lt;/code&gt; takes ownership of a reference to the value that you pass it.</source>
          <target state="translated">La cach&amp;eacute; de datos privados tomar&amp;aacute; posesi&amp;oacute;n de una referencia a private_sv, de la misma manera que &lt;code&gt;hv_store()&lt;/code&gt; toma posesi&amp;oacute;n de una referencia al valor que usted le pasa.</target>
        </trans-unit>
        <trans-unit id="7c29fbafe2b5b36ada501a03eca4a2fd699c674d" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</source>
          <target state="translated">Las claves hash de objetos privados como &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; no se pueden cambiar, pero se pueden agregar claves adicionales, como &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22731711df90de28382d892b4f249e651429dc6f" translate="yes" xml:space="preserve">
          <source>The private object hash keys like &lt;code&gt;$x-&amp;gt;{sign}&lt;/code&gt; may not be changed, but additional keys can be added, like &lt;code&gt;$x-&amp;gt;{_custom}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="660e221c9f99f43f8d3110d11068349758eb697d" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;&quot;RESTORE_LC_NUMERIC&quot;&lt;/a&gt; can restore it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9da35a7db7a9991be43f0a35bab375b2fa2f7661" translate="yes" xml:space="preserve">
          <source>The private variable is used to save the current locale state, so that the requisite matching call to &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; can restore it.</source>
          <target state="translated">La variable privada se usa para guardar el estado de la configuraci&amp;oacute;n regional actual, de modo que la llamada coincidente requerida a &lt;a href=&quot;#RESTORE_LC_NUMERIC&quot;&gt;RESTORE_LC_NUMERIC&lt;/a&gt; pueda restaurarlo.</target>
        </trans-unit>
        <trans-unit id="2ca51914e8f8318dafeffce74323b676d587ba34" translate="yes" xml:space="preserve">
          <source>The private_use feature is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5290ff0dba8c2d4696fae469f418160732641247" translate="yes" xml:space="preserve">
          <source>The problem can be further examined in a roughly equivalent C program:</source>
          <target state="translated">El problema puede examinarse más a fondo en un programa C aproximadamente equivalente:</target>
        </trans-unit>
        <trans-unit id="13328591f6760dcc09259e6c0b9735e71fa4da38" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt; :</source>
          <target state="translated">El problema surge cuando toma sus n&amp;uacute;meros de algo que Perl piensa que es una cadena, como un argumento de l&amp;iacute;nea de comando en &lt;code&gt;@ARGV&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="2c1b07cc8bfa77fdc4b2aa2cb8ca8cba9947e03f" translate="yes" xml:space="preserve">
          <source>The problem comes in when you take your numbers from something that Perl thinks is a string, such as a command line argument in &lt;code&gt;@ARGV&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cd8bb5622c99567256e6a98501e22410a2a7900d" translate="yes" xml:space="preserve">
          <source>The problem comes when you have, for instance, a string that isn't flagged as UTF-8, and contains a byte sequence that could be UTF-8 -- especially when combining non-UTF-8 and UTF-8 strings.</source>
          <target state="translated">El problema viene cuando tienes,por ejemplo,una cadena que no está marcada como UTF-8,y contiene una secuencia de bytes que podría ser UTF-8-especialmente cuando se combinan cadenas que no son UTF-8 y UTF-8.</target>
        </trans-unit>
        <trans-unit id="e918e6ad2cf12f5152c6540799f1ea5ccc7d457e" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; uses &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="translated">El problema existe porque la subrutina an&amp;oacute;nima que se est&amp;aacute; asignando al glob &lt;code&gt;*Foo::foo&lt;/code&gt; aparecer&amp;aacute; en la pila de llamadas como &lt;code&gt;__ANON__&lt;/code&gt; y no &lt;code&gt;foo&lt;/code&gt; como cabr&amp;iacute;a esperar. Dado que &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next::method&lt;/a&gt;&lt;/code&gt; usa &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; para encontrar el nombre del m&amp;eacute;todo en el que fue llamado, fallar&amp;aacute; en este caso.</target>
        </trans-unit>
        <trans-unit id="f6e3278fa9663415debfd4e39d0b068a1659902a" translate="yes" xml:space="preserve">
          <source>The problem exists because the anonymous subroutine being assigned to the &lt;code&gt;*Foo::foo&lt;/code&gt; glob will show up in the call stack as being called &lt;code&gt;__ANON__&lt;/code&gt; and not &lt;code&gt;foo&lt;/code&gt; as you might expect. Since &lt;code&gt;next::method&lt;/code&gt; uses &lt;code&gt;caller&lt;/code&gt; to find the name of the method it was called in, it will fail in this case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aea1a84a6e43b26958b1598b1f93e9a632b83a16" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="translated">El problema aqu&amp;iacute; es que Uid_t podr&amp;iacute;a no solo no ser &lt;code&gt;&lt;a href=&quot;functions/int&quot;&gt;int&lt;/a&gt;&lt;/code&gt; -wide sino que tambi&amp;eacute;n podr&amp;iacute;a no estar firmado, en cuyo caso los uids grandes se imprimir&amp;iacute;an como valores negativos.</target>
        </trans-unit>
        <trans-unit id="27a99efdaf6b6471f2df947f1f817dd0e909810c" translate="yes" xml:space="preserve">
          <source>The problem here is that Uid_t might be not only not &lt;code&gt;int&lt;/code&gt;-wide but it might also be unsigned, in which case large uids would be printed as negative values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="56bc12834cd035d1009997925f3d7abe998a9788" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt; .</source>
          <target state="translated">El problema aqu&amp;iacute; es que tanto el grupo llamado &lt;code&gt;a&lt;/code&gt; como el grupo llamado &lt;code&gt;b&lt;/code&gt; son alias del grupo que pertenece a &lt;code&gt;$1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b18408c3bf47516e5c9af25c6047a1bd86154733" translate="yes" xml:space="preserve">
          <source>The problem here is that both the group named &lt;code&gt;a&lt;/code&gt; and the group named &lt;code&gt;b&lt;/code&gt; are aliases for the group belonging to &lt;code&gt;$1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dda9a4d26fe1b0eb3aeffd7cffb748b622bb8f5f" translate="yes" xml:space="preserve">
          <source>The problem is that Perl has both compile-time and run-time warnings. To disable compile-time warnings you need to rewrite the code like this:</source>
          <target state="translated">El problema es que Perl tiene advertencias tanto en tiempo de compilación como en tiempo de ejecución.Para deshabilitar los avisos en tiempo de compilación necesitas reescribir el código así:</target>
        </trans-unit>
        <trans-unit id="000d776ae8231195ffb025ac77c4f425f1c2ff6f" translate="yes" xml:space="preserve">
          <source>The problem is that both &lt;code&gt;rp&lt;/code&gt; and &lt;code&gt;dp&lt;/code&gt; are pointers to the same location in memory! In C, you'd have to remember to malloc() yourself some new memory. In Perl, you'll want to use the array constructor &lt;code&gt;[]&lt;/code&gt; or the hash constructor &lt;code&gt;{}&lt;/code&gt; instead. Here's the right way to do the preceding broken code fragments:</source>
          <target state="translated">&amp;iexcl;El problema es que tanto &lt;code&gt;rp&lt;/code&gt; como &lt;code&gt;dp&lt;/code&gt; apuntan a la misma ubicaci&amp;oacute;n en la memoria! En C, tendr&amp;iacute;as que acordarte de malloc () t&amp;uacute; mismo alg&amp;uacute;n recuerdo nuevo. En Perl, querr&amp;aacute; usar el constructor de matriz &lt;code&gt;[]&lt;/code&gt; o el constructor hash &lt;code&gt;{}&lt;/code&gt; en su lugar. Esta es la forma correcta de hacer los fragmentos de c&amp;oacute;digo roto anteriores:</target>
        </trans-unit>
        <trans-unit id="44e0ee462b8e8a33d77de1117d49fdbd0c841da5" translate="yes" xml:space="preserve">
          <source>The problem is that grep builds a return list, regardless of the context. This means you're making Perl go to the trouble of building a list that you then just throw away. If the list is large, you waste both time and space. If your intent is to iterate over the list, then use a for loop for this purpose.</source>
          <target state="translated">El problema es que grep construye una lista de retorno,independientemente del contexto.Esto significa que haces que Perl se moleste en construir una lista que luego simplemente tiras.Si la lista es grande,pierdes tanto tiempo como espacio.Si tu intención es iterar sobre la lista,entonces usa un bucle for para este propósito.</target>
        </trans-unit>
        <trans-unit id="6df859dc8cac16c31baff14e80c7d840e1cb3153" translate="yes" xml:space="preserve">
          <source>The problem is that none of these examples are reliable: they depend on the command interpreter. Under Unix, the first two often work. Under DOS, it's entirely possible that neither works. If 4DOS was the command shell, you'd probably have better luck like this:</source>
          <target state="translated">El problema es que ninguno de estos ejemplos es fiable:dependen del intérprete de comandos.Bajo Unix,los dos primeros suelen funcionar.Bajo el DOS,es totalmente posible que ninguno funcione.Si 4DOS fuera el shell de comandos,probablemente tendrías mejor suerte así:</target>
        </trans-unit>
        <trans-unit id="95485cb814321ef14b952e45ddf9a35301af1a5e" translate="yes" xml:space="preserve">
          <source>The problem is that none of this is reliable: it depends on the command and it is entirely possible neither works. If</source>
          <target state="translated">El problema es que nada de esto es confiable:depende del comando y es totalmente posible que ninguno de los dos funcione.Si</target>
        </trans-unit>
        <trans-unit id="88377fbeaf8b4fab35329a7e374ea24a4795a7c5" translate="yes" xml:space="preserve">
          <source>The problem is that this code will always be parsed and executed, even when the debug level set in the logging configuration file is zero. Once the debug() subroutine has been entered, and the internal &lt;code&gt;$debug&lt;/code&gt; variable confirmed to be zero, for example, the message which has been sent in will be discarded and the program will continue. In the example given though, the &lt;code&gt;\%INC&lt;/code&gt; hash will already have been dumped, and the message string constructed, all of which work could be bypassed by a debug variable at the statement level, like this:</source>
          <target state="translated">El problema es que este c&amp;oacute;digo siempre se analizar&amp;aacute; y ejecutar&amp;aacute;, incluso cuando el nivel de depuraci&amp;oacute;n establecido en el archivo de configuraci&amp;oacute;n de registro sea cero. Una vez que se haya ingresado la subrutina debug () y se haya confirmado que la variable interna &lt;code&gt;$debug&lt;/code&gt; es cero, por ejemplo, el mensaje que se envi&amp;oacute; se descartar&amp;aacute; y el programa continuar&amp;aacute;. Sin embargo, en el ejemplo dado, el hash &lt;code&gt;\%INC&lt;/code&gt; ya se habr&amp;aacute; descargado y la cadena del mensaje se habr&amp;aacute; construido, todo el trabajo podr&amp;iacute;a ser omitido por una variable de depuraci&amp;oacute;n en el nivel de la declaraci&amp;oacute;n, como esta:</target>
        </trans-unit>
        <trans-unit id="73cae6ed898e3261e96216aa07490bc469dc51e8" translate="yes" xml:space="preserve">
          <source>The problem is that this code would</source>
          <target state="translated">El problema es que este código</target>
        </trans-unit>
        <trans-unit id="e6af2011607132108daf874aceb7c74f8abf4357" translate="yes" xml:space="preserve">
          <source>The problem is that those double-quotes force stringification--coercing numbers and references into strings--even when you don't want them to be strings. Think of it this way: double-quote expansion is used to produce new strings. If you already have a string, why do you need more?</source>
          <target state="translated">El problema es que esas dobles comillas obligan a la encadenamiento,coaccionando números y referencias en cuerdas,incluso cuando no quieres que sean cuerdas.Piénsalo de esta manera:la expansión de las comillas dobles se usa para producir nuevas cuerdas.Si ya tienes una cadena,¿por qué necesitas más?</target>
        </trans-unit>
        <trans-unit id="d0f76e9ccc888898fb7c8d297bdf6217c3b3b765" translate="yes" xml:space="preserve">
          <source>The problem is that various structures visible via procfs use off_t, and if you compile with largefile support these change from 32 bits to 64 bits. Thus what you get back from procfs doesn't match up with the structures in perl, resulting in garbage. See proc(4) for further discussion.</source>
          <target state="translated">El problema es que varias estructuras visibles a través de procfs usan off_t,y si compilas con soporte de archivo grande estas cambian de 32 bits a 64 bits.Por lo tanto,lo que obtienes de procfs no coincide con las estructuras en perl,resultando en basura.Ver proc(4)para más información.</target>
        </trans-unit>
        <trans-unit id="36b3f29973dcb4084c4233c180d15ad0f5ad2090" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;'+'&lt;/code&gt; and &lt;code&gt;'*'&lt;/code&gt;: one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fc4b1a9098877c5f0dfd053c053f3947a9421580" translate="yes" xml:space="preserve">
          <source>The problem is the nested indeterminate quantifiers. There are many different ways of partitioning a string of length n between the &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt; : one repetition with &lt;code&gt;b+&lt;/code&gt; of length n, two repetitions with the first &lt;code&gt;b+&lt;/code&gt; length k and the second with length n-k, m repetitions whose bits add up to length n, etc. In fact there are an exponential number of ways to partition a string as a function of its length. A regexp may get lucky and match early in the process, but if there is no match, Perl will try</source>
          <target state="translated">El problema son los cuantificadores indeterminados anidados. Hay muchas formas diferentes de dividir una cadena de longitud n entre &lt;code&gt;+&lt;/code&gt; y &lt;code&gt;*&lt;/code&gt; : una repetici&amp;oacute;n con &lt;code&gt;b+&lt;/code&gt; de longitud n, dos repeticiones con la primera &lt;code&gt;b+&lt;/code&gt; longitud k y la segunda con longitud nk, m repeticiones cuyos bits suman la longitud n , etc. De hecho, hay un n&amp;uacute;mero exponencial de formas de particionar una cadena en funci&amp;oacute;n de su longitud. Una expresi&amp;oacute;n regular puede tener suerte y coincidir al principio del proceso, pero si no hay ninguna coincidencia, Perl lo intentar&amp;aacute;</target>
        </trans-unit>
        <trans-unit id="57ef8306dabb66b8a3dd5849936f56c155cd391f" translate="yes" xml:space="preserve">
          <source>The problem is usually that the command interpreters on those systems have rather different ideas about quoting than the Unix shells under which the one-liners were created. On some systems, you may have to change single-quotes to double ones, which you must</source>
          <target state="translated">El problema suele ser que los intérpretes de comandos de esos sistemas tienen ideas bastante diferentes sobre las citas que los shells de Unix bajo los cuales se crearon las líneas únicas.En algunos sistemas,puede que tengas que cambiar las comillas simples por dobles,lo cual debes</target>
        </trans-unit>
        <trans-unit id="814a82003c2ef63857b1187789261eb0a14ef57b" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;$writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ee9f00b1299262770f29ccbf33382cfb01278a2" translate="yes" xml:space="preserve">
          <source>The problem with this is that buffering is really going to ruin your day. Even though your &lt;code&gt;Writer&lt;/code&gt; filehandle is auto-flushed so the process on the other end gets your data in a timely manner, you can't usually do anything to force that process to give its data to you in a similarly quick fashion. In this special case, we could actually so, because we gave</source>
          <target state="translated">El problema con esto es que el almacenamiento en b&amp;uacute;fer realmente arruinar&amp;aacute; tu d&amp;iacute;a. Aunque el administrador de archivos de &lt;code&gt;Writer&lt;/code&gt; se vac&amp;iacute;a autom&amp;aacute;ticamente, por lo que el proceso del otro extremo obtiene sus datos de manera oportuna, normalmente no puede hacer nada para obligar a ese proceso a que le proporcione sus datos de manera igualmente r&amp;aacute;pida. En este caso especial, de hecho podr&amp;iacute;amos hacerlo, porque dimos</target>
        </trans-unit>
        <trans-unit id="f6f3b81b70ac61e4574d6ebcd3e976b1d72049f0" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt; . It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="translated">Los problemas de recolecci&amp;oacute;n de basura y seguridad de subprocesos son abordados por la funci&amp;oacute;n &lt;code&gt;register()&lt;/code&gt; . Registra un objeto junto con cualquier n&amp;uacute;mero de hashes. Registro significa que cuando el objeto muere, se eliminar&amp;aacute; una entrada en cualquiera de los hash bajo la direcci&amp;oacute;n de referencia de este objeto. Esto garantiza la recolecci&amp;oacute;n de basura en estos hashes. Tambi&amp;eacute;n significa que en la clonaci&amp;oacute;n de subprocesos, las entradas del objeto en hashes registrados se reemplazar&amp;aacute;n con entradas actualizadas cuya clave es la direcci&amp;oacute;n de referencia del objeto clonado. Por lo tanto, la asociaci&amp;oacute;n objeto-datos se vuelve segura para subprocesos.</target>
        </trans-unit>
        <trans-unit id="d49a5cf6f714984f5d4aa1ae27ae4adaa45ad30d" translate="yes" xml:space="preserve">
          <source>The problems of garbage collection and thread safety are both addressed by the function &lt;code&gt;register()&lt;/code&gt;. It registers an object together with any number of hashes. Registry means that when the object dies, an entry in any of the hashes under the reference address of this object will be deleted. This guarantees garbage collection in these hashes. It also means that on thread cloning the object's entries in registered hashes will be replaced with updated entries whose key is the cloned object's reference address. Thus the object-data association becomes thread-safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4aef2d934929be669275ad225ef041e450d29108" translate="yes" xml:space="preserve">
          <source>The procedure for doing this is roughly as follows (using the example of tonyc's smoke-me branch called win32stat):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9452ac7ff4d68965b2304a021a3f491d59cd9f05" translate="yes" xml:space="preserve">
          <source>The process ID in which the event was generated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95e6fb31b348934a4b1c0d293aa560867eaa2c02" translate="yes" xml:space="preserve">
          <source>The process number of the Perl running this script. Though you</source>
          <target state="translated">El número de proceso del Perl que ejecuta este guión.Aunque tú...</target>
        </trans-unit>
        <trans-unit id="b93ffa0ee1718038fedc8009038c2d7f70371455" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; functions.</source>
          <target state="translated">El proceso de convertir una cadena en uno de los cuatro &lt;b&gt;mapas de casos&lt;/b&gt; Unicode ; en Perl, se implementa con las funciones &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7b3ce77cc42e100f56e2fb73208b06058b72b962" translate="yes" xml:space="preserve">
          <source>The process of converting a string to one of the four Unicode &lt;b&gt;casemaps&lt;/b&gt;; in Perl, it is implemented with the &lt;code&gt;fc&lt;/code&gt;, &lt;code&gt;lc&lt;/code&gt;, &lt;code&gt;ucfirst&lt;/code&gt;, and &lt;code&gt;uc&lt;/code&gt; functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf36cd26c284e1c84d9c66a1a4b1fbb69c4ead2" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt; , its only parent is &lt;code&gt;File&lt;/code&gt; . If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">El proceso de determinar qu&amp;eacute; m&amp;eacute;todo debe utilizarse se denomina &lt;b&gt;resoluci&amp;oacute;n de m&amp;eacute;todo&lt;/b&gt; . Lo que hace Perl es mirar primero la clase del objeto ( &lt;code&gt;File::MP3&lt;/code&gt; en este caso). Si esa clase define el m&amp;eacute;todo, entonces se llama a la versi&amp;oacute;n del m&amp;eacute;todo de esa clase. Si no es as&amp;iacute;, Perl examina cada clase principal por turno. Para &lt;code&gt;File::MP3&lt;/code&gt; , su &amp;uacute;nico padre es &lt;code&gt;File&lt;/code&gt; . Si &lt;code&gt;File::MP3&lt;/code&gt; no define el m&amp;eacute;todo, pero &lt;code&gt;File&lt;/code&gt; lo hace, Perl llama al m&amp;eacute;todo en &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2d45b13e98be85d3a3cff56a4de1619efcb5c0e5" translate="yes" xml:space="preserve">
          <source>The process of determining what method should be used is called &lt;b&gt;method resolution&lt;/b&gt;. What Perl does is look at the object's class first (&lt;code&gt;File::MP3&lt;/code&gt; in this case). If that class defines the method, then that class's version of the method is called. If not, Perl looks at each parent class in turn. For &lt;code&gt;File::MP3&lt;/code&gt;, its only parent is &lt;code&gt;File&lt;/code&gt;. If &lt;code&gt;File::MP3&lt;/code&gt; does not define the method, but &lt;code&gt;File&lt;/code&gt; does, then Perl calls the method in &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="080ae8ae51ff51ae8e5ac989879f84eb0a78985b" translate="yes" xml:space="preserve">
          <source>The process of gluing one cat&amp;rsquo;s nose to another cat&amp;rsquo;s tail. Also a similar operation on two &lt;b&gt;strings&lt;/b&gt;.</source>
          <target state="translated">El proceso de pegar la nariz de un gato a la cola de otro gato. Tambi&amp;eacute;n una operaci&amp;oacute;n similar en dos &lt;b&gt;cuerdas&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="908f91e0beaa0a05d55f4dc47581a39df63d9d61" translate="yes" xml:space="preserve">
          <source>The process of producing a &lt;b&gt;string&lt;/b&gt; representation of an abstract object.</source>
          <target state="translated">El proceso de producir una representaci&amp;oacute;n de &lt;b&gt;cadena&lt;/b&gt; de un objeto abstracto.</target>
        </trans-unit>
        <trans-unit id="3e1e79f73acf8d324572f017b3dffb010974336f" translate="yes" xml:space="preserve">
          <source>The process of trying one alternative, seeing if it matches, and moving on to the next alternative, while going back in the string from where the previous alternative was tried, if it doesn't, is called</source>
          <target state="translated">El proceso de probar una alternativa,ver si coincide,y pasar a la siguiente alternativa,mientras se vuelve a la cadena desde donde se probó la alternativa anterior,si no lo hace,se llama</target>
        </trans-unit>
        <trans-unit id="74fa9d2e4258275e6ce9c275f9e0e82d2661aeb2" translate="yes" xml:space="preserve">
          <source>The process of turning source code into a machine-usable form. See &lt;b&gt;compile phase&lt;/b&gt;.</source>
          <target state="translated">El proceso de convertir el c&amp;oacute;digo fuente en una forma utilizable por m&amp;aacute;quina. Ver &lt;b&gt;fase de compilaci&amp;oacute;n&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2c86388b6b25502da94ef398d94ba381de4e7acd" translate="yes" xml:space="preserve">
          <source>The program assumes prior understanding of the internal structure of a Zip file. You should have a copy of the Zip APPNOTE file at hand to help understand the output from this program (&lt;a href=&quot;#SEE-ALSO&quot;&gt;&quot;SEE ALSO&quot;&lt;/a&gt; for details).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc5a52491b0f391cb1ad331e975b3decd008b51b" translate="yes" xml:space="preserve">
          <source>The program can be made to run by &quot;laundering&quot; the tainted value through a regular expression: the second example--which still ignores locale information--runs, creating the file named on its command line if it can.</source>
          <target state="translated">El programa puede ser hecho funcionar &quot;lavando&quot; el valor contaminado a través de una expresión regular:el segundo ejemplo,que aún ignora la información de localización,se ejecuta,creando el archivo nombrado en su línea de comandos si puede.</target>
        </trans-unit>
        <trans-unit id="71e8e6b13bea2c8688fa8edfd4a4d7df9ffed609" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt; , the log is over.</source>
          <target state="translated">El programa se bloquea, &lt;code&gt;&lt;a href=&quot;../functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; , llama a &lt;code&gt;closelog&lt;/code&gt; , el registro ha terminado.</target>
        </trans-unit>
        <trans-unit id="acb249bf3e58472d9c05a98a3d9fd3a22a634ed9" translate="yes" xml:space="preserve">
          <source>The program crashes, &lt;code&gt;die&lt;/code&gt;s, calls &lt;code&gt;closelog&lt;/code&gt;, the log is over.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f6e033c5ffe643ac5235dd0c4de96e8993b109b" translate="yes" xml:space="preserve">
          <source>The program h2xs is the starting point for creating extensions. In later examples we'll see how we can use h2xs to read header files and generate templates to connect to C routines.</source>
          <target state="translated">El programa h2xs es el punto de partida para crear extensiones.En ejemplos posteriores veremos cómo podemos usar h2xs para leer archivos de encabezado y generar plantillas para conectar con las rutinas C.</target>
        </trans-unit>
        <trans-unit id="6480e775a128a11d00bdb33611f7cc04c69a6a31" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2--7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt; , whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="translated">El programa tiene dos partes: las l&amp;iacute;neas 2 a 7 leen la entrada y construyen una estructura de datos, y las l&amp;iacute;neas 8 a 13 analizan los datos e imprimen el informe. Vamos a tener una &lt;code&gt;%table&lt;/code&gt; hash, % , cuyas claves son nombres de pa&amp;iacute;ses y cuyos valores son referencias a matrices de nombres de ciudades. La estructura de datos se ver&amp;aacute; as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="467c57531a345de9ffd810bfeb5971919e96c865" translate="yes" xml:space="preserve">
          <source>The program has two pieces: Lines 2-7 read the input and build a data structure, and lines 8-13 analyze the data and print out the report. We're going to have a hash, &lt;code&gt;%table&lt;/code&gt;, whose keys are country names, and whose values are references to arrays of city names. The data structure will look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d46a6e0b6bbf3d5823709dce22271813109f1ce6" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures.</source>
          <target state="translated">El programa est&amp;aacute; representado por una matriz de estructuras de &lt;code&gt;regnode&lt;/code&gt; , una o m&amp;aacute;s de las cuales representan una sola repetici&amp;oacute;n del programa. Struct &lt;code&gt;regnode&lt;/code&gt; es la estructura m&amp;aacute;s peque&amp;ntilde;a necesaria y tiene una estructura de campo que se comparte con todas las dem&amp;aacute;s estructuras m&amp;aacute;s grandes.</target>
        </trans-unit>
        <trans-unit id="3ea55b0618cf1b22588d3366ef69169df7ae378e" translate="yes" xml:space="preserve">
          <source>The program is represented by an array of &lt;code&gt;regnode&lt;/code&gt; structures, one or more of which represent a single regop of the program. Struct &lt;code&gt;regnode&lt;/code&gt; is the smallest struct needed, and has a field structure which is shared with all the other larger structures. (Outside this document, the term &quot;regnode&quot; is sometimes used to mean &quot;regop&quot;, which could be confusing.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="135fe1206adbfe007b6735c772853b1eaf66848e" translate="yes" xml:space="preserve">
          <source>The program must take care to ensure that this takes place</source>
          <target state="translated">El programa debe tener cuidado para asegurar que esto se lleve a cabo</target>
        </trans-unit>
        <trans-unit id="c1da64105b623d7426e31c12654e36ae7053e949" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="translated">El programa tard&amp;oacute; poco m&amp;aacute;s de 17 segundos en ejecutarse. Tenga en cuenta los diferentes valores de salida de &lt;code&gt;&lt;a href=&quot;functions/time&quot;&gt;time&lt;/a&gt;&lt;/code&gt; , es importante usar siempre el mismo y no confundir lo que significa cada uno.</target>
        </trans-unit>
        <trans-unit id="453564270c1c0cd5131ab07331c35f9b9398730b" translate="yes" xml:space="preserve">
          <source>The program took just over 17 wallclock seconds to run. Note the different values &lt;code&gt;time&lt;/code&gt; outputs, it's important to always use the same one, and to not confuse what each one means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8912a00ba87d6cbf5df35a3207c6a72bfeb3c965" translate="yes" xml:space="preserve">
          <source>The program will halt</source>
          <target state="translated">El programa se detendrá</target>
        </trans-unit>
        <trans-unit id="267c6b23ea1ed3936b0ecbfc44abd9e2d8aa3502" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;md5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="translated">La interfaz de programaci&amp;oacute;n es f&amp;aacute;cil de usar: es la misma que se encuentra en el m&amp;oacute;dulo &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; de CPAN . Por lo tanto, si sus aplicaciones actualmente usan &lt;a href=&quot;md5&quot;&gt;Digest :: MD5&lt;/a&gt; y prefiere la seguridad m&amp;aacute;s s&amp;oacute;lida de SHA, convertirlas es muy sencillo.</target>
        </trans-unit>
        <trans-unit id="7b1493356cb4a3eba009f1a11b50de871f482665" translate="yes" xml:space="preserve">
          <source>The programming interface is easy to use: it's the same one found in CPAN's &lt;a href=&quot;digest&quot;&gt;Digest&lt;/a&gt; module. So, if your applications currently use &lt;a href=&quot;Digest::MD5&quot;&gt;Digest::MD5&lt;/a&gt; and you'd prefer the stronger security of SHA, it's a simple matter to convert them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0f12348b1996ab0ae0eb3467409b46f3ff517e5" translate="yes" xml:space="preserve">
          <source>The programs and documentation in this dist are distributed in the hope that they will be useful, but without any warranty; without even the implied warranty of merchantability or fitness for a particular purpose.</source>
          <target state="translated">Los programas y la documentación en esta distancia se distribuyen con la esperanza de que sean útiles,pero sin ninguna garantía,ni siquiera la garantía implícita de comerciabilidad o idoneidad para un propósito particular.</target>
        </trans-unit>
        <trans-unit id="3b63891b0a81b9b51c173bac879417506124032c" translate="yes" xml:space="preserve">
          <source>The prompt of the cpan shell can contain the current command number for easier tracking of the session or be a plain string.</source>
          <target state="translated">El prompt del shell de cpan puede contener el número de comando actual para facilitar el seguimiento de la sesión o ser una simple cadena.</target>
        </trans-unit>
        <trans-unit id="a9cf8b59c024e83e18267b0f8a6518d4ffcc35fc" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt; ) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="translated">La propiedad de las min&amp;uacute;sculas antes de las letras may&amp;uacute;sculas en EBCDIC se lleva incluso a las p&amp;aacute;ginas del EBCDIC latino 1, como 0037 y 1047. Un ejemplo ser&amp;iacute;a que &quot;&amp;Euml;&quot; ( &lt;code&gt;E WITH DIAERESIS&lt;/code&gt; , 203) viene antes de &quot;&amp;euml;&quot; ( &lt;code&gt;e WITH DIAERESIS&lt;/code&gt; , 235) ) en una plataforma ASCII, pero la &amp;uacute;ltima (83) precede a la primera (115) en una plataforma EBCDIC. (Los lectores astutos notar&amp;aacute;n que la versi&amp;oacute;n may&amp;uacute;scula de &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; es simplemente &quot;SS&quot; y que las versiones may&amp;uacute;sculas de &quot;&amp;yuml;&quot; ( &lt;code&gt;y WITH DIAERESIS&lt;/code&gt; ) y &quot;&amp;micro;&quot; ( &lt;code&gt;MICRO SIGN&lt;/code&gt; ) no est&amp;aacute;n en el 0..255 pero est&amp;aacute;n en Unicode, en un Perl habilitado para Unicode).</target>
        </trans-unit>
        <trans-unit id="d068c61e1d2738a4b949032692f164ea749e79a4" translate="yes" xml:space="preserve">
          <source>The property of lowercase before uppercase letters in EBCDIC is even carried to the Latin 1 EBCDIC pages such as 0037 and 1047. An example would be that &quot;&amp;Euml;&quot; (&lt;code&gt;E WITH DIAERESIS&lt;/code&gt;, 203) comes before &quot;&amp;euml;&quot; (&lt;code&gt;e WITH DIAERESIS&lt;/code&gt;, 235) on an ASCII platform, but the latter (83) comes before the former (115) on an EBCDIC platform. (Astute readers will note that the uppercase version of &quot;&amp;szlig;&quot; &lt;code&gt;SMALL LETTER SHARP S&lt;/code&gt; is simply &quot;SS&quot; and that the upper case versions of &quot;&amp;yuml;&quot; (small &lt;code&gt;y WITH DIAERESIS&lt;/code&gt;) and &quot;&amp;micro;&quot; (&lt;code&gt;MICRO SIGN&lt;/code&gt;) are not in the 0..255 range but are in Unicode, in a Unicode enabled Perl).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="09b7c3443c95713bb7f5c3a34ea900a666d3209c" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</source>
          <target state="translated">El protocolo (por ejemplo, &lt;code&gt;IPPROTO_TCP&lt;/code&gt; )</target>
        </trans-unit>
        <trans-unit id="1d688930b159b0de8e063999fc12f1fc3e668a59" translate="yes" xml:space="preserve">
          <source>The protocol (e.g. &lt;code&gt;IPPROTO_TCP&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16c98cd2a0bd15be4f172d1ada9a2ed6c4ba31c3" translate="yes" xml:space="preserve">
          <source>The protocol also defines several standard &lt;b&gt;translations&lt;/b&gt; which the file can undergo during transfer. These are ASCII, EBCDIC, binary, and byte. ASCII is the default type, and indicates that the sender of files will translate the ends of lines to a standard representation which the receiver will then translate back into their local representation. EBCDIC indicates the file being transferred is in EBCDIC format. Binary (also known as image) format sends the data as a contiguous bit stream. Byte format transfers the data as bytes, the values of which remain the same regardless of differences in byte size between the two machines (in theory - in practice you should only use this if you really know what you're doing). This class does not support the EBCDIC or byte formats, and will default to binary instead if they are attempted.</source>
          <target state="translated">El protocolo tambi&amp;eacute;n define varias &lt;b&gt;traducciones&lt;/b&gt; est&amp;aacute;ndar&lt;b&gt;&lt;/b&gt;que el archivo puede sufrir durante la transferencia. Estos son ASCII, EBCDIC, binarios y bytes. ASCII es el tipo predeterminado e indica que el remitente de los archivos traducir&amp;aacute; los extremos de las l&amp;iacute;neas a una representaci&amp;oacute;n est&amp;aacute;ndar que el receptor luego traducir&amp;aacute; de nuevo a su representaci&amp;oacute;n local. EBCDIC indica que el archivo que se transfiere est&amp;aacute; en formato EBCDIC. El formato binario (tambi&amp;eacute;n conocido como imagen) env&amp;iacute;a los datos como un flujo de bits contiguo. El formato de bytes transfiere los datos como bytes, cuyos valores siguen siendo los mismos independientemente de las diferencias en el tama&amp;ntilde;o de bytes entre las dos m&amp;aacute;quinas (en teor&amp;iacute;a, en la pr&amp;aacute;ctica, solo debe usar esto si realmente sabe lo que est&amp;aacute; haciendo). Esta clase no admite los formatos EBCDIC o de bytes y, en su lugar, se establecer&amp;aacute; de forma predeterminada en binario si se intentan.</target>
        </trans-unit>
        <trans-unit id="3e54303b3641a865f35ca39d2a398386ca07567a" translate="yes" xml:space="preserve">
          <source>The prototype CV for a 'my' sub.</source>
          <target state="translated">El prototipo de CV para un &quot;mi&quot; submarino.</target>
        </trans-unit>
        <trans-unit id="11a1d81ab8f0f4c68c1c261efa58242791ed97cf" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, come after the signature.</source>
          <target state="translated">El atributo del prototipo,y cualquier otro atributo,viene después de la firma.</target>
        </trans-unit>
        <trans-unit id="571effb91670d02136e12104ead995a6cc16a1c2" translate="yes" xml:space="preserve">
          <source>The prototype attribute, and any other attributes, must come before the signature. The signature always immediately precedes the block of the subroutine's body.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="420268bbe69f10bd1b6ed7fa6d80a149e32d8a64" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt; .</source>
          <target state="translated">El prototipo del atributo se asigna al sub inmediatamente despu&amp;eacute;s del prototipo del sub, lo que significa que si ambos se declaran al mismo tiempo, se ignora el prototipo definido tradicionalmente. En otras palabras, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; es indistinguible de &lt;code&gt;sub foo(@){}&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a9e026f2d40529605b03137d9a9ed6ef4bb374c7" translate="yes" xml:space="preserve">
          <source>The prototype from the attribute is assigned to the sub immediately after the prototype from the sub, which means that if both are declared at the same time, the traditionally defined prototype is ignored. In other words, &lt;code&gt;sub foo($$) : prototype(@) {}&lt;/code&gt; is indistinguishable from &lt;code&gt;sub foo(@){}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d6eb998a9749fabedff565e15bacf235434a61b2" translate="yes" xml:space="preserve">
          <source>The provided argument MUST be equal to the string for the validation to pass.</source>
          <target state="translated">El argumento proporcionado DEBE ser igual a la cadena para que la validación pase.</target>
        </trans-unit>
        <trans-unit id="113c257205a6110f9be3ea8173531d90a26a925b" translate="yes" xml:space="preserve">
          <source>The provided argument MUST equal one of the elements of the array ref for the validation to pass. An array ref can hold all the above values.</source>
          <target state="translated">El argumento proporcionado DEBE ser igual a uno de los elementos de la matriz ref para que la validación pase.Un array ref puede contener todos los valores anteriores.</target>
        </trans-unit>
        <trans-unit id="f0175fe813dc359c6d5d92da9a9b07e142152ec0" translate="yes" xml:space="preserve">
          <source>The provided argument MUST match the regular expression for the validation to pass.</source>
          <target state="translated">El argumento proporcionado DEBE coincidir con la expresión regular para que la validación pase.</target>
        </trans-unit>
        <trans-unit id="7028c08ff6edd9122ed07f747d04ab21bb6b6da9" translate="yes" xml:space="preserve">
          <source>The provided subroutine MUST return true in order for the validation to pass and the argument accepted.</source>
          <target state="translated">La subrutina proporcionada DEBE volver verdadera para que la validación pase y el argumento sea aceptado.</target>
        </trans-unit>
        <trans-unit id="93c41fbabb74d3c7cddc4b5e78899f8faa1b1f17" translate="yes" xml:space="preserve">
          <source>The pseudo-hash feature was an experimental feature introduced in earlier versions of Perl and removed in 5.10.0. A pseudo-hash is an array reference which can be accessed using named keys like a hash. You may run in to some code in the wild which uses it. See the &lt;a href=&quot;fields&quot;&gt;fields&lt;/a&gt; pragma for more information.</source>
          <target state="translated">La funci&amp;oacute;n de pseudo-hash fue una funci&amp;oacute;n experimental introducida en versiones anteriores de Perl y eliminada en 5.10.0. Un pseudo-hash es una referencia de matriz a la que se puede acceder utilizando claves con nombre como un hash. Puede ejecutar alg&amp;uacute;n c&amp;oacute;digo en la naturaleza que lo usa. Consulte los &lt;a href=&quot;fields&quot;&gt;campos&lt;/a&gt; pragma para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="2c3bf5ebc790603d27cda992131fe6f16a627371" translate="yes" xml:space="preserve">
          <source>The public API must remain consistent, i.e. if a sub-class is overloading addition, the sub-class must use the same name, in this case badd(). The reason for this is that Math::BigInt is optimized to call the object methods directly.</source>
          <target state="translated">La API pública debe ser consistente,es decir,si una subclase está sobrecargando la adición,la subclase debe usar el mismo nombre,en este caso badd().La razón de esto es que Math::BigInt está optimizado para llamar a los métodos de objeto directamente.</target>
        </trans-unit>
        <trans-unit id="dc2995512c58b9b2e35d09bc546dc5a7fbc84663" translate="yes" xml:space="preserve">
          <source>The purpose of the macro &lt;code&gt;SPAGAIN&lt;/code&gt; is to refresh the local copy of the stack pointer. This is necessary because it is possible that the memory allocated to the Perl stack has been reallocated during the</source>
          <target state="translated">El prop&amp;oacute;sito de la macro &lt;code&gt;SPAGAIN&lt;/code&gt; es actualizar la copia local del puntero de pila. Esto es necesario porque es posible que la memoria asignada a la pila de Perl haya sido reasignada durante la</target>
        </trans-unit>
        <trans-unit id="211ca4f47d195354704ae118cbe1d64c1c871ea0" translate="yes" xml:space="preserve">
          <source>The purpose of the pragma is to alert users to the status of such a module by issuing a warning that encourages them to install the module from CPAN, so that a future upgrade to a perl which omits the module will not break their code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b29cd6102fd964c85b9f311d0c28db3fab69123d" translate="yes" xml:space="preserve">
          <source>The purpose of the testing is twofold: one, to help developers fix any problems in their code that crop up because of lack of testing on other platforms; two, to provide users with information about whether a given module works on a given platform.</source>
          <target state="translated">El propósito de las pruebas es doble:uno,ayudar a los desarrolladores a arreglar cualquier problema en su código que surja por falta de pruebas en otras plataformas;dos,proporcionar a los usuarios información sobre si un módulo determinado funciona en una plataforma determinada.</target>
        </trans-unit>
        <trans-unit id="a5dd5b4e9fced711b08542f3e0ab81c18273f9bd" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to document what has been deprecated in Perl, and by which version the deprecated feature will disappear, or, for already removed features, when it was removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="843821edac19011f1a6d1c830e78298f0013f7a5" translate="yes" xml:space="preserve">
          <source>The purpose of this document is to show you how to call Perl subroutines directly from C, i.e., how to write</source>
          <target state="translated">El propósito de este documento es mostrarle cómo llamar a las subrutinas de Perl directamente desde C,es decir,cómo escribir</target>
        </trans-unit>
        <trans-unit id="414e7fd5b34fea33393baf5db076f7ff8658e79f" translate="yes" xml:space="preserve">
          <source>The purpose of this module is to provide a wide range of testing utilities. Various ways to say &quot;ok&quot; with better diagnostics, facilities to skip tests, test future features and compare complicated data structures. While you can do almost anything with a simple &lt;code&gt;ok()&lt;/code&gt; function, it doesn't provide good diagnostic output.</source>
          <target state="translated">El prop&amp;oacute;sito de este m&amp;oacute;dulo es proporcionar una amplia gama de utilidades de prueba. Varias formas de decir &quot;ok&quot; con mejores diagn&amp;oacute;sticos, facilidades para omitir pruebas, probar funciones futuras y comparar estructuras de datos complicadas. Si bien puede hacer casi cualquier cosa con una simple funci&amp;oacute;n &lt;code&gt;ok()&lt;/code&gt; , no proporciona un buen resultado de diagn&amp;oacute;stico.</target>
        </trans-unit>
        <trans-unit id="9bfc8ef428f97c3f3e1176a68cf8e1112929bebf" translate="yes" xml:space="preserve">
          <source>The purpose, scope and target applications of your module</source>
          <target state="translated">El propósito,el alcance y las aplicaciones objetivo de su módulo</target>
        </trans-unit>
        <trans-unit id="cb81c6a18976d12ebe998a0a0b9af8a1bf213151" translate="yes" xml:space="preserve">
          <source>The pyramids.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddc9dd67da090624c445edfafa6830e5bccd4e64" translate="yes" xml:space="preserve">
          <source>The quality that makes you go to great effort to reduce overall energy expenditure. It makes you write labor-saving programs that other people will find useful, and then document what you wrote so you don&amp;rsquo;t have to answer so many questions about it. Hence, the first great virtue of a programmer. Also hence, this book. See also &lt;b&gt;impatience&lt;/b&gt; and &lt;b&gt;hubris&lt;/b&gt;.</source>
          <target state="translated">La calidad que le hace hacer un gran esfuerzo para reducir el gasto energ&amp;eacute;tico total. Le hace escribir programas que ahorran trabajo que otras personas encontrar&amp;aacute;n &amp;uacute;tiles y luego documentar lo que escribi&amp;oacute; para que no tenga que responder tantas preguntas al respecto. De ah&amp;iacute; la primera gran virtud de un programador. Tambi&amp;eacute;n de ah&amp;iacute;, este libro. V&amp;eacute;ase tambi&amp;eacute;n &lt;b&gt;impaciencia&lt;/b&gt; y &lt;b&gt;arrogancia&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="52d7089e85ac35a7092bc58942f32bee7ca90b8d" translate="yes" xml:space="preserve">
          <source>The question of string equivalence turns somewhat complicated in Unicode: what do you mean by &quot;equal&quot;?</source>
          <target state="translated">La cuestión de la equivalencia de las cadenas se complica un poco en Unicode:¿qué quieres decir con &quot;igual&quot;?</target>
        </trans-unit>
        <trans-unit id="f2a24b3b2648553142b8c5a0c4598996a73f792a" translate="yes" xml:space="preserve">
          <source>The question remains on when the SVs which are</source>
          <target state="translated">La pregunta sigue en pie cuando los SV que son</target>
        </trans-unit>
        <trans-unit id="099c0ce39a19f948a86d0ea40fc49e8ea2b14385" translate="yes" xml:space="preserve">
          <source>The question, of course, is why would you do something like this? Why create a semaphore with a starting count that's not one, or why decrement or increment it by more than one? The answer is resource availability. Many resources that you want to manage access for can be safely used by more than one thread at once.</source>
          <target state="translated">La pregunta,por supuesto,es ¿por qué harías algo así? ¿Por qué crear un semáforo con una cuenta inicial que no es una,o por qué disminuirlo o incrementarlo en más de una? La respuesta es la disponibilidad de recursos.Muchos de los recursos para los que quieres gestionar el acceso pueden ser utilizados con seguridad por más de un hilo a la vez.</target>
        </trans-unit>
        <trans-unit id="7e4709a385e818a7adc04721b36836ff38439abe" translate="yes" xml:space="preserve">
          <source>The quick answer is because they are easy to implement yourself. The long answer is that to write these in such a way that multiple platforms are supported correctly would just require too much code. Below are some examples how you can implement these yourself.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="551d1aa8a1248eaf53c1cd9d606d72ab7488cd21" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty method only works well when you don't plan to leave the commented code in the source. If a Pod parser comes along, your multiline comment is going to show up in the Pod translation. A better way hides it from Pod parsers as well.</source>
          <target state="translated">El método rápido y sucio sólo funciona bien cuando no planeas dejar el código comentado en la fuente.Si aparece un analizador de Pod,tu comentario multilínea aparecerá en la traducción del Pod.Una mejor manera de ocultarlo de los analizadores de Pod también.</target>
        </trans-unit>
        <trans-unit id="a41d7294035834639b17968992ffda16ae85e9a1" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt; , ending the Pod section:</source>
          <target state="translated">La forma r&amp;aacute;pida y sucia de comentar m&amp;aacute;s de una l&amp;iacute;nea de Perl es rodear esas l&amp;iacute;neas con directivas Pod. Debe poner estas directivas al principio de la l&amp;iacute;nea y en alg&amp;uacute;n lugar donde Perl espera una nueva declaraci&amp;oacute;n (por lo tanto, no en medio de declaraciones como los comentarios &lt;code&gt;#&lt;/code&gt; ). Termina el comentario con &lt;code&gt;=cut&lt;/code&gt; , terminando la secci&amp;oacute;n Pod:</target>
        </trans-unit>
        <trans-unit id="d90a105b257205ce48226d803e75858a07587fa6" translate="yes" xml:space="preserve">
          <source>The quick-and-dirty way to comment out more than one line of Perl is to surround those lines with Pod directives. You have to put these directives at the beginning of the line and somewhere where Perl expects a new statement (so not in the middle of statements like the &lt;code&gt;#&lt;/code&gt; comments). You end the comment with &lt;code&gt;=cut&lt;/code&gt;, ending the Pod section:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c2f3594848e5558e5b1bcd7932b24c116883439" translate="yes" xml:space="preserve">
          <source>The quotient is always the greatest integer less than or equal to the real-valued quotient of the two operands, and the remainder (when it is non-zero) always has the same sign as the second operand; so, for example,</source>
          <target state="translated">El cociente es siempre el mayor entero menor o igual al cociente real de los dos operandos,y el resto (cuando no es cero)siempre tiene el mismo signo que el segundo operando;así,por ejemplo,</target>
        </trans-unit>
        <trans-unit id="04db20aec07e3c7b83de9b23243f0bb2ef9f279e" translate="yes" xml:space="preserve">
          <source>The random characters are provided by File::Temp and ensure that each module's individual build directory is unique. This makes running CPAN.pm in concurrent processes simultaneously safe.</source>
          <target state="translated">Los caracteres aleatorios son proporcionados por File::Temp y aseguran que el directorio de construcción individual de cada módulo es único.Esto hace que ejecutar CPAN.pm en procesos simultáneos sea seguro.</target>
        </trans-unit>
        <trans-unit id="054e3d7058644b114207f253c83eb2c8a141a8e1" translate="yes" xml:space="preserve">
          <source>The range operator (in list context) makes use of the magical auto-increment algorithm if the operands are strings. You can say</source>
          <target state="translated">El operador de rango (en el contexto de la lista)utiliza el algoritmo mágico de autoincremento si los operandos son cuerdas.Puede decir</target>
        </trans-unit>
        <trans-unit id="4828534433b64aecd95537d37d705a006ad5851e" translate="yes" xml:space="preserve">
          <source>The range operator &lt;code&gt;..&lt;/code&gt; cannot be overloaded.</source>
          <target state="translated">El operador de rango &lt;code&gt;..&lt;/code&gt; . no se puede sobrecargar.</target>
        </trans-unit>
        <trans-unit id="bc508fe7a659eeced29e856ebc7b8d62470c6bbb" translate="yes" xml:space="preserve">
          <source>The range operator also works on strings, using the magical auto-increment, see below.</source>
          <target state="translated">El operador de rango también trabaja con cuerdas,usando el auto-incremento mágico,ver abajo.</target>
        </trans-unit>
        <trans-unit id="31d3e334c25d2382911ee65d3fae61de81e23584" translate="yes" xml:space="preserve">
          <source>The range operator in list context can make use of the magical auto-increment algorithm if both operands are strings, subject to the following rules:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e7f8ca3eb25d07981f64e697003d81f247478aa9" translate="yes" xml:space="preserve">
          <source>The range operator is &quot;..&quot;, not comma. The comma operator works as in C.</source>
          <target state="translated">El operador del campo de tiro es &quot;..&quot;,no coma.El operador de la coma funciona como en C.</target>
        </trans-unit>
        <trans-unit id="6b43593ef7e3f96c529ec6f6490c77d15e8ee949" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt; , rather than comma.</source>
          <target state="translated">El operador de rango es &lt;code&gt;...&lt;/code&gt; , en lugar de coma.</target>
        </trans-unit>
        <trans-unit id="6702b09bbe69f958fa5f9869c6ae81b0c789760d" translate="yes" xml:space="preserve">
          <source>The range operator is &lt;code&gt;...&lt;/code&gt;, rather than comma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41fb6d64bc39d2dbbf811ff985ded944bd6951e6" translate="yes" xml:space="preserve">
          <source>The rationale for inclusion in this module is that the function performs some work for which an XS implementation is essential because it cannot be implemented in Pure Perl, and which is sufficiently-widely used across CPAN that its popularity warrants inclusion in a core module, which this is.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="272be5d09f375bcf2f8787674ae6b79aa38f8abf" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="translated">La raz&amp;oacute;n para requerir esto es no romper los programas m&amp;aacute;s antiguos que dependen de la forma en que funcionaban las cosas antes de que apareciera Unicode. Esos programas m&amp;aacute;s antiguos solo conoc&amp;iacute;an el conjunto de caracteres ASCII, por lo que es posible que no funcionen correctamente para caracteres adicionales. Cuando una cadena est&amp;aacute; codificada en UTF-8, Perl asume que el programa est&amp;aacute; preparado para trabajar con Unicode, pero cuando la cadena no lo es, Perl asume que solo se desea ASCII, por lo que los caracteres que no son caracteres ASCII no lo son. reconocidos en cuanto a lo que ser&amp;iacute;an en Unicode. &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature 'unicode_strings'&lt;/code&gt; le dice a Perl que trate todos los caracteres como Unicode, ya sea que la cadena est&amp;eacute; codificada en UTF-8 o no, evitando as&amp;iacute; el problema.</target>
        </trans-unit>
        <trans-unit id="cd600fcbf1a6b70419da39d25dfcf62c3af89b3f" translate="yes" xml:space="preserve">
          <source>The rationale for requiring this is to not break older programs that rely on the way things worked before Unicode came along. Those older programs knew only about the ASCII character set, and so may not work properly for additional characters. When a string is encoded in UTF-8, Perl assumes that the program is prepared to deal with Unicode, but when the string isn't, Perl assumes that only ASCII is wanted, and so those characters that are not ASCII characters aren't recognized as to what they would be in Unicode. &lt;code&gt;use feature 'unicode_strings'&lt;/code&gt; tells Perl to treat all characters as Unicode, whether the string is encoded in UTF-8 or not, thus avoiding the problem.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="062d7f6e6f9ffa42523f91b3b98af5b6e21dddc1" translate="yes" xml:space="preserve">
          <source>The raw floppy disk. Doesn't work under Windows 95. This allows you to read or write raw sectors of the floppy disk and to use &lt;code&gt;DeviceIoControl&lt;/code&gt; to perform miscellaneous queries and operations to the floppy disk or drive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62a00a9112198d60e9e6e148f4efbf8b5c8bde2f" translate="yes" xml:space="preserve">
          <source>The raw original L&amp;lt;...&amp;gt; content, before text is split on &quot;|&quot;, &quot;/&quot;, etc, and before E&amp;lt;...&amp;gt; codes are expanded.</source>
          <target state="translated">El contenido L &amp;lt;...&amp;gt; original sin procesar, antes de que el texto se divida en &quot;|&quot;, &quot;/&quot;, etc., y antes de que se expandan los c&amp;oacute;digos E &amp;lt;...&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="16f6921cb27bb9d796f9843804daa8d9f88db314" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;), and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="translated">La variable m&amp;aacute;gica de solo lectura &lt;code&gt;${^UNICODE}&lt;/code&gt; refleja el valor num&amp;eacute;rico de esta configuraci&amp;oacute;n. Esta variable se establece durante el inicio de Perl y, a partir de entonces, es de solo lectura. Si quieres efectos de tiempo de ejecuci&amp;oacute;n, utilice el de tres arg abierto () (v&amp;eacute;ase &lt;a href=&quot;functions/open&quot;&gt;abierta&lt;/a&gt; ), el binmode de dos arg () (ver &lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt; ), y la &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; Pragma (ver &lt;a href=&quot;open&quot;&gt;abierta&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="7133d99787afc8bed88333155f330e0814f3badc" translate="yes" xml:space="preserve">
          <source>The read-only magic variable &lt;code&gt;${^UNICODE}&lt;/code&gt; reflects the numeric value of this setting. This variable is set during Perl startup and is thereafter read-only. If you want runtime effects, use the three-arg open() (see &lt;a href=&quot;perlfunc#open&quot;&gt;&quot;open&quot; in perlfunc&lt;/a&gt;), the two-arg binmode() (see &lt;a href=&quot;perlfunc#binmode&quot;&gt;&quot;binmode&quot; in perlfunc&lt;/a&gt;), and the &lt;code&gt;open&lt;/code&gt; pragma (see &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ac185b6e70958a0bc2daae47b4a77ca571d1fad" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt; , and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt; , one of which may be the same as the first number.</source>
          <target state="translated">El verdadero gid de este proceso. Si est&amp;aacute; en una m&amp;aacute;quina que admite la membres&amp;iacute;a en varios grupos simult&amp;aacute;neamente, proporciona una lista separada por espacios de los grupos en los que se encuentra. El primer n&amp;uacute;mero es el devuelto por &lt;code&gt;getgid()&lt;/code&gt; y los siguientes por &lt;code&gt;getgroups()&lt;/code&gt; , uno de los cuales puede ser el mismo que el primer n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="1b0d46bf2b89fe3b91282dbaf19dbfd7a631baf9" translate="yes" xml:space="preserve">
          <source>The real gid of this process. If you are on a machine that supports membership in multiple groups simultaneously, gives a space separated list of groups you are in. The first number is the one returned by &lt;code&gt;getgid()&lt;/code&gt;, and the subsequent ones by &lt;code&gt;getgroups()&lt;/code&gt;, one of which may be the same as the first number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c41410f8fa129356669d6ff84f5e22cd64e4d0cb" translate="yes" xml:space="preserve">
          <source>The real sequence number of the OP, as a regular number and not adjusted to be relative to the start of the real program. (This will generally be a fairly large number because all of &lt;b&gt;B::Concise&lt;/b&gt; is compiled before your program is).</source>
          <target state="translated">El n&amp;uacute;mero de secuencia real del OP, como un n&amp;uacute;mero regular y no ajustado para ser relativo al inicio del programa real. (Por lo general, este ser&amp;aacute; un n&amp;uacute;mero bastante grande porque todo &lt;b&gt;B :: Concise&lt;/b&gt; se compila antes que su programa).</target>
        </trans-unit>
        <trans-unit id="520aa3cfc6d3d06d2079bcf3cd80538cdc94136b" translate="yes" xml:space="preserve">
          <source>The real time timing is done using time(2) and the granularity is therefore only one second.</source>
          <target state="translated">La cronología en tiempo real se realiza utilizando el tiempo(2)y la granularidad es,por lo tanto,sólo un segundo.</target>
        </trans-unit>
        <trans-unit id="000f9aa1d39e9791c956bd280884dcab10bddcf9" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="translated">El fluido real de este proceso. Puede cambiar tanto el uid real como el uid efectivo al mismo tiempo usando &lt;code&gt;POSIX::setuid()&lt;/code&gt; . Dado que los cambios a &lt;code&gt;$&amp;lt;&lt;/code&gt; requieren una llamada al sistema, marque &lt;code&gt;$!&lt;/code&gt; despu&amp;eacute;s de un cambio, intente detectar posibles errores.</target>
        </trans-unit>
        <trans-unit id="2ac048e62e66a7879f9411bea5e557339bb43fff" translate="yes" xml:space="preserve">
          <source>The real uid of this process. You can change both the real uid and the effective uid at the same time by using &lt;code&gt;POSIX::setuid()&lt;/code&gt;. Since changes to &lt;code&gt;$&amp;lt;&lt;/code&gt; require a system call, check &lt;code&gt;$!&lt;/code&gt; after a change attempt to detect any possible errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="226998a781d1d6550060a07be6fe5dd8d2b4b4b4" translate="yes" xml:space="preserve">
          <source>The real work is done in the standard typemap.</source>
          <target state="translated">El trabajo real se hace en el mapa tipo estándar.</target>
        </trans-unit>
        <trans-unit id="c08e193bbc2bcd92c562519697a3487f212bcddb" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt; , but consider this situation:</source>
          <target state="translated">La raz&amp;oacute;n &lt;code&gt;encode_language_tag&lt;/code&gt; existe encode_language_tag es porque diferentes etiquetas de idioma pueden representar el mismo idioma; esto normalmente se puede tratar con &lt;code&gt;same_language_tag&lt;/code&gt; , pero considere esta situaci&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="3ce46cd4af70310d3ca26a396ea6fdf7fb3672f3" translate="yes" xml:space="preserve">
          <source>The reason &lt;code&gt;encode_language_tag&lt;/code&gt; exists is because different language tags may represent the same language; this is normally treatable with &lt;code&gt;same_language_tag&lt;/code&gt;, but consider this situation:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca772eb153fd56cb7e89f09b86319ec24565520e" translate="yes" xml:space="preserve">
          <source>The reason I said &quot;in this instance&quot; is because that</source>
          <target state="translated">La razón por la que dije &quot;en este caso&quot; es porque</target>
        </trans-unit>
        <trans-unit id="739ee83789116c83fd6d7b4456cdd5e4f5143663" translate="yes" xml:space="preserve">
          <source>The reason for not checking the return value from print() is because of pipe buffering; physical writes are delayed. That won't blow up until the close, and it will blow up with a SIGPIPE. To catch it, you could use this:</source>
          <target state="translated">La razón por la que no se comprueba el valor de retorno de print()es por el buffer de la tubería;las escrituras físicas se retrasan.Eso no estallará hasta el cierre,y estallará con un SIGPIPE.Para atraparlo,podrías usar esto:</target>
        </trans-unit>
        <trans-unit id="5243164bf937a2da41254af85f8953f57eda8b63" translate="yes" xml:space="preserve">
          <source>The reason for the bailout.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ff2ad92ed56d2b83c1783a3daf037c2fcef9e124" translate="yes" xml:space="preserve">
          <source>The reason for the exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="58e74d3011543f0cacc6e865a92179ab3feabba8" translate="yes" xml:space="preserve">
          <source>The reason for the skip, todo etc. See &lt;a href=&quot;Test::Builder&quot;&gt;Test::Builder&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3e75d2f4213b8c35d2937b292cccac3d8a1e38d" translate="yes" xml:space="preserve">
          <source>The reason for this is that CPAN does not know the dependencies of all modules when it starts out. To decide about the additional items to install, it just uses data found in the META.yml file or the generated Makefile. An undetected missing piece breaks the process. But it may well be that your Bundle installs some prerequisite later than some depending item and thus your second try is able to resolve everything. Please note, CPAN.pm does not know the dependency tree in advance and cannot sort the queue of things to install in a topologically correct order. It resolves perfectly well &lt;b&gt;if&lt;/b&gt; all modules declare the prerequisites correctly with the PREREQ_PM attribute to MakeMaker or the &lt;code&gt;requires&lt;/code&gt; stanza of Module::Build. For bundles which fail and you need to install often, it is recommended to sort the Bundle definition file manually.</source>
          <target state="translated">La raz&amp;oacute;n de esto es que CPAN no conoce las dependencias de todos los m&amp;oacute;dulos cuando se inicia. Para decidir sobre los elementos adicionales a instalar, solo usa los datos que se encuentran en el archivo META.yml o el Makefile generado. Una pieza faltante no detectada rompe el proceso. Pero bien puede ser que su Bundle instale alg&amp;uacute;n requisito previo m&amp;aacute;s tarde que alg&amp;uacute;n elemento dependiente y, por lo tanto, su segundo intento pueda resolverlo todo. Tenga en cuenta que CPAN.pm no conoce el &amp;aacute;rbol de dependencias de antemano y no puede ordenar la cola de cosas para instalar en un orden topol&amp;oacute;gicamente correcto. Se resuelve perfectamente &lt;b&gt;si&lt;/b&gt; todos los m&amp;oacute;dulos declaran correctamente los requisitos previos con el atributo PREREQ_PM a MakeMaker o los &lt;code&gt;requires&lt;/code&gt; estrofa de Module :: Build. Para los paquetes que fallan y necesita instalarlos con frecuencia, se recomienda ordenar el archivo de definici&amp;oacute;n del paquete manualmente.</target>
        </trans-unit>
        <trans-unit id="9dfe6b3d7e7af99fa8c5c069ac28ca23f9e16764" translate="yes" xml:space="preserve">
          <source>The reason for this is that the &lt;a href=&quot;version#numify%28%29&quot;&gt;numify()&lt;/a&gt; operator will turn &quot;v1.0&quot; into the equivalent string &quot;1.000000&quot;. Forcing the outer version object to &lt;a href=&quot;version#normal%28%29&quot;&gt;normal()&lt;/a&gt; form will display the mathematically equivalent &quot;v1.0.0&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5fa379384b7d494ede930080ac4d01947c2521a8" translate="yes" xml:space="preserve">
          <source>The reason for this unusability is that a fundamental assumption of Perl is that the characters it cares about for parsing and lexical analysis are the same whether or not the text is in UTF-8. For example, Perl expects the character &lt;code&gt;&quot;[&quot;&lt;/code&gt; to have the same representation, no matter if the string containing it (or program text) is UTF-8 encoded or not. To ensure this, Perl adapts UTF-EBCDIC to the particular code page so that all characters it expects to be UTF-8 invariant are in fact UTF-8 invariant. This means that text generated on a computer running one version of Perl's UTF-EBCDIC has to be translated to be intelligible to a computer running another.</source>
          <target state="translated">La raz&amp;oacute;n de esta inutilizaci&amp;oacute;n es que una suposici&amp;oacute;n fundamental de Perl es que los caracteres que le interesan para el an&amp;aacute;lisis sint&amp;aacute;ctico y l&amp;eacute;xico son los mismos tanto si el texto est&amp;aacute; en UTF-8 como si no. Por ejemplo, Perl espera que el car&amp;aacute;cter &lt;code&gt;&quot;[&quot;&lt;/code&gt; tenga la misma representaci&amp;oacute;n, sin importar si la cadena que lo contiene (o el texto del programa) est&amp;aacute; codificado en UTF-8 o no. Para garantizar esto, Perl adapta UTF-EBCDIC a la p&amp;aacute;gina de c&amp;oacute;digos particular para que todos los caracteres que espera que sean invariantes UTF-8 sean de hecho invariantes UTF-8. Esto significa que el texto generado en una computadora que ejecuta una versi&amp;oacute;n de UTF-EBCDIC de Perl debe traducirse para que sea inteligible para una computadora que ejecute otra.</target>
        </trans-unit>
        <trans-unit id="148e8f8b4033e043ed0349ade3e3972ed042dff2" translate="yes" xml:space="preserve">
          <source>The reason is that Encode::Guess guesses encoding by trial and error. It first splits $data into lines and tries to decode the line for each suspect. It keeps it going until all but one encoding is eliminated out of suspects list. ISO-8859 series is just too successful for most cases (because it fills almost all code points in \x00-\xff).</source>
          <target state="translated">La razón es que Codifica::Adivina codificando por ensayo y error.Primero divide los datos en líneas y trata de decodificar la línea para cada sospechoso.Lo mantiene en marcha hasta que todas las codificaciones menos una son eliminadas de la lista de sospechosos.La serie ISO-8859 es demasiado exitosa para la mayoría de los casos (porque llena casi todos los puntos de código en \x00-\xff).</target>
        </trans-unit>
        <trans-unit id="94742df1b378e1ee0c32933e905c9b3866f15f37" translate="yes" xml:space="preserve">
          <source>The reason is that variable interpolation and code expressions together pose a security risk. The combination is dangerous because many programmers who write search engines often take user input and plug it directly into a regexp:</source>
          <target state="translated">La razón es que la interpolación variable y las expresiones de código juntas plantean un riesgo de seguridad.La combinación es peligrosa porque muchos programadores que escriben motores de búsqueda a menudo toman las entradas del usuario y las conectan directamente a un regexp:</target>
        </trans-unit>
        <trans-unit id="c8fa70ef72504bbb3f7d6986506b4705b0ceb70a" translate="yes" xml:space="preserve">
          <source>The reason is that vendor encoding is usually a superset of national standard so it becomes too ambiguous for most cases.</source>
          <target state="translated">La razón es que la codificación de los proveedores suele ser un superconjunto de normas nacionales,por lo que resulta demasiado ambigua en la mayoría de los casos.</target>
        </trans-unit>
        <trans-unit id="76e332a13c138bbbc50c17d9967b9928970c16a2" translate="yes" xml:space="preserve">
          <source>The reason it isn't quite a drop-in replacement is actually an advantage. The only difference is that it returns &lt;code&gt;const char *&lt;/code&gt;, whereas plain &lt;code&gt;nl_langinfo()&lt;/code&gt; returns &lt;code&gt;char *&lt;/code&gt;, but you are (only by documentation) forbidden to write into the buffer. By declaring this &lt;code&gt;const&lt;/code&gt;, the compiler enforces this restriction, so if it is violated, you know at compilation time, rather than getting segfaults at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e0f1d70e28ee48bb2440f0dfad9e2b39b29922f" translate="yes" xml:space="preserve">
          <source>The reason that &lt;code&gt;host $failed_ack_host&lt;/code&gt; did not receive a valid ACK. Useful to find out why when &lt;code&gt;ack($fail_ack_host)&lt;/code&gt; returns a false value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fedf7056008fbc98297422a200d9b784c0b8db45" translate="yes" xml:space="preserve">
          <source>The reason that doesn't do what you want is because assigning a named array like that to a scalar is taking an array in scalar context, which means just counts the number of elements in @tmp.</source>
          <target state="translated">La razón por la que eso no hace lo que quieres es porque asignar una matriz con nombre como ese a un escalar es tomar una matriz en contexto escalar,lo que significa que sólo cuenta el número de elementos en @tmp.</target>
        </trans-unit>
        <trans-unit id="550ff1bc08b0298c35cdd00d235a478cadb820d7" translate="yes" xml:space="preserve">
          <source>The reason that host $failed_ack_host did not receive a valid ACK. Useful to find out why when ack( $fail_ack_host ) returns a false value.</source>
          <target state="translated">La razón por la que el host $failed_ack_host no recibió un ACK válido.Es útil para averiguar por qué cuando ack($fail_ack_host)devuelve un valor falso.</target>
        </trans-unit>
        <trans-unit id="761e66631890fba3f96026c5ab632825150c6b23" translate="yes" xml:space="preserve">
          <source>The reason that using gettext runs into walls (as in the above second-person horror story) is that you're trying to use a string (or worse, a choice among a bunch of strings) to do what you really need a function for -- which is futile. Preforming (s)printf interpolation on the strings which you get back from gettext does allow you to do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="251bb3c15e15e0ec21516300833b60efe1125c75" translate="yes" xml:space="preserve">
          <source>The reason this function has &quot;_strictly&quot; in its name is that when you're processing an Accept-Language list according to the RFCs, if you interpret the RFCs quite strictly, then you would use implicate_supers_strictly, but for normal use (i.e., common-sense use, as far as I'm concerned) you'd use implicate_supers.</source>
          <target state="translated">La razón por la que esta función tiene &quot;_estrictamente&quot; en su nombre es que cuando estás procesando una lista de lenguas de aceptación según las RFC,si interpretas las RFC de forma bastante estricta,entonces usarías implicate_supers_strictly,pero para un uso normal (es decir,un uso de sentido común,en lo que a mí respecta)usarías implicate_supers.</target>
        </trans-unit>
        <trans-unit id="00e0d83a9d5edf83f32ea0d0701c8b2f4b38f236" translate="yes" xml:space="preserve">
          <source>The reason this is considered to be only partially implemented is that Perl has &lt;a href=&quot;perlrebackslash#%5Cb%7Blb%7D&quot;&gt;&lt;code&gt;qr/\b{lb}/&lt;/code&gt;&lt;/a&gt; and &lt;code&gt;&lt;a href=&quot;Unicode::LineBreak&quot;&gt;Unicode::LineBreak&lt;/a&gt;&lt;/code&gt; that are conformant with &lt;a href=&quot;https://www.unicode.org/reports/tr14&quot;&gt;UAX#14 &quot;Unicode Line Breaking Algorithm&quot;&lt;/a&gt;. The regular expression construct provides default behavior, while the heavier-weight module provides customizable line breaking.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1005d9c83a9fa9fcbc88e4d2084838b8de52293" translate="yes" xml:space="preserve">
          <source>The reason this is necessary is that the area of the Perl stack which held them will very likely have been overwritten by something else by the time control returns from</source>
          <target state="translated">La razón por la que esto es necesario es que el área de la pila de Perl que las contenía muy probablemente haya sido sobrescrita por otra cosa para cuando el control regrese de</target>
        </trans-unit>
        <trans-unit id="7f8610d66bd9a8ef9ccb75cedd8c737641eb770d" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because RFC 1951 content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">La razón por la que este no es un comportamiento por defecto es porque el contenido del RFC 1951 sólo puede ser detectado al intentar descomprimirlo.Este proceso es propenso a errores y puede resultar en falsos positivos.</target>
        </trans-unit>
        <trans-unit id="19bd78bd51bc1c56b13d7881beac1baa5b73fb31" translate="yes" xml:space="preserve">
          <source>The reason this is not default behaviour is because lzma_alone content can only be detected by attempting to uncompress it. This process is error prone and can result is false positives.</source>
          <target state="translated">La razón por la que este no es un comportamiento por defecto es porque el contenido de lzma_alone sólo puede ser detectado al intentar descomprimirlo.Este proceso es propenso a errores y puede resultar en falsos positivos.</target>
        </trans-unit>
        <trans-unit id="28f02f8a8e5a76ee5006992d613d3802d772737a" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt; , it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt; . This is particularly true for these cases:</source>
          <target state="translated">La raz&amp;oacute;n por la que esto es incorrecto es que, para cuando &lt;code&gt;CallSavedSub1&lt;/code&gt; a usar el puntero &lt;code&gt;rememberSub&lt;/code&gt; en CallSavedSub1 , puede que se refiera o no a la subrutina Perl que se registr&amp;oacute; en &lt;code&gt;SaveSub1&lt;/code&gt; . Esto es particularmente cierto para estos casos:</target>
        </trans-unit>
        <trans-unit id="e2bf2d952027d4fe995c4250ed0910c8a499fa98" translate="yes" xml:space="preserve">
          <source>The reason this is wrong is that, by the time you come to use the pointer &lt;code&gt;rememberSub&lt;/code&gt; in &lt;code&gt;CallSavedSub1&lt;/code&gt;, it may or may not still refer to the Perl subroutine that was recorded in &lt;code&gt;SaveSub1&lt;/code&gt;. This is particularly true for these cases:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1fc61e22be627df80a7651746e52decec2ded90a" translate="yes" xml:space="preserve">
          <source>The reasons for most important skipped tests are:</source>
          <target state="translated">Las razones de la mayoría de las pruebas omitidas importantes son:</target>
        </trans-unit>
        <trans-unit id="cc1622b786a9a5b8c43f01f8734a1a12e356f528" translate="yes" xml:space="preserve">
          <source>The recognized bright background color attributes (colors 8 to 15) are:</source>
          <target state="translated">Los atributos de color de fondo brillante reconocidos (colores 8 a 15)son:</target>
        </trans-unit>
        <trans-unit id="6c5d4a5f4c9a09fda354809420b2cbe2f30c42f0" translate="yes" xml:space="preserve">
          <source>The recognized normal background color attributes (colors 0 to 7) are:</source>
          <target state="translated">Los atributos de color de fondo normal reconocidos (colores 0 a 7)son:</target>
        </trans-unit>
        <trans-unit id="4a93814d53d2a583e73a218be86053c6699847f6" translate="yes" xml:space="preserve">
          <source>The recognized normal foreground color attributes (colors 0 to 7) are:</source>
          <target state="translated">Los atributos de color de primer plano normales reconocidos (colores 0 a 7)son:</target>
        </trans-unit>
        <trans-unit id="c8d8fb33b8f8ad299c896b38af940448a2194ca3" translate="yes" xml:space="preserve">
          <source>The recognized options to new() are as follows. All options take a single argument.</source>
          <target state="translated">Las opciones reconocidas a new()son las siguientes.Todas las opciones toman un solo argumento.</target>
        </trans-unit>
        <trans-unit id="1e562f76f9cdb0ef2aab453d2c38556cc6a6334d" translate="yes" xml:space="preserve">
          <source>The recommended compiler to use in Tru64 is the native C compiler. The native compiler produces much faster code (the speed difference is noticeable: several dozen percentages) and also more correct code: if you are considering using the GNU C compiler you should use at the very least the release of 2.95.3 since all older gcc releases are known to produce broken code when compiling Perl. One manifestation of this brokenness is the lib/sdbm test dumping core; another is many of the op/regexp and op/pat, or ext/Storable tests dumping core (the exact pattern of failures depending on the GCC release and optimization flags).</source>
          <target state="translated">El compilador recomendado para usar en Tru64 es el compilador nativo de C.El compilador nativo produce un código mucho más rápido (la diferencia de velocidad es notable:varias docenas de porcentajes)y también un código más correcto:si está considerando usar el compilador de C de GNU debería usar como mínimo la versión 2.95.3 ya que se sabe que todas las versiones antiguas de gcc producen código roto al compilar Perl.Una manifestación de esta rotura es el núcleo de volcado de pruebas lib/sdbm;otra son muchos de los núcleos de volcado de pruebas op/regexp y op/pat,o ext/Storable (el patrón exacto de fallos depende de la versión de GCC y de las banderas de optimización).</target>
        </trans-unit>
        <trans-unit id="a954751580ed0f6e74f6ae52a458e3decc2b6782" translate="yes" xml:space="preserve">
          <source>The recommended order of sections in Perl module documentation is:</source>
          <target state="translated">El orden recomendado de las secciones en la documentación del módulo Perl es:</target>
        </trans-unit>
        <trans-unit id="da2bd70489cefb603292ce8b5cfe4c6cae04aaf7" translate="yes" xml:space="preserve">
          <source>The recommended way to build Perl for the OS/400 PASE is to build the Perl 5 source code (release 5.8.1 or later) under AIX.</source>
          <target state="translated">La forma recomendada de construir Perl para el OS/400 PASE es construir el código fuente de Perl 5 (versión 5.8.1 o posterior)bajo AIX.</target>
        </trans-unit>
        <trans-unit id="e06b04ad5d41fce493c0b00ecf1ca37dfa5afcff" translate="yes" xml:space="preserve">
          <source>The red() and green() functions would be similar. To create these, we'll assign a closure to a typeglob of the name of the function we're trying to build.</source>
          <target state="translated">Las funciones rojo()y verde()serían similares.Para crearlas,asignaremos un cierre a una tipografía del nombre de la función que estamos tratando de construir.</target>
        </trans-unit>
        <trans-unit id="f9a173256f222e6807faedf390f953793a1d344d" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; will be decremented at the end of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d461f380b420e2f92a59ecbfaa16c7256f214ff" translate="yes" xml:space="preserve">
          <source>The refcount of &lt;code&gt;sv&lt;/code&gt; would be decremented at the end of</source>
          <target state="translated">El recuento de &lt;code&gt;sv&lt;/code&gt; se reducir&amp;iacute;a al final de</target>
        </trans-unit>
        <trans-unit id="aa0554de1d883a744516c47aa9649afa91c2844b" translate="yes" xml:space="preserve">
          <source>The reference count for each specified &lt;code&gt;SV*&lt;/code&gt; parameter is decremented.</source>
          <target state="translated">El recuento de referencia para cada par&amp;aacute;metro &lt;code&gt;SV*&lt;/code&gt; especificado se reduce.</target>
        </trans-unit>
        <trans-unit id="2beb795bee8f23385c682524158dfa3883714ef0" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name list.</source>
          <target state="translated">El recuento de referencias de la lista de nombres de la almohadilla.</target>
        </trans-unit>
        <trans-unit id="ed87a4c5aaea6eeced4317ed59578fe0847b6b0f" translate="yes" xml:space="preserve">
          <source>The reference count of the pad name.</source>
          <target state="translated">El recuento de referencia del nombre de la almohadilla.</target>
        </trans-unit>
        <trans-unit id="0f3b4f395e70b832ec180500f62bfe30abfdf04c" translate="yes" xml:space="preserve">
          <source>The reference count of the padlist. Currently this is always 1.</source>
          <target state="translated">El recuento de referencia de la lista.Actualmente este es siempre 1.</target>
        </trans-unit>
        <trans-unit id="b9e9c4a001467c1b7e5e43bb821f471e292d9d31" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La referencia de &lt;code&gt;$foo&lt;/code&gt; a &lt;code&gt;$bar&lt;/code&gt; se ha debilitado. Cuando la variable &lt;code&gt;$bar&lt;/code&gt; queda fuera de alcance, se recolectar&amp;aacute; como basura. La pr&amp;oacute;xima vez que mire el valor de la tecla &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; , ser&amp;aacute; &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a1de879124c2751ad3ecd4b63c57cecfe27d3f64" translate="yes" xml:space="preserve">
          <source>The reference from &lt;code&gt;$foo&lt;/code&gt; to &lt;code&gt;$bar&lt;/code&gt; has been weakened. When the &lt;code&gt;$bar&lt;/code&gt; variable goes out of scope, it will be garbage-collected. The next time you look at the value of the &lt;code&gt;$foo-&amp;gt;{bar}&lt;/code&gt; key, it will be &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3fc857a94806f2c57cbbf2e2dd2d2b88b08c2fe6" translate="yes" xml:space="preserve">
          <source>The reference is truly dumped and we can finally see what we're dealing with. Our quoting was perfectly valid but wrong for our purposes, with 'and jerry' being treated as 2 separate words rather than a phrase, thus throwing the evenly paired hash structure out of alignment.</source>
          <target state="translated">La referencia está realmente descartada y finalmente podemos ver con qué estamos tratando.Nuestra cita era perfectamente válida,pero equivocada para nuestros propósitos,con &quot;y jerry&quot; siendo tratada como dos palabras separadas en lugar de una frase,lo que hace que la estructura de hachís emparejada uniformemente se desajuste.</target>
        </trans-unit>
        <trans-unit id="4adfd6b1f7abb309b66c9315a05ff37197f3a0fe" translate="yes" xml:space="preserve">
          <source>The references you get from rule 2 are the same kind of references that you get from rule 1:</source>
          <target state="translated">Las referencias que se obtienen de la regla 2 son el mismo tipo de referencias que se obtienen de la regla 1:</target>
        </trans-unit>
        <trans-unit id="4f2739050aee8d49851e25b790d128e1ca19fbde" translate="yes" xml:space="preserve">
          <source>The regex_sets feature is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c14a48971a0368f8bbf545f9e2905f7ac019ed5" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="168bedf74d17b291ff7d2c437f9134d9006e0ffe" translate="yes" xml:space="preserve">
          <source>The regexp has a single grouping which considers 4-letter combinations, then 3-letter combinations, etc., and uses &lt;code&gt;\g1&lt;/code&gt; to look for a repeat. Although &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\g1&lt;/code&gt; represent the same thing, care should be taken to use matched variables &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; ,... only</source>
          <target state="translated">La expresi&amp;oacute;n regular tiene una sola agrupaci&amp;oacute;n que considera combinaciones de 4 letras, luego combinaciones de 3 letras, etc., y usa &lt;code&gt;\g1&lt;/code&gt; para buscar una repetici&amp;oacute;n. Aunque &lt;code&gt;$1&lt;/code&gt; y &lt;code&gt;\g1&lt;/code&gt; representan lo mismo, se debe tener cuidado de usar solo variables coincidentes &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;$2&lt;/code&gt; , ...</target>
        </trans-unit>
        <trans-unit id="d1eb9cbcdcc85f0afd97e3812b595b9e1f6b3fd8" translate="yes" xml:space="preserve">
          <source>The regexp matches an open parenthesis, one or more copies of an alternation, and a close parenthesis. The alternation is two-way, with the first alternative &lt;code&gt;[^()]+&lt;/code&gt; matching a substring with no parentheses and the second alternative &lt;code&gt;\([^()]*\)&lt;/code&gt; matching a substring delimited by parentheses. The problem with this regexp is that it is pathological: it has nested indeterminate quantifiers of the form &lt;code&gt;(a+|b)+&lt;/code&gt;. We discussed in Part 1 how nested quantifiers like this could take an exponentially long time to execute if there was no match possible. To prevent the exponential blowup, we need to prevent useless backtracking at some point. This can be done by enclosing the inner quantifier as an independent subexpression:</source>
          <target state="translated">La expresi&amp;oacute;n regular coincide con un par&amp;eacute;ntesis abierto, una o m&amp;aacute;s copias de una alternancia y un par&amp;eacute;ntesis cerrado. La alternancia es bidireccional, con la primera alternativa &lt;code&gt;[^()]+&lt;/code&gt; haciendo coincidir una subcadena sin par&amp;eacute;ntesis y la segunda alternativa &lt;code&gt;\([^()]*\)&lt;/code&gt; haciendo coincidir una subcadena delimitada por par&amp;eacute;ntesis. El problema con esta expresi&amp;oacute;n regular es que es patol&amp;oacute;gica: tiene cuantificadores indeterminados anidados de la forma &lt;code&gt;(a+|b)+&lt;/code&gt; . En la Parte 1 discutimos c&amp;oacute;mo cuantificadores anidados como este podr&amp;iacute;an tardar un tiempo exponencialmente largo en ejecutarse si no hubiera una coincidencia posible. Para evitar la explosi&amp;oacute;n exponencial, debemos evitar un retroceso in&amp;uacute;til en alg&amp;uacute;n momento. Esto se puede hacer encerrando el cuantificador interno como una subexpresi&amp;oacute;n independiente:</target>
        </trans-unit>
        <trans-unit id="368bf455728e0cc079751b44e9fea4161849b273" translate="yes" xml:space="preserve">
          <source>The regexp structure contains all the data that perl needs to be aware of to properly work with the regular expression. It includes data about optimisations that perl can use to determine if the regex engine should really be used, and various other control info that is needed to properly execute patterns in various contexts such as is the pattern anchored in some way, or what flags were used during the compile, or whether the program contains special constructs that perl needs to be aware of.</source>
          <target state="translated">La estructura regexp contiene todos los datos que Perl debe conocer para trabajar adecuadamente con la expresión regular.Incluye datos sobre optimizaciones que perl puede utilizar para determinar si el motor regex debe ser realmente utilizado,y otra información de control que es necesaria para ejecutar adecuadamente los patrones en varios contextos,como si el patrón está anclado de alguna manera,o qué banderas se utilizaron durante la compilación,o si el programa contiene construcciones especiales que perl necesita conocer.</target>
        </trans-unit>
        <trans-unit id="c3c54f92228f6f05bcc0bda8517b5a88720264e3" translate="yes" xml:space="preserve">
          <source>The regexp without the &lt;code&gt;//x&lt;/code&gt; modifier is</source>
          <target state="translated">La expresi&amp;oacute;n regular sin el modificador &lt;code&gt;//x&lt;/code&gt; es</target>
        </trans-unit>
        <trans-unit id="cd0504e6dcc01ce1582fd08d19ab6d72b18efd43" translate="yes" xml:space="preserve">
          <source>The regops are defined in</source>
          <target state="translated">Los regops se definen en</target>
        </trans-unit>
        <trans-unit id="398b15f4cf9df5e68a324633c771b534053133cc" translate="yes" xml:space="preserve">
          <source>The regression tests for each operator live in</source>
          <target state="translated">Las pruebas de regresión para cada operador viven en</target>
        </trans-unit>
        <trans-unit id="1185c36b91985e4291f68ed8a08b57d301b0c6f7" translate="yes" xml:space="preserve">
          <source>The regular expression engine can be a weighty tool to wield. On long strings and complex patterns it can end up having to do a lot of work to find a match, and even more to decide that no match is possible. Consider a situation like the following pattern.</source>
          <target state="translated">El motor de expresión regular puede ser una herramienta de peso para manejar.En cuerdas largas y patrones complejos puede terminar teniendo que hacer mucho trabajo para encontrar una coincidencia,y más aún para decidir que no hay coincidencia posible.Considere una situación como el siguiente patrón.</target>
        </trans-unit>
        <trans-unit id="550e74d9d02bffd01cf3b652c4e172b2d8cb3f39" translate="yes" xml:space="preserve">
          <source>The regular expression to execute.</source>
          <target state="translated">La expresión regular para ejecutar.</target>
        </trans-unit>
        <trans-unit id="8c3b3408d3eb9771532acb10a043be225a8f7a49" translate="yes" xml:space="preserve">
          <source>The regular expression to match the balanced text uses two new (to Perl 5.10) regular expression features. These are covered in &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; and this example is a modified version of one in that documentation.</source>
          <target state="translated">La expresi&amp;oacute;n regular para hacer coincidir el texto equilibrado utiliza dos nuevas funciones de expresi&amp;oacute;n regular (para Perl 5.10). Estos est&amp;aacute;n cubiertos en &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; y este ejemplo es una versi&amp;oacute;n modificada de uno en esa documentaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7b89c7165c60ab0797d1970f7d1380e29eaa0008" translate="yes" xml:space="preserve">
          <source>The related &lt;code&gt;base&lt;/code&gt; pragma will combine fields from base classes and any fields declared using the &lt;code&gt;fields&lt;/code&gt; pragma. This enables field inheritance to work properly. Inherited fields can be overridden but will generate a warning if warnings are enabled.</source>
          <target state="translated">El pragma &lt;code&gt;base&lt;/code&gt; relacionado combinar&amp;aacute; campos de clases base y cualquier campo declarado usando el pragma de &lt;code&gt;fields&lt;/code&gt; . Esto permite que la herencia de campos funcione correctamente. Los campos heredados se pueden anular pero generar&amp;aacute;n una advertencia si las advertencias est&amp;aacute;n habilitadas.</target>
        </trans-unit>
        <trans-unit id="31c9eb432cfde9dbb8b6575337f7f66a6d53cbda" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</source>
          <target state="translated">El fragmento relevante de &lt;code&gt;Perl_pp_regcomp&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="86d45b748524cf3c3ed19b4942d99f6682b785f8" translate="yes" xml:space="preserve">
          <source>The relevant snippet from &lt;code&gt;Perl_pp_regcomp&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99cbb925914614f38c9cb5913b1dca990337342e" translate="yes" xml:space="preserve">
          <source>The remainder of the input string (i.e. the characters after the extracted string). On failure, the entire string is returned.</source>
          <target state="translated">El resto de la cadena de entrada (es decir,los caracteres después de la cadena extraída).Al fallar,se devuelve la cadena completa.</target>
        </trans-unit>
        <trans-unit id="efbd63ef88d15920cb0b989c9bf11dcb1d2eacf4" translate="yes" xml:space="preserve">
          <source>The remaining arguments list the files to be included in the tar file. These files must all exist. Any files which don't exist or can't be read are silently ignored.</source>
          <target state="translated">El resto de los argumentos enumeran los archivos que se incluirán en el archivo tar.Estos archivos deben existir todos.Los archivos que no existen o no pueden ser leídos son ignorados silenciosamente.</target>
        </trans-unit>
        <trans-unit id="f73744579f886d96e9ed158f08b1414dc3c821e4" translate="yes" xml:space="preserve">
          <source>The remaining fields specify the starting and ending cylinder and head of the range of tracks to be formatted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1833f6078478dddd497b7e7b088899346fc9339d" translate="yes" xml:space="preserve">
          <source>The remaining list-reduction functions are all specialisations of this generic idea.</source>
          <target state="translated">El resto de las funciones de reducción de la lista son todas especializaciones de esta idea genérica.</target>
        </trans-unit>
        <trans-unit id="5790bf8249cfb740e1105f12c204270f7d624a65" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt; . If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt; . See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="translated">El resto de categor&amp;iacute;as de configuraci&amp;oacute;n regional no las utiliza actualmente Perl. Pero nuevamente tenga en cuenta que las cosas con las que interact&amp;uacute;a Perl pueden usarlas, incluidas las extensiones fuera de la distribuci&amp;oacute;n est&amp;aacute;ndar de Perl, y por el sistema operativo y sus utilidades. Tenga en cuenta especialmente que el valor de cadena de &lt;code&gt;$!&lt;/code&gt; y &lt;code&gt;LC_MESSAGES&lt;/code&gt; puede cambiar los mensajes de error dados por las utilidades externas . Si desea tener c&amp;oacute;digos de error port&amp;aacute;tiles, use &lt;code&gt;%!&lt;/code&gt; . Ver &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c93d95569d58cc954c309a9c37710dcae16b378b" translate="yes" xml:space="preserve">
          <source>The remaining locale categories are not currently used by Perl itself. But again note that things Perl interacts with may use these, including extensions outside the standard Perl distribution, and by the operating system and its utilities. Note especially that the string value of &lt;code&gt;$!&lt;/code&gt; and the error messages given by external utilities may be changed by &lt;code&gt;LC_MESSAGES&lt;/code&gt;. If you want to have portable error codes, use &lt;code&gt;%!&lt;/code&gt;. See &lt;a href=&quot;errno&quot;&gt;Errno&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f593d82b22de04a34fb6b00553893736966b088" translate="yes" xml:space="preserve">
          <source>The remaining three arguments to &lt;code&gt;autosplit&lt;/code&gt; govern other options to the autosplitter.</source>
          <target state="translated">Los tres argumentos restantes para la &lt;code&gt;autosplit&lt;/code&gt; gobiernan otras opciones para la divisi&amp;oacute;n autom&amp;aacute;tica.</target>
        </trans-unit>
        <trans-unit id="359f225886acbac14791dc5bc2f8daf71a950d7f" translate="yes" xml:space="preserve">
          <source>The remaining transformations (e.g. hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) are left as an exercise to the inclined reader.</source>
          <target state="translated">Las transformaciones restantes (por ejemplo, hex -&amp;gt; oct, bin -&amp;gt; hex, etc.) se dejan como ejercicio para el lector inclinado.</target>
        </trans-unit>
        <trans-unit id="24d565f51a3155e5d1586b0499680351e5378dc6" translate="yes" xml:space="preserve">
          <source>The repeat count for &lt;code&gt;u&lt;/code&gt; is interpreted as the maximal number of bytes to encode per line of output, with 0, 1 and 2 replaced by 45. The repeat count should not be more than 65.</source>
          <target state="translated">El recuento de repeticiones para &lt;code&gt;u&lt;/code&gt; se interpreta como el n&amp;uacute;mero m&amp;aacute;ximo de bytes a codificar por l&amp;iacute;nea de salida, con 0, 1 y 2 reemplazados por 45. El recuento de repeticiones no debe ser superior a 65.</target>
        </trans-unit>
        <trans-unit id="f593cdc0477b84a5d137272da930d89fe6995081" translate="yes" xml:space="preserve">
          <source>The repertoire of characters that Perl can represent is a superset of those defined by the Unicode Consortium. On most platforms the ordinal values of a character as returned by &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; is the</source>
          <target state="translated">El repertorio de caracteres que puede representar Perl es un superconjunto de los definidos por Unicode Consortium. En la mayor&amp;iacute;a de las plataformas, los valores ordinales de un car&amp;aacute;cter devueltos por &lt;code&gt;ord(&lt;i&gt;S&lt;/i&gt;)&lt;/code&gt; son los</target>
        </trans-unit>
        <trans-unit id="b4becab04b9eae1dfa2922434e872f92f0ca7ffd" translate="yes" xml:space="preserve">
          <source>The replacement UNIVERSAL::VERSION, when used as a function, like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b90d7584bfb12af61e5f1ab0554e525a346ffd6" translate="yes" xml:space="preserve">
          <source>The report generated is in the following format:</source>
          <target state="translated">El informe generado tiene el siguiente formato:</target>
        </trans-unit>
        <trans-unit id="c18cb003bcf6566604f8240405fff42c4ea43f6c" translate="yes" xml:space="preserve">
          <source>The report is then grouped by the &lt;b&gt;Package&lt;/b&gt; of each variable, subroutine or format with the special case &quot;(lexicals)&quot; meaning lexical variables. Each &lt;b&gt;object&lt;/b&gt; name (implicitly qualified by its containing &lt;b&gt;Package&lt;/b&gt;) includes its type character(s) at the beginning where possible. Lexical variables are easier to track and even included dereferencing information where possible.</source>
          <target state="translated">El informe luego se agrupa por el &lt;b&gt;paquete&lt;/b&gt; de cada variable, subrutina o formato con el caso especial &quot;(l&amp;eacute;xicos)&quot; que significa variables l&amp;eacute;xicas. Cada nombre de &lt;b&gt;objeto&lt;/b&gt; (calificado impl&amp;iacute;citamente por el &lt;b&gt;paquete que lo&lt;/b&gt; contiene ) incluye su (s) car&amp;aacute;cter (es) de tipo al principio cuando es posible. Las variables l&amp;eacute;xicas son m&amp;aacute;s f&amp;aacute;ciles de rastrear e incluso incluyen informaci&amp;oacute;n de desreferenciaci&amp;oacute;n cuando es posible.</target>
        </trans-unit>
        <trans-unit id="a2f4b71d3df1e22731185a4eb5f4e73af9bf14da" translate="yes" xml:space="preserve">
          <source>The report with</source>
          <target state="translated">El informe con</target>
        </trans-unit>
        <trans-unit id="32baff471ed8eb8f5ceead8f0fa06a41ab81b875" translate="yes" xml:space="preserve">
          <source>The request was judged to be small, so the possibility to trap it depends on the way perl was compiled. By default it is not trappable. However, if compiled for this, Perl may use the contents of &lt;code&gt;$^M&lt;/code&gt; as an emergency pool after die()ing with this message. In this case the error is trappable</source>
          <target state="translated">Se consider&amp;oacute; que la solicitud era peque&amp;ntilde;a, por lo que la posibilidad de atraparla depende de la forma en que se compil&amp;oacute; perl. Por defecto, no se puede atrapar. Sin embargo, si se compila para esto, Perl puede usar el contenido de &lt;code&gt;$^M&lt;/code&gt; como un grupo de emergencia despu&amp;eacute;s de morir () con este mensaje. En este caso, el error es atrapable.</target>
        </trans-unit>
        <trans-unit id="e06f7be9330cffa7a55aee96bfbe8c1e1072f6a9" translate="yes" xml:space="preserve">
          <source>The requests do not necessarily go always all the way down to the operating system: that's where PerlIO buffering comes into play.</source>
          <target state="translated">Las solicitudes no siempre llegan hasta el sistema operativo:ahí es donde entra en juego el buffer de PerlIO.</target>
        </trans-unit>
        <trans-unit id="c2923a29c348a827f2ff3da1221b43b0a603bfa9" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d362ada26ee954875bdcbdb4ef3110ff77e350ef" translate="yes" xml:space="preserve">
          <source>The require function will actually look for the &quot;</source>
          <target state="translated">La función &quot;Requerir&quot; buscará en realidad el &quot;</target>
        </trans-unit>
        <trans-unit id="437fdd0ce3dd49b0cb6d8dbfa1617238f6bfc689" translate="yes" xml:space="preserve">
          <source>The require function will look for the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7925470de731575e163d706573142112baceaaab" translate="yes" xml:space="preserve">
          <source>The require function will look for the &quot;</source>
          <target state="translated">La función &quot;Requerir&quot; buscará el &quot;</target>
        </trans-unit>
        <trans-unit id="a4dd4536ee0a716833e52164851f465f831c0d1d" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt; ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="translated">Los argumentos necesarios durante el &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; son el hash, el paquete y la referencia a la funci&amp;oacute;n de &lt;code&gt;FETCH&lt;/code&gt; . Los argumentos opcionales son un $ data escalar arbitrario, la referencia a la funci&amp;oacute;n &lt;code&gt;EXISTS&lt;/code&gt; y los valores iniciales del hash y de la cach&amp;eacute; de existencia.</target>
        </trans-unit>
        <trans-unit id="72b681659bb57f7021407ce5fd3ac4d104c48565" translate="yes" xml:space="preserve">
          <source>The required arguments during &lt;code&gt;tie&lt;/code&gt; are the hash, the package, and the reference to the &lt;code&gt;FETCH&lt;/code&gt;ing function. The optional arguments are an arbitrary scalar $data, the reference to the &lt;code&gt;EXISTS&lt;/code&gt; function, and initial values of the hash and of the existence cache.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="37cc4a6beddbd481d62d1aa4fb0c7078c9745a11" translate="yes" xml:space="preserve">
          <source>The requires and build_requires dependency declarations</source>
          <target state="translated">El requires and build_requires declaraciones de dependencia</target>
        </trans-unit>
        <trans-unit id="68eca29cf3cefa1ee83b5c875c176fa92ac4b217" translate="yes" xml:space="preserve">
          <source>The rest is duplicate code from MM_Unix. Should move the linker code to its own method.</source>
          <target state="translated">El resto es código duplicado de MM_Unix.Debería mover el código del enlazador a su propio método.</target>
        </trans-unit>
        <trans-unit id="5f0ee77d23f152cd1591836db1cbf485219544f6" translate="yes" xml:space="preserve">
          <source>The rest is for internal usage of this package. In particular, if TIEHASH is overwritten, it should call SUPER::TIEHASH.</source>
          <target state="translated">El resto es para uso interno de este paquete.En particular,si TIEHASH es sobrescrito,debería llamar a SUPER::TIEHASH.</target>
        </trans-unit>
        <trans-unit id="fe2906e8b2561874cbab3bd035dddc47777e922a" translate="yes" xml:space="preserve">
          <source>The rest of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf6a19c74f24c99c3610c0c4323af3d860d85c2f" translate="yes" xml:space="preserve">
          <source>The rest of the .pm file contains sample code for providing documentation for the extension.</source>
          <target state="translated">El resto del archivo .pm contiene un código de muestra para proporcionar la documentación de la extensión.</target>
        </trans-unit>
        <trans-unit id="7c74ae28959473b4a69a8f31fe847650cadce3cf" translate="yes" xml:space="preserve">
          <source>The rest of the META.yml file is one big YAML &lt;a href=&quot;http://yaml.org/spec/history/2002-10-31.html#syntax-mapping&quot;&gt;mapping&lt;/a&gt;, whose keys are described here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a0a96f4412d084abe1abbbb705cc005b4d7612f" translate="yes" xml:space="preserve">
          <source>The rest of the function description may be indented or left-adjusted. The following example shows a function with its body left-adjusted. Most examples in this document will indent the body for better readability.</source>
          <target state="translated">El resto de la descripción de la función puede estar indentada o ajustada a la izquierda.El siguiente ejemplo muestra una función con su cuerpo ajustado a la izquierda.La mayoría de los ejemplos de este documento sangrarán el cuerpo para una mejor legibilidad.</target>
        </trans-unit>
        <trans-unit id="4748c8c8a6af67adc5b974371e823f12ce953a5d" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please email comments to &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt;.</source>
          <target state="translated">Es posible que sea necesario actualizar el resto de esta secci&amp;oacute;n, pero no sabemos qu&amp;eacute; deber&amp;iacute;a decir. Env&amp;iacute;e sus comentarios por correo electr&amp;oacute;nico a &lt;a href=&quot;http://search.cpan.org/perldoc/mailto:perlbug@perl.org&quot;&gt;perlbug@perl.org&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b6c6c6a28aca9f64e81536b5041a7bd3a852dd99" translate="yes" xml:space="preserve">
          <source>The rest of this section may need updating, but we don't know what it should say. Please submit comments to &lt;a href=&quot;https://github.com/Perl/perl5/issues&quot;&gt;https://github.com/Perl/perl5/issues&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd5215ed25fc6b559f1f45b7ad436f4f9831272e" translate="yes" xml:space="preserve">
          <source>The rest which are already available are based upon the vendor mappings at &lt;a href=&quot;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f01295182848e9dbbe34960bfb27f883cc4035bb" translate="yes" xml:space="preserve">
          <source>The rest which are already available are based upon the vendor mappings at &lt;a href=&quot;https://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&quot;&gt;http://www.unicode.org/Public/MAPPINGS/VENDORS/APPLE/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a3cb44cf97eef964df25c82472ad386e80122021" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt; .</source>
          <target state="translated">El reinicio se implement&amp;oacute; previamente usando un &lt;code&gt;longjmp&lt;/code&gt; en &lt;code&gt;regatom()&lt;/code&gt; nuevo a un &lt;code&gt;setjmp&lt;/code&gt; en &lt;code&gt;Perl_re_op_compile()&lt;/code&gt; , pero esto result&amp;oacute; ser problem&amp;aacute;tico ya que esta &amp;uacute;ltima es una funci&amp;oacute;n grande que contiene muchas variables autom&amp;aacute;ticas, que interact&amp;uacute;an mal con el flujo de control emergente de &lt;code&gt;setjmp&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0cb3a75ceb2d2ee1d3bf90c88d2151a6541e047d" translate="yes" xml:space="preserve">
          <source>The restart was previously implemented using a &lt;code&gt;longjmp&lt;/code&gt; in &lt;code&gt;regatom()&lt;/code&gt; back to a &lt;code&gt;setjmp&lt;/code&gt; in &lt;code&gt;Perl_re_op_compile()&lt;/code&gt;, but this proved to be problematic as the latter is a large function containing many automatic variables, which interact badly with the emergent control flow of &lt;code&gt;setjmp&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5e8310b48c79e713f14decd4088c7da40b8f8d5f" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt; . In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="translated">La restricci&amp;oacute;n para la operaci&amp;oacute;n de comparaci&amp;oacute;n es que incluso si, por ejemplo, &lt;code&gt;cmp&lt;/code&gt; devuelve una referencia bendecida, la funci&amp;oacute;n &lt;code&gt;lt&lt;/code&gt; autogenerada producir&amp;aacute; solo un valor l&amp;oacute;gico est&amp;aacute;ndar basado en el valor num&amp;eacute;rico del resultado de &lt;code&gt;cmp&lt;/code&gt; . En particular, en este caso se necesita una conversi&amp;oacute;n num&amp;eacute;rica funcional (posiblemente expresada en t&amp;eacute;rminos de otras conversiones).</target>
        </trans-unit>
        <trans-unit id="f937ca260b1eebc06f72a3641b2c030503e4317b" translate="yes" xml:space="preserve">
          <source>The restriction for the comparison operation is that even if, for example, &lt;code&gt;cmp&lt;/code&gt; should return a blessed reference, the autogenerated &lt;code&gt;lt&lt;/code&gt; function will produce only a standard logical value based on the numerical value of the result of &lt;code&gt;cmp&lt;/code&gt;. In particular, a working numeric conversion is needed in this case (possibly expressed in terms of other conversions).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17095fb32ad5dc43587aca28eee99cc6fee8a6b5" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;$^R&lt;/code&gt; is automatically localized, so that it will behave properly in the presence of backtracking.</source>
          <target state="translated">El resultado &lt;code&gt;$^R&lt;/code&gt; se localiza autom&amp;aacute;ticamente, de modo que se comportar&amp;aacute; correctamente en presencia de retroceso.</target>
        </trans-unit>
        <trans-unit id="917b4b2d464d47448ca46f205a594a1f2094a00d" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El resultado &lt;code&gt;Regexp&lt;/code&gt; indica que el argumento es una expresi&amp;oacute;n regular resultante de &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1beec82c5ad986daa3005ca6feae967035c22b78" translate="yes" xml:space="preserve">
          <source>The result &lt;code&gt;Regexp&lt;/code&gt; indicates that the argument is a regular expression resulting from &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El resultado &lt;code&gt;Regexp&lt;/code&gt; indica que el argumento es una expresi&amp;oacute;n regular resultante de &lt;code&gt;&lt;a href=&quot;qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fa60f0453236256bf9eae460e1101cb5ebaf3da0" translate="yes" xml:space="preserve">
          <source>The result has a dual nature: it is a NaN, but it also carries the integer inside it. The integer can be retrieved with &lt;a href=&quot;#getpayload&quot;&gt;&quot;getpayload&quot;&lt;/a&gt;. Note, though, that the payload is not propagated, not even on copies, and definitely not in arithmetic operations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="413c5704399ec4e320c4b4de62416c60414146e3" translate="yes" xml:space="preserve">
          <source>The result is returned as two arguments. If the modular multiplicative inverse does not exist, both arguments are undefined. Otherwise, the arguments are a number (object) and its sign (&quot;+&quot; or &quot;-&quot;).</source>
          <target state="translated">El resultado se devuelve como dos argumentos.Si el inverso multiplicativo modular no existe,ambos argumentos no están definidos.En caso contrario,los argumentos son un número (objeto)y su signo (&quot;+&quot; o &quot;-&quot;).</target>
        </trans-unit>
        <trans-unit id="e2176289afdf7f655c62c369888f79d214a9f024" translate="yes" xml:space="preserve">
          <source>The result is that the contents of line 17 of the file will be replaced with &quot;Cherry pie&quot;; a newline character will separate line 17 from line 18. This means that this code will do nothing:</source>
          <target state="translated">El resultado es que el contenido de la línea 17 del archivo será reemplazado por &quot;Pastel de cereza&quot;;un nuevo carácter de línea separará la línea 17 de la 18.Esto significa que este código no hará nada:</target>
        </trans-unit>
        <trans-unit id="f863b8e99992f5c2a779d9ed98aecf9cef5b7a84" translate="yes" xml:space="preserve">
          <source>The result is the Unicode character or character sequence given by</source>
          <target state="translated">El resultado es el carácter o secuencia de caracteres Unicode dado por</target>
        </trans-unit>
        <trans-unit id="f066226510a6a63558092d6e0a75383b46653b7b" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17faf27e0d190c0297fec9a5baff8ccb279e91a8" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">El resultado es el car&amp;aacute;cter especificado por el n&amp;uacute;mero hexadecimal entre llaves. Consulte &lt;a href=&quot;#%5b8%5d&quot;&gt;[8] a&lt;/a&gt; continuaci&amp;oacute;n para obtener detalles sobre qu&amp;eacute; personaje.</target>
        </trans-unit>
        <trans-unit id="7238c8e2e1333323c2dd62857b981306a7706e6a" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1743ff5152c2110b7544e70901f154f3b6b46b92" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the hexadecimal number in the range 0x00 to 0xFF. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">El resultado es el car&amp;aacute;cter especificado por el n&amp;uacute;mero hexadecimal en el rango de 0x00 a 0xFF. Consulte &lt;a href=&quot;#%5b8%5d&quot;&gt;[8] a&lt;/a&gt; continuaci&amp;oacute;n para obtener detalles sobre qu&amp;eacute; personaje.</target>
        </trans-unit>
        <trans-unit id="d86f6bbcc0ec2a19c70956057e4d3cc4063fc333" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6bbe820fb63fd799e4d92d37fd1768342fc0ad13" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the octal number between the braces. See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">El resultado es el car&amp;aacute;cter especificado por el n&amp;uacute;mero octal entre llaves. Consulte &lt;a href=&quot;#%5b8%5d&quot;&gt;[8] a&lt;/a&gt; continuaci&amp;oacute;n para obtener detalles sobre qu&amp;eacute; personaje.</target>
        </trans-unit>
        <trans-unit id="2ca77b886ca2262e5c2630425a0b7e07037d32d3" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5B8%5D&quot;&gt;&quot;[8]&quot;&lt;/a&gt; below for details on which character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5d07b8bddc1c5dd823f98677754aff0c68b0c00" translate="yes" xml:space="preserve">
          <source>The result is the character specified by the three-digit octal number in the range 000 to 777 (but best to not use above 077, see next paragraph). See &lt;a href=&quot;#%5b8%5d&quot;&gt;[8]&lt;/a&gt; below for details on which character.</source>
          <target state="translated">El resultado es el car&amp;aacute;cter especificado por el n&amp;uacute;mero octal de tres d&amp;iacute;gitos en el rango de 000 a 777 (pero es mejor no usar por encima de 077, consulte el p&amp;aacute;rrafo siguiente). Consulte &lt;a href=&quot;#%5b8%5d&quot;&gt;[8] a&lt;/a&gt; continuaci&amp;oacute;n para obtener detalles sobre qu&amp;eacute; personaje.</target>
        </trans-unit>
        <trans-unit id="4d2ac189a7b892d497c3a957f821832172806b14" translate="yes" xml:space="preserve">
          <source>The result is the same as &lt;code&gt;xhdr&lt;/code&gt; except the is will be restricted to headers where the text of the header matches &lt;code&gt;PATTERN&lt;/code&gt;</source>
          <target state="translated">El resultado es el mismo que &lt;code&gt;xhdr&lt;/code&gt; excepto que estar&amp;aacute; restringido a encabezados donde el texto del encabezado coincide con &lt;code&gt;PATTERN&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="37186ac3e81998654b9034f359d33c97b138b201" translate="yes" xml:space="preserve">
          <source>The result may be used as a subpattern in a match:</source>
          <target state="translated">El resultado puede ser utilizado como un subpatrón en un partido:</target>
        </trans-unit>
        <trans-unit id="aea5a1ac74300d067b63729d12ad0881314aa59c" translate="yes" xml:space="preserve">
          <source>The result of each test is captured in a hash. These hashes are the same as the hashes returned by Test::Builder-&amp;gt;details but with a couple of extra fields.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30a38c7996159062562ab2957a6c23713b7a1d86" translate="yes" xml:space="preserve">
          <source>The result of evaluation of the last successful &lt;code&gt;(?{ code })&lt;/code&gt; regular expression assertion (see &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt;). May be written to.</source>
          <target state="translated">El resultado de la evaluaci&amp;oacute;n de la &amp;uacute;ltima afirmaci&amp;oacute;n de expresi&amp;oacute;n regular exitosa &lt;code&gt;(?{ code })&lt;/code&gt; (ver &lt;a href=&quot;perlre&quot;&gt;perlre&lt;/a&gt; ). Puede escribirse a.</target>
        </trans-unit>
        <trans-unit id="66611e861a602cfa60591a93b737577becd37f08" translate="yes" xml:space="preserve">
          <source>The result of great_circle_direction is in radians, zero indicating straight north, pi or -pi straight south, pi/2 straight west, and -pi/2 straight east.</source>
          <target state="translated">El resultado de la dirección del gran_círculo está en radianes,el cero indica la recta norte,pi o -pi recta sur,pi/2 recta oeste,y -pi/2 recta este.</target>
        </trans-unit>
        <trans-unit id="f6846ed84b71cca2d8b5fb5477773187fbddddb3" translate="yes" xml:space="preserve">
          <source>The result of md5(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) will be exactly the same as the result of md5(&quot;abc&quot;).</source>
          <target state="translated">El resultado de md5(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;)será exactamente el mismo que el resultado de md5(&quot;abc&quot;).</target>
        </trans-unit>
        <trans-unit id="641d055cafe1e1ee3cae38ce56b7935f5d3bc2b3" translate="yes" xml:space="preserve">
          <source>The result of overflowing the range of the integers is undefined because it is undefined also in C. In other words, using 32-bit integers, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; is undefined. Shifting by a negative number of bits is also undefined.</source>
          <target state="translated">El resultado de desbordar el rango de los enteros no est&amp;aacute; definido porque tampoco est&amp;aacute; definido en C. En otras palabras, si se utilizan enteros de 32 bits, &lt;code&gt;1 &amp;lt;&amp;lt; 32&lt;/code&gt; no est&amp;aacute; definido. El desplazamiento de un n&amp;uacute;mero negativo de bits tampoco est&amp;aacute; definido.</target>
        </trans-unit>
        <trans-unit id="00de3247a1fa0dbaa5340672e75fce7f76fa569f" translate="yes" xml:space="preserve">
          <source>The result of this scenario is at best a database that doesn't contain what you expect. At worst the database will corrupt.</source>
          <target state="translated">El resultado de este escenario es,en el mejor de los casos,una base de datos que no contiene lo que esperas.En el peor de los casos,la base de datos se corromperá.</target>
        </trans-unit>
        <trans-unit id="f6de57c3d8ec6b1611fc0077d370dda9fed1574d" translate="yes" xml:space="preserve">
          <source>The result returned will be one of the following:</source>
          <target state="translated">El resultado devuelto será uno de los siguientes:</target>
        </trans-unit>
        <trans-unit id="0b8a9a1357d52322f675cb2cb87488ac744f63b6" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="translated">La cadena de resultado que contiene material interpolado est&amp;aacute; contaminada si est&amp;aacute; en vigor un formulario de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; que incluye &lt;code&gt;LC_CTYPE&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="dc181363eb40ff0bd863bde77567e9656e7a29d5" translate="yes" xml:space="preserve">
          <source>The result string containing interpolated material is tainted if a &lt;code&gt;use locale&lt;/code&gt; form that includes &lt;code&gt;LC_CTYPE&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51fb17ca190a73d84710650cb1a592da2c670185" translate="yes" xml:space="preserve">
          <source>The result will be an array of 3 elements, each a reference to an array which will hold the handles that are ready for reading, writing and have exceptions respectively. Upon error an empty list is returned.</source>
          <target state="translated">El resultado será un conjunto de 3 elementos,cada uno de ellos una referencia a un conjunto que contendrá los asideros que están listos para la lectura,la escritura y tienen excepciones respectivamente.En caso de error se devuelve una lista vacía.</target>
        </trans-unit>
        <trans-unit id="a68ddca584ffd166b11e615f1b961f7dd364600e" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="translated">El resultado ser&amp;aacute; hasta tres veces el n&amp;uacute;mero de capas: el primer elemento ser&amp;aacute; un nombre, el segundo elemento los argumentos (los argumentos no especificados ser&amp;aacute;n &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ), el tercer elemento las banderas, el cuarto elemento un nombre nuevamente, y as&amp;iacute; adelante.</target>
        </trans-unit>
        <trans-unit id="3e9d88696af53de04206c2554e1cd6a14550e72c" translate="yes" xml:space="preserve">
          <source>The result will be up to be three times the number of layers: the first element will be a name, the second element the arguments (unspecified arguments will be &lt;code&gt;undef&lt;/code&gt;), the third element the flags, the fourth element a name again, and so forth.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6e0c7dba94f1684aba5f4cd6501d599a99358de" translate="yes" xml:space="preserve">
          <source>The resulting $subdir_cmd has no leading tab nor trailing newline. This makes it easier to embed in a make string. For example.</source>
          <target state="translated">El $subdir_cmd resultante no tiene una pestaña principal ni una línea nueva posterior.Esto hace más fácil de incrustar en una cadena de fabricación.Por ejemplo.</target>
        </trans-unit>
        <trans-unit id="5f6fcb4f54789b9c880bc0144fb1cf2ebd3b3159" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; values of this string's bytes - the &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="translated">La secuencia de bytes resultante es m&amp;aacute;s conveniente para verificar la suma de verificaci&amp;oacute;n. No ralentice su programa con un bucle for agregando los valores &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; de los bytes de esta cadena; el c&amp;oacute;digo de &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; &lt;code&gt;%&lt;/code&gt; es lo que debe usar para calcular la suma de 8 bits de todos los bytes, que debe ser igual a cero:</target>
        </trans-unit>
        <trans-unit id="7e685873aa2576bcd6d048591b67cf99d300730d" translate="yes" xml:space="preserve">
          <source>The resulting byte sequence is most convenient for checking the checksum. Don't slow your program down with a for loop adding the &lt;code&gt;ord&lt;/code&gt; values of this string's bytes - the &lt;code&gt;unpack&lt;/code&gt; code &lt;code&gt;%&lt;/code&gt; is the thing to use for computing the 8-bit sum of all bytes, which must be equal to zero:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="421b5462923e8d16da2f8509620d57a56b898133" translate="yes" xml:space="preserve">
          <source>The resulting path is relative by default, i.e. the resulting path will have a leading colon.</source>
          <target state="translated">El camino resultante es relativo por defecto,es decir,el camino resultante tendrá un colon de avance.</target>
        </trans-unit>
        <trans-unit id="d4b19b5c805ca56f431cfbcdeba1af9f3a6200a3" translate="yes" xml:space="preserve">
          <source>The resulting program then looks like:</source>
          <target state="translated">El programa resultante entonces parece:</target>
        </trans-unit>
        <trans-unit id="e4aa8c76073812eb40b9e292fb100c683926c76e" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;&quot;catpath&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd638c59c5752a7ccfc83a3bf825d1784299cda6" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">Los resultados se pueden pasar a &lt;a href=&quot;#catpath&quot;&gt;catpath&lt;/a&gt; para recuperar una ruta equivalente (generalmente id&amp;eacute;ntica) a la ruta original.</target>
        </trans-unit>
        <trans-unit id="156c1084cc95fa3e7b597345b8d09fde064a081b" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath%28%29&quot;&gt;&quot;catpath()&quot;&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbae74b52e9e1a2f4034868dc967236dfb097109" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;a href=&quot;#catpath()&quot;&gt;catpath()&lt;/a&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">Los resultados se pueden pasar a &lt;a href=&quot;#catpath()&quot;&gt;catpath ()&lt;/a&gt; para recuperar una ruta equivalente (generalmente id&amp;eacute;ntica) a la ruta original.</target>
        </trans-unit>
        <trans-unit id="9fd6f04fef4668c0fb9b5436580855adbbe256e9" translate="yes" xml:space="preserve">
          <source>The results can be passed to &lt;code&gt;catpath()&lt;/code&gt; to get back a path equivalent to (usually identical to) the original path.</source>
          <target state="translated">Los resultados se pueden pasar a &lt;code&gt;catpath()&lt;/code&gt; para recuperar una ruta equivalente (generalmente id&amp;eacute;ntica) a la ruta original.</target>
        </trans-unit>
        <trans-unit id="7b48baa73a171c70124bb46d586398a253fc305f" translate="yes" xml:space="preserve">
          <source>The results follow ASCII rules. Only the characters &lt;code&gt;A-Z&lt;/code&gt; change, to &lt;code&gt;a-z&lt;/code&gt; respectively.</source>
          <target state="translated">Los resultados siguen las reglas ASCII. Solo los caracteres &lt;code&gt;A-Z&lt;/code&gt; cambian, a &lt;code&gt;a-z&lt;/code&gt; respectivamente.</target>
        </trans-unit>
        <trans-unit id="e6e1386230ca5a3e137558786aef0b9ef4ab7b59" translate="yes" xml:space="preserve">
          <source>The results of creating new symbol table entries directly or modifying any entries that are not already typeglobs are undefined and subject to change between releases of perl.</source>
          <target state="translated">Los resultados de la creación de nuevas entradas de tablas de símbolos directamente o de la modificación de cualquier entrada que no sea ya tipografía,no están definidos y están sujetos a cambios entre las versiones de perl.</target>
        </trans-unit>
        <trans-unit id="7c1728e8e43393222dde9f78fe3123aaa1846fe7" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="translated">El retorno de &lt;code&gt;VERSION&lt;/code&gt; ser&amp;aacute; en realidad el objeto de versi&amp;oacute;n en cadena que usa el paquete &lt;code&gt;$VERSION&lt;/code&gt; escalar, que se garantiza que es equivalente pero puede que no sea precisamente el contenido del escalar &lt;code&gt;$VERSION&lt;/code&gt; . Si desea el contenido real de &lt;code&gt;$VERSION&lt;/code&gt; , use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; lugar.</target>
        </trans-unit>
        <trans-unit id="95e455ea284fe76f90c5b0d39ee105831c2e5eaa" translate="yes" xml:space="preserve">
          <source>The return from &lt;code&gt;VERSION&lt;/code&gt; will actually be the stringified version object using the package &lt;code&gt;$VERSION&lt;/code&gt; scalar, which is guaranteed to be equivalent but may not be precisely the contents of the &lt;code&gt;$VERSION&lt;/code&gt; scalar. If you want the actual contents of &lt;code&gt;$VERSION&lt;/code&gt;, use &lt;code&gt;$CLASS::VERSION&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94b2a16af23a66e19e44621474dc0fa990710d75" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="translated">La lista de retorno de la funci&amp;oacute;n Perl generada consta del valor de retorno C de la funci&amp;oacute;n (a menos que XSUB sea de tipo de retorno &lt;code&gt;void&lt;/code&gt; o se haya utilizado la &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; ) seguido de todos los par&amp;aacute;metros &lt;code&gt;OUTLIST&lt;/code&gt; e &lt;code&gt;IN_OUTLIST&lt;/code&gt; (en el orden de aparici&amp;oacute;n). A la vuelta del XSUB, el par&amp;aacute;metro Perl &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; se modificar&amp;aacute; para tener los valores escritos por la funci&amp;oacute;n C.</target>
        </trans-unit>
        <trans-unit id="44655e68104aa5b50fd85988b88ae70262129b43" translate="yes" xml:space="preserve">
          <source>The return list of the generated Perl function consists of the C return value from the function (unless the XSUB is of &lt;code&gt;void&lt;/code&gt; return type or &lt;code&gt;The NO_OUTPUT Keyword&lt;/code&gt; was used) followed by all the &lt;code&gt;OUTLIST&lt;/code&gt; and &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters (in the order of appearance). On the return from the XSUB the &lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; Perl parameter will be modified to have the values written by the C function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d71452936695d00a40f619faefe33e6d1a6ac20b" translate="yes" xml:space="preserve">
          <source>The return may be incorrect for those rare locales where the currency symbol replaces the radix character. Send email to &lt;a href=&quot;mailto:perlbug@perl.org&quot;&gt;mailto:perlbug@perl.org&lt;/a&gt; if you have examples of it needing to work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0420f753fa3324f9eec48f35a50efc8cee6a049e" translate="yes" xml:space="preserve">
          <source>The return points to a per-thread static buffer, which is overwritten the next time &lt;code&gt;Perl_setlocale&lt;/code&gt; is called from the same thread.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a21da59cc5c1c0e700b109e9dda17411cbacb1df" translate="yes" xml:space="preserve">
          <source>The return true when the argument satisfies the condition. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; are not integers and are neither odd nor even.</source>
          <target state="translated">Devuelve verdadero cuando el argumento satisface la condici&amp;oacute;n. &lt;code&gt;NaN&lt;/code&gt; , &lt;code&gt;+inf&lt;/code&gt; , &lt;code&gt;-inf&lt;/code&gt; no son n&amp;uacute;meros enteros y no son pares ni impares.</target>
        </trans-unit>
        <trans-unit id="b8bfaca788fa3c0ddbe45ea5ad9f0da16e79efb8" translate="yes" xml:space="preserve">
          <source>The return value (if defined) is a Perl object, of class &lt;code&gt;PerlIO::Layer&lt;/code&gt; which is created by the C code in</source>
          <target state="translated">El valor de retorno (si est&amp;aacute; definido) es un objeto Perl, de clase &lt;code&gt;PerlIO::Layer&lt;/code&gt; que es creado por el c&amp;oacute;digo C en</target>
        </trans-unit>
        <trans-unit id="45642a1469744a5e7107d7873a8272d52cfce5d2" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">El valor &lt;code&gt;LVALUE&lt;/code&gt; indica una referencia a un lvalue que no es una variable. Obtienes esto tomando la referencia de llamadas a funciones como &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;VSTRING&lt;/code&gt; se devuelve si la referencia apunta a una &lt;a href=&quot;perldata#Version-Strings&quot;&gt;cadena de versi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="68a59800451bff6b585d75aa0febce039f889432" translate="yes" xml:space="preserve">
          <source>The return value &lt;code&gt;LVALUE&lt;/code&gt; indicates a reference to an lvalue that is not a variable. You get this from taking the reference of function calls like &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt;. &lt;code&gt;VSTRING&lt;/code&gt; is returned if the reference points to a &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;version string&lt;/a&gt;.</source>
          <target state="translated">El valor &lt;code&gt;LVALUE&lt;/code&gt; indica una referencia a un lvalue que no es una variable. Obtienes esto tomando la referencia de llamadas a funciones como &lt;code&gt;&lt;a href=&quot;pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;substr&quot;&gt;substr()&lt;/a&gt;&lt;/code&gt; . &lt;code&gt;VSTRING&lt;/code&gt; se devuelve si la referencia apunta a una &lt;a href=&quot;../perldata#Version-Strings&quot;&gt;cadena de versi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d1b1a3b59d37e5fda7fca51bd6d7cc822e1098fc" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="translated">El valor de retorno se puede &lt;code&gt;&lt;a href=&quot;../functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; uar para obtener una copia id&amp;eacute;ntica de la estructura de referencia original. (&amp;iexcl;Considere las implicaciones de seguridad de evaluar c&amp;oacute;digo de fuentes no confiables!)</target>
        </trans-unit>
        <trans-unit id="341077e987e38231c6848bd510801f6ac305a364" translate="yes" xml:space="preserve">
          <source>The return value can be &lt;code&gt;eval&lt;/code&gt;ed to get back an identical copy of the original reference structure. (Please do consider the security implications of eval'ing code from untrusted sources!)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5ce36c299811e6d9af00c0cefc9c75e073456ac7" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">El valor de retorno de &lt;code&gt;&lt;a href=&quot;atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; est&amp;aacute; definido por la implementaci&amp;oacute;n; consulte su p&amp;aacute;gina de manual de atan2 (3) para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="769d902022de1a90d1cd24370f703e7b45d5dad4" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; is implementation-defined; consult your atan2(3) manpage for more information.</source>
          <target state="translated">El valor de retorno de &lt;code&gt;&lt;a href=&quot;functions/atan2&quot;&gt;atan2(0,0)&lt;/a&gt;&lt;/code&gt; est&amp;aacute; definido por la implementaci&amp;oacute;n; consulte su p&amp;aacute;gina de manual de atan2 (3) para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="3f7e47c80e390cbc99d4bd2d52e4ac31f1eae4a5" translate="yes" xml:space="preserve">
          <source>The return value for &lt;code&gt;atan2(0,0)&lt;/code&gt; is implementation-defined; consult your &lt;a href=&quot;http://man.he.net/man3/atan2&quot;&gt;atan2(3)&lt;/a&gt; manpage for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7fa7da95c4b58e8bb23e135f8795df5f9ac97aa0" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt; .</source>
          <target state="translated">El valor de retorno es &lt;code&gt;true&lt;/code&gt; si se trata de un prototipo v&amp;aacute;lido y &lt;code&gt;false&lt;/code&gt; si no lo es, independientemente de si &lt;code&gt;&lt;a href=&quot;functions/warn&quot;&gt;warn&lt;/a&gt;&lt;/code&gt; fue &lt;code&gt;true&lt;/code&gt; o &lt;code&gt;false&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5c3cd7efde35a3e831a5bdd29d0ed5265715cc55" translate="yes" xml:space="preserve">
          <source>The return value is &lt;code&gt;true&lt;/code&gt; if this is a valid prototype, and &lt;code&gt;false&lt;/code&gt; if it is not, regardless of whether &lt;code&gt;warn&lt;/code&gt; was &lt;code&gt;true&lt;/code&gt; or &lt;code&gt;false&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd97a8975a72082d0544ff1e498721e427862ae3" translate="yes" xml:space="preserve">
          <source>The return value is POSIX-like (shifted up by 8 bits), which only allows room for a made-up value derived from the severity bits of the native 32-bit condition code (unless overridden by &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; ). If the native condition code is one that has a POSIX value encoded, the POSIX value will be decoded to extract the expected exit value. For more details see &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? in perlvms&lt;/a&gt;. (VMS)</source>
          <target state="translated">El valor de retorno es similar a POSIX (desplazado hacia arriba en 8 bits), que solo deja espacio para un valor inventado derivado de los bits de gravedad del c&amp;oacute;digo de condici&amp;oacute;n nativo de 32 bits (a menos que se &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; vmsish 'status'&lt;/code&gt; mediante el &lt;a href=&quot;functions/use&quot;&gt;uso de&lt;/a&gt; vmsish 'status' ). Si el c&amp;oacute;digo de condici&amp;oacute;n nativo es uno que tiene un valor POSIX codificado, el valor POSIX se decodificar&amp;aacute; para extraer el valor de salida esperado. Para obtener m&amp;aacute;s detalles, consulte &lt;a href=&quot;perlvms#%24%3f&quot;&gt;$? en perlvms&lt;/a&gt; . (VMS)</target>
        </trans-unit>
        <trans-unit id="38f16262d38a09b1b50bf9932e5e395bae210a67" translate="yes" xml:space="preserve">
          <source>The return value is a boolean: TRUE if the global locale at the time of call was in effect; and FALSE if a per-thread locale was in effect. This can be used by the caller that needs to restore things as-they-were to decide whether or not to call &lt;a href=&quot;perlapi#switch_to_global_locale&quot;&gt;&lt;code&gt;Perl_switch_to_global_locale&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f7f3af5a62c5a74bbd990f1648eb2762ff5d0f59" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43901da674d6737b62ebf11f4c04c938005307af" translate="yes" xml:space="preserve">
          <source>The return value is always a scalar, either a string or a number. For properties where there are synonyms for the values, the synonym returned by this function is the longest, most descriptive form, the one returned by &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; when called in a scalar context. Of course, you can call &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; on the result to get other synonyms.</source>
          <target state="translated">El valor de retorno es siempre un escalar, ya sea una cadena o un n&amp;uacute;mero. Para las propiedades donde hay sin&amp;oacute;nimos para los valores, el sin&amp;oacute;nimo devuelto por esta funci&amp;oacute;n es la forma m&amp;aacute;s larga y descriptiva, la devuelta por &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; cuando se llama en un contexto escalar. Por supuesto, puede llamar a &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; en el resultado para obtener otros sin&amp;oacute;nimos.</target>
        </trans-unit>
        <trans-unit id="897578330f8509b5163b4447af0b4daff044a33c" translate="yes" xml:space="preserve">
          <source>The return value is formatted according to OLE conventions, as groups of hex digits with surrounding braces. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01e2753bab1a4f25f52114a02dccb7b840c45d95" translate="yes" xml:space="preserve">
          <source>The return value is the $ctx object itself.</source>
          <target state="translated">El valor de retorno es el propio objeto $ctx.</target>
        </trans-unit>
        <trans-unit id="437a2be9f2de32d0576eb59aa85a5731812472a7" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;a href=&quot;#wait&quot;&gt;&lt;code&gt;wait&lt;/code&gt;&lt;/a&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec-LIST&quot;&gt;&lt;code&gt;exec&lt;/code&gt;&lt;/a&gt;. This is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52ee5d406f163544969cdcc538ef722336dcb763" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">El valor de retorno es el estado de salida del programa devuelto por la llamada de &lt;code&gt;&lt;a href=&quot;functions/wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; . Para obtener el valor de salida real, cambie ocho a la derecha (ver m&amp;aacute;s abajo). V&amp;eacute;ase tambi&amp;eacute;n &lt;a href=&quot;#exec&quot;&gt;exec&lt;/a&gt; . Esto es</target>
        </trans-unit>
        <trans-unit id="aadd087b1069c48b3ff2e37ed0925a6bb732b05e" translate="yes" xml:space="preserve">
          <source>The return value is the exit status of the program as returned by the &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; call. To get the actual exit value, shift right by eight (see below). See also &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;. This is</source>
          <target state="translated">El valor de retorno es el estado de salida del programa devuelto por la llamada de &lt;code&gt;&lt;a href=&quot;wait&quot;&gt;wait&lt;/a&gt;&lt;/code&gt; . Para obtener el valor de salida real, cambie ocho a la derecha (ver m&amp;aacute;s abajo). V&amp;eacute;ase tambi&amp;eacute;n &lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt; . Esto es</target>
        </trans-unit>
        <trans-unit id="28ff84250f55ab2bea98fda52eb0b62db0c2d4bd" translate="yes" xml:space="preserve">
          <source>The return value is the total length &lt;code&gt;src&lt;/code&gt; would be if the copy completely succeeded. If it is larger than &lt;code&gt;size&lt;/code&gt;, the excess was not copied.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db618f76ec023ae4b98dae939007dd3399a79764" translate="yes" xml:space="preserve">
          <source>The return value is the total length that &lt;code&gt;dst&lt;/code&gt; would have if &lt;code&gt;size&lt;/code&gt; is sufficiently large. Thus it is the initial length of &lt;code&gt;dst&lt;/code&gt; plus the length of &lt;code&gt;src&lt;/code&gt;. If &lt;code&gt;size&lt;/code&gt; is smaller than the return, the excess was not appended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="857262cdace40b471947bb6d3b761ee596eafe64" translate="yes" xml:space="preserve">
          <source>The return value is the updated object itself.</source>
          <target state="translated">El valor de retorno es el propio objeto actualizado.</target>
        </trans-unit>
        <trans-unit id="7f93f7b8be78580a6fdb8b5153d679ad923050d6" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El valor de retorno puede ser una lista que contenga cero o m&amp;aacute;s de una referencia de matriz, un n&amp;uacute;mero entero o &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3f37d26524cdd675f6f08be05c61f9223fd0378a" translate="yes" xml:space="preserve">
          <source>The return value may be a list containing zero or more of an arrayref, an integer, or &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36fd088c56b8f88cc2d2e8985a8fda08a71a63d3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="translated">El valor de retorno puede ser una referencia de matriz de pesos 1 a 4 como se muestra arriba. El valor de retorno puede ser un n&amp;uacute;mero entero como peso principal como se muestra a continuaci&amp;oacute;n. Si se devuelve &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , se utilizar&amp;aacute; el elemento de clasificaci&amp;oacute;n derivado predeterminado.</target>
        </trans-unit>
        <trans-unit id="68d7e0ec957990f452acfaa57c18c8410bd4dda3" translate="yes" xml:space="preserve">
          <source>The return value may be an arrayref of 1st to 4th weights as shown above. The return value may be an integer as the primary weight as shown below. If &lt;code&gt;undef&lt;/code&gt; is returned, the default derived collation element will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="222fe952afa9c24172c89b0f769d4878a2ea7ad7" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#ioctl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;ioctl&lt;/code&gt;&lt;/a&gt; (and &lt;a href=&quot;#fcntl-FILEHANDLE%2CFUNCTION%2CSCALAR&quot;&gt;&lt;code&gt;fcntl&lt;/code&gt;&lt;/a&gt;) is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a717c20899094357a3bea685885351b6040d8de0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. &lt;a href=&quot;#tell-FILEHANDLE&quot;&gt;&lt;code&gt;tell&lt;/code&gt;&lt;/a&gt; on pipes, fifos, and sockets usually returns -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d5675dc8f958bc8634e0a1b5851a8577fc5c3bc" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">El valor de retorno de &lt;code&gt;&lt;a href=&quot;functions/ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (y &lt;code&gt;&lt;a href=&quot;functions/fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) es el siguiente:</target>
        </trans-unit>
        <trans-unit id="03abb254ae6958b0d4d3e3d838f5570ae93832e6" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (and &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt;) is as follows:</source>
          <target state="translated">El valor de retorno de &lt;code&gt;&lt;a href=&quot;ioctl&quot;&gt;ioctl&lt;/a&gt;&lt;/code&gt; (y &lt;code&gt;&lt;a href=&quot;fcntl&quot;&gt;fcntl&lt;/a&gt;&lt;/code&gt; ) es el siguiente:</target>
        </trans-unit>
        <trans-unit id="16085bf8175ff49a2dcc989db1bc66f5346f4ab0" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;INLINED&lt;/code&gt; in this example will always be 54321, regardless of later modifications to $x. You can also put any arbitrary code inside the sub, at it will be executed immediately and its return value captured the same way.</source>
          <target state="translated">El valor de retorno de &lt;code&gt;INLINED&lt;/code&gt; en este ejemplo siempre ser&amp;aacute; 54321, independientemente de las modificaciones posteriores a $ x. Tambi&amp;eacute;n puede poner cualquier c&amp;oacute;digo arbitrario dentro del sub, se ejecutar&amp;aacute; inmediatamente y su valor de retorno capturado de la misma manera.</target>
        </trans-unit>
        <trans-unit id="f23542316437f18c2dc0de0ad16ae0deb404671a" translate="yes" xml:space="preserve">
          <source>The return value of &lt;code&gt;survey&lt;/code&gt; is two hashes:</source>
          <target state="translated">El valor de retorno de la &lt;code&gt;survey&lt;/code&gt; es de dos valores hash:</target>
        </trans-unit>
        <trans-unit id="6c7d2d6bce6775764986b9434f93f3fd3d99f22b" translate="yes" xml:space="preserve">
          <source>The return value of Pod::Perldoc::GetOptsOO::getopts is true if no errors, otherwise it's false.</source>
          <target state="translated">El valor de retorno del Pod::Perldoc::GetOptsOO::getopts es verdadero si no hay errores,de lo contrario es falso.</target>
        </trans-unit>
        <trans-unit id="57cb77ff2698d7727be628530d185f8aa579f00d" translate="yes" xml:space="preserve">
          <source>The return value of tell() for the standard streams like the STDIN depends on the operating system: it may return -1 or something else. tell() on pipes, fifos, and sockets usually returns -1.</source>
          <target state="translated">El valor de retorno de tell()para los flujos estándar como el STDIN depende del sistema operativo:puede retornar -1 o algo más.tell()en tuberías,fifos,y sockets usualmente retorna -1.</target>
        </trans-unit>
        <trans-unit id="d4713d5655dc6e9b8c7a80e55df87e6a297b0b32" translate="yes" xml:space="preserve">
          <source>The return value will be &lt;code&gt;NULL&lt;/code&gt; if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt;. Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned &lt;code&gt;NULL&lt;/code&gt;. Effectively a successful &lt;code&gt;hv_store&lt;/code&gt; takes ownership of one reference to &lt;code&gt;val&lt;/code&gt;. This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, &lt;code&gt;hv_store&lt;/code&gt; will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. &lt;code&gt;hv_store&lt;/code&gt; is not implemented as a call to &lt;code&gt;hv_store_ent&lt;/code&gt;, and does not create a temporary SV for the key, so if your key data is not already in SV form then use &lt;code&gt;hv_store&lt;/code&gt; in preference to &lt;code&gt;hv_store_ent&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="972da9f747345510c81b2dc820fd0994a9799509" translate="yes" xml:space="preserve">
          <source>The return value will be NULL if the operation failed or if the value did not need to be actually stored within the hash (as in the case of tied hashes). Otherwise it can be dereferenced to get the original &lt;code&gt;SV*&lt;/code&gt; . Note that the caller is responsible for suitably incrementing the reference count of &lt;code&gt;val&lt;/code&gt; before the call, and decrementing it if the function returned NULL. Effectively a successful hv_store takes ownership of one reference to &lt;code&gt;val&lt;/code&gt; . This is usually what you want; a newly created SV has a reference count of one, so if all your code does is create SVs then store them in a hash, hv_store will own the only reference to the new SV, and your code doesn't need to do anything further to tidy up. hv_store is not implemented as a call to hv_store_ent, and does not create a temporary SV for the key, so if your key data is not already in SV form then use hv_store in preference to hv_store_ent.</source>
          <target state="translated">El valor de retorno ser&amp;aacute; NULL si la operaci&amp;oacute;n fall&amp;oacute; o si el valor no tuvo que almacenarse realmente dentro del hash (como en el caso de los hash vinculados). De lo contrario, se puede desreferenciar para obtener el &lt;code&gt;SV*&lt;/code&gt; original . Tenga en cuenta que la persona que llama es responsable de incrementar adecuadamente el recuento de referencia de &lt;code&gt;val&lt;/code&gt; antes de la llamada y de disminuirlo si la funci&amp;oacute;n devolvi&amp;oacute; NULL. Efectivamente, un hv_store exitoso se apropia de una referencia a &lt;code&gt;val&lt;/code&gt; . Esto suele ser lo que quieres; un SV reci&amp;eacute;n creado tiene un recuento de referencia de uno, por lo que si todo lo que hace su c&amp;oacute;digo es crear SV y luego almacenarlos en un hash, hv_store poseer&amp;aacute; la &amp;uacute;nica referencia al nuevo SV, y su c&amp;oacute;digo no necesita hacer nada m&amp;aacute;s para organizar. hv_store no se implementa como una llamada a hv_store_ent y no crea un SV temporal para la clave, por lo que si los datos de su clave a&amp;uacute;n no est&amp;aacute;n en formato SV, utilice hv_store en lugar de hv_store_ent.</target>
        </trans-unit>
        <trans-unit id="9bfc61e3c5920efd0c58d16c1ed44649d2d5bb7c" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error condition, followed by the hostname and service name.</source>
          <target state="translated">El valor de retorno será una lista;el primer valor será una condición de error,seguido por el nombre del host y el nombre del servicio.</target>
        </trans-unit>
        <trans-unit id="080fb2b25b92c9701522bdcbe08ea5301edb65d9" translate="yes" xml:space="preserve">
          <source>The return value will be a list; the first value being an error indication, followed by a list of address structures (if no error occurred).</source>
          <target state="translated">El valor de retorno será una lista;el primer valor será una indicación de error,seguido de una lista de estructuras de dirección (si no se ha producido ningún error).</target>
        </trans-unit>
        <trans-unit id="e58ba0106a37355ff008e5789a74611883b7e6cc" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains a reference to an array which contains the overview fields for that message.</source>
          <target state="translated">El valor de retorno será una referencia a un hash en el que las claves son los números de los mensajes y cada valor contiene una referencia a una matriz que contiene los campos de resumen de ese mensaje.</target>
        </trans-unit>
        <trans-unit id="c8d88b4235e896d1cdf2637f38fe289f36609de1" translate="yes" xml:space="preserve">
          <source>The return value will be a reference to a hash where the keys are the message numbers and each value contains the text of the requested header for that message.</source>
          <target state="translated">El valor de retorno será una referencia a un hash en el que las claves son los números de los mensajes y cada valor contiene el texto del encabezamiento solicitado para ese mensaje.</target>
        </trans-unit>
        <trans-unit id="7ff5356b785d18cf62379ed63c212e5a8a9ffb9a" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo%28%29&quot;&gt;&quot;charinfo()&quot;&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="17d18fcb9f371a15bbc60a7727df47264e8d90a5" translate="yes" xml:space="preserve">
          <source>The return values are more &quot;cooked&quot; than the &lt;a href=&quot;#charinfo()&quot;&gt;charinfo()&lt;/a&gt; ones. For example, the &lt;code&gt;&quot;uc&quot;&lt;/code&gt; property value is the actual string containing the full uppercase mapping of the input code point. You have to go to extra trouble with &lt;code&gt;charinfo&lt;/code&gt; to get this value from its &lt;code&gt;upper&lt;/code&gt; hash element when the full mapping differs from the simple one.</source>
          <target state="translated">Los valores de retorno est&amp;aacute;n m&amp;aacute;s &quot;cocinados&quot; que los de &lt;a href=&quot;#charinfo()&quot;&gt;charinfo ()&lt;/a&gt; . Por ejemplo, el valor de la propiedad &lt;code&gt;&quot;uc&quot;&lt;/code&gt; es la cadena real que contiene el mapeo completo en may&amp;uacute;sculas del punto del c&amp;oacute;digo de entrada. Tienes que hacer un &lt;code&gt;charinfo&lt;/code&gt; adicional con charinfo para obtener este valor de su elemento hash &lt;code&gt;upper&lt;/code&gt; cuando el mapeo completo difiere del simple.</target>
        </trans-unit>
        <trans-unit id="a0c27b1b52fce6c8f2f090cdffac0089b776c9ec" translate="yes" xml:space="preserve">
          <source>The returned NaN is always a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e761cd70527853f3676a64d7d2be637d80127b77" translate="yes" xml:space="preserve">
          <source>The returned hash consists of 4 parts:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac925fdbc70f038b7d79d3f22cbbb8542015b931" translate="yes" xml:space="preserve">
          <source>The returned list will begin with the initial value for &lt;code&gt;$a&lt;/code&gt;, followed by each return value from the block in order. The final value of the result will be identical to what the &lt;code&gt;reduce&lt;/code&gt; function would have returned given the same block and list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3df12c311a5affa1878c7637ef497a0992643ca1" translate="yes" xml:space="preserve">
          <source>The returned object will only be valid as long as the underlying OPs and SVs continue to exist. Do not attempt to use the object after the underlying structures are freed.</source>
          <target state="translated">El objeto devuelto sólo será válido mientras sigan existiendo los OP y SV subyacentes.No intente utilizar el objeto después de que las estructuras subyacentes sean liberadas.</target>
        </trans-unit>
        <trans-unit id="27c81be6b30926294699f4659627b6ffa79304d4" translate="yes" xml:space="preserve">
          <source>The returned script will be &lt;code&gt;SCX_Inherited&lt;/code&gt; iff all the code points in it are from the Inherited script.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c9c36a9cfb66d7244d884d86187f93dbed4c9d0" translate="yes" xml:space="preserve">
          <source>The returned value will have the characters that can't be decoded replaced by &quot;\x{FFFD}&quot;, the Unicode replacement character.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afb88fca63fb7d940d0f8f78e07d1c80fa709c01" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">Los valores devueltos son copias de las claves originales en el hash, por lo que modificarlos no afectar&amp;aacute; al hash original. Compara &lt;a href=&quot;#values&quot;&gt;valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="a3aac40383199a850fb451c54d0b1c983a804515" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;#values-HASH&quot;&gt;&lt;code&gt;values&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d53dad6b674af04a6d84ac0aee48048c271fdde" translate="yes" xml:space="preserve">
          <source>The returned values are copies of the original keys in the hash, so modifying them will not affect the original hash. Compare &lt;a href=&quot;values&quot;&gt;values&lt;/a&gt;.</source>
          <target state="translated">Los valores devueltos son copias de las claves originales en el hash, por lo que modificarlos no afectar&amp;aacute; al hash original. Compara &lt;a href=&quot;values&quot;&gt;valores&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="21a00c167788624d4ca90d4b617125a344dae47a" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt; &quot; in a Perl regular rexpression for these, like &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</source>
          <target state="translated">Los valores devueltos para las propiedades de la extensi&amp;oacute;n Perl, como &lt;code&gt;Any&lt;/code&gt; y &lt;code&gt;Greek&lt;/code&gt; , son algo enga&amp;ntilde;osos. Los valores son &lt;code&gt;&quot;Y&quot;&lt;/code&gt; o &lt;code&gt;&quot;N&lt;/code&gt; &quot;. Todas las propiedades Unicode son bipartitas, por lo que puede utilizar la &lt;code&gt;&quot;Y&quot;&lt;/code&gt; o la &lt;code&gt;&quot;N&lt;/code&gt; &quot; en una reexpresi&amp;oacute;n regular de Perl para estas, como &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{ID_Start=Y/}&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr/\p{Upper=N/}&lt;/a&gt;&lt;/code&gt; . Pero las extensiones de Perl no se especifican de esta manera, solo como &lt;code&gt;/qr/\p{Any}&lt;/code&gt; ,</target>
        </trans-unit>
        <trans-unit id="0b00496e0ac48606a2b2f5ade4900470b3e5cc37" translate="yes" xml:space="preserve">
          <source>The returned values for the Perl extension properties, such as &lt;code&gt;Any&lt;/code&gt; and &lt;code&gt;Greek&lt;/code&gt; are somewhat misleading. The values are either &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot;. All Unicode properties are bipartite, so you can actually use the &lt;code&gt;&quot;Y&quot;&lt;/code&gt; or &lt;code&gt;&quot;N&lt;/code&gt;&quot; in a Perl regular expression for these, like &lt;code&gt;qr/\p{ID_Start=Y/}&lt;/code&gt; or &lt;code&gt;qr/\p{Upper=N/}&lt;/code&gt;. But the Perl extensions aren't specified this way, only like &lt;code&gt;/qr/\p{Any}&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5eea968d1f523529d28fcd024fbb7e15c83c048" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; object.</source>
          <target state="translated">La revisi&amp;oacute;n, versi&amp;oacute;n y subversi&amp;oacute;n del int&amp;eacute;rprete de Perl, representada como un objeto de &lt;a href=&quot;version&quot;&gt;versi&amp;oacute;n&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="85e9edc5bb272a0ee91c10e7c6d3172fdb763afd" translate="yes" xml:space="preserve">
          <source>The revision, version, and subversion of the Perl interpreter, represented as a decimal of the form 5.XXXYYY, where XXX is the version / 1e3 and YYY is the subversion / 1e6. For example, Perl v5.10.1 would be &quot;5.010001&quot;.</source>
          <target state="translated">La revisión,versión y subversión del intérprete de Perl,representada como un decimal de la forma 5.XXXYYY,donde XXX es la versión/1e3 y YYY es la subversión/1e6.Por ejemplo,Perl v5.10.1 sería &quot;5.010001&quot;.</target>
        </trans-unit>
        <trans-unit id="66e488be2f8483df95b9f037ffeda3de74384599" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt; . The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="translated">La versi&amp;oacute;n reescrita de este m&amp;oacute;dulo (frente a v0.01) es m&amp;aacute;s lenta en ciertas operaciones, como &lt;code&gt;new()&lt;/code&gt; , &lt;code&gt;bstr()&lt;/code&gt; y &lt;code&gt;numify()&lt;/code&gt; . La raz&amp;oacute;n es que ahora hace m&amp;aacute;s trabajo y maneja muchos m&amp;aacute;s casos. El tiempo empleado en estas operaciones generalmente se gana en las otras operaciones matem&amp;aacute;ticas, por lo que el c&amp;oacute;digo en promedio deber&amp;iacute;a ser (mucho) m&amp;aacute;s r&amp;aacute;pido. Si no es as&amp;iacute;, comun&amp;iacute;quese con el autor.</target>
        </trans-unit>
        <trans-unit id="d648a5385a086d97fdf940828d9fd6d003974ab0" translate="yes" xml:space="preserve">
          <source>The rewritten version of this module (vs. v0.01) is slower on certain operations, like &lt;code&gt;new()&lt;/code&gt;, &lt;code&gt;bstr()&lt;/code&gt; and &lt;code&gt;numify()&lt;/code&gt;. The reason are that it does now more work and handles much more cases. The time spent in these operations is usually gained in the other math operations so that code on the average should get (much) faster. If they don't, please contact the author.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23622f986ab9be80262d33005c6066bc0cc050da" translate="yes" xml:space="preserve">
          <source>The right column will also caution you if a property means something different than what might normally be expected.</source>
          <target state="translated">La columna de la derecha también le advertirá si una propiedad significa algo diferente de lo que normalmente se podría esperar.</target>
        </trans-unit>
        <trans-unit id="ae21a75ed2b2f6ef4dbb92843a55ab639a296c6c" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt; also in</source>
          <target state="translated">El lado derecho, que comienza en la l&amp;iacute;nea 5, es similar a lo que acabamos de ver: tenemos la &lt;code&gt;pp_add&lt;/code&gt; &lt;code&gt;add&lt;/code&gt; ( pp_add tambi&amp;eacute;n en</target>
        </trans-unit>
        <trans-unit id="a97b5a9d26a8152b03235a227c2f7630aad78c10" translate="yes" xml:space="preserve">
          <source>The right hand side, starting at line 5 is similar to what we've just seen: we have the &lt;code&gt;add&lt;/code&gt; op (&lt;code&gt;pp_add&lt;/code&gt;, also in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="88e3fe5f1905fd5d0642f37b1a353b457c2b5b66" translate="yes" xml:space="preserve">
          <source>The right operand is not evaluated while the operator is in the &quot;false&quot; state, and the left operand is not evaluated while the operator is in the &quot;true&quot; state. The precedence is a little lower than || and &amp;amp;&amp;amp;. The value returned is either the empty string for false, or a sequence number (beginning with 1) for true. The sequence number is reset for each range encountered. The final sequence number in a range has the string &lt;code&gt;&quot;E0&quot;&lt;/code&gt; appended to it, which doesn't affect its numeric value, but gives you something to search for if you want to exclude the endpoint. You can exclude the beginning point by waiting for the sequence number to be greater than 1.</source>
          <target state="translated">El operando derecho no se eval&amp;uacute;a mientras el operador est&amp;aacute; en el estado &quot;falso&quot; y el operando izquierdo no se eval&amp;uacute;a mientras el operador est&amp;aacute; en el estado &quot;verdadero&quot;. La precedencia es un poco menor que || y &amp;amp;&amp;amp;. El valor devuelto es la cadena vac&amp;iacute;a para falso o un n&amp;uacute;mero de secuencia (que comienza con 1) para verdadero. El n&amp;uacute;mero de secuencia se restablece para cada rango encontrado. El n&amp;uacute;mero de secuencia final en un rango tiene la cadena &lt;code&gt;&quot;E0&quot;&lt;/code&gt; agregada, lo que no afecta su valor num&amp;eacute;rico, pero le da algo para buscar si desea excluir el punto final. Puede excluir el punto de inicio esperando que el n&amp;uacute;mero de secuencia sea mayor que 1.</target>
        </trans-unit>
        <trans-unit id="712b7dd783ec62d03111b67512c4c71fb70fa066" translate="yes" xml:space="preserve">
          <source>The rightmost delimiter beginning the argument text to the interior sequence (should be &quot;&amp;gt;&quot;).</source>
          <target state="translated">El delimitador m&amp;aacute;s a la derecha que comienza el texto del argumento en la secuencia interior (debe ser &quot;&amp;gt;&quot;).</target>
        </trans-unit>
        <trans-unit id="f1b13ab5c99b5028d035c2e34026b78f830a5ce1" translate="yes" xml:space="preserve">
          <source>The rmtree() function provide the legacy interface of remove_tree() with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to remove_tree().</source>
          <target state="translated">La función rmtree()proporciona a la interfaz heredada de remove_tree()una interpretación diferente de los argumentos pasados.Por lo demás,el comportamiento y el valor de retorno de la función es idéntico al de remove_tree().</target>
        </trans-unit>
        <trans-unit id="97d9690fe48f5ed9ac8be9b70513653d3ab42339" translate="yes" xml:space="preserve">
          <source>The rot13 example was a trivial example. Here's another demonstration that shows off a few more features.</source>
          <target state="translated">El ejemplo de rot13 fue un ejemplo trivial.Aquí hay otra demostración que muestra algunas características más.</target>
        </trans-unit>
        <trans-unit id="4a28f646da84403da9a05e371721d016d1168285" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</source>
          <target state="translated">El equivalente aproximado de Perl es &lt;code&gt;$myarray[$idx]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="4b4a8606a49a46444c3a9ed277908732090e4141" translate="yes" xml:space="preserve">
          <source>The rough perl equivalent is &lt;code&gt;$myarray[$key]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07cb0ce6d373861ed9384fe1d2dba7e82ae7d7eb" translate="yes" xml:space="preserve">
          <source>The routine &lt;code&gt;regtail()&lt;/code&gt; is called by both &lt;code&gt;reg()&lt;/code&gt; and &lt;code&gt;regbranch()&lt;/code&gt; in order to &quot;set the tail pointer&quot; correctly. When executing and we get to the end of a branch, we need to go to the node following the grouping parens. When parsing, however, we don't know where the end will be until we get there, so when we do we must go back and update the offsets as appropriate. &lt;code&gt;regtail&lt;/code&gt; is used to make this easier.</source>
          <target state="translated">La rutina &lt;code&gt;regtail()&lt;/code&gt; es llamada tanto por &lt;code&gt;reg()&lt;/code&gt; como por &lt;code&gt;regbranch()&lt;/code&gt; para &quot;establecer el puntero de cola&quot; correctamente. Al ejecutar y llegar al final de una rama, debemos ir al nodo siguiendo los parens de agrupaci&amp;oacute;n. Sin embargo, al analizar, no sabemos d&amp;oacute;nde estar&amp;aacute; el final hasta que lleguemos all&amp;iacute;, por lo que cuando lo hagamos debemos volver atr&amp;aacute;s y actualizar las compensaciones seg&amp;uacute;n corresponda. &lt;code&gt;regtail&lt;/code&gt; se utiliza para facilitar esto.</target>
        </trans-unit>
        <trans-unit id="96fb8a6192d6d2137dae358308fab281f2803684" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , a loop exit, or a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt; .</source>
          <target state="translated">La rutina indicada por &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; se llama cuando est&amp;aacute; a punto de lanzarse una excepci&amp;oacute;n fatal. El mensaje de error se pasa como primer argumento. Cuando &lt;code&gt;__DIE__&lt;/code&gt; una rutina de enganche __DIE__ , el procesamiento de excepciones contin&amp;uacute;a como lo hubiera hecho en ausencia del enganche, a menos que la rutina de enganche en s&amp;iacute; misma salga a trav&amp;eacute;s de un &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;sub&lt;/code&gt; , una salida de bucle o un &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; . El controlador &lt;code&gt;__DIE__&lt;/code&gt; est&amp;aacute; expl&amp;iacute;citamente deshabilitado durante la llamada, por lo que puede morir de un controlador &lt;code&gt;__DIE__&lt;/code&gt; . De manera similar para &lt;code&gt;__WARN__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a3747082bcec8b320b157ca0f6db8a2c2a773d76" translate="yes" xml:space="preserve">
          <source>The routine indicated by &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is called when a fatal exception is about to be thrown. The error message is passed as the first argument. When a &lt;code&gt;__DIE__&lt;/code&gt; hook routine returns, the exception processing continues as it would have in the absence of the hook, unless the hook routine itself exits via a &lt;code&gt;goto &amp;amp;sub&lt;/code&gt;, a loop exit, or a &lt;code&gt;die()&lt;/code&gt;. The &lt;code&gt;__DIE__&lt;/code&gt; handler is explicitly disabled during the call, so that you can die from a &lt;code&gt;__DIE__&lt;/code&gt; handler. Similarly for &lt;code&gt;__WARN__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c23e498d9e0f7b9916602bb81bb457e05dc15d28" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt; . The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="translated">La rutina m&amp;aacute;s utilizada es &lt;code&gt;call_sv&lt;/code&gt; . El argumento &lt;code&gt;SV*&lt;/code&gt; contiene el nombre de la subrutina Perl que se va a llamar o una referencia a la subrutina. El segundo argumento consta de indicadores que controlan el contexto en el que se llama a la subrutina, si a la subrutina se le pasan argumentos o no, c&amp;oacute;mo se deben atrapar los errores y c&amp;oacute;mo tratar los valores de retorno.</target>
        </trans-unit>
        <trans-unit id="8b9d3fc2ab950a51903275842538b6aa8532b735" translate="yes" xml:space="preserve">
          <source>The routine most often used is &lt;code&gt;call_sv&lt;/code&gt;. The &lt;code&gt;SV*&lt;/code&gt; argument contains either the name of the Perl subroutine to be called, or a reference to the subroutine. The second argument consists of flags that control the context in which the subroutine is called, whether or not the subroutine is being passed arguments, how errors should be trapped, and how to treat return values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02aa17c916dde6540e50fc69118a82269239b3fa" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;b&gt;false&lt;/b&gt; otherwise.</source>
          <target state="translated">De lo contrario, la rutina devuelve &lt;b&gt;falso&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="2a6f415596eaaeb6ae6674de29690a406129631d" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; exception.</source>
          <target state="translated">La rutina devuelve &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; para problemas de E / S u otro error interno, un valor verdadero en caso contrario. Los errores graves se propagan como una excepci&amp;oacute;n del &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="274062f280eff9b69a72565df5a686a0a630e507" translate="yes" xml:space="preserve">
          <source>The routine returns &lt;code&gt;undef&lt;/code&gt; for I/O problems or other internal error, a true value otherwise. Serious errors are propagated as a &lt;code&gt;die&lt;/code&gt; exception.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30cd5a5724b0cdff1db0ded8bf4cad313b5d3163" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;reftype&lt;/code&gt; are exportable.</source>
          <target state="translated">Las rutinas &lt;code&gt;get&lt;/code&gt; y &lt;code&gt;reftype&lt;/code&gt; son exportables.</target>
        </trans-unit>
        <trans-unit id="7978092db3768ef7e6d213d57a05b4b46c4c1d11" translate="yes" xml:space="preserve">
          <source>The routines &lt;code&gt;make_path&lt;/code&gt; and &lt;code&gt;remove_tree&lt;/code&gt; are &lt;b&gt;not&lt;/b&gt; exported by default. You must specify which ones you want to use.</source>
          <target state="translated">Las rutinas &lt;code&gt;make_path&lt;/code&gt; y &lt;code&gt;remove_tree&lt;/code&gt; se &lt;b&gt;no se&lt;/b&gt; exportan de manera predeterminada. Debe especificar cu&amp;aacute;les desea utilizar.</target>
        </trans-unit>
        <trans-unit id="5f252df425e68241a153a06fc0e9c8513b5f1aa7" translate="yes" xml:space="preserve">
          <source>The routines are called in string comparison order of KEY.</source>
          <target state="translated">Las rutinas se llaman en el orden de comparación de las cadenas de la CLAVE.</target>
        </trans-unit>
        <trans-unit id="74358fa70816b0be14690b88380765bc85d1b11f" translate="yes" xml:space="preserve">
          <source>The routines provided are:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="258695837b0d342f488ae3724d49cf11d73778d9" translate="yes" xml:space="preserve">
          <source>The rule by which Digest::SHA handles a Unicode string is easy to state, but potentially confusing to grasp: the string is interpreted as a sequence of byte values, where each byte value is equal to the ordinal value (viz. code point) of its corresponding Unicode character. That way, the Unicode string 'abc' has exactly the same digest value as the ordinary string 'abc'.</source>
          <target state="translated">La regla por la cual Digest::SHA maneja una cadena Unicode es fácil de enunciar,pero potencialmente confusa de entender:la cadena se interpreta como una secuencia de valores de bytes,donde cada valor de byte es igual al valor ordinal (es decir,el punto de código)de su correspondiente carácter Unicode.De esta manera,la cadena Unicode &quot;abc&quot; tiene exactamente el mismo valor digestivo que la cadena ordinaria &quot;abc&quot;.</target>
        </trans-unit>
        <trans-unit id="6b4e5af62f9d03a0b5c8d39854ce10f47d56d0b1" translate="yes" xml:space="preserve">
          <source>The rule must only have one top level key: either 'par' for &quot;parallel&quot; or 'seq' for &quot;sequence&quot;.</source>
          <target state="translated">La regla sólo debe tener una clave de nivel superior:o bien &quot;par&quot; para &quot;paralelo&quot; o &quot;seq&quot; para &quot;secuencia&quot;.</target>
        </trans-unit>
        <trans-unit id="2858e68dbb1d52d413ae8f5dae1d589d672ac788" translate="yes" xml:space="preserve">
          <source>The rule of thumb for portable code is: Do it all in portable Perl, or use a module (that may internally implement it with platform-specific code, but exposes a common interface).</source>
          <target state="translated">La regla general para el código portátil es:Hacerlo todo en Perl portátil,o utilizar un módulo (que puede implementarlo internamente con código específico de la plataforma,pero que expone una interfaz común).</target>
        </trans-unit>
        <trans-unit id="242ca7a8186e9298403d04b4bfd265a295183ebf" translate="yes" xml:space="preserve">
          <source>The rule of thumb is to use &lt;code&gt;UTF-8&lt;/code&gt; unless you know what you're doing and unless you really benefit from using &lt;code&gt;UTF-16&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d771186d9f060b8e39d56f4b8de80fe1694de984" translate="yes" xml:space="preserve">
          <source>The rules data structure is documented more in the next section.</source>
          <target state="translated">La estructura de datos de las reglas se documenta más en la siguiente sección.</target>
        </trans-unit>
        <trans-unit id="b2b47541d9fe53d041ea0cd594a357e270362960" translate="yes" xml:space="preserve">
          <source>The rules determining what it is are quite simple: if the character following the backslash is an ASCII punctuation (non-word) character (that is, anything that is not a letter, digit, or underscore), then the backslash just takes away any special meaning of the character following it.</source>
          <target state="translated">Las reglas que determinan qué es son bastante simples:si el carácter que sigue a la barra invertida es un carácter de puntuación ASCII (no de palabra)(es decir,cualquier cosa que no sea una letra,un dígito o un guión bajo),entonces la barra invertida sólo le quita cualquier significado especial al carácter que la sigue.</target>
        </trans-unit>
        <trans-unit id="f747d6278f9a09b6ca106424547e7e55bc600835" translate="yes" xml:space="preserve">
          <source>The rules of conduct that, in the absence of other guidance, determine what should happen first. For example, in the absence of parentheses, you always do multiplication before addition.</source>
          <target state="translated">Las normas de conducta que,a falta de otra orientación,determinan lo que debe suceder primero.Por ejemplo,a falta de paréntesis,siempre se hace la multiplicación antes de la suma.</target>
        </trans-unit>
        <trans-unit id="ba784b5f42a3cdb9214cd0e95e0cb55e8afe477c" translate="yes" xml:space="preserve">
          <source>The rules used by &lt;a href=&quot;re#%27strict%27-mode&quot;&gt;&lt;code&gt;use re 'strict&lt;/code&gt;&lt;/a&gt; apply to this construct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="903df1a17859e1fa3a6b96e5e64488aec405db63" translate="yes" xml:space="preserve">
          <source>The rules used for matching decimal digits are slightly stricter. Many scripts have their own sets of digits equivalent to the Western &lt;code&gt;0&lt;/code&gt; through &lt;code&gt;9&lt;/code&gt; ones. A few, such as Arabic, have more than one set. For a string to be considered a script run, all digits in it must come from the same set of ten, as determined by the first digit encountered. As an example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ac2685482eb75c8db66c436a646aa6e3d97f9ed" translate="yes" xml:space="preserve">
          <source>The runtime component should have the name</source>
          <target state="translated">El componente de tiempo de ejecución debería tener el nombre</target>
        </trans-unit>
        <trans-unit id="9ac33bbce70d7ec48c4fcab9365b96ff1ebc5597" translate="yes" xml:space="preserve">
          <source>The runtime phase refers not only to when the distribution's contents are installed, but also to its continued use. Any library that is a prerequisite for regular use of this distribution should be indicated here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="763ace778385d85ae756e3844782d5cfee6e0e05" translate="yes" xml:space="preserve">
          <source>The same approach as a command line:</source>
          <target state="translated">El mismo enfoque que una línea de mando:</target>
        </trans-unit>
        <trans-unit id="9976b6a81a6abb21b7cab5b632b4ad690c05665b" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; directive.</source>
          <target state="translated">Lo mismo que para &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; , pero si un operador faltante no se puede generar autom&amp;aacute;ticamente , en lugar de emitir un mensaje de error, Perl puede volver a lo que hubiera hecho para ese operador si no hubiera habido una directiva de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="aff3ca408715d6ed9bbfe43d93b70be580afe993" translate="yes" xml:space="preserve">
          <source>The same as for &lt;code&gt;undef&lt;/code&gt;, but if a missing operator cannot be autogenerated then, instead of issuing an error message, Perl is allowed to revert to what it would have done for that operator if there had been no &lt;code&gt;use overload&lt;/code&gt; directive.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c7d5583bb4c7bf75d630d65c93bc37b198d69e0" translate="yes" xml:space="preserve">
          <source>The same caveats as the previous form apply: The non-graphic characters are no longer allowed with &quot;use utf8&quot;, it is unwise to use this form at all, and utf8ness makes a big difference.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="286499ca118e6aee1159ad012e0d0c293bc05679" translate="yes" xml:space="preserve">
          <source>The same checksum can also be calculated in OO style:</source>
          <target state="translated">La misma suma de control también puede ser calculada en el estilo OO:</target>
        </trans-unit>
        <trans-unit id="e7121397996c97368f3bf5006e5d7cf5183183f6" translate="yes" xml:space="preserve">
          <source>The same effect as the example above in a different way. The coderef takes the alias name as an argument and returns a canonical name on success or undef if not. Note the second argument is ignored if provided. Use this with even more caution than the regex version.</source>
          <target state="translated">El mismo efecto que el ejemplo anterior de una manera diferente.El coderef toma el nombre del alias como argumento y devuelve un nombre canónico en el éxito o en el fracaso si no.Nótese que el segundo argumento se ignora si se proporciona.Utilízalo con más precaución que la versión regex.</target>
        </trans-unit>
        <trans-unit id="e43451146d37e633afabe95e907553562bae7cb9" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;ed strings looks like &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</source>
          <target state="translated">Lo mismo se aplica a las cadenas evaluadas que contienen subrutinas o que se est&amp;aacute;n ejecutando actualmente. El nombre de archivo $ para las cadenas &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; uadas se parece a &lt;code&gt;(&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt; 34)&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="6bfd670d25b13b1b3ec948c8f09f21523b3aecf7" translate="yes" xml:space="preserve">
          <source>The same holds for evaluated strings that contain subroutines, or which are currently being executed. The $filename for &lt;code&gt;eval&lt;/code&gt;ed strings looks like &lt;code&gt;(eval 34)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a048bf53e27173e747513cb4000a6c6bd711ca9e" translate="yes" xml:space="preserve">
          <source>The same information is displayed at the end of the output from the command</source>
          <target state="translated">La misma información se muestra al final de la salida del comando</target>
        </trans-unit>
        <trans-unit id="fe72bff5d187e52fa5d199f09887af6af2e32815" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt; : these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="translated">No ocurre lo mismo con las implementaciones de &lt;code&gt;++&lt;/code&gt; y &lt;code&gt;--&lt;/code&gt; : se espera que modifiquen su operando. Una implementaci&amp;oacute;n apropiada de &lt;code&gt;--&lt;/code&gt; podr&amp;iacute;a parecer</target>
        </trans-unit>
        <trans-unit id="07cb6e84563964c1b3fb8a6ff37a2b4286b6b128" translate="yes" xml:space="preserve">
          <source>The same is not true of implementations of &lt;code&gt;++&lt;/code&gt; and &lt;code&gt;--&lt;/code&gt;: these are expected to modify their operand. An appropriate implementation of &lt;code&gt;--&lt;/code&gt; might look like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9889316caadba38254c295ba1f667d08e692e37" translate="yes" xml:space="preserve">
          <source>The same might happen to AIX 5.1 or other OS levels. As a side note, Perl cannot be built without bos.adt.syscalls and bos.adt.libm installed</source>
          <target state="translated">Lo mismo podría suceder con AIX 5.1 u otros niveles del sistema operativo.Como nota al margen,Perl no puede ser construido sin bos.adt.syscalls y bos.adt.libm instalados</target>
        </trans-unit>
        <trans-unit id="2d3beec233d4767fecd283497936fe00947a8d1a" translate="yes" xml:space="preserve">
          <source>The same package name can be used more than once, allowing for non-contiguous code. This is useful if you have a stronger ordering principle than package names.</source>
          <target state="translated">El mismo nombre de paquete puede ser usado más de una vez,permitiendo un código no contiguo.Esto es útil si tienes un principio de ordenamiento más fuerte que los nombres de los paquetes.</target>
        </trans-unit>
        <trans-unit id="adf0ce12f9a7b11a4e4d148adc2353bc6022f25b" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="translated">Los mismos problemas surgen si habilita la UTF-8-ificaci&amp;oacute;n autom&amp;aacute;tica de sus identificadores de archivo est&amp;aacute;ndar, la capa &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; predeterminada y &lt;code&gt;@ARGV&lt;/code&gt; en configuraciones regionales que no son ISO8859-1, no UTF-8 (usando la l&amp;iacute;nea de comando &lt;b&gt;-C&lt;/b&gt; switch o la variable de entorno &lt;code&gt;PERL_UNICODE&lt;/code&gt; ; consulte &lt;a href=&quot;perlrun&quot;&gt;perlrun&lt;/a&gt; ). Las cosas se leen como UTF-8, lo que normalmente implicar&amp;iacute;a una interpretaci&amp;oacute;n Unicode, pero la presencia de una configuraci&amp;oacute;n regional hace que se interpreten en esa configuraci&amp;oacute;n regional. Por ejemplo, un punto de c&amp;oacute;digo 0xD7 en la entrada Unicode, que deber&amp;iacute;a significar el signo de multiplicaci&amp;oacute;n, no ser&amp;aacute; interpretado por Perl de esa manera en la configuraci&amp;oacute;n regional griega. Esto no es un problema</target>
        </trans-unit>
        <trans-unit id="44e618a0d24868bdeb405a4592271ed0ce58faad" translate="yes" xml:space="preserve">
          <source>The same problems ensue if you enable automatic UTF-8-ification of your standard file handles, default &lt;code&gt;open()&lt;/code&gt; layer, and &lt;code&gt;@ARGV&lt;/code&gt; on non-ISO8859-1, non-UTF-8 locales (by using either the &lt;b&gt;-C&lt;/b&gt; command line switch or the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable; see &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;perlrun&lt;/a&gt;). Things are read in as UTF-8, which would normally imply a Unicode interpretation, but the presence of a locale causes them to be interpreted in that locale instead. For example, a 0xD7 code point in the Unicode input, which should mean the multiplication sign, won't be interpreted by Perl that way under the Greek locale. This is not a problem</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8104fdf41371cefa43c656a17bffde6b62386dd0" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from BigInt.</source>
          <target state="translated">Los mismos problemas ocurren si les pasa objetos Math :: BigInt-&amp;gt; binf (). Dado que no es posible sobrecargar estas rutinas, esto no se puede solucionar desde BigInt.</target>
        </trans-unit>
        <trans-unit id="7dc30b04b9083d2f8edd85ddb5597b7e64cf1167" translate="yes" xml:space="preserve">
          <source>The same problems occur if you pass them Math::BigInt-&amp;gt;binf() objects. Since overloading these routines is not possible, this cannot be fixed from Math::BigInt.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd308e84d4bbc13d1645c341d0f0d15e57ef77b4" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e999fed9c0e326d353539553d4a7555374fd82" translate="yes" xml:space="preserve">
          <source>The same template may generally also be used in unpack().</source>
          <target state="translated">Por lo general,la misma plantilla puede utilizarse también para desempacar().</target>
        </trans-unit>
        <trans-unit id="6b6c7f4b6ab698dbba6b63d74e5bcb57fa5d9973" translate="yes" xml:space="preserve">
          <source>The same tests are run both times, but more information is provided when running as &lt;code&gt;./perl harness&lt;/code&gt;.</source>
          <target state="translated">Las mismas pruebas se ejecutan en ambas ocasiones, pero se proporciona m&amp;aacute;s informaci&amp;oacute;n cuando se ejecuta como &lt;code&gt;./perl harness&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1f4add58be52aaba625e5f7ff33a20f204714d58" translate="yes" xml:space="preserve">
          <source>The sample program:</source>
          <target state="translated">El programa de muestra:</target>
        </trans-unit>
        <trans-unit id="81ca6bed72a326bbf775e3304829aa324851950b" translate="yes" xml:space="preserve">
          <source>The save stack is used by perl to implement the &lt;code&gt;local&lt;/code&gt; keyword and other similar behaviours; any cleanup operations that need to be performed when leaving the current scope. Items pushed to this stack generally capture the current value of some internal variable or state, which will be restored when the scope is unwound due to leaving, &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;die&lt;/code&gt;, &lt;code&gt;goto&lt;/code&gt; or other reasons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f745bb5cbca08197cbed6d6403139abf437a8fa9" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt; .</source>
          <target state="translated">El valor de &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; escalar se almacena en una instancia de SV llamada &lt;code&gt;PL_sv_undef&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d200dc97f6deaa66b9415179bc13a97fa0cc3da" translate="yes" xml:space="preserve">
          <source>The scalar &lt;code&gt;undef&lt;/code&gt; value is stored in an SV instance called &lt;code&gt;PL_sv_undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6e858b562140c68ce32ea23e2b6e666b2e82798f" translate="yes" xml:space="preserve">
          <source>The scalar/list context for the subroutine and for the right-hand side of assignment is determined as if the subroutine call is replaced by a scalar. For example, consider:</source>
          <target state="translated">El contexto del escalar/lista para la subrutina y para el lado derecho de la asignación se determina como si la llamada de la subrutina fuera reemplazada por un escalar.Por ejemplo,considere:</target>
        </trans-unit>
        <trans-unit id="6c0b56c4841154473a184d3770a4651387051abe" translate="yes" xml:space="preserve">
          <source>The scalars for in-memory files are treated as octet strings: unless the file is being opened with truncation the scalar may not contain any code points over 0xFF.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a59c0bcb531b15ec7601a5c46eda41a994dbd08" translate="yes" xml:space="preserve">
          <source>The scheme above allows interpretation of a wide range of dates, particularly if 4-digit years are used.</source>
          <target state="translated">El esquema anterior permite la interpretación de una amplia gama de fechas,en particular si se utilizan años de cuatro dígitos.</target>
        </trans-unit>
        <trans-unit id="3fc0ce48ddfa00a9f249dd98501d09516efb57c0" translate="yes" xml:space="preserve">
          <source>The scheme from the uri (like 'file', 'http', etc)</source>
          <target state="translated">El esquema de la uri (como &quot;file&quot;,&quot;http&quot;,etc.)</target>
        </trans-unit>
        <trans-unit id="73f8b37079fc67e2d535d7e2f263c71e4f89003f" translate="yes" xml:space="preserve">
          <source>The scope of the &lt;code&gt;package&lt;/code&gt; declaration is from the declaration itself through the end of the enclosing block, &lt;code&gt;eval&lt;/code&gt;, or file, whichever comes first (the same scope as the my(), our(), state(), and local() operators, and also the effect of the experimental &quot;reference aliasing,&quot; which may change), or until the next &lt;code&gt;package&lt;/code&gt; declaration. Unqualified dynamic identifiers will be in this namespace, except for those few identifiers that, if unqualified, default to the main package instead of the current one as described below. A &lt;code&gt;package&lt;/code&gt; statement affects only dynamic global symbols, including subroutine names, and variables you've used local() on, but</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49277474cf2c3fa04e4e431396fc13bca0311697" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="translated">El alcance donde se usa la &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length&lt;/a&gt;&lt;/code&gt; ha elevado la categor&amp;iacute;a de advertencias &lt;code&gt;void&lt;/code&gt; a un error fatal, por lo que el programa termina inmediatamente cuando encuentra la advertencia.</target>
        </trans-unit>
        <trans-unit id="3dbfebc1570cc3ef48ec03f51a2706061f280881" translate="yes" xml:space="preserve">
          <source>The scope where &lt;code&gt;length&lt;/code&gt; is used has escalated the &lt;code&gt;void&lt;/code&gt; warnings category into a fatal error, so the program terminates immediately when it encounters the warning.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62f56ab0ebe6cfd894b851115a602d7f9f59ed1f" translate="yes" xml:space="preserve">
          <source>The script exits with zero if it thinks that everything worked, or a positive number if it thinks that something failed. Note, however, that in some cases it has to divine a failure by the output of things it does not control. For now, the exit codes are vague:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="05dbbff48c1e514e522b4520f47f1f9d051aaac1" translate="yes" xml:space="preserve">
          <source>The script first verifies the function of the &lt;code&gt;Name&lt;/code&gt; class.</source>
          <target state="translated">El script primero verifica la funci&amp;oacute;n de la clase &lt;code&gt;Name&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bab70c074a8060d72a4a917d75cb758f3fdbebe9" translate="yes" xml:space="preserve">
          <source>The script is available from &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</source>
          <target state="translated">El script est&amp;aacute; disponible en &lt;a href=&quot;https://gist.github.com/eqhmcow/5389877&quot;&gt;https://gist.github.com/eqhmcow/5389877&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="63775c5f58b6e8ca06f6c938a637be34887e3ffd" translate="yes" xml:space="preserve">
          <source>The script of a character is determined by the &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;), as described above.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="496da3e22e1e3340caf097640e4353358048134f" translate="yes" xml:space="preserve">
          <source>The sdbm file format was designed for speed and convenience, not for portability or security. A maliciously crafted file might cause perl to crash or even expose a security vulnerability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc3001b62b3120b5e625f2291ab08a912ad78b79" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt; ) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="translated">El motor de b&amp;uacute;squeda inicialmente coincidir&amp;aacute; con &lt;code&gt;\D*&lt;/code&gt; con &quot;ABC&quot;. Entonces intentar&amp;aacute; hacer coincidir &lt;code&gt;(?!123)&lt;/code&gt; con &quot;123&quot;, que falla. Pero debido a que se ha utilizado un cuantificador ( &lt;code&gt;\D*&lt;/code&gt; ) en la expresi&amp;oacute;n regular, el motor de b&amp;uacute;squeda puede retroceder y volver a intentar la coincidencia de forma diferente con la esperanza de que coincida con la expresi&amp;oacute;n regular completa.</target>
        </trans-unit>
        <trans-unit id="2dd6a24dc0c40439966d70dfb7faeebd4df837f5" translate="yes" xml:space="preserve">
          <source>The search engine will initially match &lt;code&gt;\D*&lt;/code&gt; with &quot;ABC&quot;. Then it will try to match &lt;code&gt;(?!123)&lt;/code&gt; with &quot;123&quot;, which fails. But because a quantifier (&lt;code&gt;\D*&lt;/code&gt;) has been used in the regular expression, the search engine can backtrack and retry the match differently in the hope of matching the complete regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4989338d675235ed7afc62322345e940a111f8d8" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;//p&lt;/code&gt; , which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="translated">La segunda ventaja es que los modificadores incrustados (excepto &lt;code&gt;//p&lt;/code&gt; , que modifica toda la expresi&amp;oacute;n regular) solo afectan la expresi&amp;oacute;n regular dentro del grupo en el que est&amp;aacute; contenido el modificador incrustado. Por lo tanto, la agrupaci&amp;oacute;n se puede usar para localizar los efectos del modificador:</target>
        </trans-unit>
        <trans-unit id="344654afee619df186bd5aa49c470902771a22f7" translate="yes" xml:space="preserve">
          <source>The second advantage is that embedded modifiers (except &lt;code&gt;/p&lt;/code&gt;, which modifies the entire regexp) only affect the regexp inside the group the embedded modifier is contained in. So grouping can be used to localize the modifier's effects:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e6b19a99a58715509197b4fd3bb055452f4e6bb8" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt; . The final argument to &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="translated">El segundo y tercer &lt;code&gt;number&lt;/code&gt; y &lt;code&gt;type&lt;/code&gt; argumentos especifican cu&amp;aacute;ntos de los tipos especificados de estructura de datos deben asignarse. El &lt;code&gt;type&lt;/code&gt; argumento se pasa a &lt;code&gt;sizeof&lt;/code&gt; . El argumento final de &lt;code&gt;Newxc&lt;/code&gt; , &lt;code&gt;cast&lt;/code&gt; , debe usarse si el argumento del &lt;code&gt;pointer&lt;/code&gt; es diferente del argumento del &lt;code&gt;type&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="fea027e954f4ec8636256c0b94ce6f7f44ab6c0c" translate="yes" xml:space="preserve">
          <source>The second and third arguments &lt;code&gt;number&lt;/code&gt; and &lt;code&gt;type&lt;/code&gt; specify how many of the specified type of data structure should be allocated. The argument &lt;code&gt;type&lt;/code&gt; is passed to &lt;code&gt;sizeof&lt;/code&gt;. The final argument to &lt;code&gt;Newxc&lt;/code&gt;, &lt;code&gt;cast&lt;/code&gt;, should be used if the &lt;code&gt;pointer&lt;/code&gt; argument is different from the &lt;code&gt;type&lt;/code&gt; argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b7128198e8ffe79d47674dc971b588a148d07fe" translate="yes" xml:space="preserve">
          <source>The second and third highest priorities are to look in the parent of the current directory and a directory called</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9372cc26ce11f225b78cb9001dded71987be37ab" translate="yes" xml:space="preserve">
          <source>The second argument ($eol) is the line-ending sequence to use. It is optional and defaults to &quot;\n&quot;. Every occurrence of &quot;\n&quot; is replaced with this string, and it is also used for additional &quot;soft line breaks&quot; to ensure that no line end up longer than 76 characters. Pass it as &quot;\015\012&quot; to produce data suitable for external consumption. The string &quot;\r\n&quot; produces the same result on many platforms, but not all.</source>
          <target state="translated">El segundo argumento ($eol)es la secuencia de fin de línea a usar.Es opcional y por defecto es &quot;\N&quot;.Cada vez que aparece &quot;\n&quot; se reemplaza con esta cadena,y también se usa para &quot;saltos de línea&quot; adicionales para asegurar que ninguna línea termine con más de 76 caracteres.Pásala como &quot;\015\012&quot; para producir datos adecuados para el consumo externo.La cadena &quot;\r\N&quot; produce el mismo resultado en muchas plataformas,pero no en todas.</target>
        </trans-unit>
        <trans-unit id="691db7e7ba5b2eef57391203c3fd8b3455b42a9c" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El segundo argumento puede ser una referencia hash con opciones, que son id&amp;eacute;nticas a los argumentos pasados ​​a &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d9356e806771df85496c708eb7a467795a26a60f" translate="yes" xml:space="preserve">
          <source>The second argument can be a hash reference with options, which are identical to the arguments passed to &lt;code&gt;read()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36e7dec2e6aed1723cd212b39460017f8772c38b" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="translated">El segundo argumento es una expresi&amp;oacute;n regular. Se puede dar como una referencia de expresi&amp;oacute;n regular (es decir, &lt;code&gt;&lt;a href=&quot;../functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; ) o (para una mejor compatibilidad con perls anteriores) como una cadena que parece una expresi&amp;oacute;n regular (actualmente no se admiten delimitadores alternativos):</target>
        </trans-unit>
        <trans-unit id="851ff1e7afee5d9f26155a298af3215064fbafc8" translate="yes" xml:space="preserve">
          <source>The second argument is a regular expression. It may be given as a regex reference (i.e. &lt;code&gt;qr//&lt;/code&gt;) or (for better compatibility with older perls) as a string that looks like a regex (alternative delimiters are currently not supported):</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9cd8da657568e7bbba17b34028b2178bd5abb57" translate="yes" xml:space="preserve">
          <source>The second argument is considered a regex if it is either a regex object or a string that looks like a regex. Regex objects are constructed with the qr// operator in recent versions of perl. A string is considered to look like a regex if its first and last characters are &quot;/&quot;, or if the first character is &quot;m&quot; and its second and last characters are both the same non-alphanumeric non-whitespace character. These regexp</source>
          <target state="translated">El segundo argumento se considera un regex si es un objeto regex o una cadena que se parece a un regex.Los objetos regex se construyen con el operador qr//en las versiones recientes de perl.Se considera que una cadena se parece a una regex si su primer y último carácter son &quot;/&quot;,o si el primer carácter es &quot;m&quot; y su segundo y último carácter son ambos el mismo carácter no alfanumérico no blanco.Estos regexp</target>
        </trans-unit>
        <trans-unit id="ffe3c605f37afcab4c8601d801b588d13a566637" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; in the case of a unary operator.</source>
          <target state="translated">El segundo argumento es el otro operando, o &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; en el caso de un operador unario.</target>
        </trans-unit>
        <trans-unit id="e4f1fa234686b49496c4cac025cf1d9ea03f5c52" translate="yes" xml:space="preserve">
          <source>The second argument is the other operand, or &lt;code&gt;undef&lt;/code&gt; in the case of a unary operator.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a8f0c3f0ec389d3780a678c2cc02cdb14b452933" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can compress using &lt;code&gt;gzip&lt;/code&gt;, &lt;code&gt;bzip2&lt;/code&gt; or &lt;code&gt;xz&lt;/code&gt;. If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e99835175d57940dd272e3dc71fc2882ef5b0d66" translate="yes" xml:space="preserve">
          <source>The second argument is used to indicate compression. You can either compress using &lt;code&gt;gzip&lt;/code&gt; or &lt;code&gt;bzip2&lt;/code&gt; . If you pass a digit, it's assumed to be the &lt;code&gt;gzip&lt;/code&gt; compression level (between 1 and 9), but the use of constants is preferred:</source>
          <target state="translated">El segundo argumento se utiliza para indicar compresi&amp;oacute;n. Puede comprimir usando &lt;code&gt;gzip&lt;/code&gt; o &lt;code&gt;bzip2&lt;/code&gt; . Si pasa un d&amp;iacute;gito, se supone que es el nivel de compresi&amp;oacute;n &lt;code&gt;gzip&lt;/code&gt; (entre 1 y 9), pero se prefiere el uso de constantes:</target>
        </trans-unit>
        <trans-unit id="a0c730e612ef3dd802df3a15f52c50f234217ccd" translate="yes" xml:space="preserve">
          <source>The second argument may be considered optional, but remains for backwards compatibility. Archive::Tar now looks at the file magic to determine what class should be used to open the file and will transparently Do The Right Thing.</source>
          <target state="translated">El segundo argumento puede considerarse opcional,pero se mantiene para la compatibilidad hacia atrás.Archivo::Tar ahora mira la magia del archivo para determinar qué clase debe ser usada para abrir el archivo y transparentemente hará lo correcto.</target>
        </trans-unit>
        <trans-unit id="fc50752077e3b12e3cd10f78b06bb8c9b8f956b4" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt; 's. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="translated">El segundo argumento apunta a una matriz que contiene &lt;code&gt;num&lt;/code&gt; &lt;code&gt;SV*&lt;/code&gt; . Una vez que se ha creado el AV, los SV pueden destruirse, si as&amp;iacute; se desea.</target>
        </trans-unit>
        <trans-unit id="51ba89f615646daa0a3b0a56db80558ec7c78c30" translate="yes" xml:space="preserve">
          <source>The second argument points to an array containing &lt;code&gt;num&lt;/code&gt;&lt;code&gt;SV*&lt;/code&gt;'s. Once the AV has been created, the SVs can be destroyed, if so desired.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8c79378da8449512fbe01727cd6ac969d7ae7c" translate="yes" xml:space="preserve">
          <source>The second argument to &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;&quot;-|&quot;&lt;/code&gt;, makes it a read-pipe into a separate program, rather than an ordinary filehandle into a file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="241df4a30fc4febc2cd9ef098abdb1cdbc871750" translate="yes" xml:space="preserve">
          <source>The second call to hex() will warn about a non-portable constant.</source>
          <target state="translated">La segunda llamada a hex()advertirá sobre una constante no portable.</target>
        </trans-unit>
        <trans-unit id="52f5fb6e434df4bf3ba2648b67634f2b93cdc1b5" translate="yes" xml:space="preserve">
          <source>The second call-back is optional if the call back is registered prior to the call to $term-&amp;gt;readline.</source>
          <target state="translated">La segunda devoluci&amp;oacute;n de llamada es opcional si la devoluci&amp;oacute;n de llamada se registra antes de la llamada a $ term-&amp;gt; readline.</target>
        </trans-unit>
        <trans-unit id="104d457b0581ca75e5a33a6cc382aa3d75495d54" translate="yes" xml:space="preserve">
          <source>The second call-back registered is the call back for registration. The input filehandle (often STDIN, but not necessarily) will be passed in.</source>
          <target state="translated">La segunda llamada registrada es la llamada de registro.El filehandle de entrada (a menudo STDIN,pero no necesariamente)será pasado.</target>
        </trans-unit>
        <trans-unit id="8a9a833fe2a8c9894ba16f1673e04b6df3b8c78c" translate="yes" xml:space="preserve">
          <source>The second case often turns out to have identical results to the first case, albeit only by accident.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a2db73bb8959c9504bedfb024b1f19ea96655cb" translate="yes" xml:space="preserve">
          <source>The second class of portable ranges is invoked when one or both of the range's end points are expressed as &lt;code&gt;\N{...}&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d9c1d1eb4a7fe50e319b8d6cb4e544cda2638c9" translate="yes" xml:space="preserve">
          <source>The second column is the return type, the third column the name. Columns after that are the arguments. The first column is a set of flags:</source>
          <target state="translated">La segunda columna es el tipo de retorno,la tercera columna el nombre.Las columnas siguientes son los argumentos.La primera columna es un conjunto de banderas:</target>
        </trans-unit>
        <trans-unit id="833ac465c5bc76260e3533a8f5293c1a6cc4e353" translate="yes" xml:space="preserve">
          <source>The second example in the synopsis does something equivalent to this:</source>
          <target state="translated">El segundo ejemplo de la sinopsis hace algo equivalente a esto:</target>
        </trans-unit>
        <trans-unit id="f7f8f6797190b2ee94971db1ba0f6aeb4ac8dc06" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt; , and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt; , or are shorter than 5 chars.</source>
          <target state="translated">El segundo ejemplo imprime entradas con nombres &lt;code&gt;foo&lt;/code&gt; y tambi&amp;eacute;n entradas con nombres que terminan en &lt;code&gt;bar&lt;/code&gt; ra o tienen menos de 5 caracteres.</target>
        </trans-unit>
        <trans-unit id="ff08cd3ad532db8c5d5dd8a872abb6c4f322ba5e" translate="yes" xml:space="preserve">
          <source>The second example prints entries with names &lt;code&gt;foo&lt;/code&gt;, and also entries with names which ends on &lt;code&gt;bar&lt;/code&gt;, or are shorter than 5 chars.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b7ec951497cf0073403b17626a675e036c31257" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt; .</source>
          <target state="translated">El segundo punto de salida prueba si quedan datos en el b&amp;uacute;fer de entrada, &lt;code&gt;$input&lt;/code&gt; ; recuerde que la opci&amp;oacute;n &lt;code&gt;ConsumeInput&lt;/code&gt; se habilita autom&amp;aacute;ticamente cuando se usa &lt;code&gt;LimitOutput&lt;/code&gt; . Cuando el b&amp;uacute;fer de entrada se ha agotado, el bucle externo puede ejecutarse nuevamente y sobrescribir una &lt;code&gt;$input&lt;/code&gt; ahora vac&amp;iacute;a .</target>
        </trans-unit>
        <trans-unit id="7cea8aa29f5d1b03f7b0a4cb746f125b76bdff01" translate="yes" xml:space="preserve">
          <source>The second exit point tests if there is any data left in the input buffer, &lt;code&gt;$input&lt;/code&gt; - remember that the &lt;code&gt;ConsumeInput&lt;/code&gt; option is automatically enabled when &lt;code&gt;LimitOutput&lt;/code&gt; is used. When the input buffer has been exhausted, the outer loop can run again and overwrite a now empty &lt;code&gt;$input&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dba4d9ed358b9b1b26a10b82c95880d18ef1ec5" translate="yes" xml:space="preserve">
          <source>The second form allows the filter to hold state information using a closure, thus:</source>
          <target state="translated">La segunda forma permite que el filtro retenga información de estado usando un cierre,por lo tanto:</target>
        </trans-unit>
        <trans-unit id="204d9fcc358796976a40cb62f3873844790ea690" translate="yes" xml:space="preserve">
          <source>The second form is strongly discouraged, because it breaks the ability of a subclass to reuse the parent's constructor, but you may still run across it in existing code.</source>
          <target state="translated">La segunda forma es muy desaconsejada,porque rompe la capacidad de una subclase de reutilizar el constructor del progenitor,pero aún así se puede encontrar en el código existente.</target>
        </trans-unit>
        <trans-unit id="0819d819ae212b8e1bcdb9b5bc6d671458a8958e" translate="yes" xml:space="preserve">
          <source>The second form limits or expands the output with shell globbing as in the following examples:</source>
          <target state="translated">La segunda forma limita o amplía la salida con el &quot;shell globbing&quot; como en los siguientes ejemplos:</target>
        </trans-unit>
        <trans-unit id="c407c89499b72c27a5a072472ddedf2b307bb4f0" translate="yes" xml:space="preserve">
          <source>The second form takes an ASCII string of &quot;0&quot; and &quot;1&quot; characters as its argument. It's equivalent to</source>
          <target state="translated">La segunda forma toma como argumento una cadena ASCII de caracteres &quot;0&quot; y &quot;1&quot;.Es equivalente a</target>
        </trans-unit>
        <trans-unit id="653b770c920437547bfd253af4e36f98e0dbfce5" translate="yes" xml:space="preserve">
          <source>The second form, for convenience, simply calls the &lt;code&gt;new&lt;/code&gt; method on its arguments before dumping the object immediately.</source>
          <target state="translated">La segunda forma, por conveniencia, simplemente llama al &lt;code&gt;new&lt;/code&gt; m&amp;eacute;todo en sus argumentos antes de descargar el objeto inmediatamente.</target>
        </trans-unit>
        <trans-unit id="dc711c3d286876153bcbf61db541b42c9a9350fc" translate="yes" xml:space="preserve">
          <source>The second gives data on how many keys are at each depth in the chain, and gives an idea of how much work a fetch *hit* will take. The performance for an update or delete of an item in the hash is equivalent to this case.</source>
          <target state="translated">El segundo da datos sobre cuántas llaves hay en cada profundidad de la cadena,y da una idea de cuánto trabajo llevará un *hit*.El rendimiento para una actualización o eliminación de un elemento en el hash es equivalente a este caso.</target>
        </trans-unit>
        <trans-unit id="5995436678b8ce31e572994a72a1c15e94c7f93e" translate="yes" xml:space="preserve">
          <source>The second is</source>
          <target state="translated">El segundo es</target>
        </trans-unit>
        <trans-unit id="3d4dc00d964c0b0076b393752a2dfc8106f40760" translate="yes" xml:space="preserve">
          <source>The second is a question mark &lt;code&gt;?&lt;/code&gt; to match any single character. The third specifies a specific set of characters.</source>
          <target state="translated">&amp;iquest;El segundo es un signo de interrogaci&amp;oacute;n &lt;code&gt;?&lt;/code&gt; para que coincida con cualquier car&amp;aacute;cter. El tercero especifica un conjunto espec&amp;iacute;fico de caracteres.</target>
        </trans-unit>
        <trans-unit id="86badbc4e990f49a4a0e0309ce3e34af3acb8215" translate="yes" xml:space="preserve">
          <source>The second is, in short, more readable. In particular, it's obvious that the number of parameters you're feeding to that phrase (two) is the number of parameters that it</source>
          <target state="translated">La segunda es,en resumen,más legible.En particular,es obvio que el número de parámetros que alimenta a esa frase (dos)es el número de parámetros que</target>
        </trans-unit>
        <trans-unit id="7d7dcadbcc9256c73e53e45ca4167a8f00171936" translate="yes" xml:space="preserve">
          <source>The second method both creates the AV and initially populates it with SVs:</source>
          <target state="translated">El segundo método crea la AV y la llena inicialmente con SV:</target>
        </trans-unit>
        <trans-unit id="5a04571edd1042cba183eaac5eb081daffd5163c" translate="yes" xml:space="preserve">
          <source>The second method divides up the generated code into</source>
          <target state="translated">El segundo método divide el código generado en</target>
        </trans-unit>
        <trans-unit id="30b5717864fa144252bae28ce0e68e9e2886c509" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="translated">El segundo par&amp;aacute;metro de visualizaci&amp;oacute;n nuevo es &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt; , que se puede establecer en verdadero o falso, siendo el valor predeterminado verdadero. Consulte la secci&amp;oacute;n anterior para saber qu&amp;eacute; significa esto.</target>
        </trans-unit>
        <trans-unit id="a8d5bb3a74ae14b7cc834ba7cb47fc90749857de" translate="yes" xml:space="preserve">
          <source>The second new display parameter is &lt;code&gt;&quot;polar_pretty_print&quot;&lt;/code&gt;, which can be set to true or false, the default being true. See the previous section for what this means.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="105094491ac9a931737afcae5ec00cc67ecea83f" translate="yes" xml:space="preserve">
          <source>The second option is to explicitly instruct Configure to detect the newer Berkeley DB installation, by supplying the right directories with &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; and &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt;&lt;b&gt;and&lt;/b&gt; before running &quot;make test&quot; setting your LD_LIBRARY_PATH to</source>
          <target state="translated">La segunda opci&amp;oacute;n es indicar expl&amp;iacute;citamente a Configure que detecte la instalaci&amp;oacute;n m&amp;aacute;s reciente de Berkeley DB, proporcionando los directorios correctos con &lt;code&gt;-Dlocincpth=/some/include&lt;/code&gt; y &lt;code&gt;-Dloclibpth=/some/lib&lt;/code&gt; &lt;b&gt;y&lt;/b&gt; antes de ejecutar &quot;make test&quot; configurando LD_LIBRARY_PATH en</target>
        </trans-unit>
        <trans-unit id="b104d0289f2a63192d73ded4515b99bcffef5da9" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt; , is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt; , so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="translated">El segundo par&amp;aacute;metro, &lt;code&gt;$mode&lt;/code&gt; , se usa para especificar si el archivo se abre para lectura o escritura y para especificar opcionalmente un nivel de compresi&amp;oacute;n y una estrategia de compresi&amp;oacute;n al escribir. El formato del par&amp;aacute;metro &lt;code&gt;$mode&lt;/code&gt; es similar al par&amp;aacute;metro de modo de la funci&amp;oacute;n 'C' &lt;code&gt;fopen&lt;/code&gt; , por lo que &quot;rb&quot; se usa para abrir para leer, &quot;wb&quot; para escribir y &quot;ab&quot; para agregar (escribir al final del expediente).</target>
        </trans-unit>
        <trans-unit id="40f3477c6f4b0d20844832da1b4bf48b8115879e" translate="yes" xml:space="preserve">
          <source>The second parameter, &lt;code&gt;$mode&lt;/code&gt;, is used to specify whether the file is opened for reading or writing and to optionally specify a compression level and compression strategy when writing. The format of the &lt;code&gt;$mode&lt;/code&gt; parameter is similar to the mode parameter to the 'C' function &lt;code&gt;fopen&lt;/code&gt;, so &quot;rb&quot; is used to open for reading, &quot;wb&quot; for writing and &quot;ab&quot; for appending (writing at the end of the file).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3411b2ade45037b8736308e07cf74ad1d92df3ee" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;'^'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;'$'&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eae2bfeb40a7aaf7114e7fd8256ee81caccdbd3" translate="yes" xml:space="preserve">
          <source>The second regexp doesn't match because &lt;code&gt;^&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the beginning of the string, but &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; has keeper starting in the middle. The third regexp does match, since the &lt;code&gt;$&lt;/code&gt; constrains &lt;code&gt;keeper&lt;/code&gt; to match only at the end of the string.</source>
          <target state="translated">La segunda expresi&amp;oacute;n regular no coincide porque &lt;code&gt;^&lt;/code&gt; obliga al &lt;code&gt;keeper&lt;/code&gt; a coincidir solo al principio de la cadena, pero &lt;code&gt;&quot;housekeeper&quot;&lt;/code&gt; tiene al portero comenzando en el medio. La tercera expresi&amp;oacute;n regular coincide, ya que &lt;code&gt;$&lt;/code&gt; restringe al &lt;code&gt;keeper&lt;/code&gt; a que coincida solo al final de la cadena.</target>
        </trans-unit>
        <trans-unit id="733da91fc44d8ab5e75ced78a6cc48a582c7d7b0" translate="yes" xml:space="preserve">
          <source>The second returned item and &lt;code&gt;$!&lt;/code&gt; can be used to check for valid input:</source>
          <target state="translated">&amp;iexcl;El segundo art&amp;iacute;culo devuelto y &lt;code&gt;$!&lt;/code&gt; se puede utilizar para verificar una entrada v&amp;aacute;lida:</target>
        </trans-unit>
        <trans-unit id="2c1496bf9c5a01143ce96b1f9c010fe32e40f772" translate="yes" xml:space="preserve">
          <source>The second sentence is wrong. In actual fact bval will only default to &lt;code&gt;&quot;\n&quot;&lt;/code&gt; when the openinfo parameter in dbopen is NULL. If a non-NULL openinfo parameter is used at all, the value that happens to be in bval will be used. That means you always have to specify bval when making use of any of the options in the openinfo parameter. This documentation error will be fixed in the next release of Berkeley DB.</source>
          <target state="translated">La segunda oraci&amp;oacute;n es incorrecta. De hecho, bval solo tendr&amp;aacute; el valor predeterminado &lt;code&gt;&quot;\n&quot;&lt;/code&gt; cuando el par&amp;aacute;metro openinfo en dbopen sea NULL. Si se usa un par&amp;aacute;metro openinfo que no sea NULL, se usar&amp;aacute; el valor que est&amp;eacute; en bval. Eso significa que siempre debe especificar bval al hacer uso de cualquiera de las opciones en el par&amp;aacute;metro openinfo. Este error de documentaci&amp;oacute;n se solucionar&amp;aacute; en la pr&amp;oacute;xima versi&amp;oacute;n de Berkeley DB.</target>
        </trans-unit>
        <trans-unit id="aaad1f57fe700f2a9b2dd58ec708684feaf8128f" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a lexical subroutine that has gone out of scope, for example,</source>
          <target state="translated">La segunda situación se debe a que una evaluación accede a una subrutina léxica que ha quedado fuera de alcance,por ejemplo,</target>
        </trans-unit>
        <trans-unit id="9ade278ee614d31e9547b1781d35dc6ff90a8980" translate="yes" xml:space="preserve">
          <source>The second situation is caused by an eval accessing a variable that has gone out of scope, for example,</source>
          <target state="translated">La segunda situación se debe a que una evaluación accede a una variable que se ha salido de su ámbito de aplicación,por ejemplo,</target>
        </trans-unit>
        <trans-unit id="b47d8c8a23f4e0d763e99999d69c0c5eb0cb3a92" translate="yes" xml:space="preserve">
          <source>The second style of bundling lifts this restriction. It can be enabled with:</source>
          <target state="translated">El segundo estilo de agrupación levanta esta restricción.Se puede activar con:</target>
        </trans-unit>
        <trans-unit id="ab8073e684e0f88cfe3fd5f9716b9c696bbef27e" translate="yes" xml:space="preserve">
          <source>The second value to be substituted in the output string (usually the row in cursor addressing capabilities)</source>
          <target state="translated">El segundo valor que debe sustituirse en la cadena de salida (normalmente la fila en las capacidades de direccionamiento del cursor)</target>
        </trans-unit>
        <trans-unit id="72ec171fc6e9d8dd4e1917d8ba0d47a2f390d23d" translate="yes" xml:space="preserve">
          <source>The second, more efficient way is to use the following template for your Foo.xs:</source>
          <target state="translated">La segunda forma,más eficiente,es usar la siguiente plantilla para sus Foo.xs:</target>
        </trans-unit>
        <trans-unit id="ea8fa202ee5b9df3dfb7272625ecae21681f7d7d" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="translated">La secci&amp;oacute;n (tambi&amp;eacute;n conocido como &quot;elemento&quot; en perlpods m&amp;aacute;s antiguos), o &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; si no hay ninguno. Por ejemplo, en &quot;L &amp;lt;Getopt :: Std / DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; es la secci&amp;oacute;n. (Tenga en cuenta que esto no es lo mismo que una secci&amp;oacute;n de p&amp;aacute;gina de manual como el &quot;5&quot; en &quot;man 5 crontab&quot;. &quot;Secci&amp;oacute;n Foo&quot; en el sentido de Pod significa la parte del texto que se introduce en el encabezado o elemento cuyo texto es &quot;Foo &quot;.)</target>
        </trans-unit>
        <trans-unit id="cd89b9d74f7d870dca4a759e8ab8f51f0dc1f9b2" translate="yes" xml:space="preserve">
          <source>The section (AKA &quot;item&quot; in older perlpods), or &lt;code&gt;undef&lt;/code&gt; if none. E.g., in &quot;L&amp;lt;Getopt::Std/DESCRIPTION&amp;gt;&quot;, &quot;DESCRIPTION&quot; is the section. (Note that this is not the same as a manpage section like the &quot;5&quot; in &quot;man 5 crontab&quot;. &quot;Section Foo&quot; in the Pod sense means the part of the text that's introduced by the heading or item whose text is &quot;Foo&quot;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="592a5f44132e9a3aa5e9a10cfa07afacf196746b" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;&quot;safe_level&quot;&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d5faf936bbea0ef6b4af3b53c6607ced9b3cdea" translate="yes" xml:space="preserve">
          <source>The security aspect of temporary file creation is emphasized such that a filehandle and filename are returned together. This helps guarantee that a race condition can not occur where the temporary file is created by another process between checking for the existence of the file and its opening. Additional security levels are provided to check, for example, that the sticky bit is set on world writable directories. See &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; for more information.</source>
          <target state="translated">El aspecto de seguridad de la creaci&amp;oacute;n de archivos temporales se enfatiza de manera que un identificador de archivo y un nombre de archivo se devuelven juntos. Esto ayuda a garantizar que no pueda ocurrir una condici&amp;oacute;n de carrera cuando el archivo temporal es creado por otro proceso entre la verificaci&amp;oacute;n de la existencia del archivo y su apertura. Se proporcionan niveles de seguridad adicionales para comprobar, por ejemplo, que el bit adhesivo est&amp;aacute; configurado en directorios de escritura mundial. Consulte &lt;a href=&quot;#safe_level&quot;&gt;safe_level&lt;/a&gt; para obtener m&amp;aacute;s informaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="02ef1170c6c4276366f2c9602e48f300db3d9145" translate="yes" xml:space="preserve">
          <source>The seemingly equivalent construct in Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; first does the deref of $aref, making it take $aref as a reference to an array, and then dereference that, and finally tell you the</source>
          <target state="translated">La construcci&amp;oacute;n aparentemente equivalente en Perl, &lt;code&gt;$$aref[$i]&lt;/code&gt; primero hace el deref de $ aref, haciendo que tome $ aref como una referencia a una matriz, y luego desreferencia eso, y finalmente le diga el</target>
        </trans-unit>
        <trans-unit id="5ae490ef8bae426993ed6639b51d33e36f67a5f8" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;a href=&quot;setitimer(2)&quot;&gt;&lt;code&gt;setitimer(2)&lt;/code&gt;&lt;/a&gt; documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5d3a7adddb69f2204deb61bd662439aeebd384d4" translate="yes" xml:space="preserve">
          <source>The semantics of interval timers for multithreaded programs are system-specific, and some systems may support additional interval timers. For example, it is unspecified which thread gets the signals. See your &lt;code&gt;setitimer()&lt;/code&gt; documentation.</source>
          <target state="translated">La sem&amp;aacute;ntica de los temporizadores de intervalo para programas multiproceso es espec&amp;iacute;fica del sistema y algunos sistemas pueden admitir temporizadores de intervalo adicionales. Por ejemplo, no se especifica qu&amp;eacute; hilo recibe las se&amp;ntilde;ales. Consulte la &lt;code&gt;setitimer()&lt;/code&gt; su setitimer () .</target>
        </trans-unit>
        <trans-unit id="65ef3e0624e679879b7ce02cec7d6809073f165d" translate="yes" xml:space="preserve">
          <source>The sense of the match can be reversed by using &lt;code&gt;!~&lt;/code&gt; operator:</source>
          <target state="translated">El sentido de la coincidencia se puede revertir usando el operador &lt;code&gt;!~&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="571f2b8a003669439aca5df927f2bc3b59493e17" translate="yes" xml:space="preserve">
          <source>The sequence &lt;code&gt;\b&lt;/code&gt; is special inside a bracketed character class. While outside the character class, &lt;code&gt;\b&lt;/code&gt; is an assertion indicating a point that does not have either two word characters or two non-word characters on either side, inside a bracketed character class, &lt;code&gt;\b&lt;/code&gt; matches a backspace character.</source>
          <target state="translated">La secuencia &lt;code&gt;\b&lt;/code&gt; es especial dentro de una clase de caracteres entre corchetes. Mientras est&amp;aacute; fuera de la clase de caracteres, &lt;code&gt;\b&lt;/code&gt; es una afirmaci&amp;oacute;n que indica un punto que no tiene dos caracteres de palabra o dos caracteres que no son de palabra en ninguno de los lados, dentro de una clase de caracteres entre corchetes, &lt;code&gt;\b&lt;/code&gt; coincide con un car&amp;aacute;cter de retroceso.</target>
        </trans-unit>
        <trans-unit id="2e682f0e9f09d4fac48ccdb6cb912af9bfeddf7f" translate="yes" xml:space="preserve">
          <source>The sequence can also be extended to negative index n using the re-arranged recurrence relation</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b263532d25e62f98e230387976bd3e1a8c5cb59" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP's next OP.</source>
          <target state="translated">El número de secuencia de la siguiente operación.</target>
        </trans-unit>
        <trans-unit id="b45bacc53a5ed1f0afceaa4ff3006834edab117c" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP, or a hyphen if it doesn't have one.</source>
          <target state="translated">El número de secuencia de la OP,o un guión si no tiene uno.</target>
        </trans-unit>
        <trans-unit id="4f0a83d5889e74bacf92e475321b6ad01721beb5" translate="yes" xml:space="preserve">
          <source>The sequence number of the OP. Note that this is a sequence number generated by B::Concise.</source>
          <target state="translated">El número de secuencia de la OP.Note que este es un número de secuencia generado por B::Conciso.</target>
        </trans-unit>
        <trans-unit id="a1e46d38c7dda11bf03f174aca8ec057ac38a288" translate="yes" xml:space="preserve">
          <source>The sequence number of this partition. Partitions are numbered starting as &lt;code&gt;1&lt;/code&gt; [with &quot;partition 0&quot; meaning the entire disk]. Sometimes this field may be &lt;code&gt;0&lt;/code&gt; and you'll have to infer the partition sequence number from how many partitions precede it on the disk.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c10dc949f49eb3d32cdb0534e93e9f1fddb641e8" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; , and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="translated">Las secuencias &lt;code&gt;\a&lt;/code&gt; , &lt;code&gt;\c&lt;/code&gt; , &lt;code&gt;\e&lt;/code&gt; , &lt;code&gt;\f&lt;/code&gt; , &lt;code&gt;\n&lt;/code&gt; , &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt; , &lt;code&gt;\r&lt;/code&gt; , &lt;code&gt;\t&lt;/code&gt; y &lt;code&gt;\x&lt;/code&gt; tambi&amp;eacute;n son especiales y tienen los mismos significados que hacer fuera de una clase de caracteres entre corchetes.</target>
        </trans-unit>
        <trans-unit id="90a0a5f9a35ae3ea0a297068e4b1bab795815fcf" translate="yes" xml:space="preserve">
          <source>The sequences &lt;code&gt;\a&lt;/code&gt;, &lt;code&gt;\c&lt;/code&gt;, &lt;code&gt;\e&lt;/code&gt;, &lt;code&gt;\f&lt;/code&gt;, &lt;code&gt;\n&lt;/code&gt;, &lt;code&gt;\N{&lt;i&gt;NAME&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\N{U+&lt;i&gt;hex char&lt;/i&gt;}&lt;/code&gt;, &lt;code&gt;\r&lt;/code&gt;, &lt;code&gt;\t&lt;/code&gt;, and &lt;code&gt;\x&lt;/code&gt; are also special and have the same meanings as they do outside a bracketed character class.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="899a56478deaf614d4bf9d04537d9557616e32cf" translate="yes" xml:space="preserve">
          <source>The serialized structure will include a &lt;code&gt;x_serialization_backend&lt;/code&gt; entry giving the package and version used to serialize. Any existing key in the given &lt;code&gt;$meta&lt;/code&gt; object will be clobbered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0d53186f69243fe4e7fc81db07bccfc51f977e9e" translate="yes" xml:space="preserve">
          <source>The serializing hook, called on the object during serialization. It can be inherited, or defined in the class itself, like any other method.</source>
          <target state="translated">El gancho de serialización,llamó al objeto durante la serialización.Puede ser heredado,o definido en la propia clase,como cualquier otro método.</target>
        </trans-unit>
        <trans-unit id="4e9ebcecc7a860f145ea8f9108514a4fa8316dfb" translate="yes" xml:space="preserve">
          <source>The service name supplied to getaddrinfo() is not available for the socket type given in the $hints.</source>
          <target state="translated">El nombre de servicio suministrado a getaddrinfo()no está disponible para el tipo de enchufe dado en los $hints.</target>
        </trans-unit>
        <trans-unit id="ba23ccf9d34101355ab34a3727e24a0a0f7b250a" translate="yes" xml:space="preserve">
          <source>The services a piece of code promises to provide forever, in contrast to its &lt;b&gt;implementation&lt;/b&gt;, which it should feel free to change whenever it likes.</source>
          <target state="translated">Los servicios que un fragmento de c&amp;oacute;digo promete proporcionar para siempre, en contraste con su &lt;b&gt;implementaci&amp;oacute;n&lt;/b&gt; , que deber&amp;iacute;a sentirse libre de cambiar cuando quiera.</target>
        </trans-unit>
        <trans-unit id="32c78a4d560dbf4474d5f3b5cef5e0e631bdf4c5" translate="yes" xml:space="preserve">
          <source>The set is specified as a list of characters, or as a range of characters where the beginning and end of the range are separated by a minus (or dash) character, or as any combination of lists and ranges. The dash can also be included in the set as a character it if is the beginning or end of the set. This set is enclosed in square brackets. The close square bracket &lt;code&gt;]&lt;/code&gt; may be used in a set if it is the first character in the set.</source>
          <target state="translated">El conjunto se especifica como una lista de caracteres o como un rango de caracteres donde el principio y el final del rango est&amp;aacute;n separados por un car&amp;aacute;cter menos (o gui&amp;oacute;n), o como cualquier combinaci&amp;oacute;n de listas y rangos. El gui&amp;oacute;n tambi&amp;eacute;n se puede incluir en el conjunto como un car&amp;aacute;cter, si es el principio o el final del conjunto. Este conjunto est&amp;aacute; entre corchetes. El corchete cerrado &lt;code&gt;]&lt;/code&gt; se puede utilizar en un conjunto si es el primer car&amp;aacute;cter del conjunto.</target>
        </trans-unit>
        <trans-unit id="271c11282a628a982454242ec29109ed2ea23f1d" translate="yes" xml:space="preserve">
          <source>The set of characters that are deemed whitespace are those that Unicode calls &quot;Pattern White Space&quot;, namely:</source>
          <target state="translated">El conjunto de caracteres que se consideran espacio en blanco son los que Unicode llama &quot;Patrón de espacio en blanco&quot;,a saber:</target>
        </trans-unit>
        <trans-unit id="5e7d4549f7a90817f3e92cc9271f629864ca580a" translate="yes" xml:space="preserve">
          <source>The setlocale function</source>
          <target state="translated">La función setlocale</target>
        </trans-unit>
        <trans-unit id="6cd53441a7a72535c4ff8e055f31a3a3fc042379" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="translated">La configuraci&amp;oacute;n de los atributos de las subrutinas ocurre en el momento de la compilaci&amp;oacute;n. Los atributos variables en &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; declaraciones tambi&amp;eacute;n se aplican en tiempo de compilaci&amp;oacute;n. Sin embargo, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; variables obtienen sus atributos aplicados en tiempo de ejecuci&amp;oacute;n. Esto significa que tienes que</target>
        </trans-unit>
        <trans-unit id="229ecae54cd846eee20b1cbee543175ec9cd197e" translate="yes" xml:space="preserve">
          <source>The setting of subroutine attributes happens at compile time. Variable attributes in &lt;code&gt;our&lt;/code&gt; declarations are also applied at compile time. However, &lt;code&gt;my&lt;/code&gt; variables get their attributes applied at run-time. This means that you have to</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ab1edc3ed4db36281da6290a4a02b6bb1d2f2a9a" translate="yes" xml:space="preserve">
          <source>The seven routines are:</source>
          <target state="translated">Las siete rutinas son:</target>
        </trans-unit>
        <trans-unit id="7db711982141cfb12b9e3602192ccba86ac4d921" translate="yes" xml:space="preserve">
          <source>The sheet</source>
          <target state="translated">La sábana</target>
        </trans-unit>
        <trans-unit id="67100f7fba2fe91ac3115331e86988966a0f9ad9" translate="yes" xml:space="preserve">
          <source>The shell offers to run in</source>
          <target state="translated">El proyectil se ofrece a correr en</target>
        </trans-unit>
        <trans-unit id="d2a4c575dba49342e824220d900f0c783780f4b9" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="translated">La &lt;code&gt;test&lt;/code&gt; del shell usa &quot;=&quot;, &quot;! =&quot;, &quot;&amp;lt;&quot;, Etc. para comparaciones de cadenas y &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot;, etc. para comparaciones num&amp;eacute;ricas. Este es el reverso de Perl, que utiliza &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; , &lt;code&gt;lt&lt;/code&gt; para las comparaciones de cadenas, y &lt;code&gt;==&lt;/code&gt; , &lt;code&gt;!=&lt;/code&gt; &lt;code&gt;&amp;lt;&lt;/code&gt; Etc para comparaciones num&amp;eacute;ricas.</target>
        </trans-unit>
        <trans-unit id="a4421a2ab5bd2e622c5d0a683eecbd4f08bbe24b" translate="yes" xml:space="preserve">
          <source>The shell's &lt;code&gt;test&lt;/code&gt; uses &quot;=&quot;, &quot;!=&quot;, &quot;&amp;lt;&quot; etc for string comparisons and &quot;-eq&quot;, &quot;-ne&quot;, &quot;-lt&quot; etc for numeric comparisons. This is the reverse of Perl, which uses &lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;, &lt;code&gt;lt&lt;/code&gt; for string comparisons, and &lt;code&gt;==&lt;/code&gt;, &lt;code&gt;!=&lt;/code&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; etc for numeric comparisons.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe36cec28443e99377776c6efc56682531e56f06" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="translated">La respuesta corta es que, por defecto, Perl compara la equivalencia ( &lt;code&gt;eq&lt;/code&gt; , &lt;code&gt;ne&lt;/code&gt; ) bas&amp;aacute;ndose solo en los puntos de c&amp;oacute;digo de los caracteres. En el caso anterior, la respuesta es no (porque 0x00C1! = 0x0041). Pero a veces, cualquier LETRA MAY&amp;Uacute;SCULA A debe considerarse igual, o incluso A en cualquier caso.</target>
        </trans-unit>
        <trans-unit id="84602cf60297d60acdefd80efdd1c60462b73b9b" translate="yes" xml:space="preserve">
          <source>The short answer is that by default Perl compares equivalence (&lt;code&gt;eq&lt;/code&gt;, &lt;code&gt;ne&lt;/code&gt;) based only on code points of the characters. In the above case, the answer is no (because 0x00C1 != 0x0041). But sometimes, any CAPITAL LETTER A's should be considered equal, or even A's of any case.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b57501930c25501b20f82b569d1ea16761a497e6" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</source>
          <target state="translated">La respuesta corta es que, por defecto, Perl compara cadenas ( &lt;code&gt;lt&lt;/code&gt; , &lt;code&gt;le&lt;/code&gt; , &lt;code&gt;cmp&lt;/code&gt; , &lt;code&gt;ge&lt;/code&gt; , &lt;code&gt;gt&lt;/code&gt; ) bas&amp;aacute;ndose &amp;uacute;nicamente en los puntos de c&amp;oacute;digo de los caracteres. En el caso anterior, la respuesta es &quot;despu&amp;eacute;s&quot;, ya que &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d67ccb6666f81cda59931fcf7ad032ead024bc41" translate="yes" xml:space="preserve">
          <source>The short answer is that by default, Perl compares strings (&lt;code&gt;lt&lt;/code&gt;, &lt;code&gt;le&lt;/code&gt;, &lt;code&gt;cmp&lt;/code&gt;, &lt;code&gt;ge&lt;/code&gt;, &lt;code&gt;gt&lt;/code&gt;) based only on the code points of the characters. In the above case, the answer is &quot;after&quot;, since &lt;code&gt;0x00C1&lt;/code&gt; &amp;gt; &lt;code&gt;0x00C0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ace0e0cec639bb708cb2cf532e982971dd3748da" translate="yes" xml:space="preserve">
          <source>The short name of the general category of</source>
          <target state="translated">El nombre corto de la categoría general de</target>
        </trans-unit>
        <trans-unit id="02c6ec10d109a1b719286e329258adf56d502cef" translate="yes" xml:space="preserve">
          <source>The short story</source>
          <target state="translated">La historia corta</target>
        </trans-unit>
        <trans-unit id="eb4d2d85d25fb4d71e2225f2e7a3eb6515112128" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;functions/defined&quot;&gt;defined&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="translated">La historia corta es que probablemente solo deber&amp;iacute;a usar definido en escalares o funciones, no en agregados (matrices y hashes). Consulte la &lt;a href=&quot;functions/defined&quot;&gt;definici&amp;oacute;n&lt;/a&gt; de la versi&amp;oacute;n 5.004 o posterior de Perl para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="53f5dab7a291daa9043df504d583260ae569f535" translate="yes" xml:space="preserve">
          <source>The short story is that you should probably only use defined on scalars or functions, not on aggregates (arrays and hashes). See &lt;a href=&quot;perlfunc#defined&quot;&gt;&quot;defined&quot; in perlfunc&lt;/a&gt; in the 5.004 release or later of Perl for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be047f864fccecb4801e21c3ca26d33faa969dbf" translate="yes" xml:space="preserve">
          <source>The sign &lt;code&gt;/^[+-]$/&lt;/code&gt; is stored separately. The string 'NaN' is used to represent the result when input arguments are not numbers, as well as the result of dividing by zero.</source>
          <target state="translated">El signo &lt;code&gt;/^[+-]$/&lt;/code&gt; se almacena por separado. La cadena 'NaN' se usa para representar el resultado cuando los argumentos de entrada no son n&amp;uacute;meros, as&amp;iacute; como el resultado de dividir por cero.</target>
        </trans-unit>
        <trans-unit id="5d535efa9748a7b51984807c3b0e47062fc14e19" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf' and stored separately. You can access it with the sign() method.</source>
          <target state="translated">El signo es &quot;+&quot;,&quot;-&quot;,&quot;NaN&quot;,&quot;+inf&quot; o &quot;-inf&quot; y se guardan por separado.Puedes acceder a él con el método sign().</target>
        </trans-unit>
        <trans-unit id="be8bba598ba0bfbad37b038eb92c99bbb5b687ac" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'.</source>
          <target state="translated">El signo es &quot;+&quot;,&quot;-&quot;,&quot;NaN&quot;,&quot;+inf&quot; o &quot;-inf&quot;.</target>
        </trans-unit>
        <trans-unit id="32ee9fc8e75a1189426734a34b70183ae0bf5e08" translate="yes" xml:space="preserve">
          <source>The sign is either '+', '-', 'NaN', '+inf' or '-inf'. You can access it with the sign() method.</source>
          <target state="translated">El signo es &quot;+&quot;,&quot;-&quot;,&quot;NaN&quot;,&quot;+inf&quot; o &quot;-inf&quot;.Puedes acceder a él con el método sign().</target>
        </trans-unit>
        <trans-unit id="11646904ceab245420048654e9bde4a41bb7ec59" translate="yes" xml:space="preserve">
          <source>The signal Exec signal mask</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="104ebb4db613ce634a3b75383995774c2e797f04" translate="yes" xml:space="preserve">
          <source>The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d781ab42c79199084a9c305d1ab2ed6d80e787b" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code, but when using a signature, the signature is a parenthesised list that goes immediately before the block, after any name or attributes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d68142e064ec1d6e704c7c13d44f8b02e77345ce" translate="yes" xml:space="preserve">
          <source>The signature is part of a subroutine's body. Normally the body of a subroutine is simply a braced block of code. When using a signature, the signature is a parenthesised list that goes immediately after the subroutine name. The signature declares lexical variables that are in scope for the block. When the subroutine is called, the signature takes control first. It populates the signature variables from the list of arguments that were passed. If the argument list doesn't meet the requirements of the signature, then it will throw an exception. When the signature processing is complete, control passes to the block.</source>
          <target state="translated">La firma es parte del cuerpo de una subrutina.Normalmente el cuerpo de una subrutina es simplemente un bloque de código reforzado.Cuando se usa una firma,la firma es una lista entre paréntesis que va inmediatamente después del nombre de la subrutina.La firma declara las variables léxicas que están en el ámbito del bloque.Cuando se llama la subrutina,la firma toma el control primero.Pobla las variables de la firma de la lista de argumentos que fueron pasados.Si la lista de argumentos no cumple los requisitos de la firma,entonces lanzará una excepción.Cuando el procesamiento de la firma se completa,el control pasa al bloque.</target>
        </trans-unit>
        <trans-unit id="8bf79dd34df166da1a0a362d8a7c14bc52139481" translate="yes" xml:space="preserve">
          <source>The signatures feature is experimental</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebf9d6090863be01051258238bf3ef2c8b46c7c9" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched as-is by putting a backslash before it:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2444d6c2a6baf7e1580c4abcb9b61735a0532f35" translate="yes" xml:space="preserve">
          <source>The significance of each of these will be explained in the rest of the tutorial, but for now, it is important only to know that a metacharacter can be matched by putting a backslash before it:</source>
          <target state="translated">El significado de cada uno de ellos se explicará en el resto del tutorial,pero por ahora,sólo es importante saber que un metacaracter se puede igualar poniendo una barra invertida delante de él:</target>
        </trans-unit>
        <trans-unit id="d05188639d7fd13d368b039de9eab91f22380450" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt; , matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; . That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="translated">La propiedad de nombre similar, &lt;code&gt;\p{Punct}&lt;/code&gt; , coincide con un conjunto algo diferente en el rango ASCII, a saber, &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt; ,. /:;? @ [\\\] _ {}] . Es decir, faltan los nueve caracteres &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt; . Esto se debe a que Unicode divide lo que POSIX considera puntuaci&amp;oacute;n en dos categor&amp;iacute;as, Puntuaci&amp;oacute;n y S&amp;iacute;mbolos.</target>
        </trans-unit>
        <trans-unit id="8cd091ac264b3ba5cf264f4cd380086afff2aabf" translate="yes" xml:space="preserve">
          <source>The similarly named property, &lt;code&gt;\p{Punct}&lt;/code&gt;, matches a somewhat different set in the ASCII range, namely &lt;code&gt;[-!&quot;#%&amp;amp;'()*,./:;?@[\\\]_{}]&lt;/code&gt;. That is, it is missing the nine characters &lt;code&gt;[$+&amp;lt;=&amp;gt;^`|~]&lt;/code&gt;. This is because Unicode splits what POSIX considers to be punctuation into two categories, Punctuation and Symbols.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a851643ae5a58ccc6f3ce68bfdab3a7ef68d1794" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt; , execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="translated">La regla simple es: la herencia no funcionar&amp;aacute; cuando se carguen autom&amp;aacute;ticamente los no m&amp;eacute;todos. La soluci&amp;oacute;n simple para el c&amp;oacute;digo antiguo es: En cualquier m&amp;oacute;dulo que sol&amp;iacute;a depender de la herencia de &lt;code&gt;AUTOLOAD&lt;/code&gt; para no m&amp;eacute;todos de una clase base llamada &lt;code&gt;BaseClass&lt;/code&gt; , ejecute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; durante el inicio.</target>
        </trans-unit>
        <trans-unit id="145065cb1f22a69e2ed6682015cb7947554b75d7" translate="yes" xml:space="preserve">
          <source>The simple rule is: Inheritance will not work when autoloading non-methods. The simple fix for old code is: In any module that used to depend on inheriting &lt;code&gt;AUTOLOAD&lt;/code&gt; for non-methods from a base class named &lt;code&gt;BaseClass&lt;/code&gt;, execute &lt;code&gt;*AUTOLOAD = \&amp;amp;BaseClass::AUTOLOAD&lt;/code&gt; during startup.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5af89b6d15a00a979315dfddae0b5f323e4af12" translate="yes" xml:space="preserve">
          <source>The simple rule to remember, if you want to match a literal &lt;code&gt;{&lt;/code&gt; character (U+007B &lt;code&gt;LEFT CURLY BRACKET&lt;/code&gt;) in a regular expression pattern, is to escape each literal instance of it in some way. Generally easiest is to precede it with a backslash, like &lt;code&gt;\{&lt;/code&gt; or enclose it in square brackets (&lt;code&gt;[{]&lt;/code&gt;). If the pattern delimiters are also braces, any matching right brace (&lt;code&gt;}&lt;/code&gt;) should also be escaped to avoid confusing the parser, for example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41d909120b343bfa9af89dc978321448d395292c" translate="yes" xml:space="preserve">
          <source>The simple stdio implementation creates the files</source>
          <target state="translated">La simple implementación de stdio crea los archivos</target>
        </trans-unit>
        <trans-unit id="f2a9e9b7a3c97685eea0b1595b9417bb605f6809" translate="yes" xml:space="preserve">
          <source>The simplest XSUBs consist of 3 parts: a description of the return value, the name of the XSUB routine and the names of its arguments, and a description of types or formats of the arguments.</source>
          <target state="translated">Los XSUB más simples constan de 3 partes:una descripción del valor de retorno,el nombre de la rutina XSUB y los nombres de sus argumentos,y una descripción de los tipos o formatos de los argumentos.</target>
        </trans-unit>
        <trans-unit id="5cfe5e43e01ddc5838feef9195e0126bb74ada96" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt; . Thus the integer regexp is</source>
          <target state="translated">El caso m&amp;aacute;s simple son los n&amp;uacute;meros enteros. Estos consisten en una secuencia de d&amp;iacute;gitos, con un signo opcional al frente. Los d&amp;iacute;gitos que podemos representar con &lt;code&gt;\d+&lt;/code&gt; y el signo se pueden emparejar con &lt;code&gt;[+-]&lt;/code&gt; . Por lo tanto, la expresi&amp;oacute;n regular entera es</target>
        </trans-unit>
        <trans-unit id="16ed7663dd31b0d719b95952e4dbcc002ac1e075" translate="yes" xml:space="preserve">
          <source>The simplest case is integers. These consist of a sequence of digits, with an optional sign in front. The digits we can represent with &lt;code&gt;\d+&lt;/code&gt; and the sign can be matched with &lt;code&gt;[+-]&lt;/code&gt;. Thus the integer regexp is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5ce4a00629ba2eb87550ae04e313683cd18e39d" translate="yes" xml:space="preserve">
          <source>The simplest format for a Version Range is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="205579583087d3f83514fed292a979acc1fd2056" translate="yes" xml:space="preserve">
          <source>The simplest format for a version specification is just the version number itself, e.g. &lt;code&gt;2.4&lt;/code&gt;. This means that &lt;b&gt;at least&lt;/b&gt; version 2.4 must be present. To indicate that &lt;b&gt;any&lt;/b&gt; version of a prerequisite is okay, even if the prerequisite doesn't define a version at all, use the version &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="90f647a57152f0376dead3744742f9e10945d73a" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt; .</source>
          <target state="translated">El m&amp;eacute;todo m&amp;aacute;s simple usa la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; . Puede rellenar la izquierda o la derecha con espacios en blanco y la izquierda con ceros y no truncar&amp;aacute; el resultado. La funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;&lt;/code&gt; solo puede rellenar las cadenas de la derecha con espacios en blanco y truncar&amp;aacute; el resultado a una longitud m&amp;aacute;xima de &lt;code&gt;$pad_len&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="60ef9faadf39e8b6092ce866661076ad7721c8c1" translate="yes" xml:space="preserve">
          <source>The simplest method uses the &lt;code&gt;sprintf&lt;/code&gt; function. It can pad on the left or right with blanks and on the left with zeroes and it will not truncate the result. The &lt;code&gt;pack&lt;/code&gt; function can only pad strings on the right with blanks and it will truncate the result to a maximum length of &lt;code&gt;$pad_len&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc3e208a9819c2ed872df1040ec4eed39730cc50" translate="yes" xml:space="preserve">
          <source>The simplest regex is simply a word, or more generally, a string of characters. A regex consisting of a word matches any string that contains that word:</source>
          <target state="translated">El regex más simple es simplemente una palabra,o más generalmente,una cadena de caracteres.Un regex que consiste en una palabra coincide con cualquier cadena que contenga esa palabra:</target>
        </trans-unit>
        <trans-unit id="e7349953e0f225a36578668e9ad5be25a2093d5b" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of a word matches any string that contains that word:</source>
          <target state="translated">El regexp más simple es simplemente una palabra,o más generalmente,una cadena de caracteres.Un regexp que consiste en una palabra coincide con cualquier cadena que contenga esa palabra:</target>
        </trans-unit>
        <trans-unit id="0eaf5ad324e3121e2a83d8b08987e28055dbf879" translate="yes" xml:space="preserve">
          <source>The simplest regexp is simply a word, or more generally, a string of characters. A regexp consisting of just a word matches any string that contains that word:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f93ecdae42936826d9c1b25b5229a95d439104b0" translate="yes" xml:space="preserve">
          <source>The simplest style of bundling can be enabled with:</source>
          <target state="translated">Se puede habilitar el estilo más simple de agrupación con:</target>
        </trans-unit>
        <trans-unit id="7cd479644d912e323fa369ec3403c930944ff04b" translate="yes" xml:space="preserve">
          <source>The simplest two-level data structure to build in Perl is an array of arrays, sometimes casually called a list of lists. It's reasonably easy to understand, and almost everything that applies here will also be applicable later on with the fancier data structures.</source>
          <target state="translated">La estructura de datos de dos niveles más sencilla de construir en Perl es un conjunto de matrices,a veces llamadas casualmente lista de listas.Es razonablemente fácil de entender,y casi todo lo que se aplica aquí también se aplicará más adelante con las estructuras de datos más elegantes.</target>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
