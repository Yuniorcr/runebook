<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" version="1.2">
  <file source-language="en" target-language="es" datatype="htmlbody" original="perl">
    <body>
      <group id="perl">
        <trans-unit id="b01d04c5af24a4340d0f912c2ccf886a5fc1edcb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#exit-EXPR&quot;&gt;&lt;code&gt;exit&lt;/code&gt;&lt;/a&gt; function does not always exit immediately. It calls any defined &lt;code&gt;END&lt;/code&gt; routines first, but these &lt;code&gt;END&lt;/code&gt; routines may not themselves abort the exit. Likewise any object destructors that need to be called are called before the real exit. &lt;code&gt;END&lt;/code&gt; routines and destructors can change the exit status by modifying &lt;a href=&quot;perlvar#%24%3F&quot;&gt;&lt;code&gt;$?&lt;/code&gt;&lt;/a&gt;. If this is a problem, you can call &lt;a href=&quot;posix#_exit&quot;&gt;&lt;code&gt;POSIX::_exit($status)&lt;/code&gt;&lt;/a&gt; to avoid &lt;code&gt;END&lt;/code&gt; and destructor processing. See &lt;a href=&quot;perlmod&quot;&gt;perlmod&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ee540728eb307530289af963d36689ec3a1444d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#getprotobynumber-NUMBER&quot;&gt;&lt;code&gt;getprotobynumber&lt;/code&gt;&lt;/a&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a1f9e63055c82c44f33e919de1bfed56733c2d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;last EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;last LABEL&lt;/code&gt;. The &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block, if any, is not executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="889dc5e06ef6b79bfd7037342382aa88c842b099" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#next-LABEL&quot;&gt;&lt;code&gt;next&lt;/code&gt;&lt;/a&gt; command is like the &lt;code&gt;continue&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f6c37dbdd3d3faf157e953bebef6eeac7f43fa10" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#oct-EXPR&quot;&gt;&lt;code&gt;oct&lt;/code&gt;&lt;/a&gt; function is commonly used when a string such as &lt;code&gt;644&lt;/code&gt; needs to be converted into a file mode, for example. Although Perl automatically converts strings into numbers as needed, this automatic conversion assumes base 10.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2173488a74d711836ae18ee727857a8643388af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the external protocol. Uses &lt;a href=&quot;Net::Ping::External&quot;&gt;Net::Ping::External&lt;/a&gt; to do an external ping.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc7c9b7850979e6e7def2184badf7bf1bc4a1d3d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the forking syn protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="641eb29f28723359d8e506ee9152e1f38204dfa6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the icmp protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1957ff6c7452234943290c79fb5d121b6e83c5a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the icmpv6 protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acd013c64eb2eb70a4842cac8e8d68d7939687f1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the stream protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cbf91af075e5c18933e470cdffacd91d45bab2cc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the syn protocol. Sends a TCP SYN packet to host specified.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e289226b6ef91e47994450b9dc7ca74494856a25" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the tcp protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8bacd7d416bf9eb142f724a00d7ab4625004301a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#ping&quot;&gt;&quot;ping&quot;&lt;/a&gt; method used with the udp protocol.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be711bbef7a00d2eb13cc8d85cfba9b425e71aaf" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4486da16fa0f4a006b57a0a44a17953ec38fd8dc" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1ce0427217e7e69e6e5a80f1afd684e23957d161" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8854fb6583fec2754cd3983ea80d85f9b0022749" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the bidi type name.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; se puede utilizar para obtener todos los sin&amp;oacute;nimos del nombre del tipo bidi.</target>
        </trans-unit>
        <trans-unit id="76a16bb68fd364d030e4901c8f1d916862b53339" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the category name.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; se puede utilizar para obtener todos los sin&amp;oacute;nimos del nombre de la categor&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="2277466bc19ae0c38a8069cd1ac99be48d5794e6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; function can be used to get all the synonyms of the combining class number.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; se puede utilizar para obtener todos los sin&amp;oacute;nimos del n&amp;uacute;mero de clase de combinaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="4904f3373dd8be370b7583b9b3b50ffe1a1a4b51" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b1feb25bb50a467b88daf8d606e828a649203e2c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values%28%29&quot;&gt;&quot;prop_values()&quot;&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases%28%29&quot;&gt;&quot;prop_value_aliases()&quot;&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d0d02ad47d23ca3616a65821c3a3e94a1c4a3210" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short bidi type names; and the second gets all the synonyms of a given bidi type name.</source>
          <target state="translated">Las &lt;a href=&quot;#prop_values()&quot;&gt;funciones prop_values ​​()&lt;/a&gt; y &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; se pueden utilizar como alternativa a esta funci&amp;oacute;n; el primero devuelve una lista simple de los nombres cortos de los tipos bidi; y el segundo obtiene todos los sin&amp;oacute;nimos de un nombre de tipo bidi dado.</target>
        </trans-unit>
        <trans-unit id="ff1836f9843147fc775222ff3469395bcf43b303" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#prop_values()&quot;&gt;prop_values()&lt;/a&gt; and &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases()&lt;/a&gt; functions can be used as an alternative to this function; the first returning a simple list of the short category names; and the second gets all the synonyms of a given category name.</source>
          <target state="translated">Las &lt;a href=&quot;#prop_values()&quot;&gt;funciones prop_values ​​()&lt;/a&gt; y &lt;a href=&quot;#prop_value_aliases()&quot;&gt;prop_value_aliases ()&lt;/a&gt; se pueden utilizar como alternativa a esta funci&amp;oacute;n; el primero devuelve una lista simple de los nombres cortos de las categor&amp;iacute;as; y el segundo obtiene todos los sin&amp;oacute;nimos de un nombre de categor&amp;iacute;a dado.</target>
        </trans-unit>
        <trans-unit id="234f248bda745adf52767c8afed6c1179ce0b206" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#redo-LABEL&quot;&gt;&lt;code&gt;redo&lt;/code&gt;&lt;/a&gt; command restarts the loop block without evaluating the conditional again. The &lt;a href=&quot;#continue-BLOCK&quot;&gt;&lt;code&gt;continue&lt;/code&gt;&lt;/a&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;redo EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;redo LABEL&lt;/code&gt;. Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a519b9af5d08ee020d0e49465d3e607833a7248" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist%28%29&quot;&gt;&quot;search_invlist()&quot;&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8295b9c404465c68e21720ae88623e9c9b91d667" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist()&lt;/a&gt; function is provided for finding a code point within an inversion list.</source>
          <target state="translated">La funci&amp;oacute;n &lt;a href=&quot;#search_invlist()&quot;&gt;search_invlist ()&lt;/a&gt; se proporciona para encontrar un punto de c&amp;oacute;digo dentro de una lista de inversi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="a99fc3c1e89a0b4e840a4661bca0de0880d27694" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;../file/stat&quot;&gt;File :: stat&lt;/a&gt; proporciona un conveniente mecanismo de acceso por nombre:</target>
        </trans-unit>
        <trans-unit id="f74e082436b86f6a01a3f1c31662df75f43fb323" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="translated">El &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; no utiliza una gram&amp;aacute;tica formal porque TAP es esencialmente un protocolo basado en flujo. De hecho, es bastante legal tener un flujo infinito. Por la misma raz&amp;oacute;n que no aplicamos expresiones regulares a las transmisiones, no estamos usando una gram&amp;aacute;tica formal aqu&amp;iacute;. En su lugar, analizamos el TAP en l&amp;iacute;neas.</target>
        </trans-unit>
        <trans-unit id="9b27238d4d5342b8376d19c0241b7f8feab19452" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="translated">La secci&amp;oacute;n de &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; contiene un ejemplo de atar manijas.</target>
        </trans-unit>
        <trans-unit id="6d31ab6a810582c2c717e2c46d057f9872d7ae58" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="translated">La secci&amp;oacute;n de &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; utiliza un buen ejemplo de vinculaci&amp;oacute;n de escalares asociando ID de proceso con prioridad.</target>
        </trans-unit>
        <trans-unit id="ef794a4d4eb5de692a3463fa7a1780b4cded7598" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;../time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;../time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">Los m&amp;oacute;dulos &lt;a href=&quot;../time/gmtime&quot;&gt;Time :: gmtime&lt;/a&gt; y &lt;a href=&quot;../time/localtime&quot;&gt;Time :: localtime&lt;/a&gt; proporcionan un conveniente mecanismo de acceso por nombre a las funciones gmtime () y localtime (), respectivamente.</target>
        </trans-unit>
        <trans-unit id="7f59d8b64082e6585a0f86dcd5c37ba82d09b8aa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9f0381e14460ccca0ae56322db0a7c83995df5b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdf4aaa34018ae1ca4bf41f4b79cdbb9a0cff285" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;B::Xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f196a1609183db140dea47e36f3fc23cd9f51305" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94925a2d828e44c2072ac8bf9e5922e018a8e287" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f5057256958429150491aec28876109720171696" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Data::Dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="061063093e9b457e789ea7dfaed817ebef3e8fa9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="414fad6d87355758dbe61a47fbcaa678d06818a4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dad6fcc6ed17db5c607714adee78b91a0147dac4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63fa62cd04b5ec9ae734d2f288b28465a83825b7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt;, into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a2f33574a7da40336507f2c618ec329b05bfc03" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06f493ee4e3ed13a3c3c25372d0b8e47b8faa82e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;File::Find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41be3e08eb17eb5dab7c9db97b667db51319891c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6c7bd1eef5bd53ddee501c6b8d48384c043b208a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1c8b4aba1c450fd5e83e76f37c3b27a8ef91aa4e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6eb5ba6674a28ab9cde2b0f4fa3385630b28d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="785624fefaf011b1c3c4e26dff67213b765e81c8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e7daf70cf70f962093675df7cd3c0bff0a54c56" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::Spec&quot;&gt;&lt;code&gt;File::Spec&lt;/code&gt;&lt;/a&gt; modules provide methods to manipulate path specifications and return the results in native format for each platform. This is often unnecessary as Unix-style paths are understood by Perl on every supported platform, but if you need to produce native paths for a native utility that does not understand Unix syntax, or if you are operating on paths or path components in unknown (and thus possibly native) syntax, &lt;a href=&quot;File::Spec&quot;&gt;&lt;code&gt;File::Spec&lt;/code&gt;&lt;/a&gt; is your friend. Here are two brief examples:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b19e201b91274dc82f186817a1d33cf7babd619" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;File::stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16818dfffaaf61b6c966f79b42c1f8e2b7feb79d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bba763c04be417f13a8a4419a2a27f106dcca680" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5994860ba25215b560ca2d61fa7577cd91572e65" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IO::Pty&quot;&gt;IO::Pty&lt;/a&gt; and &lt;a href=&quot;expect&quot;&gt;Expect&lt;/a&gt; modules from CPAN can help with this, as they provide a real tty (well, a pseudo-tty, actually), which gets you back to line buffering in the invoked command again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="57ff19b2be9bd948571db368af45b45f30d772d1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;pipe()&lt;/code&gt;, &lt;code&gt;fork()&lt;/code&gt;, and &lt;code&gt;exec()&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;IPC::Open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;&quot;Bidirectional Communication with Another Process&quot; in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;&quot;Bidirectional Communication with Yourself&quot; in perlipc&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0bfdae92972068b982647ca50573a173382b253e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;MIME::Base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c81136d6431fd17ef0e4aa23b6bb0cdcdd4be5ab" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Net::Domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2e94a57c84c2082998da5d9e3718fef9c662bb23" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Pod::Simple::Methody&quot;&gt;Pod::Simple::Methody&lt;/a&gt; interface is event-based, similar to that of &lt;a href=&quot;HTML::Parser&quot;&gt;HTML::Parser&lt;/a&gt; or &lt;a href=&quot;XML::Parser&quot;&gt;XML::Parser&lt;/a&gt;'s &quot;Handlers&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3225637b7a30ef3b9b4ead58416b060ae1216f73" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="570fbc1b333b95e1cacbc6d622c051543a52e083" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Sys::Hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="83438d62ddac1d3b0024cb20543586b81f4a2ed4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="360df13e9e42398d87ddf7c87ae270331934433d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; does not use a formal grammar because TAP is essentially a stream-based protocol. In fact, it's quite legal to have an infinite stream. For the same reason that we don't apply regexes to streams, we're not using a formal grammar here. Instead, we parse the TAP in lines.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="da5808fca337034f35682036721a9427ccd81f04" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aafbf1ee7c517c584849dcba00f2431a29c861d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Term::Cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="000a3fd43d21166c2b39d6546fdf69078cc7d878" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e513d6d25a35bd468fa6dfadf342f7abd0a9398b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt; object, as well as all &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; types need to have access to information about where they were created. This object represents that information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="25e3f2d15c3d0ceb7fdd915ea6fc508fa38a5afa" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Test2::Event::Pass&quot;&gt;Test2::Event::Pass&lt;/a&gt; is a specially crafted and optimized event, using this will help the performance of passing tests.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="64e3ab29916cf475d197cf70cfb13cb08a0c4ba1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;Time::HiRes&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;perlfunc#syscall&quot;&gt;&quot;syscall&quot; in perlfunc&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7e6f85e54060d65479b4d06b632210eb849f1f0e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;localtime&lt;/code&gt; that returns an object, and &lt;a href=&quot;Time::Seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ae8d644c0f0739788e0fe94553d172a549be62ef" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::Piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8cc9a688570f19df6de24c492632ed7647b5575b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Time::gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;Time::localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the &lt;a href=&quot;#gmtime-EXPR&quot;&gt;&lt;code&gt;gmtime&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#localtime-EXPR&quot;&gt;&lt;code&gt;localtime&lt;/code&gt;&lt;/a&gt; functions, respectively.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b9edd1164f7fd428ef66d1f77bb74482f07ecc4" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4148a12496e441ea4f3ef8053e86029175f36271" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;autodie&quot;&gt;autodie&lt;/a&gt; pragma is very smart when it comes to working with Perl's built-in functions. The behaviour for these functions are fixed, and &lt;code&gt;autodie&lt;/code&gt; knows exactly how they try to signal failure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1b61ff031aeab44addeeb9ed990fdd03cf707db7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;b/xref&quot;&gt;B::Xref&lt;/a&gt; module can be used to generate cross-reference reports for Perl programs.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;b/xref&quot;&gt;B :: Xref&lt;/a&gt; se puede utilizar para generar informes de referencias cruzadas para programas Perl.</target>
        </trans-unit>
        <trans-unit id="1c782dc05843dae452f5fa426b35990195e14641" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;carp&quot;&gt;Carp&lt;/a&gt; module allows you to present your error messages from the caller's perspective; this gives you a way to signal a problem with the caller and not your module. For instance, if you say this:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;carp&quot;&gt;Carp le&lt;/a&gt; permite presentar sus mensajes de error desde la perspectiva de la persona que llama; esto le da una forma de se&amp;ntilde;alar un problema con la persona que llama y no con su m&amp;oacute;dulo. Por ejemplo, si dices esto:</target>
        </trans-unit>
        <trans-unit id="99917712f2804784fe8d984e9caf76b36fd4b3a3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;crypt&quot;&gt;crypt&lt;/a&gt; function is unsuitable for hashing large quantities of data, not least of all because you can't get the information back. Look at the &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; module for more robust algorithms.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;a href=&quot;crypt&quot;&gt;cripta&lt;/a&gt; no es adecuada para hacer hash de grandes cantidades de datos, sobre todo porque no puede recuperar la informaci&amp;oacute;n. Mire el m&amp;oacute;dulo &lt;a href=&quot;../digest&quot;&gt;Digest&lt;/a&gt; para algoritmos m&amp;aacute;s robustos.</target>
        </trans-unit>
        <trans-unit id="5477977d65c206b7b8a0bfb0ffcfed2d08e7d436" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module can pretty-print Perl data structures:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; puede imprimir estructuras de datos Perl de forma bonita:</target>
        </trans-unit>
        <trans-unit id="c389b29dcc18d72eca5cc18bef171945489bed86" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;data/dumper&quot;&gt;Data::Dumper&lt;/a&gt; module on CPAN (or the 5.005 release of Perl) is great for printing out data structures. The &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; module on CPAN (or the 5.8 release of Perl), provides a function called &lt;code&gt;dclone&lt;/code&gt; that recursively copies its argument.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;data/dumper&quot;&gt;Data :: Dumper&lt;/a&gt; en CPAN (o la versi&amp;oacute;n 5.005 de Perl) es excelente para imprimir estructuras de datos. El m&amp;oacute;dulo &lt;a href=&quot;storable&quot;&gt;Storable&lt;/a&gt; en CPAN (o la versi&amp;oacute;n 5.8 de Perl), proporciona una funci&amp;oacute;n llamada &lt;code&gt;dclone&lt;/code&gt; que copia recursivamente su argumento.</target>
        </trans-unit>
        <trans-unit id="3a7849edfc0302d7fe31cbb60d0e88c8f3db830b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fb29e7cd4504f7ca3895f71c6eb9fad7707159a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;encoding&quot;&gt;encoding&lt;/a&gt; module has been deprecated since perl 5.18 and the perl internals it requires have been removed with perl 5.26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f90e864f3a759969a519520835fc4b34320f5652" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; module, better known simply as &quot;MakeMaker&quot;, turns a Perl script, typically called &lt;code&gt;Makefile.PL&lt;/code&gt; , into a Makefile. The Unix tool &lt;code&gt;make&lt;/code&gt; uses this file to manage dependencies and actions to process and install a Perl distribution.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;extutils/makemaker&quot;&gt;ExtUtils :: MakeMaker&lt;/a&gt; , m&amp;aacute;s conocido simplemente como &quot;MakeMaker&quot;, convierte un script de Perl, normalmente llamado &lt;code&gt;Makefile.PL&lt;/code&gt; , en un Makefile. La herramienta Unix &lt;code&gt;make&lt;/code&gt; usa este archivo para administrar dependencias y acciones para procesar e instalar una distribuci&amp;oacute;n Perl.</target>
        </trans-unit>
        <trans-unit id="b36a8fb9e123f79842afcd307b1051443b42499f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt; module, which comes with Perl, does all of the hard work to traverse a directory structure. It comes with Perl. You simply call the &lt;code&gt;find&lt;/code&gt; subroutine with a callback subroutine and the directories you want to traverse:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;file/find&quot;&gt;File :: Find&lt;/a&gt; , que viene con Perl, hace todo el trabajo duro para atravesar una estructura de directorio. Viene con Perl. Simplemente llame a la subrutina de &lt;code&gt;find&lt;/code&gt; con una subrutina de devoluci&amp;oacute;n de llamada y los directorios que desea recorrer:</target>
        </trans-unit>
        <trans-unit id="c85303530151e0f7d4bf77f032f56bce0f2d433a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module also has a legacy interface to the older &lt;code&gt;rmtree&lt;/code&gt; subroutine.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; tambi&amp;eacute;n tiene una interfaz heredada para la subrutina &lt;code&gt;rmtree&lt;/code&gt; anterior .</target>
        </trans-unit>
        <trans-unit id="2e3abc4db13d619062f522429a3b20e4ff646e91" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/path&quot;&gt;File::Path&lt;/a&gt; module, which comes with Perl, has a &lt;code&gt;remove_tree&lt;/code&gt; which can take care of all of the hard work for you:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;file/path&quot;&gt;File :: Path&lt;/a&gt; , que viene con Perl, tiene un &lt;code&gt;remove_tree&lt;/code&gt; que puede encargarse de todo el trabajo duro por usted:</target>
        </trans-unit>
        <trans-unit id="e423ba5fb093092e153154cd61200bfa0809ecf8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;file/stat&quot;&gt;File::stat&lt;/a&gt; module provides a convenient, by-name access mechanism:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;file/stat&quot;&gt;File :: stat&lt;/a&gt; proporciona un conveniente mecanismo de acceso por nombre:</target>
        </trans-unit>
        <trans-unit id="147153b8beaaff8771aea84e885cb82d17734d7a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt; , which you can then use to construct the right library path:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; , que viene con Perl, podr&amp;iacute;a funcionar. Encuentra el directorio del script que se est&amp;aacute; ejecutando actualmente y lo coloca en &lt;code&gt;$Bin&lt;/code&gt; , que luego puede usar para construir la ruta de biblioteca correcta:</target>
        </trans-unit>
        <trans-unit id="177b530c271fe1dca56344e28974f18250fe298e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;findbin&quot;&gt;FindBin&lt;/a&gt; module, which comes with Perl, might work. It finds the directory of the currently running script and puts it in &lt;code&gt;$Bin&lt;/code&gt;, which you can then use to construct the right library path:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6627242b752186d85aed5b69d9aaec46b0dd05af" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;Algorithm::Loops&lt;/a&gt; module also provides the &lt;code&gt;NextPermute&lt;/code&gt; and &lt;code&gt;NextPermuteNum&lt;/code&gt; functions which efficiently find all unique permutations of an array, even if it contains duplicate values, modifying it in-place: if its elements are in reverse-sorted order then the array is reversed, making it sorted, and it returns false; otherwise the next permutation is returned.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/Algorithm::Loops&quot;&gt;Algorithm :: Loops&lt;/a&gt; tambi&amp;eacute;n proporciona las funciones &lt;code&gt;NextPermute&lt;/code&gt; y &lt;code&gt;NextPermuteNum&lt;/code&gt; que encuentran de manera eficiente todas las permutaciones &amp;uacute;nicas de una matriz, incluso si contiene valores duplicados, modific&amp;aacute;ndola en el lugar: si sus elementos est&amp;aacute;n en orden inverso, la matriz se invierte , haci&amp;eacute;ndolo ordenado, y devuelve falso; de lo contrario, se devuelve la siguiente permutaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="7f004cbac628e9968204a02264b31a3bb1043a19" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;Array::Iterator::Circular&lt;/a&gt; creates an iterator object for circular arrays:</source>
          <target state="translated">La &lt;a href=&quot;http://search.cpan.org/perldoc/Array::Iterator::Circular&quot;&gt;matriz :: Iterator :: circular&lt;/a&gt; crea un objeto iterador para matrices circulares:</target>
        </trans-unit>
        <trans-unit id="a8c05beafd26231c80f038931300ac0e459427b6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module provides an abstract interface to most database servers and types, including Oracle, DB2, Sybase, mysql, Postgresql, ODBC, and flat files. The DBI module accesses each database type through a database driver, or DBD. You can see a complete list of available drivers on CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . You can read more about DBI on &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; proporciona una interfaz abstracta para la mayor&amp;iacute;a de servidores y tipos de bases de datos, incluidos Oracle, DB2, Sybase, mysql, Postgresql, ODBC y archivos planos. El m&amp;oacute;dulo DBI accede a cada tipo de base de datos a trav&amp;eacute;s de un controlador de base de datos o DBD. Puede ver una lista completa de controladores disponibles en CPAN: &lt;a href=&quot;http://www.cpan.org/modules/by-module/DBD/&quot;&gt;http://www.cpan.org/modules/by-module/DBD/&lt;/a&gt; . Puede leer m&amp;aacute;s sobre DBI en &lt;a href=&quot;http://dbi.perl.org/&quot;&gt;http://dbi.perl.org/&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="d99e17e2d810ab06df1befd3ba4deffe8e1f4100" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data::Diver&lt;/a&gt; module on CPAN can do it for you too. Its &lt;code&gt;Dive&lt;/code&gt; subroutine can tell you not only if the keys exist but also get the value:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/Data::Diver&quot;&gt;Data :: Diver&lt;/a&gt; en CPAN tambi&amp;eacute;n puede hacerlo por usted. Su subrutina &lt;code&gt;Dive&lt;/code&gt; puede decirle no solo si las claves existen, sino tambi&amp;eacute;n obtener el valor:</target>
        </trans-unit>
        <trans-unit id="2f20a46404ea5d10e8ff52857742923d6a8c636c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date::Calc&lt;/a&gt; module provides two functions to calculate these, too:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/Date::Calc&quot;&gt;Date :: Calc&lt;/a&gt; proporciona dos funciones para calcularlos tambi&amp;eacute;n:</target>
        </trans-unit>
        <trans-unit id="cffc0b8a618b23964a5ae541c5cad5a91da659e3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel::NYTProf&lt;/a&gt; (New York Times Profiler) does both statement and subroutine profiling. It's available from CPAN and you also invoke it with the &lt;code&gt;-d&lt;/code&gt; switch:</source>
          <target state="translated">El &lt;a href=&quot;http://search.cpan.org/perldoc/Devel::NYTProf&quot;&gt;Devel :: NYTProf&lt;/a&gt; (New York Times Profiler) realiza perfiles tanto de declaraciones como de subrutinas. Est&amp;aacute; disponible en CPAN y tambi&amp;eacute;n lo invoca con el &lt;code&gt;-d&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="36fe1514538dca6b4e14625a53ea351dc45f0bbb" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email::MIME&lt;/a&gt; module can decode base 64-encoded email message parts transparently so the developer doesn't need to worry about it.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/Email::MIME&quot;&gt;Email :: MIME&lt;/a&gt; puede decodificar partes de mensajes de correo electr&amp;oacute;nico codificados en 64 de forma transparente para que el desarrollador no tenga que preocuparse por eso.</target>
        </trans-unit>
        <trans-unit id="5544c90428de4242a1010e3b0f0f5fbfd72933f8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;File::Find::Closures&lt;/a&gt;, which you can download from CPAN, provides many ready-to-use subroutines that you can use with &lt;a href=&quot;file/find&quot;&gt;File::Find&lt;/a&gt;.</source>
          <target state="translated">El &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Closures&quot;&gt;Archivo :: Buscar :: Los cierres&lt;/a&gt; , que se puede descargar desde CPAN, ofrece muchas subrutinas listas para usar que se pueden utilizar con &lt;a href=&quot;file/find&quot;&gt;archivos :: find&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="56af297ba8a5f6d4fadfc00398e4a75a93e0389e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;File::Find::Rule&lt;/a&gt; module, which you can download from CPAN, has a similar interface, but does the traversal for you too:</source>
          <target state="translated">El &lt;a href=&quot;http://search.cpan.org/perldoc/File::Find::Rule&quot;&gt;m&amp;oacute;dulo File :: Find :: Rule&lt;/a&gt; , que puede descargar de CPAN, tiene una interfaz similar, pero tambi&amp;eacute;n realiza el recorrido por usted:</target>
        </trans-unit>
        <trans-unit id="b152dc512307ef4ac58f7c9208c20855dec936d6" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;File::Finder&lt;/a&gt;, which you can download from CPAN, can help you create the callback subroutine using something closer to the syntax of the &lt;code&gt;find&lt;/code&gt; command-line utility:</source>
          <target state="translated">El &lt;a href=&quot;http://search.cpan.org/perldoc/File::Finder&quot;&gt;Archivo :: Buscador&lt;/a&gt; , que se puede descargar desde CPAN, puede ayudar a crear la subrutina de devoluci&amp;oacute;n de llamada usando algo m&amp;aacute;s cercano a la sintaxis del &lt;code&gt;find&lt;/code&gt; utilidad de l&amp;iacute;nea de comandos:</target>
        </trans-unit>
        <trans-unit id="1598869d41d1eca117a3416dff8d5309f0c6cfec" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File::ReadBackwards&lt;/a&gt; module also has the advantage of setting the input record separator to a regular expression.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/File::ReadBackwards&quot;&gt;File :: ReadBackwards&lt;/a&gt; tambi&amp;eacute;n tiene la ventaja de establecer el separador de registros de entrada en una expresi&amp;oacute;n regular.</target>
        </trans-unit>
        <trans-unit id="91110246c66bf6d661128beb45e4417253ba4c01" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO::Interactive&lt;/a&gt; module does the best it can to give you an answer. Its &lt;code&gt;is_interactive&lt;/code&gt; function returns an output filehandle; that filehandle points to standard output if the module thinks the session is interactive. Otherwise, the filehandle is a null handle that simply discards the output:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/IO::Interactive&quot;&gt;IO :: Interactive&lt;/a&gt; hace lo mejor que puede para darle una respuesta. Su funci&amp;oacute;n &lt;code&gt;is_interactive&lt;/code&gt; devuelve un identificador de archivo de salida; ese identificador de archivo apunta a una salida est&amp;aacute;ndar si el m&amp;oacute;dulo cree que la sesi&amp;oacute;n es interactiva. De lo contrario, el identificador de archivo es un identificador nulo que simplemente descarta la salida:</target>
        </trans-unit>
        <trans-unit id="6b13cf53c66e0915c0e8281e749fbd4b759e7ba2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc::Daemon&lt;/a&gt; module, available from CPAN, provides a function to perform these actions for you.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/Proc::Daemon&quot;&gt;Proc :: Daemon&lt;/a&gt; , disponible en CPAN, proporciona una funci&amp;oacute;n para realizar estas acciones por usted.</target>
        </trans-unit>
        <trans-unit id="078338e81125883115260ece46dd352b4457327c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;Sys::Hostname::Long&lt;/a&gt; module takes a different approach and tries harder to return the fully qualified hostname:</source>
          <target state="translated">El &lt;a href=&quot;http://search.cpan.org/perldoc/Sys::Hostname::Long&quot;&gt;m&amp;oacute;dulo Sys :: Hostname :: Long&lt;/a&gt; adopta un enfoque diferente y se esfuerza por devolver el nombre de host completo:</target>
        </trans-unit>
        <trans-unit id="d7d7335f50cc47451871f0f97f15916c1b4287d7" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;Task::Kensho&lt;/a&gt; module has a list of recommended modules which you should review as a good starting point.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/Task::Kensho&quot;&gt;Task :: Kensho&lt;/a&gt; tiene una lista de m&amp;oacute;dulos recomendados que debe revisar como un buen punto de partida.</target>
        </trans-unit>
        <trans-unit id="96f2822c5bca6e995fc1a0007a9363af6e5934b2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term::ReadKey&lt;/a&gt; module from CPAN offers an easy-to-use interface that should be more efficient than shelling out to &lt;b&gt;stty&lt;/b&gt; for each key. It even includes limited support for Windows.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/Term::ReadKey&quot;&gt;Term :: ReadKey&lt;/a&gt; de CPAN ofrece una interfaz f&amp;aacute;cil de usar que deber&amp;iacute;a ser m&amp;aacute;s eficiente que &lt;b&gt;gastar&lt;/b&gt; en &lt;b&gt;stty&lt;/b&gt; para cada clave. Incluso incluye soporte limitado para Windows.</target>
        </trans-unit>
        <trans-unit id="32118c4d7f9e3bede84a1a66430b5426071bf4d3" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;Unicode::Tussle&lt;/a&gt; CPAN module includes many programs to help with working with Unicode, including these programs to fully or partly replace standard utilities:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/Unicode::Tussle&quot;&gt;Unicode :: Tussle&lt;/a&gt; CPAN incluye muchos programas para ayudar a trabajar con Unicode, incluidos estos programas para reemplazar total o parcialmente las utilidades est&amp;aacute;ndar:</target>
        </trans-unit>
        <trans-unit id="919f72853738df881eb6e91400681adc998b688b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;a href=&quot;http://search.cpan.org/perldoc/strictures#VERSION-2&quot;&gt;restricciones&lt;/a&gt; en CPAN ofrece un ejemplo de un subconjunto de advertencias que los autores del m&amp;oacute;dulo creen que es relativamente seguro de fatalizar.</target>
        </trans-unit>
        <trans-unit id="843917bc0f80fad466bd923d5aab8d1c0906f90e" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;io/handle&quot;&gt;IO::Handle&lt;/a&gt; objects also have a &lt;code&gt;flush&lt;/code&gt; method. You can flush the buffer any time you want without auto-buffering</source>
          <target state="translated">Los objetos &lt;a href=&quot;io/handle&quot;&gt;IO :: Handle&lt;/a&gt; tambi&amp;eacute;n tienen un m&amp;eacute;todo de &lt;code&gt;flush&lt;/code&gt; . Puede vaciar el b&amp;uacute;fer en cualquier momento que desee sin almacenamiento autom&amp;aacute;tico</target>
        </trans-unit>
        <trans-unit id="5839e7279588dcb1c4433f17b527ae9a9d772eed" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt; module (part of the standard perl distribution) is an easy-to-use approach that internally uses &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; to do the job. Make sure you read the deadlock warnings in its documentation, though (see &lt;a href=&quot;ipc/open2&quot;&gt;IPC::Open2&lt;/a&gt;). See &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;Bidirectional Communication with Another Process in perlipc&lt;/a&gt; and &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;Bidirectional Communication with Yourself in perlipc&lt;/a&gt;</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt; (parte de la distribuci&amp;oacute;n est&amp;aacute;ndar de Perl) es un enfoque f&amp;aacute;cil de usar que utiliza internamente &lt;code&gt;&lt;a href=&quot;functions/pipe&quot;&gt;pipe()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/fork&quot;&gt;fork()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec()&lt;/a&gt;&lt;/code&gt; para hacer el trabajo. Sin embargo, aseg&amp;uacute;rese de leer las advertencias de interbloqueo en su documentaci&amp;oacute;n (consulte &lt;a href=&quot;ipc/open2&quot;&gt;IPC :: Open2&lt;/a&gt; ). Vea &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Another-Process&quot;&gt;Comunicaci&amp;oacute;n bidireccional con otro proceso en perlipc&lt;/a&gt; y &lt;a href=&quot;perlipc#Bidirectional-Communication-with-Yourself&quot;&gt;Comunicaci&amp;oacute;n bidireccional con usted mismo en perlipc&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="09e04b4b58ffa26e2662b854208dafbdb133126a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mime/base64&quot;&gt;MIME::Base64&lt;/a&gt; package handles this as well as the MIME/QP encoding. Decoding base 64 becomes as simple as:</source>
          <target state="translated">El paquete &lt;a href=&quot;mime/base64&quot;&gt;MIME :: Base64&lt;/a&gt; maneja esto as&amp;iacute; como la codificaci&amp;oacute;n MIME / QP. Decodificar la base 64 se vuelve tan simple como:</target>
        </trans-unit>
        <trans-unit id="0b7108620b7e75ec5ba066fc83c0e7f6113d802f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; pragma provides some functions for manipulating the method cache directly.</source>
          <target state="translated">El pragma &lt;a href=&quot;mro&quot;&gt;mro&lt;/a&gt; proporciona algunas funciones para manipular la cach&amp;eacute; de m&amp;eacute;todos directamente.</target>
        </trans-unit>
        <trans-unit id="f076d77a637b12522b1379f81df9ca81640a9292" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;net/domain&quot;&gt;Net::Domain&lt;/a&gt; module, which is part of the Standard Library starting in Perl 5.7.3, can get you the fully qualified domain name (FQDN), the host name, or the domain name.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;net/domain&quot;&gt;Net :: Domain&lt;/a&gt; , que es parte de la biblioteca est&amp;aacute;ndar a partir de Perl 5.7.3, puede proporcionarle el nombre de dominio completo (FQDN), el nombre de host o el nombre de dominio.</target>
        </trans-unit>
        <trans-unit id="76dc71fd851bfecf3d4eefc768e03ef389a05460" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; call.</source>
          <target state="translated">El pragma &lt;a href=&quot;open&quot;&gt;abierto&lt;/a&gt; afecta a todas las llamadas &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; despu&amp;eacute;s del pragma estableciendo capas predeterminadas. Si desea afectar solo ciertos flujos, use capas expl&amp;iacute;citas directamente en la llamada &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="3b5f1dd446b40bac39fbf56bdb1eee6bbfa27f8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;open&quot;&gt;open&lt;/a&gt; pragma affects all the &lt;code&gt;open()&lt;/code&gt; calls after the pragma by setting default layers. If you want to affect only certain streams, use explicit layers directly in the &lt;code&gt;open()&lt;/code&gt; call.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cf8373e5ee8839618cf4f3d8412574499af0964" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;parent&quot;&gt;parent&lt;/a&gt; module is one of several ways that Perl lets you define inheritance relationships.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;parent&quot;&gt;principal&lt;/a&gt; es una de las varias formas en que Perl le permite definir relaciones de herencia.</target>
        </trans-unit>
        <trans-unit id="4ba42fed843fbbf72076d217b81b8e5c3f052f2f" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5Bnumber%2Flist%5D&quot;&gt;&lt;code&gt;-C&lt;/code&gt;&lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7B%5EUNICODE%7D&quot;&gt;&quot;${^UNICODE}&quot; in perlvar&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b0fe01583804e7c24edcd36bf4d1dc86edd7004" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C &lt;/a&gt; command line option can specify that certain inputs to the program are Unicode, and the values of this can be read by your Perl code, see &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;${^UNICODE} in perlvar&lt;/a&gt;.</source>
          <target state="translated">La opci&amp;oacute;n de l&amp;iacute;nea de comando &lt;a href=&quot;perlrun#-C-%5bnumber%2flist%5d&quot;&gt;-C&lt;/a&gt; puede especificar que ciertas entradas al programa son Unicode, y los valores de esto pueden ser le&amp;iacute;dos por su c&amp;oacute;digo Perl, vea &lt;a href=&quot;perlvar#%24%7b%5eUNICODE%7d&quot;&gt;$ {^ UNICODE} en perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="bc877ff3004436e21e412f3d7536c1241e3ab1bd" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;dbi&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;system&lt;/code&gt; or &lt;code&gt;exec&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1dd5f1da5843d43e215f1c5605c7bd2602ba3c8d" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; documentation has general advice about data security. If you are using the &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; module, use placeholder to fill in data. If you are running external programs with &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;, use the list forms. There are many other precautions that you should take, too many to list here, and most of them fall under the category of not using any data that you don't intend to use. Trust no one.</source>
          <target state="translated">La documentaci&amp;oacute;n de &lt;a href=&quot;perlsec&quot;&gt;perlsec&lt;/a&gt; tiene consejos generales sobre la seguridad de los datos. Si est&amp;aacute; utilizando el m&amp;oacute;dulo &lt;a href=&quot;http://search.cpan.org/perldoc/DBI&quot;&gt;DBI&lt;/a&gt; , use un marcador de posici&amp;oacute;n para completar los datos. Si est&amp;aacute; ejecutando programas externos con &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; , utilice los formularios de lista. Hay muchas otras precauciones que debe tomar, demasiadas para enumerarlas aqu&amp;iacute;, y la mayor&amp;iacute;a de ellas entran en la categor&amp;iacute;a de no usar ning&amp;uacute;n dato que no tenga la intenci&amp;oacute;n de usar. No conf&amp;iacute;es en nadie.</target>
        </trans-unit>
        <trans-unit id="a18edb94d1038cfdd671ad02ef0a771da5913e80" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section contains an example of tying handles.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8d872a7f80e3dcd2bcfe4f77e0ab218cfcf5f3d9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; section uses a good example of tying scalars by associating process IDs with priority.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e969c75d9a86d34240a9b4b0c3bacd72a35586a9" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;perlvar#%24%5EO&quot;&gt;&lt;code&gt;$^O&lt;/code&gt;&lt;/a&gt; variable and the &lt;a href=&quot;config#archname&quot;&gt;&lt;code&gt;$Config{archname}&lt;/code&gt;&lt;/a&gt; values for various DOSish perls are as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3dddc8cefb2df3a4b2f380a117370ecb94e0324" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; , and a number of other mathematical and trigonometric functions.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; (parte de la distribuci&amp;oacute;n est&amp;aacute;ndar de Perl) implementa &lt;code&gt;ceil()&lt;/code&gt; , &lt;code&gt;floor()&lt;/code&gt; y varias otras funciones matem&amp;aacute;ticas y trigonom&amp;eacute;tricas.</target>
        </trans-unit>
        <trans-unit id="3cfd8963d803d863b1baabc1a6fb32761a10e916" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module (part of the standard Perl distribution) implements &lt;code&gt;ceil()&lt;/code&gt;, &lt;code&gt;floor()&lt;/code&gt;, and a number of other mathematical and trigonometric functions.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb81881ffc1ffa7659057b3aad0d531c1c255d43" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module can also format a date as the day of the year or week of the year.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; tambi&amp;eacute;n puede formatear una fecha como el d&amp;iacute;a del a&amp;ntilde;o o la semana del a&amp;ntilde;o.</target>
        </trans-unit>
        <trans-unit id="f19febd4ca12ddc4d78578d816e9ed0531d16d0b" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; module makes extensive use of this type.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;posix&quot;&gt;POSIX&lt;/a&gt; hace un uso extensivo de este tipo.</target>
        </trans-unit>
        <trans-unit id="dda44e28f3e372b46a40263a9e3342beb0a11995" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;posix#getattr&quot;&gt;&lt;code&gt;POSIX::getattr&lt;/code&gt;&lt;/a&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;a href=&quot;Term::ReadKey&quot;&gt;&lt;code&gt;Term::ReadKey&lt;/code&gt;&lt;/a&gt; module on CPAN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9379f8868c28dae16be3be866b6601876aaeaba" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;provide&quot;&gt;provide&lt;/a&gt; module from CPAN can be used to select one of several possible modules to load based on the version of Perl that is running.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2b0fd33e8403b054935aab9d8ee0ab65dd34b689" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; module to alter behaviour and aid debugging.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;re&quot;&gt;re&lt;/a&gt; para alterar el comportamiento y ayudar a la depuraci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="82ec47dd24e184de112e4cf2a9605a038adc3316" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;strictures#VERSION-2&quot;&gt;strictures&lt;/a&gt; module on CPAN offers one example of a warnings subset that the module's authors believe is relatively safe to fatalize.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb49b0f767217eaf2addd5f51c9329970eca01df" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;sys/hostname&quot;&gt;Sys::Hostname&lt;/a&gt; module, part of the Standard Library, can also get the hostname:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;sys/hostname&quot;&gt;Sys :: Hostname&lt;/a&gt; , parte de la biblioteca est&amp;aacute;ndar, tambi&amp;eacute;n puede obtener el nombre de host:</target>
        </trans-unit>
        <trans-unit id="220edf79ba9ff4834b00c1168d4289b47c73eb1c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;term/cap&quot;&gt;Term::Cap&lt;/a&gt; module can also get the special sequence if you want to deal with the low-level details of terminal control. The &lt;code&gt;Tputs&lt;/code&gt; method returns the string for the given capability:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;term/cap&quot;&gt;Term :: Cap&lt;/a&gt; tambi&amp;eacute;n puede obtener la secuencia especial si desea lidiar con los detalles de bajo nivel del control de terminal. El m&amp;eacute;todo &lt;code&gt;Tputs&lt;/code&gt; devuelve la cadena para la capacidad dada:</target>
        </trans-unit>
        <trans-unit id="e87c5439cafd856838e66bb969aac3bccda2430c" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads/shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="translated">Los &lt;a href=&quot;threads&quot;&gt;subprocesos&lt;/a&gt; y &lt;a href=&quot;threads/shared&quot;&gt;subprocesos ::&lt;/a&gt; m&amp;oacute;dulos compartidos se incluyen en la distribuci&amp;oacute;n principal de Perl. Adem&amp;aacute;s, se mantienen como m&amp;oacute;dulos separados en CPAN, por lo que puede verificar all&amp;iacute; si hay actualizaciones.</target>
        </trans-unit>
        <trans-unit id="f6686ccb369690f0486ecaf90ca58010d28981b5" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; and &lt;a href=&quot;threads::shared&quot;&gt;threads::shared&lt;/a&gt; modules are included in the core Perl distribution. Additionally, they are maintained as a separate modules on CPAN, so you can check there for any updates.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a9bb0674257a5140b5151993d5c3d3a37202400" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the basic functions you need to write threaded programs. In the following sections, we'll cover the basics, showing you what you need to do to create a threaded program. After that, we'll go over some of the features of the &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module that make threaded programming easier.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;a href=&quot;threads&quot;&gt;subprocesos&lt;/a&gt; proporciona las funciones b&amp;aacute;sicas que necesita para escribir programas con subprocesos. En las siguientes secciones, cubriremos los conceptos b&amp;aacute;sicos y le mostraremos lo que debe hacer para crear un programa con subprocesos. Despu&amp;eacute;s de eso, repasaremos algunas de las caracter&amp;iacute;sticas del m&amp;oacute;dulo de &lt;a href=&quot;threads&quot;&gt;subprocesos&lt;/a&gt; que facilitan la programaci&amp;oacute;n de subprocesos.</target>
        </trans-unit>
        <trans-unit id="2a739a40945ec3475dfa2806df561fe8eb1d910a" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;a href=&quot;threads&quot;&gt;hilos&lt;/a&gt; proporciona las herramientas que necesita para crear nuevos hilos. Como cualquier otro m&amp;oacute;dulo, necesita decirle a Perl que quiere usarlo; &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; threads;&lt;/code&gt; importa todas las piezas que necesita para crear hilos b&amp;aacute;sicos.</target>
        </trans-unit>
        <trans-unit id="5c7c73d979dc1bd0fbebb065f801ce33de931673" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;threads&quot;&gt;threads&lt;/a&gt; module provides the tools you need to create new threads. Like any other module, you need to tell Perl that you want to use it; &lt;code&gt;use threads;&lt;/code&gt; imports all the pieces you need to create basic threads.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac95afd4b80a6c32d7d4b6fc126fc11993d69484" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/gmtime&quot;&gt;Time::gmtime&lt;/a&gt; and &lt;a href=&quot;time/localtime&quot;&gt;Time::localtime&lt;/a&gt; modules provide a convenient, by-name access mechanism to the gmtime() and localtime() functions, respectively.</source>
          <target state="translated">Los m&amp;oacute;dulos &lt;a href=&quot;time/gmtime&quot;&gt;Time :: gmtime&lt;/a&gt; y &lt;a href=&quot;time/localtime&quot;&gt;Time :: localtime&lt;/a&gt; proporcionan un conveniente mecanismo de acceso por nombre a las funciones gmtime () y localtime (), respectivamente.</target>
        </trans-unit>
        <trans-unit id="27e7660ba02616c82b0460251677001be2bab8d2" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; module (part of the standard distribution as of Perl 5.8) measures time with the &lt;code&gt;gettimeofday()&lt;/code&gt; system call, which returns the time in microseconds since the epoch. If you can't install &lt;a href=&quot;time/hires&quot;&gt;Time::HiRes&lt;/a&gt; for older Perls and you are on a Unixish system, you may be able to call &lt;code&gt;gettimeofday(2)&lt;/code&gt; directly. See &lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt;.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; (parte de la distribuci&amp;oacute;n est&amp;aacute;ndar a partir de Perl 5.8) mide el tiempo con la llamada al sistema &lt;code&gt;gettimeofday()&lt;/code&gt; , que devuelve el tiempo en microsegundos desde la &amp;eacute;poca. Si no puede instalar &lt;a href=&quot;time/hires&quot;&gt;Time :: HiRes&lt;/a&gt; para Perls m&amp;aacute;s antiguos y est&amp;aacute; en un sistema Unixish, puede llamar a &lt;code&gt;gettimeofday(2)&lt;/code&gt; directamente. Ver &lt;a href=&quot;functions/syscall&quot;&gt;syscall&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="70cd112c1d983694e459a2b5affce0b2c176b5e1" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module exports a new &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; that returns an object, and &lt;a href=&quot;time/seconds&quot;&gt;Time::Seconds&lt;/a&gt; exports the &lt;code&gt;ONE_DAY&lt;/code&gt; constant that is a set number of seconds. This means that it always gives the time 24 hours ago, which is not always yesterday. This can cause problems around the end of daylight saving time when there's one day that is 25 hours long.</source>
          <target state="translated">El &lt;a href=&quot;time/piece&quot;&gt;Tiempo :: pieza&lt;/a&gt; m&amp;oacute;dulo exporta una nueva &lt;code&gt;&lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt;&lt;/code&gt; que devuelve un objeto, y &lt;a href=&quot;time/seconds&quot;&gt;el tiempo :: segundos&lt;/a&gt; exportaciones del &lt;code&gt;ONE_DAY&lt;/code&gt; constantes que es un n&amp;uacute;mero determinado de segundos. Esto significa que siempre da la hora de hace 24 horas, que no siempre es ayer. Esto puede causar problemas al final del horario de verano cuando hay un d&amp;iacute;a que dura 25 horas.</target>
        </trans-unit>
        <trans-unit id="ad7b96811e1e0447b346c7c68b0b6f49a0e303ce" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;time/piece&quot;&gt;Time::Piece&lt;/a&gt; module, which comes with Perl, replaces &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt; with a version that returns an object. It also overloads the comparison operators so you can compare them directly:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;a href=&quot;time/piece&quot;&gt;Time :: Piece&lt;/a&gt; , que viene con Perl, reemplaza &lt;a href=&quot;functions/localtime&quot;&gt;localtime&lt;/a&gt; con una versi&amp;oacute;n que devuelve un objeto. Tambi&amp;eacute;n sobrecarga los operadores de comparaci&amp;oacute;n para que pueda compararlos directamente:</target>
        </trans-unit>
        <trans-unit id="3b4c77d08ed357c92167918b7693fcf1d9ab7f90" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;universal#VERSION-%28-%5B-REQUIRE-%5D-%29&quot;&gt;default &lt;code&gt;VERSION&lt;/code&gt; method&lt;/a&gt;, inherited from the &lt;a href=&quot;universal&quot;&gt;&lt;code&gt;UNIVERSAL&lt;/code&gt;&lt;/a&gt; class, croaks if the given version is larger than the value of the variable &lt;code&gt;$Module::VERSION&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b06bcf860d30364b7b86c5e727206450a5e8ad8" translate="yes" xml:space="preserve">
          <source>The &lt;a href=&quot;version&quot;&gt;version&lt;/a&gt; module provides the most reliable way to compare version numbers in all the various ways they might be provided or might exist within modules. Given two strings containing version numbers, &lt;code&gt;$v1&lt;/code&gt; and &lt;code&gt;$v2&lt;/code&gt;, they should be converted to &lt;code&gt;version&lt;/code&gt; objects before using ordinary comparison operators. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7624d8ccf09fad70c6649ad6b1aa4fa701ecfb1c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; flag controls some of the Perl Unicode features.</source>
          <target state="translated">La bandera &lt;b&gt;-C&lt;/b&gt; controla algunas de las caracter&amp;iacute;sticas de Perl Unicode.</target>
        </trans-unit>
        <trans-unit id="eeee1b2385aaa3798bce91466fcda51762a843eb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-C&lt;/b&gt; option only works if it is specified on the command line as well (with the same sequence of letters or numbers following). Either specify this option on the command line, or, if your system supports it, make your script executable and run it directly instead of passing it to perl.</source>
          <target state="translated">La opci&amp;oacute;n &lt;b&gt;-C&lt;/b&gt; solo funciona si tambi&amp;eacute;n se especifica en la l&amp;iacute;nea de comando (con la misma secuencia de letras o n&amp;uacute;meros a continuaci&amp;oacute;n). Especifique esta opci&amp;oacute;n en la l&amp;iacute;nea de comandos o, si su sistema la admite, haga que su script sea ejecutable y ejec&amp;uacute;telo directamente en lugar de pasarlo a perl.</target>
        </trans-unit>
        <trans-unit id="adbe88919d7c337e67d217e417ae52c5e78e86cc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt; ). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="translated">El &lt;b&gt;modificador&lt;/b&gt; de l&amp;iacute;nea de comandos &lt;b&gt;-DL&lt;/b&gt; est&amp;aacute; obsoleto desde Perl 5.6.0 (solo estaba disponible si Perl se &lt;code&gt;-DDEBUGGING&lt;/code&gt; con -DDEBUGGING ). El interruptor se utiliz&amp;oacute; para rastrear las asignaciones de memoria de Perl y las posibles p&amp;eacute;rdidas de memoria. En estos d&amp;iacute;as, el uso de herramientas de depuraci&amp;oacute;n malloc como</target>
        </trans-unit>
        <trans-unit id="10ff88d6a964ef244acd1861f020528cdc0021d6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-DL&lt;/b&gt; command-line switch is obsolete since circa Perl 5.6.0 (it was available only if Perl was built with &lt;code&gt;-DDEBUGGING&lt;/code&gt;). The switch was used to track Perl's memory allocations and possible memory leaks. These days the use of malloc debugging tools like</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a02c2d05901d298065bac05eaefdaf89b098f1d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-a&lt;/b&gt; option followed by the name of a perl api function will extract the documentation of this function from &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt;.</source>
          <target state="translated">La opci&amp;oacute;n &lt;b&gt;-a&lt;/b&gt; seguida del nombre de una funci&amp;oacute;n api de perl extraer&amp;aacute; la documentaci&amp;oacute;n de esta funci&amp;oacute;n de &lt;a href=&quot;perlapi&quot;&gt;perlapi&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b7458f799f2d3bc9e0821f8f30b793deae5a843f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-f&lt;/b&gt; option followed by the name of a perl built-in function will extract the documentation of this function from &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;.</source>
          <target state="translated">La opci&amp;oacute;n &lt;b&gt;-f&lt;/b&gt; seguida del nombre de una funci&amp;oacute;n incorporada de perl extraer&amp;aacute; la documentaci&amp;oacute;n de esta funci&amp;oacute;n de &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1902e94f8bb188d5617c0fc133e4af994267a619" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-q&lt;/b&gt; option takes a regular expression as an argument. It will search the &lt;b&gt;q&lt;/b&gt;uestion headings in perlfaq[1-9] and print the entries matching the regular expression.</source>
          <target state="translated">La opci&amp;oacute;n &lt;b&gt;-q&lt;/b&gt; toma una expresi&amp;oacute;n regular como argumento. Se buscar&amp;aacute; los &lt;b&gt;q&lt;/b&gt; partidas REGUNTA en perlfaq [1-9] e imprimir las entradas que coinciden con la expresi&amp;oacute;n regular.</target>
        </trans-unit>
        <trans-unit id="5344e76d29fb1384ca26893a56599519b1faad07" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-v&lt;/b&gt; option followed by the name of a Perl predefined variable will extract the documentation of this variable from &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt;.</source>
          <target state="translated">La opci&amp;oacute;n &lt;b&gt;-v&lt;/b&gt; seguida del nombre de una variable predefinida de Perl extraer&amp;aacute; la documentaci&amp;oacute;n de esta variable de &lt;a href=&quot;perlvar&quot;&gt;perlvar&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c5ae0073660f495c2b0b0a5aff71edb22c20f2cb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-verbose&lt;/b&gt; flag first prints out the &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; introduction before any other diagnostics. The $diagnostics::PRETTY variable can generate nicer escape sequences for pagers.</source>
          <target state="translated">El &lt;b&gt;-verbose&lt;/b&gt; bandera imprime primero la &lt;a href=&quot;perldiag&quot;&gt;perldiag&lt;/a&gt; introducci&amp;oacute;n antes de cualquier otro diagn&amp;oacute;stico. La variable $ diagnostics :: PRETTY puede generar secuencias de escape m&amp;aacute;s agradables para los buscapersonas.</target>
        </trans-unit>
        <trans-unit id="ceb38ecccfec93207c00c9dee183b84b32a5f056" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;-w&lt;/b&gt; flag just sets the global &lt;code&gt;$^W&lt;/code&gt; variable as in 5.005. This means that any legacy code that currently relies on manipulating &lt;code&gt;$^W&lt;/code&gt; to control warning behavior will still work as is.</source>
          <target state="translated">La bandera &lt;b&gt;-w&lt;/b&gt; simplemente establece la variable global &lt;code&gt;$^W&lt;/code&gt; como en 5.005. Esto significa que cualquier c&amp;oacute;digo heredado que actualmente se base en la manipulaci&amp;oacute;n de &lt;code&gt;$^W&lt;/code&gt; para controlar el comportamiento de las advertencias seguir&amp;aacute; funcionando como est&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="72bbdbcc137e1ec7edde830d8069bcdc7d47c4dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; is similar in purpose to &lt;b&gt;SelfLoader&lt;/b&gt;: both delay the loading of subroutines.</source>
          <target state="translated">El &lt;b&gt;Autocargador&lt;/b&gt; tiene un prop&amp;oacute;sito similar al &lt;b&gt;Autocargador&lt;/b&gt; : ambos retrasan la carga de subrutinas.</target>
        </trans-unit>
        <trans-unit id="0f53ec7201e8a617c94e28662bed3af80a664f4d" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;AutoLoader&lt;/b&gt; module works with the &lt;b&gt;AutoSplit&lt;/b&gt; module and the &lt;code&gt;__END__&lt;/code&gt; token to defer the loading of some subroutines until they are used rather than loading them all at once.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;b&gt;Autocargador&lt;/b&gt; funciona con el m&amp;oacute;dulo &lt;b&gt;AutoSplit&lt;/b&gt; y el token &lt;code&gt;__END__&lt;/code&gt; para aplazar la carga de algunas subrutinas hasta que se utilicen en lugar de cargarlas todas a la vez.</target>
        </trans-unit>
        <trans-unit id="93865b59868e970114227e97ec05c9ea3f594f39" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;ExtUtils::Embed&lt;/b&gt; kit on CPAN also contains all source code for the examples in this document, tests, additional examples and other information you may find useful.</source>
          <target state="translated">El kit &lt;b&gt;ExtUtils :: Embed&lt;/b&gt; en CPAN tambi&amp;eacute;n contiene todo el c&amp;oacute;digo fuente de los ejemplos de este documento, pruebas, ejemplos adicionales y otra informaci&amp;oacute;n que puede resultarle &amp;uacute;til.</target>
        </trans-unit>
        <trans-unit id="78c68d8eddf3cc79f99821ef8cc24a0430101c54" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2FO-Operators&quot;&gt;&quot;I/O Operators&quot; in perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d362af90dceed3d87816d0dcbc3d699668f7c9c9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;IO&lt;/b&gt; extension, &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt;, &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;I/O Operators in perlop&lt;/a&gt;.</source>
          <target state="translated">La extensi&amp;oacute;n &lt;b&gt;IO&lt;/b&gt; , &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; , &lt;a href=&quot;perlop#I%2fO-Operators&quot;&gt;operadores I / O en perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="f4ddb503abc843b9ef214b377226c71b441a111a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Pod::Hyperlink&lt;/b&gt; class is mainly designed to parse the contents of the &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence, providing a simple interface for accessing the different parts of a POD hyperlink for further processing. It can also be used to construct hyperlinks.</source>
          <target state="translated">La clase &lt;b&gt;Pod :: Hyperlink&lt;/b&gt; est&amp;aacute; dise&amp;ntilde;ada principalmente para analizar el contenido de la secuencia &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; , proporcionando una interfaz simple para acceder a las diferentes partes de un hiperv&amp;iacute;nculo POD para su posterior procesamiento. Tambi&amp;eacute;n se puede utilizar para construir hiperv&amp;iacute;nculos.</target>
        </trans-unit>
        <trans-unit id="159cbd250976e52bd0b54f9fbb2c920f60501cf2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt; . You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="translated">El &lt;b&gt;Autocargador&lt;/b&gt; puede reemplazar al Autocargador; simplemente cambie 'usar Autocargador' por 'usar Autocargador' (aunque tenga en cuenta que el &lt;b&gt;Autocargador&lt;/b&gt; exporta la funci&amp;oacute;n AUTOLOAD, pero si tiene su propio AUTOLOAD y tambi&amp;eacute;n est&amp;aacute; usando el Autocargador, probablemente sepa lo que est&amp;aacute; haciendo haciendo), y el token &lt;code&gt;__END__&lt;/code&gt; a &lt;code&gt;__DATA__&lt;/code&gt; . Necesitar&amp;aacute; la versi&amp;oacute;n 5.001m de perl o posterior para usar esto (versi&amp;oacute;n 5.001 con todos los parches hasta el parche m).</target>
        </trans-unit>
        <trans-unit id="b4c86354fde60d804671cf8056d3c10e6c5b0099" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; can replace the AutoLoader - just change 'use AutoLoader' to 'use SelfLoader' (though note that the &lt;b&gt;SelfLoader&lt;/b&gt; exports the AUTOLOAD function - but if you have your own AUTOLOAD and are using the AutoLoader too, you probably know what you're doing), and the &lt;code&gt;__END__&lt;/code&gt; token to &lt;code&gt;__DATA__&lt;/code&gt;. You will need perl version 5.001m or later to use this (version 5.001 with all patches up to patch m).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9cc1e94494f4935e31dcd4aca4dd8097e05b3034" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; exports the &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine to the package using the &lt;b&gt;SelfLoader&lt;/b&gt;, and this loads the called subroutine when it is first called.</source>
          <target state="translated">El &lt;b&gt;SelfLoader&lt;/b&gt; exporta el &lt;code&gt;AUTOLOAD&lt;/code&gt; subrutina para el paquete utilizando la &lt;b&gt;SelfLoader&lt;/b&gt; , y las cargas de la llamada esta subrutina cuando se le llama en primer lugar.</target>
        </trans-unit>
        <trans-unit id="be3fad23fb52579393cf97f6d16c823542fd3d2f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt; . This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="translated">El &lt;b&gt;SelfLoader&lt;/b&gt; lee desde donde &lt;b&gt;est&amp;eacute;&lt;/b&gt; la posici&amp;oacute;n actual del &lt;code&gt;FOOBAR::DATA&lt;/code&gt; de archivo FOOBAR :: DATA , hasta el EOF o &lt;code&gt;__END__&lt;/code&gt; . Esto significa que si desea usar ese identificador de archivo (y SOLO si lo desea), debe</target>
        </trans-unit>
        <trans-unit id="11f27c5dcec516e53a8a4d6fd79ba993403bc153" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; reads from wherever the current position of the &lt;code&gt;FOOBAR::DATA&lt;/code&gt; filehandle is, until the EOF or &lt;code&gt;__END__&lt;/code&gt;. This means that if you want to use that filehandle (and ONLY if you want to), you should either</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0f59147d20cbbd96eaf3ce69c4654c447143a93e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt; , and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt; , and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="translated">El &lt;b&gt;SelfLoader&lt;/b&gt; leer&amp;aacute; del identificador de archivo FOOBAR :: DATA para cargar los datos despu&amp;eacute;s de &lt;code&gt;__DATA__&lt;/code&gt; , y cargar&amp;aacute; en cualquier subrutina cuando se llame. Los costos son el an&amp;aacute;lisis &amp;uacute;nico de los datos despu&amp;eacute;s de &lt;code&gt;__DATA__&lt;/code&gt; y un retraso de carga para la _primera_ llamada de cualquier funci&amp;oacute;n de carga autom&amp;aacute;tica. Los beneficios (con suerte) son una fase de compilaci&amp;oacute;n acelerada, sin necesidad de cargar funciones que nunca se utilizan.</target>
        </trans-unit>
        <trans-unit id="661b13cb881f0c177baa79d2f9cc5c08efa1139f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will read from the FOOBAR::DATA filehandle to load in the data after &lt;code&gt;__DATA__&lt;/code&gt;, and load in any subroutine when it is called. The costs are the one-time parsing of the data after &lt;code&gt;__DATA__&lt;/code&gt;, and a load delay for the _first_ call of any autoloaded function. The benefits (hopefully) are a speeded up compilation phase, with no need to load functions which are never used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b9076a846b441722c5113e39b9bcd0673ac55d99" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; will stop reading from &lt;code&gt;__DATA__&lt;/code&gt; if it encounters the &lt;code&gt;__END__&lt;/code&gt; token - just as you would expect. If the &lt;code&gt;__END__&lt;/code&gt; token is present, and is followed by the token DATA, then the &lt;b&gt;SelfLoader&lt;/b&gt; leaves the FOOBAR::DATA filehandle open on the line after that token.</source>
          <target state="translated">El &lt;b&gt;SelfLoader&lt;/b&gt; se detendr&amp;aacute; la lectura de &lt;code&gt;__DATA__&lt;/code&gt; si encuentra el &lt;code&gt;__END__&lt;/code&gt; de token - tal como era de esperar. Si el token &lt;code&gt;__END__&lt;/code&gt; est&amp;aacute; presente, y es seguido por el token DATA, entonces &lt;b&gt;SelfLoader&lt;/b&gt; deja el identificador de archivo FOOBAR :: DATA abierto en la l&amp;iacute;nea despu&amp;eacute;s de ese token.</target>
        </trans-unit>
        <trans-unit id="ae4ca9e2af773bc53d6ebfbbbcbbb68e0e663b29" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works by the user placing the &lt;code&gt;__DATA__&lt;/code&gt; token</source>
          <target state="translated">El &lt;b&gt;SelfLoader&lt;/b&gt; funciona cuando el usuario coloca el token &lt;code&gt;__DATA__&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="b8a45570c1acb4c43b6a7805f6337844a9606503" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt; . Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="translated">El &lt;b&gt;Autocargador&lt;/b&gt; funciona de manera similar al Autocargador, pero recoge los subs despu&amp;eacute;s de &lt;code&gt;__DATA__&lt;/code&gt; en lugar de en el directorio 'lib / auto'. Hay una ganancia de mantenimiento al no necesitar ejecutar AutoSplit en el m&amp;oacute;dulo durante la instalaci&amp;oacute;n, y una ganancia de tiempo de ejecuci&amp;oacute;n al no tener que seguir abriendo y cerrando archivos para cargar subs. Hay una p&amp;eacute;rdida de tiempo de ejecuci&amp;oacute;n al necesitar analizar el c&amp;oacute;digo despu&amp;eacute;s de &lt;code&gt;__DATA__&lt;/code&gt; . Los detalles del &lt;b&gt;Autocargador&lt;/b&gt; y otra vista de estas distinciones se pueden encontrar en la documentaci&amp;oacute;n de ese m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="7dcbf6c27d3fbecf0a1da02dbc8cbd5d7c319816" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;SelfLoader&lt;/b&gt; works similarly to the AutoLoader, but picks up the subs from after the &lt;code&gt;__DATA__&lt;/code&gt; instead of in the 'lib/auto' directory. There is a maintenance gain in not needing to run AutoSplit on the module at installation, and a runtime gain in not needing to keep opening and closing files to load subs. There is a runtime loss in needing to parse the code after the &lt;code&gt;__DATA__&lt;/code&gt;. Details of the &lt;b&gt;AutoLoader&lt;/b&gt; and another view of these distinctions can be found in that module's documentation.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94dafc36f54a138d4c7c8beed77372c0b7d94298" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Array&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;b&gt;Tie :: Array&lt;/b&gt; es un c&amp;oacute;digo auxiliar que simplemente croa.</target>
        </trans-unit>
        <trans-unit id="6b199766c781a0ae9ebeafd1ad9efb33847e8a69" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::Hash&lt;/b&gt; implementation is a stub that simply croaks.</source>
          <target state="translated">La implementaci&amp;oacute;n de &lt;b&gt;Tie :: Hash&lt;/b&gt; es un c&amp;oacute;digo auxiliar que simplemente croa.</target>
        </trans-unit>
        <trans-unit id="4134fa729bc36043c1bbc4226f0d69bd4bd166dc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdArray&lt;/b&gt; package provides efficient methods required for tied arrays which are implemented as blessed references to an &quot;inner&quot; perl array. It inherits from &lt;b&gt;Tie::Array&lt;/b&gt;, and should cause tied arrays to behave exactly like standard arrays, allowing for selective overloading of methods.</source>
          <target state="translated">El paquete &lt;b&gt;Tie :: StdArray&lt;/b&gt; proporciona los m&amp;eacute;todos eficientes necesarios para las matrices vinculadas que se implementan como referencias benditas a una matriz perl &quot;interna&quot;. Hereda de &lt;b&gt;Tie :: Array&lt;/b&gt; y deber&amp;iacute;a hacer que las matrices ligadas se comporten exactamente como las matrices est&amp;aacute;ndar, lo que permite una sobrecarga selectiva de m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="61ae2de46d00875a51e425357ad71e5ccdd2ad38" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; ). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="translated">El paquete &lt;b&gt;Tie :: StdHandle&lt;/b&gt; proporciona la mayor&amp;iacute;a de los m&amp;eacute;todos para los identificadores de archivos descritos en &lt;a href=&quot;../perltie&quot;&gt;perltie&lt;/a&gt; (las excepciones son &lt;code&gt;UNTIE&lt;/code&gt; y &lt;code&gt;DESTROY&lt;/code&gt; ). Hace que los identificadores de archivos vinculados se comporten exactamente como los identificadores de archivos est&amp;aacute;ndar y permiten la sobrescritura selectiva de m&amp;eacute;todos.</target>
        </trans-unit>
        <trans-unit id="4245a18625b67300aa61449aa8288d150f2262ee" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::StdHandle&lt;/b&gt; package provide most methods for file handles described in &lt;a href=&quot;perltie&quot;&gt;perltie&lt;/a&gt; (the exceptions are &lt;code&gt;UNTIE&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt;). It causes tied file handles to behave exactly like standard file handles and allow for selective overwriting of methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eacf0e41a2a5258a61ae34656b72764dd7acc141" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;Tie::SubstrHash&lt;/b&gt; package provides a hash-table-like interface to an array of determinate size, with constant key size and record size.</source>
          <target state="translated">El paquete &lt;b&gt;Tie :: SubstrHash&lt;/b&gt; proporciona una interfaz similar a una tabla hash para una matriz de tama&amp;ntilde;o determinado, con tama&amp;ntilde;o de clave y tama&amp;ntilde;o de registro constantes.</target>
        </trans-unit>
        <trans-unit id="a8a3a1e60f743e1378ee92d392f9857036d4b3d2" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;begincheck&lt;/b&gt; program makes it all clear, eventually:</source>
          <target state="translated">El programa &lt;b&gt;begincheck lo&lt;/b&gt; deja todo claro, eventualmente:</target>
        </trans-unit>
        <trans-unit id="1112db1b82f4fc99681fd70d53f56d13ced227cf" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma changes this to use the specified encoding instead. For example:</source>
          <target state="translated">El pragma de &lt;b&gt;codificaci&amp;oacute;n&lt;/b&gt; cambia esto para usar la codificaci&amp;oacute;n especificada en su lugar. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="b7162377ab2247a065b27f7ed4e48c5d078da511" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt;. Therefore,</source>
          <target state="translated">El pragma de &lt;b&gt;codificaci&amp;oacute;n&lt;/b&gt; funciona decodificando cadenas literales en &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; y as&amp;iacute; sucesivamente. En perl v5.8.0, esto no se aplica a &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; . Por lo tanto,</target>
        </trans-unit>
        <trans-unit id="0567b6469c4f0ce811f82d15382d41c3cb9254e1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;encoding&lt;/b&gt; pragma works by decoding string literals in &lt;code&gt;q//,qq//,qr//,qw///, qx//&lt;/code&gt; and so forth. In perl v5.8.0, this does not apply to &lt;code&gt;tr///&lt;/code&gt;. Therefore,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="80faef413c7207aab71b9f1d03988df6331ef791" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="translated">El &lt;b&gt;archivo&lt;/b&gt; (o &lt;b&gt;cadena&lt;/b&gt; , en el caso de &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; ) que se est&amp;aacute; &lt;b&gt;compilando&lt;/b&gt; actualmente .</target>
        </trans-unit>
        <trans-unit id="b93fec3ba5d429ebcf5cae82011aef3ec4a01036" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;file&lt;/b&gt; (or &lt;b&gt;string&lt;/b&gt;, in the case of &lt;code&gt;eval&lt;/code&gt;) that is currently being &lt;b&gt;compiled&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb5cf33051195df3d457e45e85209f2138dc4a05" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;first time&lt;/b&gt; the hook is hit in a serialization flow, you may have it return an empty list. That will signal the Storable engine to further discard that hook for this class and to therefore revert to the default serialization of the underlying Perl data. The hook will again be normally processed in the next serialization.</source>
          <target state="translated">La &lt;b&gt;primera vez que&lt;/b&gt; se golpea el gancho en un flujo de serializaci&amp;oacute;n, puede hacer que devuelva una lista vac&amp;iacute;a. Eso indicar&amp;aacute; al motor Storable que descarte a&amp;uacute;n m&amp;aacute;s ese gancho para esta clase y, por lo tanto, vuelva a la serializaci&amp;oacute;n predeterminada de los datos de Perl subyacentes. El gancho se volver&amp;aacute; a procesar normalmente en la siguiente serializaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="31b896e0d53803b62960180dd945e43dfa7f81e7" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;garbage collection&lt;/b&gt; of globals (and the running of any associated object destructors) that takes place when a Perl &lt;b&gt;interpreter&lt;/b&gt; is being shut down. Global destruction should not be confused with the Apocalypse, except perhaps when it should.</source>
          <target state="translated">La &lt;b&gt;recolecci&amp;oacute;n&lt;/b&gt; de &lt;b&gt;basura&lt;/b&gt; de globales (y la ejecuci&amp;oacute;n de cualquier destructor de objeto asociado) que tiene lugar cuando se cierra un &lt;b&gt;int&amp;eacute;rprete de&lt;/b&gt; Perl . La destrucci&amp;oacute;n global no deber&amp;iacute;a confundirse con el Apocalipsis, excepto quiz&amp;aacute;s cuando deber&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="987526f88e29534e7fb822b3987e499066378921" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt; . Some more examples are</source>
          <target state="translated">Los metacaracteres de &lt;b&gt;agrupaci&amp;oacute;n &lt;/b&gt; &lt;code&gt;()&lt;/code&gt; permiten que una parte de una expresi&amp;oacute;n regular se trate como una sola unidad. Las partes de una expresi&amp;oacute;n regular se agrupan encerr&amp;aacute;ndolas entre par&amp;eacute;ntesis. La &lt;code&gt;house(cat|keeper)&lt;/code&gt; expresiones regulares (gato | guardi&amp;aacute;n) significa &lt;code&gt;house&lt;/code&gt; f&amp;oacute;sforos seguida de &lt;code&gt;cat&lt;/code&gt; o &lt;code&gt;keeper&lt;/code&gt; . Algunos ejemplos m&amp;aacute;s son</target>
        </trans-unit>
        <trans-unit id="8b06519ab9371f66acf34ade00457226ccfb28ee" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;grouping&lt;/b&gt; metacharacters &lt;code&gt;()&lt;/code&gt; allow a part of a regex to be treated as a single unit. Parts of a regex are grouped by enclosing them in parentheses. The regex &lt;code&gt;house(cat|keeper)&lt;/code&gt; means match &lt;code&gt;house&lt;/code&gt; followed by either &lt;code&gt;cat&lt;/code&gt; or &lt;code&gt;keeper&lt;/code&gt;. Some more examples are</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ba87bd98015a685039202791b8b4c178941ed0ba" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;interpolation&lt;/b&gt; of a scalar or array variable into a string.</source>
          <target state="translated">La &lt;b&gt;interpolaci&amp;oacute;n&lt;/b&gt; de una variable escalar o de matriz en una cadena.</target>
        </trans-unit>
        <trans-unit id="fd9fd954815d11416f915389911ed3472be1a48a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;new()&lt;/b&gt; method can either be passed a set of key/value pairs or a single scalar value, namely the contents of a &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; sequence. An object of the class &lt;code&gt;Pod::Hyperlink&lt;/code&gt; is returned. The value &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; indicates a failure, the error message is stored in &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">El m&amp;eacute;todo &lt;b&gt;new ()&lt;/b&gt; puede pasar un conjunto de pares clave / valor o un solo valor escalar, es decir, el contenido de una secuencia &lt;code&gt;L&amp;lt;...&amp;gt;&lt;/code&gt; . Se devuelve un objeto de la clase &lt;code&gt;Pod::Hyperlink&lt;/code&gt; . El valor &lt;code&gt;&lt;a href=&quot;../functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; indica una falla, el mensaje de error se almacena en &lt;code&gt;$@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="22dcd0ec3aed7a2c1842ef98e2374e061c59b868" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;package&lt;/b&gt; in which the current statement is &lt;b&gt;compiled&lt;/b&gt;. Scan backward in the text of your program through the current &lt;b&gt;lexical scope&lt;/b&gt; or any enclosing lexical scopes until you find a package declaration. That&amp;rsquo;s your current package name.</source>
          <target state="translated">El &lt;b&gt;paquete&lt;/b&gt; en el que se &lt;b&gt;compila la&lt;/b&gt; declaraci&amp;oacute;n actual . Escanee hacia atr&amp;aacute;s en el texto de su programa a trav&amp;eacute;s del &lt;b&gt;&amp;aacute;mbito l&amp;eacute;xico&lt;/b&gt; actual o cualquier &lt;b&gt;&amp;aacute;mbito&lt;/b&gt; l&amp;eacute;xico adjunto hasta que encuentre una declaraci&amp;oacute;n de paquete. Ese es su nombre de paquete actual.</target>
        </trans-unit>
        <trans-unit id="837534d7853b1df8d6be64303da76d4fb655fe6c" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;parse_text()&lt;/b&gt; method takes a given paragraph of text, and returns a parse-tree that contains one or more children, each of which may be a text-string, or an InteriorSequence object. There are also callback-options that may be passed to &lt;b&gt;parse_text()&lt;/b&gt; to customize the way it expands or transforms interior-sequences, as well as the returned result. These callbacks can be used to create a parse-tree with custom-made objects (which may or may not support the parse-tree interface, depending on how you choose to do it).</source>
          <target state="translated">El m&amp;eacute;todo &lt;b&gt;parse_text ()&lt;/b&gt; toma un p&amp;aacute;rrafo dado de texto y devuelve un &amp;aacute;rbol de an&amp;aacute;lisis sint&amp;aacute;ctico que contiene uno o m&amp;aacute;s elementos secundarios, cada uno de los cuales puede ser una cadena de texto o un objeto InteriorSequence. Tambi&amp;eacute;n hay opciones de devoluci&amp;oacute;n de llamada que se pueden pasar a &lt;b&gt;parse_text ()&lt;/b&gt; para personalizar la forma en que expande o transforma las secuencias interiores, as&amp;iacute; como el resultado devuelto. Estas devoluciones de llamada se pueden utilizar para crear un &amp;aacute;rbol de an&amp;aacute;lisis sint&amp;aacute;ctico con objetos personalizados (que pueden admitir o no la interfaz del &amp;aacute;rbol de an&amp;aacute;lisis sint&amp;aacute;ctico, seg&amp;uacute;n c&amp;oacute;mo elija hacerlo).</target>
        </trans-unit>
        <trans-unit id="b2fcda0a32417727cdd721f28d0c908b93bc1f19" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;perlivp&lt;/b&gt; program is set up at Perl source code build time to test the Perl version it was built under. It can be used after running:</source>
          <target state="translated">El programa &lt;b&gt;perlivp&lt;/b&gt; se configura en el momento de la compilaci&amp;oacute;n del c&amp;oacute;digo fuente de Perl para probar la versi&amp;oacute;n de Perl con la que se cre&amp;oacute;. Se puede utilizar despu&amp;eacute;s de ejecutar:</target>
        </trans-unit>
        <trans-unit id="dc37ad02e0c6923bebd0d4430ccd02307461404f" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; command is provided for checking Pod syntax for errors and warnings. For example, it checks for completely blank lines in Pod blocks and for unknown commands and formatting codes. You should still also pass your document through one or more translators and proofread the result, or print out the result and proofread that. Some of the problems found may be bugs in the translators, which you may or may not wish to work around.</source>
          <target state="translated">El comando &lt;b&gt;podchecker&lt;/b&gt; se proporciona para verificar la sintaxis del pod en busca de errores y advertencias. Por ejemplo, busca l&amp;iacute;neas completamente en blanco en bloques de Pod y comandos desconocidos y c&amp;oacute;digos de formato. Tambi&amp;eacute;n debe pasar su documento a trav&amp;eacute;s de uno o m&amp;aacute;s traductores y corregir el resultado, o imprimir el resultado y corregirlo. Algunos de los problemas encontrados pueden ser errores en los traductores, que puede que desee o no evitar.</target>
        </trans-unit>
        <trans-unit id="0a20174d8e3b5a76e2734d6eb6a0cf7707e14ad1" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;podchecker&lt;/b&gt; script that comes with this distribution is a lean wrapper around this module. See the online manual with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d299b97d8bab37b1330370eb9473b8a413d005a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; , and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="translated">&amp;iquest;Los metacaracteres &lt;b&gt;cuantificadores &lt;/b&gt; &lt;code&gt;?&lt;/code&gt; , &lt;code&gt;*&lt;/code&gt; , &lt;code&gt;+&lt;/code&gt; y &lt;code&gt;{}&lt;/code&gt; nos permiten determinar el n&amp;uacute;mero de repeticiones de una parte de una expresi&amp;oacute;n regular que consideramos una coincidencia. Los cuantificadores se colocan inmediatamente despu&amp;eacute;s del car&amp;aacute;cter, clase de car&amp;aacute;cter o agrupaci&amp;oacute;n que queremos especificar. Tienen los siguientes significados:</target>
        </trans-unit>
        <trans-unit id="eaae51c09e62ae41b20067864a8beaa2340f2425" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;quantifier&lt;/b&gt; metacharacters &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;{}&lt;/code&gt; allow us to determine the number of repeats of a portion of a regex we consider to be a match. Quantifiers are put immediately after the character, character class, or grouping that we want to specify. They have the following meanings:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b54e7f659f70ec7a4f3708e917b8834ab10ef21" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; , the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="translated">Los &lt;b&gt;valores escalares&lt;/b&gt; que proporciona a una &lt;b&gt;funci&amp;oacute;n&lt;/b&gt; o &lt;b&gt;subrutina&lt;/b&gt; cuando la llama. Por ejemplo, cuando llama a &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt; , la cadena &lt;code&gt;&quot;puff&quot;&lt;/code&gt; es el argumento real. Ver tambi&amp;eacute;n &lt;b&gt;argumento&lt;/b&gt; y &lt;b&gt;argumentos formales&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="322845e84e15f9ba6a6f987f2f0f5a926b87542a" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;scalar values&lt;/b&gt; that you supply to a &lt;b&gt;function&lt;/b&gt; or &lt;b&gt;subroutine&lt;/b&gt; when you call it. For instance, when you call &lt;code&gt;power(&quot;puff&quot;)&lt;/code&gt;, the string &lt;code&gt;&quot;puff&quot;&lt;/code&gt; is the actual argument. See also &lt;b&gt;argument&lt;/b&gt; and &lt;b&gt;formal arguments&lt;/b&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4a023f0632e523744570838f6670cc7a9e367c0e" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="translated">El &lt;b&gt;SIGTRAP&lt;/b&gt; pragma es una interfaz sencilla para la instalaci&amp;oacute;n de manejadores de se&amp;ntilde;ales. Puede hacer que instale uno de los dos controladores suministrados por &lt;b&gt;sigtrap&lt;/b&gt; (uno que proporciona un seguimiento de pila de Perl y otro que simplemente &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die()&lt;/a&gt;&lt;/code&gt; s), o alternativamente puede proporcionar su propio controlador para que lo instale. Solo se le puede decir que instale un controlador para se&amp;ntilde;ales que no est&amp;aacute;n atrapadas o ignoradas. Tiene un par de listas de se&amp;ntilde;ales para atrapar, adem&amp;aacute;s, puede proporcionar su propia lista de se&amp;ntilde;ales.</target>
        </trans-unit>
        <trans-unit id="9bf9f6bd9139c0d963b36b36175d399537dfc4fb" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;sigtrap&lt;/b&gt; pragma is a simple interface to installing signal handlers. You can have it install one of two handlers supplied by &lt;b&gt;sigtrap&lt;/b&gt; itself (one which provides a Perl stack trace and one which simply &lt;code&gt;die()&lt;/code&gt;s), or alternately you can supply your own handler for it to install. It can be told only to install a handler for signals which are either untrapped or ignored. It has a couple of lists of signals to trap, plus you can supply your own list of signals.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d7c162ba3d4340b1ed67afae232423e0f505fd2b" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; produced by a &lt;b&gt;subroutine&lt;/b&gt; or &lt;b&gt;expression&lt;/b&gt; when evaluated. In Perl, a return value may be either a &lt;b&gt;list&lt;/b&gt; or a &lt;b&gt;scalar&lt;/b&gt;.</source>
          <target state="translated">El &lt;b&gt;valor&lt;/b&gt; producido por una &lt;b&gt;subrutina&lt;/b&gt; o &lt;b&gt;expresi&amp;oacute;n&lt;/b&gt; cuando se eval&amp;uacute;a. En Perl, un valor de retorno puede ser una &lt;b&gt;lista&lt;/b&gt; o un &lt;b&gt;escalar&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="7487920171bd7708f5f44fcbcd3a51b3cd669ff9" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt; . Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="translated">El &lt;b&gt;valor&lt;/b&gt; devuelto al &lt;b&gt;proceso&lt;/b&gt; padre cuando uno de sus procesos hijo muere. Este valor se coloca en la variable especial &lt;code&gt;$?&lt;/code&gt; . Sus ocho &lt;b&gt;bits&lt;/b&gt; superiores son el estado de salida del proceso difunto, y sus ocho bits inferiores identifican la se&amp;ntilde;al (si la hay) de la que muri&amp;oacute; el proceso. En los sistemas Unix, este valor de estado es el mismo que la palabra de estado devuelta por</target>
        </trans-unit>
        <trans-unit id="92fc59668896181422dc0c709aa06976d25a8bdd" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;value&lt;/b&gt; returned to the parent &lt;b&gt;process&lt;/b&gt; when one of its child processes dies. This value is placed in the special variable &lt;code&gt;$?&lt;/code&gt;. Its upper eight &lt;b&gt;bits&lt;/b&gt; are the exit status of the defunct process, and its lower eight bits identify the signal (if any) that the process died from. On Unix systems, this status value is the same as the status word returned by</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f75f87bdfa0eb35c4f5fe0a1642de1f3532d7289" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt; .</source>
          <target state="translated">Los &lt;b&gt;valores&lt;/b&gt; que proporciona junto con el nombre de un programa cuando le dice a un &lt;b&gt;shell&lt;/b&gt; que ejecute un &lt;b&gt;comando&lt;/b&gt; . Estos valores se pasan a un programa Perl a trav&amp;eacute;s de &lt;code&gt;@ARGV&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="41ad86c2a0eef157efad4b1818e0188a3bba4d01" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;values&lt;/b&gt; you supply along with a program name when you tell a &lt;b&gt;shell&lt;/b&gt; to execute a &lt;b&gt;command&lt;/b&gt;. These values are passed to a Perl program through &lt;code&gt;@ARGV&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8215a7b783f151c4ff06cfd84ff859eb48442e77" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt; :</source>
          <target state="translated">La &lt;b&gt;palabra ancla &lt;/b&gt; &lt;code&gt;\b&lt;/code&gt; coincide con un l&amp;iacute;mite entre un car&amp;aacute;cter de palabra y un car&amp;aacute;cter que no es de palabra &lt;code&gt;\w\W&lt;/code&gt; o &lt;code&gt;\W\w&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="e0d33c43c6614d46185d88549fdc18a2c8537ffc" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;word anchor&lt;/b&gt;&lt;code&gt;\b&lt;/code&gt; matches a boundary between a word character and a non-word character &lt;code&gt;\w\W&lt;/code&gt; or &lt;code&gt;\W\w&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="98df2a206a33c61c05323edbf28b990dfe8bb9b6" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program takes the XS code in the .xs file and translates it into C code, placing it in a file whose suffix is .c. The C code created makes heavy use of the C functions within Perl.</source>
          <target state="translated">El programa &lt;b&gt;xsubpp&lt;/b&gt; toma el c&amp;oacute;digo XS en el archivo .xs y lo traduce a c&amp;oacute;digo C, coloc&amp;aacute;ndolo en un archivo cuyo sufijo es .c. El c&amp;oacute;digo C creado hace un uso intensivo de las funciones C dentro de Perl.</target>
        </trans-unit>
        <trans-unit id="e9db711485ba959f3d0b453c931365b6638809a5" translate="yes" xml:space="preserve">
          <source>The &lt;b&gt;xsubpp&lt;/b&gt; program uses rules to convert from Perl's data types (scalar, array, etc.) to C's data types (int, char, etc.). These rules are stored in the typemap file ($PERLLIB/ExtUtils/typemap). There's a brief discussion below, but all the nitty-gritty details can be found in &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt;. If you have a new-enough version of perl (5.16 and up) or an upgraded XS compiler (&lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 or better), then you can inline typemaps in your XS instead of writing separate files. Either way, this typemap thing is split into three parts:</source>
          <target state="translated">El programa &lt;b&gt;xsubpp&lt;/b&gt; usa reglas para convertir de los tipos de datos de Perl (escalar, matriz, etc.) a los tipos de datos de C (int, char, etc.). Estas reglas se almacenan en el archivo typemap ($ PERLLIB / ExtUtils / typemap). Hay una breve discusi&amp;oacute;n a continuaci&amp;oacute;n, pero todos los detalles esenciales se pueden encontrar en &lt;a href=&quot;perlxstypemap&quot;&gt;perlxstypemap&lt;/a&gt; . Si tiene una versi&amp;oacute;n lo suficientemente nueva de perl (5.16 y superior) o un compilador XS actualizado ( &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; 3.13_01 o mejor), entonces puede insertar typemaps en su XS en lugar de escribir archivos separados. De cualquier manera, este tipo de mapa se divide en tres partes:</target>
        </trans-unit>
        <trans-unit id="1082cc04157e373604ca98ab1606eeb58e2bd5d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt; $output &lt;/code&gt; argument may be:</source>
          <target state="translated">El argumento &lt;code&gt; $output &lt;/code&gt; puede ser:</target>
        </trans-unit>
        <trans-unit id="fe02d79593918e0f0b57f9efa92b9388e3573b1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;)&quot;&lt;/code&gt; is out-of-place. Something apparently was supposed to be combined with the digits, or the &lt;code&gt;&quot;+&quot;&lt;/code&gt; shouldn't be there, or something like that. Perl can't figure out what was intended.</source>
          <target state="translated">El &lt;code&gt;&quot;)&quot;&lt;/code&gt; est&amp;aacute; fuera de lugar. Al parecer, se supon&amp;iacute;a que algo deb&amp;iacute;a combinarse con los d&amp;iacute;gitos, o el &lt;code&gt;&quot;+&quot;&lt;/code&gt; no deber&amp;iacute;a estar all&amp;iacute;, o algo as&amp;iacute;. Perl no puede entender lo que se pretend&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="b82e89101d474c0486e6c08a915553c14b105df6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;*&quot;&lt;/code&gt; quantifier is equivalent to &lt;code&gt;{0,}&lt;/code&gt;, the &lt;code&gt;&quot;+&quot;&lt;/code&gt; quantifier to &lt;code&gt;{1,}&lt;/code&gt;, and the &lt;code&gt;&quot;?&quot;&lt;/code&gt; quantifier to &lt;code&gt;{0,1}&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="74bbd851b5114dd4dbacbd6abc257c5bbd630765" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#%28%3FPARNO%29-%28%3F-PARNO%29-%28%3F%2BPARNO%29-%28%3FR%29-%28%3F0%29&quot;&gt;&lt;code&gt;(?&lt;i&gt;PARNO&lt;/i&gt;)&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="54034a923125cadab60eef06f26fcb91d4e7c351" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;+&quot;&lt;/code&gt; is valid only when followed by digits, indicating a capturing group. See &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(?PARNO)&lt;/a&gt;.</source>
          <target state="translated">El &lt;code&gt;&quot;+&quot;&lt;/code&gt; es v&amp;aacute;lido solo cuando est&amp;aacute; seguido de d&amp;iacute;gitos, lo que indica un grupo de captura. Ver &lt;a href=&quot;perlre#(%3fPARNO)-(%3f-PARNO)-(%3f%2bPARNO)-(%3fR)-(%3f0)&quot;&gt;(? PARNO)&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="07bb712ac114a7fe219229eb5a67b484b3ca58ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;?&quot;&lt;/code&gt; and &lt;code&gt;&quot;+&quot;&lt;/code&gt; don't have any effect, as they modify whether to match more or fewer when there is a choice, and by specifying to match exactly a given numer, there is no room left for a choice.</source>
          <target state="translated">El &lt;code&gt;&quot;?&quot;&lt;/code&gt; y &lt;code&gt;&quot;+&quot;&lt;/code&gt; no tienen ning&amp;uacute;n efecto, ya que modifican si hacer coincidir m&amp;aacute;s o menos cuando hay una opci&amp;oacute;n, y al especificar que coincida exactamente con un n&amp;uacute;mero dado, no queda espacio para una elecci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="622f5262d7227133a18718033006d1fe595c3150" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;U&quot;&lt;/code&gt; template has been ported to mean &quot;Unicode&quot; on all platforms so that</source>
          <target state="translated">La plantilla &lt;code&gt;&quot;U&quot;&lt;/code&gt; se ha adaptado para que signifique &quot;Unicode&quot; en todas las plataformas para que</target>
        </trans-unit>
        <trans-unit id="d9a4c62629e10d33b540e16fc1ce8f7a3f41635f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;\x&quot;&lt;/code&gt; construct without curly braces should be followed by exactly two hex digits; this one is followed by three. This currently evaluates as equivalent to</source>
          <target state="translated">La construcci&amp;oacute;n &lt;code&gt;&quot;\x&quot;&lt;/code&gt; sin llaves debe ir seguida exactamente de dos d&amp;iacute;gitos hexadecimales; a este le siguen tres. Esto actualmente se eval&amp;uacute;a como equivalente a</target>
        </trans-unit>
        <trans-unit id="18a8e19a030c3c8f53e48396122990cc28295c5e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;a&quot;&lt;/code&gt; is a valid modifier flag, but the &lt;code&gt;&quot;n&quot;&lt;/code&gt; is not, and raises this error. Likely what was meant instead was:</source>
          <target state="translated">La &lt;code&gt;&quot;a&quot;&lt;/code&gt; es una bandera modificadora v&amp;aacute;lida, pero la &lt;code&gt;&quot;n&quot;&lt;/code&gt; no lo es, y genera este error. Probablemente lo que se quiso decir en cambio fue:</target>
        </trans-unit>
        <trans-unit id="14e2e8dae7c922be26733e3e660b25612cc5ce26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="translated">Las plantillas &lt;code&gt;&quot;c&quot;&lt;/code&gt; y &lt;code&gt;&quot;C&quot;&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; dependen de la codificaci&amp;oacute;n del juego de caracteres. Ejemplos de uso en EBCDIC incluyen:</target>
        </trans-unit>
        <trans-unit id="3a90b3cf3b7660a315d348d508a144827f3fa53e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;c&quot;&lt;/code&gt; and &lt;code&gt;&quot;C&quot;&lt;/code&gt; templates for &lt;code&gt;pack()&lt;/code&gt; are dependent upon character set encoding. Examples of usage on EBCDIC include:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c8f5308cfb898e8f57b9a7b021b28f517778138" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt; . The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="translated">La subrutina &lt;code&gt;&quot;code&quot;&lt;/code&gt; solo se utilizar&amp;aacute; para filtrar partes del c&amp;oacute;digo fuente que no sean quotelikes, POD o &lt;code&gt;__DATA__&lt;/code&gt; . La subrutina de &lt;code&gt;quotelike&lt;/code&gt; solo filtra los quotelikes de Perl (incluidos aqu&amp;iacute; los documentos).</target>
        </trans-unit>
        <trans-unit id="00d33c98d86ed179e5a669f2bc40830325b6bdf3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;code&quot;&lt;/code&gt; subroutine will only be used to filter parts of the source code that are not quotelikes, POD, or &lt;code&gt;__DATA__&lt;/code&gt;. The &lt;code&gt;quotelike&lt;/code&gt; subroutine only filters Perl quotelikes (including here documents).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de5cb8ed1d57c1871e5453eb580a0076b635dfd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&quot;use locale&quot;&lt;/code&gt; pragma</source>
          <target state="translated">El pragma &lt;code&gt;&quot;use locale&quot;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="9e55a545076df6df5f2e5f8da5ca2fba9b8a556b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;a href=&quot;#-x&quot;&gt;&quot;-x&quot;&lt;/a&gt; was used to find the beginning of the program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5361c21bc61e8999f4b7544ffeef33e12b0b1a2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;#!&lt;/code&gt; line is always examined for switches as the line is being parsed. Thus, if you're on a machine that allows only one argument with the &lt;code&gt;#!&lt;/code&gt; line, or worse, doesn't even recognize the &lt;code&gt;#!&lt;/code&gt; line, you still can get consistent switch behaviour regardless of how Perl was invoked, even if &lt;b&gt;-x&lt;/b&gt; was used to find the beginning of the program.</source>
          <target state="translated">El &lt;code&gt;#!&lt;/code&gt; La l&amp;iacute;nea siempre se examina en busca de conmutadores a medida que se analiza la l&amp;iacute;nea. Por lo tanto, si est&amp;aacute; en una m&amp;aacute;quina que solo permite un argumento con &lt;code&gt;#!&lt;/code&gt; l&amp;iacute;nea, o peor a&amp;uacute;n, &amp;iexcl;ni siquiera reconoce el &lt;code&gt;#!&lt;/code&gt; line, a&amp;uacute;n puede obtener un comportamiento de cambio consistente independientemente de c&amp;oacute;mo se invoc&amp;oacute; Perl, incluso si se us&amp;oacute; &lt;b&gt;-x&lt;/b&gt; para encontrar el comienzo del programa.</target>
        </trans-unit>
        <trans-unit id="108405af164a595d0a02e5242d4aac5c7a9939f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; form was added in Perl v5.20.0 for historical reasons but its use is discouraged. (If your reason to use &lt;code&gt;$]&lt;/code&gt; is to run code on old perls then referring to it as &lt;code&gt;$OLD_PERL_VERSION&lt;/code&gt; would be self-defeating.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a8b854056feda55458ac395207c0edacf4109d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; doesn't support &lt;code&gt;'IGNORE'&lt;/code&gt;; it has the same effect as &lt;code&gt;'DEFAULT'&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="06cfb8f268bdf180a533e3982943c594a32d2955" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; hook is called even inside an &lt;code&gt;eval()&lt;/code&gt;. It was never intended to happen this way, but an implementation glitch made this possible. This used to be deprecated, as it allowed strange action at a distance like rewriting a pending exception in &lt;code&gt;$@&lt;/code&gt;. Plans to rectify this have been scrapped, as users found that rewriting a pending exception is actually a useful feature, and not a bug.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4fb2868e39025eacf0d00ec1478ba8ee01a99e7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$VERSION&lt;/code&gt; variable is used to ensure that the .pm file and the shared library are &quot;in sync&quot; with each other. Any time you make changes to the .pm or .xs files, you should increment the value of this variable.</source>
          <target state="translated">La variable &lt;code&gt;$VERSION&lt;/code&gt; se utiliza para garantizar que el archivo .pm y la biblioteca compartida est&amp;eacute;n &quot;sincronizados&quot; entre s&amp;iacute;. Cada vez que realice cambios en los archivos .pm o .xs, debe incrementar el valor de esta variable.</target>
        </trans-unit>
        <trans-unit id="2ee72eb90ddce6bbc0931d4e233b1341c5327087" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt; ) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="translated">La variable &lt;code&gt;$^O&lt;/code&gt; ( &lt;code&gt;$OSNAME&lt;/code&gt; si usa &lt;code&gt;English&lt;/code&gt; ) contiene una indicaci&amp;oacute;n del nombre del sistema operativo (no su n&amp;uacute;mero de versi&amp;oacute;n) para el que se cre&amp;oacute; su binario de Perl.</target>
        </trans-unit>
        <trans-unit id="3c4fecf66108e7576d4b50d6bd4010c1a13f5ea1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable (&lt;code&gt;$OSNAME&lt;/code&gt; if you use &lt;code&gt;English&lt;/code&gt;) contains an indication of the name of the operating system (not its release number) that your perl binary was built for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d2aab00569329bab82f1ebc14faa8b668168dc31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$^O&lt;/code&gt; variable and the &lt;code&gt;$Config{archname}&lt;/code&gt; values for various DOSish perls are as follows:</source>
          <target state="translated">La variable &lt;code&gt;$^O&lt;/code&gt; y los valores &lt;code&gt;$Config{archname}&lt;/code&gt; para varias perls de DOSish son los siguientes:</target>
        </trans-unit>
        <trans-unit id="eba7fdbb831c55f9a441c12e1806775b9e1de0a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$array[1]&lt;/code&gt; is a single-element access to the array. It's going to return the item in index 1 (or undef if there is no item there). If you intend to get exactly one element from the array, this is the form you should use.</source>
          <target state="translated">El &lt;code&gt;$array[1]&lt;/code&gt; es un acceso de un solo elemento a la matriz. Devolver&amp;aacute; el art&amp;iacute;culo en el &amp;iacute;ndice 1 (o undef si no hay ning&amp;uacute;n art&amp;iacute;culo all&amp;iacute;). Si tiene la intenci&amp;oacute;n de obtener exactamente un elemento de la matriz, este es el formulario que debe usar.</target>
        </trans-unit>
        <trans-unit id="2844c7d661123084d4f84dec0ab13e6bfc03da52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$buffer&lt;/code&gt; puede ser una referencia escalar o escalar.</target>
        </trans-unit>
        <trans-unit id="27274181277155f678e99b9a2b287e41860c82ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter can either be a scalar or a scalar reference. The contents of the &lt;code&gt;$buffer&lt;/code&gt; parameter are destroyed after calling this function.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$buffer&lt;/code&gt; puede ser una referencia escalar o escalar. El contenido del par&amp;aacute;metro &lt;code&gt;$buffer&lt;/code&gt; se destruye despu&amp;eacute;s de llamar a esta funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8c4fb1959a7d1bef1019739dc5a4ea212bbc1a3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt; . On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt; . When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$buffer&lt;/code&gt; es modificado por &lt;code&gt;inflate&lt;/code&gt; . Al finalizar, contendr&amp;aacute; lo que quede del b&amp;uacute;fer de entrada despu&amp;eacute;s de la inflaci&amp;oacute;n. Esto significa que &lt;code&gt;$buffer&lt;/code&gt; ser&amp;aacute; una cadena vac&amp;iacute;a cuando el estado de retorno sea &lt;code&gt;Z_OK&lt;/code&gt; . Cuando el estado de retorno es &lt;code&gt;Z_STREAM_END&lt;/code&gt; , el par&amp;aacute;metro &lt;code&gt;$buffer&lt;/code&gt; contendr&amp;aacute; lo que (si es que hay algo) se almacen&amp;oacute; en el b&amp;uacute;fer de entrada despu&amp;eacute;s del flujo de datos desinflado.</target>
        </trans-unit>
        <trans-unit id="735065db643a224d7abc76057afb08424a7f97a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$buffer&lt;/code&gt; parameter is modified by &lt;code&gt;inflate&lt;/code&gt;. On completion it will contain what remains of the input buffer after inflation. This means that &lt;code&gt;$buffer&lt;/code&gt; will be an empty string when the return status is &lt;code&gt;Z_OK&lt;/code&gt;. When the return status is &lt;code&gt;Z_STREAM_END&lt;/code&gt; the &lt;code&gt;$buffer&lt;/code&gt; parameter will contains what (if anything) was stored in the input buffer after the deflated data stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4dd78ddf95d786af083e0413cd47b10ceef529f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$context&lt;/code&gt; passed in will be an instance of &lt;a href=&quot;Test2::API::Context&quot;&gt;Test2::API::Context&lt;/a&gt;. The &lt;code&gt;$exit&lt;/code&gt; argument will be the original exit code before anything modified it. &lt;code&gt;$$new_exit&lt;/code&gt; is a reference to the new exit code. You may modify this to change the exit code. Please note that &lt;code&gt;$$new_exit&lt;/code&gt; may already be different from &lt;code&gt;$exit&lt;/code&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1f084c43da0252a420f089c62656f2a4438958f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;&quot;parsers&quot;&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4deaa69228d0bed93aa2331246fd160457f98868" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$description&lt;/code&gt; is usually a test file name (but only by convention.) It is used as a unique identifier (see e.g. &lt;a href=&quot;#parsers&quot;&gt;parsers&lt;/a&gt;.) Reusing a description is a fatal error.</source>
          <target state="translated">La &lt;code&gt;$description&lt;/code&gt; es generalmente un nombre de archivo de prueba (pero solo por convenci&amp;oacute;n). Se usa como un identificador &amp;uacute;nico (ver, por ejemplo, &lt;a href=&quot;#parsers&quot;&gt;analizadores&lt;/a&gt; ). Reutilizar una descripci&amp;oacute;n es un error fatal.</target>
        </trans-unit>
        <trans-unit id="04558cf60bc9c7167d85368eb6635a2473770d4f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter needs a bit of explanation.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$eof&lt;/code&gt; necesita una peque&amp;ntilde;a explicaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="65f92aaac6b66cd674844396e8d45e3f370fce50" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$eof&lt;/code&gt; parameter only needs to be used if &lt;b&gt;all&lt;/b&gt; of the following conditions apply</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$eof&lt;/code&gt; solo debe usarse si se cumplen &lt;b&gt;todas&lt;/b&gt; las condiciones siguientes</target>
        </trans-unit>
        <trans-unit id="8a410599f21ede34ce0c4e99388bf1aa3ff8199e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$gzerrno&lt;/code&gt; scalar holds the error code associated with the most recent</source>
          <target state="translated">El escalar &lt;code&gt;$gzerrno&lt;/code&gt; contiene el c&amp;oacute;digo de error asociado con el m&amp;aacute;s reciente</target>
        </trans-unit>
        <trans-unit id="6264c4349310ae2e82ed9dccab08bd7526a285d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$in_fh&lt;/code&gt; parameter may be any object that provides a &lt;b&gt;getline()&lt;/b&gt; method to retrieve a single line of input text (hence, an appropriate wrapper object could be used to parse PODs from a single string or an array of strings).</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$in_fh&lt;/code&gt; puede ser cualquier objeto que proporcione un m&amp;eacute;todo &lt;b&gt;getline ()&lt;/b&gt; para recuperar una sola l&amp;iacute;nea de texto de entrada (por lo tanto, se podr&amp;iacute;a usar un objeto contenedor apropiado para analizar los POD de una sola cadena o una matriz de cadenas).</target>
        </trans-unit>
        <trans-unit id="e89b34e9c40c9e18afebc88c2be1c3150fecd52e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input&lt;/code&gt; and &lt;code&gt;$output&lt;/code&gt; parameters can be either scalars or scalar references.</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;$input&lt;/code&gt; y &lt;code&gt;$output&lt;/code&gt; pueden ser escalares o referencias escalares.</target>
        </trans-unit>
        <trans-unit id="d5ad245702c5052688f1d153e2fbd703e2f8f301" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$input_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$input_filename_or_reference&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="daa9f5f9a1ef279c49e625124d1e76146ad5e7d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; , and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; . If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$level&lt;/code&gt; define el nivel de compresi&amp;oacute;n. Los valores v&amp;aacute;lidos son de 0 a 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt; , &lt;code&gt;Z_BEST_SPEED&lt;/code&gt; , &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt; y &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; . Si no se especifica &lt;code&gt;$level&lt;/code&gt; , se utilizar&amp;aacute; &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="898131faa0f3e8f99a6d077f4bd62a3c78ce8ae9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$level&lt;/code&gt; parameter defines the compression level. Valid values are 0 through 9, &lt;code&gt;Z_NO_COMPRESSION&lt;/code&gt;, &lt;code&gt;Z_BEST_SPEED&lt;/code&gt;, &lt;code&gt;Z_BEST_COMPRESSION&lt;/code&gt;, and &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt;. If &lt;code&gt;$level&lt;/code&gt; is not specified &lt;code&gt;Z_DEFAULT_COMPRESSION&lt;/code&gt; will be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb33cd5cc665b9c3bd624d64f0ec40381e42cbac" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt; . The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="translated">El &lt;code&gt;$mon&lt;/code&gt; tiene una base cero: enero es igual a &lt;code&gt;0&lt;/code&gt; . El &lt;code&gt;$year&lt;/code&gt; se basa en 1900: 2001 es igual a &lt;code&gt;101&lt;/code&gt; . &lt;code&gt;$wday&lt;/code&gt; y &lt;code&gt;$yday&lt;/code&gt; predeterminados a cero (y generalmente se ignoran de todos modos), y &lt;code&gt;$isdst&lt;/code&gt; predeterminado a -1.</target>
        </trans-unit>
        <trans-unit id="7421dc164fd8281f20128cde64ce3b745047d3c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$mon&lt;/code&gt; is zero-based: January equals &lt;code&gt;0&lt;/code&gt;. The &lt;code&gt;$year&lt;/code&gt; is 1900-based: 2001 equals &lt;code&gt;101&lt;/code&gt;. &lt;code&gt;$wday&lt;/code&gt; and &lt;code&gt;$yday&lt;/code&gt; default to zero (and are usually ignored anyway), and &lt;code&gt;$isdst&lt;/code&gt; defaults to -1.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="23cd0f7ae4d6af5b92c0f4a1db509d798cb0ac59" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$name&lt;/code&gt; variable should be the key used to access the facet in a facets hashref. For instance the assertion facet has the key 'assert', the information facet has the 'info' key, and the error facet has the key 'errors'. You may include or omit the 's' at the end of the name, the method is smart enough to try both the 's' and no-'s' forms, it will check what you provided first, and if that is not found it will add or strip the 's and try again.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d866868676edf3ef0ef337619cbb9d7d463b060f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$output_filename_or_reference&lt;/code&gt; parameter</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$output_filename_or_reference&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="c96d672905fea90a5656f24eb9f7936742884276" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;../parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="translated">El &lt;code&gt;$parser&lt;/code&gt; es un objeto &lt;a href=&quot;../parser&quot;&gt;TAP :: Parser&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="6143cd77ebc527cea165f0db3248c326b91b9c6e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$parser&lt;/code&gt; is a &lt;a href=&quot;TAP::Parser&quot;&gt;TAP::Parser&lt;/a&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0cde3685cee91824cf2720ce6f47ce3c1655541a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$tabstop&lt;/code&gt; variable controls how many column positions apart each tabstop is. The default is 8.</source>
          <target state="translated">La variable &lt;code&gt;$tabstop&lt;/code&gt; controla cu&amp;aacute;ntas posiciones de columna est&amp;aacute;n separadas por cada tabulador. El valor predeterminado es 8.</target>
        </trans-unit>
        <trans-unit id="07507ab596d7a55a579157466578b8c289c17f57" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter should be one of SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$whence&lt;/code&gt; debe ser uno de SEEK_SET, SEEK_CUR o SEEK_END.</target>
        </trans-unit>
        <trans-unit id="78200cc1ea59e994c5d2418e77df8c6e8fa8185d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$whence&lt;/code&gt; parameter takes one the usual values, namely SEEK_SET, SEEK_CUR or SEEK_END.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;$whence&lt;/code&gt; toma uno de los valores habituales, a saber, SEEK_SET, SEEK_CUR o SEEK_END.</target>
        </trans-unit>
        <trans-unit id="d36c42de8f17d5532305a2dae875ef12d3135188" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;$|&lt;/code&gt; is one of the per-filehandle special variables, so each filehandle has its own copy of its value. If you want to merge standard output and standard error for instance, you have to unbuffer each (although STDERR might be unbuffered by default):</source>
          <target state="translated">El &lt;code&gt;$|&lt;/code&gt; es una de las variables especiales por identificador de archivo, por lo que cada identificador de archivo tiene su propia copia de su valor. Si desea fusionar la salida est&amp;aacute;ndar y el error est&amp;aacute;ndar, por ejemplo, debe eliminar el b&amp;uacute;fer de cada uno (aunque STDERR puede no tener b&amp;uacute;fer de forma predeterminada):</target>
        </trans-unit>
        <trans-unit id="697d0e02c23a6252ba73964b72ba7fef06e6718b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt; . This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="translated">El &lt;code&gt;%^H&lt;/code&gt; de hash proporciona el mismo alcance sem&amp;aacute;ntico &lt;code&gt;$^H&lt;/code&gt; . Esto lo hace &amp;uacute;til para la implementaci&amp;oacute;n de pragmas de &amp;aacute;mbito l&amp;eacute;xico. Ver &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt; . Todas las entradas est&amp;aacute;n secuenciadas cuando se accede a ellas en tiempo de ejecuci&amp;oacute;n, por lo que solo se pueden acomodar valores simples. Esto significa que no hay punteros a objetos, por ejemplo.</target>
        </trans-unit>
        <trans-unit id="1c509249d339b2febfc4d2738ff085bd8d0cc7d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%^H&lt;/code&gt; hash provides the same scoping semantic as &lt;code&gt;$^H&lt;/code&gt;. This makes it useful for implementation of lexically scoped pragmas. See &lt;a href=&quot;perlpragma&quot;&gt;perlpragma&lt;/a&gt;. All the entries are stringified when accessed at runtime, so only simple values can be accommodated. This means no pointers to objects, for example.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0c6228356b1a9a18f543cd58f3d14ae5ed0885fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt; , and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="translated">El &lt;code&gt;%s&lt;/code&gt; se expande para ser el nombre del archivo ( se usa &lt;code&gt;&lt;a href=&quot;../functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; , as&amp;iacute; que tenga cuidado de escapar de cualquier otro signo &lt;code&gt;%&lt;/code&gt; ). Se comprueba la cordura de los 'comandos': deben contener &lt;code&gt;%s&lt;/code&gt; , y la lectura abierta debe terminar con el signo de la tuber&amp;iacute;a, y la escritura abierta debe comenzar con el signo de la tuber&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="2719188c4cf371193166be19d0cfafdbeb67f360" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;%s&lt;/code&gt; is expanded to be the filename (&lt;code&gt;sprintf&lt;/code&gt; is used, so be careful to escape any other &lt;code&gt;%&lt;/code&gt; signs). The 'commands' are checked for sanity - they must contain the &lt;code&gt;%s&lt;/code&gt;, and the read open must end with the pipe sign, and the write open must begin with the pipe sign.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cf6ebcc90a0416e4d456de5b17214b9e0b4a29e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt; , but provide a pointer to this value when the C function is called.</source>
          <target state="translated">El operador &lt;code&gt;&amp;amp;&lt;/code&gt; unario en la secci&amp;oacute;n INPUT: se usa para decirle a &lt;b&gt;xsubpp&lt;/b&gt; que debe convertir un valor Perl a / desde C usando el tipo C a la izquierda de &lt;code&gt;&amp;amp;&lt;/code&gt; , pero proporciona un puntero a este valor cuando se llama a la funci&amp;oacute;n C.</target>
        </trans-unit>
        <trans-unit id="f377db487fb9db0d6201d5c112d20cdac0c1ec99" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;amp;&lt;/code&gt; unary operator in the INPUT: section is used to tell &lt;b&gt;xsubpp&lt;/b&gt; that it should convert a Perl value to/from C using the C type to the left of &lt;code&gt;&amp;amp;&lt;/code&gt;, but provide a pointer to this value when the C function is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0b29d8efcd6e9fd3b54226af4554626aa17bc6d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can also be used on &lt;code&gt;()&lt;/code&gt; groups to force a particular byte-order on all components in that group, including all its subgroups.</source>
          <target state="translated">Los modificadores &lt;code&gt;&amp;gt;&lt;/code&gt; y &lt;code&gt;&amp;lt;&lt;/code&gt; tambi&amp;eacute;n se pueden usar en grupos &lt;code&gt;()&lt;/code&gt; para forzar un orden de bytes particular en todos los componentes de ese grupo, incluidos todos sus subgrupos.</target>
        </trans-unit>
        <trans-unit id="46a36b2037ff10a0c2a8e03718578280ecd8883f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;&lt;/code&gt; modifiers can only be used on floating-point formats on big- or little-endian machines. Otherwise, attempting to use them raises an exception.</source>
          <target state="translated">Los modificadores &lt;code&gt;&amp;gt;&lt;/code&gt; o &lt;code&gt;&amp;lt;&lt;/code&gt; solo se pueden usar en formatos de punto flotante en m&amp;aacute;quinas con big o little-endian. De lo contrario, intentar usarlos genera una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="99da10732816cfac1a93d49f7cb24d6856262342" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator is most often seen in a &lt;code&gt;while&lt;/code&gt; loop:</source>
          <target state="translated">La &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operador se ve m&amp;aacute;s a menudo en un &lt;code&gt;while&lt;/code&gt; bucle:</target>
        </trans-unit>
        <trans-unit id="afce8c3936870dcddae71b2f62bcc6619bb65ebe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt; . People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="translated">El operador &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; realiza una operaci&amp;oacute;n de globbing (ver arriba). En las versiones de Perl anteriores a la v5.6.0, el operador glob () interno bifurca csh (1) para hacer la expansi&amp;oacute;n glob real, pero csh no puede manejar m&amp;aacute;s de 127 elementos y, por lo tanto, muestra el mensaje de error &lt;code&gt;Argument list too long&lt;/code&gt; . Las personas que instalaron tcsh como csh no tendr&amp;aacute;n este problema, pero sus usuarios pueden sorprenderse.</target>
        </trans-unit>
        <trans-unit id="83ef73a269b83405910162deabaede06a6badff3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; operator performs a globbing operation (see above). In Perl versions earlier than v5.6.0, the internal glob() operator forks csh(1) to do the actual glob expansion, but csh can't handle more than 127 items and so gives the error message &lt;code&gt;Argument list too long&lt;/code&gt;. People who installed tcsh as csh won't have this problem, but their users may be surprised by it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6640438652752fb93dc538db26332c2e258075d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt; , will read input from STDIN.</source>
          <target state="translated">El s&amp;iacute;mbolo &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; devolver&amp;aacute; &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; para el final del archivo solo una vez. Si lo vuelve a llamar despu&amp;eacute;s de esto, asumir&amp;aacute; que est&amp;aacute; procesando otra lista &lt;code&gt;@ARGV&lt;/code&gt; , y si no ha configurado &lt;code&gt;@ARGV&lt;/code&gt; , leer&amp;aacute; la entrada de STDIN.</target>
        </trans-unit>
        <trans-unit id="3dc916b5527d8e3b6254129215dab620bcd909c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; symbol will return &lt;code&gt;undef&lt;/code&gt; for end-of-file only once. If you call it again after this, it will assume you are processing another &lt;code&gt;@ARGV&lt;/code&gt; list, and if you haven't set &lt;code&gt;@ARGV&lt;/code&gt;, will read input from STDIN.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb62b601a884f58c8064f8b862089ac2459b0228" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt; ..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; and that</source>
          <target state="translated">El prefijo &lt;code&gt;'I'&lt;/code&gt; se usa durante la creaci&amp;oacute;n de &lt;code&gt;stdin&lt;/code&gt; .. &lt;code&gt;stderr&lt;/code&gt; a trav&amp;eacute;s de llamadas especiales &lt;code&gt;PerlIO_fdopen&lt;/code&gt; ; el prefijo &lt;code&gt;'#'&lt;/code&gt; significa que esto es &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; y que</target>
        </trans-unit>
        <trans-unit id="e4a1e4127c99792fcfccb34fc1ce371d9c5cbbcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'I'&lt;/code&gt; prefix is used during creation of &lt;code&gt;stdin&lt;/code&gt;..&lt;code&gt;stderr&lt;/code&gt; via special &lt;code&gt;PerlIO_fdopen&lt;/code&gt; calls; the &lt;code&gt;'#'&lt;/code&gt; prefix means that this is &lt;code&gt;sysopen&lt;/code&gt; and that</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="039ae207dd483bda31bf76d897310e5b8ac60fad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; key for that missing method. If the experimental &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="translated">La &lt;code&gt;'nomethod'&lt;/code&gt; se usa para especificar una funci&amp;oacute;n catch-all que se llamar&amp;aacute; para cualquier operador que no est&amp;eacute; sobrecargado individualmente. A la funci&amp;oacute;n especificada se le pasar&amp;aacute;n cuatro par&amp;aacute;metros. Los tres primeros argumentos coinciden con los que se habr&amp;iacute;an pasado al m&amp;eacute;todo correspondiente si se hubiera definido. El cuarto argumento es la clave de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; overload&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; para ese m&amp;eacute;todo que falta. Si la caracter&amp;iacute;stica experimental &quot;bit a bit&quot; est&amp;aacute; habilitada (ver &lt;a href=&quot;feature&quot;&gt;caracter&amp;iacute;stica&lt;/a&gt; ), se pasa un quinto argumento TRUE a las subrutinas que manejan &lt;code&gt;&amp;amp;&lt;/code&gt; , &lt;code&gt;|&lt;/code&gt; , &lt;code&gt;^&lt;/code&gt; y &lt;code&gt;~&lt;/code&gt; para indicar que la persona que llama espera un comportamiento num&amp;eacute;rico.</target>
        </trans-unit>
        <trans-unit id="7a25ce7c1bcfa6d33e234b18065c7c24fe6b0cdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;'nomethod'&lt;/code&gt; key is used to specify a catch-all function to be called for any operator that is not individually overloaded. The specified function will be passed four parameters. The first three arguments coincide with those that would have been passed to the corresponding method if it had been defined. The fourth argument is the &lt;code&gt;use overload&lt;/code&gt; key for that missing method. If the &quot;bitwise&quot; feature is enabled (see &lt;a href=&quot;feature&quot;&gt;feature&lt;/a&gt;), a fifth TRUE argument is passed to subroutines handling &lt;code&gt;&amp;amp;&lt;/code&gt;, &lt;code&gt;|&lt;/code&gt;, &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;~&lt;/code&gt; to indicate that the caller is expecting numeric behaviour.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a56ee7f30e7bca1dfc3e81783dadbc2bc19f727f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;(a|b)*&lt;/code&gt; part can match at every char in the string, and then fail every time because there is no &lt;code&gt;z&lt;/code&gt; in the string. So obviously we can avoid using the regex engine unless there is a &lt;code&gt;z&lt;/code&gt; in the string. Likewise in a pattern like:</source>
          <target state="translated">La parte &lt;code&gt;(a|b)*&lt;/code&gt; puede coincidir en cada car&amp;aacute;cter de la cadena y luego fallar cada vez porque no hay &lt;code&gt;z&lt;/code&gt; en la cadena. Entonces, obviamente, podemos evitar usar el motor de expresiones regulares a menos que haya una &lt;code&gt;z&lt;/code&gt; en la cadena. Asimismo en un patr&amp;oacute;n como:</target>
        </trans-unit>
        <trans-unit id="13f6771d5d5f30a227731a56b375d2b66657907c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt; . This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="translated">El archivo &lt;code&gt;*_BS&lt;/code&gt; puede poner algo de c&amp;oacute;digo en el archivo &lt;code&gt;*.bs&lt;/code&gt; generado coloc&amp;aacute;ndolo en &lt;code&gt;$bscode&lt;/code&gt; . Este es un pr&amp;aacute;ctico mecanismo de &quot;escape&quot; que puede resultar &amp;uacute;til en situaciones complejas.</target>
        </trans-unit>
        <trans-unit id="b4a8908910386e1e7fa8ea911939f668d427bb11" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*_BS&lt;/code&gt; file can put some code into the generated &lt;code&gt;*.bs&lt;/code&gt; file by placing it in &lt;code&gt;$bscode&lt;/code&gt;. This is a handy 'escape' mechanism that may prove useful in complex situations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2ecae669ab5e752a1da7ac780070c852f9269859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*foo{THING}&lt;/code&gt; notation can also be used to obtain references to the individual elements of *foo. See &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt;.</source>
          <target state="translated">La notaci&amp;oacute;n &lt;code&gt;*foo{THING}&lt;/code&gt; tambi&amp;eacute;n se puede utilizar para obtener referencias a los elementos individuales de * foo. Ver &lt;a href=&quot;perlref&quot;&gt;perlref&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="255645a7c66228ebcb1a14a341007dcfb97aeb51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;*x = \$y&lt;/code&gt; mechanism may be used to pass and return cheap references into or from subroutines if you don't want to copy the whole thing. It only works when assigning to dynamic variables, not lexicals.</source>
          <target state="translated">El mecanismo &lt;code&gt;*x = \$y&lt;/code&gt; se puede usar para pasar y devolver referencias baratas hacia o desde subrutinas si no desea copiar todo. Solo funciona cuando se asigna a variables din&amp;aacute;micas, no l&amp;eacute;xicas.</target>
        </trans-unit>
        <trans-unit id="fa1621299f61dcb4d1993cf9ac21afe7e26870e3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; form is now obsolete and strongly deprecated.</source>
          <target state="translated">El formulario &lt;code&gt;+&lt;/code&gt; ahora est&amp;aacute; obsoleto y en desuso.</target>
        </trans-unit>
        <trans-unit id="6cc8f120eca26410795cc27186ae2b363ac834f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; prototype is a special alternative to &lt;code&gt;$&lt;/code&gt; that will act like &lt;code&gt;\[@%]&lt;/code&gt; when given a literal array or hash variable, but will otherwise force scalar context on the argument. This is useful for functions which should accept either a literal array or an array reference as the argument:</source>
          <target state="translated">El &lt;code&gt;+&lt;/code&gt; prototipo es una alternativa especial a &lt;code&gt;$&lt;/code&gt; que actuar&amp;aacute; como &lt;code&gt;\[@%]&lt;/code&gt; cuando se le proporcione una matriz literal o una variable hash, pero de lo contrario forzar&amp;aacute; un contexto escalar en el argumento. Esto es &amp;uacute;til para funciones que deber&amp;iacute;an aceptar una matriz literal o una referencia de matriz como argumento:</target>
        </trans-unit>
        <trans-unit id="bb2105637115aa748fce8bf2036dcef89f13282b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; specifier is ignored if the option destination is not a scalar.</source>
          <target state="translated">El especificador &lt;code&gt;+&lt;/code&gt; se ignora si el destino de la opci&amp;oacute;n no es un escalar.</target>
        </trans-unit>
        <trans-unit id="6806c6a2e8d1792a36b6bbc8a8afc151b341b78f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;+&lt;/code&gt; unary operator doesn't do anything in Perl. It exists to avoid syntactic ambiguities.</source>
          <target state="translated">El operador unario &lt;code&gt;+&lt;/code&gt; no hace nada en Perl. Existe para evitar ambig&amp;uuml;edades sint&amp;aacute;cticas.</target>
        </trans-unit>
        <trans-unit id="37675ebea1632ec83c2cb0e9f47bb19d76dac534" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;&lt;/code&gt; syntax is also used when dereferencing a reference. It looks like the same operator, but these are two different operations.</source>
          <target state="translated">La sintaxis &lt;code&gt;-&amp;gt;&lt;/code&gt; tambi&amp;eacute;n se usa cuando se elimina la referencia a una referencia. Parece el mismo operador, pero se trata de dos operaciones diferentes.</target>
        </trans-unit>
        <trans-unit id="d4b0e534108246bac541ccb7068bc25380ccc720" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;-&amp;gt;new()&lt;/code&gt; es un alias para &lt;code&gt;-&amp;gt;create()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7955495872f4b4ea374a5a73bb5908daadd88feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-&amp;gt;new()&lt;/code&gt; method is an alias for &lt;code&gt;-&amp;gt;create()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8192632e359d95a2b8b1baa2f14ef188f64fb3bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--libpods&lt;/code&gt; option is no longer recognized as of Perl 5.26.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="127cc52ec86933168c2c1aece6f9b232d7cd7b7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--rules&lt;/code&gt; option is used to control which tests are run sequentially and which are run in parallel, if the &lt;code&gt;--jobs&lt;/code&gt; option is specified. The option may be specified multiple times, and the order matters.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;--rules&lt;/code&gt; se utiliza para controlar qu&amp;eacute; pruebas se ejecutan secuencialmente y cu&amp;aacute;les se ejecutan en paralelo, si se especifica la opci&amp;oacute;n &lt;code&gt;--jobs&lt;/code&gt; . La opci&amp;oacute;n se puede especificar varias veces y el orden es importante.</target>
        </trans-unit>
        <trans-unit id="608a757f76e2d49976d1abe026a19ab9cb45d134" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch may be used more than once.</source>
          <target state="translated">El &lt;code&gt;--state&lt;/code&gt; interruptor puede ser usado m&amp;aacute;s de una vez.</target>
        </trans-unit>
        <trans-unit id="cc3c8ce0b0c852fbdda4091c52f36592afcdc410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--state&lt;/code&gt; switch requires an argument which must be a comma separated list of one or more of the following options.</source>
          <target state="translated">El &lt;code&gt;--state&lt;/code&gt; requiere un argumento que debe ser una lista separada por comas de una o m&amp;aacute;s de las siguientes opciones.</target>
        </trans-unit>
        <trans-unit id="377dc2d9444ba53f1e07b9f9c8ed4eb80a1854c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;--trap&lt;/code&gt; option will attempt to trap SIGINT (Ctrl-C) during a test run and display the test summary even if the run is interrupted</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;--trap&lt;/code&gt; intentar&amp;aacute; atrapar SIGINT (Ctrl-C) durante una ejecuci&amp;oacute;n de prueba y mostrar&amp;aacute; el resumen de la prueba incluso si la ejecuci&amp;oacute;n se interrumpe</target>
        </trans-unit>
        <trans-unit id="e392f25b1c4fe3943f476468712579d620408f6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; command line switch</source>
          <target state="translated">El interruptor de l&amp;iacute;nea de comando &lt;code&gt;-A&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="eb91ceec65f320f24de6ea1ba97059dfa04bc1be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;-X&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--use-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="597b9a9c8e6ccba33470cbc78977519edc52f8e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-A&lt;/code&gt; omits the Autoloader code, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; omits XS elements, &lt;code&gt;--skip-exporter&lt;/code&gt; omits the Exporter code, &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; sets up a modern testing environment, and &lt;code&gt;-n&lt;/code&gt; specifies the name of the module.</source>
          <target state="translated">Los &lt;code&gt;-A&lt;/code&gt; omite el c&amp;oacute;digo del cargador autom&amp;aacute;tico, &lt;code&gt;&lt;a href=&quot;functions/-x&quot;&gt;-X&lt;/a&gt;&lt;/code&gt; elementos XS omite, &lt;code&gt;--skip-exporter&lt;/code&gt; omite el c&amp;oacute;digo de exportador, &lt;code&gt;--&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt;-new-tests&lt;/code&gt; establece un entorno de prueba moderna, y &lt;code&gt;-n&lt;/code&gt; especifica el nombre del m&amp;oacute;dulo.</target>
        </trans-unit>
        <trans-unit id="c623c1943d0dabf76760d7670756f1a93a94f39a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt; ). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="translated">El &lt;code&gt;-Dusecbacktrace&lt;/code&gt; tambi&amp;eacute;n permite mantener la informaci&amp;oacute;n de depuraci&amp;oacute;n al compilar / enlazar (a menudo: &lt;code&gt;-g&lt;/code&gt; ). Muchos compiladores / enlazadores admiten la optimizaci&amp;oacute;n y el mantenimiento de la informaci&amp;oacute;n de depuraci&amp;oacute;n. La informaci&amp;oacute;n de depuraci&amp;oacute;n es necesaria para los nombres de los s&amp;iacute;mbolos y las ubicaciones de origen.</target>
        </trans-unit>
        <trans-unit id="82d0f491a8ddd8c808b16ec9be7ca117f4caf1b7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Dusecbacktrace&lt;/code&gt; also enables keeping the debug information when compiling/linking (often: &lt;code&gt;-g&lt;/code&gt;). Many compilers/linkers do support having both optimization and keeping the debug information. The debug information is needed for the symbol names and the source locations.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="63378b07c96f9b709eea4a8451598ec112926512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;../perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">Los interruptores &lt;code&gt;-T&lt;/code&gt; y &lt;code&gt;-B&lt;/code&gt; funcionan de la siguiente manera. Se examina el primer bloque del archivo para ver si es UTF-8 v&amp;aacute;lido que incluye caracteres que no son ASCII. Si, entonces es un archivo &lt;code&gt;-T&lt;/code&gt; . De lo contrario, esa misma parte del archivo se examina en busca de caracteres extra&amp;ntilde;os, como c&amp;oacute;digos de control extra&amp;ntilde;os o caracteres con el bit alto establecido. Si m&amp;aacute;s de un tercio de los caracteres son extra&amp;ntilde;os, es un archivo &lt;code&gt;-B&lt;/code&gt; ; de lo contrario, es un archivo &lt;code&gt;-T&lt;/code&gt; . Adem&amp;aacute;s, cualquier archivo que contenga un byte cero en la parte examinada se considera un archivo binario. (Si se ejecuta dentro del alcance de una &lt;a href=&quot;../perllocale&quot;&gt;configuraci&amp;oacute;n regional de uso&lt;/a&gt; que incluye &lt;code&gt;LC_CTYPE&lt;/code&gt; , los caracteres impares son cualquier cosa que no sea imprimible ni espacio en la configuraci&amp;oacute;n regional actual). &lt;code&gt;-T&lt;/code&gt; o &lt;code&gt;-B&lt;/code&gt; se usa en un identificador de archivo, se examina el b&amp;uacute;fer de E / S actual en lugar del primer bloque. Tanto &lt;code&gt;-T&lt;/code&gt; como &lt;code&gt;-B&lt;/code&gt; devuelven verdadero en un archivo vac&amp;iacute;o o en un archivo en EOF cuando se prueba un identificador de archivo. Debido a que debe leer un archivo para hacer la prueba &lt;code&gt;-T&lt;/code&gt; , en la mayor&amp;iacute;a de las ocasiones desea usar una &lt;code&gt;-f&lt;/code&gt; contra el archivo primero, como en el &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="c91ca83f347b61a13eb65089f07047ddb67d9622" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; switches work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If, so it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt; , odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</source>
          <target state="translated">Los interruptores &lt;code&gt;-T&lt;/code&gt; y &lt;code&gt;-B&lt;/code&gt; funcionan de la siguiente manera. Se examina el primer bloque del archivo para ver si es UTF-8 v&amp;aacute;lido que incluye caracteres que no son ASCII. Si, entonces es un archivo &lt;code&gt;-T&lt;/code&gt; . De lo contrario, esa misma parte del archivo se examina en busca de caracteres extra&amp;ntilde;os, como c&amp;oacute;digos de control extra&amp;ntilde;os o caracteres con el bit alto establecido. Si m&amp;aacute;s de un tercio de los caracteres son extra&amp;ntilde;os, es un archivo &lt;code&gt;-B&lt;/code&gt; ; de lo contrario, es un archivo &lt;code&gt;-T&lt;/code&gt; . Adem&amp;aacute;s, cualquier archivo que contenga un byte cero en la parte examinada se considera un archivo binario. (Si se ejecuta dentro del alcance de una &lt;a href=&quot;perllocale&quot;&gt;configuraci&amp;oacute;n regional de uso&lt;/a&gt; que incluye &lt;code&gt;LC_CTYPE&lt;/code&gt; , los caracteres impares son cualquier cosa que no sea imprimible ni espacio en la configuraci&amp;oacute;n regional actual). &lt;code&gt;-T&lt;/code&gt; o &lt;code&gt;-B&lt;/code&gt; se usa en un identificador de archivo, se examina el b&amp;uacute;fer de E / S actual en lugar del primer bloque. Tanto &lt;code&gt;-T&lt;/code&gt; como &lt;code&gt;-B&lt;/code&gt; devuelven verdadero en un archivo vac&amp;iacute;o o en un archivo en EOF cuando se prueba un identificador de archivo. Debido a que debe leer un archivo para hacer la prueba &lt;code&gt;-T&lt;/code&gt; , en la mayor&amp;iacute;a de las ocasiones desea usar una &lt;code&gt;-f&lt;/code&gt; contra el archivo primero, como en el &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt; unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="7d03161bfdc601bdcaa9b51890ed40d35154d9a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; tests work as follows. The first block or so of the file is examined to see if it is valid UTF-8 that includes non-ASCII characters. If so, it's a &lt;code&gt;-T&lt;/code&gt; file. Otherwise, that same portion of the file is examined for odd characters such as strange control codes or characters with the high bit set. If more than a third of the characters are strange, it's a &lt;code&gt;-B&lt;/code&gt; file; otherwise it's a &lt;code&gt;-T&lt;/code&gt; file. Also, any file containing a zero byte in the examined portion is considered a binary file. (If executed within the scope of a &lt;a href=&quot;perllocale&quot;&gt;use locale&lt;/a&gt; which includes &lt;code&gt;LC_CTYPE&lt;/code&gt;, odd characters are anything that isn't a printable nor space in the current locale.) If &lt;code&gt;-T&lt;/code&gt; or &lt;code&gt;-B&lt;/code&gt; is used on a filehandle, the current IO buffer is examined rather than the first block. Both &lt;code&gt;-T&lt;/code&gt; and &lt;code&gt;-B&lt;/code&gt; return true on an empty file, or a file at EOF when testing a filehandle. Because you have to read a file to do the &lt;code&gt;-T&lt;/code&gt; test, on most occasions you want to use a &lt;code&gt;-f&lt;/code&gt; against the file first, as in &lt;code&gt;next unless -f $file &amp;amp;&amp;amp; -T $file&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9bc0f3fa215c39800076a942f11672815853d1f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wall&lt;/code&gt; is by default on.</source>
          <target state="translated">El &lt;code&gt;-Wall&lt;/code&gt; es por defecto en.</target>
        </trans-unit>
        <trans-unit id="6dfbaa82d695de76db5a43cbdf063e4ffac5d9ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-Wtraditional&lt;/code&gt; is another example of the annoying tendency of gcc to bundle a lot of warnings under one switch (it would be impossible to deploy in practice because it would complain a lot) but it does contain some warnings that would be beneficial to have available on their own, such as the warning about string constants inside macros containing the macro arguments: this behaved differently pre-ANSI than it does in ANSI, and some C compilers are still in transition, AIX being an example.</source>
          <target state="translated">El &lt;code&gt;-Wtraditional&lt;/code&gt; es otro ejemplo de la molesta tendencia de gcc a agrupar muchas advertencias en un solo interruptor (ser&amp;iacute;a imposible implementarlo en la pr&amp;aacute;ctica porque se quejar&amp;iacute;a mucho) pero contiene algunas advertencias que ser&amp;iacute;a beneficioso tener disponibles por s&amp;iacute; mismos, como la advertencia sobre las constantes de cadena dentro de las macros que contienen los argumentos de la macro: esto se comport&amp;oacute; de manera diferente antes de ANSI que en ANSI, y algunos compiladores de C todav&amp;iacute;a est&amp;aacute;n en transici&amp;oacute;n, siendo AIX un ejemplo.</target>
        </trans-unit>
        <trans-unit id="29f275b0f904c074e809dc11f6813898aaca641a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-a&lt;/code&gt; option is used to include all files that git tracks that you have changed. If at this time, you only want to commit some of the files you have worked on, you can omit the &lt;code&gt;-a&lt;/code&gt; and use the command &lt;code&gt;git add &lt;i&gt;FILE ...&lt;/i&gt;&lt;/code&gt; before doing the commit. &lt;code&gt;git add --interactive&lt;/code&gt; allows you to even just commit portions of files instead of all the changes in them.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dea68b3a7d6bdc421299da6629ccc22d6bd7b572" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt; ) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="translated">El &lt;code&gt;-ansi&lt;/code&gt; (y su compa&amp;ntilde;ero, el &lt;code&gt;-pedantic&lt;/code&gt; ) ser&amp;iacute;a bueno para estar en siempre, pero por desgracia no son seguros en todas las plataformas, que pueden por ejemplo provocar conflictos fatales con las cabeceras del sistema (Solaris es un buen ejemplo). Si se utiliza Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; , la interfaz de &lt;code&gt;cflags&lt;/code&gt; selecciona &lt;code&gt;-ansi -pedantic&lt;/code&gt; para las plataformas en las que se sabe que son seguras.</target>
        </trans-unit>
        <trans-unit id="3c0974d53dc0e4835c4ef757f3690c3874414b6a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-ansi&lt;/code&gt; (and its sidekick, &lt;code&gt;-pedantic&lt;/code&gt;) would be nice to be on always, but unfortunately they are not safe on all platforms, they can for example cause fatal conflicts with the system headers (Solaris being a prime example). If Configure &lt;code&gt;-Dgccansipedantic&lt;/code&gt; is used, the &lt;code&gt;cflags&lt;/code&gt; frontend selects &lt;code&gt;-ansi -pedantic&lt;/code&gt; for the platforms where they are known to be safe.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cb94d9f2c59455332a30530ef3be81c2f437b975" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-h&lt;/code&gt; option will show a usage message.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;-h&lt;/code&gt; mostrar&amp;aacute; un mensaje de uso.</target>
        </trans-unit>
        <trans-unit id="2bf6b5a2450e550c35673777465af352e8fad7fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-m&lt;/code&gt; option is used to specify the commit message. If you omit it, git will open a text editor for you to compose the message interactively. This is useful when the changes are more complex than the sample given here, and, depending on the editor, to know that the first line of the commit message doesn't exceed the 50 character legal maximum. See &lt;a href=&quot;perlhack#Commit-message&quot;&gt;&quot;Commit message&quot; in perlhack&lt;/a&gt; for more information about what makes a good commit message.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="02d034bd54a852b799ddb0bca00601006bc9ad62" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-newlex&lt;/code&gt; option produces a more readable &lt;code&gt;name =&amp;gt; value&lt;/code&gt; format, and is shown in the second example above.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;-newlex&lt;/code&gt; produce un formato &lt;code&gt;name =&amp;gt; value&lt;/code&gt; m&amp;aacute;s legible , y se muestra en el segundo ejemplo anterior.</target>
        </trans-unit>
        <trans-unit id="3ed7e26de1fd10b827d09512227b49a4f8d06d08" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-nosp&lt;/code&gt; option eliminates reporting of SPECIALs, such as &lt;code&gt;0: SPECIAL
#1 &amp;amp;PL_sv_undef&lt;/code&gt; above. Reporting of SPECIALs can sometimes overwhelm your declared lexicals.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;-nosp&lt;/code&gt; elimina los informes de SPECIALs, como &lt;code&gt;0: SPECIAL #1 &amp;amp;PL_sv_undef&lt;/code&gt; arriba. Informar sobre SPECIAL a veces puede abrumar los l&amp;eacute;xicos declarados.</target>
        </trans-unit>
        <trans-unit id="063586d44811e787a3acc7fa9925ec22a0e1ef32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-pretty&lt;/code&gt; directive is called too late to affect matters. You have to do this instead, and</source>
          <target state="translated">La directiva &lt;code&gt;-pretty&lt;/code&gt; se llama demasiado tarde para afectar las cosas. Tienes que hacer esto en su lugar, y</target>
        </trans-unit>
        <trans-unit id="64b5e1fcc02dcf849bd221c8c257f81fb47b92a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</source>
          <target state="translated">Las opciones &lt;code&gt;-q&lt;/code&gt; y &lt;code&gt;-qq&lt;/code&gt; no funcionan correctamente si perl no se compila con el soporte de PerlIO: STDOUT se cerrar&amp;aacute; en lugar de ser redirigido a &lt;code&gt;$O::BEGIN_output&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="29496d6f7bd6b984673c9ef63d5a96a39bc5fbb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-q&lt;/code&gt; and &lt;code&gt;-qq&lt;/code&gt; options don't work correctly if perl isn't compiled with PerlIO support : STDOUT will be closed instead of being redirected to &lt;code&gt;$O::BEGIN_output&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6261ab8564541d33e35c7ac1e97aa8a5e571dd14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-qq&lt;/code&gt; option behaves like &lt;code&gt;-q&lt;/code&gt;, except that it also closes STDERR after deparsing has finished. This suppresses the &quot;Syntax OK&quot; message normally produced by perl.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;-qq&lt;/code&gt; se comporta como &lt;code&gt;-q&lt;/code&gt; , excepto que tambi&amp;eacute;n cierra STDERR una vez finalizado el deparsing. Esto suprime el mensaje &quot;Sintaxis correcta&quot; normalmente producido por perl.</target>
        </trans-unit>
        <trans-unit id="cb173d8eff47f06c7e37f7374c7227453a2ad4d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;-u&lt;/code&gt; switch causes the VMS debugger to be invoked after the Perl program is compiled, but before it has run. It does not create a core dump file.</source>
          <target state="translated">El &lt;code&gt;-u&lt;/code&gt; hace que se invoque el depurador VMS despu&amp;eacute;s de que se compile el programa Perl, pero antes de que se ejecute. No crea un archivo de volcado de n&amp;uacute;cleo.</target>
        </trans-unit>
        <trans-unit id="1e542d84460c8b59074b5a3d74792d84cf2329fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; and &lt;code&gt;...&lt;/code&gt; flip-flop operators. Note that the &lt;code&gt;...&lt;/code&gt; flip-flop operator is completely different from the &lt;code&gt;...&lt;/code&gt; elliptical statement just described.</source>
          <target state="translated">Los operadores &lt;code&gt;..&lt;/code&gt; y &lt;code&gt;...&lt;/code&gt; flip-flop. Tenga en cuenta que el operador &lt;code&gt;...&lt;/code&gt; flip-flop es completamente diferente de la declaraci&amp;oacute;n &lt;code&gt;...&lt;/code&gt; el&amp;iacute;ptica que se acaba de describir.</target>
        </trans-unit>
        <trans-unit id="8189082aec1c35ce34b10a2a482272d1f9442cdd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;..&lt;/code&gt; range operator treats certain character ranges with care on EBCDIC platforms. For example the following array will have twenty six elements on either an EBCDIC platform or an ASCII platform:</source>
          <target state="translated">El operador &lt;code&gt;..&lt;/code&gt; range trata ciertos rangos de caracteres con cuidado en las plataformas EBCDIC. Por ejemplo, la siguiente matriz tendr&amp;aacute; veintis&amp;eacute;is elementos en una plataforma EBCDIC o una plataforma ASCII:</target>
        </trans-unit>
        <trans-unit id="1bfc1b4066699d36e1a1c96b8bf42e5d376ee7e9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//&lt;/code&gt; matching operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;. It operates on &lt;code&gt;$_&lt;/code&gt; by default, or can be bound to another variable using the &lt;code&gt;=~&lt;/code&gt; binding operator (also documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;).</source>
          <target state="translated">El &lt;code&gt;//&lt;/code&gt; operador coincidente est&amp;aacute; documentado en &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; . Opera en &lt;code&gt;$_&lt;/code&gt; por defecto, o se puede vincular a otra variable usando el operador de vinculaci&amp;oacute;n &lt;code&gt;=~&lt;/code&gt; (tambi&amp;eacute;n documentado en &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="32ef826cb43c384876c66cdfd8ef3d6094273ed3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;//a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of \d, \s, and \w to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;//aa&lt;/code&gt; , to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="translated">El modificador &lt;code&gt;//a&lt;/code&gt; , disponible a partir de Perl 5.14, se usa para restringir las coincidencias de \ d, \ s y \ w solo en el rango ASCII. Es &amp;uacute;til evitar que su programa se exponga innecesariamente a Unicode completo (y las consideraciones de seguridad que lo acompa&amp;ntilde;an) cuando todo lo que desea es procesar texto similar al ingl&amp;eacute;s. (La &quot;a&quot; se puede duplicar, &lt;code&gt;//aa&lt;/code&gt; , para proporcionar a&amp;uacute;n m&amp;aacute;s restricciones, evitando la coincidencia entre may&amp;uacute;sculas y min&amp;uacute;sculas de ASCII con caracteres no ASCII; de lo contrario, un &quot;signo Kelvin&quot; Unicode coincidir&amp;iacute;a sin may&amp;uacute;sculas con una &quot;k&quot; o &quot;K&quot; .)</target>
        </trans-unit>
        <trans-unit id="4d28a339cbae1f464fa994976dfeef2db93a1d7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/&lt;/code&gt; template character allows packing and unpacking of a sequence of items where the packed structure contains a packed item count followed by the packed items themselves. This is useful when the structure you're unpacking has encoded the sizes or repeat counts for some of its fields within the structure itself as separate fields.</source>
          <target state="translated">El car&amp;aacute;cter &lt;code&gt;/&lt;/code&gt; plantilla permite empaquetar y desempacar una secuencia de art&amp;iacute;culos donde la estructura empaquetada contiene un recuento de art&amp;iacute;culos empacados seguido de los propios art&amp;iacute;culos empacados. Esto es &amp;uacute;til cuando la estructura que est&amp;aacute; desempaquetando ha codificado los tama&amp;ntilde;os o los recuentos repetidos para algunos de sus campos dentro de la estructura misma como campos separados.</target>
        </trans-unit>
        <trans-unit id="11f550725d5f2471c6ff447b2d5f1594f1eb63d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, available starting in Perl 5.14, is used to restrict the matches of &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt;, and &lt;code&gt;\w&lt;/code&gt; to just those in the ASCII range. It is useful to keep your program from being needlessly exposed to full Unicode (and its accompanying security considerations) when all you want is to process English-like text. (The &quot;a&quot; may be doubled, &lt;code&gt;/aa&lt;/code&gt;, to provide even more restrictions, preventing case-insensitive matching of ASCII with non-ASCII characters; otherwise a Unicode &quot;Kelvin Sign&quot; would caselessly match a &quot;k&quot; or &quot;K&quot;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8377a1a6991c29f230dc12ce290846f6b362ebc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt; modifier, on the other hand, may be useful. Its purpose is to allow code that is to work mostly on ASCII data to not have to concern itself with Unicode.</source>
          <target state="translated">El modificador &lt;code&gt;/a&lt;/code&gt; , por otro lado, puede ser &amp;uacute;til. Su prop&amp;oacute;sito es permitir que el c&amp;oacute;digo que funciona principalmente con datos ASCII no tenga que preocuparse por Unicode.</target>
        </trans-unit>
        <trans-unit id="4128278fcab003f758fd62a9e37cfc1e76abe115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/a&lt;/code&gt;, &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/l&lt;/code&gt;, and &lt;code&gt;/u&lt;/code&gt; modifiers (added in Perl 5.14) control the character set rules, but &lt;code&gt;/a&lt;/code&gt; is the only one you are likely to want to specify explicitly; the other three are selected automatically by various pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d46362c6dee371fc1e41d5a94fbe9c509a82363" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt; , and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="translated">Es probable que los modificadores &lt;code&gt;/d&lt;/code&gt; , &lt;code&gt;/u&lt;/code&gt; y &lt;code&gt;/l&lt;/code&gt; no le sean de mucha utilidad, por lo que no debe preocuparse mucho por ellos. Existen para el uso interno de Perl, de modo que las estructuras de datos de expresiones regulares complejas se pueden serializar autom&amp;aacute;ticamente y luego reconstituir exactamente, incluidos todos sus matices. Pero, dado que Perl no puede guardar un secreto, y puede haber casos raros en los que sean &amp;uacute;tiles, se documentan aqu&amp;iacute;.</target>
        </trans-unit>
        <trans-unit id="12ab225e2a1f0826b5de7058218cdd1f025dae16" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/d&lt;/code&gt;, &lt;code&gt;/u&lt;/code&gt;, and &lt;code&gt;/l&lt;/code&gt; modifiers are not likely to be of much use to you, and so you need not worry about them very much. They exist for Perl's internal use, so that complex regular expression data structures can be automatically serialized and later exactly reconstituted, including all their nuances. But, since Perl can't keep a secret, and there may be rare instances where they are useful, they are documented here.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7a635bd3deb5f6d1f8ced7e30d0ca4af436ee119" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt; , perhaps something like &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; , then I could get myself in trouble.</source>
          <target state="translated">La &lt;code&gt;/e&lt;/code&gt; tambi&amp;eacute;n ignorar&amp;aacute; silenciosamente las violaciones de estricto, reemplazando los nombres de variables indefinidos con la cadena vac&amp;iacute;a. Como estoy usando el indicador &lt;code&gt;/e&lt;/code&gt; (&amp;iexcl;dos veces incluso!), Tengo todos los mismos problemas de seguridad que tengo con &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; en su forma de cadena. Si hay algo extra&amp;ntilde;o en &lt;code&gt;$foo&lt;/code&gt; , tal vez algo como &lt;code&gt;@{[ &lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt; &quot;rm -rf /&quot; ]}&lt;/code&gt; , entonces podr&amp;iacute;a meterme en problemas.</target>
        </trans-unit>
        <trans-unit id="b81362cf7da8bf9fa9ba69433decc106d6e660e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/e&lt;/code&gt; will also silently ignore violations of strict, replacing undefined variable names with the empty string. Since I'm using the &lt;code&gt;/e&lt;/code&gt; flag (twice even!), I have all of the same security problems I have with &lt;code&gt;eval&lt;/code&gt; in its string form. If there's something odd in &lt;code&gt;$foo&lt;/code&gt;, perhaps something like &lt;code&gt;@{[ system &quot;rm -rf /&quot; ]}&lt;/code&gt;, then I could get myself in trouble.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="613bcc3a2284ecc4926054a5b934f30e880d5007" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/g&lt;/code&gt; modifier specifies global pattern matching--that is, matching as many times as possible within the string. How it behaves depends on the context. In list context, it returns a list of the substrings matched by any capturing parentheses in the regular expression. If there are no parentheses, it returns a list of all the matched strings, as if there were parentheses around the whole pattern.</source>
          <target state="translated">El modificador &lt;code&gt;/g&lt;/code&gt; especifica la coincidencia de patrones global, es decir, la coincidencia tantas veces como sea posible dentro de la cadena. C&amp;oacute;mo se comporta depende del contexto. En el contexto de la lista, devuelve una lista de las subcadenas que coinciden con cualquier par&amp;eacute;ntesis de captura en la expresi&amp;oacute;n regular. Si no hay par&amp;eacute;ntesis, devuelve una lista de todas las cadenas coincidentes, como si hubiera par&amp;eacute;ntesis alrededor de todo el patr&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="987314591903795033c1fec25347d7b594aec577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas give consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="translated">El &lt;code&gt;/l&lt;/code&gt; y &lt;code&gt;/u&lt;/code&gt; modificadores se seleccionan autom&amp;aacute;ticamente para expresiones regulares compiladas en el marco de diversos pragmas, y recomendamos que, en general, se utiliza esas pragmas en lugar de especificar estos modificadores de forma expl&amp;iacute;cita. Por un lado, los modificadores afectan solo la coincidencia de patrones y no se extienden ni siquiera a ning&amp;uacute;n reemplazo realizado, mientras que el uso de pragmas proporciona resultados consistentes para todas las operaciones apropiadas dentro de sus alcances. Por ejemplo,</target>
        </trans-unit>
        <trans-unit id="2a3e23c2d6681fc3d86e431f129513cbcb6ae252" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/l&lt;/code&gt; and &lt;code&gt;/u&lt;/code&gt; modifiers are automatically selected for regular expressions compiled within the scope of various pragmas, and we recommend that in general, you use those pragmas instead of specifying these modifiers explicitly. For one thing, the modifiers affect only pattern matching, and do not extend to even any replacement done, whereas using the pragmas gives consistent results for all appropriate operations within their scopes. For example,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a222e38b5a40a1bf140094ce44f5b0c1b82a0ec" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/o&lt;/code&gt; option for regular expressions (documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; and &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt;) tells Perl to compile the regular expression only once. This is only useful when the pattern contains a variable. Perls 5.6 and later handle this automatically if the pattern does not change.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;/o&lt;/code&gt; para expresiones regulares (documentada en &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; y &lt;a href=&quot;perlreref&quot;&gt;perlreref&lt;/a&gt; ) le dice a Perl que compile la expresi&amp;oacute;n regular solo una vez. Esto solo es &amp;uacute;til cuando el patr&amp;oacute;n contiene una variable. Perls 5.6 y posteriores manejan esto autom&amp;aacute;ticamente si el patr&amp;oacute;n no cambia.</target>
        </trans-unit>
        <trans-unit id="02f1967b4475720a962bf35cfc3049c63165e0f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;/x&lt;/code&gt; modifier causes whitespace to be ignored in a regex pattern (except in a character class and a few other places), and also allows you to use normal comments there, too. As you can imagine, whitespace and comments help a lot.</source>
          <target state="translated">El modificador &lt;code&gt;/x&lt;/code&gt; hace que los espacios en blanco se ignoren en un patr&amp;oacute;n de expresiones regulares (excepto en una clase de caracteres y algunos otros lugares), y tambi&amp;eacute;n le permite usar comentarios normales all&amp;iacute;. Como puede imaginar, los espacios en blanco y los comentarios ayudan mucho.</target>
        </trans-unit>
        <trans-unit id="26a965e97d532904de76cbb5ec7fa62c78040c70" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;0x&lt;/code&gt; prefix means a hexadecimal number, the digits are 0-9</source>
          <target state="translated">El prefijo &lt;code&gt;0x&lt;/code&gt; significa un n&amp;uacute;mero hexadecimal, los d&amp;iacute;gitos son 0-9</target>
        </trans-unit>
        <trans-unit id="c084ffd08879b68d48b86f14b0edd6d007fd471f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt; . It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="translated">La etiqueta &lt;code&gt;:&lt;a href=&quot;../functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; , ahora desaconsejada, es la versi&amp;oacute;n anterior de &lt;code&gt;:bsd_glob&lt;/code&gt; . Exporta las mismas constantes y funciones, pero su anulaci&amp;oacute;n glob () no admite la iteraci&amp;oacute;n; devuelve el &amp;uacute;ltimo nombre de archivo en contexto escalar. Eso significa que esto se repetir&amp;aacute; para siempre:</target>
        </trans-unit>
        <trans-unit id="4231c54d461bf5e25a3f991c3ecf987daad7c115" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:ALL&lt;/code&gt; tag will get all of the above exports.</source>
          <target state="translated">La etiqueta &lt;code&gt;:ALL&lt;/code&gt; obtendr&amp;aacute; todas las exportaciones anteriores.</target>
        </trans-unit>
        <trans-unit id="f4ffb1e41b5af144e1e66d6009daba34fcfe78d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bsd_glob&lt;/code&gt; export tag exports bsd_glob() and the constants listed below. It also overrides glob() in the calling package with one that behaves like bsd_glob() with regard to spaces (the space is treated as part of a file name), but supports iteration in scalar context; i.e., it preserves the core function's feature of returning the next item each time it is called.</source>
          <target state="translated">La etiqueta de exportaci&amp;oacute;n &lt;code&gt;:bsd_glob&lt;/code&gt; exporta bsd_glob () y las constantes enumeradas a continuaci&amp;oacute;n. Tambi&amp;eacute;n anula glob () en el paquete de llamada con uno que se comporta como bsd_glob () con respecto a los espacios (el espacio se trata como parte de un nombre de archivo), pero admite la iteraci&amp;oacute;n en contexto escalar; es decir, conserva la caracter&amp;iacute;stica de la funci&amp;oacute;n principal de devolver el siguiente elemento cada vez que se llama.</target>
        </trans-unit>
        <trans-unit id="e5933b7ecdff0d26d0d1ee137373273e087ab3ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , and any other directives of the form &lt;code&gt;:...&lt;/code&gt; , are called I/O</source>
          <target state="translated">Los &lt;code&gt;:bytes&lt;/code&gt; , &lt;code&gt;:crlf&lt;/code&gt; , &lt;code&gt;:utf8&lt;/code&gt; , y cualquier otra directiva de la forma &lt;code&gt;:...&lt;/code&gt; , se denominan E / S</target>
        </trans-unit>
        <trans-unit id="586c160f0002e3dc300faf81c49d6dc770a315b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt; layer corresponds to &quot;binary mode&quot; and the &lt;code&gt;:crlf&lt;/code&gt; layer corresponds to &quot;text mode&quot; on platforms that distinguish between the two modes when opening files (which is many DOS-like platforms, including Windows). These two layers are no-ops on platforms where binmode() is a no-op, but perform their functions everywhere if PerlIO is enabled.</source>
          <target state="translated">La capa &lt;code&gt;:bytes&lt;/code&gt; corresponde al &quot;modo binario&quot; y la capa &lt;code&gt;:crlf&lt;/code&gt; corresponde al &quot;modo texto&quot; en plataformas que distinguen entre los dos modos al abrir archivos (que es muchas plataformas similares a DOS, incluida Windows). Estas dos capas son no operativas en plataformas donde binmode () es una no operativa, pero realizan sus funciones en todas partes si PerlIO est&amp;aacute; habilitado.</target>
        </trans-unit>
        <trans-unit id="11a84ca57962b97df10238d25c4ab7c8ca38ba9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:bytes&lt;/code&gt;, &lt;code&gt;:crlf&lt;/code&gt;, &lt;code&gt;:utf8&lt;/code&gt;, and any other directives of the form &lt;code&gt;:...&lt;/code&gt;, are called I/O</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec6da40dddc20e97c2aa930b3dff507bcb27589f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; declaration.</source>
          <target state="translated">El paquete &lt;code&gt;:default&lt;/code&gt; representa el conjunto de caracter&amp;iacute;sticas que est&amp;aacute; habilitado antes de cualquier &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; feature&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; o &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; feature&lt;/code&gt; declaraci&amp;oacute;n de caracter&amp;iacute;stica .</target>
        </trans-unit>
        <trans-unit id="09364c3e01a418de2009247f52456634c275c2f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:default&lt;/code&gt; bundle represents the feature set that is enabled before any &lt;code&gt;use feature&lt;/code&gt; or &lt;code&gt;no feature&lt;/code&gt; declaration.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="229b3ff64bd12a209b4e991d14388add7cc976a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:glob&lt;/code&gt; tag, now discouraged, is the old version of &lt;code&gt;:bsd_glob&lt;/code&gt;. It exports the same constants and functions, but its glob() override does not support iteration; it returns the last file name in scalar context. That means this will loop forever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a790449d8cd7160d313e0f6fd7d2b5f5cd711410" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one boolean argument.</source>
          <target state="translated">El &lt;code&gt;:gzip_external&lt;/code&gt; requiere un argumento booleano.</target>
        </trans-unit>
        <trans-unit id="bc95aee8e2b941e818640ac51c8f3c3052958780" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_external&lt;/code&gt; requires one string argument.</source>
          <target state="translated">El &lt;code&gt;:gzip_external&lt;/code&gt; requiere un argumento de cadena.</target>
        </trans-unit>
        <trans-unit id="d6ef1d12b23a99b06dce59bf86591d40b628073e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;USING THE EXTERNAL GZIP&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="20c0f5f557ffbe0666f0dfcd916d2b61a638ef52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_read_open&lt;/code&gt; argument must end with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">El argumento &lt;code&gt;:gzip_read_open&lt;/code&gt; debe terminar con el signo de tuber&amp;iacute;a (|) y tener &lt;code&gt;%s&lt;/code&gt; como nombre de archivo. Consulte &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USO DEL GZIP EXTERNO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="c09f18a82aa110a317c88049c0e7c4128399d22c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;&quot;USING THE EXTERNAL GZIP&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="740fe127c4ced02d559ebb2a859c745ac796eb7c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:gzip_write_open&lt;/code&gt; argument must begin with the pipe sign (|) and have the &lt;code&gt;%s&lt;/code&gt; for the filename. An output redirect (&amp;gt;) is also often a good idea, depending on your operating system shell syntax. See &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USING THE EXTERNAL GZIP&lt;/a&gt;.</source>
          <target state="translated">El argumento &lt;code&gt;:gzip_write_open&lt;/code&gt; debe comenzar con el signo de tuber&amp;iacute;a (|) y tener &lt;code&gt;%s&lt;/code&gt; como nombre de archivo. Una redirecci&amp;oacute;n de salida (&amp;gt;) tambi&amp;eacute;n suele ser una buena idea, dependiendo de la sintaxis de shell de su sistema operativo. Consulte &lt;a href=&quot;#USING-THE-EXTERNAL-GZIP&quot;&gt;USO DEL GZIP EXTERNO&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="244205effe1c86456dd4171100ec82efbb0324f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, only with the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt;, and the &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma.</source>
          <target state="translated">El &lt;code&gt;:locale&lt;/code&gt; no funciona actualmente con &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; , solo con el pragma &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; . Los &lt;code&gt;:utf8&lt;/code&gt; y &lt;code&gt;:encoding(...)&lt;/code&gt; funcionan con todos los m&amp;eacute;todos &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma.</target>
        </trans-unit>
        <trans-unit id="868d235ace169d2c7fa342c5a97f5b35d506dd95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; does not currently work with &lt;code&gt;open()&lt;/code&gt; and &lt;code&gt;binmode()&lt;/code&gt;, only with the &lt;code&gt;open&lt;/code&gt; pragma. The &lt;code&gt;:utf8&lt;/code&gt; and &lt;code&gt;:encoding(...)&lt;/code&gt; methods do work with all of &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;binmode()&lt;/code&gt;, and the &lt;code&gt;open&lt;/code&gt; pragma.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0a7c262fbc0be9a9844fe48c62a845c0f4528fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:locale&lt;/code&gt; sub-pragma</source>
          <target state="translated">El &lt;code&gt;:locale&lt;/code&gt; sub-pragma</target>
        </trans-unit>
        <trans-unit id="90148b6fce0bbabdeb9d2a0e71e782bdff20ba4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt; .</source>
          <target state="translated">La capa &lt;code&gt;:mmap&lt;/code&gt; no existir&amp;aacute; si la plataforma no es compatible con &lt;code&gt;mmap()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="81e4222eb657623bdd73dc5a2ea005b2d704479c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:mmap&lt;/code&gt; layer will not exist if the platform does not support &lt;code&gt;mmap()&lt;/code&gt;. See &lt;a href=&quot;PerlIO::mmap&quot;&gt;PerlIO::mmap&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd944a87b4f64134b2d5190fde7ca74a27bd05a6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; layer is</source>
          <target state="translated">La &lt;code&gt;:raw&lt;/code&gt; capa cruda es</target>
        </trans-unit>
        <trans-unit id="9474a45f1b69ac0f4649940b34d53df78423a114" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:raw&lt;/code&gt; pseudo-layer is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eb8af45fe08808536fe0e78893d59ec120f251eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:std&lt;/code&gt; subpragma on its own has no effect, but if combined with the &lt;code&gt;:utf8&lt;/code&gt; or &lt;code&gt;:encoding&lt;/code&gt; subpragmas, it converts the standard filehandles (STDIN, STDOUT, STDERR) to comply with encoding selected for input/output handles. For example, if both input and out are chosen to be &lt;code&gt;:encoding(utf8)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will mean that STDIN, STDOUT, and STDERR are also in &lt;code&gt;:encoding(utf8)&lt;/code&gt; . On the other hand, if only output is chosen to be in &lt;code&gt;:encoding(koi8r)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; will cause only the STDOUT and STDERR to be in &lt;code&gt;koi8r&lt;/code&gt; . The &lt;code&gt;:locale&lt;/code&gt; subpragma implicitly turns on &lt;code&gt;:std&lt;/code&gt; .</source>
          <target state="translated">El subpragma &lt;code&gt;:std&lt;/code&gt; por s&amp;iacute; solo no tiene ning&amp;uacute;n efecto, pero si se combina con los &lt;code&gt;:utf8&lt;/code&gt; o &lt;code&gt;:encoding&lt;/code&gt; , convierte los identificadores de archivo est&amp;aacute;ndar (STDIN, STDOUT, STDERR) para cumplir con la codificaci&amp;oacute;n seleccionada para los identificadores de entrada / salida. Por ejemplo, si tanto la entrada como la salida se eligen para ser &lt;code&gt;:encoding(utf8)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; significar&amp;aacute; que STDIN, STDOUT y STDERR tambi&amp;eacute;n est&amp;aacute;n en &lt;code&gt;:encoding(utf8)&lt;/code&gt; . Por otro lado, si solo se elige la salida para estar en &lt;code&gt;:encoding(koi8r)&lt;/code&gt; , a &lt;code&gt;:std&lt;/code&gt; har&amp;aacute; que solo STDOUT y STDERR est&amp;eacute;n en &lt;code&gt;koi8r&lt;/code&gt; . El subpragma &lt;code&gt;:locale&lt;/code&gt; activa impl&amp;iacute;citamente &lt;code&gt;:std&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="2743b792818bf7f895d0f0b22baae763060aa81f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt; . To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . To disable autodie for only a single function (eg, open) use &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; .</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;:void&lt;/code&gt; se admite en &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt; , pero no en &lt;code&gt;autodie&lt;/code&gt; . Para solucionar esto, el &lt;code&gt;autodie&lt;/code&gt; puede desactivarse expl&amp;iacute;citamente hasta el final del bloque actual &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie&lt;/code&gt; . Para deshabilitar el autodie para una &amp;uacute;nica funci&amp;oacute;n (por ejemplo, abrir), &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; autodie qw(open)&lt;/code&gt; use autodie qw (abrir) .</target>
        </trans-unit>
        <trans-unit id="0969ef951925275c4d8bd4c9c51662e300f9c641" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;:void&lt;/code&gt; option is supported in &lt;a href=&quot;fatal&quot;&gt;Fatal&lt;/a&gt;, but not &lt;code&gt;autodie&lt;/code&gt;. To workaround this, &lt;code&gt;autodie&lt;/code&gt; may be explicitly disabled until the end of the current block with &lt;code&gt;no autodie&lt;/code&gt;. To disable autodie for only a single function (eg, open) use &lt;code&gt;no autodie qw(open)&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="67318be992f4377bb68fbe49ed99f910c657a047" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt; for more details on &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt;).</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n se utiliza para crear una instancia del filtro. Perl lo llama indirectamente cuando encuentra la l&amp;iacute;nea &lt;code&gt;&lt;a href=&quot;../../functions/use&quot;&gt;use&lt;/a&gt; MyFilter&lt;/code&gt; en un archivo fuente (ver &lt;a href=&quot;../../functions/import&quot;&gt;importaci&amp;oacute;n&lt;/a&gt; para m&amp;aacute;s detalles sobre la &lt;code&gt;&lt;a href=&quot;../../functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n ).</target>
        </trans-unit>
        <trans-unit id="69849addd7818fee9c7e8c167a05d6c0d2986859" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; will</source>
          <target state="translated">La &lt;code&gt;&lt;a href=&quot;../functions/read&quot;&gt;read&lt;/a&gt;&lt;/code&gt; ser&amp;aacute;</target>
        </trans-unit>
        <trans-unit id="0eafa6355d483056647b2819a7f67215461c3497" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt; . You may call</source>
          <target state="translated">La llamada de &lt;code&gt;&lt;a href=&quot;../functions/tie&quot;&gt;tie&lt;/a&gt;&lt;/code&gt; devuelve un objeto, digamos &lt;code&gt;$o&lt;/code&gt; . Puedes llamar</target>
        </trans-unit>
        <trans-unit id="51ffe3fc21c6601c2932126d4f4eca5123604eda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">La construcci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; &lt;a href=&quot;delete&quot;&gt;eliminaci&amp;oacute;n &lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; tambi&amp;eacute;n se puede utilizar para localizar la eliminaci&amp;oacute;n de elementos de matriz / hash en el bloque actual. Consulte &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Eliminaci&amp;oacute;n localizada de elementos de tipos compuestos en perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="b1621ad946434d6c08e6becea5950298e8d654de" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">La construcci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; &lt;a href=&quot;delete&quot;&gt;eliminaci&amp;oacute;n &lt;/a&gt; &lt;a href=&quot;local&quot;&gt;local&lt;/a&gt; localiza la eliminaci&amp;oacute;n en el bloque actual en tiempo de ejecuci&amp;oacute;n. Hasta que el bloque salga, los elementos eliminados localmente temporalmente ya no existen. Consulte &lt;a href=&quot;../perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Eliminaci&amp;oacute;n localizada de elementos de tipos compuestos en perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="413b32076323a1b9dc32ef8307740eba59479274" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; ejecuta un comando del sistema</target>
        </trans-unit>
        <trans-unit id="2195a8cff19304cef2dc99fbcce68cf6dbdaf4fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; no est&amp;aacute; implementada en todas las versiones de Windows. Consulte la documentaci&amp;oacute;n de su versi&amp;oacute;n espec&amp;iacute;fica de Perl.</target>
        </trans-unit>
        <trans-unit id="1cc7a7cd989d44101ffb59063ba0d9ec90f901e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; was called.</source>
          <target state="translated">El operador &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; intentar&amp;aacute; asegurarse de que no se produzca ninguna traducci&amp;oacute;n del control de carro en la entrada o salida de este identificador de archivo. Dado que esto implica volver a abrir el archivo y luego restaurar su indicador de posici&amp;oacute;n de archivo, si esta funci&amp;oacute;n devuelve FALSE, es posible que el &lt;code&gt;&lt;a href=&quot;functions/binmode&quot;&gt;binmode&lt;/a&gt;&lt;/code&gt; archivo subyacente ya no apunte a un archivo abierto, o puede apuntar a una posici&amp;oacute;n diferente en el archivo que antes de llamar a binmode .</target>
        </trans-unit>
        <trans-unit id="d7b9155394683e2730126a87d41bdd8b7ec8ee0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; functions work on whole characters.</source>
          <target state="translated">Las funciones &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord()&lt;/a&gt;&lt;/code&gt; funcionan con caracteres completos.</target>
        </trans-unit>
        <trans-unit id="b8d018fd592275cef4c6f8f9148b669393d46ef8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="translated">El operador de la &lt;code&gt;&lt;a href=&quot;functions/crypt&quot;&gt;crypt&lt;/a&gt;&lt;/code&gt; utiliza el servicio del sistema &lt;code&gt;sys$hash_password&lt;/code&gt; para generar la representaci&amp;oacute;n hash de PLAINTEXT. Si USER es un nombre de usuario v&amp;aacute;lido, el algoritmo y los valores de sal se toman del registro UAF de ese usuario. Si no es as&amp;iacute;, se utilizan el algoritmo preferido y una sal de 0. El valor cifrado de cuatro palabras se devuelve como una cadena de 8 caracteres.</target>
        </trans-unit>
        <trans-unit id="51567ba352ff0d9256d32ae3d4a4cc5e55c3b1bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">La construcci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; &lt;a href=&quot;functions/delete&quot;&gt;eliminaci&amp;oacute;n &lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; tambi&amp;eacute;n se puede utilizar para localizar la eliminaci&amp;oacute;n de elementos de matriz / hash en el bloque actual. Consulte &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Eliminaci&amp;oacute;n localizada de elementos de tipos compuestos en perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="205f4f4c053e1354b5fd41e9a973041210cd6cb4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Localized deletion of elements of composite types in perlsub&lt;/a&gt;.</source>
          <target state="translated">La construcci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/delete&quot;&gt;delete&lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; EXPR&lt;/code&gt; &lt;a href=&quot;functions/delete&quot;&gt;eliminaci&amp;oacute;n &lt;/a&gt; &lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt; localiza la eliminaci&amp;oacute;n en el bloque actual en tiempo de ejecuci&amp;oacute;n. Hasta que el bloque salga, los elementos eliminados localmente temporalmente ya no existen. Consulte &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;Eliminaci&amp;oacute;n localizada de elementos de tipos compuestos en perlsub&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="7c330ed0d1614413aef6482d1172074b901ca8ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="translated">La construcci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt; {}&lt;/code&gt; no es un bucle real en el que pueda usar el control de bucle.</target>
        </trans-unit>
        <trans-unit id="bf5bbfe9093c8abccc03e7c7efe8dbe3d8e0233d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="translated">Sin embargo, el operador &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; puede ser un poco complicado. No puede agregar o eliminar claves del hash mientras lo est&amp;aacute; usando sin posiblemente omitir o volver a procesar algunos pares despu&amp;eacute;s de que Perl repita internamente todos los elementos. Adem&amp;aacute;s, un hash tiene solo un iterador, por lo que si mezcla &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/values&quot;&gt;values&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; en el mismo hash, corre el riesgo de restablecer el iterador y estropear su procesamiento. Consulte &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; entrada en &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="6a7ce17abb69e82a8250b438247bf503d68963f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; method.</source>
          <target state="translated">La &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each&lt;/a&gt;&lt;/code&gt; operador devuelve los pares en orden aparentemente aleatoria, de modo que si los asuntos de la orden Para usted, usted tendr&amp;aacute; que seguir con la &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt;&lt;/code&gt; m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="1d704aced95cc8764eb35404aac65f2304fbf2d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; method wrapped an &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; around a &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt; .</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; envolvi&amp;oacute; una &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; uaci&amp;oacute;n alrededor de una &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; , y por lo tanto esper&amp;oacute; a que saliera un hilo, pasando los valores que el hilo podr&amp;iacute;a haber devuelto y colocando los errores en &lt;code&gt;$@&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="80c53083069f05797eef5848d626cca139bde071" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; feature enables the &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; keyword, which evaluates the argument passed to it as a string of bytes. It dies if the string contains any characters outside the 8-bit range. Source filters work within &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt;: they apply to the contents of the string being evaluated.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; habilita la palabra clave &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; , que eval&amp;uacute;a el argumento que se le pasa como una cadena de bytes. Muere si la cadena contiene caracteres fuera del rango de 8 bits. Los filtros de origen funcionan dentro de &lt;code&gt;&lt;a href=&quot;functions/evalbytes&quot;&gt;evalbytes&lt;/a&gt;&lt;/code&gt; : se aplican al contenido de la cadena que se eval&amp;uacute;a.</target>
        </trans-unit>
        <trans-unit id="013c20c8a39c1e9d213753c8f42aa60136c4133a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function executes a system command</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; ejecuta un comando del sistema</target>
        </trans-unit>
        <trans-unit id="cc6b445e37f9fe0173dc131ac1ed2864194322f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt;. :)</source>
          <target state="translated">El trabajo de la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; es convertir su proceso en otro comando y nunca regresar. Si eso no es lo que quiere hacer, no use &lt;code&gt;&lt;a href=&quot;functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; . :)</target>
        </trans-unit>
        <trans-unit id="c64c8f5547bb2a6573770267608423f5c2aa4dc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn).</source>
          <target state="translated">El modificador &lt;code&gt;&lt;a href=&quot;functions/for&quot;&gt;for(each)&lt;/a&gt;&lt;/code&gt; es un iterador: ejecuta la declaraci&amp;oacute;n una vez para cada elemento de la LISTA (con &lt;code&gt;$_&lt;/code&gt; alias para cada elemento a su vez).</target>
        </trans-unit>
        <trans-unit id="fcbb7f06dac39b4543299760a90086a0717180ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; , aunque solo toma un argumento, tiene la prioridad de un operador de lista, as&amp;iacute; que tenga cuidado:</target>
        </trans-unit>
        <trans-unit id="d7025a8a8790fde9485d755f6c425f01c04b8467" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">El operador &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime&lt;/a&gt;&lt;/code&gt; funcionar&amp;aacute; correctamente si tiene una rutina &lt;code&gt;&lt;a href=&quot;functions/gmtime&quot;&gt;gmtime()&lt;/a&gt;&lt;/code&gt; , o si el nombre l&amp;oacute;gico SYS $ TIMEZONE_DIFFERENTIAL se define como la cantidad de segundos que se deben agregar a UTC para obtener la hora local. (Este nombre l&amp;oacute;gico se define autom&amp;aacute;ticamente si est&amp;aacute; ejecutando una versi&amp;oacute;n de VMS con soporte UTC incorporado). Si ninguno de estos casos es verdadero, se imprime un mensaje de advertencia y se devuelve &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5a3ff2f4c2a7967681e4811d9bc792e927dbfcbd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">La forma &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; es bastante diferente de las otras formas de &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; . De hecho, no es un goto en el sentido normal en absoluto, y no tiene el estigma asociado con otros gotos. En cambio, sale de la subrutina actual (perdiendo cualquier cambio establecido por local ()) e inmediatamente llama en su lugar a la subrutina nombrada usando el valor actual de @_. Esto lo utilizan las subrutinas &lt;code&gt;AUTOLOAD&lt;/code&gt; que desean cargar otra subrutina y luego pretenden que la otra subrutina ha sido llamada en primer lugar (excepto que cualquier modificaci&amp;oacute;n a &lt;code&gt;@_&lt;/code&gt; en la subrutina actual se propaga a la otra subrutina). Despu&amp;eacute;s del &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , ni siquiera &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; podr&amp;aacute; saber que esta rutina se llam&amp;oacute; primero.</target>
        </trans-unit>
        <trans-unit id="8c6cdb8b9140a3413b924a1be37defd8094c23ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">El formulario &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; espera evaluar &lt;code&gt;EXPR&lt;/code&gt; a una referencia de c&amp;oacute;digo o un nombre de etiqueta. Si se eval&amp;uacute;a como una referencia de c&amp;oacute;digo, se manejar&amp;aacute; como &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , a continuaci&amp;oacute;n. Esto es especialmente &amp;uacute;til para implementar la recursividad de cola a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="f9a08aec53b4872b20c38601dfe1ff47bb7271a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">El formulario &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; encuentra la instrucci&amp;oacute;n etiquetada con LABEL y reanuda la ejecuci&amp;oacute;n all&amp;iacute;. No se puede usar para salir de un bloque o subrutina dada para &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Se puede usar para ir a casi cualquier otro lugar dentro del alcance din&amp;aacute;mico, incluso fuera de las subrutinas, pero generalmente es mejor usar alguna otra construcci&amp;oacute;n como &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . El autor de Perl nunca ha sentido la necesidad de utilizar esta forma de &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (en Perl, es decir, C es otra cuesti&amp;oacute;n). (La diferencia es que C no ofrece bucles con nombre combinados con control de bucle. Perl s&amp;iacute;, y esto reemplaza la mayor&amp;iacute;a de los usos estructurados de &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; en otros lenguajes).</target>
        </trans-unit>
        <trans-unit id="fd5e7141b6809acf60b4ffb9ca0527589ab4d1fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">La forma &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; - &amp;amp; NAME es muy m&amp;aacute;gica y sustituye una llamada a la subrutina nombrada por la subrutina en ejecuci&amp;oacute;n. Esto es utilizado por las subrutinas &lt;code&gt;AUTOLOAD()&lt;/code&gt; que desean cargar otra subrutina y luego pretenden que la otra subrutina ha sido llamada en primer lugar (excepto que cualquier modificaci&amp;oacute;n a &lt;code&gt;@_&lt;/code&gt; en la subrutina actual se propaga a la otra subrutina). &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , ni siquiera el &lt;code&gt;&lt;a href=&quot;functions/caller&quot;&gt;caller()&lt;/a&gt;&lt;/code&gt; podr&amp;aacute; decir que esta rutina se llam&amp;oacute; primero.</target>
        </trans-unit>
        <trans-unit id="0f2fbb144491503128d3d631573fe99dbb58cb74" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="translated">El formulario &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -EXPR espera un nombre de etiqueta, cuyo alcance se resolver&amp;aacute; din&amp;aacute;micamente. Esto permite &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; s calculados por FORTRAN, pero no se recomienda necesariamente si est&amp;aacute; optimizando para la mantenibilidad:</target>
        </trans-unit>
        <trans-unit id="747fd1051ce1561b7aad0a462ec80a7083e807f2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="translated">El formulario &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; -LABEL encuentra la instrucci&amp;oacute;n etiquetada con LABEL y reanuda la ejecuci&amp;oacute;n all&amp;iacute;. No se puede utilizar para entrar en ninguna construcci&amp;oacute;n que requiera inicializaci&amp;oacute;n, como una subrutina o un bucle &lt;code&gt;foreach&lt;/code&gt; . Tampoco se puede usar para entrar en una construcci&amp;oacute;n optimizada. Se puede usar para ir a casi cualquier otro lugar dentro del alcance din&amp;aacute;mico, incluso fuera de las subrutinas, pero generalmente es mejor usar alguna otra construcci&amp;oacute;n como &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . El autor de Perl nunca ha sentido la necesidad de utilizar esta forma de &lt;code&gt;&lt;a href=&quot;functions/goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (en Perl, es decir, C es otro asunto).</target>
        </trans-unit>
        <trans-unit id="b3e30e59d91f75eda248244fb51004176883c63f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/grep&quot;&gt;grep&lt;/a&gt;&lt;/code&gt; en contexto escalar devuelve el recuento. Si desea la lista de elementos coincidentes, simplemente util&amp;iacute;cela en el contexto de la lista:</target>
        </trans-unit>
        <trans-unit id="612dabc89cee10beadc6c980b04dfdba8cc2e280" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys()&lt;/a&gt;&lt;/code&gt; funci&amp;oacute;n tambi&amp;eacute;n restablece el repetidor, lo que significa que es posible que vea resultados extra&amp;ntilde;os si se utiliza esta entre los usos de otros operadores de hash como &lt;code&gt;&lt;a href=&quot;functions/each&quot;&gt;each()&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="84a92b66f23e84ffcea0f8036601109332768c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; puede usarse para probar esta funcionalidad desde dentro de un programa.</target>
        </trans-unit>
        <trans-unit id="8f9dd8be24cd7b207201afca586d0393221c8761" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/kill&quot;&gt;kill&lt;/a&gt;&lt;/code&gt; en el bloque &lt;code&gt;if&lt;/code&gt; del padre est&amp;aacute; ah&amp;iacute; para enviar una se&amp;ntilde;al a nuestro proceso hijo, que actualmente se ejecuta en el bloque &lt;code&gt;else&lt;/code&gt; , tan pronto como el servidor remoto haya cerrado su extremo de la conexi&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8bfb3b07d45ff01232bb221af626a6a5fb4ea5a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; comando sale inmediatamente del bucle en cuesti&amp;oacute;n. El bloque de &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , si lo hay, no se ejecuta:</target>
        </trans-unit>
        <trans-unit id="ac302bdab0f919a07174f63d0969bebc85f1b892" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; comando es como la instrucci&amp;oacute;n &lt;code&gt;break&lt;/code&gt; en C (como se usa en los bucles); sale inmediatamente del bucle en cuesti&amp;oacute;n. Si se omite LABEL, el comando se refiere al bucle envolvente m&amp;aacute;s interno. La &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; forma EXPR , disponible a partir de Perl 5.18.0, permite calcular un nombre de etiqueta en tiempo de ejecuci&amp;oacute;n y, por lo dem&amp;aacute;s, es id&amp;eacute;ntica a la &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . El bloque de &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , si lo hay, no se ejecuta:</target>
        </trans-unit>
        <trans-unit id="506963259280dc353e83831a1d7243717b046918" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt; Keyword</source>
          <target state="translated">La palabra clave de &lt;code&gt;&lt;a href=&quot;functions/length&quot;&gt;length(NAME)&lt;/a&gt;&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="249bfee98e5c2e5ddbdeda77c1a70bb97c684fdb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; function. Using &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; toma una variable compartida y la bloquea. Ning&amp;uacute;n otro hilo puede bloquear la variable hasta que el hilo que sujeta el bloqueo la desbloquee. El desbloqueo ocurre autom&amp;aacute;ticamente cuando el hilo de bloqueo sale del bloque que contiene la llamada a la funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; . Usar &lt;code&gt;&lt;a href=&quot;functions/lock&quot;&gt;lock()&lt;/a&gt;&lt;/code&gt; es sencillo: este ejemplo tiene varios subprocesos que realizan algunos c&amp;aacute;lculos en paralelo y ocasionalmente actualizan un total acumulado:</target>
        </trans-unit>
        <trans-unit id="844dd628839d69aa91981cfdf9d35b8aa941b210" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; en realidad no es necesario; solo podr&amp;iacute;as usar:</target>
        </trans-unit>
        <trans-unit id="15c7027f68a72fedc245e7d612cf00a82d9df24d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; es simplemente un modificador en algo que usted puede asignar a. Entonces, cuando asigna variables en su lista de argumentos, &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; no cambia si esas variables se ven como un escalar o una matriz. Entonces</target>
        </trans-unit>
        <trans-unit id="82cb7d6fd4d7d98853ace6ba4000362cdc7fa762" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if/unless/elsif/else&lt;/code&gt;), loop (&lt;code&gt;for/foreach/while/until/continue&lt;/code&gt;), subroutine, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;ized with &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; instead.</source>
          <target state="translated">El operador &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; declara que las variables enumeradas se limitan l&amp;eacute;xicamente al bloque adjunto, condicional ( &lt;code&gt;if/unless/elsif/else&lt;/code&gt; ), bucle ( &lt;code&gt;for/foreach/while/until/continue&lt;/code&gt; ), subrutina, &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; , o &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do/require/use&lt;/a&gt;&lt;/code&gt; Archivo 'd. Si se incluye m&amp;aacute;s de un valor, la lista debe colocarse entre par&amp;eacute;ntesis. Todos los elementos enumerados deben ser valores legales. S&amp;oacute;lo identificadores alfanum&amp;eacute;ricos pueden &amp;aacute;mbito l&amp;eacute;xico - m&amp;aacute;gicos muebles empotrados como &lt;code&gt;$/&lt;/code&gt; Actualmente se deben &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; es zan con &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; es en su lugar.</target>
        </trans-unit>
        <trans-unit id="598c24981891ed39a33542154be0ea54335c8268" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; comando es como la instrucci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; en C; inicia la siguiente iteraci&amp;oacute;n del ciclo:</target>
        </trans-unit>
        <trans-unit id="4ac987f577bf457aa0aa7edd6027d43957e00541" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; comando inicia la siguiente iteraci&amp;oacute;n del ciclo:</target>
        </trans-unit>
        <trans-unit id="90d027781b9d30c834bc3f75976b8010ac44b08a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords work differently.</source>
          <target state="translated">Las palabras clave &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/exit&quot;&gt;exit&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; funcionan de manera diferente.</target>
        </trans-unit>
        <trans-unit id="5eeb76addad99da0bbdd65d75ec9e60f2b34827f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; pragma doesn't</source>
          <target state="translated">El pragma de &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; &lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; no</target>
        </trans-unit>
        <trans-unit id="7bf3b5adc84fde6d734586f4bec0209359aa5187" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; lib&lt;/code&gt; elimina todas las instancias de cada directorio nombrado de @INC.</target>
        </trans-unit>
        <trans-unit id="1aa289805fbc7ad3a1863fbfa81d350e063c7221" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="translated">Las construcciones &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(FOO, &quot;|-&quot;)&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;(BAR, &quot;-|&quot;)&lt;/code&gt; a&amp;uacute;n no est&amp;aacute;n implementadas. Esta limitaci&amp;oacute;n se puede solucionar f&amp;aacute;cilmente en c&amp;oacute;digo nuevo creando una tuber&amp;iacute;a expl&amp;iacute;citamente. El siguiente ejemplo muestra c&amp;oacute;mo escribir a un ni&amp;ntilde;o bifurcado:</target>
        </trans-unit>
        <trans-unit id="91b6442686235ec3446ecfbcfcc1b68ae5f717df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (also known as &quot;disciplines&quot;) for all I/O. Any two-argument open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults. Even three-argument opens may be affected by this pragma when they don't specify IO layers in MODE.</source>
          <target state="translated">El pragma &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; sirve como una de las interfaces para declarar &quot;capas&quot; predeterminadas (tambi&amp;eacute;n conocidas como &quot;disciplinas&quot;) para todas las E / S. Cualquier open (), readpipe () (tambi&amp;eacute;n conocido como qx //) de dos argumentos y operadores similares que se encuentren dentro del alcance l&amp;eacute;xico de este pragma usar&amp;aacute;n los valores predeterminados declarados. Incluso las aperturas de tres argumentos pueden verse afectadas por este pragma cuando no especifican capas de E / S en MODE.</target>
        </trans-unit>
        <trans-unit id="d568cb2b48539b711386365d8e03258e04c0c727" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="translated">Las funciones &lt;code&gt;&lt;a href=&quot;functions/ord&quot;&gt;ord&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/chr&quot;&gt;chr&lt;/a&gt;&lt;/code&gt; funcionan de forma transparente en todos los puntos de c&amp;oacute;digo, no solo en ASCII ni, de hecho, ni siquiera solo en Unicode.</target>
        </trans-unit>
        <trans-unit id="48c955c71d75929afac22e8dfa9aad63b2004a10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="translated">El operador &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr//&lt;/a&gt;&lt;/code&gt; apareci&amp;oacute; en perl 5.005. Compila una expresi&amp;oacute;n regular, pero no la aplica. Cuando usa la versi&amp;oacute;n precompilada de la expresi&amp;oacute;n regular, perl hace menos trabajo. En este ejemplo, insert&amp;eacute; un &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; a para convertir cada patr&amp;oacute;n en su forma precompilada. El resto del script es el mismo, pero m&amp;aacute;s r&amp;aacute;pido:</target>
        </trans-unit>
        <trans-unit id="6086a140e1b37399f10a989a119aa2028d369c83" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is</source>
          <target state="translated">El comando &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; reinicia el bloque de bucle sin evaluar el condicional nuevamente. El bloque de &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , si lo hay, es</target>
        </trans-unit>
        <trans-unit id="362e8253628830d9a4d5614fd639fe79bc546984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">El comando &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; reinicia el bloque de bucle sin evaluar el condicional nuevamente. El bloque de &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , si lo hay, no se ejecuta. Si se omite LABEL, el comando se refiere al bucle envolvente m&amp;aacute;s interno. El formulario &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; , disponible a partir de Perl 5.18.0, permite calcular el nombre de una etiqueta en tiempo de ejecuci&amp;oacute;n y, por lo dem&amp;aacute;s, es id&amp;eacute;ntico a &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; . Los programas que quieren mentirse a s&amp;iacute; mismos sobre lo que se acaba de ingresar normalmente usan este comando:</target>
        </trans-unit>
        <trans-unit id="f9c130f1621f9ce97dabd985717a6055d0d6afd0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="translated">El operador de sustituci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; est&amp;aacute; documentado en &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="121511ae0b5d1fbb23eba64b638e8a05d463c939" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt; , if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split()&lt;/a&gt;&lt;/code&gt; es otro lugar donde se usa una expresi&amp;oacute;n regular. &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt; /regexp/, string, limit&lt;/code&gt; separa el operando de &lt;code&gt;string&lt;/code&gt; en una lista de subcadenas y devuelve esa lista. La expresi&amp;oacute;n regular debe dise&amp;ntilde;arse para que coincida con lo que constituya los separadores de las subcadenas deseadas. El &lt;code&gt;limit&lt;/code&gt; , si est&amp;aacute; presente, restringe la divisi&amp;oacute;n en no m&amp;aacute;s que el n&amp;uacute;mero &lt;code&gt;limit&lt;/code&gt; de cadenas. Por ejemplo, para dividir una cadena en palabras, use</target>
        </trans-unit>
        <trans-unit id="7f7da5ebd320780203ed7d5e0028f1f486db3bfd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="translated">La palabra clave &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; crea una variable l&amp;eacute;xica (siguiendo las mismas reglas de alcance que &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ) que persiste de una llamada a subrutina a la siguiente. Si una variable de estado reside dentro de una subrutina an&amp;oacute;nima, entonces cada copia de la subrutina tiene su propia copia de la variable de estado. Sin embargo, el valor de la variable de estado a&amp;uacute;n persistir&amp;aacute; entre llamadas a la misma copia de la subrutina an&amp;oacute;nima. (No olvide que &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub&lt;/a&gt; { ... }&lt;/code&gt; crea una nueva subrutina cada vez que se ejecuta).</target>
        </trans-unit>
        <trans-unit id="87a4764ce311581074e8327a658c6ee1ed914b66" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="translated">Los &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-entry&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/sub&quot;&gt;sub-return&lt;/a&gt;&lt;/code&gt; sondas adquieren un cuarto argumento: el nombre del paquete de la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="fa495b532decb2c8f20d40c7506dd35df2aff6f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="translated">Se considera que el &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; integrado ha fallado en las siguientes circunstancias:</target>
        </trans-unit>
        <trans-unit id="007bfa453d22a010bcc25f103e9e741d0e19770d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt; , any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="translated">El operador del &lt;code&gt;&lt;a href=&quot;functions/system&quot;&gt;system&lt;/a&gt;&lt;/code&gt; crea un subproceso y pasa sus argumentos al subproceso para su ejecuci&amp;oacute;n como un comando DCL. Dado que el subproceso se crea directamente a trav&amp;eacute;s de &lt;code&gt;lib$spawn()&lt;/code&gt; , se puede especificar cualquier cadena de comando DCL v&amp;aacute;lida. Si la cadena comienza con '@', se trata incondicionalmente como un comando DCL. De lo contrario, si el primer token contiene un car&amp;aacute;cter utilizado como delimitador en la especificaci&amp;oacute;n del archivo (por ejemplo &lt;code&gt;:&lt;/code&gt; o &lt;code&gt;]&lt;/code&gt; ), se intenta expandirlo utilizando un tipo predeterminado de</target>
        </trans-unit>
        <trans-unit id="c442498b077f35c1d517c581c1d1aa5d5b6d170c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/times&quot;&gt;times()&lt;/a&gt;&lt;/code&gt; devuelve el tiempo real transcurrido desde alg&amp;uacute;n momento en el pasado (como el inicio del sistema), los tiempos del usuario y del sistema para este proceso, y los tiempos del usuario y del sistema utilizados por los procesos secundarios. Todos los tiempos se devuelven en tics de reloj.</target>
        </trans-unit>
        <trans-unit id="80b97318408e6d656bf28c96d67c4dfdc24c2653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</source>
          <target state="translated">El operador &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///&lt;/a&gt;&lt;/code&gt; traduce caracteres completos. (Tenga en cuenta que se ha eliminado la funcionalidad &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr///CU&lt;/a&gt;&lt;/code&gt; . Para obtener una funcionalidad similar, consulte el &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('U0', ...)&lt;/code&gt; y el &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack&lt;/a&gt;('C0', ...)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="11a568ea0ae08ef300d37d167d740832b4c2b16f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; alternative might look like this:</source>
          <target state="translated">La alternativa &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; podr&amp;iacute;a verse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="42f87c254ee8d81cee26e792f60cacaefbfbe36a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; counts the null bytes. The &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; block.</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; cuenta los bytes nulos. La llamada al &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack&lt;/a&gt;&lt;/code&gt; devuelve una lista de pares de nombre-valor, cada uno de los cuales se desarma en el bloque de &lt;code&gt;&lt;a href=&quot;functions/map&quot;&gt;map&lt;/a&gt;&lt;/code&gt; a .</target>
        </trans-unit>
        <trans-unit id="a53ff006297297281156ad4ddc8aef0830e3811c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="translated">La versi&amp;oacute;n &lt;code&gt;&lt;a href=&quot;functions/tr&quot;&gt;tr&lt;/a&gt;&lt;/code&gt; es un claro ganador. Una soluci&amp;oacute;n es flexible, la otra es r&amp;aacute;pida, y es apropiado que el programador elija cu&amp;aacute;l usar.</target>
        </trans-unit>
        <trans-unit id="6f47b182b84a1df9e8040499b142da5e15a5a35d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; Gotcha</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/untie&quot;&gt;untie&lt;/a&gt;&lt;/code&gt; Gotcha</target>
        </trans-unit>
        <trans-unit id="5e2ca855aa217bd553e610f05dba85cf9019d5da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; pragma disables character semantics for the rest of the lexical scope in which it appears. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; can be used to reverse the effect of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; within the current lexical scope.</source>
          <target state="translated">El pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; deshabilita la sem&amp;aacute;ntica de caracteres para el resto del &amp;aacute;mbito l&amp;eacute;xico en el que aparece. &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; bytes&lt;/code&gt; se pueden usar bytes para revertir el efecto de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; bytes&lt;/code&gt; dentro del alcance l&amp;eacute;xico actual.</target>
        </trans-unit>
        <trans-unit id="9fdef637aec2a8c40d4ef4a640873fd3daeaa545" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="translated">Las &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; filetest o &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; filetest&lt;/code&gt; afectan las pruebas de archivo definidas en su bloque, hasta el final del bloque adjunto m&amp;aacute;s cercano (son l&amp;eacute;xicamente de &amp;aacute;mbito de bloque).</target>
        </trans-unit>
        <trans-unit id="8744ea2543ae1b476ba91732c622f01f08c1038b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope (allow UTF-EBCDIC on EBCDIC based platforms). The &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope.</source>
          <target state="translated">El pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; utf8&lt;/code&gt; le dice al analizador Perl que permita UTF-8 en el texto del programa en el &amp;aacute;mbito l&amp;eacute;xico actual (permitir UTF-EBCDIC en plataformas basadas en EBCDIC). El pragma &lt;code&gt;&lt;a href=&quot;functions/no&quot;&gt;no&lt;/a&gt; utf8&lt;/code&gt; le dice a Perl que vuelva a tratar el texto fuente como bytes literales en el &amp;aacute;mbito l&amp;eacute;xico actual.</target>
        </trans-unit>
        <trans-unit id="43067066e43761608ec314550d1ef0009ca78c23" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="translated">Las &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; Pragma o &lt;b&gt;-w&lt;/b&gt; interruptor le advertir&amp;aacute;n si se interpreta una palabra reservada como una cadena. Pero ya no le advertir&amp;aacute; sobre el uso de palabras en min&amp;uacute;sculas, porque la cadena est&amp;aacute; efectivamente entre comillas.</target>
        </trans-unit>
        <trans-unit id="19cdd025fab18dcd164b56bb8b49804d47261c9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="translated">El pragma de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; produce unos buenos diagn&amp;oacute;sticos. Tambi&amp;eacute;n se puede utilizar el indicador &lt;b&gt;-w&lt;/b&gt; , pero normalmente se desaconseja su uso, porque se aplica a todo el c&amp;oacute;digo Perl ejecutado, incluido el que no est&amp;aacute; bajo su control.</target>
        </trans-unit>
        <trans-unit id="98ff32ffdb1aaec51b5964ab04fedf9b556042ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; function, even though it only takes one argument, has the precedence of a list operator, so beware:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;getprotobynumber&quot;&gt;getprotobynumber&lt;/a&gt;&lt;/code&gt; , aunque solo toma un argumento, tiene la prioridad de un operador de lista, as&amp;iacute; que tenga cuidado:</target>
        </trans-unit>
        <trans-unit id="57bb7a10c9bf27aba4e74945efa7f4324ecc8306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by local()) and immediately calls in its place the named subroutine using the current value of @_. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt;, not even &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="translated">La forma &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; es bastante diferente de las otras formas de &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; . De hecho, no es un goto en el sentido normal en absoluto, y no tiene el estigma asociado con otros gotos. En cambio, sale de la subrutina actual (perdiendo cualquier cambio establecido por local ()) e inmediatamente llama en su lugar a la subrutina nombrada usando el valor actual de @_. Esto lo utilizan las subrutinas &lt;code&gt;AUTOLOAD&lt;/code&gt; que desean cargar otra subrutina y luego pretenden que la otra subrutina ha sido llamada en primer lugar (excepto que cualquier modificaci&amp;oacute;n a &lt;code&gt;@_&lt;/code&gt; en la subrutina actual se propaga a la otra subrutina). Despu&amp;eacute;s del &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; , ni siquiera &lt;code&gt;&lt;a href=&quot;caller&quot;&gt;caller&lt;/a&gt;&lt;/code&gt; podr&amp;aacute; saber que esta rutina se llam&amp;oacute; primero.</target>
        </trans-unit>
        <trans-unit id="e45cfef5656ef233c1972b6e6db8f04158149f58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , below. This is especially useful for implementing tail recursion via &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</source>
          <target state="translated">El formulario &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; EXPR&lt;/code&gt; espera evaluar &lt;code&gt;EXPR&lt;/code&gt; a una referencia de c&amp;oacute;digo o un nombre de etiqueta. Si se eval&amp;uacute;a como una referencia de c&amp;oacute;digo, se manejar&amp;aacute; como &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; &amp;amp;NAME&lt;/code&gt; , a continuaci&amp;oacute;n. Esto es especialmente &amp;uacute;til para implementar la recursividad de cola a trav&amp;eacute;s de &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; __SUB__&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0fba7d2ee7cbb751d9b45951b63706bcd429d8d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; in other languages.)</source>
          <target state="translated">El formulario &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt; LABEL&lt;/code&gt; encuentra la instrucci&amp;oacute;n etiquetada con LABEL y reanuda la ejecuci&amp;oacute;n all&amp;iacute;. No se puede usar para salir de un bloque o subrutina dada para &lt;code&gt;&lt;a href=&quot;sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; . Se puede usar para ir a casi cualquier otro lugar dentro del alcance din&amp;aacute;mico, incluso fuera de las subrutinas, pero generalmente es mejor usar alguna otra construcci&amp;oacute;n como &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;die&quot;&gt;die&lt;/a&gt;&lt;/code&gt; . El autor de Perl nunca ha sentido la necesidad de utilizar esta forma de &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; (en Perl, es decir, C es otra cuesti&amp;oacute;n). (La diferencia es que C no ofrece bucles con nombre combinados con control de bucle. Perl s&amp;iacute;, y esto reemplaza la mayor&amp;iacute;a de los usos estructurados de &lt;code&gt;&lt;a href=&quot;goto&quot;&gt;goto&lt;/a&gt;&lt;/code&gt; en otros lenguajes).</target>
        </trans-unit>
        <trans-unit id="0ec2144df4bcb647e47e9a3fffb037716e0ff735" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;break&lt;/code&gt; statement in C (as used in loops); it immediately exits the loop in question. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed:</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; comando es como la instrucci&amp;oacute;n &lt;code&gt;break&lt;/code&gt; en C (como se usa en los bucles); inmediatamente sale del bucle en cuesti&amp;oacute;n. Si se omite LABEL, el comando se refiere al bucle envolvente m&amp;aacute;s interno. El &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; EXPR&lt;/code&gt; formulario EXPR , disponible a partir de Perl 5.18.0, permite calcular un nombre de etiqueta en tiempo de ejecuci&amp;oacute;n y, por lo dem&amp;aacute;s, es id&amp;eacute;ntico al &lt;code&gt;&lt;a href=&quot;last&quot;&gt;last&lt;/a&gt; LABEL&lt;/code&gt; . El bloque de &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , si lo hay, no se ejecuta:</target>
        </trans-unit>
        <trans-unit id="0dc04adeb5f33f6be3e55c3b75049d3460dd5faf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; command is like the &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; statement in C; it starts the next iteration of the loop:</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; comando es como la instrucci&amp;oacute;n &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; en C; inicia la siguiente iteraci&amp;oacute;n del ciclo:</target>
        </trans-unit>
        <trans-unit id="d03baace3369995824b0971e1012da68e7afe6a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d90f5477a728439ae001b7de4028bc5063fe8048" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; pragma can be used to set default modifiers (including these) for regular expressions compiled within its scope. This pragma has precedence over the other pragmas listed below that also change the defaults.</source>
          <target state="translated">El pragma &lt;code&gt;&lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;use re '/foo'&lt;/a&gt;&lt;/code&gt; se puede usar para establecer modificadores predeterminados (incluidos estos) para expresiones regulares compiladas dentro de su alcance. Este pragma tiene prioridad sobre los otros pragmas enumerados a continuaci&amp;oacute;n que tambi&amp;eacute;n cambian los valores predeterminados.</target>
        </trans-unit>
        <trans-unit id="00f56e4e287b4dad7bb9b00175cad4e28ccf4f49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; block, if any, is not executed. If the LABEL is omitted, the command refers to the innermost enclosing loop. The &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; form, available starting in Perl 5.18.0, allows a label name to be computed at run time, and is otherwise identical to &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;
LABEL&lt;/code&gt; . Programs that want to lie to themselves about what was just input normally use this command:</source>
          <target state="translated">El comando &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; reinicia el bloque de bucle sin evaluar el condicional nuevamente. El bloque de &lt;code&gt;&lt;a href=&quot;continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; , si lo hay, no se ejecuta. Si se omite LABEL, el comando se refiere al bucle envolvente m&amp;aacute;s interno. El formulario &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; EXPR&lt;/code&gt; , disponible a partir de Perl 5.18.0, permite calcular el nombre de una etiqueta en tiempo de ejecuci&amp;oacute;n y, por lo dem&amp;aacute;s, es id&amp;eacute;ntico a &lt;code&gt;&lt;a href=&quot;redo&quot;&gt;redo&lt;/a&gt; LABEL&lt;/code&gt; . Los programas que quieren mentirse a s&amp;iacute; mismos sobre lo que se acaba de ingresar normalmente usan este comando:</target>
        </trans-unit>
        <trans-unit id="98d8fed67bad4314d20d9f4fe777fa7ab53123e6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator (sometimes pronounced &quot;fat comma&quot;) is a synonym for the comma except that it causes a word on its left to be interpreted as a string if it begins with a letter or underscore and is composed only of letters, digits and underscores. This includes operands that might otherwise be interpreted as operators, constants, single number v-strings or function calls. If in doubt about this behavior, the left operand can be quoted explicitly.</source>
          <target state="translated">El operador &lt;code&gt;=&amp;gt;&lt;/code&gt; (a veces pronunciado &quot;coma gruesa&quot;) es un sin&amp;oacute;nimo de la coma, excepto que hace que una palabra a su izquierda se interprete como una cadena si comienza con una letra o un gui&amp;oacute;n bajo y se compone solo de letras, d&amp;iacute;gitos y subrayados. Esto incluye operandos que de otro modo podr&amp;iacute;an interpretarse como operadores, constantes, cadenas v de un solo n&amp;uacute;mero o llamadas a funciones. Si tiene dudas sobre este comportamiento, el operando izquierdo se puede citar expl&amp;iacute;citamente.</target>
        </trans-unit>
        <trans-unit id="8399dbf8e2e784c4274bc7b091a4f7216970d51b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=&amp;gt;&lt;/code&gt; operator is helpful in documenting the correspondence between keys and values in hashes, and other paired elements in lists.</source>
          <target state="translated">El operador &lt;code&gt;=&amp;gt;&lt;/code&gt; es &amp;uacute;til para documentar la correspondencia entre claves y valores en hashes y otros elementos emparejados en listas.</target>
        </trans-unit>
        <trans-unit id="efd3e2bb957eaa0ff2ef103df55bdfaea8225389" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=back&lt;/code&gt; command does not take any arguments.</source>
          <target state="translated">El comando &lt;code&gt;=back&lt;/code&gt; no toma ning&amp;uacute;n argumento.</target>
        </trans-unit>
        <trans-unit id="2748bc14f635bff7b4cada98a19718c4d6f31834" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt; . End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="translated">La directiva &lt;code&gt;=begin&lt;/code&gt; puede marcar una secci&amp;oacute;n para un prop&amp;oacute;sito particular. Si el analizador de Pod no quiere manejarlo, simplemente lo ignora. Etiquete los comentarios con &lt;code&gt;comment&lt;/code&gt; . Termine el comentario usando &lt;code&gt;=end&lt;/code&gt; con la misma etiqueta. A&amp;uacute;n necesita el &lt;code&gt;=cut&lt;/code&gt; para volver al c&amp;oacute;digo Perl desde el comentario del Pod:</target>
        </trans-unit>
        <trans-unit id="f59fd3ccb5e9b7feba1f1fe25b7136044c1d07fe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=begin&lt;/code&gt; directive can mark a section for a particular purpose. If the Pod parser doesn't want to handle it, it just ignores it. Label the comments with &lt;code&gt;comment&lt;/code&gt;. End the comment using &lt;code&gt;=end&lt;/code&gt; with the same label. You still need the &lt;code&gt;=cut&lt;/code&gt; to go back to Perl code from the Pod comment:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef8064ce24f5339d152aec47e53a990ce73ae1e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt; ) or the end of the file.</source>
          <target state="translated">El comando &lt;code&gt;=over&lt;/code&gt; no tiene un &lt;code&gt;=back&lt;/code&gt; correspondiente antes del siguiente encabezado ( &lt;code&gt;=head1&lt;/code&gt; o &lt;code&gt;=head2&lt;/code&gt; ) o al final del archivo.</target>
        </trans-unit>
        <trans-unit id="e8028d211e346b9053331798c8e936f0c3ebfac6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;=over&lt;/code&gt; command does not have a corresponding &lt;code&gt;=back&lt;/code&gt; before the next heading (&lt;code&gt;=head1&lt;/code&gt; or &lt;code&gt;=head2&lt;/code&gt;) or the end of the file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8153dbca699722108378e052ce04788e510ab3df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@EXPORT&lt;/code&gt; array tells Perl which of the extension's variables and subroutines should be placed into the calling package's namespace. Because you don't know if the user has already used your variable and subroutine names, it's vitally important to carefully select what to export. Do</source>
          <target state="translated">La matriz &lt;code&gt;@EXPORT&lt;/code&gt; le dice a Perl cu&amp;aacute;les de las variables y subrutinas de la extensi&amp;oacute;n deben colocarse en el espacio de nombres del paquete de llamada. Debido a que no sabe si el usuario ya ha utilizado sus nombres de variables y subrutinas, es de vital importancia seleccionar cuidadosamente qu&amp;eacute; exportar. Hacer</target>
        </trans-unit>
        <trans-unit id="59c8e98631ebe2ad43446558b18c0e9a67b97b20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; .</source>
          <target state="translated">El &lt;code&gt;@array[1]&lt;/code&gt; es una rodaja de matriz, a pesar de que s&amp;oacute;lo tiene un &amp;iacute;ndice. Puede extraer varios elementos simult&amp;aacute;neamente especificando &amp;iacute;ndices adicionales como una lista, como &lt;code&gt;@array[1,4,3,0]&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="acd3d23d5c24e2e27f46834d267601cebe9f5684" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;@array[1]&lt;/code&gt; is an array slice, although it has only one index. You can pull out multiple elements simultaneously by specifying additional indices as a list, like &lt;code&gt;@array[1,4,3,0]&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="651c155493f8eecba5929c58d7483ab06d1863f4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ACTUAL&lt;/code&gt; tells &lt;code&gt;NEXT&lt;/code&gt; that there must actually be a next method to call, or it should throw an exception.</source>
          <target state="translated">El &lt;code&gt;ACTUAL&lt;/code&gt; le dice a &lt;code&gt;NEXT&lt;/code&gt; que en realidad debe haber un pr&amp;oacute;ximo m&amp;eacute;todo para llamar, o deber&amp;iacute;a lanzar una excepci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="8e537d261fb0eb0877ceb1c6331c23797b3540cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Alias&lt;/code&gt; module implements localization of the basic types within the</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Alias&lt;/code&gt; implementa la localizaci&amp;oacute;n de los tipos b&amp;aacute;sicos dentro del</target>
        </trans-unit>
        <trans-unit id="2c6a8f1a286c25be4929a3d652924543120a4cba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt; . Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Archive::Tar&lt;/code&gt; puede utilizar opcionalmente &lt;code&gt;Compress::Zlib&lt;/code&gt; (a trav&amp;eacute;s del m&amp;oacute;dulo &lt;code&gt;IO::Zlib&lt;/code&gt; ) para acceder a los archivos tar que han sido comprimidos con &lt;code&gt;gzip&lt;/code&gt; . Desafortunadamente, los archivos tar comprimidos con la utilidad de &lt;code&gt;compress&lt;/code&gt; Unix no pueden ser le&amp;iacute;dos por &lt;code&gt;Compress::Zlib&lt;/code&gt; y, por lo tanto, &lt;code&gt;Archive::Tar&lt;/code&gt; no puede acceder directamente .</target>
        </trans-unit>
        <trans-unit id="c846109c9cdb2321e2be7662c4588cdc7ec88db7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt;. Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accessed by &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b17fdbcd746a9f7c286b280ba85ada7dc1cad7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Archive::Tar&lt;/code&gt; module can optionally use &lt;code&gt;Compress::Zlib&lt;/code&gt; (via the &lt;code&gt;IO::Zlib&lt;/code&gt; module) to access tar files that have been compressed with &lt;code&gt;gzip&lt;/code&gt;. Unfortunately tar files compressed with the Unix &lt;code&gt;compress&lt;/code&gt; utility cannot be read by &lt;code&gt;Compress::Zlib&lt;/code&gt; and so cannot be directly accesses by &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="43769b61441be000184345132a2a54dc3708064b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B::COP&lt;/code&gt; class is used for &quot;nextstate&quot; and &quot;dbstate&quot; ops. As of Perl 5.22, it is also used for &quot;null&quot; ops that started out as COPs.</source>
          <target state="translated">La clase &lt;code&gt;B::COP&lt;/code&gt; se utiliza para las operaciones &quot;nextstate&quot; y &quot;dbstate&quot;. A partir de Perl 5.22, tambi&amp;eacute;n se utiliza para operaciones &quot;nulas&quot; que comenzaron como COP.</target>
        </trans-unit>
        <trans-unit id="1a2938ca3d630d110b73048269c361ea78fb5cb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module contains a set of utility functions for querying the current state of the Perl interpreter; typically these functions return objects from the B::SV and B::OP classes, or their derived classes. These classes in turn define methods for querying the resulting objects about their own internal state.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;B&lt;/code&gt; contiene un conjunto de funciones de utilidad para consultar el estado actual del int&amp;eacute;rprete de Perl; normalmente, estas funciones devuelven objetos de las clases B :: SV y B :: OP, o sus clases derivadas. Estas clases, a su vez, definen m&amp;eacute;todos para consultar los objetos resultantes sobre su propio estado interno.</target>
        </trans-unit>
        <trans-unit id="40f9413962f128106cd0802b4a2c73013cd7ed0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module exports a variety of functions: some are simple utility functions, others provide a Perl program with a way to get an initial &quot;handle&quot; on an internal object.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;B&lt;/code&gt; exporta una variedad de funciones: algunas son funciones de utilidad simples, otras proporcionan un programa Perl con una forma de obtener un &quot;identificador&quot; inicial en un objeto interno.</target>
        </trans-unit>
        <trans-unit id="5c92116836eedf111e1da108ac269b10e9e38e79" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;B&lt;/code&gt; module supplies classes which allow a Perl program to delve into its own innards. It is the module used to implement the &quot;backends&quot; of the Perl compiler. Usage of the compiler does not require knowledge of this module: see the</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;B&lt;/code&gt; proporciona clases que permiten a un programa Perl profundizar en sus propias entra&amp;ntilde;as. Es el m&amp;oacute;dulo utilizado para implementar los &quot;backends&quot; del compilador Perl. El uso del compilador no requiere conocimientos de este m&amp;oacute;dulo: consulte la</target>
        </trans-unit>
        <trans-unit id="36e744ee541a84c63162e7b4ffbdc783bc6d5f1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT and END in perlmod&lt;/a&gt;</source>
          <target state="translated">El &lt;code&gt;BEGIN&lt;/code&gt; , &lt;code&gt;UNITCHECK&lt;/code&gt; , &lt;code&gt;CHECK&lt;/code&gt; , &lt;code&gt;INIT&lt;/code&gt; y &lt;code&gt;END&lt;/code&gt; subrutinas no son tanto como subrutinas especiales bloques de c&amp;oacute;digo con nombre, de los cuales se puede tener m&amp;aacute;s de uno en un paquete, y que puede &lt;b&gt;no&lt;/b&gt; llamar expl&amp;iacute;citamente. Ver &lt;a href=&quot;perlmod#BEGIN%2c-UNITCHECK%2c-CHECK%2c-INIT-and-END&quot;&gt;BEGIN, UNITCHECK, CHECK, INIT y END en perlmod&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="b8aea840d46b0e93fbdf7c5fc764686c8f3b8c58" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; to happen at compile time. The &lt;a href=&quot;#require-VERSION&quot;&gt;&lt;code&gt;require&lt;/code&gt;&lt;/a&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method any way it likes, though most modules just choose to derive their &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;a href=&quot;exporter&quot;&gt;&lt;code&gt;Exporter&lt;/code&gt;&lt;/a&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;a href=&quot;#import-LIST&quot;&gt;&lt;code&gt;import&lt;/code&gt;&lt;/a&gt; method can be found, then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38a9cf1f5e3f21b86fcbb8df98f12cbc38b145e5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">El &lt;code&gt;BEGIN&lt;/code&gt; fuerzas de la &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; a suceder en tiempo de compilaci&amp;oacute;n. El &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; asegura que el m&amp;oacute;dulo se cargue en la memoria si a&amp;uacute;n no lo ha hecho. La &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n no est&amp;aacute; incorporada; es solo una llamada a un m&amp;eacute;todo est&amp;aacute;tico ordinario en el paquete del &lt;code&gt;Module&lt;/code&gt; para decirle al m&amp;oacute;dulo que importe la lista de caracter&amp;iacute;sticas de nuevo al paquete actual. El m&amp;oacute;dulo puede implementar su m&amp;eacute;todo de &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n de la forma que desee, aunque la mayor&amp;iacute;a de los m&amp;oacute;dulos simplemente eligen derivar su m&amp;eacute;todo de &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n a trav&amp;eacute;s de la herencia de la clase &lt;code&gt;Exporter&lt;/code&gt; que se define en el m&amp;oacute;dulo &lt;code&gt;Exporter&lt;/code&gt; . Ver &lt;a href=&quot;exporter&quot;&gt;exportador&lt;/a&gt; . Si no &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; se puede encontrar el m&amp;eacute;todo de importaci&amp;oacute;n , luego se omite la llamada, incluso si hay un m&amp;eacute;todo AUTOLOAD.</target>
        </trans-unit>
        <trans-unit id="a9fa3a73043129ebc13296822d30d370f57d9e72" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; forces the &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; to happen at compile time. The &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; makes sure the module is loaded into memory if it hasn't been yet. The &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; is not a builtin; it's just an ordinary static method call into the &lt;code&gt;Module&lt;/code&gt; package to tell the module to import the list of features back into the current package. The module can implement its &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method any way it likes, though most modules just choose to derive their &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method via inheritance from the &lt;code&gt;Exporter&lt;/code&gt; class that is defined in the &lt;code&gt;Exporter&lt;/code&gt; module. See &lt;a href=&quot;../exporter&quot;&gt;Exporter&lt;/a&gt;. If no &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; method can be found then the call is skipped, even if there is an AUTOLOAD method.</source>
          <target state="translated">El &lt;code&gt;BEGIN&lt;/code&gt; fuerzas de la &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; a suceder en tiempo de compilaci&amp;oacute;n. El &lt;code&gt;&lt;a href=&quot;require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; asegura que el m&amp;oacute;dulo se cargue en la memoria si a&amp;uacute;n no lo ha hecho. La &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n no est&amp;aacute; incorporada; es solo una llamada a un m&amp;eacute;todo est&amp;aacute;tico ordinario en el paquete del &lt;code&gt;Module&lt;/code&gt; para decirle al m&amp;oacute;dulo que importe la lista de caracter&amp;iacute;sticas de nuevo al paquete actual. El m&amp;oacute;dulo puede implementar su m&amp;eacute;todo de &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n de la forma que desee, aunque la mayor&amp;iacute;a de los m&amp;oacute;dulos simplemente eligen derivar su m&amp;eacute;todo de &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n a trav&amp;eacute;s de la herencia de la clase &lt;code&gt;Exporter&lt;/code&gt; que se define en el m&amp;oacute;dulo &lt;code&gt;Exporter&lt;/code&gt; . Ver &lt;a href=&quot;../exporter&quot;&gt;exportador&lt;/a&gt; . Si no &lt;code&gt;&lt;a href=&quot;import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; se puede encontrar el m&amp;eacute;todo de importaci&amp;oacute;n , luego se omite la llamada, incluso si hay un m&amp;eacute;todo AUTOLOAD.</target>
        </trans-unit>
        <trans-unit id="9201471b5261b8b4c37aca6c270b666c4082753d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt; will assure that the loading of</source>
          <target state="translated">El &lt;code&gt;BEGIN&lt;/code&gt; asegurar&amp;aacute; que la carga de</target>
        </trans-unit>
        <trans-unit id="1df83aa021f2d25a04664c457983f82d52813309" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;BEGIN&lt;/code&gt;, &lt;code&gt;UNITCHECK&lt;/code&gt;, &lt;code&gt;CHECK&lt;/code&gt;, &lt;code&gt;INIT&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; subroutines are not so much subroutines as named special code blocks, of which you can have more than one in a package, and which you can &lt;b&gt;not&lt;/b&gt; call explicitly. See &lt;a href=&quot;perlmod#BEGIN%2C-UNITCHECK%2C-CHECK%2C-INIT-and-END&quot;&gt;&quot;BEGIN, UNITCHECK, CHECK, INIT and END&quot; in perlmod&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="08a5cc1adfa77075f0adc752b299d298837ebeee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt;, string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;, or string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="translated">Los bloques &lt;code&gt;CHECK&lt;/code&gt; e &lt;code&gt;INIT&lt;/code&gt; en el c&amp;oacute;digo compilado por &lt;code&gt;&lt;a href=&quot;functions/require&quot;&gt;require&lt;/a&gt;&lt;/code&gt; , string &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; o string &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; no se ejecutar&amp;aacute;n si ocurren despu&amp;eacute;s del final de la fase de compilaci&amp;oacute;n principal; eso puede ser un problema en mod_perl y otros entornos persistentes que usan esas funciones para cargar c&amp;oacute;digo en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="b104eb26cbd94be033237435dd68c95041e8eb25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CHECK&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; blocks in code compiled by &lt;code&gt;require&lt;/code&gt;, string &lt;code&gt;do&lt;/code&gt;, or string &lt;code&gt;eval&lt;/code&gt; will not be executed if they occur after the end of the main compilation phase; that can be a problem in mod_perl and other persistent environments which use those functions to load code at runtime.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="981efa7d62f736b9f150f24425de3b13fd11e4dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d8f4372f9a2ba513ea1d0d1264224c42f7ba97c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CNS11643&lt;/code&gt; encoding files are not complete. For common &lt;code&gt;CNS11643&lt;/code&gt; manipulation, please use &lt;code&gt;EUC-TW&lt;/code&gt; in &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode::HanExtra&lt;/a&gt;, which contains planes 1-7.</source>
          <target state="translated">Los archivos de codificaci&amp;oacute;n &lt;code&gt;CNS11643&lt;/code&gt; no est&amp;aacute;n completos. Para la manipulaci&amp;oacute;n com&amp;uacute;n de &lt;code&gt;CNS11643&lt;/code&gt; , utilice &lt;code&gt;EUC-TW&lt;/code&gt; en &lt;a href=&quot;http://search.cpan.org/perldoc/Encode::HanExtra&quot;&gt;Encode :: HanExtra&lt;/a&gt; , que contiene los planos 1-7.</target>
        </trans-unit>
        <trans-unit id="82651f5375f4780d1c104db566c2ac41e7d83b9e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;CORE&lt;/code&gt; namespace gives access to the original built-in functions of Perl. The &lt;code&gt;CORE&lt;/code&gt; package is built into Perl, and therefore you do not need to use or require a hypothetical &quot;CORE&quot; module prior to accessing routines in this namespace.</source>
          <target state="translated">El espacio de nombres &lt;code&gt;CORE&lt;/code&gt; da acceso a las funciones integradas originales de Perl. El paquete &lt;code&gt;CORE&lt;/code&gt; est&amp;aacute; integrado en Perl y, por lo tanto, no es necesario utilizar ni requerir un m&amp;oacute;dulo &quot;CORE&quot; hipot&amp;eacute;tico antes de acceder a las rutinas en este espacio de nombres.</target>
        </trans-unit>
        <trans-unit id="8ae42d583657def46159ee7ad1318ba4bd6a3fc1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Compress::Zlib&lt;/code&gt; module can be split into two general areas of functionality, namely a simple read/write interface to</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Compress::Zlib&lt;/code&gt; se puede dividir en dos &amp;aacute;reas generales de funcionalidad, a saber, una interfaz simple de lectura / escritura para</target>
        </trans-unit>
        <trans-unit id="46e8d3223a09166ecaf398dcfdae3710dcb3dcb7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DATA&lt;/code&gt; file handle by default has whatever PerlIO layers were in place when Perl read the file to parse the source. Normally that means that the file is being read bytewise, as if it were encoded in Latin-1, but there are two major ways for it to be otherwise. Firstly, if the &lt;code&gt;__END__&lt;/code&gt;/&lt;code&gt;__DATA__&lt;/code&gt; token is in the scope of a &lt;code&gt;use utf8&lt;/code&gt; pragma then the &lt;code&gt;DATA&lt;/code&gt; handle will be in UTF-8 mode. And secondly, if the source is being read from perl's standard input then the &lt;code&gt;DATA&lt;/code&gt; file handle is actually aliased to the &lt;code&gt;STDIN&lt;/code&gt; file handle, and may be in UTF-8 mode because of the &lt;code&gt;PERL_UNICODE&lt;/code&gt; environment variable or perl's command-line switches.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b6db4ade377c3bdb345b712f7106420996bb7261" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB::OUT&lt;/code&gt; filehandle is opened to</source>
          <target state="translated">El identificador de archivo &lt;code&gt;DB::OUT&lt;/code&gt; se abre para</target>
        </trans-unit>
        <trans-unit id="3f0a37f63cf06fefd13078baff9b2ef8733fd16b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DB&lt;/code&gt; and &lt;code&gt;main&lt;/code&gt; packages are always omitted, as are any &quot;private&quot; packages that have leading underscores in the namespace (e.g. &lt;code&gt;Foo::_private&lt;/code&gt;)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b7ced3778c80b0e6ddceec7627220df1317342e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DEBUG&lt;/code&gt; constant wipes the floor with even the &lt;code&gt;$debug&lt;/code&gt; variable, clocking in at minus zero seconds, and generates a &quot;warning: too few iterations for a reliable count&quot; message into the bargain. To see what is really going on, and why we had too few iterations when we thought we asked for 100000, we can use the very useful &lt;code&gt;B::Deparse&lt;/code&gt; to inspect the new code:</source>
          <target state="translated">La constante &lt;code&gt;DEBUG&lt;/code&gt; borra el piso incluso con la variable &lt;code&gt;$debug&lt;/code&gt; , registrando menos cero segundos, y genera un mensaje de &quot;advertencia: muy pocas iteraciones para un recuento confiable&quot; en la negociaci&amp;oacute;n. Para ver lo que realmente est&amp;aacute; sucediendo y por qu&amp;eacute; tuvimos muy pocas iteraciones cuando pensamos que pedimos 100000, podemos usar el muy &amp;uacute;til &lt;code&gt;B::Deparse&lt;/code&gt; para inspeccionar el nuevo c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="c9d4dcbece0076153dceb385297ea42930b3d2ab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DOES&lt;/code&gt; method returns</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;DOES&lt;/code&gt; regresa</target>
        </trans-unit>
        <trans-unit id="13b108bacf05fadc1d57d69518e2671634247ba4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Deparse&lt;/code&gt; flag makes Dump() run slower, since the XSUB implementation does not support it.</source>
          <target state="translated">El indicador &lt;code&gt;Deparse&lt;/code&gt; hace que Dump () se ejecute m&amp;aacute;s lento, ya que la implementaci&amp;oacute;n de XSUB no lo admite.</target>
        </trans-unit>
        <trans-unit id="1afec46de9e3c4185e7d2feb3396554e349575f1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::NYTProf&lt;/code&gt; and &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; modules can help you find uses of these problematic match variables in your code.</source>
          <target state="translated">Los m&amp;oacute;dulos &lt;code&gt;Devel::NYTProf&lt;/code&gt; y &lt;code&gt;Devel::FindAmpersand&lt;/code&gt; pueden ayudarlo a encontrar usos de estas variables de coincidencia problem&amp;aacute;ticas en su c&amp;oacute;digo.</target>
        </trans-unit>
        <trans-unit id="7a6b56d230ad8470a46e41fa3a6181ade20a4909" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel::SmallProf&lt;/code&gt; profiler examines the runtime of your Perl program and produces a line-by-line listing to show how many times each line was called, and how long each line took to execute. It is called by supplying the familiar &lt;code&gt;-d&lt;/code&gt; flag to Perl at runtime.</source>
          <target state="translated">El &lt;code&gt;Devel::SmallProf&lt;/code&gt; perfiles Devel :: SmallProf examina el tiempo de ejecuci&amp;oacute;n de su programa Perl y produce una lista l&amp;iacute;nea por l&amp;iacute;nea para mostrar cu&amp;aacute;ntas veces se llam&amp;oacute; a cada l&amp;iacute;nea y cu&amp;aacute;nto tiempo tard&amp;oacute; en ejecutarse. Se llama proporcionando el distintivo &lt;code&gt;-d&lt;/code&gt; familiar a Perl en tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="e3e899b88f5d9c103f9957a381fb75493e4ca219" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Devel&lt;/code&gt; namespace has several modules which you can use to profile your Perl programs.</source>
          <target state="translated">El espacio de nombres de &lt;code&gt;Devel&lt;/code&gt; tiene varios m&amp;oacute;dulos que puede utilizar para perfilar sus programas Perl.</target>
        </trans-unit>
        <trans-unit id="f7b3b4bbb4e3a91049c3f2bf1c1599a52a4bab75" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; interface is based on the interface originally developed by Neil Winton for his &lt;code&gt;MD5&lt;/code&gt; module.</source>
          <target state="translated">La interfaz &lt;code&gt;Digest::&lt;/code&gt; se basa en la interfaz desarrollada originalmente por Neil Winton para su m&amp;oacute;dulo &lt;code&gt;MD5&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="359f33360a7a83f14790bf4d659bef0945120eaf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::&lt;/code&gt; modules calculate digests, also called &quot;fingerprints&quot; or &quot;hashes&quot;, of some data, called a message. The digest is (usually) some small/fixed size string. The actual size of the digest depend of the algorithm used. The message is simply a sequence of arbitrary bytes or bits.</source>
          <target state="translated">Los m&amp;oacute;dulos &lt;code&gt;Digest::&lt;/code&gt; calculan res&amp;uacute;menes, tambi&amp;eacute;n llamados &quot;huellas digitales&quot; o &quot;hashes&quot;, de algunos datos, llamados mensajes. El resumen es (generalmente) una cadena de tama&amp;ntilde;o peque&amp;ntilde;o / fijo. El tama&amp;ntilde;o real del resumen depende del algoritmo utilizado. El mensaje es simplemente una secuencia de bytes o bits arbitrarios.</target>
        </trans-unit>
        <trans-unit id="5112b49f2609b19e911cd2f6a34cb7ffa7088cff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module allows you to use the RSA Data Security Inc. MD5 Message Digest algorithm from within Perl programs. The algorithm takes as input a message of arbitrary length and produces as output a 128-bit &quot;fingerprint&quot; or &quot;message digest&quot; of the input.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Digest::MD5&lt;/code&gt; permite utilizar el algoritmo MD5 Message Digest de RSA Data Security Inc. desde los programas de Perl. El algoritmo toma como entrada un mensaje de longitud arbitraria y produce como salida una &quot;huella dactilar&quot; o un &quot;resumen del mensaje&quot; de la entrada.</target>
        </trans-unit>
        <trans-unit id="2adafeb0e9eb580775e9922353cdda9ed2fef18a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module is written by Gisle Aas &amp;lt;gisle@ActiveState.com&amp;gt;.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Digest::MD5&lt;/code&gt; est&amp;aacute; escrito por Gisle Aas &amp;lt;gisle@ActiveState.com&amp;gt;.</target>
        </trans-unit>
        <trans-unit id="048cfda097524929fcf424f6794f7c010276767b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::MD5&lt;/code&gt; module provide a procedural interface for simple use, as well as an object oriented interface that can handle messages of arbitrary length and which can read files directly.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Digest::MD5&lt;/code&gt; proporciona una interfaz de procedimiento para un uso sencillo, as&amp;iacute; como una interfaz orientada a objetos que puede manejar mensajes de longitud arbitraria y que puede leer archivos directamente.</target>
        </trans-unit>
        <trans-unit id="417545c4adfbc434083e36d20bccbfb0f99aa98e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt; , and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt; .</source>
          <target state="translated">La clase &lt;code&gt;Digest::base&lt;/code&gt; proporciona implementaciones de los m&amp;eacute;todos &lt;code&gt;addfile&lt;/code&gt; y &lt;code&gt;add_bits&lt;/code&gt; en t&amp;eacute;rminos de &lt;code&gt;add&lt;/code&gt; , y de los m&amp;eacute;todos &lt;code&gt;hexdigest&lt;/code&gt; y &lt;code&gt;b64digest&lt;/code&gt; en t&amp;eacute;rminos de &lt;code&gt;digest&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="1c6996a284acc9e86940a92ab690a3ac4f18b4dc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Digest::base&lt;/code&gt; class provide implementations of the methods &lt;code&gt;addfile&lt;/code&gt; and &lt;code&gt;add_bits&lt;/code&gt; in terms of &lt;code&gt;add&lt;/code&gt;, and of the methods &lt;code&gt;hexdigest&lt;/code&gt; and &lt;code&gt;b64digest&lt;/code&gt; in terms of &lt;code&gt;digest&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="628d5f24b15638f2c6ff193717192cc425ae4155" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;DirHandle&lt;/code&gt; method provide an alternative interface to the opendir(), closedir(), readdir(), and rewinddir() functions.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;DirHandle&lt;/code&gt; proporciona una interfaz alternativa a las funciones opendir (), closedir (), readdir () y rewinddir ().</target>
        </trans-unit>
        <trans-unit id="358ca39e53232388840862f052183678f86697cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt; . And &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; will call &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;Dump()&lt;/code&gt; toma uno o dos argumentos: algo para volcar y un l&amp;iacute;mite opcional para elementos de recursi&amp;oacute;n y matriz (el valor predeterminado es 4). El primer argumento se eval&amp;uacute;a en el contexto escalar rvalue, con excepciones para @array y% hash, que descargan la matriz o el propio hash. Entonces &lt;code&gt;Dump @array&lt;/code&gt; funciona, al igual que &lt;code&gt;Dump $foo&lt;/code&gt; . Y &lt;code&gt;Dump &lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; llamar&amp;aacute; a &lt;code&gt;&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;&lt;/code&gt; en el contexto rvalue, mientras que &lt;code&gt;Dump ${\&lt;a href=&quot;../functions/pos&quot;&gt;pos&lt;/a&gt;}&lt;/code&gt; lo llamar&amp;aacute; en el contexto lvalue.</target>
        </trans-unit>
        <trans-unit id="a13938ff22176b323e1b3258e2271152d9209b89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function takes one or two arguments: something to dump, and an optional limit for recursion and array elements (default is 4). The first argument is evaluted in rvalue scalar context, with exceptions for @array and %hash, which dump the array or hash itself. So &lt;code&gt;Dump @array&lt;/code&gt; works, as does &lt;code&gt;Dump $foo&lt;/code&gt;. And &lt;code&gt;Dump pos&lt;/code&gt; will call &lt;code&gt;pos&lt;/code&gt; in rvalue context, whereas &lt;code&gt;Dump ${\pos}&lt;/code&gt; will call it in lvalue context.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cdbf79b7555598c068ba8d9743bee2fb95392923" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Dump()&lt;/code&gt; function, by default, dumps up to 4 elements from a toplevel array or hash. This number can be increased by supplying a second argument to the function.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;Dump()&lt;/code&gt; , por defecto, vuelca hasta 4 elementos de una matriz de nivel superior o hash. Este n&amp;uacute;mero se puede aumentar proporcionando un segundo argumento a la funci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="c95778d99c76e8e03e061209f2b6b5768436be5a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;END&lt;/code&gt; block isn't called when untrapped signals kill the program, though, so if you use &lt;code&gt;END&lt;/code&gt; blocks you should also use</source>
          <target state="translated">Sin embargo, el bloque &lt;code&gt;END&lt;/code&gt; no se llama cuando las se&amp;ntilde;ales no atrapadas matan el programa, por lo que si usa bloques &lt;code&gt;END&lt;/code&gt; tambi&amp;eacute;n debe usar</target>
        </trans-unit>
        <trans-unit id="f434d74067f98a36c01cbe9c20f7d7cf7b02ed54" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;EXPR&lt;/code&gt; following the modifier is referred to as the &quot;condition&quot;. Its truth or falsehood determines how the modifier will behave.</source>
          <target state="translated">El &lt;code&gt;EXPR&lt;/code&gt; que sigue al modificador se denomina &quot;condici&amp;oacute;n&quot;. Su verdad o falsedad determina c&amp;oacute;mo se comportar&amp;aacute; el modificador.</target>
        </trans-unit>
        <trans-unit id="0be035a23dc6f5f75a5bb7fdc10fe00056028240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module knows about many encodings and has interfaces for doing conversions between those encodings:</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Encode&lt;/code&gt; conoce muchas codificaciones y tiene interfaces para realizar conversiones entre esas codificaciones:</target>
        </trans-unit>
        <trans-unit id="5cdf933f51543c5ce4713919bd68bbd3f797378f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Encode&lt;/code&gt; module provides the interface between Perl strings and the rest of the system. Perl strings are sequences of</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Encode&lt;/code&gt; proporciona la interfaz entre las cadenas de Perl y el resto del sistema. Las cadenas de Perl son secuencias de</target>
        </trans-unit>
        <trans-unit id="4968644a1dddd78111692e0824f91d81d4b5fde6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ) to scalars. If the &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;Env::import()&lt;/code&gt; vincula las variables de entorno con nombres adecuados a las variables globales de Perl con los mismos nombres. De forma predeterminada, vincula todas las variables de entorno existentes ( &lt;code&gt;&lt;a href=&quot;functions/keys&quot;&gt;keys&lt;/a&gt; %ENV&lt;/code&gt; ) a escalares. Si la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/import&quot;&gt;import&lt;/a&gt;&lt;/code&gt; aci&amp;oacute;n recibe argumentos, los toma como una lista de variables para vincular; est&amp;aacute; bien si a&amp;uacute;n no existen. El prefijo de tipo escalar '$' se infiere para cualquier elemento de esta lista que no tenga el prefijo '$' o '@'. Las matrices se implementan en t&amp;eacute;rminos de &lt;code&gt;&lt;a href=&quot;functions/split&quot;&gt;split&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/join&quot;&gt;join&lt;/a&gt;&lt;/code&gt; , usando &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; como delimitador.</target>
        </trans-unit>
        <trans-unit id="5d5e15ad1a58fa2627594efcd21d9bd55ca58029" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Env::import()&lt;/code&gt; function ties environment variables with suitable names to global Perl variables with the same names. By default it ties all existing environment variables (&lt;code&gt;keys %ENV&lt;/code&gt;) to scalars. If the &lt;code&gt;import&lt;/code&gt; function receives arguments, it takes them to be a list of variables to tie; it's okay if they don't yet exist. The scalar type prefix '$' is inferred for any element of this list not prefixed by '$' or '@'. Arrays are implemented in terms of &lt;code&gt;split&lt;/code&gt; and &lt;code&gt;join&lt;/code&gt;, using &lt;code&gt;$Config::Config{path_sep}&lt;/code&gt; as the delimiter.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2cb5e18a95e482684c2bead13158da2042ed8e01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtUtils::ParseXS&lt;/code&gt; object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="04fe8159aef76b700007013f5b9be387367b2a84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ExtraFieldLocal&lt;/code&gt; option is used to store additional metadata in the local header for the zip file/buffer. The &lt;code&gt;ExtraFieldCentral&lt;/code&gt; does the same for the matching central header.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;ExtraFieldLocal&lt;/code&gt; se usa para almacenar metadatos adicionales en el encabezado local para el archivo zip / b&amp;uacute;fer. El &lt;code&gt;ExtraFieldCentral&lt;/code&gt; hace lo mismo para la cabecera central de juego.</target>
        </trans-unit>
        <trans-unit id="7dceaf4fc99f40b45472fc6396adb3cf093b19ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt; /&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt; /&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="translated">El par &lt;code&gt;FREETMPS&lt;/code&gt; / &lt;code&gt;LEAVE&lt;/code&gt; eliminar&amp;aacute; cualquier valor devuelto por la subrutina Perl (vea el siguiente ejemplo), adem&amp;aacute;s de que tambi&amp;eacute;n volcar&amp;aacute; los SV mortales que hemos creado. Tener &lt;code&gt;ENTER&lt;/code&gt; / &lt;code&gt;SAVETMPS&lt;/code&gt; al principio del c&amp;oacute;digo asegura que ning&amp;uacute;n otro mortal sea destruido.</target>
        </trans-unit>
        <trans-unit id="140fe01c0b7ba42e4663eeef8254f0e842ecf849" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREETMPS&lt;/code&gt;/&lt;code&gt;LEAVE&lt;/code&gt; pair will get rid of any values returned by the Perl subroutine (see next example), plus it will also dump the mortal SVs we have created. Having &lt;code&gt;ENTER&lt;/code&gt;/&lt;code&gt;SAVETMPS&lt;/code&gt; at the beginning of the code makes sure that no other mortals are destroyed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a6ea08916fc715ad11c85a7aa69540693ba076ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;FREEZE&lt;/code&gt; method can return any number of values (i.e. zero or more). These values and the paclkage/classname of the object will then be encoded as a tagged JSON value in the following format:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="577b209cddb0e754330f4709ee24d502c593af10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;G_RETHROW&lt;/code&gt; flag can be used if you only need eval_sv() to execute code specified by a string, but not catch any errors.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94e4c30b0dc82b24659a532f35106fc4afecb721" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Host&lt;/code&gt; header is generated from the URL in accordance with RFC 2616. It is a fatal error to specify &lt;code&gt;Host&lt;/code&gt; in the &lt;code&gt;headers&lt;/code&gt; option. Other headers may be ignored or overwritten if necessary for transport compliance.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1e824605b84cee8c0b954423f3ab5ef2eb2758b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt; /&lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="translated">Las palabras clave &lt;code&gt;IN&lt;/code&gt; / &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; se pueden mezclar con declaraciones de estilo ANSI, como en</target>
        </trans-unit>
        <trans-unit id="9f81634b914a660a9d16e3716c6017257055b0e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN&lt;/code&gt;/&lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; keywords can be mixed with ANSI-style declarations, as in</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2291d3950c0f7a1274711a429d0d47b0e9604c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INPUT&lt;/code&gt; and &lt;code&gt;OUTPUT&lt;/code&gt; sections have identical formats, that is, each unindented line starts a new in- or output map respectively. A new in- or output map must start with the name of the XS type to map on a line by itself, followed by the code that implements it indented on the following lines. Example:</source>
          <target state="translated">Las secciones &lt;code&gt;INPUT&lt;/code&gt; y &lt;code&gt;OUTPUT&lt;/code&gt; tienen formatos id&amp;eacute;nticos, es decir, cada l&amp;iacute;nea sin sangr&amp;iacute;a inicia un nuevo mapa de entrada o salida, respectivamente. Un nuevo mapa de entrada o salida debe comenzar con el nombre del tipo XS a mapear en una l&amp;iacute;nea por s&amp;iacute; mismo, seguido del c&amp;oacute;digo que lo implementa sangrado en las siguientes l&amp;iacute;neas. Ejemplo:</target>
        </trans-unit>
        <trans-unit id="0839ebfa51c8f90f143d226a6a7f33a7ff311878" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="translated">La macro &lt;code&gt;INT2PTR&lt;/code&gt; (definida en perl.h) lanza un n&amp;uacute;mero entero a un puntero de un tipo dado, teniendo en cuenta los posibles tama&amp;ntilde;os diferentes de n&amp;uacute;meros enteros y punteros. Tambi&amp;eacute;n hay &lt;code&gt;PTR2IV&lt;/code&gt; , &lt;code&gt;PTR2UV&lt;/code&gt; , &lt;code&gt;PTR2NV&lt;/code&gt; , para mapear de otra manera, que pueden ser &amp;uacute;tiles en las secciones de SALIDA.</target>
        </trans-unit>
        <trans-unit id="8dee4e81117d0288fc40b8cb09d886277f261bfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;INT2PTR&lt;/code&gt; macro (defined in perl.h) casts an integer to a pointer of a given type, taking care of the possible different size of integers and pointers. There are also &lt;code&gt;PTR2IV&lt;/code&gt;, &lt;code&gt;PTR2UV&lt;/code&gt;, &lt;code&gt;PTR2NV&lt;/code&gt; macros, to map the other way, which may be useful in OUTPUT sections.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7466a438605e61935ae6328f4fe2d9214ef781c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;&quot;The &amp;amp; Unary Operator&quot;&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3A-Keyword&quot;&gt;&quot;The OUTPUT: Keyword&quot;&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="61f85903ef5f9040c0ff99931c044e8d15426a65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IN_OUT&lt;/code&gt; parameters are identical with parameters introduced with &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; and put into the &lt;code&gt;OUTPUT:&lt;/code&gt; section (see &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;The OUTPUT: Keyword&lt;/a&gt;). The &lt;code&gt;IN_OUTLIST&lt;/code&gt; parameters are very similar, the only difference being that the value C function writes through the pointer would not modify the Perl parameter, but is put in the output list.</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;IN_OUT&lt;/code&gt; son id&amp;eacute;nticos a los par&amp;aacute;metros introducidos con &lt;a href=&quot;#The-%26-Unary-Operator&quot;&gt;The &amp;amp; Unary Operator&lt;/a&gt; y colocados en la secci&amp;oacute;n &lt;code&gt;OUTPUT:&lt;/code&gt; (ver &lt;a href=&quot;#The-OUTPUT%3a-Keyword&quot;&gt;The OUTPUT: Keyword&lt;/a&gt; ). Los par&amp;aacute;metros &lt;code&gt;IN_OUTLIST&lt;/code&gt; son muy similares, la &amp;uacute;nica diferencia es que el valor que la funci&amp;oacute;n C escribe a trav&amp;eacute;s del puntero no modificar&amp;iacute;a el par&amp;aacute;metro Perl, sino que se coloca en la lista de salida.</target>
        </trans-unit>
        <trans-unit id="e01d4a34408ea1bec61899bb0715159c8fcfc543" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Dir&lt;/code&gt; package provides two interfaces to perl's directory reading routines.</source>
          <target state="translated">El paquete &lt;code&gt;IO::Dir&lt;/code&gt; proporciona dos interfaces para las rutinas de lectura de directorios de perl.</target>
        </trans-unit>
        <trans-unit id="2e8c3db24464dee992cbd4fb5389ee4e7af6c03b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="translated">El paquete &lt;code&gt;IO::Select&lt;/code&gt; implementa un enfoque de objeto para la llamada a la funci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;../functions/select&quot;&gt;select&lt;/a&gt;&lt;/code&gt; del sistema . Permite al usuario ver qu&amp;eacute; maneja IO, ver &lt;a href=&quot;handle&quot;&gt;IO :: Handle&lt;/a&gt; , est&amp;aacute; listo para leer, escribir o tener una excepci&amp;oacute;n pendiente.</target>
        </trans-unit>
        <trans-unit id="d4a23c694ba8531eb134632f2092cafc7861a78d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IO::Select&lt;/code&gt; package implements an object approach to the system &lt;code&gt;select&lt;/code&gt; function call. It allows the user to see what IO handles, see &lt;a href=&quot;IO::Handle&quot;&gt;IO::Handle&lt;/a&gt;, are ready for reading, writing or have an exception pending.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5b99267c0bd0ea1d7a95c4de6c3170224a12616" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;IVdf&lt;/code&gt; will expand to whatever is the correct format for the IVs. Note that the spaces are required around the format in case the code is compiled with C++, to maintain compliance with its standard.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="93e9868cf44653a0a473010fe2cd91001e0a676d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt; , to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="translated">El m&amp;oacute;dulo de &lt;code&gt;Interpolation&lt;/code&gt; tambi&amp;eacute;n puede hacer mucha magia por ti. Puede especificar un nombre de variable, en este caso &lt;code&gt;E&lt;/code&gt; , para configurar un hash vinculado que haga la interpolaci&amp;oacute;n por usted. Tambi&amp;eacute;n tiene varios otros m&amp;eacute;todos para hacer esto.</target>
        </trans-unit>
        <trans-unit id="329ab637f04429657f9fe6aaf5dca20594f33c89" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Interpolation&lt;/code&gt; module can also do a lot of magic for you. You can specify a variable name, in this case &lt;code&gt;E&lt;/code&gt;, to set up a tied hash that does the interpolation for you. It has several other methods to do this as well.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d3bc590cafc9b13c0e888463643b3750cf44fd73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; , or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; substitutions; and case-independent regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="translated">El entorno local &lt;code&gt;LC_CTYPE&lt;/code&gt; tambi&amp;eacute;n proporciona el mapa que se utiliza para transliterar caracteres entre min&amp;uacute;sculas y may&amp;uacute;sculas. Esto afecta a las funciones de mapeo de may&amp;uacute;sculas y min&amp;uacute;sculas: &lt;code&gt;&lt;a href=&quot;functions/fc&quot;&gt;fc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lc&quot;&gt;lc()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/lcfirst&quot;&gt;lcfirst()&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/uc&quot;&gt;uc()&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/ucfirst&quot;&gt;ucfirst()&lt;/a&gt;&lt;/code&gt; ; interpolaci&amp;oacute;n de mapeo de casos con &lt;code&gt;\F&lt;/code&gt; , &lt;code&gt;\l&lt;/code&gt; , &lt;code&gt;\L&lt;/code&gt; , &lt;code&gt;\u&lt;/code&gt; o &lt;code&gt;\U&lt;/code&gt; en cadenas entre comillas dobles y sustituciones &lt;code&gt;&lt;a href=&quot;functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; ; y coincidencia de patrones de expresi&amp;oacute;n regular independiente de may&amp;uacute;sculas y min&amp;uacute;sculas utilizando el modificador &lt;code&gt;i&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="bc3c541f503e52e8ac4f6d3ffd90d52fc4128eb9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_CTYPE&lt;/code&gt; locale also provides the map used in transliterating characters between lower and uppercase. This affects the case-mapping functions--&lt;code&gt;fc()&lt;/code&gt;, &lt;code&gt;lc()&lt;/code&gt;, &lt;code&gt;lcfirst()&lt;/code&gt;, &lt;code&gt;uc()&lt;/code&gt;, and &lt;code&gt;ucfirst()&lt;/code&gt;; case-mapping interpolation with &lt;code&gt;\F&lt;/code&gt;, &lt;code&gt;\l&lt;/code&gt;, &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\u&lt;/code&gt;, or &lt;code&gt;\U&lt;/code&gt; in double-quoted strings and &lt;code&gt;s///&lt;/code&gt; substitutions; and case-insensitive regular expression pattern matching using the &lt;code&gt;i&lt;/code&gt; modifier.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="941219cd505be61ac26ba8728d69370c60e37046" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LC_NUMERIC&lt;/code&gt; controls the numeric output:</source>
          <target state="translated">El &lt;code&gt;LC_NUMERIC&lt;/code&gt; controla la salida num&amp;eacute;rica:</target>
        </trans-unit>
        <trans-unit id="412121500ef04a2233556ed3ed8bb5c784494003" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;LimitOutput&lt;/code&gt; cambia el comportamiento del m&amp;eacute;todo &lt;code&gt;$i-&amp;gt;bzinflate&lt;/code&gt; para que la cantidad de memoria utilizada por el b&amp;uacute;fer de salida pueda ser limitada.</target>
        </trans-unit>
        <trans-unit id="1b18a1d213993f63112fefb5d5804b6552cbf33b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option changes the behavior of the &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; method so that the amount of memory used by the output buffer can be limited.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;LimitOutput&lt;/code&gt; cambia el comportamiento del m&amp;eacute;todo &lt;code&gt;$i-&amp;gt;inflate&lt;/code&gt; para que la cantidad de memoria utilizada por el b&amp;uacute;fer de salida pueda ser limitada.</target>
        </trans-unit>
        <trans-unit id="3600b0d3775b442853dade84e908851ee6d60512" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;LimitOutput&lt;/code&gt; option is designed to help with this use-case.</source>
          <target state="translated">La opci&amp;oacute;n &lt;code&gt;LimitOutput&lt;/code&gt; est&amp;aacute; dise&amp;ntilde;ada para ayudar con este caso de uso.</target>
        </trans-unit>
        <trans-unit id="4e39cafde8d7c8f339d79044ffb14c41f2b59abf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Listen&lt;/code&gt; parameter is set to the maximum number of pending connections we can accept until we turn away incoming clients. Think of it as a call-waiting queue for your telephone. The low-level Socket module has a special symbol for the system maximum, which is SOMAXCONN.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;Listen&lt;/code&gt; se establece en el n&amp;uacute;mero m&amp;aacute;ximo de conexiones pendientes que podemos aceptar hasta que rechacemos los clientes entrantes. Piense en ello como una cola de llamadas en espera para su tel&amp;eacute;fono. El m&amp;oacute;dulo Socket de bajo nivel tiene un s&amp;iacute;mbolo especial para el m&amp;aacute;ximo del sistema, que es SOMAXCONN.</target>
        </trans-unit>
        <trans-unit id="39d8f8a92949aebb617dd074e69f347a559dd1fc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Country&lt;/code&gt; module provides access to several code sets that can be used for identifying countries, such as those defined in ISO 3166-1.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Locale::Country&lt;/code&gt; proporciona acceso a varios conjuntos de c&amp;oacute;digos que se pueden utilizar para identificar pa&amp;iacute;ses, como los definidos en ISO 3166-1.</target>
        </trans-unit>
        <trans-unit id="7ce570b70dc3b1217c7829eb357747faae317306" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Currency&lt;/code&gt; module provides access to standard codes used for identifying currencies and funds, such as those defined in ISO 4217.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Locale::Currency&lt;/code&gt; proporciona acceso a c&amp;oacute;digos est&amp;aacute;ndar que se utilizan para identificar monedas y fondos, como los definidos en ISO 4217.</target>
        </trans-unit>
        <trans-unit id="e1ffcce2675347ee9e15ffb62b7a866fc9499f7b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Language&lt;/code&gt; module provides access to standard codes used for identifying languages, such as those as defined in ISO 639.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Locale::Language&lt;/code&gt; proporciona acceso a c&amp;oacute;digos est&amp;aacute;ndar que se utilizan para identificar idiomas, como los definidos en ISO 639.</target>
        </trans-unit>
        <trans-unit id="aa76c519ff8997e91915d966da6aed9450ba1a90" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Locale::Script&lt;/code&gt; module provides access to standards codes used for identifying scripts, such as those defined in ISO 15924.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Locale::Script&lt;/code&gt; proporciona acceso a los c&amp;oacute;digos de est&amp;aacute;ndares utilizados para identificar los scripts, como los definidos en ISO 15924.</target>
        </trans-unit>
        <trans-unit id="e8120d017d19784f5ec18621659dfbf762367c0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;MGVTBL&lt;/code&gt; has five (or sometimes eight) pointers to the following routine types:</source>
          <target state="translated">El &lt;code&gt;MGVTBL&lt;/code&gt; tiene cinco (o en ocasiones ocho) indicadores para los siguientes tipos de rutinas:</target>
        </trans-unit>
        <trans-unit id="cb0939f4e09d7100879a1f0cd7a45d518f685d85" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;Math::Complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62960d717ea2191ee6cb352f5b362492a57f4b7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Math::Trig&lt;/code&gt; handles this by using the &lt;code&gt;Math::Complex&lt;/code&gt; package which knows how to handle complex numbers, please see &lt;a href=&quot;complex&quot;&gt;Math::Complex&lt;/a&gt; for more information. In practice you need not to worry about getting complex numbers as results because the &lt;code&gt;Math::Complex&lt;/code&gt; takes care of details like for example how to display complex numbers. For example:</source>
          <target state="translated">La &lt;code&gt;Math::Trig&lt;/code&gt; maneja esto mediante el uso de la &lt;code&gt;Math::Complex&lt;/code&gt; paquete que sabe c&amp;oacute;mo manejar n&amp;uacute;meros complejos, por favor ver &lt;a href=&quot;complex&quot;&gt;Matem&amp;aacute;ticas :: Complejo&lt;/a&gt; para m&amp;aacute;s informaci&amp;oacute;n. En la pr&amp;aacute;ctica, no debe preocuparse por obtener n&amp;uacute;meros complejos como resultados porque &lt;code&gt;Math::Complex&lt;/code&gt; se encarga de detalles como, por ejemplo, c&amp;oacute;mo mostrar n&amp;uacute;meros complejos. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="59d3e5116a50776a62b5e7307aca3591f0689480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">Los autores de &lt;code&gt;Moose&lt;/code&gt; esperan que alg&amp;uacute;n d&amp;iacute;a &lt;code&gt;Moo&lt;/code&gt; pueda quedar obsoleto mejorando &lt;code&gt;Moose&lt;/code&gt; lo suficiente, pero por ahora proporciona una alternativa valiosa a &lt;code&gt;Moose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="cd61d23b6e3309b14f23bde3328a9b1cfdb75d47" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Moose&lt;/code&gt; authors hope that one day &lt;code&gt;Moo&lt;/code&gt; can be made obsolete by improving &lt;code&gt;Moose&lt;/code&gt; enough, but for now it provides a worthwhile alternative to &lt;code&gt;Moose&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bc9a3a0a2d0497d18f72b7ad30f16ed602816e32" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NEXT&lt;/code&gt; module adds a pseudoclass named &lt;code&gt;NEXT&lt;/code&gt; to any program that uses it. If a method &lt;code&gt;m&lt;/code&gt; calls &lt;code&gt;$self-&amp;gt;NEXT::m()&lt;/code&gt;, the call to &lt;code&gt;m&lt;/code&gt; is redispatched as if the calling method had not originally been found.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5cda22c66d7ae69cf0c1a687755ef0ea97e644b2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;NNTP&lt;/code&gt; protocol uses the &lt;code&gt;WILDMAT&lt;/code&gt; format for patterns. The WILDMAT format was first developed by Rich Salz based on the format used in the UNIX &quot;find&quot; command to articulate file names. It was developed to provide a uniform mechanism for matching patterns in the same manner that the UNIX shell matches filenames.</source>
          <target state="translated">El protocolo &lt;code&gt;NNTP&lt;/code&gt; usa el formato &lt;code&gt;WILDMAT&lt;/code&gt; para patrones. El formato WILDMAT fue desarrollado por primera vez por Rich Salz basado en el formato utilizado en el comando &quot;buscar&quot; de UNIX para articular nombres de archivos. Fue desarrollado para proporcionar un mecanismo uniforme para hacer coincidir patrones de la misma manera que el shell de UNIX coincide con los nombres de archivo.</target>
        </trans-unit>
        <trans-unit id="8856a9c3b92894fbca75a7c6a84e03f49c7d82b9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Net::FTP&lt;/code&gt; module provides two low-level methods called &lt;code&gt;stor&lt;/code&gt; and &lt;code&gt;retr&lt;/code&gt; that both return filehandles. These filehandles can used with the &lt;code&gt;IO::Compress/Uncompress&lt;/code&gt; modules to compress or uncompress files read from or written to an FTP Server on the fly, without having to create a temporary file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="812543816e7e36906e0a41744e1b881bd6061a33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt; ) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;O::import&lt;/code&gt; carga el m&amp;oacute;dulo &lt;code&gt;B::Backend&lt;/code&gt; apropiado y llama a su funci&amp;oacute;n de &lt;code&gt;compile&lt;/code&gt; , pas&amp;aacute;ndole OPTIONS. Se espera que esa funci&amp;oacute;n devuelva una sub referencia a la que llamaremos CALLBACK. A continuaci&amp;oacute;n, se activa la bandera de &quot;s&amp;oacute;lo compilaci&amp;oacute;n&quot; (equivalente a la opci&amp;oacute;n de l&amp;iacute;nea de comandos &lt;code&gt;-c&lt;/code&gt; ) y se registra un bloque CHECK que llama a CALLBACK. As&amp;iacute;, el programa principal de Perl mencionado en la l&amp;iacute;nea de comandos se lee, analiza y compila en forma de &amp;aacute;rbol de sintaxis interno. Dado que el indicador &lt;code&gt;-c&lt;/code&gt; est&amp;aacute; establecido, el programa no comienza a ejecutarse (excepto los bloques BEGIN, por supuesto), pero se llama a la funci&amp;oacute;n CALLBACK registrada por el backend del compilador.</target>
        </trans-unit>
        <trans-unit id="d7e78f61b2ef3885efb7f8bb2d5b2723a7d2f5bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;O::import&lt;/code&gt; function loads the appropriate &lt;code&gt;B::Backend&lt;/code&gt; module and calls its &lt;code&gt;compile&lt;/code&gt; function, passing it OPTIONS. That function is expected to return a sub reference which we'll call CALLBACK. Next, the &quot;compile-only&quot; flag is switched on (equivalent to the command-line option &lt;code&gt;-c&lt;/code&gt;) and a CHECK block is registered which calls CALLBACK. Thus the main Perl program mentioned on the command-line is read in, parsed and compiled into internal syntax tree form. Since the &lt;code&gt;-c&lt;/code&gt; flag is set, the program does not start running (excepting BEGIN blocks of course) but the CALLBACK function registered by the compiler backend is called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d373b71890ff94863d227c7cfce5d1d697b7746" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OP *&lt;/code&gt; is op_free()ed at the end of</source>
          <target state="translated">El &lt;code&gt;OP *&lt;/code&gt; es op_free () ed al final de</target>
        </trans-unit>
        <trans-unit id="998cf5d3020bb78a9ba1d3cad328d90e354a7767" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt; /&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt; /&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;OUTLIST&lt;/code&gt; / &lt;code&gt;OUT&lt;/code&gt; difiere de los par&amp;aacute;metros &lt;code&gt;IN_OUTLIST&lt;/code&gt; / &lt;code&gt;IN_OUT&lt;/code&gt; solo porque el valor inicial del par&amp;aacute;metro Perl no se lee (y no se le da a la funci&amp;oacute;n C, que en su lugar obtiene algo de basura). Por ejemplo, la misma funci&amp;oacute;n C anterior se puede interconectar como</target>
        </trans-unit>
        <trans-unit id="77d530437d7fdd465ebf5f4d28d1ba3ab2ce9989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;OUTLIST&lt;/code&gt;/&lt;code&gt;OUT&lt;/code&gt; parameter differ from &lt;code&gt;IN_OUTLIST&lt;/code&gt;/&lt;code&gt;IN_OUT&lt;/code&gt; parameters only by the initial value of the Perl parameter not being read (and not being given to the C function - which gets some garbage instead). For example, the same C function as above can be interfaced with as</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0628c399d26c3378a27108a14e1ac2344b8aefb0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt; , perl's &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt; . The full prototype is as follows:</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;Open()&lt;/code&gt; tiene muchos argumentos porque combina las funciones de perl's &lt;code&gt;&lt;a href=&quot;functions/open&quot;&gt;open&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;PerlIO_open&lt;/code&gt; , perl's &lt;code&gt;&lt;a href=&quot;functions/sysopen&quot;&gt;sysopen&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;PerlIO_fdopen&lt;/code&gt; y &lt;code&gt;PerlIO_reopen&lt;/code&gt; . El prototipo completo es el siguiente:</target>
        </trans-unit>
        <trans-unit id="a364ca34d8039b509a216c6b70daa6a333bd164c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Open()&lt;/code&gt; method has lots of arguments because it combines the functions of perl's &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;PerlIO_open&lt;/code&gt;, perl's &lt;code&gt;sysopen&lt;/code&gt;, &lt;code&gt;PerlIO_fdopen&lt;/code&gt; and &lt;code&gt;PerlIO_reopen&lt;/code&gt;. The full prototype is as follows:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b50db457121e66e0a351ce78b3a957dc8ab0fb3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL5DB&lt;/code&gt; environment variable can be used to define a debugger. For example, the minimal &quot;working&quot; debugger (it actually doesn't do anything) consists of one line:</source>
          <target state="translated">La variable de entorno &lt;code&gt;PERL5DB&lt;/code&gt; se puede utilizar para definir un depurador. Por ejemplo, el depurador &quot;en funcionamiento&quot; m&amp;iacute;nimo (en realidad no hace nada) consta de una l&amp;iacute;nea:</target>
        </trans-unit>
        <trans-unit id="d2bc99a442d5c0b29501891792cdc1fff80da05a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; and &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; magic types are defined specifically for use by extensions and will not be used by perl itself. Extensions can use &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic to 'attach' private information to variables (typically objects). This is especially useful because there is no way for normal perl code to corrupt this private information (unlike using extra elements of a hash object).</source>
          <target state="translated">Los tipos m&amp;aacute;gicos &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; y &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; est&amp;aacute;n definidos espec&amp;iacute;ficamente para ser usados ​​por extensiones y no ser&amp;aacute;n usados ​​por perl mismo. Las extensiones pueden usar &lt;code&gt;PERL_MAGIC_ext&lt;/code&gt; magic para 'adjuntar' informaci&amp;oacute;n privada a variables (generalmente objetos). Esto es especialmente &amp;uacute;til porque no hay forma de que el c&amp;oacute;digo perl normal corrompa esta informaci&amp;oacute;n privada (a diferencia del uso de elementos adicionales de un objeto hash).</target>
        </trans-unit>
        <trans-unit id="8a6e94721b04748465ec2688a94fd6f249730156" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; interface for hashes</source>
          <target state="translated">La interfaz &lt;code&gt;PERL_MAGIC_uvar&lt;/code&gt; para hashes</target>
        </trans-unit>
        <trans-unit id="bda510e29f461a0c3d4c9c5037a48e14d8e62436" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PERL_SCAN_DISALLOW_PREFIX&lt;/code&gt; flag is always treated as being set for this function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebc956792cc9e74cf6710a9899c98dc65f9e9723" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POPi&lt;/code&gt; macro is used here to pop the return value from the stack. In this case we wanted an integer, so &lt;code&gt;POPi&lt;/code&gt; was used.</source>
          <target state="translated">La macro &lt;code&gt;POPi&lt;/code&gt; se utiliza aqu&amp;iacute; para extraer el valor de retorno de la pila. En este caso, quer&amp;iacute;amos un n&amp;uacute;mero entero, por &lt;code&gt;POPi&lt;/code&gt; se us&amp;oacute; POPi .</target>
        </trans-unit>
        <trans-unit id="441004a0b6f6f50d94cdd26e8efdb4418e11d7d7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::getattr&lt;/code&gt; function can do this more portably on systems purporting POSIX compliance. See also the &lt;code&gt;Term::ReadKey&lt;/code&gt; module from your nearest &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; site.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;POSIX::getattr&lt;/code&gt; puede hacer esto de manera m&amp;aacute;s port&amp;aacute;til en sistemas que pretenden cumplir con POSIX. Consulte tambi&amp;eacute;n el m&amp;oacute;dulo &lt;code&gt;Term::ReadKey&lt;/code&gt; de su sitio &lt;a href=&quot;http://search.cpan.org/perldoc/http:#%2fwww.cpan.org&quot;&gt;CPAN&lt;/a&gt; m&amp;aacute;s cercano .</target>
        </trans-unit>
        <trans-unit id="30a4c7c0312ad4ebafbfc4ecde82010a30e5b1d4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;The setlocale function&lt;/a&gt;.)</source>
          <target state="translated">El &lt;code&gt;POSIX::localeconv()&lt;/code&gt; funci&amp;oacute;n le permite obtener los detalles de la informaci&amp;oacute;n num&amp;eacute;rica de formatear dependiente de la localizaci&amp;oacute;n especificada por las corrientes subyacentes &lt;code&gt;LC_NUMERIC&lt;/code&gt; y &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (independientemente de si se llama desde dentro del &amp;aacute;mbito de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; o no). (Si solo desea el nombre de la configuraci&amp;oacute;n regional actual para una categor&amp;iacute;a en particular, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; con un solo par&amp;aacute;metro; consulte &lt;a href=&quot;#The-setlocale-function&quot;&gt;La funci&amp;oacute;n setlocale&lt;/a&gt; ).</target>
        </trans-unit>
        <trans-unit id="2b43e9db384d2d0a57a2a9c77f122fdc5d00196d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;POSIX::localeconv()&lt;/code&gt; function allows you to get particulars of the locale-dependent numeric formatting information specified by the current underlying &lt;code&gt;LC_NUMERIC&lt;/code&gt; and &lt;code&gt;LC_MONETARY&lt;/code&gt; locales (regardless of whether called from within the scope of &lt;code&gt;use locale&lt;/code&gt; or not). (If you just want the name of the current locale for a particular category, use &lt;code&gt;POSIX::setlocale()&lt;/code&gt; with a single parameter--see &lt;a href=&quot;#The-setlocale-function&quot;&gt;&quot;The setlocale function&quot;&lt;/a&gt;.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f685f77eea7b515d4045c7a67182dbbc7755a25" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section</source>
          <target state="translated">La macro &lt;code&gt;PUSHMARK&lt;/code&gt; le dice a Perl que tome nota mental del puntero de pila actual. Incluso si no est&amp;aacute; pasando ning&amp;uacute;n par&amp;aacute;metro (como el ejemplo que se muestra en la secci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="163850ef5b169ef12088a9930a0f3972d7c61a0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUSHMARK&lt;/code&gt; macro tells Perl to make a mental note of the current stack pointer. Even if you aren't passing any parameters (like the example shown in the section &lt;a href=&quot;#No-Parameters%2C-Nothing-Returned&quot;&gt;&quot;No Parameters, Nothing Returned&quot;&lt;/a&gt;) you must still call the &lt;code&gt;PUSHMARK&lt;/code&gt; macro before you can call any of the</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="07465ad7c738ebeee81550400552ecd67a850bce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PUTBACK&lt;/code&gt; macro sets the global copy of the stack pointer to be the same as our local copy. If we didn't do this,</source>
          <target state="translated">La macro &lt;code&gt;PUTBACK&lt;/code&gt; establece la copia global del puntero de pila para que sea la misma que nuestra copia local. Si no hicimos esto,</target>
        </trans-unit>
        <trans-unit id="8baae86fdb4cb4e701226e31c2071774be7ff5cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PeerAddr&lt;/code&gt; can be a hostname or the IP-address on the &quot;xx.xx.xx.xx&quot; form. The &lt;code&gt;PeerPort&lt;/code&gt; can be a number or a symbolic service name. The service name might be followed by a number in parenthesis which is used if the service is not known by the system. The &lt;code&gt;PeerPort&lt;/code&gt; specification can also be embedded in the &lt;code&gt;PeerAddr&lt;/code&gt; by preceding it with a &quot;:&quot;.</source>
          <target state="translated">El &lt;code&gt;PeerAddr&lt;/code&gt; puede ser un nombre de host o la direcci&amp;oacute;n IP en la forma &quot;xx.xx.xx.xx&quot;. El &lt;code&gt;PeerPort&lt;/code&gt; puede ser un n&amp;uacute;mero o un nombre de servicio simb&amp;oacute;lico. El nombre del servicio puede ir seguido de un n&amp;uacute;mero entre par&amp;eacute;ntesis que se utiliza si el sistema no conoce el servicio. La especificaci&amp;oacute;n &lt;code&gt;PeerPort&lt;/code&gt; tambi&amp;eacute;n se puede incrustar en &lt;code&gt;PeerAddr&lt;/code&gt; precedi&amp;eacute;ndola con un &quot;:&quot;.</target>
        </trans-unit>
        <trans-unit id="354584d7434f3b3042f7e803f86eee0735ecb30f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt; . This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt; . It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="translated">El &lt;code&gt;PerlInterpreter*&lt;/code&gt; se est&amp;aacute; construyendo a trav&amp;eacute;s de &lt;code&gt;perl_construct&lt;/code&gt; . Este valor est&amp;aacute; principalmente ah&amp;iacute; para completar y para usar a trav&amp;eacute;s de la variable C subyacente &lt;code&gt;PL_phase&lt;/code&gt; . Realmente no es posible que se ejecute el c&amp;oacute;digo Perl a menos que la construcci&amp;oacute;n del int&amp;eacute;rprete est&amp;eacute; terminada.</target>
        </trans-unit>
        <trans-unit id="98058838817e528c0fbf9fe55b4c498c1c669b4e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;PerlInterpreter*&lt;/code&gt; is being constructed via &lt;code&gt;perl_construct&lt;/code&gt;. This value is mostly there for completeness and for use via the underlying C variable &lt;code&gt;PL_phase&lt;/code&gt;. It's not really possible for Perl code to be executed unless construction of the interpreter is finished.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="619b9e421badf230488baf0eee0a8b4f64f3d92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; operator. The built-in &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="translated">El ejemplo de &lt;code&gt;REGlob&lt;/code&gt; anterior no implementa todo el soporte necesario para anular limpiamente el operador &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; de perl . El &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; incorporado tiene diferentes comportamientos dependiendo de si aparece en un contexto escalar o de lista, pero nuestro &lt;code&gt;REGlob&lt;/code&gt; no. De hecho, muchos perl incorporados tienen comportamientos sensibles al contexto, y estos deben estar adecuadamente respaldados por una anulaci&amp;oacute;n escrita correctamente. Para obtener un ejemplo completamente funcional de anulaci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/glob&quot;&gt;glob&lt;/a&gt;&lt;/code&gt; , estudie la implementaci&amp;oacute;n de &lt;code&gt;File::DosGlob&lt;/code&gt; en la biblioteca est&amp;aacute;ndar.</target>
        </trans-unit>
        <trans-unit id="2793461193bbb08faabc42ded2214d9447a84314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;REGlob&lt;/code&gt; example above does not implement all the support needed to cleanly override perl's &lt;code&gt;glob&lt;/code&gt; operator. The built-in &lt;code&gt;glob&lt;/code&gt; has different behaviors depending on whether it appears in a scalar or list context, but our &lt;code&gt;REGlob&lt;/code&gt; doesn't. Indeed, many perl built-in have such context sensitive behaviors, and these must be adequately supported by a properly written override. For a fully functional example of overriding &lt;code&gt;glob&lt;/code&gt;, study the implementation of &lt;code&gt;File::DosGlob&lt;/code&gt; in the standard library.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="541482224c51c4cb7a6cd08e437f820560b203ea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Return&lt;/code&gt; and &lt;code&gt;Envelope&lt;/code&gt; parameters are used for DSN (Delivery Status Notification).</source>
          <target state="translated">Los par&amp;aacute;metros &lt;code&gt;Return&lt;/code&gt; y &lt;code&gt;Envelope&lt;/code&gt; se utilizan para DSN (Notificaci&amp;oacute;n de estado de entrega).</target>
        </trans-unit>
        <trans-unit id="0fb74752f70cdbcc4b24e6fe1a79d1c71cc57bd4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Reuse&lt;/code&gt; parameter is needed so that we restart our server manually without waiting a few minutes to allow system buffers to clear out.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;Reuse&lt;/code&gt; es necesario para que reiniciemos nuestro servidor manualmente sin esperar unos minutos para permitir que se borren los b&amp;uacute;feres del sistema.</target>
        </trans-unit>
        <trans-unit id="6ef497f2f64147d9fc11b64ad7836f6a54270b55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; below.</source>
          <target state="translated">La se&amp;ntilde;al &lt;code&gt;SIGALRM&lt;/code&gt; se env&amp;iacute;a despu&amp;eacute;s del n&amp;uacute;mero especificado de segundos. Implementado usando &lt;code&gt;setitimer()&lt;/code&gt; si est&amp;aacute; disponible, &lt;code&gt;ualarm()&lt;/code&gt; si no. El argumento &lt;code&gt;$interval_floating_seconds&lt;/code&gt; es opcional y ser&amp;aacute; cero si no se especifica, lo que da como resultado un comportamiento similar a una &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm()&lt;/a&gt;&lt;/code&gt; . Esta funci&amp;oacute;n se puede importar, lo que resulta en un buen reemplazo directo para la &lt;code&gt;&lt;a href=&quot;../functions/alarm&quot;&gt;alarm&lt;/a&gt;&lt;/code&gt; a proporcionada con perl, consulte los &lt;a href=&quot;#EXAMPLES&quot;&gt;EJEMPLOS a&lt;/a&gt; continuaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="9c45565a357a5307165173264e504c30b567da1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SIGALRM&lt;/code&gt; signal is sent after the specified number of seconds. Implemented using &lt;code&gt;setitimer()&lt;/code&gt; if available, &lt;code&gt;ualarm()&lt;/code&gt; if not. The &lt;code&gt;$interval_floating_seconds&lt;/code&gt; argument is optional and will be zero if unspecified, resulting in &lt;code&gt;alarm()&lt;/code&gt;-like behaviour. This function can be imported, resulting in a nice drop-in replacement for the &lt;code&gt;alarm&lt;/code&gt; provided with perl, see the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; below.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="739f23e9e223585aacd76fc17b10f95586c4f592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SSL_options&lt;/code&gt; attribute could also be used for such things as providing a client certificate for authentication to a server or controlling the choice of cipher used for the SSL connection. See &lt;a href=&quot;IO::Socket::SSL&quot;&gt;IO::Socket::SSL&lt;/a&gt; documentation for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bcb26b9a2abefa95e1228823d5039552d2541e20" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER::&lt;/code&gt; bit tells Perl to look for the &lt;code&gt;print_info()&lt;/code&gt; in the &lt;code&gt;File::MP3&lt;/code&gt; class's inheritance chain. When it finds the parent class that implements this method, the method is called.</source>
          <target state="translated">El &lt;code&gt;SUPER::&lt;/code&gt; bit le dice a Perl que busque &lt;code&gt;print_info()&lt;/code&gt; en la cadena de herencia de la clase &lt;code&gt;File::MP3&lt;/code&gt; . Cuando encuentra la clase padre que implementa este m&amp;eacute;todo, se llama al m&amp;eacute;todo.</target>
        </trans-unit>
        <trans-unit id="3f5b4cff6fbfe1c281604ef06c021cd92e1eaa6d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; modifier can</source>
          <target state="translated">El modificador &lt;code&gt;SUPER&lt;/code&gt; puede</target>
        </trans-unit>
        <trans-unit id="371b5ebfc9cdf0db9a0a55eae240989e954cb726" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class is resolved from the package where the call is made. It is</source>
          <target state="translated">La &lt;code&gt;SUPER&lt;/code&gt; se resuelve desde el paquete donde se realiza la llamada. Es</target>
        </trans-unit>
        <trans-unit id="00f36328e65732130767ca69dab4491f0365d24c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SUPER&lt;/code&gt; pseudo-class that was described earlier is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1a7a3a508d1d6570aa1ef0df5ea57827a95bbfc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;SV_FORCE_UTF8_UPGRADE&lt;/code&gt; flag is now ignored.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ce9315ac1b0e03b32c4d0f032e1290883c21a935" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script&lt;/code&gt; or &lt;code&gt;Script_Extensions&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="translated">Es probable que las propiedades &lt;code&gt;Script&lt;/code&gt; o &lt;code&gt;Script_Extensions&lt;/code&gt; sean las que desee utilizar al procesar lenguaje natural; la propiedad &lt;code&gt;Block&lt;/code&gt; puede ser &amp;uacute;til ocasionalmente para trabajar con las tuercas y tornillos de Unicode.</target>
        </trans-unit>
        <trans-unit id="0c768e6f5d4be03a1a932a1028083efcf53f3ba5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script_Extensions&lt;/code&gt; or &lt;code&gt;Script&lt;/code&gt; properties are likely to be the ones you want to use when processing natural language; the &lt;code&gt;Block&lt;/code&gt; property may occasionally be useful in working with the nuts and bolts of Unicode.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e2c75703b39600771c0a8ce5df27de06d22689b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Script_Extensions&lt;/code&gt; property as modified by UTS 39 (&lt;a href=&quot;https://unicode.org/reports/tr39/&quot;&gt;https://unicode.org/reports/tr39/&lt;/a&gt;) is used as the basis for this feature.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0daac5f890ff04f28fabf32094505977d698c4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; predicate will tell you whether network order was used in the last store or retrieve operation. If you don't know how to use this, just forget about it.</source>
          <target state="translated">El predicado &lt;code&gt;Storable::last_op_in_netorder()&lt;/code&gt; le dir&amp;aacute; si el pedido de red se us&amp;oacute; en la &amp;uacute;ltima operaci&amp;oacute;n de almacenamiento o recuperaci&amp;oacute;n. Si no sabes c&amp;oacute;mo usarlo, olv&amp;iacute;dalo.</target>
        </trans-unit>
        <trans-unit id="4f2453d7aa3fb23473e60b4a26a3d26672cf6341" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TODO:&lt;/code&gt; and &lt;code&gt;$TODO&lt;/code&gt; syntax is generally pretty good about figuring out whether or not we're in a TODO test. However, often we find that this is not possible to determine (such as when we want to use &lt;code&gt;$TODO&lt;/code&gt; but the tests are being executed in other packages which can't be inferred beforehand).</source>
          <target state="translated">La sintaxis &lt;code&gt;TODO:&lt;/code&gt; y &lt;code&gt;$TODO&lt;/code&gt; es generalmente bastante buena para saber si estamos o no en una prueba TODO. Sin embargo, a menudo encontramos que esto no es posible de determinar (como cuando queremos usar &lt;code&gt;$TODO&lt;/code&gt; pero las pruebas se est&amp;aacute;n ejecutando en otros paquetes que no se pueden inferir de antemano).</target>
        </trans-unit>
        <trans-unit id="316a59c6c105ba5a65d5de6abf6871022622f157" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TO_JSON&lt;/code&gt; method may safely call die if it wants. If &lt;code&gt;TO_JSON&lt;/code&gt; returns other blessed objects, those will be handled in the same way. &lt;code&gt;TO_JSON&lt;/code&gt; must take care of not causing an endless recursion cycle (== crash) in this case. The name of &lt;code&gt;TO_JSON&lt;/code&gt; was chosen because other methods called by the Perl core (== not by the user of the object) are usually in upper case letters and to avoid collisions with any &lt;code&gt;to_json&lt;/code&gt; function or method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="94063ef306bbe0bc69a744042850751f57d8165a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TRUE&lt;/code&gt; and &lt;code&gt;FALSE&lt;/code&gt; macros are available for situations where using them would clarify intent. (But they always just mean the same as the integers 1 and 0 regardless, so using them isn't compulsory.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca16843b685fa84c8313aca285e376c5597ef322" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;TYPEMAP&lt;/code&gt; section should contain one pair of C type and XS type per line as follows. An example from the core typemap file:</source>
          <target state="translated">La secci&amp;oacute;n &lt;code&gt;TYPEMAP&lt;/code&gt; debe contener un par de tipo C y tipo XS por l&amp;iacute;nea de la siguiente manera. Un ejemplo del archivo de mapa de tipos principal:</target>
        </trans-unit>
        <trans-unit id="ea8183d7125676dfc1989dcabf04b34c38b4f669" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; function returns a thread object that represents the thread making the &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; call.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; devuelve un objeto de hilo que representa el hilo que realiza la llamada &lt;code&gt;Thread-&amp;gt;self&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="5f72cf2b372d3d426c2948d6098fd6cd1afad651" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module provides multithreading support for Perl.</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Thread&lt;/code&gt; proporciona compatibilidad con m&amp;uacute;ltiples subprocesos para Perl.</target>
        </trans-unit>
        <trans-unit id="7fe8315550458ad4289f70c4a27bed2792ae2d78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Thread&lt;/code&gt; module served as the frontend to the old-style thread model, called</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;Thread&lt;/code&gt; sirvi&amp;oacute; como interfaz para el modelo de thread de estilo antiguo, llamado</target>
        </trans-unit>
        <trans-unit id="ab5cb47a9617fcafbcf6221a375828cf9de09e24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;EXAMPLES&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; , and &lt;code&gt;setitimer&lt;/code&gt; /&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="translated">El &lt;code&gt;Time::HiRes&lt;/code&gt; m&amp;oacute;dulo implementa una interfaz de Perl para los &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;nanosleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; y &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; llamadas al sistema, es decir, de alta resoluci&amp;oacute;n de tiempo y contadores de tiempo. Consulte la secci&amp;oacute;n de &lt;a href=&quot;#EXAMPLES&quot;&gt;EJEMPLOS a&lt;/a&gt; continuaci&amp;oacute;n y los scripts de prueba para su uso; consulte la documentaci&amp;oacute;n del sistema para la descripci&amp;oacute;n del subyacente &lt;code&gt;nanosleep&lt;/code&gt; o &lt;code&gt;usleep&lt;/code&gt; , &lt;code&gt;ualarm&lt;/code&gt; , &lt;code&gt;gettimeofday&lt;/code&gt; y &lt;code&gt;setitimer&lt;/code&gt; / &lt;code&gt;getitimer&lt;/code&gt; llamadas.</target>
        </trans-unit>
        <trans-unit id="840bb1616acfc5f4c8448fa1adbdaac8f85745ff" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Time::HiRes&lt;/code&gt; module implements a Perl interface to the &lt;code&gt;usleep&lt;/code&gt;, &lt;code&gt;nanosleep&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt;, &lt;code&gt;gettimeofday&lt;/code&gt;, and &lt;code&gt;setitimer&lt;/code&gt;/&lt;code&gt;getitimer&lt;/code&gt; system calls, in other words, high resolution time and timers. See the &lt;a href=&quot;#EXAMPLES&quot;&gt;&quot;EXAMPLES&quot;&lt;/a&gt; section below and the test scripts for usage; see your system documentation for the description of the underlying &lt;code&gt;nanosleep&lt;/code&gt; or &lt;code&gt;usleep&lt;/code&gt;, &lt;code&gt;ualarm&lt;/code&gt;, &lt;code&gt;gettimeofday&lt;/code&gt;, and &lt;code&gt;setitimer&lt;/code&gt;/&lt;code&gt;getitimer&lt;/code&gt; calls.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db031bd2869c09fc69e58469a4b3b15d15dfaaa1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;UTF8_CHECK_ONLY&lt;/code&gt; flag overrides the behavior when a non-allowed (by other flags) malformation is found. If this flag is set, the routine assumes that the caller will raise a warning, and this function will silently just set &lt;code&gt;retlen&lt;/code&gt; to &lt;code&gt;-1&lt;/code&gt; (cast to &lt;code&gt;STRLEN&lt;/code&gt;) and return zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="adde2e15da0476d4564064bbc384c4ca957b8d40" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;VERSION&lt;/code&gt; method returns the version number of the class (package).</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;VERSION&lt;/code&gt; devuelve el n&amp;uacute;mero de versi&amp;oacute;n de la clase (paquete).</target>
        </trans-unit>
        <trans-unit id="d8baa2e2f7c0fd0a2f0c9455f11a42eb910290cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="translated">Los m&amp;oacute;dulos &lt;code&gt;Win32::*&lt;/code&gt; en &lt;a href=&quot;http://search.cpan.org/perldoc/Win32&quot;&gt;Win32&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="365cfe3394d31517ee04bbcb7fdcf61281c556f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Win32::*&lt;/code&gt; modules in &lt;a href=&quot;win32&quot;&gt;Win32&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c6c47ba9b1855f9e0e157ed96c1dac4112ef8de3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; sequence is supposed to be empty.</source>
          <target state="translated">Se supone que la secuencia &lt;code&gt;Z&amp;lt;&amp;gt;&lt;/code&gt; est&amp;aacute; vac&amp;iacute;a.</target>
        </trans-unit>
        <trans-unit id="4f3af2152fe286b612ed068b47a818a0a9d55853" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5C1-Instead-of-%241&quot;&gt;&quot;Warning on \1 Instead of $1&quot;&lt;/a&gt; below for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3c164b87544e368a57522144bf31b4093cb008b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; notation also works in certain circumstances outside the pattern. See &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;Warning on \1 Instead of $1&lt;/a&gt; below for details.</source>
          <target state="translated">La notaci&amp;oacute;n &lt;code&gt;\&lt;i&gt;digit&lt;/i&gt;&lt;/code&gt; tambi&amp;eacute;n funciona en determinadas circunstancias fuera del patr&amp;oacute;n. Consulte &lt;a href=&quot;#Warning-on-%5c1-Instead-of-%241&quot;&gt;Advertencia sobre \ 1 en lugar de $ 1 a&lt;/a&gt; continuaci&amp;oacute;n para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="c49d42a1bfbc0b22f583d2817d2ce107934b83b0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\C&lt;/code&gt; is unsupported in lookbehind, because the already treacherous definition of &lt;code&gt;\C&lt;/code&gt; would become even more so when going backwards.</source>
          <target state="translated">La &lt;code&gt;\C&lt;/code&gt; no se admite en mirar atr&amp;aacute;s, porque la definici&amp;oacute;n ya traicionera de &lt;code&gt;\C&lt;/code&gt; se volver&amp;iacute;a a&amp;uacute;n m&amp;aacute;s si se retrocediera.</target>
        </trans-unit>
        <trans-unit id="b97997ed1726a2dd70e1e88046ee54105827a12b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Regexp Quote-Like Operators in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt; -like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; as an lvalue: see &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;Repeated Patterns Matching a Zero-length Substring&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="translated">La aserci&amp;oacute;n &lt;code&gt;\G&lt;/code&gt; se puede usar para encadenar coincidencias globales (usando &lt;code&gt;&lt;a href=&quot;functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; ), como se describe en &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;Operadores similares a citas de expresiones regulares en perlop&lt;/a&gt; . Tambi&amp;eacute;n es &amp;uacute;til al escribir esc&amp;aacute;neres similares a &lt;code&gt;lex&lt;/code&gt; , cuando tiene varios patrones que desea hacer coincidir con las subsecuentes subcadenas de su cadena; ver la referencia anterior. La ubicaci&amp;oacute;n real donde &lt;code&gt;\G&lt;/code&gt; coincidir&amp;aacute; tambi&amp;eacute;n puede verse influenciada por el uso de &lt;code&gt;&lt;a href=&quot;functions/pos&quot;&gt;pos()&lt;/a&gt;&lt;/code&gt; como un valor l: ver &lt;a href=&quot;functions/pos&quot;&gt;pos&lt;/a&gt; . Tenga en cuenta que la regla para las coincidencias de longitud cero (consulte &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;Patrones repetidos que coinciden con una subcadena de longitud cero&lt;/a&gt; ) se modifica un poco, ya que el contenido a la izquierda de &lt;code&gt;\G&lt;/code&gt; no se cuentan al determinar la duraci&amp;oacute;n del partido. Por lo tanto, lo siguiente no coincidir&amp;aacute; para siempre:</target>
        </trans-unit>
        <trans-unit id="e1ff47fb2c42daca3a8b3c8a3d0395f0593d6c3c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\G&lt;/code&gt; assertion can be used to chain global matches (using &lt;code&gt;m//g&lt;/code&gt;), as described in &lt;a href=&quot;perlop#Regexp-Quote-Like-Operators&quot;&gt;&quot;Regexp Quote-Like Operators&quot; in perlop&lt;/a&gt;. It is also useful when writing &lt;code&gt;lex&lt;/code&gt;-like scanners, when you have several patterns that you want to match against consequent substrings of your string; see the previous reference. The actual location where &lt;code&gt;\G&lt;/code&gt; will match can also be influenced by using &lt;code&gt;pos()&lt;/code&gt; as an lvalue: see &lt;a href=&quot;perlfunc#pos&quot;&gt;&quot;pos&quot; in perlfunc&lt;/a&gt;. Note that the rule for zero-length matches (see &lt;a href=&quot;#Repeated-Patterns-Matching-a-Zero-length-Substring&quot;&gt;&quot;Repeated Patterns Matching a Zero-length Substring&quot;&lt;/a&gt;) is modified somewhat, in that contents to the left of &lt;code&gt;\G&lt;/code&gt; are not counted when determining the length of the match. Thus the following will not match forever:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9300fc0425608314652e19b5173bc5fd7efd18c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N&lt;/code&gt; character class, not to be confused with the named character sequence &lt;code&gt;\N{NAME}&lt;/code&gt; , denotes any non-newline character in a regular expression.</source>
          <target state="translated">La clase de caracteres &lt;code&gt;\N&lt;/code&gt; , que no debe confundirse con la secuencia de caracteres nombrada &lt;code&gt;\N{NAME}&lt;/code&gt; , denota cualquier car&amp;aacute;cter que no sea una nueva l&amp;iacute;nea en una expresi&amp;oacute;n regular.</target>
        </trans-unit>
        <trans-unit id="6fc55e5a124a8f9ba1fb9b74d5a25063c2e050b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\N{...}&lt;/code&gt; construct explicitly refers to a Unicode code point, even if it is one that is also in ASCII. Therefore the string containing it must be Unicode.</source>
          <target state="translated">La construcci&amp;oacute;n &lt;code&gt;\N{...}&lt;/code&gt; se refiere expl&amp;iacute;citamente a un punto de c&amp;oacute;digo Unicode, incluso si es uno que tambi&amp;eacute;n est&amp;aacute; en ASCII. Por lo tanto, la cadena que lo contiene debe ser Unicode.</target>
        </trans-unit>
        <trans-unit id="7f0273d79d748bac786c369cab505ed24fe2cfda" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d&lt;/code&gt; gets rid of needing to anchor the pattern, since it forces the result to only match &lt;code&gt;[0-9]&lt;/code&gt;, and the &lt;code&gt;[0-5]&lt;/code&gt; further restricts it.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52316cb23d6228b5040f834369875ce8a00e4e55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of bracketed character classes. Here are some in use:</source>
          <target state="translated">Las abreviaturas &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; se pueden usar tanto dentro como fuera de las clases de caracteres entre corchetes. Aqu&amp;iacute; hay algunos en uso:</target>
        </trans-unit>
        <trans-unit id="dc3bb1079451a53e38a66554502d10e12737dc82" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; abbreviations can be used both inside and outside of character classes. Here are some in use:</source>
          <target state="translated">Las abreviaturas &lt;code&gt;\d\s\w\D\S\W&lt;/code&gt; se pueden usar tanto dentro como fuera de las clases de caracteres. Aqu&amp;iacute; hay algunos en uso:</target>
        </trans-unit>
        <trans-unit id="0f2c8f2ff00b285673d694a7e44211cdef772f8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc., and this notation is still accepted (and likely always will be). But it leads to some ambiguities if there are more than 9 capture groups, as &lt;code&gt;\10&lt;/code&gt; could mean either the tenth capture group, or the character whose ordinal in octal is 010 (a backspace in ASCII). Perl resolves this ambiguity by interpreting &lt;code&gt;\10&lt;/code&gt; as a backreference only if at least 10 left parentheses have opened before it. Likewise &lt;code&gt;\11&lt;/code&gt; is a backreference only if at least 11 left parentheses have opened before it. And so on. &lt;code&gt;\1&lt;/code&gt; through &lt;code&gt;\9&lt;/code&gt; are always interpreted as backreferences. There are several examples below that illustrate these perils. You can avoid the ambiguity by always using &lt;code&gt;\g{}&lt;/code&gt; or &lt;code&gt;\g&lt;/code&gt; if you mean capturing groups; and for octal constants always using &lt;code&gt;\o{}&lt;/code&gt; , or for &lt;code&gt;\077&lt;/code&gt; and below, using 3 digits padded with leading zeros, since a leading zero implies an octal constant.</source>
          <target state="translated">Las notaciones &lt;code&gt;\g&lt;/code&gt; y &lt;code&gt;\k&lt;/code&gt; se introdujeron en Perl 5.10.0. Antes de eso, no hab&amp;iacute;a grupos de captura con nombres ni n&amp;uacute;meros relativos. Se hizo referencia a los grupos numerados absolutos mediante &lt;code&gt;\1&lt;/code&gt; , &lt;code&gt;\2&lt;/code&gt; , etc., y esta notaci&amp;oacute;n todav&amp;iacute;a se acepta (y probablemente siempre lo ser&amp;aacute;). Pero conduce a algunas ambig&amp;uuml;edades si hay m&amp;aacute;s de 9 grupos de captura, ya que &lt;code&gt;\10&lt;/code&gt; podr&amp;iacute;a significar el d&amp;eacute;cimo grupo de captura o el car&amp;aacute;cter cuyo ordinal en octal es 010 (un retroceso en ASCII). Perl resuelve esta ambig&amp;uuml;edad interpretando &lt;code&gt;\10&lt;/code&gt; como una referencia inversa solo si al menos 10 par&amp;eacute;ntesis izquierdos se han abierto antes. Asimismo &lt;code&gt;\11&lt;/code&gt; es una referencia inversa solo si al menos 11 par&amp;eacute;ntesis izquierdos se han abierto antes. Y as&amp;iacute;. &lt;code&gt;\1&lt;/code&gt; a &lt;code&gt;\9&lt;/code&gt; siempre se interpretan como referencias inversas. Hay varios ejemplos a continuaci&amp;oacute;n que ilustran estos peligros. Puede evitar la ambig&amp;uuml;edad usando siempre &lt;code&gt;\g{}&lt;/code&gt; o &lt;code&gt;\g&lt;/code&gt; si se refiere a capturar grupos; y para las constantes octales usando siempre &lt;code&gt;\o{}&lt;/code&gt; , o para &lt;code&gt;\077&lt;/code&gt; y menos, usando 3 d&amp;iacute;gitos rellenados con ceros a la izquierda, ya que un cero a la izquierda implica una constante octal.</target>
        </trans-unit>
        <trans-unit id="15b6b1b5929104c2b72fb96a6e633ae2051f4ffd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;/code&gt; and &lt;code&gt;\k&lt;/code&gt; notations were introduced in Perl 5.10.0. Prior to that there were no named nor relative numbered capture groups. Absolute numbered groups were referred to using &lt;code&gt;\1&lt;/code&gt;, &lt;code&gt;\2&lt;/code&gt;,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="517d2abbf8670e3eaf5c272713d99b8bf67cd7d0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; , and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt; , you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="translated">La forma &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; se puede escribir de forma equivalente como &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; que evita la ambig&amp;uuml;edad al construir una expresi&amp;oacute;n regular mediante la concatenaci&amp;oacute;n de cadenas m&amp;aacute;s cortas. De lo contrario, si tuvieras una expresi&amp;oacute;n regular &lt;code&gt;&lt;a href=&quot;functions/qr&quot;&gt;qr/$a$b/&lt;/a&gt;&lt;/code&gt; , y &lt;code&gt;$a&lt;/code&gt; contuviera &lt;code&gt;&quot;\g1&quot;&lt;/code&gt; y &lt;code&gt;$b&lt;/code&gt; contuviera &lt;code&gt;&quot;37&quot;&lt;/code&gt; , obtendr&amp;iacute;as &lt;code&gt;/\g137/&lt;/code&gt; que probablemente no sea lo que pretend&amp;iacute;as.</target>
        </trans-unit>
        <trans-unit id="03256d4028754b69d229d57c7593954c93901408" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;\g&lt;i&gt;N&lt;/i&gt;&lt;/code&gt; form can be equivalently written as &lt;code&gt;\g{&lt;i&gt;N&lt;/i&gt;}&lt;/code&gt; which avoids ambiguity when building a regex by concatenating shorter strings. Otherwise if you had a regex &lt;code&gt;qr/$a$b/&lt;/code&gt;, and &lt;code&gt;$a&lt;/code&gt; contained &lt;code&gt;&quot;\g1&quot;&lt;/code&gt;, and &lt;code&gt;$b&lt;/code&gt; contained &lt;code&gt;&quot;37&quot;&lt;/code&gt;, you would get &lt;code&gt;/\g137/&lt;/code&gt; which is probably not what you intended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1162dcf378fe4b180c42e9c8606223aea754f52f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;__DATA__&lt;/code&gt; token tells the perl compiler that the perl code for compilation is finished. Everything after the &lt;code&gt;__DATA__&lt;/code&gt; token is available for reading via the filehandle FOOBAR::DATA, where FOOBAR is the name of the current package when the &lt;code&gt;__DATA__&lt;/code&gt; token is reached. This works just the same as &lt;code&gt;__END__&lt;/code&gt; does in package 'main', but for other modules data after &lt;code&gt;__END__&lt;/code&gt; is not automatically retrievable, whereas data after &lt;code&gt;__DATA__&lt;/code&gt; is. The &lt;code&gt;__DATA__&lt;/code&gt; token is not recognized in versions of perl prior to 5.001m.</source>
          <target state="translated">El token &lt;code&gt;__DATA__&lt;/code&gt; le dice al compilador de Perl que el c&amp;oacute;digo de Perl para la compilaci&amp;oacute;n est&amp;aacute; terminado. Todo lo que &lt;code&gt;__DATA__&lt;/code&gt; despu&amp;eacute;s del token __DATA__ est&amp;aacute; disponible para leer a trav&amp;eacute;s del identificador de archivo FOOBAR :: DATA, donde FOOBAR es el nombre del paquete actual cuando se &lt;code&gt;__DATA__&lt;/code&gt; token __DATA__ . Esto funciona igual que &lt;code&gt;__END__&lt;/code&gt; en el paquete 'main', pero para otros m&amp;oacute;dulos, los datos posteriores a &lt;code&gt;__END__&lt;/code&gt; no se pueden recuperar autom&amp;aacute;ticamente, mientras que los datos posteriores a &lt;code&gt;__DATA__&lt;/code&gt; s&amp;iacute; lo son. El token &lt;code&gt;__DATA__&lt;/code&gt; no se reconoce en versiones de perl anteriores a 5.001m.</target>
        </trans-unit>
        <trans-unit id="aaae759fadc0ccc32d523d9d6a0dc772ae2d9269" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;_r&lt;/code&gt; forms are automatically used, starting in Perl 5.28, if you compile your code, with</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e8e846812293eaeddc68b23ea744d79168534a2d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; , and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="translated">Los &lt;code&gt;a&lt;/code&gt; , &lt;code&gt;A&lt;/code&gt; y &lt;code&gt;Z&lt;/code&gt; tipos engullen s&amp;oacute;lo un valor, pero paquete como una cadena de cuenta de longitud, relleno con nulos o espacios seg&amp;uacute;n sea necesario. Al desembalar, &lt;code&gt;A&lt;/code&gt; tiras espacios en blanco y los nulos, &lt;code&gt;Z&lt;/code&gt; tiras todo despu&amp;eacute;s de la primera null, y &lt;code&gt;a&lt;/code&gt; devuelve datos sin pelar en absoluto.</target>
        </trans-unit>
        <trans-unit id="1a1b3cf59097aca7e4188f4992a603a0b5d6ae0f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;A&lt;/code&gt;, and &lt;code&gt;Z&lt;/code&gt; types gobble just one value, but pack it as a string of length count, padding with nulls or spaces as needed. When unpacking, &lt;code&gt;A&lt;/code&gt; strips trailing whitespace and nulls, &lt;code&gt;Z&lt;/code&gt; strips everything after the first null, and &lt;code&gt;a&lt;/code&gt; returns data with no stripping at all.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="893b37c14397452b4b42e37cd794a8b9b2d1eb65" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;alarm()&lt;/code&gt; function is not implemented on all versions of Windows. Check the documentation for your specific version of Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d5cca45db774b8d4bbc26743f5dae5512cca0753" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt; -like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt; . We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt; .</source>
          <target state="translated">La bandera de importaci&amp;oacute;n de &lt;code&gt;antlers&lt;/code&gt; le dice a &lt;code&gt;Class::Accessor&lt;/code&gt; que desea definir sus atributos usando una sintaxis similar a &lt;code&gt;Moose&lt;/code&gt; . El &amp;uacute;nico par&amp;aacute;metro que se puede pasar a &lt;code&gt;has&lt;/code&gt; es &lt;code&gt;is&lt;/code&gt; . Recomendamos que use esta sintaxis similar a Moose si elige &lt;code&gt;Class::Accessor&lt;/code&gt; ya que significa que tendr&amp;aacute; una ruta de actualizaci&amp;oacute;n m&amp;aacute;s suave si luego decide pasar a &lt;code&gt;Moose&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="96ee1d0dc9d201f79ce6ef0d53eb7c5448972089" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;antlers&lt;/code&gt; import flag tells &lt;code&gt;Class::Accessor&lt;/code&gt; that you want to define your attributes using &lt;code&gt;Moose&lt;/code&gt;-like syntax. The only parameter that you can pass to &lt;code&gt;has&lt;/code&gt; is &lt;code&gt;is&lt;/code&gt;. We recommend that you use this Moose-like syntax if you choose &lt;code&gt;Class::Accessor&lt;/code&gt; since it means you will have a smoother upgrade path if you later decide to move to &lt;code&gt;Moose&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30d4c5418acb92744951617bccd4c2bb4e907086" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;as_number()&lt;/code&gt; function returns a BigInt from a Math::BigFloat. It uses 'trunc' as rounding mode to make it equivalent to:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;as_number()&lt;/code&gt; devuelve un BigInt de Math :: BigFloat. Utiliza 'trunc' como modo de redondeo para que sea equivalente a:</target>
        </trans-unit>
        <trans-unit id="a93f0f0ee3776b1d1340911a8e79d371cb0d5ce7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;authors&lt;/code&gt; and &lt;code&gt;licenses&lt;/code&gt; methods may also be called as &lt;code&gt;author&lt;/code&gt; and &lt;code&gt;license&lt;/code&gt;, respectively, to match the field name in the distmeta structure.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3e4be85862bcecd6790751ef47534ab240cde4eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma has</source>
          <target state="translated">El &lt;code&gt;autodie&lt;/code&gt; pragma tiene</target>
        </trans-unit>
        <trans-unit id="92907be6274b88924410c3eb7108af17c084f529" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autodie&lt;/code&gt; pragma provides a convenient way to replace functions that normally return false on failure with equivalents that throw an exception on failure.</source>
          <target state="translated">El pragma &lt;code&gt;autodie&lt;/code&gt; proporciona una manera conveniente de reemplazar funciones que normalmente devuelven falso en caso de falla con equivalentes que generan una excepci&amp;oacute;n en caso de falla.</target>
        </trans-unit>
        <trans-unit id="3ccf77f6494c4bb94f71a5890c3e377c22247ef4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt; . It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="translated">La interfaz de divisi&amp;oacute;n &lt;code&gt;autosplit&lt;/code&gt; divide el archivo especificado en una jerarqu&amp;iacute;a enraizada en el directorio &lt;code&gt;$dir&lt;/code&gt; . Crea directorios seg&amp;uacute;n sea necesario para reflejar la jerarqu&amp;iacute;a de clases y crea el archivo</target>
        </trans-unit>
        <trans-unit id="9ec1a56ade0e6bb491c622b2d56bc77a622eb46d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit&lt;/code&gt; interface splits the specified file into a hierarchy rooted at the directory &lt;code&gt;$dir&lt;/code&gt;. It creates directories as needed to reflect class hierarchy, and creates the file</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc73dbc80868b5e2537b36abd82d968f2ba4c751" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autosplit_lib_modules&lt;/code&gt; form is used in the building of perl. It takes as input a list of files (modules) that are assumed to reside in a directory &lt;b&gt;lib&lt;/b&gt; relative to the current directory. Each file is sent to the autosplitter one at a time, to be split into the directory &lt;b&gt;lib/auto&lt;/b&gt;.</source>
          <target state="translated">El formulario &lt;code&gt;autosplit_lib_modules&lt;/code&gt; se utiliza en la construcci&amp;oacute;n de perl. Toma como entrada una lista de archivos (m&amp;oacute;dulos) que se supone que residen en un directorio &lt;b&gt;lib&lt;/b&gt; relativo al directorio actual. Cada archivo se env&amp;iacute;a al divisor &lt;b&gt;autom&amp;aacute;tico de&lt;/b&gt; uno en uno, para dividirlo en el directorio &lt;b&gt;lib / auto&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="423004d21ce960dd9509db30e9f26d66964e12d2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;autotie&lt;/code&gt; mechanism supports this too. The following code:</source>
          <target state="translated">El mecanismo de &lt;code&gt;autotie&lt;/code&gt; tambi&amp;eacute;n lo admite. El siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="eadb034339c34e003fe891167b8ebaef4be23657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_clear&lt;/code&gt; function deletes all the elements in the AV* array, but does not actually delete the array itself. The &lt;code&gt;av_undef&lt;/code&gt; function will delete all the elements in the array plus the array itself. The &lt;code&gt;av_extend&lt;/code&gt; function extends the array so that it contains at least &lt;code&gt;key+1&lt;/code&gt; elements. If &lt;code&gt;key+1&lt;/code&gt; is less than the currently allocated length of the array, then nothing is done.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;av_clear&lt;/code&gt; elimina todos los elementos de la matriz AV *, pero en realidad no elimina la matriz en s&amp;iacute;. La funci&amp;oacute;n &lt;code&gt;av_undef&lt;/code&gt; eliminar&amp;aacute; todos los elementos de la matriz m&amp;aacute;s la matriz misma. La funci&amp;oacute;n &lt;code&gt;av_extend&lt;/code&gt; extiende la matriz para que contenga al menos elementos &lt;code&gt;key+1&lt;/code&gt; . Si la &lt;code&gt;key+1&lt;/code&gt; es menor que la longitud asignada actualmente de la matriz, no se hace nada.</target>
        </trans-unit>
        <trans-unit id="d6bd36bbe209d0e332f324c88cb8fab5da451e26" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt; . It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;av_store&lt;/code&gt; , cuando se le da un argumento de matriz vinculada, simplemente copia la magia de la matriz en el valor que se &quot;almacenar&amp;aacute;&quot;, utilizando &lt;code&gt;mg_copy&lt;/code&gt; . Tambi&amp;eacute;n puede devolver NULL, lo que indica que el valor en realidad no necesitaba almacenarse en la matriz. [MAYCHANGE] Despu&amp;eacute;s de una llamada a &lt;code&gt;av_store&lt;/code&gt; en una matriz vinculada, la persona que llama normalmente necesitar&amp;aacute; llamar a &lt;code&gt;mg_set(val)&lt;/code&gt; para invocar el m&amp;eacute;todo &quot;STORE&quot; de nivel de perl en el objeto TIEARRAY. Si &lt;code&gt;av_store&lt;/code&gt; devolvi&amp;oacute; NULL, tambi&amp;eacute;n ser&amp;aacute; necesaria una llamada a &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; para evitar una p&amp;eacute;rdida de memoria. [/PODR&amp;Iacute;A CAMBIAR]</target>
        </trans-unit>
        <trans-unit id="e12306e741c00686916bfa82246266097410a872" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_store&lt;/code&gt; function, when given a tied array argument, merely copies the magic of the array onto the value to be &quot;stored&quot;, using &lt;code&gt;mg_copy&lt;/code&gt;. It may also return NULL, indicating that the value did not actually need to be stored in the array. [MAYCHANGE] After a call to &lt;code&gt;av_store&lt;/code&gt; on a tied array, the caller will usually need to call &lt;code&gt;mg_set(val)&lt;/code&gt; to actually invoke the perl level &quot;STORE&quot; method on the TIEARRAY object. If &lt;code&gt;av_store&lt;/code&gt; did return NULL, a call to &lt;code&gt;SvREFCNT_dec(val)&lt;/code&gt; will also be usually necessary to avoid a memory leak. [/MAYCHANGE]</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b0bf6421125301461c635d2914e7cd34219ce4cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt; , but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt; , and does not increment the reference count of &lt;code&gt;val&lt;/code&gt; . Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt; 's, not &lt;code&gt;SV*&lt;/code&gt; 's as their return value.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;av_top_index&lt;/code&gt; devuelve el valor de &amp;iacute;ndice m&amp;aacute;s alto en una matriz (como $ # matriz en Perl). Si la matriz est&amp;aacute; vac&amp;iacute;a, se devuelve -1. La funci&amp;oacute;n &lt;code&gt;av_fetch&lt;/code&gt; devuelve el valor en la &lt;code&gt;key&lt;/code&gt; &amp;iacute;ndice , pero si &lt;code&gt;lval&lt;/code&gt; no es cero, &lt;code&gt;av_fetch&lt;/code&gt; almacenar&amp;aacute; un valor indefinido en ese &amp;iacute;ndice. La funci&amp;oacute;n &lt;code&gt;av_store&lt;/code&gt; almacena el valor &lt;code&gt;val&lt;/code&gt; en la &lt;code&gt;key&lt;/code&gt; &amp;iacute;ndice y no incrementa el recuento de referencia de &lt;code&gt;val&lt;/code&gt; . Por lo tanto, la persona que llama es responsable de encargarse de eso, y si &lt;code&gt;av_store&lt;/code&gt; devuelve NULL, la persona que llama tendr&amp;aacute; que disminuir el recuento de referencias para evitar una p&amp;eacute;rdida de memoria. Tenga en cuenta que &lt;code&gt;av_fetch&lt;/code&gt; y &lt;code&gt;av_store&lt;/code&gt; devuelven &lt;code&gt;SV**&lt;/code&gt; , no &lt;code&gt;SV*&lt;/code&gt; como valor de retorno.</target>
        </trans-unit>
        <trans-unit id="b720f9a7cf39478f335b0b67c7ecec4e7dd453ba" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;av_top_index&lt;/code&gt; function returns the highest index value in an array (just like $#array in Perl). If the array is empty, -1 is returned. The &lt;code&gt;av_fetch&lt;/code&gt; function returns the value at index &lt;code&gt;key&lt;/code&gt;, but if &lt;code&gt;lval&lt;/code&gt; is non-zero, then &lt;code&gt;av_fetch&lt;/code&gt; will store an undef value at that index. The &lt;code&gt;av_store&lt;/code&gt; function stores the value &lt;code&gt;val&lt;/code&gt; at index &lt;code&gt;key&lt;/code&gt;, and does not increment the reference count of &lt;code&gt;val&lt;/code&gt;. Thus the caller is responsible for taking care of that, and if &lt;code&gt;av_store&lt;/code&gt; returns NULL, the caller will have to decrement the reference count to avoid a memory leak. Note that &lt;code&gt;av_fetch&lt;/code&gt; and &lt;code&gt;av_store&lt;/code&gt; both return &lt;code&gt;SV**&lt;/code&gt;'s, not &lt;code&gt;SV*&lt;/code&gt;'s as their return value.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="78b7a8fbb40ab78219d70980fb393c043d50ef45" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;bind&lt;/code&gt; argument specifies the local_addr to bind to. By specifying a bind argument you don't need the bind method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0be24d4311997148f32f98999c298c4120e52577" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binmode&lt;/code&gt; function can be called on an opened handle to push additional layers onto the stack, which may also modify the existing layers. &lt;code&gt;binmode&lt;/code&gt; called with no layers will remove or unset any existing layers which transform the byte stream, making the handle suitable for binary data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="185e8e007341d198fca87c48c9798b7fe0dfa929" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;binmode&lt;/code&gt; operator will attempt to insure that no translation of carriage control occurs on input from or output to this filehandle. Since this involves reopening the file and then restoring its file position indicator, if this function returns FALSE, the underlying filehandle may no longer point to an open file, or may point to a different position in the file than before &lt;code&gt;binmode&lt;/code&gt; was called.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca3e501abc26cf1405f0402c343ec30915264f88" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; keywords from C become in Perl &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="translated">Las palabras clave &lt;code&gt;break&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/continue&quot;&gt;continue&lt;/a&gt;&lt;/code&gt; de C se convierten en Perl &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , respectivamente. A diferencia de C, estos hacen</target>
        </trans-unit>
        <trans-unit id="cf097e70ce7b8cc145798b0019e84f65b1044b49" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;break&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; keywords from C become in Perl &lt;code&gt;last&lt;/code&gt; and &lt;code&gt;next&lt;/code&gt;, respectively. Unlike in C, these do</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="787c128b8b97671abe15918465f291ec006979e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;buffered&lt;/code&gt; attribute of the &lt;a href=&quot;Test2::Event::Subtest&quot;&gt;Test2::Event::Subtest&lt;/a&gt; event will be set to the value of this flag. This means any formatter, listener, etc which looks at the event will know if it was buffered.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1750aab93908ada1ee29e1880f7061b67617e505" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cacheout&lt;/code&gt; function will make sure that there's a filehandle open for reading or writing available as the pathname you give it. It automatically closes and re-opens files if you exceed your system's maximum number of file descriptors, or the suggested maximum</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;cacheout&lt;/code&gt; se asegurar&amp;aacute; de que haya un identificador de archivo abierto para lectura o escritura disponible como el nombre de ruta que le proporcione. Cierra y vuelve a abrir archivos autom&amp;aacute;ticamente si excede el n&amp;uacute;mero m&amp;aacute;ximo de descriptores de archivo de su sistema, o el m&amp;aacute;ximo sugerido</target>
        </trans-unit>
        <trans-unit id="2c5778ca552de672cec71f94fb24332cb951e6b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt; . This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; is returned.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;can&lt;/code&gt; comprueba si la clase u objeto en el que se llam&amp;oacute; tiene un m&amp;eacute;todo llamado &lt;code&gt;$method&lt;/code&gt; . Esto busca el m&amp;eacute;todo en la clase y todos sus padres. Si el m&amp;eacute;todo existe, se devuelve una referencia a la subrutina. Si no es &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; se devuelve undef .</target>
        </trans-unit>
        <trans-unit id="b581c43bfa8c63ce0337f8cf0f51834457cb5241" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can&lt;/code&gt; method checks to see if the class or object it was called on has a method named &lt;code&gt;$method&lt;/code&gt;. This checks for the method in the class and all of its parents. If the method exists, then a reference to the subroutine is returned. If it does not then &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a231f00f91910adc2ab3862d9199fc8f2fdda4f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;can_run&lt;/code&gt; function can tell you if a certain binary is installed and if so where, whereas the &lt;code&gt;run&lt;/code&gt; function can actually execute any of the commands you give it and give you a clear return value, as well as adhere to your verbosity settings.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;can_run&lt;/code&gt; puede decirle si un determinado binario est&amp;aacute; instalado y, de ser as&amp;iacute;, d&amp;oacute;nde, mientras que la funci&amp;oacute;n de &lt;code&gt;run&lt;/code&gt; puede ejecutar cualquiera de los comandos que le d&amp;eacute; y darle un valor de retorno claro, as&amp;iacute; como adherirse a su configuraci&amp;oacute;n de verbosidad.</target>
        </trans-unit>
        <trans-unit id="ae669119c46135f428f552580c056d83e94ae6fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;char*&lt;/code&gt; string does not tell you the whole story, and you can't copy or reconstruct an SV just by copying the string value. Check if the old SV has the UTF8 flag set (</source>
          <target state="translated">La cadena &lt;code&gt;char*&lt;/code&gt; no le dice toda la historia, y no puede copiar o reconstruir un SV simplemente copiando el valor de la cadena. Compruebe si el antiguo SV tiene la bandera UTF8 configurada (</target>
        </trans-unit>
        <trans-unit id="3b094d933bb88b4ae1f6722063975d6ce16a864f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="translated">Los &lt;code&gt;charnames&lt;/code&gt; pragma apoya los argumentos &lt;code&gt;:full&lt;/code&gt; , &lt;code&gt;:loose&lt;/code&gt; , &lt;code&gt;:short&lt;/code&gt; , nombres de scripts y &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;alias personalizados&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="3385057bdbf70e4b65ad1d11db30e12395abd68a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;charnames&lt;/code&gt; pragma supports arguments &lt;code&gt;:full&lt;/code&gt;, &lt;code&gt;:loose&lt;/code&gt;, &lt;code&gt;:short&lt;/code&gt;, script names and &lt;a href=&quot;#CUSTOM-ALIASES&quot;&gt;customized aliases&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9f351acbd57d2d1102a02f0ad7f0071439704163" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;chr()&lt;/code&gt; and &lt;code&gt;ord()&lt;/code&gt; functions work on whole characters.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7bf018bbe36ec38be15a617cdd0dc65af5cb382c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cmp&lt;/code&gt; (and hence &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt;) operators do not necessarily give the correct results when both operands are UTF-EBCDIC encoded strings and there is a mixture of ASCII and/or control characters, along with other characters.</source>
          <target state="translated">Los operadores &lt;code&gt;cmp&lt;/code&gt; (y por tanto &lt;code&gt;&lt;a href=&quot;functions/sort&quot;&gt;sort&lt;/a&gt;&lt;/code&gt; ) no necesariamente dan los resultados correctos cuando ambos operandos son cadenas codificadas en UTF-EBCDIC y hay una mezcla de ASCII y / o caracteres de control, junto con otros caracteres.</target>
        </trans-unit>
        <trans-unit id="ec09ece4b13035db3b64ac6559a812694d130f2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;color&lt;/code&gt; function determines if colouring should occur or not. Passing it a true or false value will enable or disable colouring respectively, and the function called with no argument will return the current setting.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;color&lt;/code&gt; determina si se debe colorear o no. Pasarle un valor verdadero o falso habilitar&amp;aacute; o deshabilitar&amp;aacute; la coloraci&amp;oacute;n respectivamente, y la funci&amp;oacute;n llamada sin argumento devolver&amp;aacute; la configuraci&amp;oacute;n actual.</target>
        </trans-unit>
        <trans-unit id="fcc832a2467057f7acfd689fa1bb07925f149ce1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;complicated&lt;/code&gt; function will return the same numeric &lt;code&gt;$result&lt;/code&gt; regardless of whether it is called in list or in scalar context.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;complicated&lt;/code&gt; devolver&amp;aacute; el mismo &lt;code&gt;$result&lt;/code&gt; num&amp;eacute;rico independientemente de si se llama en una lista o en un contexto escalar.</target>
        </trans-unit>
        <trans-unit id="f67952b359119ecd8ea38089ffb10eb7987a4172" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; , though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;cond_broadcast&lt;/code&gt; funciona de manera similar a &lt;code&gt;cond_signal&lt;/code&gt; . &lt;code&gt;cond_broadcast&lt;/code&gt; , sin embargo, desbloquear&amp;aacute; &lt;b&gt;todos&lt;/b&gt; los subprocesos que est&amp;aacute;n bloqueados en un &lt;code&gt;cond_wait&lt;/code&gt; en la variable bloqueada, en lugar de solo uno.</target>
        </trans-unit>
        <trans-unit id="2c18198f3431b0af0518f8194180bdd1d59f0718" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_broadcast&lt;/code&gt; function works similarly to &lt;code&gt;cond_signal&lt;/code&gt;. &lt;code&gt;cond_broadcast&lt;/code&gt;, though, will unblock &lt;b&gt;all&lt;/b&gt; the threads that are blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on the locked variable, rather than only one.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a85c76c4fd238a57c5f21f762fcaeb20729d17df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;cond_signal&lt;/code&gt; toma una variable &lt;b&gt;bloqueada&lt;/b&gt; como par&amp;aacute;metro y desbloquea un hilo que est&amp;aacute; &lt;code&gt;cond_wait&lt;/code&gt; en esa variable. Si m&amp;aacute;s de un hilo est&amp;aacute; bloqueado en un &lt;code&gt;cond_wait&lt;/code&gt; en esa variable, solo uno (y cu&amp;aacute;l es indeterminado) se desbloquear&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="17177c8bfdab5cbbef640ed5fdbe840af84bd3e1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt;ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c5be06c4673c5f0381dc64821a424c5ce57dffbf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt; ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;cond_signal&lt;/code&gt; toma una variable bloqueada como par&amp;aacute;metro y desbloquea un hilo que est&amp;aacute; &lt;code&gt;cond_wait&lt;/code&gt; en esa variable. Si m&amp;aacute;s de un hilo est&amp;aacute; bloqueado en un &lt;code&gt;cond_wait&lt;/code&gt; en esa variable, solo uno (y cu&amp;aacute;l es indeterminado) se desbloquear&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="90834b3f231b489213b8a6d3ee5e7273db92badc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_signal&lt;/code&gt; function takes a locked variable as a parameter and unblocks one thread that's &lt;code&gt;cond_wait&lt;/code&gt;ing on that variable. If more than one thread is blocked in a &lt;code&gt;cond_wait&lt;/code&gt; on that variable, only one (and which one is indeterminate) will be unblocked.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="076e7dbb91376a2a5dc565f0cafe6a8c9c90bfab" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;cond_wait&lt;/code&gt; toma una variable &lt;b&gt;bloqueada&lt;/b&gt; como par&amp;aacute;metro, desbloquea la variable y bloquea hasta que otro subproceso realiza una &lt;code&gt;cond_signal&lt;/code&gt; o &lt;code&gt;cond_broadcast&lt;/code&gt; para esa misma variable bloqueada. La variable que &lt;code&gt;cond_wait&lt;/code&gt; bloque&amp;oacute; se vuelve a bloquear despu&amp;eacute;s de que se satisfaga &lt;code&gt;cond_wait&lt;/code&gt; . Si hay varios subprocesos &lt;code&gt;cond_wait&lt;/code&gt; ing en la misma variable, todos menos uno se volver&amp;aacute;n a bloquear en espera de volver a adquirir el bloqueo en la variable. (Entonces, si solo est&amp;aacute; usando &lt;code&gt;cond_wait&lt;/code&gt; para la sincronizaci&amp;oacute;n, abandone el bloqueo lo antes posible). Las dos acciones de desbloquear la variable y entrar en el estado de espera bloqueada son at&amp;oacute;micas, las dos acciones de salir del estado de espera bloqueada y volver a bloquear la variable no lo son.</target>
        </trans-unit>
        <trans-unit id="439f35352dbf1d510415ebca01133fb2e86790ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is re-locked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt;ing on the same variable, all but one will re-block waiting to reacquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible). The two actions of unlocking the variable and entering the blocked wait state are atomic, the two actions of exiting from the blocked wait state and re-locking the variable are not.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0fa04a005ef5fee3bbdeb8f830aca63065ce2e7e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt; ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;cond_wait&lt;/code&gt; toma una variable &lt;b&gt;bloqueada&lt;/b&gt; como par&amp;aacute;metro, desbloquea la variable y bloquea hasta que otro subproceso realiza una &lt;code&gt;cond_signal&lt;/code&gt; o &lt;code&gt;cond_broadcast&lt;/code&gt; para esa misma variable bloqueada. La variable en la que &lt;code&gt;cond_wait&lt;/code&gt; bloque&amp;oacute; se vuelve a bloquear despu&amp;eacute;s de que se satisfaga &lt;code&gt;cond_wait&lt;/code&gt; . Si hay varios subprocesos &lt;code&gt;cond_wait&lt;/code&gt; ing en la misma variable, todos menos uno se volver&amp;aacute;n a bloquear esperando volver a adquirir el bloqueo en la variable. (Entonces, si solo usa &lt;code&gt;cond_wait&lt;/code&gt; para la sincronizaci&amp;oacute;n, abandone el bloqueo lo antes posible).</target>
        </trans-unit>
        <trans-unit id="ad78498a67881045948d88db7f3bfb4f745feb3d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cond_wait&lt;/code&gt; function takes a &lt;b&gt;locked&lt;/b&gt; variable as a parameter, unlocks the variable, and blocks until another thread does a &lt;code&gt;cond_signal&lt;/code&gt; or &lt;code&gt;cond_broadcast&lt;/code&gt; for that same locked variable. The variable that &lt;code&gt;cond_wait&lt;/code&gt; blocked on is relocked after the &lt;code&gt;cond_wait&lt;/code&gt; is satisfied. If there are multiple threads &lt;code&gt;cond_wait&lt;/code&gt;ing on the same variable, all but one will reblock waiting to re-acquire the lock on the variable. (So if you're only using &lt;code&gt;cond_wait&lt;/code&gt; for synchronization, give up the lock as soon as possible.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c05e65092ed5c30b3ec99766dc7198ef2d697366" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;condition&lt;/code&gt; can have several forms. The first form is simply an integer in parentheses &lt;code&gt;(integer)&lt;/code&gt; . It is true if the corresponding backreference &lt;code&gt;\integer&lt;/code&gt; matched earlier in the regexp. The same thing can be done with a name associated with a capture group, written as &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; or &lt;code&gt;('name')&lt;/code&gt; . The second form is a bare zero-width assertion &lt;code&gt;(?...)&lt;/code&gt;, either a lookahead, a lookbehind, or a code assertion (discussed in the next section). The third set of forms provides tests that return true if the expression is executed within a recursion (&lt;code&gt;(R)&lt;/code&gt; ) or is being called from some capturing group, referenced either by number (&lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; ,...) or by name (&lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</source>
          <target state="translated">La &lt;code&gt;condition&lt;/code&gt; puede tener varias formas. La primera forma es simplemente un n&amp;uacute;mero entero entre par&amp;eacute;ntesis &lt;code&gt;(integer)&lt;/code&gt; . Es cierto si la referencia inversa &lt;code&gt;\integer&lt;/code&gt; correspondiente coincidi&amp;oacute; anteriormente en la expresi&amp;oacute;n regular . Lo mismo se puede hacer con un nombre asociado con un grupo de captura, escrito como &lt;code&gt;(&amp;lt;name&amp;gt;)&lt;/code&gt; o &lt;code&gt;('name')&lt;/code&gt; . La segunda forma es una aserci&amp;oacute;n de ancho cero &lt;code&gt;(?...)&lt;/code&gt; , ya sea una b&amp;uacute;squeda anticipada, una b&amp;uacute;squeda retrospectiva o una aserci&amp;oacute;n de c&amp;oacute;digo (discutida en la siguiente secci&amp;oacute;n). El tercer conjunto de formularios proporciona pruebas que devuelven verdadero si la expresi&amp;oacute;n se ejecuta dentro de una recursividad ( &lt;code&gt;(R)&lt;/code&gt; ) o se llama desde alg&amp;uacute;n grupo de captura, referenciado por n&amp;uacute;mero ( &lt;code&gt;(R1)&lt;/code&gt; , &lt;code&gt;(R2)&lt;/code&gt; , ...) o por su nombre ( &lt;code&gt;(R&amp;amp;name)&lt;/code&gt; ).</target>
        </trans-unit>
        <trans-unit id="ad47d7c085885e724ad5ee56f7fe5e436f8b9c0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context()&lt;/code&gt; function will always return the current context. If there is already a context active, it will be returned. If there is not an active context, one will be generated. When a context is generated it will default to using the file and line number where the currently running sub was called from.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4ec10fe3aaaca1b55ef86de9fafc8bbe404ebad2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;context()&lt;/code&gt; method is your primary interface into the Test2 framework.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bf42e706aa15e3b9613116ccaae1bce3997d5965" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;copy&lt;/code&gt; function takes two parameters: a file to copy from and a file to copy to. Either argument may be a string, a FileHandle reference or a FileHandle glob. Obviously, if the first argument is a filehandle of some sort, it will be read from, and if it is a file</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;copy&lt;/code&gt; toma dos par&amp;aacute;metros: un archivo para copiar y un archivo para copiar. Cualquiera de los dos argumentos puede ser una cadena, una referencia FileHandle o un glob FileHandle. Obviamente, si el primer argumento es un identificador de archivo de alg&amp;uacute;n tipo, se leer&amp;aacute; desde, y si es un archivo</target>
        </trans-unit>
        <trans-unit id="bb585d66ac9e0baf39acd70331ff3f0f5eef7b95" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt; ). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt; ) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="translated">El filtro &lt;code&gt;cpp&lt;/code&gt; no se aplica al texto del m&amp;oacute;dulo Fred, solo al texto del archivo que lo utiliz&amp;oacute; ( &lt;code&gt;cpp_test&lt;/code&gt; ). Aunque la declaraci&amp;oacute;n de uso en la l&amp;iacute;nea 3 pasar&amp;aacute; por el filtro cpp, el m&amp;oacute;dulo que se incluye ( &lt;code&gt;Fred&lt;/code&gt; ) no lo har&amp;aacute;. Los flujos de origen se ven as&amp;iacute; despu&amp;eacute;s de analizar la l&amp;iacute;nea 3 y antes de analizar la l&amp;iacute;nea 4:</target>
        </trans-unit>
        <trans-unit id="cb5beac8049360b845cf124791fe07ff9a12d34c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;cpp&lt;/code&gt; filter does not apply to the text of the Fred module, only to the text of the file that used it (&lt;code&gt;cpp_test&lt;/code&gt;). Although the use statement on line 3 will pass through the cpp filter, the module that gets included (&lt;code&gt;Fred&lt;/code&gt;) will not. The source streams look like this after line 3 has been parsed and before line 4 is parsed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3a0e889b0f475939308ccb8373e116461d3751c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;create()&lt;/code&gt; method takes a reference to a subroutine and creates a new thread that starts executing in the referenced subroutine. Control then passes both to the subroutine and the caller.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;create()&lt;/code&gt; toma una referencia a una subrutina y crea un nuevo hilo que comienza a ejecutarse en la subrutina referenciada. Luego, el control pasa tanto a la subrutina como a la persona que llama.</target>
        </trans-unit>
        <trans-unit id="4daee3058488514b062a77504cbed0c79eee6390" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;crypt&lt;/code&gt; operator uses the &lt;code&gt;sys$hash_password&lt;/code&gt; system service to generate the hashed representation of PLAINTEXT. If USER is a valid username, the algorithm and salt values are taken from that user's UAF record. If it is not, then the preferred algorithm and a salt of 0 are used. The quadword encrypted value is returned as an 8-character string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3224bd5303e6f5ddff9eaa9e8454f4b95ad9fcd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;curlen&lt;/code&gt; length parameter passed in was too small, and the function was prevented from examining all the necessary bytes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="39b2e5dabf98fd166f3cc23d1829d0ea566d66df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;declare()&lt;/code&gt; method always creates dotted-decimal version objects. When used in a module, you &lt;b&gt;must&lt;/b&gt; put it on the same line as &quot;use version&quot; to ensure that $VERSION is read correctly by PAUSE and installer tools. You should also add 'version' to the 'configure_requires' section of your module metadata file. See instructions in &lt;a href=&quot;ExtUtils::MakeMaker&quot;&gt;ExtUtils::MakeMaker&lt;/a&gt; or &lt;a href=&quot;Module::Build&quot;&gt;Module::Build&lt;/a&gt; for details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af1cb7eb6b21f006259e64b150fa56903267e60" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete local EXPR&lt;/code&gt; construct can also be used to localize the deletion of array/hash elements to the current block. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;&quot;Localized deletion of elements of composite types&quot; in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="69524f53f96840e72cc2460d82457b60c364f5a2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;delete local EXPR&lt;/code&gt; construct localizes the deletion to the current block at run time. Until the block exits, elements locally deleted temporarily no longer exist. See &lt;a href=&quot;perlsub#Localized-deletion-of-elements-of-composite-types&quot;&gt;&quot;Localized deletion of elements of composite types&quot; in perlsub&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="30b3d6c14b075946962dafa1dc3a2886740f908a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;diagnostics&lt;/code&gt; Pragma</source>
          <target state="translated">El Pragma del &lt;code&gt;diagnostics&lt;/code&gt;</target>
        </trans-unit>
        <trans-unit id="086b0e345be46fb23c5d4022bc1b3516ac49d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;display_format&lt;/code&gt; class method and the corresponding &lt;code&gt;display_format&lt;/code&gt; object method can now be called using a parameter hash instead of just a one parameter.</source>
          <target state="translated">El m&amp;eacute;todo de clase &lt;code&gt;display_format&lt;/code&gt; y el m&amp;eacute;todo de objeto &lt;code&gt;display_format&lt;/code&gt; correspondiente ahora se pueden llamar usando un par&amp;aacute;metro hash en lugar de solo un par&amp;aacute;metro.</target>
        </trans-unit>
        <trans-unit id="a9abe66ed186f7fcb344af8814b57766600779f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;do {}&lt;/code&gt; construct isn't a real loop that you can use loop control on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="85937d63d0c2a7155254307de5c15a8dc64cc7fd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;done&lt;/code&gt; method returns true if the thread you're checking has finished, and false otherwise.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;done&lt;/code&gt; devuelve verdadero si el hilo que est&amp;aacute; comprobando ha finalizado y falso en caso contrario.</target>
        </trans-unit>
        <trans-unit id="322d30ea9fcb9b2fb4107fa041a490d3eef3fbe8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;dontfrag&lt;/code&gt; argument sets the IP_DONTFRAG bit, but note that IP_DONTFRAG is not yet defined by Socket, and not available on many systems. Then it is ignored. On linux it also sets IP_MTU_DISCOVER to IP_PMTUDISC_DO but need we don't chunk oversized packets. You need to set $data_size manually.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5c42a2b150a081cef9d9a1db39370eb144f13339" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;down&lt;/code&gt; disminuye la cuenta del sem&amp;aacute;foro en el n&amp;uacute;mero especificado (que debe ser un n&amp;uacute;mero entero&amp;gt; = 1), o en uno si no se especifica ning&amp;uacute;n n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="1d986e9044d0332c0e0b20d1b476092f758b1763" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_force&lt;/code&gt; method decreases the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified. This method does not block, and may cause the semaphore's count to drop below zero.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;down_force&lt;/code&gt; disminuye la cuenta del sem&amp;aacute;foro en el n&amp;uacute;mero especificado (que debe ser un n&amp;uacute;mero entero&amp;gt; = 1), o en uno si no se especifica ning&amp;uacute;n n&amp;uacute;mero. Este m&amp;eacute;todo no bloquea y puede hacer que la cuenta del sem&amp;aacute;foro caiga por debajo de cero.</target>
        </trans-unit>
        <trans-unit id="59032671c2f862c61987094dab4187139af577bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_nb&lt;/code&gt; method attempts to decrease the semaphore's count by the specified number (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;down_nb&lt;/code&gt; intenta disminuir el conteo del sem&amp;aacute;foro por el n&amp;uacute;mero especificado (que debe ser un entero&amp;gt; = 1), o por uno si no se especifica ning&amp;uacute;n n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="ad817bd0c55a8a17c45e80be5bfb80185a6f0a13" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;down_timed&lt;/code&gt; method attempts to decrease the semaphore's count by 1 or by the specified number within the specified timeout period given in seconds (which must be an integer &amp;gt;= 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="81b4509e2a48be8cd2c584657729b851defbc375" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;each()&lt;/code&gt; operator can be a bit tricky though. You can't add or delete keys of the hash while you're using it without possibly skipping or re-processing some pairs after Perl internally rehashes all of the elements. Additionally, a hash has only one iterator, so if you mix &lt;code&gt;keys&lt;/code&gt;, &lt;code&gt;values&lt;/code&gt;, or &lt;code&gt;each&lt;/code&gt; on the same hash, you risk resetting the iterator and messing up your processing. See the &lt;code&gt;each&lt;/code&gt; entry in &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for more details.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9eb0881abe1e42d6f6890023e371e6cf04aeaeaa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;each&lt;/code&gt; operator returns the pairs in apparently random order, so if ordering matters to you, you'll have to stick with the &lt;code&gt;keys&lt;/code&gt; method.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ac628ac906a6e8c64ae1a2404030120f69cfb8c8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;else&lt;/code&gt; branch should be used for the really ultimate fallback, not for code specific to some platform.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="48ce45b8c5dc5a90ffb8cc26e428eb8e7134ca2e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eogc&lt;/code&gt; flags are stripped out before being passed to the comp routine. The regex engine does not need to know if any of these are set, as those flags should only affect what Perl does with the pattern and its match variables, not how it gets compiled and executed.</source>
          <target state="translated">Los indicadores &lt;code&gt;eogc&lt;/code&gt; se eliminan antes de pasar a la rutina de compilaci&amp;oacute;n . El motor de expresiones regulares no necesita saber si alguno de estos est&amp;aacute; configurado, ya que esos indicadores solo deber&amp;iacute;an afectar lo que Perl hace con el patr&amp;oacute;n y sus variables de coincidencia, no c&amp;oacute;mo se compila y ejecuta.</target>
        </trans-unit>
        <trans-unit id="5dcaf0131993c2fe373ceb68066111b75397ce84" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;equal()&lt;/code&gt; method takes two thread objects and returns true if the objects represent the same thread, and false if they don't.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;equal()&lt;/code&gt; toma dos objetos de hilo y devuelve verdadero si los objetos representan el mismo hilo y falso si no lo hacen.</target>
        </trans-unit>
        <trans-unit id="49890ceef3269a9849305b4a6f9b549bc3f0c714" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;errno&lt;/code&gt; value is optional. In versions of &lt;code&gt;autodie::exception&lt;/code&gt; 1.99 and earlier the code would try to automatically use the current value of &lt;code&gt;$!&lt;/code&gt;, but this was unreliable and is no longer supported.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bd5c1caef84073c78e4b57183c72209f1a463dd1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;eval&lt;/code&gt; method wrapped an &lt;code&gt;eval&lt;/code&gt; around a &lt;code&gt;join&lt;/code&gt;, and so waited for a thread to exit, passing along any values the thread might have returned and placing any errors into &lt;code&gt;$@&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80af1149bc4ce69fb624da74e40c6a5dafd9409" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;examples&lt;/code&gt; sub-directory has copies of all these filters implemented both as</source>
          <target state="translated">El subdirectorio de &lt;code&gt;examples&lt;/code&gt; tiene copias de todos estos filtros implementados tanto como</target>
        </trans-unit>
        <trans-unit id="1c3c6e01b0d3bd33a4ed4055dd31b80304ebc9d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;exec&lt;/code&gt; function's job is to turn your process into another command and never to return. If that's not what you want to do, don't use &lt;code&gt;exec&lt;/code&gt;. :)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cc84f2c59070bf508814fa3ebed34092fe0cca71" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;experimental&lt;/code&gt; pragma exists to combine the required incantations into a single interface stable across releases of perl. For every experimental feature, this should enable the feature and silence warnings for the enclosing lexical scope:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="472a34a62dd6bdcf8df5e53d452c5f9dca79546f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extra_mappings&lt;/code&gt; arguments takes a hash ref with the same type of structure as described in &lt;a href=&quot;CPAN::Meta::Spec&quot;&gt;CPAN::Meta::Spec&lt;/a&gt;, except with its values as one of the &lt;a href=&quot;#MERGE-STRATEGIES&quot;&gt;defined merge strategies&lt;/a&gt; or a code ref to a merging function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a371087f59ef9684a3303b0318405ae011e9ec34" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_delimited&lt;/code&gt; function formalizes the common idiom of extracting a single-character-delimited substring from the start of a string. For example, to extract a single-quote delimited string, the following code is typically used:</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;extract_delimited&lt;/code&gt; formaliza el lenguaje com&amp;uacute;n de extraer una subcadena delimitada por un solo car&amp;aacute;cter desde el principio de una cadena. Por ejemplo, para extraer una cadena delimitada por comillas simples, normalmente se usa el siguiente c&amp;oacute;digo:</target>
        </trans-unit>
        <trans-unit id="01013bd276b6d8fe2331fe338d632601823957b8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;extract_multiple&lt;/code&gt; subroutine takes a string to be processed and a list of extractors (subroutines or regular expressions) to apply to that string.</source>
          <target state="translated">La subrutina &lt;code&gt;extract_multiple&lt;/code&gt; toma una cadena para ser procesada y una lista de extractores (subrutinas o expresiones regulares) para aplicar a esa cadena.</target>
        </trans-unit>
        <trans-unit id="0234e9715d2d58dfe4e40eada785cc5d3ba85e48" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fail&lt;/code&gt; option indicates the action to be taken if a matching end tag is not encountered (i.e. before the end of the string or some &lt;code&gt;reject&lt;/code&gt; pattern matches). By default, a failure to match a closing tag causes &lt;code&gt;extract_tagged&lt;/code&gt; to immediately fail.</source>
          <target state="translated">La opci&amp;oacute;n de &lt;code&gt;fail&lt;/code&gt; indica la acci&amp;oacute;n que se debe tomar si no se encuentra una etiqueta final coincidente (es decir, antes del final de la cadena o alguna coincidencia de patr&amp;oacute;n de &lt;code&gt;reject&lt;/code&gt; ). De forma predeterminada, el hecho de no coincidir con una etiqueta de cierre hace que &lt;code&gt;extract_tagged&lt;/code&gt; falle inmediatamente.</target>
        </trans-unit>
        <trans-unit id="7fdb136937ca0405fd0e09f20f2a40c4f858261d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;failed&lt;/code&gt; command reports all distributions that failed on one of &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; or &lt;code&gt;install&lt;/code&gt; for some reason in the currently running shell session.</source>
          <target state="translated">El comando &lt;code&gt;failed&lt;/code&gt; informa todas las distribuciones que fallaron en una de las &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; o &lt;code&gt;install&lt;/code&gt; por alguna raz&amp;oacute;n en la sesi&amp;oacute;n de shell que se est&amp;aacute; ejecutando actualmente.</target>
        </trans-unit>
        <trans-unit id="5ad80da9f3017cad820985c782b83967ca308a28" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;family&lt;/code&gt; hint to getaddrinfo(), or the family of the socket address passed to getnameinfo() is not supported.</source>
          <target state="translated">La sugerencia de &lt;code&gt;family&lt;/code&gt; para getaddrinfo (), o la familia de la direcci&amp;oacute;n de socket pasada a getnameinfo () no es compatible.</target>
        </trans-unit>
        <trans-unit id="acd804f7e1462316c1795d1b040a724ba816aee2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; command just updates the &lt;code&gt;camel&lt;/code&gt; refs, as the objects themselves should have been fetched when pulling from &lt;code&gt;origin&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aaa028e0e10b907654ea97ca6e2e56dbd54cf34e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt; . We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="translated">La utilidad de &lt;code&gt;fetch&lt;/code&gt; est&amp;aacute; disponible en FreeBSD. NetBSD y Dragonfly BSD tambi&amp;eacute;n pueden tenerlo de &lt;code&gt;pkgsrc&lt;/code&gt; . Solo verificamos la &lt;code&gt;fetch&lt;/code&gt; en esas tres plataformas.</target>
        </trans-unit>
        <trans-unit id="88909127a630a0e568460e4ef567fdf6cebea70a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fetch&lt;/code&gt; utility is available on FreeBSD. NetBSD and Dragonfly BSD may also have it from &lt;code&gt;pkgsrc&lt;/code&gt;. We only check for &lt;code&gt;fetch&lt;/code&gt; on those three platforms.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9e227d5e7190288807dd09d5662a48f3b24c6088" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fforce&lt;/code&gt; pragma is a variant that emulates a &lt;code&gt;force get&lt;/code&gt; which erases the entire memory followed by the action specified, effectively restarting the whole get/make/test/install procedure from scratch.</source>
          <target state="translated">El pragma &lt;code&gt;fforce&lt;/code&gt; es una variante que emula un &lt;code&gt;force get&lt;/code&gt; que borra toda la memoria seguida de la acci&amp;oacute;n especificada, reiniciando efectivamente todo el procedimiento get / make / test / install desde cero.</target>
        </trans-unit>
        <trans-unit id="67136aec5c09887a5fbdbeaf79603ace225d72fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fields&lt;/code&gt; pragma enables compile-time and run-time verified class fields.</source>
          <target state="translated">El pragma de &lt;code&gt;fields&lt;/code&gt; habilita campos de clase verificados en tiempo de compilaci&amp;oacute;n y tiempo de ejecuci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="1da25c8608c050c137eec0fcb8b96dfa9d530dcf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt; , &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="translated">El &lt;code&gt;filename&lt;/code&gt; , las &lt;code&gt;flags&lt;/code&gt; y los par&amp;aacute;metros de &lt;code&gt;mode&lt;/code&gt; son el equivalente directo de sus contrapartes dbopen (). El par&amp;aacute;metro final $ DB_HASH realiza la funci&amp;oacute;n de los par&amp;aacute;metros &lt;code&gt;type&lt;/code&gt; y &lt;code&gt;openinfo&lt;/code&gt; en dbopen ().</target>
        </trans-unit>
        <trans-unit id="d57b7b57482f3e0bdad4f727d65fbd7d3f8d08ef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;filename&lt;/code&gt;, &lt;code&gt;flags&lt;/code&gt; and &lt;code&gt;mode&lt;/code&gt; parameters are the direct equivalent of their dbopen() counterparts. The final parameter $DB_HASH performs the function of both the &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;openinfo&lt;/code&gt; parameters in dbopen().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="711049b66f21cfb21f8abf404e302b9cb973606c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;fileparse()&lt;/code&gt; routine divides a file path into its $dirs, $filename and (optionally) the filename $suffix.</source>
          <target state="translated">La rutina &lt;code&gt;fileparse()&lt;/code&gt; divide la ruta de un archivo en sus $ directorios, $ nombre de archivo y (opcionalmente) el nombre de archivo $ sufijo.</target>
        </trans-unit>
        <trans-unit id="2894a076625213bf8472ba18a1068c216ff2972b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;finalize&lt;/code&gt; method is always the last thing called on the formatter,</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2c20640b93e6e1928bfa39a7352c6c3efb0f1519" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; set to display &lt;code&gt;isPRINT()&lt;/code&gt;able characters as themselves, &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; to display the &lt;code&gt;\\[nrfta\\]&lt;/code&gt; as the backslashed versions (like &lt;code&gt;&quot;\n&quot;&lt;/code&gt;) (&lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; is preferred over &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; for &lt;code&gt;&quot;\\&quot;&lt;/code&gt;). &lt;code&gt;UNI_DISPLAY_QQ&lt;/code&gt; (and its alias &lt;code&gt;UNI_DISPLAY_REGEX&lt;/code&gt;) have both &lt;code&gt;UNI_DISPLAY_BACKSLASH&lt;/code&gt; and &lt;code&gt;UNI_DISPLAY_ISPRINT&lt;/code&gt; turned on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="602708ab2289d55123d1e5cfa483278e5dc2b095" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument can have UNI_DISPLAY_ISPRINT set to display isPRINT()able characters as themselves, UNI_DISPLAY_BACKSLASH to display the \\[nrfta\\] as the backslashed versions (like '\n') (UNI_DISPLAY_BACKSLASH is preferred over UNI_DISPLAY_ISPRINT for \\). UNI_DISPLAY_QQ (and its alias UNI_DISPLAY_REGEX) have both UNI_DISPLAY_BACKSLASH and UNI_DISPLAY_ISPRINT turned on.</source>
          <target state="translated">El argumento de &lt;code&gt;flags&lt;/code&gt; puede tener UNI_DISPLAY_ISPRINT configurado para mostrar los caracteres capaces de isPRINT () como ellos mismos, UNI_DISPLAY_BACKSLASH para mostrar el \\ [nrfta \\] como las versiones invertidas (como '\ n') (se prefiere UNI_DISPLAY_BACKSLASH sobre UNI_DISPLAY_ISPR). UNI_DISPLAY_QQ (y su alias UNI_DISPLAY_REGEX) tienen UNI_DISPLAY_BACKSLASH y UNI_DISPLAY_ISPRINT activados.</target>
        </trans-unit>
        <trans-unit id="45b476535dde9c4df2a5ce21abd7562e13744b06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;&quot;pv_uni_display&quot;&lt;/a&gt;().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="db2dfe02c9ae062f42652141438a9f9714c71cea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; argument is as in &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt;().</source>
          <target state="translated">El argumento &lt;code&gt;flags&lt;/code&gt; es como en &lt;a href=&quot;#pv_uni_display&quot;&gt;pv_uni_display&lt;/a&gt; ().</target>
        </trans-unit>
        <trans-unit id="99738c77e0f1da5722068673963c4a8f215d0b31" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; can be:</source>
          <target state="translated">Las &lt;code&gt;flags&lt;/code&gt; pueden ser:</target>
        </trans-unit>
        <trans-unit id="cefd6d4dfafa940aea51a92bdcb195eed2de69a7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; method returned the flags for the thread - an integer value corresponding to the internal flags for the thread.</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;flags&lt;/code&gt; devolvi&amp;oacute; las banderas del subproceso, un valor entero correspondiente a las banderas internas del subproceso.</target>
        </trans-unit>
        <trans-unit id="8425d60192539121edf35ab62976eb395bc2a704" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; option is optional and defaults to &lt;code&gt;0&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6cca4f06215bca47eddea026c40afe1b9a43be1d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter can be used to determine which of these operations the callbacks should respond to. The following flags are currently defined:</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;flags&lt;/code&gt; se puede utilizar para determinar a cu&amp;aacute;l de estas operaciones deben responder las devoluciones de llamada. Las siguientes banderas est&amp;aacute;n definidas actualmente:</target>
        </trans-unit>
        <trans-unit id="459faaa5e3280fee22284d6b094987c77fa7de30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter in all the</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;flags&lt;/code&gt; en todos los</target>
        </trans-unit>
        <trans-unit id="bfe1865df397f3698f54ec1b600413c38607abed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; is in effect.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;flags&lt;/code&gt; es un campo de bits que indica con cu&amp;aacute;l de las banderas &lt;code&gt;msixpn&lt;/code&gt; se compil&amp;oacute; la expresi&amp;oacute;n regular. Tambi&amp;eacute;n contiene informaci&amp;oacute;n adicional, como si la &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; locale&lt;/code&gt; &lt;a href=&quot;functions/use&quot;&gt;uso&lt;/a&gt; est&amp;aacute; en vigor.</target>
        </trans-unit>
        <trans-unit id="6fd73fe1f5c776efd0dba4ac9a66a7649c62b563" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is a bitfield which indicates which of the &lt;code&gt;msixpn&lt;/code&gt; flags the regex was compiled with. It also contains additional info, such as if &lt;code&gt;use locale&lt;/code&gt; is in effect.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="600009146ad8caeb28aa4266bb11bcc93c6081be" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is reserved for future use, and must always be zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="41b4f74a7487e51319a762323a60ac4f87b549c7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flags&lt;/code&gt; parameter is reserved for future use. Currently it is only used by perl internally, so extensions should always pass zero.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b886ddfa56e0b9ebfe8f2070d41589a1086768dd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;flush_cache()&lt;/code&gt; function will raise a run-time error unless the tied package provides a &lt;code&gt;CLEAR&lt;/code&gt; method.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;flush_cache()&lt;/code&gt; generar&amp;aacute; un error en tiempo de ejecuci&amp;oacute;n a menos que el paquete vinculado proporcione un m&amp;eacute;todo &lt;code&gt;CLEAR&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="124f73ccb9aad8a6d48616fcbcb3b56af5616b10" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;for(each)&lt;/code&gt; modifier is an iterator: it executes the statement once for each item in the LIST (with &lt;code&gt;$_&lt;/code&gt; aliased to each item in turn). There is no syntax to specify a C-style for loop or a lexically scoped iteration variable in this form.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8ee8bf6c49cb0d370b573c84b81eeff22daa626c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;force&lt;/code&gt; pragma may precede another command (currently: &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; , or &lt;code&gt;install&lt;/code&gt; ) to execute the command from scratch and attempt to continue past certain errors. See the section below on the &lt;code&gt;force&lt;/code&gt; and the &lt;code&gt;fforce&lt;/code&gt; pragma.</source>
          <target state="translated">El pragma de &lt;code&gt;force&lt;/code&gt; puede preceder a otro comando (actualmente: &lt;code&gt;get&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;test&lt;/code&gt; o &lt;code&gt;install&lt;/code&gt; ) para ejecutar el comando desde cero e intentar continuar pasando ciertos errores. Consulte la secci&amp;oacute;n siguiente sobre la &lt;code&gt;force&lt;/code&gt; y el pragma &lt;code&gt;fforce&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="34f4026c135fb9c9e701839369f22ab72881f9e4" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt; , that could be written like this:</source>
          <target state="translated">El &lt;code&gt;foreach&lt;/code&gt; es la forma no experimental de establecer un topicalizador. Si desea utilizar el altamente experimental &lt;code&gt;given&lt;/code&gt; , que podr&amp;iacute;a escribirse as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="8adf50b4a12807b9b440b3e9dd59f76950784e30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; is the non-experimental way to set a topicalizer. If you wish to use the highly experimental &lt;code&gt;given&lt;/code&gt;, that could be written like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="de226564415ab69d6441fa2857763cf2ce5fdae3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword, so you can use either. If VAR is omitted, &lt;code&gt;$_&lt;/code&gt; is set to each value.</source>
          <target state="translated">La palabra clave &lt;code&gt;foreach&lt;/code&gt; es en realidad un sin&amp;oacute;nimo de la palabra clave &lt;code&gt;for&lt;/code&gt; , por lo que puede usar cualquiera de las dos. Si se omite VAR, &lt;code&gt;$_&lt;/code&gt; se establece en cada valor.</target>
        </trans-unit>
        <trans-unit id="eb1c9008000e928d5125162497dd929b484cbedf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;&quot;Foreach Loops&quot; in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="375dcc1d1d2f6f42cca4896811ca8fdfa2d3b491" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; keyword is actually a synonym for the &lt;code&gt;for&lt;/code&gt; keyword. See &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">La palabra clave &lt;code&gt;foreach&lt;/code&gt; es en realidad un sin&amp;oacute;nimo de la palabra clave &lt;code&gt;for&lt;/code&gt; . Consulte &lt;code&gt;&lt;a href=&quot;perlsyn#Foreach-Loops&quot;&gt;Foreach Loops in perlsyn&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="b86bb402e5da8037aee4e69efe060f892f194612" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt;, or &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; after the backslash:</source>
          <target state="translated">El bucle &lt;code&gt;foreach&lt;/code&gt; tambi&amp;eacute;n puede tomar un constructor de referencia para su variable de bucle, aunque la sintaxis se limita a uno de los siguientes, con un &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/state&quot;&gt;state&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/our&quot;&gt;our&lt;/a&gt;&lt;/code&gt; opcional despu&amp;eacute;s de la barra invertida:</target>
        </trans-unit>
        <trans-unit id="21bbc47a2581808651eb8a89a9f603b84e2a2657" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop can also take a reference constructor for its loop variable, though the syntax is limited to one of the following, with an optional &lt;code&gt;my&lt;/code&gt;, &lt;code&gt;state&lt;/code&gt;, or &lt;code&gt;our&lt;/code&gt; after the backslash:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d9c367bfb9bb4dab65fff1b13521d38572d69dfe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="translated">El bucle &lt;code&gt;foreach&lt;/code&gt; tiene por defecto el &amp;aacute;mbito de su variable de &amp;iacute;ndice din&amp;aacute;micamente en forma de &lt;code&gt;&lt;a href=&quot;functions/local&quot;&gt;local&lt;/a&gt;&lt;/code&gt; . Sin embargo, si la variable de &amp;iacute;ndice tiene como prefijo la palabra clave &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , o si ya hay un l&amp;eacute;xico con ese nombre en el alcance, entonces se crea un nuevo l&amp;eacute;xico en su lugar. As&amp;iacute; en el bucle</target>
        </trans-unit>
        <trans-unit id="fc6d0492eecb0b7b77ecb47ab19f74f65e2c9439" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop defaults to scoping its index variable dynamically in the manner of &lt;code&gt;local&lt;/code&gt;. However, if the index variable is prefixed with the keyword &lt;code&gt;my&lt;/code&gt;, or if there is already a lexical by that name in scope, then a new lexical is created instead. Thus in the loop</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4c4603cb509242d80999a110064359f577c21d6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="translated">El bucle &lt;code&gt;foreach&lt;/code&gt; itera sobre un valor de lista normal y establece la variable escalar VAR para que sea cada elemento de la lista a su vez. Si la variable est&amp;aacute; precedida por la palabra clave &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , entonces tiene un &amp;aacute;mbito l&amp;eacute;xico y, por lo tanto, solo es visible dentro del bucle. De lo contrario, la variable es impl&amp;iacute;citamente local al ciclo y recupera su valor anterior al salir del ciclo. Si la variable se declar&amp;oacute; previamente con &lt;code&gt;&lt;a href=&quot;functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; , usa esa variable en lugar de la global, pero a&amp;uacute;n est&amp;aacute; localizada en el ciclo. Esta localizaci&amp;oacute;n impl&amp;iacute;cita ocurre</target>
        </trans-unit>
        <trans-unit id="d0916d837b24f716ed6d234f4dd39fce8bf3c636" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;foreach&lt;/code&gt; loop iterates over a normal list value and sets the scalar variable VAR to be each element of the list in turn. If the variable is preceded with the keyword &lt;code&gt;my&lt;/code&gt;, then it is lexically scoped, and is therefore visible only within the loop. Otherwise, the variable is implicitly local to the loop and regains its former value upon exiting the loop. If the variable was previously declared with &lt;code&gt;my&lt;/code&gt;, it uses that variable instead of the global one, but it's still localized to the loop. This implicit localization occurs</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb381f2681e84a2954e18395a958e606ca6cba3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;frame&lt;/code&gt; option can be used to control the output of frame information. For example, contrast this expression trace:</source>
          <target state="translated">La opci&amp;oacute;n de &lt;code&gt;frame&lt;/code&gt; se puede utilizar para controlar la salida de informaci&amp;oacute;n de marco. Por ejemplo, contrasta este rastro de expresi&amp;oacute;n:</target>
        </trans-unit>
        <trans-unit id="591f72361e30bcbf229773b985f4b81bad64b394" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gateway&lt;/code&gt; argument is only valid for IPv6, and requires a IPv6 address.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="01af8f56de621025abc07dc645713da63a5fe927" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gen_delimited_pat&lt;/code&gt; subroutine takes a single (string) argument and &amp;gt; builds a Friedl-style optimized regex that matches a string delimited by any one of the characters in the single argument. For example:</source>
          <target state="translated">La subrutina &lt;code&gt;gen_delimited_pat&lt;/code&gt; toma un solo argumento (cadena) y&amp;gt; construye una expresi&amp;oacute;n regular optimizada al estilo de Friedl que coincide con una cadena delimitada por cualquiera de los caracteres en el &amp;uacute;nico argumento. Por ejemplo:</target>
        </trans-unit>
        <trans-unit id="617ccfb027c1e5d2773071a87cbcedc95dc112aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;get_dup&lt;/code&gt; method assists in reading duplicate values from BTREE databases. The method can take the following forms:</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;get_dup&lt;/code&gt; ayuda a leer valores duplicados de las bases de datos BTREE. El m&amp;eacute;todo puede adoptar las siguientes formas:</target>
        </trans-unit>
        <trans-unit id="38757d13de90c9736c762577e50e5a7475bfa2f5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getname&lt;/code&gt; function returns the file specification associated with a Perl I/O handle. If an error occurs, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7ea986ecd3305b94f4546f1c6e3ce692488dd0fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;getopt()&lt;/code&gt; es similar, pero su argumento es una cadena que contiene todos los conmutadores que toman un argumento. Si no se proporciona un argumento para un cambio, digamos, &lt;code&gt;&lt;a href=&quot;../functions/y&quot;&gt;y&lt;/a&gt;&lt;/code&gt; , el &lt;code&gt;$opt_y&lt;/code&gt; correspondiente se establecer&amp;aacute; en un valor indefinido. Los conmutadores no especificados se aceptan silenciosamente. No se recomienda el uso de &lt;code&gt;getopt()&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="d8dad5d808a96d01abfb75223a15354d771a92d8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopt()&lt;/code&gt; function is similar, but its argument is a string containing all switches that take an argument. If no argument is provided for a switch, say, &lt;code&gt;y&lt;/code&gt;, the corresponding &lt;code&gt;$opt_y&lt;/code&gt; will be set to an undefined value. Unspecified switches are silently accepted. Use of &lt;code&gt;getopt()&lt;/code&gt; is not recommended.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c037451f79364fbd043155e0ffbbe91d2a70fbad" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt; .</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;getopts()&lt;/code&gt; procesa conmutadores de un solo car&amp;aacute;cter con agrupamiento de conmutadores. Pase un argumento que es una cadena que contiene todos los conmutadores que se reconocer&amp;aacute;n. Para cada conmutador encontrado, si se espera y se proporciona un argumento, &lt;code&gt;getopts()&lt;/code&gt; establece &lt;code&gt;$opt_x&lt;/code&gt; (donde &lt;code&gt;x&lt;/code&gt; es el nombre del conmutador) al valor del argumento. Si se espera un argumento pero no se proporciona ninguno, &lt;code&gt;$opt_x&lt;/code&gt; se establece en un valor indefinido. Si un conmutador no acepta un argumento, &lt;code&gt;$opt_x&lt;/code&gt; se establece en &lt;code&gt;1&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="91aef3725c2efdb205ada4f0830cb2c2f0326f3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function processes single-character switches with switch clustering. Pass one argument which is a string containing all switches to be recognized. For each switch found, if an argument is expected and provided, &lt;code&gt;getopts()&lt;/code&gt; sets &lt;code&gt;$opt_x&lt;/code&gt; (where &lt;code&gt;x&lt;/code&gt; is the switch name) to the value of the argument. If an argument is expected but none is provided, &lt;code&gt;$opt_x&lt;/code&gt; is set to an undefined value. If a switch does not take an argument, &lt;code&gt;$opt_x&lt;/code&gt; is set to &lt;code&gt;1&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fe182c59e721bf2edc44a9253eded06fe11c1a8a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;getopts()&lt;/code&gt; function returns true unless an invalid option was found.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;getopts()&lt;/code&gt; devuelve verdadero a menos que se encuentre una opci&amp;oacute;n no v&amp;aacute;lida.</target>
        </trans-unit>
        <trans-unit id="a7db78679ac7caa25a3af4ac6eb9b08a0ab0fc92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;gmtime&lt;/code&gt; operator will function properly if you have a working CRTL &lt;code&gt;gmtime()&lt;/code&gt; routine, or if the logical name SYS$TIMEZONE_DIFFERENTIAL is defined as the number of seconds which must be added to UTC to yield local time. (This logical name is defined automatically if you are running a version of VMS with built-in UTC support.) If neither of these cases is true, a warning message is printed, and &lt;code&gt;undef&lt;/code&gt; is returned.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ddf55542a974db500db0203f6bd0350de0ee8029" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto &amp;amp;NAME&lt;/code&gt; form is quite different from the other forms of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;. In fact, it isn't a goto in the normal sense at all, and doesn't have the stigma associated with other gotos. Instead, it exits the current subroutine (losing any changes set by &lt;a href=&quot;#local-EXPR&quot;&gt;&lt;code&gt;local&lt;/code&gt;&lt;/a&gt;) and immediately calls in its place the named subroutine using the current value of &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt;. This is used by &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;a href=&quot;perlvar#%40_&quot;&gt;&lt;code&gt;@_&lt;/code&gt;&lt;/a&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt;, not even &lt;a href=&quot;#caller-EXPR&quot;&gt;&lt;code&gt;caller&lt;/code&gt;&lt;/a&gt; will be able to tell that this routine was called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b87b19f1c73c949cde9da8170870a148c4211b7d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto EXPR&lt;/code&gt; form expects to evaluate &lt;code&gt;EXPR&lt;/code&gt; to a code reference or a label name. If it evaluates to a code reference, it will be handled like &lt;code&gt;goto &amp;amp;NAME&lt;/code&gt;, below. This is especially useful for implementing tail recursion via &lt;code&gt;goto __SUB__&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5712e372b5c3349bd4c5753ceb08d65a1f34e0e2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto LABEL&lt;/code&gt; form finds the statement labeled with LABEL and resumes execution there. It can't be used to get out of a block or subroutine given to &lt;a href=&quot;#sort-SUBNAME-LIST&quot;&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/a&gt;. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;a href=&quot;#last-LABEL&quot;&gt;&lt;code&gt;last&lt;/code&gt;&lt;/a&gt; or &lt;a href=&quot;#die-LIST&quot;&gt;&lt;code&gt;die&lt;/code&gt;&lt;/a&gt;. The author of Perl has never felt the need to use this form of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; (in Perl, that is; C is another matter). (The difference is that C does not offer named loops combined with loop control. Perl does, and this replaces most structured uses of &lt;a href=&quot;#goto-LABEL&quot;&gt;&lt;code&gt;goto&lt;/code&gt;&lt;/a&gt; in other languages.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="60a01fb6d408173d3e22945b3c56ff55146388d1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-&amp;amp;NAME form is highly magical, and substitutes a call to the named subroutine for the currently running subroutine. This is used by &lt;code&gt;AUTOLOAD()&lt;/code&gt; subroutines that wish to load another subroutine and then pretend that the other subroutine had been called in the first place (except that any modifications to &lt;code&gt;@_&lt;/code&gt; in the current subroutine are propagated to the other subroutine.) After the &lt;code&gt;goto&lt;/code&gt;, not even &lt;code&gt;caller()&lt;/code&gt; will be able to tell that this routine was called first.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="445db83ca6a37cdb271d1da44d8e4a2e039ee781" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-EXPR form expects a label name, whose scope will be resolved dynamically. This allows for computed &lt;code&gt;goto&lt;/code&gt;s per FORTRAN, but isn't necessarily recommended if you're optimizing for maintainability:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3604bc760ddc7f229653ccec982fbb33374f75b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;goto&lt;/code&gt;-LABEL form finds the statement labeled with LABEL and resumes execution there. It may not be used to go into any construct that requires initialization, such as a subroutine or a &lt;code&gt;foreach&lt;/code&gt; loop. It also can't be used to go into a construct that is optimized away. It can be used to go almost anywhere else within the dynamic scope, including out of subroutines, but it's usually better to use some other construct such as &lt;code&gt;last&lt;/code&gt; or &lt;code&gt;die&lt;/code&gt;. The author of Perl has never felt the need to use this form of &lt;code&gt;goto&lt;/code&gt; (in Perl, that is--C is another matter).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c2fadcd77a199834658c813ed1ecacfc31717619" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="688985f64d8825090cd98452194bcbd67a98423b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grammar_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">La &lt;code&gt;grammar_class&lt;/code&gt; se puede personalizar, como se describe en &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="777e123af8a17b58624e4e03631072776b99c240" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;grep&lt;/code&gt; in scalar context returns the count. If you want the list of matching items, just use it in list context instead:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="361db5e35a8a030899f4185a6ca897ccf88b2984" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) long.</source>
          <target state="translated">Los formatos &lt;code&gt;h&lt;/code&gt; y &lt;code&gt;H&lt;/code&gt; contienen una cadena de muchos nybbles (grupos de 4 bits, representables como d&amp;iacute;gitos hexadecimales, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt; &lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt; ) de largo.</target>
        </trans-unit>
        <trans-unit id="282363bb17be47a4571b65bee183b55491c1858f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;h&lt;/code&gt; and &lt;code&gt;H&lt;/code&gt; formats pack a string that many nybbles (4-bit groups, representable as hexadecimal digits, &lt;code&gt;&quot;0&quot;..&quot;9&quot;&lt;/code&gt;&lt;code&gt;&quot;a&quot;..&quot;f&quot;&lt;/code&gt;) long.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="52b0ba82d51f8c56aed17fcdac89e94cd7a38305" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt; .</source>
          <target state="translated">La subrutina &lt;code&gt;has()&lt;/code&gt; declara un atributo y &lt;code&gt;Moose&lt;/code&gt; crea autom&amp;aacute;ticamente descriptores de acceso para estos atributos. Tambi&amp;eacute;n se encarga de crear un &lt;code&gt;new()&lt;/code&gt; m&amp;eacute;todo () para usted. Este constructor conoce los atributos que declar&amp;oacute;, por lo que puede establecerlos al crear un nuevo &lt;code&gt;File&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="0b9970d46e3cdb5c6bbb0a61789e35dad5828ae7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;has()&lt;/code&gt; subroutine declares an attribute, and &lt;code&gt;Moose&lt;/code&gt; automatically creates accessors for these attributes. It also takes care of creating a &lt;code&gt;new()&lt;/code&gt; method for you. This constructor knows about the attributes you declared, so you can set them when creating a new &lt;code&gt;File&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76a592c009139dada36763e63a154e69a7ae21aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;hide_buffered()&lt;/code&gt; method must return a boolean. This is used to tell buffered subtests whether or not to send it events as they are being buffered. See &lt;a href=&quot;Test2::API#run_subtest%28...%29&quot;&gt;&quot;run_subtest(...)&quot; in Test2::API&lt;/a&gt; for more information.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="cfb4b1270d7a6c1577ddc7dc43612517ef56c1fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;host&lt;/code&gt; argument implicitly specifies the family if the family argument is not given.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5a9683174ca55dfc5709630b38ddbf4013af69ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt; ; they are tolerated for completeness' sake.</source>
          <target state="translated">&amp;iexcl;El &lt;code&gt;i!&lt;/code&gt; y &lt;code&gt;I!&lt;/code&gt; los c&amp;oacute;digos no son diferentes de &lt;code&gt;i&lt;/code&gt; y &lt;code&gt;I&lt;/code&gt; ; se toleran en aras de la integridad.</target>
        </trans-unit>
        <trans-unit id="788c747d1d57898e8c459685e81e82083e2bc64a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;i!&lt;/code&gt; and &lt;code&gt;I!&lt;/code&gt; codes aren't different from &lt;code&gt;i&lt;/code&gt; and &lt;code&gt;I&lt;/code&gt;; they are tolerated for completeness' sake.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="441288d51b032bd9af407d3a9d7124153bae7480" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is incorporated in</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;id()&lt;/code&gt; est&amp;aacute; incorporada en</target>
        </trans-unit>
        <trans-unit id="5b77bbf33fef07ab4b901464b3d1fbf57256a9cb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;id()&lt;/code&gt; se proporciona adem&amp;aacute;s del &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt; . Adem&amp;aacute;s de su nombre corto, puede ser un poco m&amp;aacute;s r&amp;aacute;pido en algunas circunstancias (y un poco m&amp;aacute;s lento en otras). Benchmark si es importante. El funcionamiento de &lt;code&gt;id()&lt;/code&gt; tambi&amp;eacute;n permite el uso del nombre de la clase como</target>
        </trans-unit>
        <trans-unit id="b2d4a03cd0e504b918c77f964222c03e6f8204c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;id()&lt;/code&gt; function is provided in addition to the existing &lt;code&gt;Scalar::Util::refaddr()&lt;/code&gt;. Besides its short name it can be a little faster under some circumstances (and a bit slower under others). Benchmark if it matters. The working of &lt;code&gt;id()&lt;/code&gt; also allows the use of the class name as a</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1766324c2122418c9321a7a3323084287c423699" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load another module. The construct:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1d508e8165fd2906f6e1a4da8eddef354ad1b2c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; module is used to conditionally load or unload another module. The construct</source>
          <target state="translated">El m&amp;oacute;dulo &lt;code&gt;if&lt;/code&gt; se utiliza para cargar o descargar condicionalmente otro m&amp;oacute;dulo. El constructo</target>
        </trans-unit>
        <trans-unit id="4b048e8a441fb17f85efa08c37a67df6bc5d9c00" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt; , the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt; , &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="translated">La declaraci&amp;oacute;n &lt;code&gt;if&lt;/code&gt; es sencilla. Debido a que los BLOQUES siempre est&amp;aacute;n delimitados por corchetes, nunca hay ambig&amp;uuml;edad acerca de qu&amp;eacute; &lt;code&gt;if&lt;/code&gt; un &lt;code&gt;else&lt;/code&gt; va con. Si usa a &lt;code&gt;unless&lt;/code&gt; en lugar de &lt;code&gt;if&lt;/code&gt; , el sentido de la prueba se invierte. Como &lt;code&gt;if&lt;/code&gt; , a &lt;code&gt;unless&lt;/code&gt; pueda ir seguido de &lt;code&gt;else&lt;/code&gt; . &lt;code&gt;unless&lt;/code&gt; que incluso pueda ir seguida de una o m&amp;aacute;s declaraciones &lt;code&gt;elsif&lt;/code&gt; , aunque es posible que desee pensarlo dos veces antes de usar esa construcci&amp;oacute;n de lenguaje en particular, ya que todos los que lean su c&amp;oacute;digo tendr&amp;aacute;n que pensar al menos dos veces antes de poder entender lo que est&amp;aacute; sucediendo.</target>
        </trans-unit>
        <trans-unit id="a3f74430f10fb167c78fb2a5e2886ee696f50106" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;if&lt;/code&gt; statement is straightforward. Because BLOCKs are always bounded by curly brackets, there is never any ambiguity about which &lt;code&gt;if&lt;/code&gt; an &lt;code&gt;else&lt;/code&gt; goes with. If you use &lt;code&gt;unless&lt;/code&gt; in place of &lt;code&gt;if&lt;/code&gt;, the sense of the test is reversed. Like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;unless&lt;/code&gt; can be followed by &lt;code&gt;else&lt;/code&gt;. &lt;code&gt;unless&lt;/code&gt; can even be followed by one or more &lt;code&gt;elsif&lt;/code&gt; statements, though you may want to think twice before using that particular language construct, as everyone reading your code will have to think at least twice before they can understand what's going on.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e9f3b671cb1eeb07ae7f1604035f9acb4eeee7c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt; . If the server desires a copy of that article, and &lt;code&gt;MESSAGE&lt;/code&gt; has been given the it will be sent.</source>
          <target state="translated">El comando &lt;code&gt;ihave&lt;/code&gt; informa al servidor que el cliente tiene un art&amp;iacute;culo cuya identificaci&amp;oacute;n es &lt;code&gt;MSGID&lt;/code&gt; . Si el servidor desea una copia de ese art&amp;iacute;culo, y se le ha dado un &lt;code&gt;MESSAGE&lt;/code&gt; se le enviar&amp;aacute;.</target>
        </trans-unit>
        <trans-unit id="31b23815f5a49e656771e950c98aed03ec7f0fc3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ihave&lt;/code&gt; command informs the server that the client has an article whose id is &lt;code&gt;MSGID&lt;/code&gt;. If the server desires a copy of that article and &lt;code&gt;MESSAGE&lt;/code&gt; has been given then it will be sent.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9aeda9f25872f01fa1451e80b809c2f965a34d18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;import&lt;/code&gt; method is used to create an instance of the filter. It is called indirectly by Perl when it encounters the &lt;code&gt;use MyFilter&lt;/code&gt; line in a source file (See &lt;a href=&quot;perlfunc#import&quot;&gt;&quot;import&quot; in perlfunc&lt;/a&gt; for more details on &lt;code&gt;import&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2a41824798980582f7eebe5a9af3082e01f3a340" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;intercept { ... }&lt;/code&gt; tool lets you temporarily intercept all events generated by the test system:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="be9e48c7280cc08e3dbfd771c25dd8dc760ce4df" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in main program scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default set via &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;&lt;code&gt;${^OPEN}&lt;/code&gt;&lt;/a&gt;, with explicit layers in open() and with binmode() one can manipulate streams as usual. This has no effect on code run in modules.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="31aa9addcda21b8978ff9bf041daba569f826e41" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;io&lt;/code&gt; options mean that any subsequent open() (or similar I/O operations) in the current file scope will have the &lt;code&gt;:utf8&lt;/code&gt; PerlIO layer implicitly applied to them, in other words, UTF-8 is expected from any input stream, and UTF-8 is produced to any output stream. This is just the default, with explicit layers in open() and with binmode() one can manipulate streams as usual.</source>
          <target state="translated">Las opciones &lt;code&gt;io&lt;/code&gt; significan que cualquier open () (o operaciones de E / S similares) subsiguientes en el alcance del archivo actual tendr&amp;aacute; la capa &lt;code&gt;:utf8&lt;/code&gt; PerlIO aplicada impl&amp;iacute;citamente, en otras palabras, se espera UTF-8 de cualquier flujo de entrada, y UTF-8 se produce en cualquier flujo de salida. Este es solo el predeterminado, con capas expl&amp;iacute;citas en open () y con binmode () uno puede manipular flujos como de costumbre.</target>
        </trans-unit>
        <trans-unit id="ea8cc24a093a2a51529b8db29000183dfdfc585d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;isa&lt;/code&gt; method returns</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;isa&lt;/code&gt; regresa</target>
        </trans-unit>
        <trans-unit id="d80df4437426b10544ca2a3550913f7483c70900" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keep_alive&lt;/code&gt; parameter enables a persistent connection, but only to a single destination scheme, host and port. Also, if any connection-relevant attributes are modified, or if the process ID or thread ID change, the persistent connection will be dropped. If you want persistent connections across multiple destinations, use multiple HTTP::Tiny objects.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82e537c44915ef2c8c7d2ba733eb7ee50f9fc357" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;keys()&lt;/code&gt; function also resets the iterator, which means that you may see strange results if you use this between uses of other hash operators such as &lt;code&gt;each()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="59f328cf1649c302313e1693d9d3ed492ede670c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill&lt;/code&gt; function can be used to test this functionality from within a program.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b31ef1c90508af7c0b307ce12a58574a2fffa8e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;kill&lt;/code&gt; function in the parent's &lt;code&gt;if&lt;/code&gt; block is there to send a signal to our child process, currently running in the &lt;code&gt;else&lt;/code&gt; block, as soon as the remote server has closed its end of the connection.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="40b75cea7c9c256a2c7f367ec1f2a28305318646" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;klen&lt;/code&gt; parameter is the length of the key being passed in (Note that you cannot pass 0 in as a value of &lt;code&gt;klen&lt;/code&gt; to tell Perl to measure the length of the key). The &lt;code&gt;val&lt;/code&gt; argument contains the SV pointer to the scalar being stored, and &lt;code&gt;hash&lt;/code&gt; is the precomputed hash value (zero if you want &lt;code&gt;hv_store&lt;/code&gt; to calculate it for you). The &lt;code&gt;lval&lt;/code&gt; parameter indicates whether this fetch is actually a part of a store operation, in which case a new undefined value will be added to the HV with the supplied key and &lt;code&gt;hv_fetch&lt;/code&gt; will return as if the value had already existed.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;klen&lt;/code&gt; es la longitud de la clave que se pasa (tenga en cuenta que no puede pasar 0 como valor de &lt;code&gt;klen&lt;/code&gt; para decirle a Perl que mida la longitud de la clave). El argumento &lt;code&gt;val&lt;/code&gt; contiene el puntero SV al escalar que se est&amp;aacute; almacenando, y &lt;code&gt;hash&lt;/code&gt; es el valor hash &lt;code&gt;hv_store&lt;/code&gt; (cero si desea que hv_store lo calcule por usted). El par&amp;aacute;metro &lt;code&gt;lval&lt;/code&gt; indica si esta recuperaci&amp;oacute;n es realmente parte de una operaci&amp;oacute;n de tienda, en cuyo caso se agregar&amp;aacute; un nuevo valor indefinido al HV con la clave proporcionada y &lt;code&gt;hv_fetch&lt;/code&gt; regresar&amp;aacute; como si el valor ya existiera.</target>
        </trans-unit>
        <trans-unit id="ce7404a130e41b36d0d6586ea9856d3d751bce9d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;last&lt;/code&gt; command immediately exits the loop in question. The &lt;code&gt;continue&lt;/code&gt; block, if any, is not executed:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="55c1db6e5ea234d6a6e740b669d07b2f2f87de01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;length(NAME)&lt;/code&gt; Keyword</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1b3be6dbaf0292e629ff79d5077e6e86e950020" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="translated">Los &lt;code&gt;line numbers&lt;/code&gt; son una lista separada por comas de n&amp;uacute;meros de l&amp;iacute;nea (algunos precedidos por letras de c&amp;oacute;digo) donde ese objeto se usa de alguna manera. Los usos simples no est&amp;aacute;n precedidos por una letra de c&amp;oacute;digo. Las introducciones (como cuando un l&amp;eacute;xico se define por primera vez con &lt;code&gt;&lt;a href=&quot;../functions/my&quot;&gt;my&lt;/a&gt;&lt;/code&gt; ) se indican con la letra &quot;i&quot;. Las llamadas a subrutinas y m&amp;eacute;todos se indican con el car&amp;aacute;cter &quot;&amp;amp;&quot;. Las definiciones de subrutinas se indican con &quot;s&quot; y las definiciones de formato con &quot;f&quot;.</target>
        </trans-unit>
        <trans-unit id="236b6ae4af5c95ab170ad24f4ae0aa38234165ed" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;line numbers&lt;/code&gt; are a comma separated list of line numbers (some preceded by code letters) where that object is used in some way. Simple uses aren't preceded by a code letter. Introductions (such as where a lexical is first defined with &lt;code&gt;my&lt;/code&gt;) are indicated with the letter &quot;i&quot;. Subroutine and method calls are indicated by the character &quot;&amp;amp;&quot;. Subroutine definitions are indicated by &quot;s&quot; and format definitions by &quot;f&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1df1ad78d22b500a60841a63c43cbb5af0dd2c94" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock()&lt;/code&gt; function takes a shared variable and puts a lock on it. No other thread may lock the variable until the variable is unlocked by the thread holding the lock. Unlocking happens automatically when the locking thread exits the block that contains the call to the &lt;code&gt;lock()&lt;/code&gt; function. Using &lt;code&gt;lock()&lt;/code&gt; is straightforward: This example has several threads doing some calculations in parallel, and occasionally updating a running total:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ed26c2274a611c42add606638c2955102446922f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt; , except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt; , but also gets a shared lock on the file before reading.</source>
          <target state="translated">Las &lt;code&gt;lock_store&lt;/code&gt; y &lt;code&gt;lock_nstore&lt;/code&gt; son equivalentes a &lt;code&gt;store&lt;/code&gt; y &lt;code&gt;nstore&lt;/code&gt; , excepto que obtienen un bloqueo exclusivo en el archivo antes de escribir. Del mismo modo, &lt;code&gt;lock_retrieve&lt;/code&gt; hace lo mismo que &lt;code&gt;retrieve&lt;/code&gt; , pero tambi&amp;eacute;n obtiene un bloqueo compartido en el archivo antes de leerlo.</target>
        </trans-unit>
        <trans-unit id="c09918116ac6368cc484da6987f7bb75bbaec828" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;lock_store&lt;/code&gt; and &lt;code&gt;lock_nstore&lt;/code&gt; routine are equivalent to &lt;code&gt;store&lt;/code&gt; and &lt;code&gt;nstore&lt;/code&gt;, except that they get an exclusive lock on the file before writing. Likewise, &lt;code&gt;lock_retrieve&lt;/code&gt; does the same as &lt;code&gt;retrieve&lt;/code&gt;, but also gets a shared lock on the file before reading.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="931b71dd87fea82969167ed5b3226571750cd592" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mail&lt;/code&gt; method can some additional ESMTP OPTIONS which is passed in hash like fashion, using key and value pairs. Possible options are:</source>
          <target state="translated">El m&amp;eacute;todo de &lt;code&gt;mail&lt;/code&gt; puede incluir algunas OPCIONES ESMTP adicionales que se pasan en forma de hash, utilizando pares de clave y valor. Las posibles opciones son:</target>
        </trans-unit>
        <trans-unit id="1672385883542a7bfdb246cc1c07640a71a68feb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make&lt;/code&gt; and &lt;code&gt;emake&lt;/code&gt; accept both real and complex arguments. When they cannot recognize the arguments they will die with error messages like the following</source>
          <target state="translated">El &lt;code&gt;make&lt;/code&gt; y &lt;code&gt;emake&lt;/code&gt; aceptan ambos argumentos reales y complejos. Cuando no puedan reconocer los argumentos, morir&amp;aacute;n con mensajes de error como el siguiente</target>
        </trans-unit>
        <trans-unit id="c85fa07be63e0e0f2104a7ea90d6fd3b867aea55" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exist before, much like the Unix command &lt;code&gt;mkdir -p&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="36df2e300d21e511804bebffd14eb9e7ae60ac30" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;make_path&lt;/code&gt; function creates the given directories if they don't exists before, much like the Unix command &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;make_path&lt;/code&gt; crea los directorios dados si no existen antes, al igual que el comando de Unix &lt;code&gt;&lt;a href=&quot;../functions/mkdir&quot;&gt;mkdir&lt;/a&gt; -p&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="072d415ade3aa9a1737c770e2e53b08afe60d304" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="translated">Los m&amp;eacute;todos &lt;code&gt;match&lt;/code&gt; , &lt;code&gt;gmatch&lt;/code&gt; , &lt;code&gt;subst&lt;/code&gt; , &lt;code&gt;gsubst&lt;/code&gt; funcionan como &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/m&quot;&gt;m//g&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;../functions/s&quot;&gt;s///g&lt;/a&gt;&lt;/code&gt; , respectivamente, pero no conocen ning&amp;uacute;n patr&amp;oacute;n, sino solo una subcadena literal.</target>
        </trans-unit>
        <trans-unit id="3e1a1e48900b4f1b87b0c10e8e5f854b940363da" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;match&lt;/code&gt;, &lt;code&gt;gmatch&lt;/code&gt;, &lt;code&gt;subst&lt;/code&gt;, &lt;code&gt;gsubst&lt;/code&gt; methods work like &lt;code&gt;m//&lt;/code&gt;, &lt;code&gt;m//g&lt;/code&gt;, &lt;code&gt;s///&lt;/code&gt;, &lt;code&gt;s///g&lt;/code&gt;, respectively, but they are not aware of any pattern, but only a literal substring.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ece173d4e6c78d6e5935815075ac81cc7c62a227" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt; .</source>
          <target state="translated">El valor de la &lt;code&gt;memory&lt;/code&gt; no es un l&amp;iacute;mite absoluto o exacto de la memoria utilizada. &lt;code&gt;Tie::File&lt;/code&gt; objetos Tie :: File contienen algunas estructuras adem&amp;aacute;s del cach&amp;eacute; de lectura y el b&amp;uacute;fer de escritura diferida, cuyos tama&amp;ntilde;os no se cargan a la &lt;code&gt;memory&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="e86eeea566744434422bb67f1ca33c0f448174c0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;memory&lt;/code&gt; value is not an absolute or exact limit on the memory used. &lt;code&gt;Tie::File&lt;/code&gt; objects contains some structures besides the read cache and the deferred write buffer, whose sizes are not charged against &lt;code&gt;memory&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19d121e9a361d9d72576c01fa16affeece8189c9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt; , which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="translated">El campo &lt;code&gt;mg_virtual&lt;/code&gt; en la estructura &lt;code&gt;MAGIC&lt;/code&gt; es un puntero a un &lt;code&gt;MGVTBL&lt;/code&gt; , que es una estructura de punteros de funci&amp;oacute;n y significa &quot;Magic Virtual Table&quot; para manejar las diversas operaciones que podr&amp;iacute;an aplicarse a esa variable.</target>
        </trans-unit>
        <trans-unit id="7a8acc1e771fdb8b24c87ae131045c8c79a6a526" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mg_virtual&lt;/code&gt; field in the &lt;code&gt;MAGIC&lt;/code&gt; structure is a pointer to an &lt;code&gt;MGVTBL&lt;/code&gt;, which is a structure of function pointers and stands for &quot;Magic Virtual Table&quot; to handle the various operations that might be applied to that variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2676c3bd8442c2414026f369d263715f307f12fa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;mkpath()&lt;/code&gt; function provide the legacy interface of &lt;code&gt;make_path()&lt;/code&gt; with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to &lt;code&gt;make_path()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a5023c90eb5f90ef422233e2dd5d44f7824eab24" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;module&lt;/code&gt; related one will be matched against</source>
          <target state="translated">El &lt;code&gt;module&lt;/code&gt; relacionado se comparar&amp;aacute; con</target>
        </trans-unit>
        <trans-unit id="47efd6577f009e8c4308e174f5b14a11ddfaec14" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;move&lt;/code&gt; function also takes two parameters: the current name and the intended name of the file to be moved. If the destination already exists and is a directory, and the source is not a directory, then the source file will be renamed into the directory specified by the destination.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;move&lt;/code&gt; tambi&amp;eacute;n toma dos par&amp;aacute;metros: el nombre actual y el nombre previsto del archivo que se va a mover. Si el destino ya existe y es un directorio, y el origen no es un directorio, entonces el archivo de origen cambiar&amp;aacute; de nombre al directorio especificado por el destino.</target>
        </trans-unit>
        <trans-unit id="f9ad05dfff8b94ab9a9d935cf92a180ec9ff2c2a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; is actually not required; you could just use:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="38fd69505c43bd3a6104acf78cba741dff69018d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; is simply a modifier on something you might assign to. So when you do assign to variables in its argument list, &lt;code&gt;my&lt;/code&gt; doesn't change whether those variables are viewed as a scalar or an array. So</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="19231a9a0cfdbf1775816cb2ae3551e57856cb0c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;my&lt;/code&gt; operator declares the listed variables to be lexically confined to the enclosing block, conditional (&lt;code&gt;if&lt;/code&gt;/&lt;code&gt;unless&lt;/code&gt;/&lt;code&gt;elsif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;), loop (&lt;code&gt;for&lt;/code&gt;/&lt;code&gt;foreach&lt;/code&gt;/&lt;code&gt;while&lt;/code&gt;/&lt;code&gt;until&lt;/code&gt;/&lt;code&gt;continue&lt;/code&gt;), subroutine, &lt;code&gt;eval&lt;/code&gt;, or &lt;code&gt;do&lt;/code&gt;/&lt;code&gt;require&lt;/code&gt;/&lt;code&gt;use&lt;/code&gt;'d file. If more than one value is listed, the list must be placed in parentheses. All listed elements must be legal lvalues. Only alphanumeric identifiers may be lexically scoped--magical built-ins like &lt;code&gt;$/&lt;/code&gt; must currently be &lt;code&gt;local&lt;/code&gt;ized with &lt;code&gt;local&lt;/code&gt; instead.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="82300ffe8ea8c4a83935f63ac88aba05d079a68e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;name&lt;/code&gt; and &lt;code&gt;namlen&lt;/code&gt; arguments are used to associate a string with the magic, typically the name of a variable. &lt;code&gt;namlen&lt;/code&gt; is stored in the &lt;code&gt;mg_len&lt;/code&gt; field and if &lt;code&gt;name&lt;/code&gt; is non-null then either a &lt;code&gt;savepvn&lt;/code&gt; copy of &lt;code&gt;name&lt;/code&gt; or &lt;code&gt;name&lt;/code&gt; itself is stored in the &lt;code&gt;mg_ptr&lt;/code&gt; field, depending on whether &lt;code&gt;namlen&lt;/code&gt; is greater than zero or equal to zero respectively. As a special case, if &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; then &lt;code&gt;name&lt;/code&gt; is assumed to contain an &lt;code&gt;SV*&lt;/code&gt; and is stored as-is with its REFCNT incremented.</source>
          <target state="translated">Los argumentos &lt;code&gt;name&lt;/code&gt; y &lt;code&gt;namlen&lt;/code&gt; se utilizan para asociar una cadena con la magia, normalmente el nombre de una variable. &lt;code&gt;namlen&lt;/code&gt; se almacena en el campo &lt;code&gt;mg_len&lt;/code&gt; y si el &lt;code&gt;name&lt;/code&gt; no es nulo, entonces se &lt;code&gt;savepvn&lt;/code&gt; una copia savepvn del &lt;code&gt;name&lt;/code&gt; o el &lt;code&gt;name&lt;/code&gt; mismo en el campo &lt;code&gt;mg_ptr&lt;/code&gt; , dependiendo de si &lt;code&gt;namlen&lt;/code&gt; es mayor que cero o igual a cero respectivamente. Como caso especial, si &lt;code&gt;(name &amp;amp;&amp;amp; namlen == HEf_SVKEY)&lt;/code&gt; , se supone que el &lt;code&gt;name&lt;/code&gt; contiene un &lt;code&gt;SV*&lt;/code&gt; y se almacena tal cual con su REFCNT incrementado.</target>
        </trans-unit>
        <trans-unit id="30007f38d6317a12ba00ec6e0a7e1a8a5a903fc2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="translated">Los &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; y &lt;code&gt;cplxe&lt;/code&gt; tambi&amp;eacute;n entender&amp;aacute;n un solo argumento (cadena) de las formas</target>
        </trans-unit>
        <trans-unit id="ed69370147fad222f299ba19e375b2bf7b98be5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; , and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="translated">Los &lt;code&gt;new&lt;/code&gt; , &lt;code&gt;make&lt;/code&gt; , &lt;code&gt;emake&lt;/code&gt; , &lt;code&gt;cplx&lt;/code&gt; y &lt;code&gt;cplxe&lt;/code&gt; tambi&amp;eacute;n entender&amp;aacute;n el caso de no argumentos: esto significa cero o (0, 0).</target>
        </trans-unit>
        <trans-unit id="6c65b03e7c38b210fdc728780536955dda01e185" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99af811bc283e732950a12fee28684ae132d20bc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt; method returns a collator object. If new() is called with no parameters, the collator should do the default collation.</source>
          <target state="translated">El &lt;code&gt;new&lt;/code&gt; m&amp;eacute;todo devuelve un objeto clasificador. Si se llama a new () sin par&amp;aacute;metros, el intercalador debe realizar la intercalaci&amp;oacute;n predeterminada.</target>
        </trans-unit>
        <trans-unit id="ae0f663693f54f75cfb0a197fa36ce7749539dce" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt; will also understand a single (string) argument of the forms</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5852a1533162d9c64ba81a3a508d931f75c8fc6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;make&lt;/code&gt;, &lt;code&gt;emake&lt;/code&gt;, &lt;code&gt;cplx&lt;/code&gt;, and &lt;code&gt;cplxe&lt;/code&gt; will also understand the case of no arguments: this means plain zero or (0, 0).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="66998427833c37a6112ac1501f01bdbb2d3aed3e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_root&lt;/code&gt; method is called when &lt;code&gt;Test2::API::Stack&lt;/code&gt; Initializes the root hub for the first time. Most formatters will simply have this call &lt;code&gt;$class-&amp;gt;new&lt;/code&gt;, which is the default behavior. Some formatters however may want to take extra action during construction of the root formatter, this is where they can do that.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4c9d718f2247f950a12fdfc4b79710e6bdd5032a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;new_root&lt;/code&gt; method is used when constructing a root formatter. The default is to just delegate to the regular &lt;code&gt;new()&lt;/code&gt; method, most formatters can ignore this.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="aeb14c874127fdd24641fa3165f1f47f1c0c5962" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt; command starts the next iteration of the loop:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9b10b638a2af4c10544e1d329f2b109151bd6354" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;exit&lt;/code&gt;, and &lt;code&gt;continue&lt;/code&gt; keywords work differently.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ebe7378b188460d4f95907a0bf8fffd8170aa799" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nntpstat&lt;/code&gt; command is similar to the &lt;code&gt;article&lt;/code&gt; command except that no text is returned. When selecting by message number within a group, the &lt;code&gt;nntpstat&lt;/code&gt; command serves to set the &quot;current article pointer&quot; without sending text.</source>
          <target state="translated">El comando &lt;code&gt;nntpstat&lt;/code&gt; es similar al comando &lt;code&gt;article&lt;/code&gt; , excepto que no se devuelve texto. Al seleccionar por n&amp;uacute;mero de mensaje dentro de un grupo, el comando &lt;code&gt;nntpstat&lt;/code&gt; sirve para establecer el &quot;puntero del art&amp;iacute;culo actual&quot; sin enviar texto.</target>
        </trans-unit>
        <trans-unit id="fef6e564421c89438d32761ce9e7776b6464e92d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no if&lt;/code&gt; construct assumes that a module or pragma has correctly implemented an &lt;code&gt;unimport()&lt;/code&gt; method -- but most modules and pragmata have not. That explains why the &lt;code&gt;no if&lt;/code&gt; construct is of limited applicability.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a4f0c6076233a4be0a02d3164def9d1f31e4b673" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no if&lt;/code&gt; construct is mainly used to deactivate categories of warnings when those categories would produce superfluous output under specified versions of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="696981a277bda71ab876e23444c84e4c429ec79c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no lib&lt;/code&gt; statement deletes all instances of each named directory from @INC.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acc82aa3e704adf455ebd4a8a84e684b82c4c216" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no sort&lt;/code&gt; pragma doesn't</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="44265817f41c8d93c79e5cd86bbcac999ebebf51" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;no_proxy&lt;/code&gt; environment variable is supported in the format of a comma-separated list of domain extensions proxy should not be used for.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9a9f846f976939c6373f157aacddb5340df46521" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;notest&lt;/code&gt; pragma skips the test part in the build process.</source>
          <target state="translated">El pragma &lt;code&gt;notest&lt;/code&gt; omite la parte de prueba en el proceso de compilaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="402cbf532fb5078e8455cec160e9e8dbd08504b1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;nvsize&lt;/code&gt; element is only present for file format v2.2 and higher.</source>
          <target state="translated">El elemento &lt;code&gt;nvsize&lt;/code&gt; solo est&amp;aacute; presente para el formato de archivo v2.2 y superior.</target>
        </trans-unit>
        <trans-unit id="c6ccaa6545aa4fe6352eb7229eabe18e5414aa4b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o conf&lt;/code&gt; command has various bells and whistles:</source>
          <target state="translated">El comando &lt;code&gt;o conf&lt;/code&gt; tiene varias campanas y silbidos:</target>
        </trans-unit>
        <trans-unit id="20b61e97734fd2f3d96ceb929809c05aaac0cfef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &quot;&lt;code&gt;foo&lt;/code&gt;&quot;, and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;&quot;*&quot;&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;/g&lt;/code&gt;:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e1d6fb5846e3f0194a9a7d71677ca6c483145c33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;o?&lt;/code&gt; matches at the beginning of &lt;code&gt;'foo'&lt;/code&gt; , and since the position in the string is not moved by the match, &lt;code&gt;o?&lt;/code&gt; would match again and again because of the &lt;code&gt;*&lt;/code&gt; quantifier. Another common way to create a similar cycle is with the looping modifier &lt;code&gt;//g&lt;/code&gt; :</source>
          <target state="translated">&amp;iquest;El &lt;code&gt;o?&lt;/code&gt; coincidencias al principio de &lt;code&gt;'foo'&lt;/code&gt; , y dado que la posici&amp;oacute;n en la cadena no es movida por la coincidencia, &lt;code&gt;o?&lt;/code&gt; coincidir&amp;iacute;a una y otra vez debido al cuantificador &lt;code&gt;*&lt;/code&gt; . Otra forma com&amp;uacute;n de crear un ciclo similar es con el modificador de bucle &lt;code&gt;//g&lt;/code&gt; :</target>
        </trans-unit>
        <trans-unit id="8add6c5a9ee20cf8238a46e09a0cd46fe0b061c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="translated">El argumento &lt;code&gt;obj&lt;/code&gt; se almacena en el campo &lt;code&gt;mg_obj&lt;/code&gt; de la estructura &lt;code&gt;MAGIC&lt;/code&gt; . Si no es lo mismo que el argumento &lt;code&gt;sv&lt;/code&gt; , se incrementa el recuento de referencias del objeto &lt;code&gt;obj&lt;/code&gt; . Si es el mismo, o si el argumento de &lt;code&gt;how&lt;/code&gt; es &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt; , o si es un puntero NULL, entonces &lt;code&gt;obj&lt;/code&gt; simplemente se almacena, sin que se incremente el recuento de referencias.</target>
        </trans-unit>
        <trans-unit id="dca84bbcee637e6ee5a3f3b53c079982ba47b456" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;obj&lt;/code&gt; argument is stored in the &lt;code&gt;mg_obj&lt;/code&gt; field of the &lt;code&gt;MAGIC&lt;/code&gt; structure. If it is not the same as the &lt;code&gt;sv&lt;/code&gt; argument, the reference count of the &lt;code&gt;obj&lt;/code&gt; object is incremented. If it is the same, or if the &lt;code&gt;how&lt;/code&gt; argument is &lt;code&gt;PERL_MAGIC_arylen&lt;/code&gt;, &lt;code&gt;PERL_MAGIC_regdatum&lt;/code&gt;, &lt;code&gt;PERL_MAGIC_regdata&lt;/code&gt;, or if it is a NULL pointer, then &lt;code&gt;obj&lt;/code&gt; is merely stored, without the reference count being incremented.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d80e9ad5ac5b4640a379da6ded2e4e7da8ef85d9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; , and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="translated">Los &lt;code&gt;op-entry&lt;/code&gt; , &lt;code&gt;loading-file&lt;/code&gt; , y &lt;code&gt;loaded-file&lt;/code&gt; se a&amp;ntilde;adieron sondas.</target>
        </trans-unit>
        <trans-unit id="f888b5670cd3a579164b6986631d6a361f670ffe" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;op-entry&lt;/code&gt;, &lt;code&gt;loading-file&lt;/code&gt;, and &lt;code&gt;loaded-file&lt;/code&gt; probes were added.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8a6cb40ac71f3af050d6baa8551cc82228d3a4f0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open(FOO, &quot;|-&quot;)&lt;/code&gt; and &lt;code&gt;open(BAR, &quot;-|&quot;)&lt;/code&gt; constructs are not yet implemented. This limitation can be easily worked around in new code by creating a pipe explicitly. The following example shows how to write to a forked child:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1d994756f4894d537087cc5686928a7d382dd8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;open&lt;/code&gt; pragma serves as one of the interfaces to declare default &quot;layers&quot; (previously known as &quot;disciplines&quot;) for all I/O. Any open(), readpipe() (aka qx//) and similar operators found within the lexical scope of this pragma will use the declared defaults via the &lt;a href=&quot;perlvar#%24%7B%5EOPEN%7D&quot;&gt;&lt;code&gt;${^OPEN}&lt;/code&gt;&lt;/a&gt; variable.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5eb381293ba1d62c6bb1f8b641a8f8c1b0afc8bf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;ord&lt;/code&gt; and &lt;code&gt;chr&lt;/code&gt; functions work transparently on all codepoints, not just on ASCII alone &amp;mdash; nor in fact, not even just on Unicode alone.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="df48f02864fb5733b7bb66ec5f70b228889d68c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;os_unsupported()&lt;/code&gt; function provides a way to correctly exit your &lt;code&gt;Makefile.PL&lt;/code&gt; before calling &lt;code&gt;WriteMakefile&lt;/code&gt;. It is essentially a &lt;code&gt;die&lt;/code&gt; with the message &quot;OS unsupported&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2f6e73c286e870319f1bf5046f6a37ff92d8c6ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;overloading&lt;/code&gt; pragma can be used to enable or disable overloaded operations within a lexical scope - see &lt;a href=&quot;overloading&quot;&gt;overloading&lt;/a&gt;.</source>
          <target state="translated">El pragma de &lt;code&gt;overloading&lt;/code&gt; se puede utilizar para habilitar o deshabilitar operaciones sobrecargadas dentro de un &amp;aacute;mbito l&amp;eacute;xico; consulte &lt;a href=&quot;overloading&quot;&gt;sobrecarga&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="20efdbd26d83eb3c5a0a6712c2d992c599e01133" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="22d5bf30a5d50f38a10cfc2d7578244917da917c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">Los &lt;code&gt;p&lt;/code&gt; y &lt;code&gt;P&lt;/code&gt; formatos deben usarse con cuidado. Dado que Perl no tiene forma de verificar si el valor pasado a &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponde a una ubicaci&amp;oacute;n de memoria v&amp;aacute;lida, pasar un valor de puntero que no se sabe que es v&amp;aacute;lido probablemente tenga consecuencias desastrosas.</target>
        </trans-unit>
        <trans-unit id="edad35170db1a049ca495222b3c0b5b8c415db1c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; and &lt;code&gt;P&lt;/code&gt; formats should be used with care. Since Perl has no way of checking whether the value passed to &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponds to a valid memory location, passing a pointer value that's not known to be valid is likely to have disastrous consequences.</source>
          <target state="translated">Los &lt;code&gt;p&lt;/code&gt; y &lt;code&gt;P&lt;/code&gt; formatos deben usarse con cuidado. Dado que Perl no tiene forma de verificar si el valor pasado a &lt;code&gt;&lt;a href=&quot;unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; corresponde a una ubicaci&amp;oacute;n de memoria v&amp;aacute;lida, pasar un valor de puntero que no se sabe que es v&amp;aacute;lido probablemente tenga consecuencias desastrosas.</target>
        </trans-unit>
        <trans-unit id="bc14cc8e3b01ab283787dc8c289608a88dca9ea7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;; similarly with &lt;a href=&quot;#unpack-TEMPLATE%2CEXPR&quot;&gt;&lt;code&gt;unpack&lt;/code&gt;&lt;/a&gt;, where a null pointer unpacks into &lt;a href=&quot;#undef-EXPR&quot;&gt;&lt;code&gt;undef&lt;/code&gt;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a342dbe90eb2666a6875f71f1fa1cb3e6e7241a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El formato &lt;code&gt;p&lt;/code&gt; incluye un puntero a una cadena terminada en nulo. Usted es responsable de asegurarse de que la cadena no sea un valor temporal, ya que podr&amp;iacute;a desasignarse antes de empezar a utilizar el resultado empaquetado. El formato &lt;code&gt;P&lt;/code&gt; incluye un puntero a una estructura del tama&amp;ntilde;o indicado por la longitud. Se crea un puntero nulo si el valor correspondiente para &lt;code&gt;p&lt;/code&gt; o &lt;code&gt;P&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ; de manera similar con unpack (), donde un puntero nulo se &lt;code&gt;&lt;a href=&quot;functions/undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; en undef .</target>
        </trans-unit>
        <trans-unit id="e2e0e3d979b5c34967b7ced67a74a5510cb236cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;p&lt;/code&gt; format packs a pointer to a null-terminated string. You are responsible for ensuring that the string is not a temporary value, as that could potentially get deallocated before you got around to using the packed result. The &lt;code&gt;P&lt;/code&gt; format packs a pointer to a structure of the size indicated by the length. A null pointer is created if the corresponding value for &lt;code&gt;p&lt;/code&gt; or &lt;code&gt;P&lt;/code&gt; is &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;; similarly with unpack(), where a null pointer unpacks into &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El formato &lt;code&gt;p&lt;/code&gt; incluye un puntero a una cadena terminada en nulo. Usted es responsable de asegurarse de que la cadena no sea un valor temporal, ya que podr&amp;iacute;a desasignarse antes de empezar a utilizar el resultado empaquetado. El formato &lt;code&gt;P&lt;/code&gt; incluye un puntero a una estructura del tama&amp;ntilde;o indicado por la longitud. Se crea un puntero nulo si el valor correspondiente para &lt;code&gt;p&lt;/code&gt; o &lt;code&gt;P&lt;/code&gt; es &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; ; de manera similar con unpack (), donde un puntero nulo se &lt;code&gt;&lt;a href=&quot;undef&quot;&gt;undef&lt;/a&gt;&lt;/code&gt; en undef .</target>
        </trans-unit>
        <trans-unit id="6cd57772719120a4cc44e7170b8984f064c5142a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;paren&lt;/code&gt; ser&amp;aacute; &lt;code&gt;1&lt;/code&gt; por &lt;code&gt;$1&lt;/code&gt; , &lt;code&gt;2&lt;/code&gt; por &lt;code&gt;$2&lt;/code&gt; y as&amp;iacute; sucesivamente, y tendr&amp;aacute; estos valores simb&amp;oacute;licos para las variables especiales:</target>
        </trans-unit>
        <trans-unit id="02d079f599dacaf5683c95e116afdd6471bd3c7f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;paren&lt;/code&gt; parameter will be &lt;code&gt;1&lt;/code&gt; for &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;2&lt;/code&gt; for &lt;code&gt;$2&lt;/code&gt; and so forth, and have these symbolic values for the special variables:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d81fd54d838a03f6a557d9a972a797c3d53d12e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;parse()&lt;/code&gt; method takes in anything that might be a version and returns a corresponding version object, doing any necessary conversion along the way.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="dc153b0fac70aafae4ce7fa649dc1cbd578affc8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pass*&lt;/code&gt; and &lt;code&gt;fail*&lt;/code&gt; are optimal if they meet your situation, using one of them will always be the most optimal. That said they are optimal by eliminating many features.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="49927bc872809a6862bb2b73a995c90fcc3d0b9a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pattern&lt;/code&gt; parameter is the scalar that was used as the pattern. Previous versions of Perl would pass two &lt;code&gt;char*&lt;/code&gt; indicating the start and end of the stringified pattern; the following snippet can be used to get the old parameters:</source>
          <target state="translated">El par&amp;aacute;metro de &lt;code&gt;pattern&lt;/code&gt; es el escalar que se utiliz&amp;oacute; como patr&amp;oacute;n. Las versiones anteriores de Perl pasar&amp;iacute;an dos caracteres &lt;code&gt;char*&lt;/code&gt; indicando el inicio y el final del patr&amp;oacute;n en cadena; el siguiente fragmento se puede utilizar para obtener los par&amp;aacute;metros antiguos:</target>
        </trans-unit>
        <trans-unit id="db17bf3bf687b24a2fdb5945dac7eff0732c46a0" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl&lt;/code&gt; related one will be matched against &lt;code&gt;$^X&lt;/code&gt; (but with the absolute path).</source>
          <target state="translated">El relacionado con &lt;code&gt;perl&lt;/code&gt; se comparar&amp;aacute; con &lt;code&gt;$^X&lt;/code&gt; (pero con la ruta absoluta).</target>
        </trans-unit>
        <trans-unit id="5f5ee6756d1fcb64032b91cf7b890baca1e81e1a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perl_alloc&lt;/code&gt; and &lt;code&gt;perl_clone&lt;/code&gt; API functions will automatically set the TLS slot to the interpreter they created, so that there is no need to do anything special if the interpreter is always accessed in the same thread that created it, and that thread did not create or call any other interpreters afterwards. If that is not the case, you have to set the TLS slot of the thread before calling any functions in the Perl API on that particular interpreter. This is done by calling the &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; macro in that thread as the first thing you do:</source>
          <target state="translated">Las funciones de la API &lt;code&gt;perl_alloc&lt;/code&gt; y &lt;code&gt;perl_clone&lt;/code&gt; establecer&amp;aacute;n autom&amp;aacute;ticamente la ranura TLS en el int&amp;eacute;rprete que crearon, de modo que no hay necesidad de hacer nada especial si siempre se accede al int&amp;eacute;rprete en el mismo hilo que lo cre&amp;oacute;, y ese hilo no cre&amp;oacute; ni llam&amp;oacute; cualquier otro int&amp;eacute;rprete despu&amp;eacute;s. Si ese no es el caso, debe establecer la ranura TLS del hilo antes de llamar a cualquier funci&amp;oacute;n en la API de Perl en ese int&amp;eacute;rprete en particular. Esto se hace llamando a la macro &lt;code&gt;PERL_SET_CONTEXT&lt;/code&gt; en ese hilo como lo primero que hace:</target>
        </trans-unit>
        <trans-unit id="97a02a3c258cf1103ffa6170e07625f674c4d40e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;perldoc&lt;/code&gt; command line tool is part of the standard Perl distribution. To read the perlfaq:</source>
          <target state="translated">La herramienta de l&amp;iacute;nea de comandos de &lt;code&gt;perldoc&lt;/code&gt; es parte de la distribuci&amp;oacute;n est&amp;aacute;ndar de Perl. Para leer el perlfaq:</target>
        </trans-unit>
        <trans-unit id="50ad124de63dc48f75c0f2545fa281fab8aa3db8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;phase-change&lt;/code&gt; probe was added.</source>
          <target state="translated">Se a&amp;ntilde;adi&amp;oacute; la sonda de &lt;code&gt;phase-change&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="04bb003d93ac0037aab6a2f453c58a6ac0c41912" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;plugin_list&lt;/code&gt; configuration parameter holds a list of strings of the form</source>
          <target state="translated">El par&amp;aacute;metro de configuraci&amp;oacute;n &lt;code&gt;plugin_list&lt;/code&gt; contiene una lista de cadenas de la forma</target>
        </trans-unit>
        <trans-unit id="a0b743645c5c1c48eeb64bb89437f58e73a4be52" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;port&lt;/code&gt; argument is only valid for a udp, tcp or stream ping, and will not do what you think it does. ping returns true when we get a &quot;Connection refused&quot;! The default is the echo port.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a63eacc1cc33a9d0218e84fb4e04a60cb849a989" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt; . When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="translated">El &lt;code&gt;pp_tie&lt;/code&gt; hace un &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt; , luego inicia un segundo ciclo de runops para ejecutar el cuerpo de &lt;code&gt;TIEARRAY&lt;/code&gt; . Cuando ejecuta la operaci&amp;oacute;n de entertry en la l&amp;iacute;nea 3, &lt;code&gt;CATCH_GET&lt;/code&gt; es verdadero, entonces &lt;code&gt;pp_entertry&lt;/code&gt; llama a &lt;code&gt;docatch&lt;/code&gt; que hace un &lt;code&gt;JMPENV_PUSH&lt;/code&gt; y comienza un tercer ciclo de runops, que luego ejecuta la operaci&amp;oacute;n de dado. En este punto, la pila de llamadas de C se ve as&amp;iacute;:</target>
        </trans-unit>
        <trans-unit id="158d812c1686b0935b414c31c5100461991aaa3b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;pp_tie&lt;/code&gt; does a &lt;code&gt;CATCH_SET(TRUE)&lt;/code&gt;, then starts a second runops loop to execute the body of &lt;code&gt;TIEARRAY&lt;/code&gt;. When it executes the entertry op on line 3, &lt;code&gt;CATCH_GET&lt;/code&gt; is true, so &lt;code&gt;pp_entertry&lt;/code&gt; calls &lt;code&gt;docatch&lt;/code&gt; which does a &lt;code&gt;JMPENV_PUSH&lt;/code&gt; and starts a third runops loop, which then executes the die op. At this point the C call stack looks like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bdfe7fb594151a128519964cf51c5b075b56f64a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prereqs&lt;/code&gt; key in the top-level metadata and within &lt;code&gt;optional_features&lt;/code&gt; define the relationship between a distribution and other packages. The prereq spec structure is a hierarchical data structure which divides prerequisites into</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6f6012284b93fc2045dcbcea769da43a4a9d853f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prompt()&lt;/code&gt; function provides an easy way to request user input used to write a makefile. It displays the $message as a prompt for input. If a $default is provided it will be used as a default. The function returns the $value selected by the user.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;prompt()&lt;/code&gt; proporciona una manera f&amp;aacute;cil de solicitar la entrada del usuario utilizada para escribir un archivo MAKE. Muestra el mensaje $ como una solicitud de entrada. Si se proporciona un $ predeterminado, se utilizar&amp;aacute; como predeterminado. La funci&amp;oacute;n devuelve el valor $ seleccionado por el usuario.</target>
        </trans-unit>
        <trans-unit id="251a318ac7ae399ceb208b84bc39666205a2a077" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test suite run.</source>
          <target state="translated">El comando de &lt;code&gt;prove&lt;/code&gt; admite una opci&amp;oacute;n &lt;code&gt;--state&lt;/code&gt; que le indica que almacene el estado persistente en todas las ejecuciones. Este m&amp;oacute;dulo encapsula los resultados de una sola ejecuci&amp;oacute;n de conjunto de pruebas.</target>
        </trans-unit>
        <trans-unit id="225b0b123ca124089a53e65a14a10e06fffd421b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module encapsulates the results for a single test.</source>
          <target state="translated">El comando de &lt;code&gt;prove&lt;/code&gt; admite una opci&amp;oacute;n &lt;code&gt;--state&lt;/code&gt; que le indica que almacene el estado persistente en todas las ejecuciones. Este m&amp;oacute;dulo encapsula los resultados de una &amp;uacute;nica prueba.</target>
        </trans-unit>
        <trans-unit id="630214733172c835a26947747354eba32ad3911c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;prove&lt;/code&gt; command supports a &lt;code&gt;--state&lt;/code&gt; option that instructs it to store persistent state across runs. This module implements that state and the operations that may be performed on it.</source>
          <target state="translated">El comando de &lt;code&gt;prove&lt;/code&gt; admite una opci&amp;oacute;n &lt;code&gt;--state&lt;/code&gt; que le indica que almacene el estado persistente en todas las ejecuciones. Este m&amp;oacute;dulo implementa ese estado y las operaciones que se pueden realizar en &amp;eacute;l.</target>
        </trans-unit>
        <trans-unit id="ebc7b6c659bfd339fe90d4f36223bdf0f00d2207" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;qr//&lt;/code&gt; operator showed up in perl 5.005. It compiles a regular expression, but doesn't apply it. When you use the pre-compiled version of the regex, perl does less work. In this example, I inserted a &lt;code&gt;map&lt;/code&gt; to turn each pattern into its pre-compiled form. The rest of the script is the same, but faster:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="89a8c0b3ff5aa42089f6c9d44d37572f7b89a880" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#%27%2Fflags%27-mode&quot;&gt;&quot;'/flags' mode&quot; in re&lt;/a&gt; for more detail.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="16ee1aae608f6953af89e472ae38b6d9068b7d8b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;re '/flags'&lt;/code&gt; pragma (introduced in Perl 5.14) turns on the given regular expression flags until the end of the lexical scope. See &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/flags' mode in re&lt;/a&gt; for more detail.</source>
          <target state="translated">El pragma &lt;code&gt;re '/flags'&lt;/code&gt; (introducido en Perl 5.14) activa los indicadores de expresi&amp;oacute;n regular dados hasta el final del &amp;aacute;mbito l&amp;eacute;xico. Consulte el modo &lt;a href=&quot;re#'%2fflags'-mode&quot;&gt;'/ flags' en re&lt;/a&gt; para obtener m&amp;aacute;s detalles.</target>
        </trans-unit>
        <trans-unit id="8026b2e7b59b6835c618b76fac10379af835df78" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;read&lt;/code&gt; will</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="eabbdc8a005d2bf3f21650b9e863366189c7ced7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recent&lt;/code&gt; command downloads a list of recent uploads to CPAN and displays them</source>
          <target state="translated">El comando &lt;code&gt;recent&lt;/code&gt; descarga una lista de cargas recientes a CPAN y las muestra</target>
        </trans-unit>
        <trans-unit id="3ae27e036bb44d621cb68002f9a110e07c700371" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;recipient&lt;/code&gt; method can also pass additional case-sensitive OPTIONS as an anonymous hash using key and value pairs. Possible options are:</source>
          <target state="translated">El m&amp;eacute;todo del &lt;code&gt;recipient&lt;/code&gt; tambi&amp;eacute;n puede pasar OPCIONES adicionales que distinguen entre may&amp;uacute;sculas y min&amp;uacute;sculas como un hash an&amp;oacute;nimo utilizando pares de clave y valor. Las posibles opciones son:</target>
        </trans-unit>
        <trans-unit id="fbfa5e6131ec26898b29be346c8692d308b580c5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;redo&lt;/code&gt; command restarts the loop block without evaluating the conditional again. The &lt;code&gt;continue&lt;/code&gt; block, if any, is</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5f6b672315250ddc806f0b1d734bf40a266a6de9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt; .</source>
          <target state="translated">La &lt;code&gt;regexp&lt;/code&gt; estructura descrita en &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; es com&amp;uacute;n a todos los motores de expresiones regulares. Dos de sus campos est&amp;aacute;n destinados al uso privado del motor de expresiones regulares que compil&amp;oacute; el patr&amp;oacute;n. Estos son los miembros &lt;code&gt;intflags&lt;/code&gt; y pprivate. El &lt;code&gt;pprivate&lt;/code&gt; es un puntero nulo a una estructura arbitraria cuyo uso y manejo es responsabilidad del motor de compilaci&amp;oacute;n. perl nunca modificar&amp;aacute; ninguno de estos valores. En el caso del motor de stock, la estructura apuntada por &lt;code&gt;pprivate&lt;/code&gt; se llama &lt;code&gt;regexp_internal&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="43d7f5d7cf7b3bd50ec33b3f8b3d3e3e1b16ccb8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;regexp&lt;/code&gt; structure described in &lt;a href=&quot;perlreapi&quot;&gt;perlreapi&lt;/a&gt; is common to all regex engines. Two of its fields are intended for the private use of the regex engine that compiled the pattern. These are the &lt;code&gt;intflags&lt;/code&gt; and pprivate members. The &lt;code&gt;pprivate&lt;/code&gt; is a void pointer to an arbitrary structure whose use and management is the responsibility of the compiling engine. perl will never modify either of these values. In the case of the stock engine the structure pointed to by &lt;code&gt;pprivate&lt;/code&gt; is called &lt;code&gt;regexp_internal&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="70e74666fabd3ef514f919b776494b74805eeb39" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;register&lt;/code&gt; method allows for the registration of a message handler for a given subroutine. The full subroutine name including the package should be used.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e4f7500531b634ca33f77ec64b4dcfc7b5a94686" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;release_status&lt;/code&gt; field &lt;b&gt;must&lt;/b&gt; have one of the following values:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="a2292ba9ae057df1902ceef2446c66c533b62b3a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -r&lt;/code&gt; or &lt;code&gt;del /s&lt;/code&gt; on Windows.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;remove_tree&lt;/code&gt; elimina los directorios dados y cualquier archivo y subdirectorio que puedan contener, al igual que el comando de Unix &lt;code&gt;rm -r&lt;/code&gt; o &lt;code&gt;del /s&lt;/code&gt; en Windows.</target>
        </trans-unit>
        <trans-unit id="f1fcc73f0626aba933df61d1eca5f7c5f0df238b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;remove_tree&lt;/code&gt; function deletes the given directories and any files and subdirectories they might contain, much like the Unix command &lt;code&gt;rm -rf&lt;/code&gt; or the Windows commands &lt;code&gt;rmdir /s&lt;/code&gt; and &lt;code&gt;rd /s&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f800b61fba3cbdc9dbaf2d3127156f3c10c2be33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;report&lt;/code&gt; command temporarily turns on the &lt;code&gt;test_report&lt;/code&gt; config variable, then runs the &lt;code&gt;force test&lt;/code&gt; command with the given arguments. The &lt;code&gt;force&lt;/code&gt; pragma reruns the tests and repeats every step that might have failed before.</source>
          <target state="translated">El comando &lt;code&gt;report&lt;/code&gt; activa temporalmente la variable de configuraci&amp;oacute;n &lt;code&gt;test_report&lt;/code&gt; , luego ejecuta el comando &lt;code&gt;force test&lt;/code&gt; con los argumentos dados. El pragma de &lt;code&gt;force&lt;/code&gt; vuelve a ejecutar las pruebas y repite todos los pasos que podr&amp;iacute;an haber fallado antes.</target>
        </trans-unit>
        <trans-unit id="3e0418f790bb3ba77ebbb5b8be57ce758907a81a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;request&lt;/code&gt; method returns a hashref containing the response. The hashref will have the following keys:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="bb965f28ada4d369f813e7b58370f45663a7e17c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;requires&lt;/code&gt; and &lt;code&gt;build_requires&lt;/code&gt; dependency declarations</source>
          <target state="translated">El &lt;code&gt;requires&lt;/code&gt; y &lt;code&gt;build_requires&lt;/code&gt; la dependencia declaraciones</target>
        </trans-unit>
        <trans-unit id="6825adde139cbe709d6cacc6c4ea55d8ef7cff02" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;resolve&lt;/code&gt; function is called to generate a linearised ISA for the given stash, using this MRO. It is called with a pointer to the stash, and a</source>
          <target state="translated">Se llama a la funci&amp;oacute;n de &lt;code&gt;resolve&lt;/code&gt; para generar un ISA linealizado para el alijo dado, utilizando este MRO. Se llama con un puntero al alijo y un</target>
        </trans-unit>
        <trans-unit id="20a1d55e5f69a55a8401c7bd274cec494c442203" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;&quot;new&quot;&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e85b7e6554a08b089b5049ccd1a608787302c15" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;result_factory_class&lt;/code&gt; can be customized, as described in &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt;.</source>
          <target state="translated">El &lt;code&gt;result_factory_class&lt;/code&gt; se puede personalizar, como se describe en &lt;a href=&quot;#new&quot;&gt;new&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="8ca2114e55ee9c4857e906508831f67273f52466" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;retrans&lt;/code&gt; argument the exponential backoff rate, default 1.2. It matches the $def_factor global.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6d4f5cbea499bebe5f70cb857ce9ac77d66aaa7a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;rmtree()&lt;/code&gt; function provide the legacy interface of &lt;code&gt;remove_tree()&lt;/code&gt; with a different interpretation of the arguments passed. The behaviour and return value of the function is otherwise identical to &lt;code&gt;remove_tree()&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6451f829e84fc9b2a12b294243486a8357dccdcc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;roffitall&lt;/code&gt; utility is not installed on your system but lives in the</source>
          <target state="translated">La utilidad &lt;code&gt;roffitall&lt;/code&gt; no est&amp;aacute; instalada en su sistema, pero vive en el</target>
        </trans-unit>
        <trans-unit id="38bb81c7279e4123eea02d7b94773b0e43184b92" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;run&lt;/code&gt; method returns 0 on success and a positive number on failure. See the section on EXIT CODES for details on the values.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ec12f7a8b2d7f40a1c42ea8d991b557d8527791c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;s///&lt;/code&gt; substitution operator is documented in &lt;a href=&quot;perlop&quot;&gt;perlop&lt;/a&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1f11595235e0f9e5e74b59c34bf7ac4552157c76" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;send()&lt;/code&gt; method is used to issue an event to the hub. This method will handle thread/fork sync, filters, listeners, TAP output, etc.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9411561fa33dd9a0d96df4e7b49fae524226bee1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;skip(...)&lt;/code&gt; function is for tests that might or might not be possible to run, depending on the availability of platform-specific features. The first argument should evaluate to true (think &quot;yes, please skip&quot;) if the required feature is</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;skip(...)&lt;/code&gt; es para pruebas que podr&amp;iacute;an o no ser posibles de ejecutar, dependiendo de la disponibilidad de funciones espec&amp;iacute;ficas de la plataforma. El primer argumento debe evaluarse como verdadero (piense &quot;s&amp;iacute;, omita&quot;) si la caracter&amp;iacute;stica requerida es</target>
        </trans-unit>
        <trans-unit id="4dd34dc5f337a99adbdb95ed69eaa2b33a678e8f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;smoke&lt;/code&gt; command takes the list of recent uploads to CPAN as provided by the &lt;code&gt;recent&lt;/code&gt; command and tests them all. While the command is running $SIG{INT} is defined to mean that the current item shall be skipped.</source>
          <target state="translated">El comando de &lt;code&gt;smoke&lt;/code&gt; toma la lista de cargas recientes a CPAN como lo proporciona el comando &lt;code&gt;recent&lt;/code&gt; y las prueba todas. Mientras se ejecuta el comando, $ SIG {INT} se define para significar que se omitir&amp;aacute; el elemento actual.</target>
        </trans-unit>
        <trans-unit id="c81eca2265a8bfa89f7e2b8216b25f7468527582" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt; , resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="translated">La sugerencia de tipo &lt;code&gt;socktype&lt;/code&gt; para getaddrinfo () filtra los resultados para incluir solo un tipo de socket y protocolo. Sin esto, la mayor&amp;iacute;a de los sistemas operativos devuelven tres combinaciones, para &lt;code&gt;SOCK_STREAM&lt;/code&gt; , &lt;code&gt;SOCK_DGRAM&lt;/code&gt; y &lt;code&gt;SOCK_RAW&lt;/code&gt; , lo que da como resultado una salida por triplicado de direcciones. El indicador &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; para getnameinfo () hace que devuelva una direcci&amp;oacute;n IP simple con formato de cadena, en lugar de resolverla en sentido inverso en un nombre de host.</target>
        </trans-unit>
        <trans-unit id="96db56547c2805160963104b9881650067bc074a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;socktype&lt;/code&gt; hint to getaddrinfo() filters the results to only include one socket type and protocol. Without this most OSes return three combinations, for &lt;code&gt;SOCK_STREAM&lt;/code&gt;, &lt;code&gt;SOCK_DGRAM&lt;/code&gt; and &lt;code&gt;SOCK_RAW&lt;/code&gt;, resulting in triplicate output of addresses. The &lt;code&gt;NI_NUMERICHOST&lt;/code&gt; flag to getnameinfo() causes it to return a string-formatted plain IP address, rather than reverse resolving it back into a hostname.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="03364b2c6aff3f77be6e48e31bc6fc170edb9637" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;TAP::Parser::Source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;&quot;iterator_factory_class&quot;&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8fb1bd48c372b36b030a4985fb7d0b8ecfff9314" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;source&lt;/code&gt; is used to create a &lt;a href=&quot;parser/source&quot;&gt;TAP::Parser::Source&lt;/a&gt; that is passed to the &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; which in turn figures out how to handle the source and creates a &amp;lt;TAP::Parser::Iterator&amp;gt; for it. The iterator is used by the parser to read in the TAP stream.</source>
          <target state="translated">La &lt;code&gt;source&lt;/code&gt; se utiliza para crear un &lt;a href=&quot;parser/source&quot;&gt;TAP :: Parser :: Source&lt;/a&gt; que se pasa a &lt;a href=&quot;#iterator_factory_class&quot;&gt;iterator_factory_class&lt;/a&gt; que a su vez descubre c&amp;oacute;mo manejar la fuente y crea un &amp;lt;TAP :: Parser :: Iterator&amp;gt; para ella. El analizador usa el iterador para leer en el flujo TAP.</target>
        </trans-unit>
        <trans-unit id="92eb80578e9c5fa00cf858e0d3634beaaf8da658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; parameters are handled.</source>
          <target state="translated">El par&amp;aacute;metro de &lt;code&gt;sources&lt;/code&gt; afecta c&amp;oacute;mo se manejan los par&amp;aacute;metros de &lt;code&gt;source&lt;/code&gt; , &lt;code&gt;tap&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;../functions/exec&quot;&gt;exec&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="ecf38e3d7dde64637f98a88870a2d809b9706769" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sources&lt;/code&gt; parameter affects how &lt;code&gt;source&lt;/code&gt;, &lt;code&gt;tap&lt;/code&gt; and &lt;code&gt;exec&lt;/code&gt; parameters are handled.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b7630407dfd17260fb141bba76fd71474e26eb1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;split()&lt;/code&gt; function is another place where a regexp is used. &lt;code&gt;split /regexp/, string, limit&lt;/code&gt; separates the &lt;code&gt;string&lt;/code&gt; operand into a list of substrings and returns that list. The regexp must be designed to match whatever constitutes the separators for the desired substrings. The &lt;code&gt;limit&lt;/code&gt;, if present, constrains splitting into no more than &lt;code&gt;limit&lt;/code&gt; number of strings. For example, to split a string into words, use</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5429b24bd7773605c81ffce19b7803e3914ae70b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;state&lt;/code&gt; keyword creates a lexical variable (following the same scoping rules as &lt;code&gt;my&lt;/code&gt;) that persists from one subroutine call to the next. If a state variable resides inside an anonymous subroutine, then each copy of the subroutine has its own copy of the state variable. However, the value of the state variable will still persist between calls to the same copy of the anonymous subroutine. (Don't forget that &lt;code&gt;sub { ... }&lt;/code&gt; creates a new subroutine each time it is executed.)</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="99a6aa9719696ddb8bff79a8c79538ca92e0d2e8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strend&lt;/code&gt; and &lt;code&gt;patend&lt;/code&gt; pointers should point to the byte following the last character of each string.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ea6e352d41818ff4bf26ca16e10b39452c55d91f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma disables certain Perl expressions that could behave unexpectedly or are difficult to debug, turning them into errors. The effect of this pragma is limited to the current file or scope block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="027d4af5bb9710fddfec7b10292492a3bd8321cd" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;strict&lt;/code&gt; pragma is useful in avoiding such errors.</source>
          <target state="translated">El pragma &lt;code&gt;strict&lt;/code&gt; es &amp;uacute;til para evitar tales errores.</target>
        </trans-unit>
        <trans-unit id="bda6d4349e03cdc3822accb764cf2332f0d166cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct()&lt;/code&gt; function</source>
          <target state="translated">El &lt;code&gt;struct()&lt;/code&gt; funci&amp;oacute;n</target>
        </trans-unit>
        <trans-unit id="7a95e760c73406947e7da7714b03782e42d5fa06" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;struct&lt;/code&gt; function has three forms of parameter-list.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;struct&lt;/code&gt; tiene tres formas de lista de par&amp;aacute;metros.</target>
        </trans-unit>
        <trans-unit id="4f0312b0e41bdaef162518003e58d7dd5119b5b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sub-entry&lt;/code&gt; and &lt;code&gt;sub-return&lt;/code&gt; probes gain a fourth argument: the package name of the function.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e032455d26f301f9311f3905ad487e2683ae6647" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; field of the response will be true if the status code is 2XX or if the status code is 304 (unmodified).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="76f86ba3ab4dadf0c5969933e8badc4119d9d2f7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;success&lt;/code&gt; field of the response will be true if the status code is 2XX.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7f8db9fbaa56d501321f36a7b37f026962feda33" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;supports_tables&lt;/code&gt; method should be true if the formatter supports directly rendering table data from the &lt;code&gt;info&lt;/code&gt; facets. This is a newer feature and many older formatters may not support it. When not supported the formatter falls back to rendering &lt;code&gt;detail&lt;/code&gt; instead of the &lt;code&gt;table&lt;/code&gt; data.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ca2248434d315d7f4555ab09ed558fffeb25af18" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument is a pointer to the SV that is to acquire a new magical feature.</source>
          <target state="translated">El argumento &lt;code&gt;sv&lt;/code&gt; es un puntero al SV que va a adquirir una nueva caracter&amp;iacute;stica m&amp;aacute;gica.</target>
        </trans-unit>
        <trans-unit id="3bd810d1cf1c18312d2c5eb1e03b023fe5ee01ae" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;&quot;Stashes and Globs&quot;&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9d1732cdeea04b3b5302655756ff012b4b97e760" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv&lt;/code&gt; argument must be a reference value. The &lt;code&gt;stash&lt;/code&gt; argument specifies which class the reference will belong to. See &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;Stashes and Globs&lt;/a&gt; for information on converting class names into stashes.</source>
          <target state="translated">El argumento &lt;code&gt;sv&lt;/code&gt; debe ser un valor de referencia. El argumento &lt;code&gt;stash&lt;/code&gt; especifica a qu&amp;eacute; clase pertenecer&amp;aacute; la referencia. Consulte &lt;a href=&quot;#Stashes-and-Globs&quot;&gt;Stashes y Globs&lt;/a&gt; para obtener informaci&amp;oacute;n sobre c&amp;oacute;mo convertir nombres de clases en escondites.</target>
        </trans-unit>
        <trans-unit id="3c426a5175e1475eb159d7aa2bfc10b9aeb2592e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; later in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="5aa9fb7196f50b878b4d2185150e32ef86a1a0ee" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_cat*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">Las &lt;code&gt;sv_cat*()&lt;/code&gt; no son lo suficientemente gen&amp;eacute;ricas para operar con valores que tienen &quot;magia&quot;. Consulte &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Tablas virtuales m&amp;aacute;gicas&lt;/a&gt; m&amp;aacute;s adelante en este documento.</target>
        </trans-unit>
        <trans-unit id="2ca2c3639e16b490b555d2489361f0871018a997" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;&quot;Magic Virtual Tables&quot;&lt;/a&gt; later in this document.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="451bffe03c920b337c26d3f6c5c7b3d0a90a952c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;sv_set*()&lt;/code&gt; functions are not generic enough to operate on values that have &quot;magic&quot;. See &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Magic Virtual Tables&lt;/a&gt; later in this document.</source>
          <target state="translated">Las &lt;code&gt;sv_set*()&lt;/code&gt; no son lo suficientemente gen&amp;eacute;ricas para operar con valores que tienen &quot;magia&quot;. Consulte &lt;a href=&quot;#Magic-Virtual-Tables&quot;&gt;Tablas virtuales m&amp;aacute;gicas&lt;/a&gt; m&amp;aacute;s adelante en este documento.</target>
        </trans-unit>
        <trans-unit id="a022ed577de5458a14b966f973f3ce2a62bb2a5b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; built-in is considered to have failed in the following circumstances:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="817c94b76b6dd84c4c7d9bb171edda3a93d8445e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;system&lt;/code&gt; operator creates a subprocess, and passes its arguments to the subprocess for execution as a DCL command. Since the subprocess is created directly via &lt;code&gt;lib$spawn()&lt;/code&gt;, any valid DCL command string may be specified. If the string begins with '@', it is treated as a DCL command unconditionally. Otherwise, if the first token contains a character used as a delimiter in file specification (e.g. &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;]&lt;/code&gt;), an attempt is made to expand it using a default type of</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="264e3c8ac2fdd944cc02ae92713944fc8cf6494f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="translated">La &lt;code&gt;taint&lt;/code&gt; pragma hace que cualquier subcadena de un partido con una variable contaminada a ser contaminados tambi&amp;eacute;n. Normalmente, este no es el caso, ya que las expresiones regulares se utilizan a menudo para extraer los bits seguros de una variable contaminada. Use &lt;code&gt;taint&lt;/code&gt; cuando no est&amp;eacute; extrayendo bits seguros, pero est&amp;eacute; realizando alg&amp;uacute;n otro procesamiento. Tanto &lt;code&gt;taint&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/eval&quot;&gt;eval&lt;/a&gt;&lt;/code&gt; pragmas se &amp;aacute;mbito l&amp;eacute;xico, que significa que son en efecto s&amp;oacute;lo hasta el final del bloque que encierra los pragmas.</target>
        </trans-unit>
        <trans-unit id="45b556a65806a34a0370ae702153cb4405855fa8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;taint&lt;/code&gt; pragma causes any substrings from a match with a tainted variable to be tainted as well. This is not normally the case, as regexps are often used to extract the safe bits from a tainted variable. Use &lt;code&gt;taint&lt;/code&gt; when you are not extracting safe bits, but are performing some other processing. Both &lt;code&gt;taint&lt;/code&gt; and &lt;code&gt;eval&lt;/code&gt; pragmas are lexically scoped, which means they are in effect only until the end of the block enclosing the pragmas.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3cc9bc272d719ab5016869a769d84acd8ec8d7c2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminate&lt;/code&gt; and &lt;code&gt;finalize&lt;/code&gt; methods are optional methods called that you can implement if the format you're generating needs to handle these cases, for example if you are generating XML and need close open tags.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="423cad30ef0048166a8eebe3340a46a30155372e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;terminate&lt;/code&gt; method is called when an event's &lt;code&gt;terminate&lt;/code&gt; method returns true, for example when a &lt;a href=&quot;Test2::Event::Plan&quot;&gt;Test2::Event::Plan&lt;/a&gt; has a &lt;code&gt;'skip_all'&lt;/code&gt; plan, or when a &lt;a href=&quot;Test2::Event::Bail&quot;&gt;Test2::Event::Bail&lt;/a&gt; event is sent. The &lt;code&gt;terminate&lt;/code&gt; method is passed a single argument, the &lt;a href=&quot;Test2::Event&quot;&gt;Test2::Event&lt;/a&gt; object which triggered the terminate.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0e22b53957ab545ec5f1fe43f2463dbb75fb5bef" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;test_diag&lt;/code&gt; function prepends comment hashes and spacing to the start and newlines to the end of the expected output passed to it and adds it to the list of expected error output. So, instead of writing</source>
          <target state="translated">El &lt;code&gt;test_diag&lt;/code&gt; funci&amp;oacute;n antepone los hashes de comentarios y espaciado del inicio y saltos de l&amp;iacute;nea al final de la salida esperada se le ha pasado y lo a&amp;ntilde;ade a la lista de salida de error esperado. Entonces, en lugar de escribir</target>
        </trans-unit>
        <trans-unit id="9a044497bbeccf899d123e744ac60158148d66b5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; , or &lt;code&gt;HV*&lt;/code&gt; . The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt; , while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt; .</source>
          <target state="translated">El argumento de &lt;code&gt;thing&lt;/code&gt; puede ser cualquiera de &lt;code&gt;SV*&lt;/code&gt; , &lt;code&gt;AV*&lt;/code&gt; o &lt;code&gt;HV*&lt;/code&gt; . Las funciones son id&amp;eacute;nticas excepto que &lt;code&gt;newRV_inc&lt;/code&gt; incrementa el recuento de referencias de la &lt;code&gt;thing&lt;/code&gt; , mientras que &lt;code&gt;newRV_noinc&lt;/code&gt; no lo hace. Por razones hist&amp;oacute;ricas, &lt;code&gt;newRV&lt;/code&gt; es sin&amp;oacute;nimo de &lt;code&gt;newRV_inc&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="39f6cd9542d25aca0f6da28dc2eb900530cd2e73" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;thing&lt;/code&gt; argument can be any of an &lt;code&gt;SV*&lt;/code&gt;, &lt;code&gt;AV*&lt;/code&gt;, or &lt;code&gt;HV*&lt;/code&gt;. The functions are identical except that &lt;code&gt;newRV_inc&lt;/code&gt; increments the reference count of the &lt;code&gt;thing&lt;/code&gt;, while &lt;code&gt;newRV_noinc&lt;/code&gt; does not. For historical reasons, &lt;code&gt;newRV&lt;/code&gt; is a synonym for &lt;code&gt;newRV_inc&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="764690cb5a9a1e69711deb7f1d4bd7570cd33533" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; class method provides your program with a way to get an object representing the thread it's currently in. You can use this object in the same way as the ones returned from thread creation.</source>
          <target state="translated">El m&amp;eacute;todo de clase &lt;code&gt;threads-&amp;gt;self()&lt;/code&gt; proporciona a su programa una forma de obtener un objeto que represente el hilo en el que se encuentra actualmente. Puede usar este objeto de la misma manera que los devueltos por la creaci&amp;oacute;n del hilo.</target>
        </trans-unit>
        <trans-unit id="5cb77a0f1c56daabcc9daa1cb20e1afceca163c1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tid&lt;/code&gt; method returns the tid of a thread. The tid is a monotonically increasing integer assigned when a thread is created. The main thread of a program will have a tid of zero, while subsequent threads will have tids assigned starting with one.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;tid&lt;/code&gt; devuelve el tid de un hilo. El tid es un n&amp;uacute;mero entero que aumenta mon&amp;oacute;tonamente y se asigna cuando se crea un hilo. El subproceso principal de un programa tendr&amp;aacute; un tid de cero, mientras que los subprocesos posteriores tendr&amp;aacute;n tids asignados comenzando con uno.</target>
        </trans-unit>
        <trans-unit id="852bdb693d32a436b5f27ac2d4c29c14b07baed2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tie&lt;/code&gt; call returns an object, say &lt;code&gt;$o&lt;/code&gt;. You may call</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="9c7906336a9d98d4a1cf6a79c6964edf2df1f812" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;time*_modern()&lt;/code&gt; subs do not do this year munging and simply take the year value as provided.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="62cae6d3e02f73d7641c7861d0693bc4b08d5c81" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; and &lt;code&gt;timegm()&lt;/code&gt; functions perform range checking on the input $sec, $min, $hour, $mday, and $mon values by default.</source>
          <target state="translated">Las &lt;code&gt;timelocal()&lt;/code&gt; y &lt;code&gt;timegm()&lt;/code&gt; realizan la verificaci&amp;oacute;n de rango en los valores de entrada $ sec, $ min, $ hour, $ mday y $ mon de forma predeterminada.</target>
        </trans-unit>
        <trans-unit id="3444ad2f99e605827ac849ba41549cb93537c5ca" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;timelocal()&lt;/code&gt; se implementa utilizando el mismo cach&amp;eacute;. Simplemente asumimos que estamos traduciendo una hora GMT y luego la modificamos cuando terminamos para los argumentos de la zona horaria y el horario de verano. Tenga en cuenta que la zona horaria se eval&amp;uacute;a para cada fecha porque los pa&amp;iacute;ses ocasionalmente cambian sus zonas horarias oficiales. Suponiendo que &lt;code&gt;&lt;a href=&quot;../functions/localtime&quot;&gt;localtime()&lt;/a&gt;&lt;/code&gt; corrige estos cambios, esta rutina tambi&amp;eacute;n ser&amp;aacute; correcta.</target>
        </trans-unit>
        <trans-unit id="d6031b9f93c7f0ead71810ff0ffcc9e88c83f87c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;timelocal()&lt;/code&gt; function is implemented using the same cache. We just assume that we're translating a GMT time, and then fudge it when we're done for the timezone and daylight savings arguments. Note that the timezone is evaluated for each date because countries occasionally change their official timezones. Assuming that &lt;code&gt;localtime()&lt;/code&gt; corrects for these changes, this routine will also be correct.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="79e29c335d0e24d411a115fbcbdaff898b8a8cf5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;times()&lt;/code&gt; function returns elapsed realtime since some point in the past (such as system startup), user and system times for this process, and user and system times used by child processes. All times are returned in clock ticks.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e88ddb341d5b31f6433cf87d10fae07c89fb702d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tmpnam&lt;/code&gt; function returns a unique string which can be used as a filename when creating temporary files. If, for some reason, it is unable to generate a name, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6b8678670162f30c825dc963303a8366061c0624" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr///&lt;/code&gt; operator translates whole characters. (Note that the &lt;code&gt;tr///CU&lt;/code&gt; functionality has been removed. For similar functionality to that, see &lt;code&gt;pack('U0', ...)&lt;/code&gt; and &lt;code&gt;pack('C0', ...)&lt;/code&gt;).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d1863d41e42c91ece1fce678f54e90a29e06de0d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; alternative might look like this:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="c010b9c38ee87dfd390ac847c9b0e002caa8d481" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; counts the null bytes. The &lt;code&gt;unpack&lt;/code&gt; call returns a list of name-value pairs each of which is taken apart in the &lt;code&gt;map&lt;/code&gt; block.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="accc9aa113f108f1f58344bb9d92f9dd409a973d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;tr&lt;/code&gt; version is a clear winner. One solution is flexible, the other is fast - and it's appropriately the programmer's choice which to use.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7969d03acba8ec22322bc524970a2e67bf531eeb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type&lt;/code&gt; argument should be equal to the &lt;code&gt;how&lt;/code&gt; value when the &lt;code&gt;SV&lt;/code&gt; was initially made magical.</source>
          <target state="translated">El argumento de &lt;code&gt;type&lt;/code&gt; debe ser igual al valor de &lt;code&gt;how&lt;/code&gt; cuando el &lt;code&gt;SV&lt;/code&gt; se hizo m&amp;aacute;gico inicialmente.</target>
        </trans-unit>
        <trans-unit id="45b58766c7b5bfa7d8fbeea9c00e3139b61f934f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type=&quot;man&quot;&lt;/code&gt; attribute is always specified for this type of L code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="51e37e784cf8826358b635a533d80412ae68521a" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;type=&quot;url&quot;&lt;/code&gt; attribute is always specified for this type of L code.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e605c3e8404b3b1569b2a8f6ee2a28bb09c8e25f" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; or &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="translated">La plantilla &lt;code&gt;u&lt;/code&gt; para &lt;code&gt;&lt;a href=&quot;functions/pack&quot;&gt;pack()&lt;/a&gt;&lt;/code&gt; o &lt;code&gt;&lt;a href=&quot;functions/unpack&quot;&gt;unpack()&lt;/a&gt;&lt;/code&gt; generar&amp;aacute; datos EBCDIC en caracteres EBCDIC equivalentes a sus contrapartes ASCII. Por ejemplo, lo siguiente imprimir&amp;aacute; &quot;S&amp;iacute;, efectivamente \ n&quot; en una computadora ASCII o EBCDIC:</target>
        </trans-unit>
        <trans-unit id="bcdcd5bf5921d41526775a635bdda4515bcae7f3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;u&lt;/code&gt; template to &lt;code&gt;pack()&lt;/code&gt; or &lt;code&gt;unpack()&lt;/code&gt; will render EBCDIC data in EBCDIC characters equivalent to their ASCII counterparts. For example, the following will print &quot;Yes indeed\n&quot; on either an ASCII or EBCDIC computer:</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0998cba5f7c7355370ef1940f9de1afcbe1199eb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;undef&lt;/code&gt; value is treated by this function as distinct from the empty string, and no warning will be produced. It is left as-is in the returned list. Subsequent &lt;code&gt;undef&lt;/code&gt; values are still considered identical to the first, and will be removed.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="7c83289af1a4c0f7e1129f103e79b7a1caa912f8" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;untie&lt;/code&gt; Gotcha</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="6a1909f52d28496be25968c9641232bd70a050cf" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;up&lt;/code&gt; method increases the semaphore's count by the number specified (which must be an integer &amp;gt;= 1), or by one if no number is specified.</source>
          <target state="translated">El m&amp;eacute;todo &lt;code&gt;up&lt;/code&gt; aumenta la cuenta del sem&amp;aacute;foro en el n&amp;uacute;mero especificado (que debe ser un n&amp;uacute;mero entero&amp;gt; = 1), o en uno si no se especifica ning&amp;uacute;n n&amp;uacute;mero.</target>
        </trans-unit>
        <trans-unit id="3bfafbe930277e35ea02604239f7cd015c3326fb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;upgrade&lt;/code&gt; command first runs an &lt;code&gt;r&lt;/code&gt; command with the given arguments and then installs the newest versions of all modules that were listed by that.</source>
          <target state="translated">El comando de &lt;code&gt;upgrade&lt;/code&gt; primero ejecuta un comando &lt;code&gt;r&lt;/code&gt; con los argumentos dados y luego instala las versiones m&amp;aacute;s recientes de todos los m&amp;oacute;dulos enumerados por ese.</target>
        </trans-unit>
        <trans-unit id="ed2a8ecd68dda5352fc1303d01e5cd582863eba1" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;urllist&lt;/code&gt; parameter of the configuration table contains a list of URLs used for downloading. If the list contains any &lt;code&gt;file&lt;/code&gt; URLs, CPAN always tries there first. This feature is disabled for index files. So the recommendation for the owner of a CD-ROM with CPAN contents is: include your local, possibly outdated CD-ROM as a &lt;code&gt;file&lt;/code&gt; URL at the end of urllist, e.g.</source>
          <target state="translated">El par&amp;aacute;metro &lt;code&gt;urllist&lt;/code&gt; de la tabla de configuraci&amp;oacute;n contiene una lista de URL utilizadas para la descarga. Si la lista contiene alguna URL de &lt;code&gt;file&lt;/code&gt; , CPAN siempre intenta all&amp;iacute; primero. Esta funci&amp;oacute;n est&amp;aacute; deshabilitada para archivos de &amp;iacute;ndice. Por lo tanto, la recomendaci&amp;oacute;n para el propietario de un CD-ROM con contenido CPAN es: incluya su CD-ROM local, posiblemente desactualizado, como una URL de &lt;code&gt;file&lt;/code&gt; al final de la lista de direcciones, por ejemplo</target>
        </trans-unit>
        <trans-unit id="52b900f042b9fdb4fefbfa11c5b63b7617ef4658" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use &lt;a href=&quot;warnings&quot;&gt;warnings&lt;/a&gt;&lt;/code&gt; pragma produces some lovely diagnostics. One can also use the &lt;b&gt;-w&lt;/b&gt; flag, but its use is normally discouraged, because it gets applied to all executed Perl code, including that not under your control.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="d475de0db7f66747e084c66e42ee75d8f3488116" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use filetest&lt;/code&gt; or &lt;code&gt;no filetest&lt;/code&gt; statements affect file tests defined in their block, up to the end of the closest enclosing block (they are lexically block-scoped).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="acfbde926d15ce3b3022057fc9c74ed9c253c404" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use utf8&lt;/code&gt; pragma tells the Perl parser to allow UTF-8 in the program text in the current lexical scope. The &lt;code&gt;no utf8&lt;/code&gt; pragma tells Perl to switch back to treating the source text as literal bytes in the current lexical scope. (On EBCDIC platforms, technically it is allowing UTF-EBCDIC, and not UTF-8, but this distinction is academic, so in this document the term UTF-8 is used to mean both).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="29c5989f0b30cb3c2f7f588b2b53bc0b52ccd653" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; switch will warn you if it interprets a reserved word as a string. But it will no longer warn you about using lowercase words, because the string is effectively quoted.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="468aa2690cfac4f39947fa49f9490387f38518f6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; and &lt;code&gt;utf8::upgrade()&lt;/code&gt; aren't needed if the argument is above 0xFF, so the above could have been written as</source>
          <target state="translated">El &lt;code&gt;utf8::unicode_to_native()&lt;/code&gt; y &lt;code&gt;utf8::upgrade()&lt;/code&gt; no son necesarios si el argumento es superior a 0xFF, lo que lo anterior podr&amp;iacute;a haber sido escrito como</target>
        </trans-unit>
        <trans-unit id="c685630771328cb31903796f4e815c9203e60a01" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;utf8&lt;/code&gt; flag therefore switches between two modes: disabled means you will get a Unicode string in Perl, enabled means you get an UTF-8 encoded octet/binary string in Perl.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="14707ff227aab2f7f6198f5296b54e26eed1065e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;util.c:1716&lt;/code&gt; is the source code file and line number.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="8b13c9e2cf58e77564c57c1639c049e04a961551" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars&lt;/code&gt; pragma (see &lt;a href=&quot;perlmod#vars&quot;&gt;&quot;vars&quot; in perlmod&lt;/a&gt;) may be used in such situations as an alternative to explicitly qualifying all globals with the package namespace. Variables pre-declared with this pragma will be visible to any autoloaded routines (but will not be invisible outside the package, unfortunately).</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="0a270d12703e96872d5ec49cc2bfa5c1ab0eb455" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vars&lt;/code&gt; pragma (see &lt;a href=&quot;perlmod#vars&quot;&gt;vars in perlmod&lt;/a&gt;) may be used in such situations as an alternative to explicitly qualifying all globals with the package namespace. Variables pre-declared with this pragma will be visible to any autoloaded routines (but will not be invisible outside the package, unfortunately).</source>
          <target state="translated">El pragma &lt;code&gt;vars&lt;/code&gt; (ver &lt;a href=&quot;perlmod#vars&quot;&gt;vars en perlmod&lt;/a&gt; ) se puede usar en tales situaciones como una alternativa para calificar expl&amp;iacute;citamente todos los globales con el espacio de nombres del paquete. Las variables declaradas previamente con este pragma ser&amp;aacute;n visibles para cualquier rutina de carga autom&amp;aacute;tica (pero no ser&amp;aacute;n invisibles fuera del paquete, desafortunadamente).</target>
        </trans-unit>
        <trans-unit id="8a981f510b5bc1a31c1fe6f83ee184b884a41beb" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verbose&lt;/code&gt; and &lt;code&gt;inc&lt;/code&gt; attributes influence the behavior of this search; notably, &lt;code&gt;inc&lt;/code&gt; , if true, adds @INC</source>
          <target state="translated">Los atributos &lt;code&gt;verbose&lt;/code&gt; e &lt;code&gt;inc&lt;/code&gt; influyen en el comportamiento de esta b&amp;uacute;squeda; notablemente, &lt;code&gt;inc&lt;/code&gt; , si es verdadero, agrega @INC</target>
        </trans-unit>
        <trans-unit id="e2febc4d875aa8fe8fb27485c483c05158694811" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;verbose&lt;/code&gt; and &lt;code&gt;inc&lt;/code&gt; attributes influence the behavior of this search; notably, &lt;code&gt;inc&lt;/code&gt;, if true, adds @INC</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="543a455e6e879b54b06a46e043825bb2c5bcee1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;version&lt;/code&gt; option is required. If it is omitted or if an unsupported version is given, then &lt;code&gt;provides&lt;/code&gt; will throw an error.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="647cdf74da11836aaddbacaf0e85905018d3cf1e" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;vmsopen&lt;/code&gt; function enables you to specify optional RMS arguments to the VMS CRTL when opening a file. Its operation is similar to the built-in Perl &lt;code&gt;open&lt;/code&gt; function (see &lt;a href=&quot;perlfunc&quot;&gt;perlfunc&lt;/a&gt; for a complete description), but it will only open normal files; it cannot open pipes or duplicate existing I/O handles. Up to 8 optional arguments may follow the file name. These arguments should be strings which specify optional file characteristics as allowed by the CRTL. (See the CRTL reference manual description of creat() and fopen() for details.) If successful, &lt;code&gt;vmsopen&lt;/code&gt; returns a VMS::Stdio file handle; if an error occurs, it returns &lt;code&gt;undef&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42e9db15fd405837558fc69a3922cf4c07b0d66c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;void&lt;/code&gt; return type for this function tells the &lt;b&gt;xsubpp&lt;/b&gt; compiler that the RETVAL variable is not needed or used and that it should not be created. In most scenarios the void return type should be used with the PPCODE: directive.</source>
          <target state="translated">El tipo de retorno &lt;code&gt;void&lt;/code&gt; para esta funci&amp;oacute;n le dice al compilador &lt;b&gt;xsubpp&lt;/b&gt; que la variable RETVAL no se necesita ni se usa y que no debe crearse. En la mayor&amp;iacute;a de los escenarios, el tipo de retorno vac&amp;iacute;o debe usarse con la directiva PPCODE :.</target>
        </trans-unit>
        <trans-unit id="0803129a0bffe56a31c42b951ef5b3d0fb1885a9" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;wanted()&lt;/code&gt; function does whatever verifications you want on each file and directory. Note that despite its name, the &lt;code&gt;wanted()&lt;/code&gt; function is a generic callback function, and does &lt;b&gt;not&lt;/b&gt; tell File::Find if a file is &quot;wanted&quot; or not. In fact, its return value is ignored.</source>
          <target state="translated">La funci&amp;oacute;n &lt;code&gt;wanted()&lt;/code&gt; realiza las verificaciones que desee en cada archivo y directorio. Tenga en cuenta que a pesar de su nombre, la funci&amp;oacute;n &lt;code&gt;wanted()&lt;/code&gt; es una funci&amp;oacute;n de devoluci&amp;oacute;n de llamada gen&amp;eacute;rica y no &lt;b&gt;le&lt;/b&gt; dice a File :: Find si un archivo es &quot;buscado&quot; o no. De hecho, se ignora su valor de retorno.</target>
        </trans-unit>
        <trans-unit id="31b1fe49028e0123810b9a17034fff70bf1be6cc" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma gives control over which warnings are enabled in which parts of a Perl program. It's a more flexible alternative for both the command line flag &lt;b&gt;-w&lt;/b&gt; and the equivalent Perl variable, &lt;code&gt;$^W&lt;/code&gt; .</source>
          <target state="translated">El pragma de &lt;code&gt;warnings&lt;/code&gt; da control sobre qu&amp;eacute; advertencias est&amp;aacute;n habilitadas en qu&amp;eacute; partes de un programa Perl. Es una alternativa m&amp;aacute;s flexible tanto para el indicador de l&amp;iacute;nea de comandos &lt;b&gt;-w&lt;/b&gt; y la variable Perl equivalente, &lt;code&gt;$^W&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a8cf47d373c14fa99c46a7f56571b8224d41ad4d" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma gives control over which warnings are enabled in which parts of a Perl program. It's a more flexible alternative for both the command line flag &lt;b&gt;-w&lt;/b&gt; and the equivalent Perl variable, &lt;code&gt;$^W&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="4d599e8a7252be8237239500a33b9cae49be5da2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;warnings&lt;/code&gt; pragma provides a number of functions that are useful for module authors. These are used when you want to report a module-specific warning to a calling module has enabled warnings via the &lt;code&gt;warnings&lt;/code&gt; pragma.</source>
          <target state="translated">El pragma de &lt;code&gt;warnings&lt;/code&gt; proporciona una serie de funciones que son &amp;uacute;tiles para los autores de m&amp;oacute;dulos. Estos se utilizan cuando desea informar una advertencia espec&amp;iacute;fica del m&amp;oacute;dulo a un m&amp;oacute;dulo que llama que ha habilitado advertencias a trav&amp;eacute;s del pragma de &lt;code&gt;warnings&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="eaaf2c2b19accccb92902e0f89453388a8136ad7" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; modifier is an experimental feature that first appeared in Perl 5.14. To use it, you should include a &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; declaration. (Technically, it requires only the &lt;code&gt;switch&lt;/code&gt; feature, but that aspect of it was not available before 5.14.) Operative only from within a &lt;code&gt;foreach&lt;/code&gt; loop or a &lt;code&gt;given&lt;/code&gt; block, it executes the statement only if the smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; is true. If the statement executes, it is followed by a &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; from inside a &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; from inside a &lt;code&gt;given&lt;/code&gt; .</source>
          <target state="translated">El modificador &lt;code&gt;when&lt;/code&gt; es una caracter&amp;iacute;stica experimental que apareci&amp;oacute; por primera vez en Perl 5.14. Para usarlo, debe incluir una declaraci&amp;oacute;n de &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; v5.14&lt;/code&gt; . (T&amp;eacute;cnicamente, solo requiere la funci&amp;oacute;n de &lt;code&gt;switch&lt;/code&gt; , pero ese aspecto no estaba disponible antes de 5.14.) Operativo solo desde dentro de un bucle &lt;code&gt;foreach&lt;/code&gt; o un bloque &lt;code&gt;given&lt;/code&gt; , ejecuta la declaraci&amp;oacute;n solo si smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; es verdadero. Si la declaraci&amp;oacute;n se ejecuta, es seguida por una &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; desde dentro de un &lt;code&gt;foreach&lt;/code&gt; y una &lt;code&gt;break&lt;/code&gt; desde dentro de una &lt;code&gt;given&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="01d8e0a81cc17a534c96cebc629a6872720abbea" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;when&lt;/code&gt; modifier is an experimental feature that first appeared in Perl 5.14. To use it, you should include a &lt;code&gt;use v5.14&lt;/code&gt; declaration. (Technically, it requires only the &lt;code&gt;switch&lt;/code&gt; feature, but that aspect of it was not available before 5.14.) Operative only from within a &lt;code&gt;foreach&lt;/code&gt; loop or a &lt;code&gt;given&lt;/code&gt; block, it executes the statement only if the smartmatch &lt;code&gt;$_ ~~ &lt;i&gt;EXPR&lt;/i&gt;&lt;/code&gt; is true. If the statement executes, it is followed by a &lt;code&gt;next&lt;/code&gt; from inside a &lt;code&gt;foreach&lt;/code&gt; and &lt;code&gt;break&lt;/code&gt; from inside a &lt;code&gt;given&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e19be3044d8f18bead09bab3403090b34e1156d5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt; modifiers have the usual &quot;&lt;code&gt;while&lt;/code&gt; loop&quot; semantics (conditional evaluated first), except when applied to a &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-BLOCK (or to the Perl4 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt;-SUBROUTINE statement), in which case the block executes once before the conditional is evaluated.</source>
          <target state="translated">El &lt;code&gt;while&lt;/code&gt; y &lt;code&gt;until&lt;/code&gt; modificadores tienen la usual &quot; &lt;code&gt;while&lt;/code&gt; bucle&quot; sem&amp;aacute;ntica (condicional evaluaron primero), excepto cuando se aplica a un &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; -Block (o a la Perl4 &lt;code&gt;&lt;a href=&quot;functions/do&quot;&gt;do&lt;/a&gt;&lt;/code&gt; declaraci&amp;oacute;n -SUBROUTINE), en cuyo caso se ejecuta el bloque una vez antes de que el condicional se eval&amp;uacute;a .</target>
        </trans-unit>
        <trans-unit id="9a6cf234df302fa34cb78a16f01d3bf12b7f579c" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt; modifiers have the usual &quot;&lt;code&gt;while&lt;/code&gt; loop&quot; semantics (conditional evaluated first), except when applied to a &lt;code&gt;do&lt;/code&gt;-BLOCK (or to the Perl4 &lt;code&gt;do&lt;/code&gt;-SUBROUTINE statement), in which case the block executes once before the conditional is evaluated.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="3d5b06f931731acb22dad061fcd52f2783c874b3" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement executes the block as long as the expression is &lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;true&lt;/a&gt;. The &lt;code&gt;until&lt;/code&gt; statement executes the block as long as the expression is false. The LABEL is optional, and if present, consists of an identifier followed by a colon. The LABEL identifies the loop for the loop control statements &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt;, &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt;, and &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt;. If the LABEL is omitted, the loop control statement refers to the innermost enclosing loop. This may include dynamically looking back your call-stack at run time to find the LABEL. Such desperate behavior triggers a warning if you use the &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag.</source>
          <target state="translated">La instrucci&amp;oacute;n &lt;code&gt;while&lt;/code&gt; ejecuta el bloque siempre que la expresi&amp;oacute;n sea &lt;a href=&quot;#Truth-and-Falsehood&quot;&gt;verdadera&lt;/a&gt; . La sentencia &lt;code&gt;until&lt;/code&gt; ejecuta el bloque siempre que la expresi&amp;oacute;n sea falsa. LABEL es opcional y, si est&amp;aacute; presente, consta de un identificador seguido de dos puntos. LABEL identifica el bucle para las declaraciones de control de bucle &lt;code&gt;&lt;a href=&quot;functions/next&quot;&gt;next&lt;/a&gt;&lt;/code&gt; , &lt;code&gt;&lt;a href=&quot;functions/last&quot;&gt;last&lt;/a&gt;&lt;/code&gt; y &lt;code&gt;&lt;a href=&quot;functions/redo&quot;&gt;redo&lt;/a&gt;&lt;/code&gt; . Si se omite LABEL, la instrucci&amp;oacute;n de control de bucle se refiere al bucle de cierre m&amp;aacute;s interno. Esto puede incluir mirar hacia atr&amp;aacute;s din&amp;aacute;micamente su pila de llamadas en tiempo de ejecuci&amp;oacute;n para encontrar LABEL. Un comportamiento tan desesperado desencadena una advertencia si usa el pragma &lt;code&gt;&lt;a href=&quot;functions/use&quot;&gt;use&lt;/a&gt; warnings&lt;/code&gt; o el indicador &lt;b&gt;-w&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="fc7bfa0e2e102bef2e270e8846cdbd5da131def6" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;while&lt;/code&gt; statement executes the block as long as the expression is true. The &lt;code&gt;until&lt;/code&gt; statement executes the block as long as the expression is false. The LABEL is optional, and if present, consists of an identifier followed by a colon. The LABEL identifies the loop for the loop control statements &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, and &lt;code&gt;redo&lt;/code&gt;. If the LABEL is omitted, the loop control statement refers to the innermost enclosing loop. This may include dynamically looking back your call-stack at run time to find the LABEL. Such desperate behavior triggers a warning if you use the &lt;code&gt;use warnings&lt;/code&gt; pragma or the &lt;b&gt;-w&lt;/b&gt; flag.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="2df4bdf5b271135d9fbaa4b9e22485bd5691df53" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;write&lt;/code&gt; method is a method, so it either gets a class or instance. The two arguments are the &lt;code&gt;$event&lt;/code&gt; object it should record, and the &lt;code&gt;$assert_num&lt;/code&gt; which is the number of the current assertion (ok), or the last assertion if this event is not itself an assertion. The assertion number may be any integer 0 or greater, and may be undefined in some cases.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="42f557fbb89c75fd2ab740d93d25721ccbf0fda2" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;yield&lt;/code&gt; function allows another thread to take control of the CPU. The exact results are implementation-dependent.</source>
          <target state="translated">La funci&amp;oacute;n de &lt;code&gt;yield&lt;/code&gt; permite que otro subproceso tome el control de la CPU. Los resultados exactos dependen de la implementaci&amp;oacute;n.</target>
        </trans-unit>
        <trans-unit id="213469077fec26be3b6b3b082204198d28c562aa" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;zipinfo&lt;/code&gt; program that comes with the info-zip distribution (&lt;a href=&quot;http://www.info-zip.org/&quot;&gt;http://www.info-zip.org/&lt;/a&gt;) can also display details of the structure of a zip file.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="246e63b2eb0074027eaf6b6fe6bf0995cbbb987b" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;||&lt;/code&gt;, &lt;code&gt;//&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; operators return the last value evaluated (unlike C's &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;, which return 0 or 1). Thus, a reasonably portable way to find out the home directory might be:</source>
          <target state="translated">El &lt;code&gt;||&lt;/code&gt; , los operadores &lt;code&gt;//&lt;/code&gt; y &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; devuelven el &amp;uacute;ltimo valor evaluado (a diferencia de los C &lt;code&gt;||&lt;/code&gt; y &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , que devuelven 0 o 1). Por lo tanto, una forma razonablemente port&amp;aacute;til de encontrar el directorio de inicio podr&amp;iacute;a ser:</target>
        </trans-unit>
        <trans-unit id="11f57b3d94eabb5c19fb9360ab6afe8316dfa0a5" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~~&lt;/code&gt; operator compares its operands &quot;polymorphically&quot;, determining how to compare them according to their actual types (numeric, string, array, hash, etc.) Like the equality operators with which it shares the same precedence, &lt;code&gt;~~&lt;/code&gt; returns 1 for true and &lt;code&gt;&quot;&quot;&lt;/code&gt; for false. It is often best read aloud as &quot;in&quot;, &quot;inside of&quot;, or &quot;is contained in&quot;, because the left operand is often looked for</source>
          <target state="translated">El operador &lt;code&gt;~~&lt;/code&gt; compara sus operandos &quot;polim&amp;oacute;rficamente&quot;, determinando c&amp;oacute;mo compararlos de acuerdo con sus tipos reales (num&amp;eacute;rico, cadena, matriz, hash, etc.) Como los operadores de igualdad con los que comparte la misma precedencia, &lt;code&gt;~~&lt;/code&gt; devuelve 1 para verdadero y &lt;code&gt;&quot;&quot;&lt;/code&gt; falso. A menudo se lee mejor en voz alta como &quot;en&quot;, &quot;dentro de&quot; o &quot;est&amp;aacute; contenido en&quot;, porque el operando izquierdo a menudo se busca</target>
        </trans-unit>
        <trans-unit id="9e2869673394c26d565412dbb368358875961728" translate="yes" xml:space="preserve">
          <source>The &lt;code&gt;~~&lt;/code&gt; operator compares its operands &quot;polymorphically&quot;, determining how to compare them according to their actual types (numeric, string, array, hash, etc.). Like the equality operators with which it shares the same precedence, &lt;code&gt;~~&lt;/code&gt; returns 1 for true and &lt;code&gt;&quot;&quot;&lt;/code&gt; for false. It is often best read aloud as &quot;in&quot;, &quot;inside of&quot;, or &quot;is contained in&quot;, because the left operand is often looked for</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="ef321bd7088ac81817f2231db61c1174692aaac0" translate="yes" xml:space="preserve">
          <source>The ADLER32 checksum field must be present.</source>
          <target state="translated">El campo de suma de control ADLER32 debe estar presente.</target>
        </trans-unit>
        <trans-unit id="9c4519701849f27da68be727b95e63207f2a9abf" translate="yes" xml:space="preserve">
          <source>The AIX tar does not fill all unused space in the tar archive with 0x00. This sometimes leads to warning messages from &lt;code&gt;Archive::Tar&lt;/code&gt; .</source>
          <target state="translated">El tar de AIX no llena todo el espacio no utilizado en el archivo tar con 0x00. Esto a veces conduce a mensajes de advertencia de &lt;code&gt;Archive::Tar&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="508b055d2e59a80ceed1c9bfc5a331ff6cb825bc" translate="yes" xml:space="preserve">
          <source>The AIX tar does not fill all unused space in the tar archive with 0x00. This sometimes leads to warning messages from &lt;code&gt;Archive::Tar&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b5549afa573e8454744ea43299cd8d8505147fcd" translate="yes" xml:space="preserve">
          <source>The ALIAS: Keyword</source>
          <target state="translated">El ALIAS:Palabra clave</target>
        </trans-unit>
        <trans-unit id="2ce9242faeeab07eef2f7afd701bea6933de8059" translate="yes" xml:space="preserve">
          <source>The ALIAS: keyword allows an XSUB to have two or more unique Perl names and to know which of those names was used when it was invoked. The Perl names may be fully-qualified with package names. Each alias is given an index. The compiler will setup a variable called &lt;code&gt;ix&lt;/code&gt; which contain the index of the alias which was used. When the XSUB is called with its declared name &lt;code&gt;ix&lt;/code&gt; will be 0.</source>
          <target state="translated">La palabra clave ALIAS: permite que un XSUB tenga dos o m&amp;aacute;s nombres de Perl &amp;uacute;nicos y sepa cu&amp;aacute;l de esos nombres se utiliz&amp;oacute; cuando se invoc&amp;oacute;. Los nombres de Perl pueden estar completamente calificados con los nombres de los paquetes. A cada alias se le asigna un &amp;iacute;ndice. El compilador configurar&amp;aacute; una variable llamada &lt;code&gt;ix&lt;/code&gt; que contiene el &amp;iacute;ndice del alias que se utiliz&amp;oacute;. Cuando se llama al XSUB con su nombre declarado, &lt;code&gt;ix&lt;/code&gt; ser&amp;aacute; 0.</target>
        </trans-unit>
        <trans-unit id="15fd0430aabb02304def7c36146cf671599d3942" translate="yes" xml:space="preserve">
          <source>The API</source>
          <target state="translated">El API</target>
        </trans-unit>
        <trans-unit id="9ed04c99d7b2c6a9ba47b9e4b73c73bb3ccc347c" translate="yes" xml:space="preserve">
          <source>The API was changed in the 2.0 branch. For a time, &lt;code&gt;mkpath&lt;/code&gt; and &lt;code&gt;rmtree&lt;/code&gt; tried, unsuccessfully, to deal with the two different calling mechanisms. This approach was considered a failure.</source>
          <target state="translated">La API se cambi&amp;oacute; en la rama 2.0. Durante un tiempo, &lt;code&gt;mkpath&lt;/code&gt; y &lt;code&gt;rmtree&lt;/code&gt; intentaron, sin &amp;eacute;xito, lidiar con los dos mecanismos de llamada diferentes. Este enfoque se consider&amp;oacute; un fracaso.</target>
        </trans-unit>
        <trans-unit id="009ead0f6ffd2c056d27d3bfda98818a54d2faea" translate="yes" xml:space="preserve">
          <source>The ASCII region (0x00-0x7f) is preserved for all encodings, even though this conflicts with mappings by the Unicode Consortium.</source>
          <target state="translated">La región ASCII (0x00-0x7f)se conserva para todas las codificaciones,aunque esto entra en conflicto con las cartografías del Consorcio Unicode.</target>
        </trans-unit>
        <trans-unit id="93fd64b40c593362e390e4e7060b0bced9f138ed" translate="yes" xml:space="preserve">
          <source>The ASCII-specific functions. Each of these is just the same as the version without the trailing &quot;A&quot;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="b3c4e287eeab5aae5482e7df8b6e409cada7c372" translate="yes" xml:space="preserve">
          <source>The ASCII/Latin-1/Unicode character with that number. A leading &quot;0x&quot; means that</source>
          <target state="translated">El carácter ASCII/Latin-1/Unicode con ese número.Un &quot;0x&quot; inicial significa que</target>
        </trans-unit>
        <trans-unit id="b76347c5c2c07c6a471b32d6864a1a7d9b8fb48a" translate="yes" xml:space="preserve">
          <source>The AUTOLOAD method, discussed in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;&quot;Autoloading&quot; in perlsub&lt;/a&gt; lets you capture calls to undefined functions and methods.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="e2afefe4f37ea14f731718bb07a4d6306f1639c5" translate="yes" xml:space="preserve">
          <source>The AUTOLOAD method, discussed in &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Autoloading in perlsub&lt;/a&gt; lets you capture calls to undefined functions and methods.</source>
          <target state="translated">El m&amp;eacute;todo AUTOLOAD, que se describe en &lt;a href=&quot;perlsub#Autoloading&quot;&gt;Carga autom&amp;aacute;tica en perlsub, le&lt;/a&gt; permite capturar llamadas a funciones y m&amp;eacute;todos no definidos.</target>
        </trans-unit>
        <trans-unit id="31231455a0cef5b5794db63f07a47d2f6efab12c" translate="yes" xml:space="preserve">
          <source>The ActiveState Pages, &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;</source>
          <target state="translated">Las p&amp;aacute;ginas de ActiveState, &lt;a href=&quot;http://www.activestate.com/&quot;&gt;http://www.activestate.com/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="334394ca32871dfe81ad4bfaf08e575776ff3a37" translate="yes" xml:space="preserve">
          <source>The ActiveState Pages, &lt;a href=&quot;https://www.activestate.com/&quot;&gt;https://www.activestate.com/&lt;/a&gt;</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fbbc6fc0e5dd1ef33879bfc672f5e3e8813e4f97" translate="yes" xml:space="preserve">
          <source>The Adventures of Tom Bombadil</source>
          <target state="translated">Las aventuras de Tom Bombadil</target>
        </trans-unit>
        <trans-unit id="e2e0a5aea5199e87efc4db9939033262cf1e73b8" translate="yes" xml:space="preserve">
          <source>The Alignment Pit</source>
          <target state="translated">El pozo de alineación</target>
        </trans-unit>
        <trans-unit id="68a751b9c456def01d238b0c06471f4927931bb2" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (ASCII or US-ASCII) is a set of integers running from 0 to 127 (decimal) that have standardized interpretations by the computers which use ASCII. For example, 65 means the letter &quot;A&quot;. The range 0..127 can be covered by setting the bits in a 7-bit binary digit, hence the set is sometimes referred to as &quot;7-bit ASCII&quot;. ASCII was described by the American National Standards Institute document ANSI X3.4-1986. It was also described by ISO 646:1991 (with localization for currency symbols). The full ASCII set is given in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt; as the first 128 elements. Languages that can be written adequately with the characters in ASCII include English, Hawaiian, Indonesian, Swahili and some Native American languages.</source>
          <target state="translated">El C&amp;oacute;digo Est&amp;aacute;ndar Americano para el Intercambio de Informaci&amp;oacute;n (ASCII o US-ASCII) es un conjunto de n&amp;uacute;meros enteros que van del 0 al 127 (decimal) que tienen interpretaciones estandarizadas por las computadoras que usan ASCII. Por ejemplo, 65 significa la letra &quot;A&quot;. El rango 0..127 puede cubrirse estableciendo los bits en un d&amp;iacute;gito binario de 7 bits, por lo que el conjunto a veces se denomina &quot;ASCII de 7 bits&quot;. ASCII fue descrito por el documento ANSI X3.4-1986 del American National Standards Institute. Tambi&amp;eacute;n fue descrito por ISO 646: 1991 (con localizaci&amp;oacute;n para s&amp;iacute;mbolos de moneda). El conjunto ASCII completo se muestra en la tabla &lt;a href=&quot;#recipe-3&quot;&gt;siguiente&lt;/a&gt; como los primeros 128 elementos. Los idiomas que se pueden escribir adecuadamente con los caracteres en ASCII incluyen ingl&amp;eacute;s, hawaiano, indonesio, swahili y algunos idiomas nativos americanos.</target>
        </trans-unit>
        <trans-unit id="4f30a3791e1ac69d9730db09043c7e01d216a23a" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (ASCII or US-ASCII) is a set of integers running from 0 to 127 (decimal) that have standardized interpretations by the computers which use ASCII. For example, 65 means the letter &quot;A&quot;. The range 0..127 can be covered by setting various bits in a 7-bit binary digit, hence the set is sometimes referred to as &quot;7-bit ASCII&quot;. ASCII was described by the American National Standards Institute document ANSI X3.4-1986. It was also described by ISO 646:1991 (with localization for currency symbols). The full ASCII set is given in the table &lt;a href=&quot;#recipe-3&quot;&gt;below&lt;/a&gt; as the first 128 elements. Languages that can be written adequately with the characters in ASCII include English, Hawaiian, Indonesian, Swahili and some Native American languages.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="f3ff218a8809c68d0eb083f2cf66b8207142d4f0" translate="yes" xml:space="preserve">
          <source>The American Standard Code for Information Interchange (a 7-bit character set adequate only for poorly representing English text). Often used loosely to describe the lowest 128 values of the various ISO-8859-X character sets, a bunch of mutually incompatible 8-bit codes best described as half ASCII. See also &lt;b&gt;Unicode&lt;/b&gt;.</source>
          <target state="translated">El C&amp;oacute;digo Est&amp;aacute;ndar Americano para el Intercambio de Informaci&amp;oacute;n (un juego de caracteres de 7 bits adecuado solo para texto en ingl&amp;eacute;s con una representaci&amp;oacute;n deficiente). A menudo se usa de manera vaga para describir los 128 valores m&amp;aacute;s bajos de los diversos conjuntos de caracteres ISO-8859-X, un grupo de c&amp;oacute;digos de 8 bits mutuamente incompatibles que se describen mejor como medio ASCII. Consulte tambi&amp;eacute;n &lt;b&gt;Unicode&lt;/b&gt; .</target>
        </trans-unit>
        <trans-unit id="0269ea9ab723afb75524e043608495b84069c96f" translate="yes" xml:space="preserve">
          <source>The Amiga::ARexx module allows you to easily create a perl based ARexx host or to send ARexx commands to other programs.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="1af5792ad21fdac265ea44a70d1cb66ca1977707" translate="yes" xml:space="preserve">
          <source>The Amiga::Exec module introduces support for Wait().</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="fd1c7da39d90054f5c4c81dc1a1fa13bcbbe82e7" translate="yes" xml:space="preserve">
          <source>The Anatomy of an XSUB</source>
          <target state="translated">La anatomía de un XSUB</target>
        </trans-unit>
        <trans-unit id="0746d95bfde5c5ba18bf27b5d1463ad01ffdafa1" translate="yes" xml:space="preserve">
          <source>The Argument Stack</source>
          <target state="translated">La pila de argumentos</target>
        </trans-unit>
        <trans-unit id="59f8369b68ee932dd97b5ec57202b3f3969c4a83" translate="yes" xml:space="preserve">
          <source>The Arrow Operator</source>
          <target state="translated">El operador de la flecha</target>
        </trans-unit>
        <trans-unit id="e40e5d487b331e1f7f4c2477322a84662ea1dcde" translate="yes" xml:space="preserve">
          <source>The Art of Computer Programming</source>
          <target state="translated">El arte de la programación informática</target>
        </trans-unit>
        <trans-unit id="e6a71a9e8ae70e8f61fd0c5d80d8189dbf3cf681" translate="yes" xml:space="preserve">
          <source>The AutoSplit and &lt;b&gt;AutoLoader&lt;/b&gt; modules automate the creation of forward declarations. The AutoSplit module creates an 'index' file containing forward declarations of all the AutoSplit subroutines. When the AutoLoader module is 'use'd it loads these declarations into its callers package.</source>
          <target state="translated">Los m&amp;oacute;dulos AutoSplit y &lt;b&gt;AutoLoader&lt;/b&gt; automatizan la creaci&amp;oacute;n de declaraciones &lt;b&gt;directas&lt;/b&gt; . El m&amp;oacute;dulo AutoSplit crea un archivo de '&amp;iacute;ndice' que contiene declaraciones hacia adelante de todas las subrutinas AutoSplit. Cuando se usa el m&amp;oacute;dulo Autocargador, carga estas declaraciones en su paquete de llamadas.</target>
        </trans-unit>
        <trans-unit id="547ca45f60093a7fb15745aaa1976d8399cc0918" translate="yes" xml:space="preserve">
          <source>The B-determined class of the OP, in all caps.</source>
          <target state="translated">La clase B-determinada de la OP,en todas las mayúsculas.</target>
        </trans-unit>
        <trans-unit id="fad9fed447a0e7963d894765232a4acc4b663de9" translate="yes" xml:space="preserve">
          <source>The B::Xref module is used to generate a cross reference listing of all definitions and uses of variables, subroutines and formats in a Perl program. It is implemented as a backend for the Perl compiler.</source>
          <target state="translated">El módulo B::Xref se utiliza para generar un listado de referencia cruzada de todas las definiciones y usos de las variables,subrutinas y formatos en un programa Perl.Se implementa como un backend para el compilador Perl.</target>
        </trans-unit>
        <trans-unit id="8026a52e63f99adbefc0e084618e1f479fd95572" translate="yes" xml:space="preserve">
          <source>The BITS mode (&quot;0&quot;) interprets the contents of</source>
          <target state="translated">El modo BITS (&quot;0&quot;)interpreta el contenido de</target>
        </trans-unit>
        <trans-unit id="ba88dd1d9005852348725927325ddcf383a69f7c" translate="yes" xml:space="preserve">
          <source>The BLOCK construct can be used to emulate case structures.</source>
          <target state="translated">La construcción del BLOQUE puede ser usada para emular las estructuras de las cajas.</target>
        </trans-unit>
        <trans-unit id="6dfef44d3b22aafe27912b6966e2a486d9c0c14d" translate="yes" xml:space="preserve">
          <source>The BOOT: Keyword</source>
          <target state="translated">La bota:Palabra clave</target>
        </trans-unit>
        <trans-unit id="d4a87a13d39a77a50a617134650c09dd8bdc8e3b" translate="yes" xml:space="preserve">
          <source>The BOOT: keyword is used to add code to the extension's bootstrap function. The bootstrap function is generated by the &lt;b&gt;xsubpp&lt;/b&gt; compiler and normally holds the statements necessary to register any XSUBs with Perl. With the BOOT: keyword the programmer can tell the compiler to add extra statements to the bootstrap function.</source>
          <target state="translated">La palabra clave BOOT: se usa para agregar c&amp;oacute;digo a la funci&amp;oacute;n bootstrap de la extensi&amp;oacute;n. La funci&amp;oacute;n de arranque es generada por el compilador &lt;b&gt;xsubpp&lt;/b&gt; y normalmente contiene las declaraciones necesarias para registrar cualquier XSUB con Perl. Con la palabra clave BOOT: el programador puede decirle al compilador que agregue declaraciones adicionales a la funci&amp;oacute;n de arranque.</target>
        </trans-unit>
        <trans-unit id="ad4a573da9545ff1a8eab5e0d4f5f08622036178" translate="yes" xml:space="preserve">
          <source>The BTREE file type optionally allows a single key to be associated with an arbitrary number of values. This option is enabled by setting the flags element of &lt;code&gt;$DB_BTREE&lt;/code&gt; to R_DUP when creating the database.</source>
          <target state="translated">El tipo de archivo BTREE permite, opcionalmente, asociar una sola clave con un n&amp;uacute;mero arbitrario de valores. Esta opci&amp;oacute;n se habilita configurando el elemento flags de &lt;code&gt;$DB_BTREE&lt;/code&gt; en R_DUP al crear la base de datos.</target>
        </trans-unit>
        <trans-unit id="4a8451f6eedb6a6056c8ac828a203a8cf8bdc79c" translate="yes" xml:space="preserve">
          <source>The BTREE interface has a feature which allows partial keys to be matched. This functionality is</source>
          <target state="translated">La interfaz BTREE tiene una característica que permite hacer coincidir las claves parciales.Esta funcionalidad es</target>
        </trans-unit>
        <trans-unit id="19350bba9c33f125fd021dceab5ff7633dce372c" translate="yes" xml:space="preserve">
          <source>The BUILD and INSTALL steps are identical to those for Unix. Some modules generate Makefiles that work better with GNU make, which is available from &lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;http://www.mks.com/s390/gnu/&lt;/a&gt;</source>
          <target state="translated">Los pasos de CONSTRUCCI&amp;Oacute;N e INSTALACI&amp;Oacute;N son id&amp;eacute;nticos a los de Unix. Algunos m&amp;oacute;dulos generan Makefiles que funcionan mejor con GNU make, que est&amp;aacute; disponible en &lt;a href=&quot;http://www.mks.com/s390/gnu/&quot;&gt;http://www.mks.com/s390/gnu/&lt;/a&gt;</target>
        </trans-unit>
        <trans-unit id="06987733f8223bbe1dde5201da803a816622002c" translate="yes" xml:space="preserve">
          <source>The Basic Principle</source>
          <target state="translated">El principio básico</target>
        </trans-unit>
        <trans-unit id="a093f7952b1838c4dd6aeda28ea5e1fc38030960" translate="yes" xml:space="preserve">
          <source>The Basics</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="afdc8705dda034aabf31fc65386bddfb61c3e95b" translate="yes" xml:space="preserve">
          <source>The Benchmark module encapsulates a number of routines to help you figure out how long it takes to execute some code.</source>
          <target state="translated">El módulo Benchmark encapsula una serie de rutinas para ayudar a calcular el tiempo que se tarda en ejecutar algún código.</target>
        </trans-unit>
        <trans-unit id="869885b765935f032e1e45165248683c4d860661" translate="yes" xml:space="preserve">
          <source>The Berkeley DB 4.1.25 has been tested with Tru64 V5.1A and found to work. The latest Berkeley DB can be found from &lt;a href=&quot;http://www.sleepycat.com&quot;&gt;http://www.sleepycat.com&lt;/a&gt;.</source>
          <target state="translated">El Berkeley DB 4.1.25 ha sido probado con Tru64 V5.1A y se ha comprobado que funciona. La &amp;uacute;ltima base de datos de Berkeley se puede encontrar en &lt;a href=&quot;http://www.sleepycat.com&quot;&gt;http://www.sleepycat.com&lt;/a&gt; .</target>
        </trans-unit>
        <trans-unit id="1425da38b0881b20e7239aedd72aa0c3d5db10c1" translate="yes" xml:space="preserve">
          <source>The Bessel function of the first kind of the order zero.</source>
          <target state="translated">La función de Bessel del primer tipo del orden cero.</target>
        </trans-unit>
        <trans-unit id="2488bfae0d46b9e4a8c30cc5e6937e82c99c48ea" translate="yes" xml:space="preserve">
          <source>The Bignum mailing list</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="95802efdaca31b27a14913bfe1089183b4ec8875" translate="yes" xml:space="preserve">
          <source>The C API for the backtrace is as follows:</source>
          <target state="translated">El API de C para el rastreo es el siguiente:</target>
        </trans-unit>
        <trans-unit id="89f382052ffa523340ba739809ce6ebbf65c53dd" translate="yes" xml:space="preserve">
          <source>The C array of a padlist, containing the pads. Only subscript it with numbers &amp;gt;= 1, as the 0th entry is not guaranteed to remain usable.</source>
          <target state="translated">La matriz C de una lista de pads, que contiene los pads. Solo sub&amp;iacute;ndice con n&amp;uacute;meros&amp;gt; = 1, ya que no se garantiza que la entrada 0 sea utilizable.</target>
        </trans-unit>
        <trans-unit id="9d9a695f29b97a18f6840062c9b13365fc424c17" translate="yes" xml:space="preserve">
          <source>The C array of pad entries.</source>
          <target state="translated">La serie C de entradas en el pad.</target>
        </trans-unit>
        <trans-unit id="82cdebaae9f3b94b2c40ce92be9ab7f40abcb4e4" translate="yes" xml:space="preserve">
          <source>The C array of pad names.</source>
          <target state="translated">La serie C de nombres de los blocs de notas.</target>
        </trans-unit>
        <trans-unit id="66ccfe4f23602b2282c83a4407f8d3eb55b4ce47" translate="yes" xml:space="preserve">
          <source>The C code asks for:</source>
          <target state="translated">El código C lo pide:</target>
        </trans-unit>
        <trans-unit id="1755acfd3f32daf3e3ba7fab9fbb3582e6e7bc1c" translate="yes" xml:space="preserve">
          <source>The C function required to call</source>
          <target state="translated">La función C necesaria para llamar a</target>
        </trans-unit>
        <trans-unit id="593e19336c2ea1e5b6f3c47a320c97c9b260fd7c" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;, wrapped if necessary, to ensure that it will return the length of the string written to the buffer. Only rare pre-ANSI systems need the wrapper function - usually this is a direct call to &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt;.</source>
          <target state="translated">El &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; de la biblioteca C, encapsulado si es necesario, para garantizar que devolver&amp;aacute; la longitud de la cadena escrita en el b&amp;uacute;fer. Solo los sistemas pre-ANSI raros necesitan la funci&amp;oacute;n de contenedor; generalmente, esta es una llamada directa a &lt;code&gt;&lt;a href=&quot;functions/sprintf&quot;&gt;sprintf&lt;/a&gt;&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="9f593f0f7e2f42e16decd49842d3eba832ba134e" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;snprintf&lt;/code&gt; functionality, if available and standards-compliant (uses &lt;code&gt;vsnprintf&lt;/code&gt; , actually). However, if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt; .</source>
          <target state="translated">La funcionalidad &lt;code&gt;snprintf&lt;/code&gt; de la biblioteca C , si est&amp;aacute; disponible y cumple con los est&amp;aacute;ndares (utiliza &lt;code&gt;vsnprintf&lt;/code&gt; , en realidad). Sin embargo, si el &lt;code&gt;vsnprintf&lt;/code&gt; no est&amp;aacute; disponible, desafortunadamente usar&amp;aacute; el &lt;code&gt;vsprintf&lt;/code&gt; inseguro que puede saturar el b&amp;uacute;fer (hay una verificaci&amp;oacute;n de saturaci&amp;oacute;n, pero eso puede ser demasiado tarde). Considere usar &lt;code&gt;sv_vcatpvf&lt;/code&gt; en su lugar u obtener &lt;code&gt;vsnprintf&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="a0e1b6d35f4716db28bfc47e17c382e52671433d" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;snprintf&lt;/code&gt; functionality, if available and standards-compliant (uses &lt;code&gt;vsnprintf&lt;/code&gt;, actually). However, if the &lt;code&gt;vsnprintf&lt;/code&gt; is not available, will unfortunately use the unsafe &lt;code&gt;vsprintf&lt;/code&gt; which can overrun the buffer (there is an overrun check, but that may be too late). Consider using &lt;code&gt;sv_vcatpvf&lt;/code&gt; instead, or getting &lt;code&gt;vsnprintf&lt;/code&gt;.</source>
          <target state="new"/>
        </trans-unit>
        <trans-unit id="661ddafc70911db04cf396a10417bb22f9c9013f" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcat&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt; -terminated strings.</source>
          <target state="translated">La biblioteca C &lt;code&gt;strlcat&lt;/code&gt; , si est&amp;aacute; disponible, o una implementaci&amp;oacute;n Perl de la misma. Esto opera en cadenas terminadas en C &lt;code&gt;NUL&lt;/code&gt; .</target>
        </trans-unit>
        <trans-unit id="15d5b3af47acfb54f6e568de8eff6bc75bdb63f0" translate="yes" xml:space="preserve">
          <source>The C library &lt;code&gt;strlcat&lt;/code&gt; if available, or a Perl implementation of it. This operates on C &lt;code&gt;NUL&lt;/code&gt;-terminated strings.</source>
          <target state="new"/>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>
